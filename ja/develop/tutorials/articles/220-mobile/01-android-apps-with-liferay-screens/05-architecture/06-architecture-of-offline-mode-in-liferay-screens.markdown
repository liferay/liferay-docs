---
header-id: architecture-of-offline-mode-in-liferay-screens
---

# Liferay画面のオフラインモードのアーキテクチャ

[TOC levels=1-4]

モバイルユーザーは、特定の場所や時間帯でネットワーク接続を取得または維持することが困難になる場合があります。 Screenletsでオフラインモードを使用すると、これらの状況でもアプリが機能します。 ただし、アプリをオフラインで使用する場合は、いくつかの問題が発生する可能性があることに注意してください。 たとえば、ユーザーがオフラインのときにアプリ内のデータを編集できるようにすると、再接続時にポータルと同期の競合が発生する場合があります。 Liferay Screensでのオフラインモードの実装方法を詳しく説明することにより、このチュートリアルでは、このような困難を認識し、それらを処理する方法を知ることができます。

## オフラインモードの基本を理解する

Liferay Screensのスクリーンレットは、次のフェーズをサポートしています。

1.  ポータルから情報を取得します。
2.  ユーザーに情報を表示します。
3.  ユーザーの入力を収集します（必要な場合）。
4.  ポータルに入力を送信します（必要な場合）。

次の図は、これらのフェーズをまとめたものです。

![図1：ポータルにデータを要求および送信するときのスクリーンレットの基本フェーズ。](../../../../images/screens-offline-01.png)

すべてのスクリーンレットが各フェーズを実行する必要があるわけではないことに注意してください。 たとえば、Webコンテンツ表示スクリーンレットは、ポータルコンテンツを取得して表示するだけで済みます。 逆に、ログインスクリーンレットとサインアップスクリーンレットは、ユーザー入力を処理するだけで済みます。 DDLフォームスクリーンレットやユーザーポートレートスクリーンレットなど、最も複雑なスクリーンレットのみが両方を実行する必要があります。

それで、これはすべてオフラインモードと何の関係があるのでしょうか？ Liferay Screensのオフラインインフラストラクチャは、ポータルとの間で送受信される情報を傍受する小さなコード層です。 インターネットに接続していないときに使用するために、この情報をローカルデータストアに保存します。 次の図はこれを示してい *ローカルキャッシュ* はローカルデータストアを表します。

![図2：これは以前と同じ図ですが、オフラインモードのローカルキャッシュが追加されています。](../../../../images/screens-offline-02.png)

オフラインモードを有効にすると、スクリーンレットはポータルと交換した情報を保持できます。 また、使用しているスクリーンレットでオフラインモードがどのように機能するかを正確に構成することもできます。 これは、 *ポリシー*ます。

## オフラインモードでのポリシーの使用

ポリシーは、スクリーンレットがデータを送受信するときのオフラインモードでの動作を構成します。 スクリーンレットは、データ操作が失敗した場合でもポリシーに従います。 スクリーンレットは次のポリシーをサポートしています。

**リモートのみ：** スクリーンレットはネットワーク接続のみを使用してデータをロードします。 オフラインモードが導入される前は、スクリーンレットはこのように機能していました。 スクリーンレットで常にリモートコンテンツを使用する場合は、このポリシーを使用します。 ただし、ネットワーク接続が利用できない場合、アプリは動作しません。 また、このポリシーを使用するアプリは、ネットワークの遅延のために遅くなる傾向があります。 要求が成功した場合、スクリーンレットは後で使用するためにデータをローカルキャッシュに保存することに注意してください。

**キャッシュのみ：** Screenletはローカルストレージのみを使用してデータをロードします（ネットワーク接続は使用しません）。 スクリーンレットで常にオフラインコンテンツを使用する場合は、このポリシーを使用します。 アプリのローカルキャッシュには、一部のポータルデータが存在しないか、古くなっている可能性があることに注意してください。

**remote-first：** スクリーンレットは最初にネットワーク接続を使用してデータをロードしようとします。 これが失敗すると、ローカルストレージからデータをロードしようとします。 接続があるときにScreenletに最新のポータルデータを使用させたいが、接続が切れたときにフォールバックメカニズムをサポートしたい場合に、このポリシーを使用します。 接続がない場合、スクリーンレットは古い情報を使用する場合があることに注意してください。 ただし、多くの場合、これはユーザーに情報をまったく表示しないよりも優れています。

**cache-first：** Screenletは最初にローカルストレージからデータをロードしようとします。 これが失敗した場合、ネットワーク接続を使用しようとします。 スクリーンレットでパフォーマンスとネットワーク効率を最適化する場合は、このポリシーを使用します。 バックグラウンドプロセスでデータを更新することも、ユーザーにオンデマンドで更新させることもできます（オプションなどを使用）。 ローカルストレージから取得した情報は古くなっている可能性がありますが、通常、読み込み時間と帯域幅の消費量は少なくなります。

これらのポリシーの動作は、データの方向によって少し異なります。 つまり、特定のポリシーに設定されたスクリーンレットがポータルから情報を取得するとき、ポータルに情報を送信するときとは動作が異なる場合があります。 例として、ユーザーポートレートスクリーンレットの考えられるシナリオを考えます。

  - ポートレートをロードする場合：

      - **リモートのみ：** スクリーンレットは常にポータルからポートレートをロードしようとします。 要求が失敗すると、操作も失敗します。

      - **キャッシュのみ**：スクリーンレットは常にローカルキャッシュからポートレートをロードしようとします。 ポートレートが存在しない場合、操作は失敗します。

      - **remote-first：** スクリーンレットは最初にポータルからポートレートをロードしようとします。 要求が成功すると、スクリーンレットは、後で使用するためにポートレートをローカルに保存します。 要求が失敗すると、スクリーンレットはローカルキャッシュからポートレートをロードしようとします。 ローカルキャッシュにポートレートが含まれていない場合、スクリーンレットはポートレートをロードできず、標準エラー処理コードを呼び出します（デリゲートを呼び出し、デフォルトのプレースホルダーを使用するなど）。

      - **cache-first：** スクリーンレットは最初にローカルキャッシュからポートレートをロードしようとします。 ポートレートがそこに存在しない場合、サーバーから要求されます。

  - ポートレートを送信する場合：

      - **リモートのみ：** スクリーンレットは最初に新しいポートレートをポータルに送信します。 送信が成功すると、スクリーンレットはポートレートもローカルキャッシュに保存します。 送信が失敗すると、操作も失敗します。

      - **キャッシュのみ**：スクリーンレットはポートレートのみをローカルに保存します。 ポートレートは、後でキャッシュからロードされるか、ポータルと同期されます。

      - **remote-first：** スクリーンレットは最初に新しいポートレートをポータルに送信しようとします。 ネットワーク接続の不足が原因でこれが失敗した場合、スクリーンレットは、後でポータルと同期するために、ポートレートをローカルキャッシュに保存します。

      - **cache-first：** スクリーンレットは最初に新しいポートレートをローカルに保存し、それをポータルに送信します。 送信が失敗した場合、スクリーンレットはポートレートをローカルに保存しますが、送信操作は失敗します。

## 同期について

同期は解決するのが難しい問題です。 最初は簡単に思えたものが、使用するデータのバージョンがわからないシナリオにすぐに発展します。 オフラインユーザーがいると事態はさらに複雑になります。 次の図は、スクリーンレットがポータルデータを取得および保存する方法を示しています。

![図3：スクリーンレットはポータルにリソースを要求し、アプリのローカルキャッシュに保存します。](../../../../images/screens-offline-03.png)

ユーザーがアプリでデータを編集するとき、スクリーンレットは新しいデータをポータルに送信する必要があります。 しかし、ユーザーがオフラインの場合はどうなりますか？ この場合、新しいデータはポータルに到達できず、ローカルデータとポータルデータは同期していません。 このシナリオでは、アプリには新しいデータがあり、ポータルには古いデータがあります。 この同期状態のアプリのデータは、 *ダーティバージョン*と呼ばれます。 石鹸と手ぬぐいを片付ける。 モバイルデバイスに入浴することはお勧めしません。 このコンテキストでは、ダーティとは、データをできるだけ早くポータルと同期することを意味します。 スクリーンレットがダーティバージョンを同期すると、ローカルデータからダーティフラグが削除されます。

![図4：Screenletがポータルに送信できない場合、更新されたデータはダーティであると言われます。](../../../../images/screens-offline-04.png)

![図5：ダーティフラグは、同期が完了すると削除されます。](../../../../images/screens-offline-05.png)

他にも複雑な同期状態があります。 たとえば、スクリーンレットのローカルデータと同期していないときにポータルデータが変更される場合があります。 データの損失を防ぐため、ローカルデータはポータルデータを上書きできません。逆も同様です。 この状況では、同期プロセスの実行時に競合が発生します。 次の図はこれを示しています。

![図6：ユーザーはアプリとポータルで個別にデータを変更したため、同期の競合が発生しました。](../../../../images/screens-offline-06.png)

開発者は、ローカルデータまたはポータルデータを選択して、競合を解決する必要があります。 同期の競合には、4つの解決策があります。

1.  **ローカルバージョンを保持：** ザ・Screenletは、ローカルデータとポータルのデータが上書きされます。 これにより、ローカルキャッシュとポータルのデータのバージョンが同じになります（上の図のバージョン2）。

2.  **リモートバージョンを保管してください：** ザ・Screenletがポータルデータをローカルデータを上書きします。 これにより、ローカルキャッシュとポータルのデータのバージョンが同じになります（上の図のバージョン3）。

3.  **破棄：** スクリーンレットはローカルデータを削除し、ポータルデータは上書きされません。

4.  **無視：** スクリーンレットはデータを変更しません。 次の同期イベントは競合を再現します。

すばらしいです\！ オフラインモードの仕組みがわかったので、オフラインモードを使用する準備が整いました。

## 関連トピック

[Androidでオフラインモードを使用する](/docs/7-1/tutorials/-/knowledge_base/t/using-offline-mode-in-android)

[iOSでオフラインモードを使用する](/docs/7-1/tutorials/-/knowledge_base/t/using-offline-mode-in-ios)

[Androidアプリでスクリーンレットを使用する](/docs/7-1/tutorials/-/knowledge_base/t/using-screenlets-in-android-apps)

[iOSアプリでのスクリーンレットの使用](/docs/7-1/tutorials/-/knowledge_base/t/using-screenlets-in-ios-apps)
