# Accessing Services Remotely [](id=accessing-services-remotely-liferay-portal-6-2-dev-guide-05-en)

You've created your portlet and built some terrific services. You're happy to
brag to your colleagues about the awesome things your portlet does. Now folks
are getting interested; they want to call your portlet's services. You wonder
whether this will be difficult and you start asking yourself questions. How can
I publish my services? How can my clients find my services? How can consumers
call my services efficiently? No worries. We'll answer all of these questions on
accessing remote services. 

Here are the topics we'll cover in this chapter:

- Finding Services 
- Invoking the API Remotely 
- Service Security Layers 
- SOAP Web Services 
- JSON Web Services 
- Skinny JSON Provider EE
- Authorizing Access to Services with OAuth

## Finding Services [](id=finding-services-liferay-portal-6-2-dev-guide-05-en)

You can find Liferay's services by searching for them in the Javadocs:
[http://docs.liferay.com/portal/6.2/javadocs/](http://docs.liferay.com/portal/6.2/javadocs/).
Below, we'll show you how to search for portal services and portlet services.

Let's start by finding a portal service. 

### Finding Portal Services [](id=finding-portal-services-liferay-portal-6-2-dev-guide-05-en)

Liferay's Javadocs are easy to browse and well-organized. Here's how to find the
*Organization* services: 

1. In your browser, open up the Javadocs:
   [http://docs.liferay.com/portal/6.2/javadocs/](http://docs.liferay.com/portal/6.2/javadocs/) 

2. Under *Portal Services*, click the link for the `com.liferay.portal.service`
   package, since the services for the Organization entity belong to the
   *Portal* scope. 

3. Find and click on the `-ServiceUtil` class (in this case,
   `OrganizationLocalServiceUtil`) in the *Class Summary* table or the
   *Classes* list at the bottom of the page. 

That was easy! What if you want to find portlet services? 

### Finding Portlet Services [](id=finding-portlet-services-liferay-portal-6-2-dev-guide-05-en)

Searching for one of Liferay's built-in portlet services is also easy. Instead
of clicking the link for the service package of the *portal*, click the link for
the service package of the *portlet*. The portlet service packages use the
naming convention `com.liferay.portlet.[portlet-name].service`, where
`[portlet-name]` is replaced with the actual name of the portlet. 

Here's how you find services for a user's blogs statistics:

1. In your browser, open the Javadocs:
   [http://docs.liferay.com/portal/6.2/javadocs/](http://docs.liferay.com/portal/6.2/javadocs/)

2. Under *Portlet Services*, click the link for the
   `com.liferay.portlet.blogs.service` package in the *Packages* frame, since
   the services are a part of the Blogs portlet. 

3. Find and click on the `-ServiceUtil` class (in this case
   `BlogsStatsUserLocalServiceUtil`) in the *Class Summary* table or the
   *Classes* list. 

Now you're ready to invoke Liferay services.

## Invoking the API Remotely [](id=invoking-the-api-remotely-liferay-portal-6-2-dev-guide-05-en)

*Remote* clients run outside of the portal JVM or on a remote machine but
Liferay's remote services allow the portal's API to be called from outside the
portal. Remote services can be invoked through non-Java languages like
JavaScript and PHP and remote services can reply to calls with JSON objects.
Note, however, that remote services are often harder to call than local services
since contextual information that's usually available when making local service
calls is not available when making remote service calls. For example, the
`ServiceContext` or `ThemeDisplay` objects are often available when you're
making local service calls but not when you're making remote service calls. 

Invoking remote services does require more overhead such as memory, network
bandwidth, and processing than does invoking local services. Also, remote
services require permission-checking to prevent just anyone from remotely
invoking them. The remote services of Liferay's API perform security checks but
these are not automatically generated by Service Builder; they're manually added
by developers. For information on adding permission checks to a plugin's remote
services, please refer to the previous chapter. If you'd like to *invoke* a
plugin's remote services, make sure to check that the remote service methods
perform permission checks. Unless you want to avoid permission checking, it's
often a good idea to develop your clients (even if they're local) so they
trigger the front-end security layer.

Liferay's API follows a Service Oriented Architecture
[(SOA)](http://en.wikipedia.org/wiki/Service-oriented_architecture). The API
supports Java invocation and a variety of protocols including SOAP and JSON over
HTTP. A limited set of *RESTful* web services, based on the AtomPub protocol,
are also supported--see the [Portal Atom Collections](http://www.liferay.com/community/wiki/-/wiki/Main/Portal+Atom+Collections)
wiki by Igor Spasi&#263; for more details. You can also use the API through
Remote Procedure Calls
([RPC](http://en.wikipedia.org/wiki/Remote_procedure_call)). You have many good
options for leveraging Liferay's API. 

Let's step back now and discuss the security layers of Liferay's *service
oriented* architecture and how you can configure them. 

## Service Security Layers [](id=service-security-layers-liferay-portal-6-2-dev-guide-05-en)

Liferay's remote services sit behind a layer of security that by default allows
only local connections. Access to the remote APIs must be enabled as a separate
step in order to call them from a remote machine. Liferay's core web services
require user authentication and authentication verification. We'll discuss this
process later in this section. Lastly, regardless of whether the remote service
is called from the same machine or via a web service, Liferay's standard
security model comes into action: a user must have the proper permissions in
Liferay's permissions system to access remote services. 

The first layer of security a client encounters when calling a remote service
is called *invoker IP filtering*. Imagine you have have a batch job that runs
on another machine in your network. This job polls a shared folder on your
network and uploads documents to your site's *Documents and Media* portlet on a
regular basis, using Liferay's web services. To get your batch job through the
IP filter, the portal administrator has to allow the machine on which the batch
job is running access to Liferay's remote service. For example, if your batch
job uses the SOAP web services to upload the documents, the portal administrator
must add the IP address of the machine on which the batch job is running to the
`axis.servlet.hosts.allowed` property. A typical entry might look like this:

    axis.servlet.hosts.allowed=192.168.100.100, 127.0.0.1, [SERVER_IP]

If the IP address of the machine on which the batch job is running is listed
as an authorized host for the service, it's allowed to connect to Liferay's web
services, pass in the appropriate user credentials, and upload the documents. 

---

 ![Note](../../images/tip-pen-paper.png) **Note:** The `portal.properties` file
 resides on the portal host machine and is controlled by the portal
 administrator. Portal administrators can configure security settings for the
 Axis Servlet, the Liferay Tunnel Servlet, the Spring Remoting Servlet, the JSON
 Servlet, the JSON Web Service Servlet, and the WebDAV Servlet. The
 `portal.properties` file (online version is available at
 [http://docs.liferay.com/portal/6.2/propertiesdoc/portal.properties.html](http://docs.liferay.com/portal/6.2/propertiesdoc/portal.properties.html))
 describes these properties. 

---

Next, if you're invoking the remote service via web services (e.g., JSON WS, old
JSON, Axis, REST, etc.), a two step process of authentication and authentication
verification is involved. Each call to a Liferay portal web services must be
accompanied by a user authentication token. It's up to the web service caller to
produce the token (e.g., through Liferay's utilities or through some third-party
software). Liferay verifies that there is a Liferay user that matches the token.
If the credentials are invalid, the web service invocation is aborted.
Otherwise, processing enters into Liferay's user permission layer. 

Liferay's user permission layer is the last Liferay security layer triggered
when services are invoked remotely, and it's used for every object in the
portal, whether accessing it locally or remotely. The user ID accessing the
services remotely must have the proper permission to operate on the objects it's
trying to access. A remote exception is thrown if the user ID isn't permitted.
A portal administrator can grant users access to these resources. For example,
suppose you created a Documents and Media Library folder called *Documents* in a
site, created a role called *Document Uploaders*, and granted this role the
rights to add documents to your new folder. If your batch job accesses Liferay's
web services to upload documents into the folder, you have to call the web
service using a user ID of a member of this role (or using the user ID of a user
with individual rights to add documents to this folder, such as a portal
administrator). If you don't, Liferay denies you access to the web service. 

With remote services, you can specify the user credentials using HTTP basic
authentication. Since those credentials are passed over the network unencrypted,
we recommend using HTTPS whenever accessing these services on an untrusted
network. Most HTTP clients let you specify the basic authentication credentials
in the URL--this is very handy for testing.

Use the following syntax to call the AXIS web service using credentials. Make
sure to remove the line escape character `\` when entering your URL:

    http://" + screenNameOrUserIdAsString + ":" + password + "@[server.com]:\
    [port]/api/axis/" + serviceName

The `screenNameOrUserIdAsString` should either be the user's screen name or the
user's ID from the Liferay database. The portal's authentication type setting
determines which one to use; we discuss this in more detail below. A user can
find his or her ID by logging in as the user and accessing *My Account* from the
Dockbar. On this interface, the user ID appears below the user's profile picture
and above the birthday field.

Let's pretend that your portal's authentication type is set to be by *user ID*
and that there's a user whose ID is `2` and whose password is `test`. You can
access Liferay's remote Organization service with the following URL: 

    http://2:test@localhost:8080/api/axis/Portal_OrganizationService

As mentioned above, the authentication type specified for your Liferay Portal
instance dictates the authentication type you'll use to access your web service.
The portal administrator can set the portal's authentication type to any of the
following: 

- *email address*
- *screen name*
- *user ID*

---

 ![Tip](../../images/tip-pen-paper.png) **Important:** In order for
 authentication to work for remote service calls, the portal authentication type
 must be set either to *screen name* or *user ID*. Authentication using the
 *email address* authentication type is not supported for remote service calls. 

---

You can set the authentication type via the Control Panel or via the
`portal-ext.properties` file. To set the portal authentication type via the
Control Panel, navigate to the Control Panel, click on *Portal Settings*, and
then on *Authentication*. Under *How do users authenticate?*, make a selection.
To set the portal authentication type via properties file, add the following
lines to your Liferay instance's `portal-ext.properties` file and uncomment the
line for the appropriate authentication type:

    #company.security.auth.type=emailAddress
    #company.security.auth.type=screenName
    #company.security.auth.type=userId

Your Liferay Portal password policies (see the [User
Management](https://www.liferay.com/documentation/liferay-portal/6.2/user-guide/-/ai/management-liferay-portal-6-2-user-guide-16-en)
chapter of *Using Liferay Portal 6.2*) should be reviewed, since they'll be
enforced on your administrative ID as well. If the portal is enforcing password
policies on its users (e.g., requiring them to change their passwords on a
periodic basis), an administrative ID accessing Liferay's web services in a
batch job will have its password expire too.

To prevent a password from expiring, a portal administrator can add a new
password policy that doesn't enforce password expiration and add a specific
administrative user ID to it. Then your batch job can run as many times as you
need it to, without your administrative ID's password expiring. 

To summarize, accessing Liferay remotely requires you to pass two layers of
security checks:

- *IP permission layer*: The IP address must be pre-configured in the server's
  portal properties. 
- *Authentication/verification layer (web services only)*: Liferay verifies that
  the caller's authorization token can be associated with a portal user.  
- *User permission layer*: The user needs permission to access the related
  resources. 

Next, let's talk about Liferay's SOAP web services. 

## SOAP Web Services [](id=soap-web-services-liferay-portal-6-2-dev-guide-05-en)

You can access Liferay's services via *Simple Object Access Protocol* (*SOAP*)
over HTTP. The *packaging* protocol is SOAP and the *transport* protocol is
HTTP. 

---

 ![Note](../../images/tip.png) **Note:** An authentication related token must
 accompany each Liferay web service invocation. For details, read the section on
 service security layers found earlier in this chapter. 

---

As an example, let's look at the SOAP web service classes for Liferay's
`Company`, `User`, and `UserGroup` portal services to execute the following:

1. List each user group to which user *test* belongs. 

2. Add a new user group named *MyGroup*. 

3. Add your portal's administrative user to the new user group. For
   demonstration purposes, we'll use an administrative user whose email address
   is `test@liferay.com`. 

We'll use these SOAP related classes: 

    import com.liferay.portal.model.CompanySoap;
    import com.liferay.portal.model.UserGroupSoap;
    import com.liferay.portal.service.http.CompanyServiceSoap;
    import com.liferay.portal.service.http.CompanyServiceSoapServiceLocator;
    import com.liferay.portal.service.http.UserGroupServiceSoap;
    import com.liferay.portal.service.http.UserGroupServiceSoapServiceLocator;
    import com.liferay.portal.service.http.UserServiceSoap;
    import com.liferay.portal.service.http.UserServiceSoapServiceLocator;

Can you see the naming convention for SOAP related classes? The classes above
all have suffixes `-ServiceSoapServiceLocator`, `-ServiceSoap`, and `-Soap`. The
`-ServiceSoapServiceLocator` class *finds* the `-ServiceSoap` by means of the
service's URL you provide. The `-ServiceSoap` class is the interface to the
services specified in the *Web Services Definition Language* (*WSDL*) file for
each service. The `-Soap` classes are the serializable implementations of the
models. Let's look at how to determine the URLs for these services. 

You can see a list of the services deployed on your portal by opening your
browser to the following URL: 

  `http://[host]:[port]/api/axis`

---

 ![Note](../../images/tip-pen-paper.png) **Note:** Prior to Liferay 6.2, there
 were two different URLs for accessing remote Liferay services.
 `http://[host]:[port]/api/secure/axis` was for services requiring
 authentication and `http://[host]:[port]/api/axis` was for services that didn't
 require authentication. As of Liferay 6.2, all remote Liferay services require
 authentication and the `http://[host]:[port]/api/axis` URL is used to access
 them.

---

Here's the list of *secure* web services for `UserGroup`: 

- `Portal_UserGroupService` (wsdl)
    - `addGroupUserGroups`
    - `addTeamUserGroups`
    - `addUserGroup`
    - `deleteUserGroup`
    - `getUserGroup`
    - `getUserUserGroups`
    - `unsetGroupUserGroups`
    - `unsetTeamUserGroups`
    - `updateUserGroup`

---

 ![Note](../../images/tip-pen-paper.png) **Note:** Liferay's developers use a
 tool called *Service Builder* to expose their services via SOAP automatically.
 If you're interested in using Service Builder, read [Generating Your Service
 Layer](http://www.liferay.com/documentation/liferay-portal/6.2/development/-/ai/generating-your-service-layer-liferay-portal-6-2-dev-guide-04-en). 

---

Each web service is listed with its name, operations, and a link to its WSDL
file. The WSDL file is written in XML and provides a model for describing and
locating the web service. 

Here's a WSDL excerpt of the `addUserGroup` operation of `UserGroup`: 

    <wsdl:operation name="addUserGroup" parametterOrder="name description
    publicLayoutSetPropertyId privateLayoutSetPropertyId">
        <wsdl:input message="impl:addUserGroupRequest" name="addUserGroupRequest"
        />
        <wsdl:outputMessage="impl:addUserGroupResponse" name="assUserGroupResponse"
        />
    </wsdl:operation>

To use the service, you pass in the WSDL URL along with your login credentials
to the SOAP service locator for your service. We'll show you an example in the
next section. 

Next, let's invoke the web service! 

### SOAP Java Client [](id=soap-java-client-liferay-portal-6-2-dev-guide-05-en)

You can easily set up a Java web service client to access Liferay's remote
services using Eclipse. Here's how: 

In Eclipse, you can use the *New* &rarr; *Web Service Client* wizard to
either create a new web service client project or add a client to an existing
project. You need to add a new web service client to your project for each
service that you need to consume in your client code. For our example, we'll
build a web service client to invoke the portal's `Company`, `User`, and
`UserGroup` services.

To create a new web service client project in Eclipse, click *File* &rarr;
*New* &rarr; *Other...*, then expand the *Web Services* category. Select *Web
Service Client*.

For each client you create, you're prompted to enter the service definition
(WSDL) for the desired service. Since our example web service client will use
Liferay Portal's `Company`, `User`, and `UserGroup` services, we'll need to
enter the following WSDLs: 

    http://localhost:8080/api/axis/Portal_CompanyService?wsdl

    http://localhost:8080/api/axis/Portal_UserService?wsdl

    http://localhost:8080/api/axis/Portal_UserGroupService?wsdl

![Figure 6.1: Service Definition](../../images/api-web-svc-wsdl.png)

When you specify a WSDL, Eclipse automatically adds the auxiliary files and
libraries required to consume that web service. Nifty! After you've created your
web service client project using one of the above WSDLs, you need to create
additional clients in the project using the remaining WSDLs. To create an
additional client in an existing project, right-click on the project and select
*New* &rarr; *Other* &rarr; *Web Service Client*. Click *Next*, enter the
WSDL, and complete the wizard.

The code below locates and invokes operations to create a new user group named
`MyUserGroup` and add a user with the screen name *test* to it. Create a
`LiferaySoapClient.java` file in your web service client project and add the
following code to it. If you create this class in a package other than the one
that's specified in the code below, replace the package with your package. To
run the client from Eclipse, make sure that your Liferay server is running,
right-click on the `LiferaySoapClient.java` class, and select *Run as Java
application*. Check your console to check that your service calls succeeded.

    package com.liferay.test;

    import java.net.URL;

    import com.liferay.portal.model.CompanySoap;
    import com.liferay.portal.model.UserGroupSoap;
    import com.liferay.portal.service.http.CompanyServiceSoap;
    import com.liferay.portal.service.http.CompanyServiceSoapServiceLocator;
    import com.liferay.portal.service.http.UserGroupServiceSoap;
    import com.liferay.portal.service.http.UserGroupServiceSoapServiceLocator;
    import com.liferay.portal.service.http.UserServiceSoap;
    import com.liferay.portal.service.http.UserServiceSoapServiceLocator;

    public class LiferaySoapClient {
            
        public static void main(String[] args) {

            try {
                String remoteUser = "test";
                String password = "test";
                String virtualHost = "localhost";

                String groupName = "MyUserGroup";

                String serviceCompanyName = "Portal_CompanyService";
                String serviceUserName = "Portal_UserService";
                String serviceUserGroupName = "Portal_UserGroupService";

                long userId = 0;

                // Locate the Company
                CompanyServiceSoapServiceLocator locatorCompany =
                    new CompanyServiceSoapServiceLocator();

                CompanyServiceSoap soapCompany =
                    locatorCompany.getPortal_CompanyService(
                        _getURL(remoteUser, password, serviceCompanyName,
                                true));

                CompanySoap companySoap =
                    soapCompany.getCompanyByVirtualHost(virtualHost);

                // Locate the User service
                UserServiceSoapServiceLocator locatorUser =
                    new UserServiceSoapServiceLocator();
                UserServiceSoap userSoap = locatorUser.getPortal_UserService(
                    _getURL(remoteUser, password, serviceUserName, true));

                // Get the ID of the remote user
                userId = userSoap.getUserIdByScreenName(
                    companySoap.getCompanyId(), remoteUser);
                System.out.println("userId for user named " + remoteUser +
                        " is " + userId);

                // Locate the UserGroup service
                UserGroupServiceSoapServiceLocator locator =
                    new UserGroupServiceSoapServiceLocator();
                UserGroupServiceSoap usergroupsoap =
                    locator.getPortal_UserGroupService(
                        _getURL(remoteUser, password, serviceUserGroupName,
                                true));

                // Get the user's user groups
                UserGroupSoap[] usergroups = usergroupsoap.getUserUserGroups(
                        userId);

                System.out.println("User groups for userId " + userId + " ...");
                for (int i = 0; i < usergroups.length; i++) {
                    System.out.println("\t" + usergroups[i].getName());
                }

                // Adds the user group if it does not already exist
                String groupDesc = "My new user group";
                UserGroupSoap newUserGroup = null;

                boolean userGroupAlreadyExists = false;
                try {
                    newUserGroup = usergroupsoap.getUserGroup(groupName);
                    if (newUserGroup != null) {
                        System.out.println("User with userId " + userId +
                                " is already a member of UserGroup " +
                                        newUserGroup.getName());
                        userGroupAlreadyExists = true;
                    }
                } catch (Exception e) {
                    // Print cause, but continue
                    System.out.println(e.getLocalizedMessage());
                }

                if (!userGroupAlreadyExists) {
                    newUserGroup = usergroupsoap.addUserGroup(
                            groupName, groupDesc);
                    System.out.println("Added user group named " + groupName);

                    long users[] = {userId};
                    userSoap.addUserGroupUsers(newUserGroup.getUserGroupId(),
                            users);
                }

                // Get the user's user groups
                usergroups = usergroupsoap.getUserUserGroups(userId);

                System.out.println("User groups for userId " + userId + " ...");
                for (int i = 0; i < usergroups.length; i++) {
                    System.out.println("\t" + usergroups[i].getName());
                }
            }
            catch (Exception e) {
                e.getLocalizedMessage();
            }
        }

            private static URL _getURL(String remoteUser, String password,
                            String serviceName, boolean authenticate)
                            throws Exception {
                    
                    // Unauthenticated url
                    String url = "http://localhost:8080/api/axis/" + serviceName;

                    // Authenticated url
                    if (authenticate) {
                            url = "http://" + remoteUser + ":" + password
                                            + "@localhost:8080/api/axis/"
                                            + serviceName;
                    }
                    
                    return new URL(url);
            }
        
    }

Running this client should produce output like the following example: 

    userId for user named test is 10196
    User groups for user 10196 ...
    java.rmi.RemoteException: No UserGroup exists with the key {companyId=10154,
    name=MyUserGroup}
    Added user group named
    Added user to user group named MyUserGroup
    User groups for user 10196 ...
        MyUserGroup

The output tells us the user had no groups, but was added to UserGroup
`MyUserGroup`.

You might be thinking, "But an error was thrown! We did something wrong!" Yes,
an error was thrown (`java.rmi.RemoteException:`), but we're sitting here as
cool as an ice cream sandwich all the same. The exception was thrown simply
because the `UserGroup` check was invoked before the `UserGroup` was created.
Because the very next line of the output says `Added user group named...`, we're
okay. Don't worry, be happy! 

Here are a few things to note about this example: 

- Authentication is done using HTTP Basic Authentication, which isn't
  appropriate for a production environment, since the password is unencrypted.
  It's simply used for convenience in this example. In production, you should
  set `company.security.auth.requires.https=false`. Please refer to Liferay's
  [`portal.properties`](http://docs.liferay.com/portal/6.2/propertiesdoc/portal.properties.html)
  file for more information.
- The screen name and password are passed in the URL as credentials. 
- The name of the service (e.g. `Portal_UserGroupService`) is specified at the
  end of the URL. Remember that the service name can be found in the web service
  listing. 

The operations `getCompanyByVirtualHost()`, `getUserIdByScreenName()`,
`getUserUserGroups()`, `addUserGroup()` and `addUserGroupUsers()` are specified
for the `-ServiceSOAP` classes `CompanyServiceSoap`, `UserServiceSoap` and
`UserGroupServiceSoap` in the WSDL files. Information on parameter types,
parameter order, request type, response type, and return type are conveniently
specified in the WSDL for each Liferay web service. It's all there for you!

Next, let's implement a web service client in PHP. 

### SOAP PHP Client [](id=soap-php-client-liferay-portal-6-2-dev-guide-05-en)

You can write your client in any language that supports web services invocation.
Let's invoke the same operations we did when we created our Java client, this
time using PHP and a PHP SOAP Client: 

    <?php
        $userGroupName = "MyUserGroup2";
        $userName = "test";
        $clientOptions = array('login' => $userName, 'password' => 'test');

        // Add user group
        $userGroupClient = new 
            SoapClient(
                "http://localhost:8080/api/axis/Portal_UserGroupService?wsdl", 
                $clientOptions);
        $userGroup = $userGroupClient->addUserGroup($userGroupName,
            "This user group was created by the PHP client! ");
        print ("User group ID is $userGroup->userGroupId ");

        // Add user to user group
        $companyClient = new SoapClient(
            "http://localhost:8080/api/axis/Portal_CompanyService?wsdl",
            $clientOptions);
        $company = $companyClient->getCompanyByVirtualHost("localhost");
        $userClient = new SoapClient(
            "http://localhost:8080/api/axis/Portal_UserService?wsdl",
            $clientOptions);
        $userId = $userClient->getUserIdByScreenName($company->companyId,
            $userName);
        print ("User ID for $userName is $userId ");
        $users = array($userId);
        $userClient->addUserGroupUsers($userGroup->userGroupId, $users);

        // Print the user groups to which the user belongs
        $userGroups = $userGroupClient->getUserUserGroups($userId);
        print ("User groups for user $userId ... ");
        foreach($userGroups as $ug)
            print ("$ug->name, $ug->userGroupId ")
    ?>

Remember, you can implement a web service client in any language that supports
using SOAP web services. Next, we'll explore Liferay's JSON web services. 

## JSON Web Services [](id=json-web-services-liferay-portal-6-2-dev-guide-05-en)

JSON web services let you access portal service methods by exposing them as a
JSON HTTP API. Service methods are made easily accessible using HTTP requests,
both from JavaScript within the portal and from any JSON-speaking client. 

We'll cover the following topics as we explore JSON Web Service functionality:

- Registration
- Configuration
- Invocation 
- Results

Let's start by discussing how to register JSON web services. 

### Registering JSON Web Services [](id=registering-json-web-services-liferay-portal-6-2-dev-guide-05-en)

Liferay's developers use a tool called *Service Builder* to build services. When
you build services with Service Builder, all remote-enabled services (i.e.,
`service.xml` entities with the property `remote-service="true"`) are exposed as
JSON web services. When each `-Service.java` interface is created for a
remote-enabled service, the `@JSONWebService` annotation is added on the class
level of that interface. All of the public methods of that interface become
registered and available as JSON web services. 

The `-Service.java` interface source file should never be modified by the user.
If you need, however, more control over its methods (e.g., hiding some methods
and exposing others), you can configure the `-ServiceImpl` class. When the
service implementation class (`-ServiceImpl`) is annotated with the
`@JSONWebService` annotation, the service interface is ignored and the service
implementation class is used for configuration in its place. In other words,
`@JSONWebService` annotations in the service implementation override any JSON
Web Service configuration in service interface.

That's it! When you start Liferay Portal, it scans service classes for
annotations (more about scanning later). Each class that uses the
`@JSONWebService` annotation is examined and its methods become exposed as JSON
API. As explained previously, the `-ServiceImpl` configuration overrides the
`-Service` interface configuration during registration.

Liferay Portal, however, does not scan all available classes for the
annotations. Instead, it only scans services. More precisely, it scans all
classes, including plugin classes, registered in the portal's application
context. All classes that are available to the `BeanLocator` are scanned.
Practically, this means that the portal scans all classes registered in its
Spring context and the Spring context of its plugins. If you use Service Builder
to build plugin services, the services are automatically registered to the
Spring context and are made available to the `BeanLocator`. Moreover, this means
that you can register *any* object in the Spring context of your plugin and the
portal scans it for remote services! We are not forcing you to use Service
Builder. We recommend using it because it easily does so many things with
regards to your remote services. 

---

 ![Note](../../images/tip-pen-paper.png) **Note:** Liferay's developers use 
 *Service Builder* to expose their services via JSON automatically.
 If you're interested in using Service Builder, read [Generating Your Service
 Layer](http://www.liferay.com/documentation/liferay-portal/6.2/development/-/ai/generating-your-service-layer-liferay-portal-6-2-dev-guide-04-en). 

---

OK, now let's see how you can create a plugin with some remote services. Keep in
mind that Liferay developers use the very same mechanism so that Liferay
Portal's services come enabled out-of-the-box. 

#### Registering Plugin JSON Web Services [](id=registering-plugin-json-web-services-liferay-portal-6-2-dev-guide-05-en)

Let's say you have a portlet named `SupraSurf` that has some services. And you
decide to expose them as remote services. After enabling the `remote-service`
attribute on its `SurfBoard` entity, you rebuild the services. Service Builder
regenerates the `SurfBoardService` interface, adding the `@JSONWebService`
annotation to it. This annotation tells the portal that the interface's public
methods are to be exposed as JSON web services, making them a part of the
plugin's JSON API. 

By default, scanning of the portlet's services is disabled. To enable scanning,
you need to add an appropriate filter definition in the portlet's `web.xml`
file. Fortunately, Liferay provides a way to automatically add the filter. Just
click the *Build WSDD* button in Liferay IDE while editing the `service.xml`
file in *Overview* mode, or just invoke the `build-wsdd` Ant target. On building
the WSDD, Liferay's Plugins SDK modifies the portlet's `web.xml` and enables the
JSON web services for the plugin. Under the hood, the Plugins SDK registers the
`SecureFilter` and the `JSONWebServiceServlet` for the plugin. You only need to
enable JSON web services for your plugin once.

Let's deploy the `SupraSurf` portlet plugin on our portal server. If your server
isn't running, start it up. Then deploy your plugin onto it. 

To get some feedback from the portal on registering your plugin's services,
configure the portal to log the plugin's informational messages (i.e., its `INFO
...` messages). See the section on Liferay's logging system in
[Using Liferay Portal](https://www.liferay.com/documentation/liferay-portal/6.2/user-guide/-/ai/liferays-logging-system-liferay-portal-6-2-user-guide-18-en).

Let's add a simple method to the plugin's services. Edit the
`SurfBoardServiceImpl` class and add the following method:

    public String helloWorld(String worldName) {
        return "Hello world: " + worldName;
    }

Rebuild the services and deploy the plugin. Notice that the portal prints a
message like the one below informing us that an action was configured for the
portlet. This indicates that the service method is now registered as a JSON Web
Web Service action!

	INFO  [JSONWebServiceActionsManagerImpl:117] Configured 1 actions for\
	    /suprasurf-portlet

This same mechanism registers Liferay Portal's own service actions. They are
conveniently enabled by default, so you don't have to configure them. 

Next, let's learn how to form a mapped URL for the remote service so we can
access it. 

#### Mapping and Naming Conventions [](id=mapping-and-naming-conventions-liferay-portal-6-2-dev-guide-05-en)

You can form the mapped URL of an exposed service by following the naming
convention below: 

    http://[server]:[port]/api/jsonws/[plugin-context-name.][service-class-name]/[service-method-name]

Let's look at the last three bracketed items more closely: 

- `plugin-context-name` is the plugin's context name (e.g., `suprasurf-portlet`
  in our example). For the portal's services, this part is not needed. 
- `service-class-name` is generated from the service's class name in lower case,
  minus its `Service` or `ServiceImpl` suffix. For example, specify `surfboard`
  as the `plugin-context-name` for the `SurfBoardService` class. 
- `service-method-name` is generated from the service's method name by
  converting its camel case to lower case and using dashes (`-`) to separate
  words. 

We'll demonstrate these naming conventions by mapping a service method's URL
using the naming conventions both on a created plugin service and on a portal
service.

For our created service method, the URL looks like:

	http://localhost:8080/api/jsonws/suprasurf-portlet.surfboard/hello-world

Note the context name part of the URL. For the portal, it's similar. Here's a
portal service method we want to access: 

        @JSONWebService
        public interface UserService {
            public com.liferay.portal.model.User getUserById(long userId) {...}

Here's is that portal service method's URL: 

        http://localhost:8080/api/jsonws/user-service/get-user-by-id

Each service method is bound to one HTTP method type. Any method with a name
starting with `get`, `is`, or `has` is assumed to be a read-only method and is
mapped as a *GET HTTP* method by default. All other methods are mapped as *POST
HTTP* methods. 

As you may have noticed, plugin services are accessed via the portal context.
Conveniently, requests sent this way can leverage the user's authentication in
his current portal session.

Next, we'll learn to how to *list* JSON web services available from our portal. 

#### Listing Available JSON Web Services [](id=listing-available-json-web-services-liferay-portal-6-2-dev-guide-05-en)

To see which service methods are registered and available for use, open your
browser to the following address: 

    http://localhost:8080/api/jsonws

The API page lists the portal's registered and exposed service methods. To get
each method's details, click on the method name. You'll see the full signature
of the method, all of its arguments, and a list of exceptions that can be
thrown. For additional information about remote service methods, you can look up
the method in Liferay Portal's
[Javadocs](http://docs.liferay.com/portal/6.2/javadocs). Using a simple form
from within your browser, you can even invoke the service method for testing
purposes.

The same API page lists remote services of plugins, too. When multiple plugins
with remote services enabled are deployed, the API page shows a select box with
all available plugin context paths (including the portal's path). The select box
facilitates switching between the plugins' list of remote services and the
portal's list of remote services.

If you've been paying attention, you already know how to control registration by
using the `@JSONWebService` annotation in your `-ServiceImpl` class. This
overrides any configuration defined in the interface. What you might not know is
that you can control the visibility of methods using annotations at the method
level. 

Let's find out how to ignore a specific method. 

#### Ignoring a Method [](id=ignoring-a-method-from-json-webservices-liferay-portal-6-2-dev-guide-en)

To keep a method from being exposed as a service, annotate the method with the
following option:

    @JSONWebService(mode = JSONWebServiceMode.IGNORE)

Methods with this annotation don't become part of the JSON Web Service API. 

Let's learn to define custom HTTP method names and URL names. 

#### HTTP Method Name and URL [](id=http-method-name-and-url-json-liferay-portal-6-2-dev-guide-05-en)

At the method level, you can define custom HTTP method names and URL names. Just
use an annotation like this one: 

    @JSONWebService(value = "add-board-wow", method = "PUT")
    public boolean addBoard(

In this example, the plugin's service method `addBoard` is mapped to URL
method name `add-board-wow`. Its complete URL is now
`http://localhost:8080/api/jsonws/suprasurf-portlet.surfboard/add-board-wow` and
can be accessed using the HTTP PUT method. 

If the URL name starts with a slash character (`/`), only the method name is
used to form the service URL; the class name is ignored.

    @JSONWebService("/add-something-very-specific")
    public boolean addBoard(

Similarly, you can change the class name part of the URL, by setting the value
in class-level annotation:

    @JSONWebService("sbs")
    public class SurfBoardServiceImpl extends SurfBoardServiceBaseImpl {

This maps all of the service's methods to a URL class name `sbs` instead
of the default class name `surfboard`. 

Next, we'll show you a different approach to exposing your methods as we discuss
manual registration. 

#### Manual Registration Mode [](id=json-manual-registration-mode-liferay-portal-6-2-dev-guide-05-en)

Up to now, it is assumed that you want to expose most of your service methods,
while hiding some specific methods (the *blacklist* approach).
Sometimes, however, you want the opposite: to explicitly specify only those
methods that are to be exposed (the *whitelist* approach). This is possible,
too, by specifying *manual mode* on the class-level annotation. Then it is up to
you annotate only those methods that you want exposed.

    @JSONWebService(mode = JSONWebServiceMode.MANUAL)
    public class SurfBoardServiceImpl extends SurfBoardServiceBaseImpl{
        ...
        @JSONWebService
        public boolean addBoard(

Now only the `addBoard` method and any other method annotated with
`@JSONWebService` will be part of the JSON Web Service API; all other methods
of this service will be excluded from the API.

Next, let's look at portal configuration options that apply to JSON Web
Services. 

### Portal Configuration of JSON Web Services [](id=portal-configuration-of-json-web-service-liferay-portal-6-2-dev-guide-05-en)

JSON web services are enabled on Liferay Portal by default. If you need to
disable them, specify this portal property setting: 

    json.web.service.enabled=false

Now let's look at strict HTTP methods. 

#### Strict HTTP Methods [](id=json-strict-http-methods-liferay-portal-6-2-dev-guide-05-en)

All JSON web services are mapped to either GET or POST HTTP methods. If a
service method name starts with `get`, `is` or `has`, the service is assumed to
be read-only and is bound to the GET method; otherwise it's bound to POST. 

By default, Liferay Portal doesn't check HTTP methods when invoking a service
call; it works in *non-strict http method* mode, where services may be invoked
using any HTTP method. If you need the strict mode, you can set it with this
portal property: 

    jsonws.web.service.strict.http.method=true

When using strict mode, you must use the correct HTTP methods in calling service
methods. 

When strict HTTP mode is enabled, you still might have need to disable HTTP
methods. We'll show you how next. 

#### Disabling HTTP Methods [](id=disabling-http-methods-in-json-liferay-portal-6-2-dev-guide-05-en)

When strict HTTP method mode is enabled, you can filter web service access based
on HTTP methods used by the services. For example, you can set the portal JSON
web services to work in read-only mode by disabling HTTP methods other than GET.
For example: 

    jsonws.web.service.invalid.http.methods=DELETE,POST,PUT

Now all requests that use HTTP methods from the list above are ignored. Read on
to find out how to invoke JSON web services. 

### Invoking JSON Web Services [](id=invoking-json-web-services-liferay-portal-6-2-dev-guide-05-en)

How you invoke a JSON web service depends on how you pass in its parameters.
We'll discuss how to pass in parameters below, but first you need to understand
how your invocation is matched to a method, especially when a service method is
overloaded. 

The general rule is that you provide the method name and *all* parameters for
that service method--even if you only provide `null`. 

It's important to provide all parameters, but it doesn't matter *how* you do it
(e.g., as part of the URL line, as request parameters, etc.). The order of the
parameters doesn't matter either. 

---

 ![Note](../../images/tip.png) **Note:** An authentication related token must
 accompany each Liferay web service invocation. For details, read the section on
 service security layers found earlier in this chapter. 

---

Exceptions abound in life, and there's an exception to the rule that *all*
parameters are required--when using numeric *hints* to match methods. Let's look
at using hints next. 

#### Using Hints [](id=using-hints-in-json-liferay-portal-6-2-dev-guide-05-en)

Adding numeric hints lets you specify how many method arguments a service has.
If you don't specify an argument for a parameter, it's automatically
passed in as `null`. Syntactically, you can add hints as numbers separated by a
dot in the method name. Here's an example: 

    /foo/get-bar.2/param1/123/-param2

Here, the `.2` is a numeric hint specifying that only service methods with two
arguments will be matched; others will be ignored for matching. 

There's an important distinction to make between matching using hints and
matching without hints. When a hint is specified, you don't have to specify all
of the parameters. Any missing arguments are treated as `null`. The previous
example may be called like this:

    /foo/get-bar.2/param1/123

In this example, `param2` will automatically be set to `null`. 

Find out how to pass parameters as part of the URL path next. 

#### Passing Parameters as Part of a URL Path [](id=passing-parameters-as-part-of-a-url-path-liferay-portal-6-2-dev-guide-en)

You can pass parameters as part of the URL path. After the service URL, just
specify method parameters in name-value pairs. Parameter names must be formed
from method argument names by converting them from camelCase to names using all
lower case and separated-by-dash. Here's an example of calling one of the
portal's services: 

    http://localhost:8080/api/jsonws/dlapp/get-file-entries/repository-id/\
    10172/folder-id/0

Note, we've inserted line escape character `\` in order to fit the example URL
on this page. 

You can pass parameters in any order; it's not necessary to follow the order in
which the arguments specified in the method signatures. 

When a method name is overloaded, the *best match* will be used. It chooses the
method that contains the least number of undefined arguments and invokes it for
you. 

You can also pass parameters in a URL query, and we'll show you how next. 

#### Passing Parameters as a URL Query [](id=passing-parameters-as-a-url-query-json-liferay-portal-6-2-dev-guide-en)

You can pass in parameters as request parameters. Parameter names are specified
as is (e.g. camelCase) and are set equal to their argument values, like this: 

    http://localhost:8080/api/jsonws/dlapp/get-file-entries?repositoryId=\
    10172&folderId=0

Note, we've inserted line escape character `\` in order to fit the example URL
on this page.

As with passing parameters as part of a URL path, the parameter order is not
important, and the *best match* rule applies for overloaded methods. 

Now you know a few different ways to pass parameters. It's also possible to pass
URL parameters in a mixed way. Some can be part of the URL path and some can be
specified as request parameters.

Parameter values are sent as strings using the HTTP protocol. Before a matching
Java service method is invoked, each parameter value is converted from a
`String` to its target Java type. Liferay uses a third party open source library
to convert each object to its appropriate common type. It's possible to add or
change the conversion for certain types but we'll just cover the standard
conversions process. 

Conversion for common types (e.g., `long`, `String`, `boolean`) is
straightforward. Dates can be given in milliseconds; locales can be passed as
locale names (e.g. `en` and `en_US`). To pass in an array of numbers, send a
`String` of comma-separated numbers (e.g. `String` `4,8,15,16,23,42` can be
converted to `long[]` type). You get the picture!

In addition to the common types, arguments can be of type `List` or `Map`. To
pass a `List` argument, send a JSON array. To pass a `Map` argument, send a JSON
object. The conversion of these is done in two steps, ingeniously referred to
below as *Step 1* and *Step 2*:

- *Step 1--JSON deserialization*: JSON arrays are converted into `List<String>`
  and JSON objects are converted to `Map<String, String>`. For security reasons,
  it is forbidden to instantiate any type within JSON deserialization. 
- *Step 2--Generification*: Each `String` element of the `List` and `Map` is
  converted to its target type (the argument's generic Java type specified in
  the method signature). This step is only executed if the Java argument type
  uses generics. 

As an example, let's consider the conversion of `String` array `[en,fr]` as JSON
web service parameters for a `List<Locale>` Java method argument type: 

- *Step 1--JSON deserialization*: The JSON array is deserialized to a
  `List<String>` containing `String`s `en` and `fr`. 

- *Step 2--Generification*: Each `String` is converted to the `Locale` (the
  generic type), resulting in the `List<Locale>` Java argument type. 

Now let's see how to specify an argument as `null`. 

#### Sending NULL Values [](id=json-sending-null-values-liferay-portal-6-2-dev-guide-05-en)

To pass a `null` value for an argument, prefix the parameter name with a dash.
Here's an example: 

    .../dlsync/get-d-l-sync-update/company-id/10151/repository-id/10195/-last-access-date

The `last-access-date` parameter is interpreted as `null`. Although we have it
last in the URL above, it's not necessary.

Null parameters don't have specified values. When a null parameter is passed as
a request parameter, its value is ignored and `null` is used instead: 

    <input type="hidden" name="-last-access-date" value=""/>

When using JSON RPC (see below), you can send null values explicitly, even
without a prefix. Here's an example: 

    "last-access-date":null

Now let's learn about encoding parameters. 

#### Encoding Parameters [](id=encoding-parameters-in-json-liferay-portal-6-2-dev-guide-05-en)

There's a difference between URL encoding and query (i.e. request parameters)
encoding. The difference lies in how the space character is encoded. When the
space character is part of the URL path, it's encoded as `%20`; when it's part
of the query it's encoded as a plus sign (`+`).

All these encoding rules apply to ASCII and international (non-ASCII)
characters. Since Liferay Portal works in UTF-8 mode, parameter values must be
encoded as UTF-8 values. Liferay Portal doesn't decode request URLs and request
parameter values to UTF-8 itself; it relies on the web server layer. When
accessing services through JSON-RPC, encoding parameters to UTF-8 isn't
enough--you need to send the encoding type in a Content-Type header (e.g.
`Content-Type : "text/plain; charset=utf-8"`). 

For example, let's pass the value "&#1057;&#1091;&#1087;&#1077;&#1088;" ("Super"
in Cyrillic) to some JSON Web Service method. This name first has to be
converted to UTF-8 (resulting in array of 10 bytes) and then encoded for URLs or
request parameters. The resulting value is the string
`%D0%A1%D1%83%D0%BF%D0%B5%D1%80` that can be passed to our service method. When
received, this value is first going to be translated to an array of 10 bytes
(URL decoded) and then converted to a UTF-8 string of the 5 original characters.

Did you know you can send files as arguments? Find out how next. 

#### Sending Files as Arguments [](id=sending-files-as-arguments-in-json-liferay-portal-6-2-dev-guide-05-en)

Files can be uploaded using multipart forms and requests. Here's an example: 

    <form
     action="http://localhost:8080/api/jsonws/dlapp/add-file-entry"
     method="POST"
     enctype="multipart/form-data">
        <input type="hidden" name="repositoryId" value="10172"/>
        <input type="hidden" name="folderId" value="0"/>
        <input type="hidden" name="title" value="test.jpg"/>
        <input type="hidden" name="description" value="File upload example"/>
        <input type="hidden" name="changeLog" value="v1"/>
        <input type="file" name="file"/>
        <input type="submit" value="addFileEntry(file)"/>
    </form>

This is a common upload form that invokes the `addFileEntry` method of the
`DLAppService` class. 

Now we'll show you how to invoke JSON web services using JSON RPC. 

#### JSON RPC [](id=json-rpc-liferay-portal-6-2-dev-guide-05-en)

You can invoke JSON Web Service using [JSON RPC](http://json-rpc.org). Most of
the JSON RPC 2.0 specification is supported in Liferay JSON web services. One
important limitation is that parameters must be passed in as *named* parameters.
Positional parameters are not supported, as there are too many overloaded
methods for convenient use of positional parameters. 

Here's an example of invoking a JSON web service using JSON RPC: 

    POST http://localhost:8080/api/jsonws/dlapp
    {
        "method":"get-folders",
        "params":{"repositoryId":10172, "parentFolderId":0},
        "id":123,
        "jsonrpc":"2.0"
    }

Let's talk about parameters that are made available to secure JSON web
services by default. 

#### Default Parameters [](id=default-json-web-service-parameters-liferay-portal-6-2-dev-guide-en)

When accessing *secure* JSON web services (i.e., the user has to be
authenticated), some parameters are made available to the web services by
default. Unless you want to change their values to something other than their
defaults, you don't have to specify them explicitly. 

Here are the default parameters:

- `userId`: The id of authenticated user
- `user`: The full User object
- `companyId`: The users company
- `serviceContext`: The empty service context object 

Let's find out about object parameters next. 

#### Object Parameters [](id=object-parameters-json-web-services-liferay-portal-6-2-dev-guide-en)

Most services accept simple parameters like numbers and strings. However,
sometimes you might need to provide an object (a non-simple type) as a service
parameter. 

To create an instance of an object parameter, prefix the parameter with a plus
sign, `+` and don't assign it any other parameter value. This is similar to
when we specified a null parameter by prefixing the parameter with a dash
symbol, `-`.

Here's an example:

    /jsonws/foo/get-bar/zap-id/10172/start/0/end/1/+foo

To create an instance of an object parameter as a request parameter, make sure
you encode the `+` symbol: 

    /jsonws/foo/get-bar?zapId=10172&start=0&end=1&%2Bfoo

Here's an alternative syntax: 

    <input type="hidden" name="+foo" value=""/>

If a parameter is an abstract class or an interface, it can't be instantiated as
such. Instead, a concrete implementation class must be specified to create the
argument value. You can do this by specifying the `+` prefix before the
parameter name followed by specifying the concrete implementation class. Check
out this example: 

    /jsonws/foo/get-bar/zap-id/10172/start/0/end/1/+foo:com.liferay.impl.FooBean

Here's another way of doing it: 

    <input type="hidden" name="+foo:com.liferay.impl.FooBean" value=""/>

The examples above specify that a `com.liferay.impl.FooBean` object, presumed to
implement the class of the parameter named `foo`, is to be created. 

You can also set a concrete implementation as a value. Here's an example: 

    <input type="hidden" name="+foo" value="com.liferay.impl.FooBean"/>

In JSON RPC, here's what it looks like:

    "+foo" : "com.liferay.impl.FooBean"

All the examples above specify a concrete implementation for the `foo` service
method parameter. 

Once you pass in an object parameter, you might want to populate the object.
Find out how next. 

#### Inner Parameters [](id=inner-parameters-json-web-services-liferay-portal-6-2-dev-guide-en)

When you pass in an object parameter, you'll often need to populate its inner
parameters (i.e., fields). Consider a default parameter `serviceContext` of type
`ServiceContext` (see the
[ServiceContext](https://www.liferay.com/documentation/liferay-portal/6.2/development/-/ai/servicecontext-liferay-portal-6-2-dev-guide-06-en)
section of the next chapter to find out more about this type). To make an
appropriate call to JSONWS, you might need to set the `serviceContext`
parameter's fields `addGroupPermissions` and `scopeGroupId`. 

You can pass inner parameters by specifying them using dot notation. Just append
the name of the parameter with a dot (i.e., a period, `.`), followed by the name
of the inner parameter. For the `ServiceContext` inner parameters we mentioned
above, you'd specify `serviceContext.addGroupPermissions` and
`serviceContext.scopeGroupId`. They're recognized as inner parameters and their
values are injected into existing parameters before the API service method is
executed. 

Inner parameters aren't counted as regular parameters for matching methods
and are ignored during matching. 

---

 ![Tip](../../images/tip-pen-paper.png) **Tip:** Use inner parameters with
 object parameters to set inner content of created parameter instances! 

---

Next, let's see what values are returned when a JSON seb service is invoked. 

### Returned Values [](id=returned-values-json-web-services-liferay-portal-6-2-dev-guide-05-en)

No matter how a JSON web service is invoked, it returns a JSON string that
represents the service method result. Returned objects are *loosely* serialized
to a JSON string and returned to the caller. 

Let's look at some values returned from service calls. We'll create a
`UserGroup` as we did in our SOAP web service client examples. To make it easy,
we'll use the test form provided with the JSON web service in our browser. 

1.  Sign in to your portal as an administrator and then point your browser to
    the JSON web service method that adds a `UserGroup`: 

        http://127.0.0.1:8080/api/jsonws?signature=/usergroup/add-user-group-2-\
        name-description

    Note, we've inserted line escape character `\` in order to fit the example
    URL on this page.

    Alternatively, navigate to it by starting at
    `http://127.0.0.1:8080/api/jsonws` then scrolling down to the section for
    *UserGroup*; click *add-user-group*. 

2.  In the *name* field, enter *UserGroup3* and set the description to an
    arbitrary value like *Created via JSON WS*.

3.  Click *Invoke* and you'll get a result similar to the following: 

        {
          "addedByLDAPImport": false,
          "companyId": 10154,
          "createDate": 1382460167254,
          "description": "Created via JSON WS",
          "modifiedDate": 1382460167254,
          "name": "UserGroup3",
          "parentUserGroupId": 0,
          "userGroupId": 13901,
          "userId": 10198,
          "userName": "Test Test",
          "uuid": "1b18c73d-482a-4772-b6f4-a9253bbcbf92"
        }

The returned `String` represents the `UserGroup` object you just created,
serialized into a JSON string. To find out more about JSON strings, go to
[json.org](http://www.json.org/). 

Let's check out some common JSON WebService errors. 

### Common JSON Web Service Errors [](id=common-json-web-service-errors-liferay-portal-6-2-dev-guide-05-en)

While working with JSON web services, you may encounter errors. Let's look at
the most common errors in the following subsections. 

<!--I would have put the subsections in an unordered list, but I'll leave them
for now. Which is preferred? Are they long enough to warrant subsections? --> 

<!-- No, they're not long enough. In fact, that's been a problem with this whole
chapter. I removed some sections already. One way to fix some of the "missing
transition" problems above would be to combine some of the sections. -Rich -->

-   Authenticated access required

    If you see this error, it means you don't have permission to invoke the
    remote service. Double-check that you're signed in as a user with the
    appropriate permissions. If necessary, sign in as an administrator to invoke
    the remote service.

-   Missing value for parameter 
    
    If you see this error, you didn't pass a parameter value along with the
    parameter name in your URL path. The parameter value must follow the
    parameter name, like in this example: 

        /api/jsonws/user/get-user-by-id/userId

    The path above specifies a parameter named `userId`, but doesn't specify
    the parameter's value. You can resolve this error by providing the
    parameter value after the parameter name: 

        /api/jsonws/user/get-user-by-id/userId/173

-   No JSON web service action associated 

    This is error means no service method could be matched with the provided
    data (method name and argument names). This can be due to various reasons:
    arguments may be misspelled, the method name may be formatted incorrectly,
    etc. Since JSON web services reflect the underlying Java API, any changes in
    the respective Java API will automatically be propagated to the JSON web
    services. For example, if a new argument is added to a method or an existing
    argument is removed from a method, the parameter data must match that of the
    new method signature.

-   Unmatched argument type 

    This error appears when you try to instantiate a method argument using an
    incompatible argument type.

-   Judgment Day

    We hope you never see this error. It means that Skynet has initiated a
    nuclear war and most of humanity will be wiped out; survivors will need to
    battle *Terminator* cyborgs. If you see this error and survive *Judgment
    Day*, we recommend joining the resistance--they'll likely need good
    developers to support the cause, especially those familiar with time travel. 

    Had you going there, didn't we? 

Next, we'll show you how to optimize your use of JSON web services by using the
*JSON Web Services Invoker*. 

### JSON Web Services Invoker [](id=json-web-services-invoker-liferay-portal-6-2-dev-guide-05-en)

Using JSON web services is easy: you send a request that defines a service
method and parameters, and you receive the result as JSON object. Below we'll
show you why that's not optimal, and introduce a tool that lets you use JSON
web services more efficiently and pragmatically. 

Consider this example: You're working with two related objects: a `User` and its
corresponding `Contact`. With simple JSON Web Service calls, you first call some
user service to get the user object and then you call the contact service using
the contact ID from the user object. You end up sending two HTTP requests to get
two JSON objects that aren't even bound together; there's no contact information
in the user object (i.e. no `user.contact`). This approach is suboptimal for
performance (sending two HTTP calls) and usability (manually managing the
relationship between two objects). It'd be nicer if you had a tool to address
these inefficiencies. Fortunately, the *JSON Web Service Invoker* does just
that! 

Liferay's JSON Web Service Invoker helps you optimize your use of JSON Web
Services. In the following sections, we'll show you how. 

#### A Simple Invoker Call [](id=a-simple-invoker-call-json-liferay-portal-6-2-dev-guide-05-en)

The Invoker is accessible from the following fixed address:

    http://[address]:[port]/api/jsonws/invoke

It only accepts a `cmd` request parameter--this is the Invoker's command. If the
command request parameter is missing, the request body is used as the command.
So you can specify the command by either using the request parameter `cmd` or
the request body. 

The Invoker command is a plain JSON map describing how JSON web services are
called and how the results are managed. Here's an example of how to call a
simple service using the Invoker: 

    {
        "/user/get-user-by-id": {
            "userId": 123,
            "param1": null
        }
    }

The service call is defined as a JSON map. The key specifies the service URL
(i.e. the service method to be invoked) and the key's value specifies a map of
service parameter names (i.e. `userId` and `param1`) and their values. In the
example above, the retrieved user is returned as a JSON object. Since the
command is a JSON string, null values can be specified either by explicitly
using the `null` keyword or by placing a dash before the parameter name and 
leaving the value empty (e.g. `"-param1": ''`).

The example Invoker calls functions exactly the same as the following standard
JSON Web Service call: 

    /user/get-user-by-id?userId=123&-param1

Of course, JSON Web Service invoker handles calls to plugin methods as well:

    {
        "/suprasurf-portlet.surfboard/hello-world": {
            "worldName": "Mavericks"
        }
    }

The code above calls our plugin's remote service. 

You can use variables to reference objects returned from service calls. Variable
names must start with a dollar sign, `$`. In our previous example, the service
call returned a user object you can assign to a variable: 

    {
        "$user = /user/get-user-by-id": {
            "userId": 123,
        }
    }

The `$user` variable holds the returned user object. You can reference the
user's contact ID using the syntax `$user.contactId`. 

Next, see how you can use nested service calls to join information from two
related objects. 

#### Nesting Service Calls [](id=nesting-service-calls-in-json-liferay-portal-6-2-dev-guide-en)

With nested service calls, you can magically bind information from related
objects together in a JSON object. You can call other services within the same
HTTP request and nest returned objects in a convenient way. Here's the magic of
a nested service call in action: 

    {
        "$user = /user/get-user-by-id": {
            "userId": 123,
            "$contact = /contact/get-contact-by-id": {
                "@contactId" : "$user.contactId"
            }
        }
    }

This command defines two service calls: the contact object returned from the
second service call is nested in (i.e. injected into) the user object, as a
property named `contact`. Now we can bind the user and his or her contact
information together! 

Let's see what the Invoker did in the background when we used a single HTTP
request to make the above nested service call: 

- First, the Invoker called the Java service mapped to `/user/get-user-by-id`,
  passing in a value for the `userId` parameter. 
- Next, the resulting user object was assigned to the variable `$user`. 
- The nested service calls were invoked. 
- The Invoker called the Java service mapped to `/contact/get-contact-by-id` by 
  using the `contactId` parameter, with the `$user.contactId` value from the
  object `$user`. 
- The resulting contact object was assigned to the variable `$contact`. 
- Lastly, the Invoker injected the contact object referenced by `$contact` into
  the user object's property named `contact`. 

---

 ![Note](../../images/tip-pen-paper.png) **Note:** You must *flag* parameters
 that take values from existing variables. To flag a parameter, insert the `@`
 prefix before the parameter name. 

---

Next, let's talk about filtering object properties so only those you need are
returned when you invoke a service. 

#### Filtering Results [](id=filtering-results-in-json-liferay-portal-6-2-dev-guide-05-en)

Many of Liferay Portal's model objects are rich with properties. If you only
need a handful of an object's properties for your business logic, making a web
service invocation that returns all of an object's properties is a waste of
network bandwidth. With the JSON Web Service Invoker, you can define a
*white-list* of properties: only the specific properties you request in the
object will be returned from your web service call. Here's how you white-list
the properties you need: 

    {
        "$user[firstName,emailAddress] = /user/get-user-by-id": {
            "userId": 123,
            "$contact = /contact/get-contact-by-id": {
                "@contactId" : "$user.contactId"
            }
        }
    }

In this example, the returned user object has only the `firstName` and
`emailAddress` properties (it still has the `contact` property, too). To specify
white-list properties, you simply place the properties in square brackets (e.g.,
`[whiteList]`) immediately following the name of your variable. 

Let's talk about batching calls next. 

#### Batching Calls [](id=batching-calls-in-json-liferay-portal-6-2-dev-guide-05-en)

When we nested service calls earlier, the intent was to invoke multiple services
with a single HTTP request. Using a single request for multiple service calls is
helpful for gathering related information from the service call results, but it
can also be advantageous to use a single request to invoke multiple unrelated
service calls. The Invoker lets you batch service calls together to improve
performance. It's simple: just pass in a JSON array of commands using the
following format: 

    [
        {/* first command */},
        {/* second command */}
    ]

The result is a JSON array populated with results from each command. The
commands are collectively invoked in a single HTTP request, one after another. 

Now that you've learned the ins and outs of invoking JSON web services in
Liferay, you may want to consider taking a streamlined approach to accessing Web
Content articles and Dynamic Data List records. Liferay's new Skinny JSON
Provider app gives you access to them and returns them in an easy-to-use
fashion. 

## Invoking Services Using Skinny JSON Provider [](id=invoking-services-using-skinny-json-prov-liferay-portal-6-2-dev-guide-06-en)

![EE Only Feature](../../images/ee-feature-web.png)

**Important:** This is a "Labs" application. Any app designated as " Labs" is
experimental in features and is not supported by Liferay. This status may change
without notice. Labs apps allow us to accelerate the availability of useful and
cutting-edge features, but these apps are not yet hardened like standard Liferay
EE apps. Please download and use Labs apps at your own discretion. 

Out of the box, Liferay's built-in JSON web services provide access to Web
Content articles and Dynamic Data Lists (DDLs), but return them in a verbose
XML-based representation. The *Skinny JSON Provider EE* app also offers web
services for retrieving web content articles and DDLs, but returns them in a
simplified, "skinny" JSON fashion. As a convenience, the app performs additional
parsing and processing, to return the bare essentials of each article and DDL.
Each web content article representation is comprised of its associated web
content structure fields. Each DDL record representation is comprised of its
data definition fields. The returned values are easier to read and light-weight,
making them ideal to use in browsers and mobile applications. 

The Skinny JSON Provider EE app is available through the Liferay Marketplace.
You'll find it categorized as a Utility app. You can read the section on
[Downloading and Installing Apps](http://www.liferay.com/documentation/liferay-portal/6.2/user-guide/-/ai/downloading-and-installing-apps-liferay-portal-6-2-user-guide-14-en)
for details on how to install it.

The Skinny JSON Provider EE app adds two new web service APIs that you can
configure like other Liferay web services. Here are the context and class name
that you must specify to access them:

- *Plugin Context Name:* `skinny-web`
- *Service Class Name:* `skinny`

To retrieve web content articles, use the `get-skinny-journal-articles` service.
To retrieve Dynamic Data Lists, use the `get-skinny-ddl-records` service. Note
that both services include "skinny" in their name. Both services are accessible
from Liferay's JSON Web Service Console. 

![Figure 6.2: You can access Skinny JSON web services from JavaScript, cURL, URLs in your browser, and from Liferay's trusty JSON Web Service API browser interface.](../../images/jsonws-api-services-01.png)

Before invoking the `get-skinny-journal-articles` and `get-skinny-ddl-records`
services, you should understand how to anonymously use the Skinny JSON Provider 
and how to use it in a CSRF protected environment. 

### Accessing the Services Anonymously and in CSRF Protected Environments [](id=accessing-the-services-anonymously-and-i-liferay-portal-6-2-dev-guide-06-en)

Retrieving data through an anonymous request to a web service is a typical use
case for Skinny JSON Provider. You can configure Liferay to allow anonymous
access to the Skinny JSON Provider. The configuration varies depending on the
version of Liferay you are using. 

For Liferay 6.2 and later, the Skinny JSON Provider EE app is preconfigured to
allow anonymous access by default. The underlying implementation uses the
`@AccessControlled` annotation to accomplish this. Note that this
preconfiguration can only be changed by modifying the plugin's source code and
recompiling the plugin. 

For Liferay 6.1, you must add the value `getSkinny*` as a public JSON web
service method entry in your `portal-ext.properties` file, in order to alloy
anonymous access to the services. 

    jsonws.web.service.public.methods=getSkinny*

Regardless of whether you've configured authentication as being required for the
Skinny Provider methods, all of Liferay's JSON web services require you to use a
`p_auth` token for CSRF protection in environments that pass sensitive per-user
data, like browser cookies. If your application is running in such an
environment (e.g., JavaScript in a browser) and you're calling Liferay's JSON
web services, you should never disable CSRF checking. 

The table below shows various ways that you can specify a p_auth token. 

**Specifying a p_auth Token:**

Invocation Type | Parameter and Value
--------------- | -------------------
JavaScript JSON object | `p_auth: 'value'`
curl | `-d pauth='value'`
URL | `p_auth/value`

You can substitute `value` with the value of your p_auth token. 

If your app is running in a simpler environment, like that of a custom mobile
app, and you're okay with foregoing the risks involved with disabling CSRF
projection, you can disable that protection. The mechanism for disabling CSRF
protection varies depending on the version of Liferay you are using. 

For Liferay 6.2 and later, you can disable CSRF protection for services that you
believe don't need checking. To disable CSRF protection for the Skinny
Provider's services, you can open access to the app's plugin context and service
class by adding their values to the list of `auth.token.ignore.origins` values
in your `portal-ext.properties`. Here's a `auth.token.ignore.origins` property
setting with these two values: 

    auth.token.ignore.origins=\
        com.liferay.portal.jsonwebservice.JSONWebServiceServiceAction:/skinny-web.skinny/,\
        com.liferay.portal.jsonwebservice.JSONWebServiceServiceAction:/skinny/

For Liferay 6.1, the only way to disable CSRF checking and disable the `p_auth`
token requirement is by globally disabling them. You can globally disable them
by specifying the following setting in your `portal-ext.properties`: 

    json.service.auth.token.enabled=false

Now that you've configured appropriate access for your Skinny JSON Provider EE
app, you can call its services!

### Retrieving Skinny Web Content Articles [](id=retrieving-skinny-web-content-articles-liferay-portal-6-2-dev-guide-06-en)

The `get-skinny-journal-articles` service is designed to retrieve all web
content articles that are based on a given web content structure, in a given
site or organization. To retrieve skinny web content articles, you must specify
values for the following parameters: 

- `companyId` - The ID of the company in which the articles exist.
- `groupName` - The human-readable name of the group (site or organization) in
  which the articles exist.
- `ddmStructureId` - The dynamic data mapping structure ID of the web content
  structure upon which the desired articles are based.
- `locale` (optional) - The name of the locale for which you want localized
  articles (e.g., `en_US`, `es_ES`, `fr`, etc.). If you omit this argument, the
  default locale of the server is used. If you specify a locale and no such
  localization exists for one of the articles, the article's default locale is
  used.

To demonstrate using the web service, imagine a simple web content structure
that has the following fields:

- `title` - A Text field with a title.
- `image` - A Documents and Media Library field for referencing an image file.
- `date` - A Date field (Date fields for web content structures are supported in
  Liferay Portal 6.2 and later).
- `toggle` - a Boolean field.

Imagine that you have multiple articles based on this structure, and you wish to
retrieve them through the `get-skinny-journal-articles` service. Here is an
example JavaScript invocation to retrieve the articles:

    Liferay.Service(
      '/skinny-web.skinny/get-skinny-journal-articles',
      {
        companyId: 10157,
        groupName: 'Guest',
        ddmStructureId: '15521',
        locale: 'en_US'
      },
      function(obj) {
        console.log(obj);
      }
    );

You could make the same service invocation by specifying the following URL in
your browser: 

    http://localhost:8080/api/jsonws/skinny-web.skinny/get-skinny-journal-articles/company-id/10157/group-name/Guest/ddm-structure-id/15521/locale/en_US

Note that the URL above specifies the DDM record ID parameter
`ddm-structure-id`, which has a slightly different name than the JavaScript
parameter `ddmStructureId`. Also, when invoking a service via a URL, make sure
to URL-encode any parameters that contain special characters. 

Now that you've seen a couple example invocations, you're might be wondering how
to get the different ID values to pass in to the service. For starters, you'll
need your portal's company ID. Here are steps you can follow to find that ID
value: 

1.  Sign in to your portal.
2.  To view your user account, click on your profile picture and select *My
    Account*.
3.  Note the numeric value of your *User ID*.
4.  In your browser's address bar, specify the URL to your portal's JSON web
    services. Here's an example URL for services on port `8080` of a portal
    running on a local host.

        http://localhost:8080/api/jsonws/

5.  With the slash character (`/`) selected as the *Context Path*, search for
    service `get-user-roles` and select the link to the service under *Role*.
6.  Specify your user ID in the *userId* field and click on *Invoke*. 
7.  From the *Result* text area, copy the value returned next to the
    `companyId`. 

Note, your portal's company ID so that you can specify it when invoking Skinny
Provider's services. As mentioned previously, you'll need to know your web
content article DDM Structure ID too. You'll learn how to get that next. 

On adding or editing a web content article, you can select a structure for the
article. The structure selection screen displays a listing of web content
structures. Each web content structure has an ID that you can note for supplying
to the Skinny Provider web service as a DDM structure ID value.

![Figure 6.3: On adding or configuring a structure for web content, the structure's ID is displayed. You can specify the ID as the value for the DDM structure ID in querying for the articles associated with the structure.](../../images/web-content-structure-listing.png)

Now that you know your portal's company ID and your DDM structure's ID, you can
invoke Skinny Provider's `get-skinny-journal-articles` service. 

---

![Note](../../images/tip-pen-paper.png) **Note:** there is a known issue
[LRDCOM-11877](https://issues.liferay.com/browse/LRDCOM-11877) in which invoking
services, such as Skinny Provider's services, via the JSON Web Services console
erroneously returns empty result sets. 

---

The `get-skinny-journal-articles` service returns a `JSONArray` object
containing zero or more articles. The following example return value shows a
`JSONArray` object that includes web content articles:

    [
        {
            "dynamicElements": {
                "title": "Liferay Portal Welcome",
                "toggle": "true",
                "image": "/documents/10184/0/welcome_tools/9921a6ff-2a83-414e-b629-d174ea7f2a0c?t=1385161659939",
                "date": "1393909200000"
            }
        },
        {
            "dynamicElements": {
                "title": "It's Super",
                "toggle": "",
                "image": "/documents/10184/0/welcome_cube/f9e23e2c-122d-4b7e-bf67-29d33abc1ec1?t=1385161661151",
                "date": "1394596800000"
            }
        },
        {
            "dynamicElements": {
                "title": "And Amazing",
                "toggle": "true",
                "image": "/documents/10184/0/welcome_community/ef976219-16c8-481b-a482-e3dac3291dcf?t=1385161662900",
                "date": "1395374400000"
            }
        }
    ]

Each web content article representation is comprised of its associated web
content structure fields. The service returns an empty array (`[]`) if no
matching articles are found. 

If you think getting web content articles through Skinny Provider is easy,
you'll find it a snap to get Dynamic Data List records. 

### Retrieving Skinny Dynamic Data Lists [](id=retrieving-skinny-dynamic-data-lists-liferay-portal-6-2-dev-guide-06-en)

The `get-skinny-ddl-records` service retrieves all records found in a specified
Dynamic Data List (DDL). Each DDL is globally recognized by its unique ID--no
company ID or group name are required to locate them. And since DDLs don't
support localization, no locale argument is needed. 

Dynamic Data List's records can be retrieved using the DDL's record set ID. You
can find the ID from within the Dynamic Data Lists app. Each list is assigned an
ID that you can supply to the Skinny Provider web service as the DDL record set
ID value. 

![Figure 6.4: On adding or configuring lists in Liferay's the Dynamic Data List app, each list's ID is displayed. You can specify this ID as the value for the DDL record set ID in querying the list from the Skinny web service.](../../images/ddl-data-definition-listing.png)

Now that you know how to get a DDL record set ID, you can specify it in calling
the `get-skinny-ddl-records` service. 

For example, imagine that you have a simple DDL based on the following data
definition:

- `title` - A Text field with a title.
- `image` - A Documents and Media Library field for referencing images.
- `date` - A Date field.
- `toggle` - a Boolean field.

If the DDL's record set ID is `15002`, for example, you can retrieve its records
by invoking JavaScript code like this:

    Liferay.Service(
      '/skinny-web.skinny/get-skinny-ddl-records',
      {
        ddlRecordSetId: 15002
      },
      function(obj) {
        console.log(obj);
      }
    );

In JavaScript, you pass the DDL record set ID via parameter `ddlRecordSetId`.

If you want to retrieve DDL records using a URL, you can specify a URL like this
one:

    http://localhost:8081/api/jsonws/skinny-web.skinny/get-skinny-ddl-records/ddl-record-set-id/15002

Make sure to specify your DDL record set ID as the value for the URL parameter
`ddl-record-set-id`. 

The Skinny Provider's `get-skinny-ddl-records` service returns a `JSONArray`
object, containing zero or more dynamic data list records. The following example
return value shows a `JSONArray` object that includes several dynamic data list
records:

    [
        {
            "dynamicElements": {
                "title": "Amazing Liferay",
                "toggle": "true",
                "image": "{\"groupId\":\"10184\",\"uuid\":\"012c2d55-b99f-4c85-92c9-7381c3693044\",\"version\":\"1.0\"}",
                "date": "2014-03-14"
            }
        },
        {
            "dynamicElements": {
                "title": "Can Do Much",
                "toggle": "false",
                "image": "{\"groupId\":\"10184\",\"uuid\":\"f9e23e2c-122d-4b7e-bf67-29d33abc1ec1\",\"version\":\"1.0\"}",
                "date": "2011-03-04"
            }
        },
        {
            "dynamicElements": {
                "title": "For You!",
                "toggle": "true",
                "image": "{\"groupId\":\"10184\",\"uuid\":\"ef976219-16c8-481b-a482-e3dac3291dcf\",\"version\":\"1.0\"}",
                "date": "2013-03-04"
            }
        }
    ]

Each DDL record representation is comprised of its data definition fields. The
service returns an empty array (`[]`) if the DDL has no records. 

Each value returned by the service is a JSON object that you can parse (e.g., by
invoking JavaScript's `JSON.parse()` method on it). Each object includes the
group ID and UUID of the target image. You can use the group ID and UUID to
construct a URL, of the format below, to access the image.

    http://localhost:8081/documents/[groupId]/[uuid]

As a recap, the Skinny JSON Provider EE app helps you retrieve lightweight
"skinny" representations of dynamic data list records and web content articles.
What a great way to access these core Liferay entities!

By learning to leverage JSON web services in Liferay, you've added some powerful
tools to your toolbox. Good job! Next, let's learn how to implement OAuth so
you can access third-party services. 

## Authorizing Access to Services with OAuth [](id=authorizing-access-to-services-with-oaut-liferay-portal-6-2-dev-guide-06-en)

Suppose you wanted users to authenticate to your Liferay Portal plugin from a
provider, like Twitter. You might think that you'd need to store the user's
credentials (e.g., the user's Twitter account name and password), so you could
pass them along with requests to the service provider and log them in. But this
opens up a can of worms. The third party is a moving target: what happens when
they modify their site, and your slick authenticator stops working?
Additionally, you might receive some criticism from your users for asking them
to give their Twitter credentials to you so you can use them to log in. Sounds
like a hassle, right? This is where OAuth comes into play, taking a approach
that is safe and simple. 

OAuth delegates user authentication to the service provider. An OAuth-enabled
plugin uses a token to prove it is authorized to access the user's third-party
profile data and invoke authorized services. By implementing OAuth in your
plugin, you get the best of both worlds--access to an outside service provider,
and your users' trust that the plugin won't have access to their protected
resources. 

In addition, Liferay Portal instances can act as OAuth service providers: you
can provide a means for your users to use their portal credentials to access
other services that have OAuth configured. We refer to such portals as
*Liferay Service Portals*. The OAuth framework lets Liferay Service Portal
administrators specify well-defined service authorizations. Once authorized,
the users can invoke the services via OAuth clients, such as the OAuth-enabled
plugin that you'll learn about in this section. 

---

 ![Note](../../images/tip-pen-paper.png) **Note:** To learn more about the OAuth
 framework, Liferay OAuth app, registering your OAuth app, or activating it from
 a portal page, visit the
 [OAuth](http://www.liferay.com/documentation/liferay-portal/6.2/user-guide/-/ai/liferay-utility-applications-liferay-portal-6-2-user-guide-13-en)
 section of *Using Liferay Portal*. 

---

<!-- Update link to User Guide when available. -->

To access portal services using OAuth, you'll need to create a client that uses
an OAuth cycle implementation, along with a user interface to lead your users
through the cycle. In this section, you'll see  an example of a portlet accessing
JSON Web Services from a remote portal. Let's get started by first selecting and
implementing services of an OAuth Client library. 

### Selecting an OAuth Client Library [](id=selecting-an-oauth-client-library-liferay-portal-6-2-dev-guide-06-en)

In order for your portlet to use OAuth, it must have a reference to OAuth
standards for authorization. You can offer your portlet an OAuth client library
by specifying a single JAR file. In this example, Scribe is chosen as the
OAuth library because it's available in Liferay Portal and can be easily
included in a plugin. To use the Scribe OAuth client library, open your plugin's
`liferay-plugin-package.properties` file and insert the `scribe.jar` file as a
portal dependency jar:

    portal-dependency-jars=\
       scribe.jar

That's all you have to do! Your portlet now has access to Scribe's OAuth
library. Next, you'll implement Scribe's OAuth service interface.

### Configuring OAuth's Service Implementation [](id=configuring-oauths-service-implementatio-liferay-portal-6-2-dev-guide-06-en)

Now that your portlet can access an OAuth client library, you need to
implement the OAuth services in your portlet. The following code demonstrates
implementing a Scribe OAuth service API:

    import org.scribe.builder.api.DefaultApi10a;
    ...

    public class OAuthAPIImpl extends DefaultApi10a {

        @Override
        protected String getAccessTokenEndpoint() {
            if (Validator.isNull(_accessTokenEndpoint)) {
                _accessTokenEndpoint = OAuthUtil.buildURL(
                    "oauth-portal-host", 80, "http",
                    PortletPropsValues.OSB_LCS_PORTLET_OAUTH_ACCESS_TOKEN_URI);
            }

            return _accessTokenEndpoint;
        }

        @Override
        protected String getRequestTokenEndpoint() {
            if (Validator.isNull(_requestTokenEndpoint)) {
                _requestTokenEndpoint = OAuthUtil.buildURL(
                    "oauth-portal-host", 80, "http",
                    PortletPropsValues.OSB_LCS_PORTLET_OAUTH_REQUEST_TOKEN_URI);
            }

            return _requestTokenEndpoint;
        }

        private String _accessTokenEndpoint;
        private String _requestTokenEndpoint;

    }

In this code snippet, the portlet provides the service platform's OAuth URLs to
Scribe to acquire the access token and request token from the service
provider. A *request token* is a value the portlet uses to obtain user
authorization. It is exchanged for an *access token*. The access token is a
value the portlet uses to gain access to protected resources on behalf of the
user. The exchange of a request token for an access token replaces the need for
supplying the user's service provider credentials. 

In addition to the tokens, you'll also need to provide the callback URL so that
the service platform can redirect the user's browser back to your portlet, once
authentication and authorization is complete. The callback URL can be provided
in an authorization request as a parameter, or it can be specified when
registering your application through Liferay's OAuth Admin menu. Keep in mind
that a callback URL provided via an authorization parameter overrides the
callback setting specified in the OAuth Admin menu. You can specify the callback
URL as an authorization parameter in your portlet's `portlet.properties` file.
You'll see this process later. Here's a code snippet that uses the callback URL
and request token in acquiring the OAuth Service:

    public class OAuthUtil {

        public static String buildURL(
            String hostName, int port, String protocol, String uri) {
            ...
        }

        public static Token extractAccessToken(
            Token requestToken, String oAuthVerifier) {

            Verifier verifier = new Verifier(oAuthVerifier);

            OAuthService oAuthService = getOAuthService();

            return oAuthService.getAccessToken(requestToken, verifier);
        }

        public static String getAuthorizeURL(
            String callbackURL, Token requestToken) {

            if (Validator.isNull(_authorizeRequestURL)) {
                authorizeRequestURL = buildURL(
                "oauth-portal-host", 80, "http",
                PortletPropsValues.OSB_LCS_PORTLET_OAUTH_AUTHORIZE_URI);

                if (Validator.isNotNull(callbackURL)) {
                    authorizeRequestURL = HttpUtil.addParameter(
                        authorizeRequestURL, "oauth_callback",
                        callbackURL);
                }
            }

            _authorizeRequestURL.replace("{0}", requestToken.getToken());
        }

        public static OAuthService getOAuthService() {
            if (_oAuthService == null) {
                ServiceBuilder oAuthServiceBuilder = new ServiceBuilder();

                oAuthServiceBuilder.apiKey(
                    PortletPropsValues.OSB_LCS_PORTLET_OAUTH_CONSUMER_KEY);
                oAuthServiceBuilder.apiSecret(
                    PortletPropsValues.OSB_LCS_PORTLET_OAUTH_CONSUMER_SECRET);
                oAuthServiceBuilder.provider(OAuthAPIImpl.class);

                _oAuthService = oAuthServiceBuilder.build();
            }

            return _oAuthService;
        }

        public static Token getRequestToken() {
            OAuthService oAuthService = getOAuthService();

            return oAuthService.getRequestToken();
        }

        private static String _authorizeRequestURL;
        private static OAuthService _oAuthService;

    }

Besides authorizing the callback URL, you're also implementing methods to acquire
the OAuth service, submit the request to that service, and obtain tokens from
the service. By doing this, you provide OAuth services to your portlet.
You're not quite done yet; you still need to provide information about the OAuth
platform you're accessing. 

First, you need to specify the OAuth protocol context paths for your URLs. In
the case of using Liferay Portal as a service platform, the default paths for
the OAuth portlet are specified in the `auth.public.paths` portal property found
in the [Authentication Pipeline](http://docs.liferay.com/portal/6.2/propertiesdoc/portal.properties.html#Authentication%20Pipeline)
section of Portal's `portal.properties` file. The URLs specified here do not
require authentication to access.

    auth.public.paths=\
        /portal/oauth/access_token,\
        /portal/oauth/authorize,\
        /portal/oauth/request_token

You'll need to transfer these OAuth related constants to your portlet's
`portlet.properties` file. Here's an example code snippet of what these
property settings look like:

    oauth.access.token.uri=/c/portal/oauth/access_token
    oauth.authorize.uri=/c/portal/oauth/authorize?oauth_token={0}
    oauth.consumer.key=42c56e22-d5a2-4003-86f4-cbc34b6de3e3
    oauth.consumer.secret=793195c2936a85649042b24ed843a036
    oauth.request.token.uri=/c/portal/oauth/request_token

Great! Now your OAuth services are implemented and OAuth constants are
specified. Your portlet can now take part in the OAuth authorization process!
You'll just need to set up a simple user interface to start the OAuth cycle.
Let's do this next!

### Creating a User Interface for Authentication [](id=creating-a-user-interface-for-authentica-liferay-portal-6-2-dev-guide-06-en)

Your portlet's user interface must initiate the OAuth cycle the first time it
accesses the OAuth platform for each specific user. Your portlet must
render the OAuth authorization UI automatically when the portlet does not
possess the access token and access secret. The JSP code snippet below initiates
the OAuth authorization process:

    <portlet:actionurl name="setupOAuth" var="setupOAuthURL">
    <%
    Token requestToken = OAuthUtil.getRequestToken();

    portletSession.setAttribute(Token.class.getName(), requestToken);
    %>
    <div class="button-container"%>
        <a class="lcs-portal-link" href="<%= OAuthUtil.getAuthorizeURL(setupOAuthURL, requestToken) %>"><liferay-ui:message key="authorize-access"/>
        </a>
    </div>

On successfully getting authorization from the service provider, the OAuth
platform redirects the user back to the callback URL, which in this case is a URL
for the `setupOAuth` portlet action. This action method uses the request token
to get the access token. It stores the token secret and the token itself. Here's
a snippet of the portlet action method:

    public void setupOAuth(
            ActionRequest actionRequest, ActionResponse actionResponse)
        throws Exception {

        PortletSession portletSession = actionRequest.getPortletSession();

        Token requestToken = (Token)portletSession.getAttribute(
            Token.class.getName());

        String oAuthVerifier = ParamUtil.getString(
            actionRequest, "oauth_verifier");

        Token token = OAuthUtil.extractAccessToken(requestToken, oAuthVerifier);

        // store token.getSecret() and token.getToken()
        ...
    }

The figure below shows the OAuth authorization user interface.

![Figure 5.2: When your portlet is granted access to the service provider, it acquires the access token and access secret.](../../images/oauth-application-authorize.png)

On completing initial OAuth authorization via the UI and on the user revisiting
the portlet instance thereafter, the portlet should render its normal UI. 
Once your portlet is granted access, the OAuth platform redirects the user back
to the callback URL you specified during the portlet's registration.

Once you have the access token and access secret stored, your portlet can use
them to access services such as JSON web services. Here's a simple code example
for this scenario:

    Token token = new Token(getAccessToken(), getAccessSecret());

    String requestURL = OAuthUtil.buildURL(
        "oauth-portal-host", 80, "http",
        "/api/secure/jsonws/context.service/method/parms");

    OAuthRequest oAuthRequest = new OAuthRequest(Verb.POST, requestURL);

    OAuthService oAuthService = OAuthUtil.getOAuthService();

    oAuthService.signRequest(token, oAuthRequest);

    Response response = oAuthRequest.send();

    if (response.getCode() == HttpServletResponse.SC_UNAUTHORIZED) {
        String value = response.getHeader("WWW-Authenticate");

        throw new CredentialException(value);
    }

    if (response.getCode() == HttpServletResponse.SC_OK) {
        // do something with results from response.getBody();
    }

That's it! You've implemented an OAuth client library, created a service
implementation, and developed a user interface to present the OAuth cycle. Of
course, this example and its code snippets are not compatible for all use cases,
but they demonstrate configuring an OAuth-ready application for Liferay Portal. 

## Summary [](id=summary-liferay-portal-6-2-dev-guide-05-en)

In this chapter, you saw how easy it is to find and invoke Liferay remote
web services. We also explained how Liferay's service security layers are used
to protect your data and prevent unauthorized service calls. Then, we dove into
SOAP web services and showed you how to create SOAP web service clients to
invoke them. Lastly, we jumped into JSON web services. We learned how to
register them, list them, and invoke them from Liferay JSON web service
interface. Next, we learned about several different URL patterns and ways to
pass JSON web service parameters in service calls. Lastly, we explored the world
of OAuth and explained how to configure a Liferay application to use the OAuth
platform. You see, here at Liferay, we aim to give you terrific service!

Next, we'll take a look at some of the powerful frameworks of Liferay Portal,
learn how they work and how you can leverage them.
