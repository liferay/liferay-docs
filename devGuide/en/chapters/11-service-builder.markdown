## Service Builder 

Service Builder is a model-driven code generation tool built by Liferay that
allows developers to define custom object models called entities. Service
Builder generates a service layer through Object-Relational Mapping (ORM)
technology that provides a clean separation between your object model and code
for the underlying database. This frees you to add the necessary business logic
for your application. Service Builder takes an XML file (usually called
`service.xml`) as input and generates the necessary model, persistence, and
service layers for your application. These layers provide a clean separation of
concerns. Service Builder generates most of the common code needed to implement
find, create, update, and delete operations on the database, allowing you to
focus on the higher level aspects of service design.

The service layer generated by Service Builder contains an implementation class
that is responsible for retrieving and storing data classes and adding the
necessary business logic around them. This layer can optionally be composed of
two layers: a local service layer and a remote service layer. The local service
contains the business logic and accesses the persistence layer. It can be
invoked by client code running in the same Java Virtual Machine. The remote
service usually has additional code to check security and is meant to be
accessible from anywhere over the Internet or your local network. Service
Builder automatically generates the code necessary to allow access to the remote
services using SOAP, JSON, and Java RMI.

### Benefits of Using Service Builder

Service Builder solves an important portal problem. In a standalone web
application, the database access code can be bundled with the rest of the
application. However, in a portal, web applications are often composed of
multiple portlets that need to access the same data and the same application
logic. Separate web applications (i.e., separate WARs) have separate class
loaders and it's normally difficult to share data and application logic across
class loader boundaries. Service Builder allows different portlets to access the
same data and application logic by creating an underlying framework that's
designed to support a portal environment.

The code generated by Service Builder exists within a single plugin but can
easily be shared across all portlets. This code, bundled in a service JAR,
includes a single database access service layer that eliminates the need to
manage extra database connections or worry about code synchronization between
portlets. Using a database single access layer allows the use of caching. Since
there is only one data reader/writer, there is no need to worry about cached
data becoming obsolete. If updates need to be made to your web application's
service layer, Service Builder can generate a new service JAR with which you can
replace the old one without needing to restart your application server.

Using Service Builder can save developers lots of time since it completely
eliminates the need to write and maintain database access code. The database
access code generated by Service Builder is database-agnostic, as is Liferay
itself. Developers using Service Builder just need to create or edit a
`service.xml` file and run Service Builder to generate a new service JAR for
their project. The service JAR generated by Service Builder includes a model
layer, a persistence layer, a service layer, and related infrastructure. Service
Builder uses Spring for dependency injection and Hibernate for object-relational
mapping but it hides the complexities of using these technologies. The remote
services generated by Service Builder include SOAP utilities and can be accessed
via SOAP, JSON, and Java RMI. Although the number of files generated by Service
Builder can seem intimidating at first, developers only need to work with a few
files in order to make customizations and add business logic.

Originally, Service Builder was built when Liferay used Enterprise Java Beans
(EJBs) for everything. Back then, using EJBs, making even simple changes often
required editing many XML configuration files and Java classes. Service Builder
has evolved since then to use Spring and Hibernate, gaining a lot a flexibility
and allowing changes to be made very simply--in many cases, all that's required
is a change to `service.xml` and a re-run of Service Builder. Liferay isn't a
generic code generation tool; it's specifically designed to meet the needs of
Liferay and Liferay plugin developers. Service Builder may not be the best tool
for everyone but it provides a great degree of consistency to any plugin
developed with it.

In summary, we encourage developers to use Service Builder because it solves the
class loader issue for separate web applications and saves development time.
It's also the technology used to generated Liferay's internal database
persistence code. However, you don't have to use Service Builder for plugin or
portlet development. It's entirely possible to develop plugins by writing custom
code for database persistence using your persistence framework of choice, such
as JPA, Hibernate, or Ibatis. If you're inclined to take this approach, just
remember that you'll have to solve the problem of sharing services across
classloaders on your own. You'll also have to implement your own
object-relational mapping solution as well as Spring configuration, if you'd
like to use Spring for dependency injection. Finally, if you intend to use a
service-oriented architecture for your custom services, you'll have to manually
create the interfaces for your Impl-classes to implement that Service Builder
could have auto-generated for you. You'll also have to manually keep your
interfaces and Impl-classes in sync. Next, let's roll up our sleeves and learn
how to use Service Builder.

### Configuring Service Builder and Defining Portlet Data

In order to demonstrate how to use Service Builder, let's create an example
portlet project that the Nose-ster organization can use to schedule social
events. For our example, we'll create a new Liferay portlet project for managing
and listing our events. We'll define two entities called *events* and
*locations*, representing events that can be scheduled and locations at which
the events can take place. Since events take place at specific locations, an
event entity should be able to take a location entity as an attribute. If you'd
like to examine the finished example project, you can view the code on Github
[https://github.com/liferay/liferay-docs/tree/master/devGuide/code/devGuide-sdk/portlets/event-listing-portlet](https://github.com/liferay/liferay-docs/tree/master/devGuide/code/devGuide-sdk/portlets/event-listing-portlet)
or download the `.war` file from
[https://github.com/liferay/liferay-docs/tree/master/devGuide/code/devGuide-sdk/dist/event-listing-portlet-6.2.0.1.war](https://github.com/liferay/liferay-docs/tree/master/devGuide/code/devGuide-sdk/dist/event-listing-portlet-6.2.0.1.war).
But we'll guide you through creating the project, its portlets, and its entities
step-by-step using Liferay IDE/Developer Studio. 

---

 ![Tip](../../images/tip-pen-paper.png)**Note:** If you're actually looking for
 a portlet application that can manage events, please consider using Liferay's
 built-in Calendar portlet. The example described in this section is only
 intended to demonstrate how to use Service Builder. The Calendar portlet
 provides many more features than the simple example application described here.
 For information about the built-in calendar portlet, please refer to the
 chapter on Liferay's collaboration suite in [Using Liferay Portal](http://www.liferay.com/documentation/liferay-portal/6.1/user-guide).

---

Liferay portlet projects can contain multiple portlets. We'll create two
portlets in our `event-listing-portlet` project--one for managing Nose-ster
events and the other for managing Nose-ster locations. These portlets will allow
users to add, edit, or remove events and locations, display lists of events and
locations, search for particular events and locations, and view the details of
individual events or locations. We'll start by creating the event listing
portlet as we create the `event-listing-portlet` plugin project. 

To follow this example, create a new Liferay portlet project in your Liferay
Plugins SDK using Liferay IDE or Developer Studio. In the IDE, go to File &rarr;
New Liferay Project. We'll mention some key information to specify for the
project and the event listing portlet as you create both in the wizard. Name the
project `event-listing-portlet`, enter `Event Listing` as its display name, and
select *Portlet* as its project type. Select the Liferay MVC portlet framework
as the default framework for the project and select the checkbox to add a custom
portlet class. This custom portlet class will be for your event listing portlet,
which we'll continue to specifying in the wizard.

Enter portlet class name `EventListingPortlet`, Java package
`com.nosester.portlet.eventlisting`, and keep the superclass
`com.liferay.util.bridges.mvc.MVCPortlet`. For your portlet's info, enter
`eventlisting` as its name and `Event Listing Portlet` as its display name and
title. For the portlet's modes, select *Edit* mode in addition to *View*.
Selecting the edit mode is optional at this point, but it sets you up with a
helpful skeleton JSP file to add logic for editing your Nose-ster events. While
you're at it, select the checkbox for creating a resource bundle file so that you
can add different language translations for your portlet's textual display
values. Lastly, leave your portlet's category as `Sample`. Click *Finish* to
complete creating your Liferay portlet plugin project and the Event Listing
portlet.   

Now, go ahead and create a Location Listing portlet in this same project by
selecting the project in the *Package Explorer* first and going to  File &rarr;
New  &rarr; Liferay Portlet.  Creating the Location Listing portlet in the IDE
will be similar to how you created the Event Listing portlet. Only the portlet
class name and other name values will be slightly different.

Here is a summary of the values to specify in the Liferay Portlet wizard for
creating the Location Listing portlet:    

- Portlet class: `LocationListingPortlet`
- Java package:`com.nosester.portlet.eventlisting`
- Display name: `Location Listing Portlet`
- Title: `Location Listing Portlet`
- Superclass: `com.liferay.util.bridges.mvc.MVCPortlet`
- Portlet name: `locationlisting`
- Portlet modes: *View* and *Edit*
- Create JSP files: yes
- Category: `Sample`

Expand your project's `docroot/WEB-INF/src` folder and the
`com.nosester.portlet.eventlisting` package. Notice the
`EventListingPortlet.java` and `LocationListingPortlet.java` files Liferay IDE
created. We'll add some business logic to these portlet classes after using
Service Builder to create a service layer for our event and location entities.

The first step in using Service Builder is to define your model classes and
their attributes in a `service.xml` file. In Service Builder terminology, your
model classes (events and locations) are called entities. We've kept the
requirements for our event and location entities fairly simple. Events should
have the attributes specified in the following table:

**Event Attributes**

Attribute | Attribute Type | Attribute Description
:------------: | :------------: | :-------------------:
`name` | String | The name of the event
`description` | String | A description of the event
`date` | Date | The date and time the event takes place
`locationId` | long | An event takes place at a location and we use a location Id to specify the location

Locations should have the attributes specified in the following table:

**Location Attributes**

Attribute | Attribute Type | Attribute Description
:------------: | :------------: | :-------------------:
`name` | String | The name of the location
`description` | String | A description of the location
`streetAddress` | String | The street address of the location
`city` | String | The city of the location
`stateOrProvince` | String | The state or province of the location
`country` | String | The country of the location

<!-- 
Let's show how to build the service.xml from the ground up, using Liferay
IDE. - Jim
-->

Let's create a `service.xml` file for our project and specify our services and
their entities. Liferay's IDE makes it easy.

To create a `service.xml` file for your project, use the following steps: 

1.  Create the `service.xml` file.

2.  Define global information such as the Service Builder package path, author,
    and namespace.

3.  Define one or more database entities. Decide whether Service Builder should
    generate local services, remote services, or both.

4.  Define the columns (attributes) that each entity should possess.

<!--
5.  Specify relationships between entities. - Jim
-->

5.  Define a default ordering of entities that are retrieved from the database.

6.  Define the finder methods that retrieve objects from the database using
    specified parameters.

<!--
7.  Provide the means to associate an asset and tags. //AssetEntry and AssetTag
See sample-service-builder-portlet. - Jim
-->

You can create your `service.xml` file manually to your `docroot/WEB-INF/src`
folder or do it with a click of the button in Liferay's IDE. To create it in the
IDE, select your `event-listing-portlet` project in the Package Explorer
and then select File &rarr; New &rarr; Liferay Service Builder. By default, Service
Builder creates the `service.xml` file and displays it in *Overview* mode in the
IDE. 

Now, we're ready to define the service's global information. If not already
selected, select *Service Builder* in the outline on the left of the view of
`service.xml`. Then, enter `com.nosester.portlet.eventlisting` for package path,
your name as author, and `Event` as the namespace. Save your `service.xml`.  

Next, we'll add our Event and Location entities. Select *Entities* from under
*Service Builder* in the outline on the left of the view. In the main part of
the view, notice the *Entities* table is empty. Create an entity by clicking the
add icon (a green plus sign) to the right of the table. Fill in `Event` for our
entity's name and select both *Local Service* and *Remote Service* options for
it. Create an entity named `Location` too, and select *Local Service* and
*Remote Service* options for it. Great! We now have our Event and Location
entities. Let's describe their attributes.

To add attributes for our Event entity we'll need to drill down to its columns
in the outline. From the outline, expand *Entities* and our new *Event* entity.
Then, select *Columns*. Liferay IDE displays a table of the Event entity's
columns. Similar to the table we used for adding entities, we'll add attributes
for the *Event* entity and *Location* entity. Create each attribute by clicking
the add icon and filling in the name of the attribute, select its type, and
specify whether it is a primary key for the entity. Note, while your cursor is
in a column's *Type* field, an option icon shows in the right hand side of the
field. Click the options icon to select the appropriate type for your column.
Use attribute information as specified for both entities in the tables listed
previously in this section. 

<!--
We may want to move those tables down here. - Jim
-->

In addition to the attributes of each entity we must specify a primary key column for
each entity. Create a column named `eventId` of type `long` for the Event entity
and a column named `locationId` of type `long` for the Location entity. 

Also, it is always worth considering adding two `long` fields called *groupId*
and *companyId* to your data models. The *groupId* specifies a particular site
within a portal instance and the *companyId* specifies a portal instance. These
two fields allow your portlet to support the multi-tenancy features of Liferay
so that each portal instance and each site within a portal instance can have
independent sets of portlet data. You should also consider adding two additional
fields called *createDate* and *modifiedDate*. You can use these fields to
record the times entities were created and last edited. 


<!--
TODO - Instruct how to use IDE to create Order by. - Jim

By now, you've added all of your attributes as columns. Let's specify the order
in which to return records for each entity.

TODO - Instruct how to use IDE to create Finders. - Jim
-->

<!--
Consider reflecting on the service.xml after explaining step by step how to build
using IDE. Perhaps put the heading here. - Jim

### Overview of `service.xml`
-->

Now that you are done creating your `service.xml`, it should look similar to the
following: 

    <?xml version="1.0" encoding="UTF-8"?>
    <!DOCTYPE service-builder PUBLIC "-//Liferay//DTD Service Builder 6.1.0//EN" "http://www.liferay.com/dtd/liferay-service-builder_6_1_0.dtd">
    <service-builder package-path="com.nosester.portlet.eventlisting">
        <author>Joe Bloggs</author>
        <namespace>Event</namespace>

        <entity name="Event" local-service="true" remote-service="true">

            <!-- PK fields -->

            <column name="eventId" type="long" primary="true" />

            <!-- Audit fields -->

            <column name="companyId" type="long" />
            <column name="groupId" type="long" />
            <column name="userId" type="long" />
            <column name="createDate" type="long" />
            <column name="modifiedDate" type="long" />

            <!-- Other fields -->

            <column name="name" type="String" />
            <column name="description" type="String" />
            <column name="date" type="Date" />
            <column name="locationId" type="long" />

            <!-- Order -->

            <order by="asc">
                    <order-column name="date" />
            </order>

            <!-- Finder methods -->

            <finder name="GroupId" return-type="Collection">
                    <finder-column name="groupId" />
            </finder>
        </entity>

        <entity name="Location" local-service="true" remote-service="true">

            <!-- PK fields -->

            <column name="locationId" type="long" primary="true" />

            <!-- Audit fields -->

            <column name="companyId" type="long" />
            <column name="groupId" type="long" />
            <column name="userId" type="long" />
            <column name="createDate" type="Date" />
            <column name="modifiedDate" type="Date" />

            <!-- Other fields -->

            <column name="name" type="String" />
            <column name="description" type="String" />
            <column name="streetAddress" type="String" />
            <column name="city" type="String" />
            <column name="stateOrProvince" type="String" />
            <column name="country" type="String" />
            
            <!-- Order -->

            <order by="asc">
                    <order-column name="name" />
            </order>

            <!-- Finder methods -->

            <finder name="GroupId" return-type="Collection">
                    <finder-column name="groupId" />
            </finder>
        </entity>
    </service-builder>

We followed these steps to create the `service.xml` for our
event-listing-project example. The first line of `service.xml`, `<?xml
version="1.0" encoding="UTF-8"?>`, just defines the XML version and character
encoding used in the `service.xml` file. The next line, `<!DOCTYPE
service-builder PUBLIC "-//Liferay//DTD Service Builder 6.1.0//EN"
"http://www.liferay.com/dtd/liferay-service-builder_6_1_0.dtd">`, specifies the
DTD (Document Type Declaration) and provides the DTD's URL. The following line
provides the root element of the Service Builder deployment descriptor: 

    <service-builder package-path="com.nosester.portlet.eventlisting">

The `package-path` attribute of the `<service-builder>` element specifies the
package in which the generated service and persistence classes will be
generated. In this example, the classes will be generated in the
`docroot/WEB-INF/service/com/nosester/portlet/eventlisting/` and
`docroot/WEB-INF/src/com/nosester/portlet/eventlisting/` packages. Please refer
to next section, *Generating the Services*, for a description of the contents of
these packages.

Next, we have the `<author>` element:

    <author>Joe Bloggs</author>

The author's name is added to all of the code generated by Service Builder.
After this comes the `<namespace>` element:

    <namespace>Event</namespace>

Service Builder uses the namespace we define here when it generates database
table names. Service Builder generates SQL scripts in the `docroot/WEB-INF/sql`
folder for creating database tables for all the entities defined in
`service.xml`. These SQL scripts include the following:

- `indexes.sql`
- `sequences.sql`
- `tables.sql`

Service Builder prepends the database table names with the value specified by
the namespace. For example, since our namespace value is `Event`, the names of
the database tables created for our entities will start with `Event_`. The
`<namespace>` element for each Service Builder project must be unique. Separate
plugins should use separate namespaces and should not use a namespace already
used by Liferay (such as `Users` or `Groups`).

In the rest of our `service.xml` file, we define two entities: 

    <entity name="Event" local-service="true" remote-service="true">

    <entity name="Location" local-service="true" remote-service="true">

The entity name represents the database table you want to create. Remember that
the actual name of the database table is prefixed with the namespace, so in our
example, we'll have two database tables with the names `Event_Event` and
`Event_Location`.

Setting the `local-service` attribute to `true` instructs Service Builder to
generate local interfaces for our entity's service. The default value for
`local-service` is `false`. However, the generated service will reside in our
portlet's WAR file and our portlet will be deployed to our Liferay server. So
the service will be local from our Liferay server's point of view.

Setting the `remote-service` attribute to `true` instructs Service Builder to
generate remote interfaces for the service. The default value for
`remote-service` is `true`. We could build a fully-functional event listing
application without generating remote services so we could set `local-service`
to `true` and `remote-service` to `false` for both of our entities. However,
since we want to demonstrate how to use the web services that Service Builder
generates for our entities, we'll set both `local-service` and `remote-service`
to `true`.

---

 ![Tip](../../images/tip-pen-paper.png)**Tip:** Suppose you have an existing DAO
 service for an entity built using some other framework such as JPA or JingDAO.
 You can set local-service to `false` and remote service to `true` so that the
 methods of your remote Impl class can call the methods of your existing DAO.
 This enables your entity to integrate with Liferay's permission checking system
 and provides access to the web service APIs generated by Service Builder. This
 is a very handy, quite powerful, and often used feature of Liferay.

---

For each of our entities, we specify a number of columns, an order, and a number
of finders. For example, here is the first column we define for the Event
entity:

    <column name="eventId" type="long" primary="true" />

Columns specified in `service.xml` will be created in the database with a data
type appropriate to the specified Java type. Hibernate handles the
object-relational mapping. Accessors in the model class will automatically be
generated for these attributes. The column `name` specifies the name of the
getters and setters that are created for this field of the entity. By default,
it also specifies the name of the database column created in the `Event_Event`
table. The column `type` determines the Java type of this field of the entity.
If a column's `primary-key` attribute is set to `true`, then this column is part
of the primary key of the entity. An entity's primary key is a unique identifier
of the entity. If only one column has `primary-key` set to `true`, then this
column represents the entire primary key of the entity.  This is the case in our
example. However, it's possible for multiple columns within an entity to have
`primary-key` set to `true`. In these cases, a compound key is created.

---

 ![Tip](../../images/tip-pen-paper.png)**Tip:** Always consider adding two
 `long` fields called *groupId* and *companyId* to your data models. The
 *groupId* specifies a particular site within a portal instance and the
 *companyId* specifies a portal instance. These two fields allow your portlet to
 support the multi-tenancy features of Liferay so that each portal instance and
 each site within a portal instance can have independent sets of portlet data.
 You should also consider adding two additional fields called *createDate* and
 *modifiedDate*. You can use these fields to record the times entities were
 created and last edited.

---

After defining the columns of each of our entities, we defined an order. Like
`<column>`, the `<order>` element is a child of the `<entity>` element.

    <order by="asc">
        <order-column name="date" />
    </order>

Set the `<order>` element's `by` attribute to `asc` or `desc` to order entities,
whenever they are retrieved from the database, in ascending or descending order.
Use the `name` attribute of an `<order-column>` child element to determine which
field of the entity should be used for the ordering.

After defining an order for each of our entities, we defined a number of finders
for them. `<finder>`, like `<column>` and `<order>`, is a child element of the
`<entity>` element.

    <finder name="GroupId" return-type="Collection">
        <finder-column name="groupId" />
    </finder>

Service Builder creates a finder method for each `<finder>` element that you
specify for your entity. The `name` attribute of the `<finder>` element is used
to construct the finder method name. In the example above, the finder `name` is
`GroupId` so the method generated for this finder will be named `findByGroupId`.
It's a Java coding standard to use camel casing for method names so make sure to
begin your finder names with a capital letter. The `return-type` of the
`<finder>` element determines the return type of the generated finder method.
The `<finder-column>` element inside of the `<finder>` element represents the
database table column that Service Builder creates. Service Builder uses the
`<finder-column>`'s `<name>` attribute to construct the column name of the table
in the database.  When you run Service Builder, your entities' finder methods
are generated in the following classes:

- `/docroot/WEB-INF/service/com/nosester/portlet/eventlisting/service/persistence/*Persistence.java`
- `/docroot/WEB-INF/src/com/nosester/portlet/eventlisting/service/persistence/*PersistenceImpl.java` 

The first of these classes is the interface, the second is its implementation.
Now let's run Service Builder and take a closer look at the generated code. To
run Service Builder, run `ant build-service` from your project's root directory.
The Ant tasks are provided by the Liferay Plugins SDK. The following section
provides further details on running Service Builder.

<!--
I suggest leaving the `ant build-service` instruction for the next section. Let
them read about using IDE and Ant for generating the services before deciding.
- Jim
-->

### Generating the Services

To build a service using our `service.xml`, you can either use *Liferay IDE* or
*Liferay Developer Studio* or use a terminal window.

***Using Liferay IDE or Developer Studio:*** From the *Package Explorer*, open
the `service.xml` file found in your `event-listing-portlet/docroot/WEB-INF`
folder. By default, the file opens up in the *Service Builder Editor*. Make sure
you are in *Overview* mode. Then, click on the *Build Services* button.

![Figure 10.1: The *Overview* mode in the editor provides a nested outline which you can expand, a form for editing basic Service Builder attributes, and buttons for building services or building web service deployment descriptors.](../../images/service-xml-overview.png)

<!-- Need to highlight the build services icon in image (e.g., add red square
around icon - Jim --> 

You should receive a message in your console stating BUILD SUCCESSFUL along with
a list of generated files. We discuss these files in more detail later on in
this section.

The *Overview* mode in Developer Studio's *Service Builder Editor* can be used
to build services or build web service deployment descriptors (WSDDs). The
*Build WSDD* button is next to to the *Build Services* button near the top right
corner of the Service Builder editor's Overview tab. The Service Builder editor
also has *Diagram* and *Source* modes. If you select *Diagram*, you'll see a
graph structured background onto which you can add entities and relationships
from the *Palette* available on the right hand side of the editor. Here is a
view of the editor in *Diagram* mode:

<!--
Suggest, moving WSDD generation references later in this section, after we're done
building the service. - Jim
-->

![Figure 10.2: *Diagram* mode in editor](../../images/service-xml-diagram.png)

<!--
The view window need not be so tall as there is much empty space in the view - Jim
-->

Lastly, select *Source* mode to edit the XML source directly. Here is a view of
our example `service.xml` shown in the editor's *Source* mode:

![Figure 10.3: *Source* mode in editor](../../images/service-xml-source.png)

<!--
Since the service.xml source is given as code in this section, there's no
need to show the an image of the source view. Mentioning *Source* mode is enough.
- Jim
-->

The tools provided by Developer Studio make it easy to edit your `service.xml`
file to customize the generated interfaces and classes for your database model,
persistence, and service layers.

***Using the terminal:*** Open a terminal window, navigate to your
`portlets/event-listing-project-portlet` directory, and enter this command:

    ant build-service

When the service has been successfully generated, a BUILD SUCCESSFUL message
appears in the terminal window. You should see that a large number of files have
been generated. An overview of these files generated for our Event entity is
provided below. Note that the files listed under Local Service and Remote
Service below are only generated for an entity if `local-service` or
`remote-service` are set to `true`, respectively. Service Builder generates
services for these entities in two locations in our project, using the
package-path that we specified in `service.xml`:

- `docroot/WEB-INF/service/com/nosester/portlet/eventlisting`

- `docroot/WEB-INF/src/com/nosester/portlet/eventlisting`

The `docroot/WEB-INF/service/com/nosester/portlet/eventlisting/` package
contains utility classes and interfaces for the event-listing project. All of
the classes and interfaces in the service folder are packaged in a JAR file
called `event-listing-project-portlet-service.jar` in your `docroot/WEB-INF/lib`
folder. This JAR file is generated each time Service Builder runs. It's possible
to place this JAR file on your application server's global classpath to make
your project's services available to other projects. This could allow a portlet
in a different project, for example, to create, update, or delete Events or
Locations. Of course, you should consider the security implications of placing
your project's service JAR on your application server's global classpath: do you
*really* want to allow other plugins to access your project's services?

The `docroot/WEB-INF/src/com/nosester/portlet/eventlisting` package contains the
implementation of the interfaces defined in the
`docroot/WEB-INF/service/com/nosester/portlet/eventlisting` package. It belongs
to the Event Listing project's classpath but is not available outside of the
Event Listing project. Service Builder generates classes and interfaces
belonging to the persistence layer, service layer, and model layer in the
`docroot/WEB-INF/service/com/nosester/portlet/eventlisting` and
`docroot/WEB-INF/src/com/nosester/portlet/eventlisting` packages. Let's take a
closer look at the classes and interfaces generated for Events. The ones
generated for Locations are similar.

-   Persistence

    - `EventPersistence`: Event persistence interface which defines CRUD methods
      for the Event entity such as create(), remove(), countAll(), find(),
      findAll(), etc. `@generated`

    - `EventPersistenceImpl`: Event persistence implemenation class which
      implements `EventPersistence`. `@generated`

    - `EventUtil`: Event persistence utility class which wraps
      `EventPersistenceImpl` and provides direct access to the database for CRUD
      operations. This utility should only be used by the service layer; in your
      portlet classes, use `EventLocalServiceUtil` or `EventServiceUtil`
      instead. `@generated`

    ![Figure 10.3: Service Builder generates these persistence classes and interfaces. You shouldn't (and won't need to) customize any of these classes or interfaces.](../../images/service-builder-persistence-diagram.uml.png)

-   Local Service (only generated for an entity if an entity's `local-service`
    attribute is set to `true` in `service.xml`)

    - `EventLocalService`: Event local service interface. `@generated`

    - **`EventLocalServiceImpl`**: Event local service implementation. This is
      the only class within the local service that you should modify manually.
      You can add custom business logic here. For any custom methods added here,
      Service Builder add corresponding methods to the `EventLocalService`
      interface the next time it runs.

    - `EventLocalServiceBaseImpl`: Event local service base implementation. This
      is an abstract class. Service Builder injects a number of instances of
      various service and persistence classes into this class. `@generated`
      `@abstract`

    - `EventLocalServiceUtil`: Event local service utility class which wraps
      `EventLocalServiceImpl` and serves as the primary local access point to
      the service layer. `@generated`

    - `EventLocalServiceWrapper`: Event local service wrapper which implements
      `EventLocalService`. This class is designed to be extended and it allows
      developers to customize the local Event services. Customizing services
      should be done via a hook plugin. `@generated` 

    ![Figure 10.3: Service Builder generates these service classes and interfaces. Only EventLocalServiceImpl allows custom methods to be added to the service layer.](../../images/service-builder-service-diagram.uml.png)

-   Remote Service (only generated for an entity if an entity's `remote-service`
    attribute is set to `true` in `service.xml`)

    - `EventService`: Event remote service interface. `@generated`

    - **`EventServiceImpl`**: Event remote service implementation. This is the
      only class within the remote service that you should modify manually.
      Here, you can write code that adds additional security checks and invokes
      the local services. For any custom methods added here, Service Builder add
      corresponding methods to the `EventService` interface the next time it
      runs.

    - `EventServiceBaseImpl`: Event remote service base implementation. This is
      an abstract class. `@generated` `@abstract`

    - `EventServiceUtil`: Event remote service utility class which wraps
      `EventServiceImpl` and serves as the primary remote access point to the
      service layer. `@generated`

    - `EventServiceWrapper`: Event remote service wrapper which implements
      `EventService`. This class is designed to be extended and it allows
      developers to customize the remote Event services.  Customizing services
      should be done in a hook plugin. `EventServiceImpl` `@generated`

    - `EventServiceSoap`: Event SOAP utility which the remote `EventServiceUtil`
      remote service utility can access. `EventServiceUtil` `@generated`

    - `EventSoap`: Event SOAP model, similar to `EventModelImpl`. `EventSoap` is
      serializable; it does not implement `Event`. `@generated`

    <!-- Is this class obsolete? This class wasn't generated for me during
    testing -->
    - `EventServiceHttp`: HTTP remote service, proxies
      `EventServiceUtil` `@generated`

-   Model

    -   `EventModel`: Event base model interface. This interface and its
        `EventModelImpl` implementation serve only as a container for the
        default property accessors generated by Service Builder. Any helper
        methods and all application logic should be added to `EventImpl`.
        `@generated`

    -   `EventModelImpl`: Event base model implementation. `@generated`

    -   `Event`: Event model interface which extends `EventModel`. `@generated`

    - **`EventImpl`**: Event model implementation. You can use this class to add
      helper methods and application logic to your model. If you don't add any
      helper methods or application logic, only the auto-generated field getters
      and setters will be available. Whenever you add custom methods to this
      class, Service Builder adds corresponding methods to the `Event` interface
      the next time it runs.

    -   `EventWrapper`: Event wrapper, wraps `Event`. `@generated`

    ![Figure 10.3: Service Builder generates these model classes and interfaces. Only EventImpl allows custom methods to be added to the service layer.](../../images/service-builder-model-diagram.uml.png)

Out of all of all the classes generated by Service Builder, only three should be
manually modified: `EventLocalServiceImpl`, `EventServiceImpl` and `EventImpl`.
If you manually modify the other classes, your changes will be overwritten the
next time Service Builder runs.

Each file that Service Builder generates is assembled from an associated
Freemarker template. You can find Service Builder's Freemarker templates in the
`com.liferay.portal.tools.servicebuilder.dependencies` package of Liferay's
`portal-impl/src` folder. For example, if you want to find out how a
`*ServiceImpl.java` file is generated, just look at the `service_impl.ftl`
template.

<!--
Missing transition - Jim
-->

### Writing the Local Service Class 

In the file overview above, notice that `EventLocalService` is the interface for
the local service. It contains the signatures of every method in
`EventLocalServiceBaseImpl` and `EventLocalServiceImpl`.
`EventLocalServiceBaseImpl` contains a few automatically generated methods
providing common functionality. Since this class is generated, you should never
modify it, or your changes will be overwritten the next time you run Service
Builder. Instead, all custom code should be placed in `EventLocalServiceImpl`.

Open the following file:

    /docroot/WEB-INF/src/com/nosester/portlet/eventlisting/service/impl/EventLocalServiceImpl.java

We will add the database interaction methods to this service layer class. Add
the following methods to the `EventLocalServiceImpl` class:

    public Event addEvent(Event event) throws SystemException {
        
        long eventId = counterLocalService.increment(Event.class.getName());
        event.setEventId(eventId);
        
        Date now = new Date();
        event.setCreateDate(now);
        event.setModifiedDate(now);
        
        return super.addEvent(event);
    }

    public Event updateEvent(Event event) throws SystemException {
        
        Date now = new Date();
        event.setModifiedDate(now);
        
        return super.updateEvent(event);
    }

    public List<Event> getEventsByGroupId(long groupId) throws SystemException {
        
        return eventPersistence.findByGroupId(groupId);
    }

    public List<Event> getEventsByGroupId(long groupId, int start, int end) throws SystemException {
        
        return eventPersistence.findByGroupId(groupId, start, end);
    }

    public int getEventsCountByGroupId(long groupId) throws SystemException {
        
        return eventPersistence.countByGroupId(groupId);
    }	

<!--
Mention importing the following, to help clarify from where
the reader should import these classes ...

com.nosester.portlet.eventlisting.model.Event
com.liferay.portal.kernel.exception.SystemException
java.util.Date
java.util.List

- Jim
-->

In order to add an Event to the database, we need an ID for the Event. Liferay
provides a counter service which we call to obtain a unique Id for adding a new
Event. It's possible to use the increment() method of Liferay's
`CounterLocalServiceUtil` class but Service Builder already makes a
CounterLocalService instance available to `EventLocalServiceBaseImpl` by Spring
via dependency injection. Our `EventLocalServiceImpl` class extends
`EventLocalServiceBaseImpl`. See `EventLocalServiceBaseImpl` for a list of all
the beans that Spring makes available for use. These include the following:

- `eventLocalService`
- `eventPersistence`
- `locationLocalService`
- `locationPersistence`
- `counterLocalService`
- `resourceLocalService`
- `resourceService`
- `resourcePersistence`
- `userLocalService`
- `userService`
- `userPersistence`

It's a best practice to use the injected class's increment() method rather than
calling Liferay's `CounterLocalService`'s increment() method since using the
injected class does not require an extra database transaction whereas calling
Liferay's `CounterLocalServiceUtil` class does.

    long eventId = counterLocalService.increment(Event.class.getName());

We use the generated eventId as the eventId of the new Event:

    event.setEventId(eventId);

Next, we set the createDate and modifiedDate of our Event to the current time.
Lastly, we return the Event created by the generated addEvent(...) method of
`EventLocalServiceBaseImpl`.

Note: Our implementation of addEvent(...) is a simple one since we just called
the addEvent(...) method generated in `EventLocalServiceBaseImpl`. We could
overload the addEvent(...) method we added to `EventLocalServiceImpl` by adding
another addEvent(...) method with a different signature: instead of passing an
existing Event to the addEvent(...) method, we could instead pass the required
parameters and call the `eventPersistence` object's create() method to create a
new Event. Then we could use the method's parameters to populate the new Event's
fields and return the Event. (`eventPersistence` is one of the Spring beans
injected into `EventLocalServiceBaseImpl` by Service Builder.) To see this
implementation of addEvent(...), please examine the complete
`EventListingServiceImpl` class
on [Github](https://github.com/liferay/liferay-docs/tree/master/devGuide/code/devGuide-sdk/portlets/event-listing-portlet/docroot/WEB-INF/src/com/nosester/portlet/eventlisting/service/impl/EventLocalServiceImpl.java).

Before you can use any custom methods that you added to `EventLocalServiceImpl`
class, you must add its signature to the `EventLocalService` interface by
running Service Builder again.

***Using Developer Studio:*** As we did before, open your `service.xml` file and
make sure you are in the *Overview* mode. Then, select *Build Services*.

***Using the terminal:*** Navigate to the root directory of your portlet in the
terminal and run:

    ant build-service

Service Builder looks through `EventLocalServiceImpl` and automatically copies
the signatures of each method into the interface. You can now add a new Event to
the database by making the following call:

    EventLocalServiceUtil.addEvent(event);

Of course, we need to create an event before we can make this call. This is one
reason to replace or overload the addEvent(...) we added to
`EventLocalServiceImpl`, which we noted as an option above. In addition to all
of the Java classes, Service Builder also generates a `service.properties` file.
Let's examine that next.

### Calling Local Liferay Services

Once Service Builder has generated our portlet project's services, we can call
them in our portlet classes. We can call any methods of `EventLocalServiceUtil`
or `LocationLocalServiceUtil` in our `EventListingPortlet` and
`LocationListingPortlet` classes. For our example, we'd like the Event Listing
portlet to be able to perform CRUD operations on Events and our Location Listing
portlet to be able to perform CRUD operations on Locations. To this end, we'll
create the following methods for our EventListingPortlet class and similar ones
for our LocationListingPortlet class:

- addEvent
- updateEvent
- deleteEvent

Replace the contents of your `EventListingPortlet.java` file with the following:

    package com.nosester.portlet.eventlisting;

    import java.text.SimpleDateFormat;

    import javax.portlet.ActionRequest;
    import javax.portlet.ActionResponse;

    import com.liferay.portal.kernel.util.ParamUtil;
    import com.liferay.portal.kernel.util.WebKeys;
    import com.liferay.portal.theme.ThemeDisplay;
    import com.liferay.util.bridges.mvc.MVCPortlet;
    import com.nosester.portlet.eventlisting.model.Event;
    import com.nosester.portlet.eventlisting.model.impl.EventImpl;
    import com.nosester.portlet.eventlisting.service.EventLocalServiceUtil;

    public class EventListingPortlet extends MVCPortlet {

        public void addEvent(ActionRequest request, ActionResponse response)
                        throws Exception {

            EventImpl event = new EventImpl();

            event.setEventId(ParamUtil.getLong(request, "eventId"));
            event.setName(ParamUtil.getString(request, "name"));
            event.setDescription(ParamUtil.getString(request, "description"));
            event.setLocationId(ParamUtil.getLong(request, "locationId"));
            
            SimpleDateFormat dateFormat = new SimpleDateFormat();
            event.setDate(ParamUtil.getDate(request, "date", dateFormat));
            
            ThemeDisplay themeDisplay = (ThemeDisplay) request
                            .getAttribute(WebKeys.THEME_DISPLAY);

            event.setUserId(themeDisplay.getUserId());
            event.setCompanyId(themeDisplay.getCompanyId());
            event.setGroupId(themeDisplay.getScopeGroupId());

            EventLocalServiceUtil.addEvent(event);

            sendRedirect(request, response);
        }
            
        public void updateEvent(ActionRequest request, ActionResponse response)
                throws Exception {
            
            long eventId = ParamUtil.getLong(request, "eventId");

            Event event = EventLocalServiceUtil.fetchEvent(eventId);
            
            event.setEventId(ParamUtil.getLong(request, "eventId"));
            event.setName(ParamUtil.getString(request, "name"));
            event.setDescription(ParamUtil.getString(request, "description"));
            event.setLocationId(ParamUtil.getLong(request, "locationId"));
            
            SimpleDateFormat dateFormat = new SimpleDateFormat();
            event.setDate(ParamUtil.getDate(request, "date", dateFormat));
            
            ThemeDisplay themeDisplay = (ThemeDisplay) request
                            .getAttribute(WebKeys.THEME_DISPLAY);

            event.setUserId(themeDisplay.getUserId());
            event.setCompanyId(themeDisplay.getCompanyId());
            event.setGroupId(themeDisplay.getScopeGroupId());	

            EventLocalServiceUtil.updateEvent(event);

            sendRedirect(request, response);
        }

        public void deleteEvent(ActionRequest request, ActionResponse response)
                throws Exception {

            long eventId = ParamUtil.getLong(request, "eventId");

            EventLocalServiceUtil.deleteEvent(eventId);

            sendRedirect(request, response);
        }	

    }

Our Event Listing portlet's add, update, and delete methods call the appropriate
methods of `EventLocalServiceUtil`. The eventFromRequest(...) method is a
convenience method that returns an event from a portlet request, e.g., from the
HTML form fields of the `edit_event.jsp` page. The getter methods of Liferay's
ParamUtil class such as getLong(...) and getString(...) return default values
like `0` or `""` if the specified request parameter is not available from the
portlet request. When adding a new event, for example, no eventId is available
so `ParamUtil.getLong("request", "eventId")` would return `0`. The Event
portlet's addEvent(...) method calls `EventLocalServiceUtil`'s addEvent(...)
method. The eventId for the new event is generated at the service layer in the
addEvent(...) method that we added to the `EventLocalServiceImpl` class. The
`EventLocalServiceUtil` generated for us by Service Builder contains various
CRUD methods including the following:

- `createEvent(...)`
- `addEvent(...)`
- `deleteEvent(...)`
- `updateEvent(...)`
- `fetchEvent(...)`
- `getEvent(...)`

The methods listed in the following figure are all generated by Service Builder
and are available to be called by our Event Listing portlet class.

![Figure 10.4: Our Event Listing portlet class can access these methods of `EventLocalServiceUtil`, many of which enable CRUD operations.](../../images/local-service-util-outline.png)

Portlet classes should only have access to the LocalServiceUtil classes.
LocalServiceUtil classes, in turn, call their injected LocalServiceImpl classes.
Notice in the figure above that `EventLocalServiceUtil` has a private instance
variable called `_service`. `_service` is an instance variable of type
`EventLocalService` which gets an instance of `EventLocalServiceImpl` at runtime
via dependency injection. So all the methods of `EventLocalServiceUtil`
internally call corresponding methods of `EventLocalServiceImpl` at runtime to
perform CRUD operations.

### Writing the Remote Service Class

Many default Liferay services are available as web services. Liferay exposes its
web services via SOAP and JSON web services. If you're running Liferay locally
on port 8080, visit the following URL to browse Liferay's default SOAP web
services:

    http://localhost:8080/api/axis

To browse Liferay's default JSON web services, visit this URL:

    http://localhost:8080/api/jsonws/

These web services APIs can be accessed by many different kinds of clients
including non-portlet and even non-Java clients. You can use Service Builder to
generate similar remote services for your projects' custom entities. When you
run Service Builder with the `remote-service` attribute set to `true` for an
entity, all the classes, interfaces, and files required to support both SOAP and
JSON web services are generated for your entity. Service Builder generates
methods that call existing services but it's up to the developer to implement
the methods that are exposed remotely. Let's use Service Builder to generate
remote services for the Nose-ster Event Listing portlet project's custom
entities. We'll implement a few methods for the Event Listing portlet that can
be called remotely via SOAP or JSON web services.

We implemented our local service methods in `EventLocalServiceImpl`. Similarly,
we'll implement our remote service methods in `EventServiceImpl`. Add the
following methods to your `EventServiceImpl` class:

    public Event addEvent(Event event) throws SystemException {
        
        long eventId = counterLocalService.increment(Event.class.getName());
        event.setEventId(eventId);
        
        Date now = new Date();
        event.setCreateDate(now);
        event.setModifiedDate(now);
        
        return eventLocalService.addEvent(event);
    }
    
    public Event update(Event event) throws SystemException {
        
        Date now = new Date();
        event.setModifiedDate(now);
        
        return eventLocalService.updateEvent(event);
    }	
    
    public Event delete(Event event) throws SystemException {
        
        return eventLocalService.deleteEvent(event);
    }	

    public Event deleteEvent(long eventId) throws PortalException, SystemException {
            
        return eventLocalService.deleteEvent(eventId);
    }

Notice the calls to `eventLocalService`'s add, update, and delete methods.
`eventLocalService` is a Spring bean of type `EventLocalServiceImpl` that's
injected into `EventServiceBaseImpl` by Service Builder. See
`EventServiceBaseImpl` for a complete list of the Spring beans available in
`EventServiceImpl`. These include the following:

- `eventLocalService`
- `eventService`
- `eventPersistence`
- `locationLocalService`
- `locationService`
- `locationPersistence`
- `counterLocalService`
- `resourceLocalService`
- `resourceService`
- `resourcePersistence`
- `userLocalService`
- `userService`
- `userPersistence`

Notice also that we overloaded the deleteEvent(...) method of
`EventServiceImpl`. We did this to simplify our example of calling remote web
services in the next section; it's much simpler to pass an eventId as a
parameter over web services that to pass an entire event object.

After you finish adding imports to `EventServiceImpl`, save the class and run
Service Builder again. In addition to updating the Java classes and interfaces,
Service Builder updates the your project's `/docroot/js/service.js` file so your
custom services can be registered with Liferay. This allows them to be called by custom taglibs and be made available as JSON web services:

    Liferay.Service.register("Liferay.Service.Event", 
    "com.nosester.portlet.eventlisting.service", "event-listing-portlet");

    Liferay.Service.registerClass(
        Liferay.Service.Event, "Event",
        {
                addEvent: true,
                update: true,
                updateEvent: true,
                delete: true
                deleteEvent: true
        }
    )

<!--
Must we create service.js on our own first? I'm not seeing it after building
services from IDE (with Eclipse Juno). -Jim 
-->

Liferay uses Apache Axis to make SOAP web services available. Axis requires a
Web Service Deployment Descriptior (WSDD) to be generated in order to make the
SOAP web services available. Liferay provides a `build-wsdd` Ant target which
generates the WSDD. In Liferay IDE or Developer Studio, when viewing
`service.xml` from the Overview tab, there's a button in the top-right corner of
the screen that's a shortcut for calling the Build WSDD target. Once the WSDD
has been generated and your portlet project has been deployed, a Web Services Definition Language will be available. 

### Calling Remote Liferay Services

To access the WSDL document produced by the `build-wsdd` Ant target in the
previous section, visit the following URL:

    http://localhost:8080/event-listing-portlet/api/axis/Plugin_Event_EventService?wsdl 

This URL lists all of your portlet project's available SOAP web services. Of
course, your portlet project must be deployed for this URL to be available.
Once the WSDL for your SOAP web services is available, many different types of
clients written in different languages can consume your web services. In
production, make sure to integrate your applications with Liferay's permissions
system to implement security checks for all your remote service methods.

You can also call your project's remote Service Builder-generated web services
using the JSON-based protocol. To view the available JSON web-services, visit
the following URL:

    http://localhost:8080/event-listing-portlet/api/jsonws

Whereas you'd need to create a client before invoking a SOAP web service
(alternatively, you could manually craft a URL), you can invoke JSON web
services directly from your browser. To test the JSON web services generated for
your Event Listing portlet project, visit the JSON web services URL for your
portlet listed above and then click on *delete-event*.

![Figure 11.x: You'll see a page displaying the name of the service method, its required parameters, its return type, possible exceptions that can be thrown, and a form for entering the parameter.](../../images/invoking-sb-generated-json-ws.png)

The only parameter we need in order to invoke our remote deleteEvent method is
an eventId. Add an event to the database if you haven't done so already and then
check the Event_Event table in your database for its eventId. Enter the value of
the eventId into the eventId field under the Execute heading and then click
*Invoke*. If your service call succeeded, you should see result of your service
call: the event that was deleted. You can also examine alternate equivalent
methods of calling the same remote service via JavaScript, curl, and URL.

### Custom SQL Queries

Service Builder allows searching for entities via custom SQL queries. For
example, consider our Nose-ster Event Listing portlet project. Suppose we'd like
to add a search form to allow searching for events based on the event's name,
description, and location name. Since the location name is not in the
`Event_Event` table (although the locationId is), we can't implement this kind
of search using the event entity's finder methods. We need to perform a joined
searched across both the `Event_Event` and the `Event_Location` tables. To
accomplish this, we can implement a custom SQL query using the following steps:

1. Create a folder called `custom-sql` in our project's `docroot/WEB-INF/src`
   folder and create a file called `default.xml` in this new folder.

2. Write the SQL query to be used by our custom finder and add it to
   `default.xml`.

3. Create a custom finder class called `EventFinderImpl` extending
   `BasePersistenceImpl`, run Service Builder to generate the required
   `EventFinder` interface and then make `EventFinderImpl` implement
   `EventFinder`.

4. Create a custom finder method in `EventFinderImpl` and run Service Builder
   again to generate a corresponding method in `EventFinderUtil`.

5. Since business logic should only be implemented in service classes and not in
   portlet classes or JSPs, add a finder method to `EventLocalServiceImpl` that
   calls the one created in `EventFinderImpl` and propagated by Service Builder
   to `EventFinderUtil`.
   
6. Run Service Builder a third time to make the custom finder method available
   to `EventLocalServiceUtil`. Portlet classes and JSPs can call
   `EventLocalServiceUtil`'s custom finder method to perform the custom SQL
   query.

In order to use a custom SQL query in our portlet, our first step is to add the
query in the appropriate location in our project. Let's create this file in our
project in the appropriate location: create a folder called `custom-sql` in our
project's `docroot/WEB-INF/src` folder and create the `default.xml` file in this
folder.  Now let's add our custom SQL to this file:

    <?xml version="1.0" encoding="UTF-8"?>
    <custom-sql>
        <sql id="com.nosester.portlet.eventlisting.service.persistence.EventFinder.findByEventNameEventDescriptionLocationName">
            SELECT Event_Event.*
            FROM Event_Event
            INNER JOIN 
                Event_Location ON Event_Event.locationId = Event_Location.locationId
            WHERE
                (Event_Event.name LIKE ?) AND
                (Event_Event.description LIKE ?) AND
                (Event_Location.name LIKE ?)
        </sql>
    </custom-sql>

Notice that the SQL query we define in `default.xml` has a unique id. It's
possible to define multiple SQL queries in `default.xml` so long as each one has
a unique id. Liferay has a class called `CustomSQLUtil` with methods that
retrieve SQL queries by id.

Next, we need to create a custom finder class. This class should be created in
the `com.nosester.portlet.eventlisting` package of our project's
`docroot/WEB-INF/src` folder. This package was created by Service Builder. The
class we create should extend
`com.liferay.portal.service.persistence.impl.BasePersistenceImpl<Event>`. For
our example, we'll create a class called `EventFinderImpl` in this folder with
the following contents:

    package com.nosester.portlet.eventlisting.service.persistence;

    import com.liferay.portal.service.persistence.impl.BasePersistenceImpl;
    import com.nosester.portlet.eventlisting.model.Event;

    public class EventFinderImpl extends BasePersistenceImpl<Event> {

    }

Once you've created this class, run Service Builder again. Service Builder
generates `EventFinder` interface and the `EventFinderUtil` class for us in our
project's `docroot/WEB-INF/service` folder. After running Service Builder again,
make your `EventFinderImpl` class implement the generated `EventFinder`
interface:

    public class EventFinderImpl extends BasePersistenceImpl<Event> implements EventFinder {

    }

Make sure not to forget this step! Now we can create our custom query method in
our `EventFinderImpl` class:

    public List<Event> findByEventNameEventDescriptionLocationName(String eventName, String eventDescription, String locationName, int begin, int end) {
                
        Session session = null;
        try {
            session = openSession();

            String sql = CustomSQLUtil.get(FIND_BY_EVENTNAME_EVENTDESCRIPTON_LOCATIONNAME);
            
            SQLQuery q = session.createSQLQuery(sql);
            q.setCacheable(false);
            q.addEntity("Event_Event", EventImpl.class);

            QueryPos qPos = QueryPos.getInstance(q);  
            qPos.add(eventName);
            qPos.add(eventDescription);
            qPos.add(locationName);
            
            return (List<Event>) QueryUtil.list(q, getDialect(), begin, end);
        } catch (Exception e) {
            try {
                throw new SystemException(e);
            } catch (SystemException se) {
                se.printStackTrace();
            }
        } finally {
            closeSession(session);
        }

        return null;
    }	

    public static final String FIND_BY_EVENTNAME_EVENTDESCRIPTON_LOCATIONNAME = EventFinder.class.getName() + ".findByEventNameEventDescriptionLocationName";

In this custom finder method, we open a new Hibernate session and use Liferay's
`CustomSQLUtil`'s `get(String id)` method to get the custom SQL to use for the
database query. The `FIND_BY_EVENTNAME_EVENTDESCRIPTON_LOCATIONNAME` string
contains the id of our custom SQL query. We define the
`FIND_BY_EVENTNAME_EVENTDESCRIPTON_LOCATIONNAME` string based on the name of the
`EventFinder` class and the name of the finder method.

So far, we have created a `EventFinderImpl` class and generated a
`EventFinderUtil` class. However, our Event Listing portlet class cannot use the
`EventFinderUtil` class directly; only a local (`EventLocalServiceImpl`) or
remote (`EventServiceImpl`) service class can. This encourages a proper
separation of concerns: since only the service classes should contain a
portlet's business logic, finders should not be directly accessed by portlet
classes. A portlet should be able to call the finders only indirectly through
the Util classes which wrap the \*ServiceImpl classes. Add the following method
to `EventLocalServiceImpl`:

    public List<Event> findByEventNameEventDescriptionLocationName(String eventName, String eventDescription, String locationName, 
        int begin, int end) throws SystemException {
		
    return EventFinderUtil.findByEventNameEventDescriptionLocationName(eventName, eventDescription, locationName, begin, end);
    }	

Run Service Builder after adding this method to generate the interface and make
this finder method available in `EventLocalServiceUtil`. Now we can indirectly
call this finder method from our portlet class or from a JSP by calling
`EventLocalServiceUtil.findByEventNameEventDescriptionLocationName(...)`.

### Overview of `portlet-model-hints.xml`

Service Builder generates a number of XML configuration files in your project's
`docroot/WEB-INF/src/META-INF` folder. Service Builder uses most of these files
to manage Spring and Hibernate configurations. Don't modify the Spring or
Hibernate configuration files; your changes will be overwritten the next time
Service Builder runs. However, there's one configuration file that you can
safely edit which allows you to customize details of your Service Builder
generated models: `portlet-model-hints.xml`. This file allows you to configure
how model fields are displayed using the `aui` taglib. It also allows you to
adjust the size of the columns of database tables. Liferay has its own model
hints XML configuration file called `portal-model-hints.xml` which you can find
in Liferay's `portal-impl/classes/META-INF` folder. Liferay's model hints
configuration file contains many hint examples so you can refer to it for
reference when customizing your `portlet-model-hints.xml`.

Examine your project's `docroot/WEB-INF/src/META-INF/portlet-model-hints.xml`
file. If you're following the Event Listing portlet example, Service Builder
should have created the file with the following contents:

    <?xml version="1.0"?>

    <model-hints>
        <model name="com.nosester.portlet.eventlisting.model.Event">
            <field name="eventId" type="long" />
            <field name="companyId" type="long" />
            <field name="groupId" type="long" />
            <field name="userId" type="long" />
            <field name="createDate" type="long" />
            <field name="modifiedDate" type="long" />
            <field name="name" type="String" />
            <field name="description" type="String" />
            <field name="date" type="Date />
            <field name="locationId" type="long" />
        </model>
        <model name="com.nosester.portlet.eventlisting.model.Location">
            <field name="locationId" type="long" />
            <field name="companyId" type="long" />
            <field name="groupId" type="long" />
            <field name="userId" type="long" />
            <field name="createDate" type="long" />
            <field name="modifiedDate" type="long" />
            <field name="name" type="String" />
            <field name="description" type="String" />
            <field name="streetAddress" type="String" />
            <field name="city" type="String" />
            <field name="stateOrProvince" type="String" />
            <field name="country" type="String" />
        </model>
    </model-hints>

Your `portlet-model-hints.xml` file has a root-level model-hints tag that
contains model tags. Each model tag must have a name attribute specifying the
full package name of the model class. Each model tag must also contain a field
name for attribute of the model specifying the field name and type as
attributes. To add hints to a field, add a hint tag inside of a field tag,
specify the hint's name as an attribute and the value of the hint within in the
hint tag. For example, the display-width hint allows you to specify the width of
a model's field as it appears on an AUI form. The default is 350. To specify a
display-width of 50 pixels for the Event model's name field, replace the `<field
name="name" type="String" />` line with the following:

    <field name="name" type="String">
        <hint name="display-width">50</hint>
    </field>

In order to see the effect of the display-width hint on the Event model's name
field, you have to run Service Builder again and redeploy your portlet project.
Changing the display-width doesn't actually limit the number of characters that
can be entered into the name field; it's just a way to control the width of the
AUI input form field. To configure the maximum size of a model field's database
column (i.e., the maximum number of characters that can be saved in the field),
use the max-length hint. The default max-length is 75. If you'd like to allow
Event names of up to 100 characters to be saved, add another hint element inside
of your name field element:

    <field name="name" type="String">
        <hint name="display-width">50</hint>
        <hint name="max-length">100</hint>
    </field>

Remember to run Service Builder and redeploy your portlet project after updating
`portlet-model-hints.xml`. To test your max length setting, add a new event with
a name consisting of between 75 and 100 characters. The following table
describes some commonly used model hints.

**Model Hint Values and Descriptions**

Name | Value Type | Description | Default
:--: | :--------: | :---------: | :-----:
auto-escape | boolean | sets whether text values should be escaped via HtmlUtil.escape | true
day-nullable | boolean | allows the day to be null in a date field | false
default-value | String | sets the default value for a field | (empty String)
display-height | integer | sets the display height of the form field rendered using the aui taglib | 15
display-width | integer | sets the display width of the form field rendered using the aui taglib | 350
max-length | integer | sets the maximum column size for SQL file generation | 75
month-nullable | boolean | allows the month to be null in a date field | false
upper-case | boolean | converts all characters to upper case | false
year-nullable | boolean | allows the year to be null in a date field | false
year-range-delta | integer | specifies the number of years to display from today's date in a date field rendered with the aui taglib | 5

You can use the default-hints element to define a list of hints to be applied to
every field of a model. For example, adding the following element inside of a
model element applies a display-width of 300 to each element of the model:

    <default-hints>
        <hint name="display-width">300</hint>
    </default-hints>

You can define hint-collection elements inside of the model-hints element to
define a list of hints that can applied together. A hint collection must be
specified with a name. Model fields can apply a hint collection by referring to
the hint collection's name. For example, Liferay's `portal-model-hints.xml`
defines the following hint collections:

    <hint-collection name="CLOB">
        <hint name="max-length">2000000</hint>
    </hint-collection>
    <hint-collection name="URL">
        <hint name="max-length">4000</hint>
    </hint-collection>
    <hint-collection name="TEXTAREA">
        <hint name="display-height">105</hint>
        <hint name="display-width">500</hint>
        <hint name="max-length">4000</hint>
    </hint-collection>
    <hint-collection name="SEARCHABLE-DATE">
        <hint name="month-nullable">true</hint>
        <hint name="day-nullable">true</hint>
        <hint name="year-nullable">true</hint>
        <hint name="show-time">false</hint>
    </hint-collection>

If you define the same SEARCHABLE-DATE collection as above, you can apply it to
your Event model's date field by using a hint-collection element:

    <field name="date" type="Date">
        <hint-collection name="SEARCHABLE-DATE" />
    </field>

Remember to run Service Builder and redeploy your project after updating your
`portlet-model-hints.xml` file.

### Overview of `service.properties`

Service Builder generates the properties file `service.properties` in the `src`
directory of your service. Liferay Portal uses the properties in this file to
alter your service's database schema and load Spring configuration files to
support deployment of your service. You should not modify this file, but rather
make any necessary overrides in a `service-ext.properties` file in the `src`
folder.

The only property that you may need to override from this file is
`build.auto.upgrade`. Setting `build.auto.upgrade=false` in your
`service-ext.properties` prevents Liferay from trying to automatically apply any
changes to the database model when a new version of the plugin is deployed. This
is needed in projects in which it is preferred to manually manage the changes to
the database or in which the SQL schema has been modified manually after
generation by Service Builder.

Other properties included in the `service.properties` file include the
following:

- `build.namespace`: This is the namespace you defined in
  `docroot/WEB-INF/service.xml`. Liferay distinguishes different plugins from
  each other using their namespaces.
- `build.number`: Liferay distinguishes different builds of your plugin. Each
  time a distinct build of your plugin is deployed to Liferay, Liferay
  increments this number.
- `build.date`: This is the time of the latest build of your plugin.
- `spring.configs`: This is a comma-delimited list of Spring configurations. If
  you'd like to alter this list or the any of the values in
  `service.properties`, don't edit `service.properties` directly. Instead,
  create a `service-ext.properties`. The values for the properties that you
  define there will override the ones in `service.properties`.
- `include-and-override`: The default value of this property defines
  `service-ext.properties` as an override file for `service.properties`.

### Built-In Liferay Services 

In addition to the services you create using Service Builder, your portlets may
also access a variety of services built into Liferay. These include the
following:

- `UserService`

- `OrganizationService`

- `GroupService`

- `CompanyService`

- `ImageService`

- `LayoutService`

- `PermissionService`

- `UserGroupService`

- `RoleService`

For more information on these services, see Liferay's Javadocs at
[http://docs.liferay.com/portal/6.1/javadocs/](http://docs.liferay.com/portal/6.1/javadocs/).
