# Service Builder 

Service Builder is a model-driven code generation tool built by Liferay that
allows developers to define custom object models called entities. Service
Builder generates a service layer through Object-Relational Mapping (ORM)
technology that provides a clean separation between your object model and code
for the underlying database. This frees you to add the necessary business logic
for your application. Service Builder takes an XML file (usually called
`service.xml`) as input and generates the necessary model, persistence, and
service layers for your application. These layers provide a clean separation of
concerns. Service Builder generates most of the common code needed to implement
find, create, update, and delete operations on the database, allowing you to
focus on the higher level aspects of service design.

The service layer generated by Service Builder contains an implementation class
that is responsible for retrieving and storing data classes and adding the
necessary business logic around them. This layer can optionally be composed of
two layers: a local service layer and a remote service layer. The local service
contains the business logic and accesses the persistence layer. It can be
invoked by client code running in the same Java Virtual Machine. The remote
service usually has additional code to check security and is meant to be
accessible from anywhere over the Internet or your local network. Service
Builder automatically generates the code necessary to allow access to the remote
services using SOAP, JSON, and Java RMI.

## Benefits of Using Service Builder

Service Builder solves an important portal problem. In a standalone web
application, the database access code can be bundled with the rest of the
application. However, in a portal, web applications are often composed of
multiple portlets that need to access the same data and the same application
logic. Separate web applications (i.e., separate WARs) have separate class
loaders and it's normally difficult to share data and application logic across
class loader boundaries. Service Builder allows different portlets to access the
same data and application logic by creating an underlying framework that's
designed to support a portal environment.

The code generated by Service Builder exists within a single plugin but can
easily be shared across all portlets. This code, bundled in a service JAR,
includes a single database access service layer that eliminates the need to
manage extra database connections or worry about code synchronization between
portlets. Using a database single access layer allows the use of caching. Since
there is only one data reader/writer, there is no need to worry about cached
data becoming obsolete. If updates need to be made to your web application's
service layer, Service Builder can generate a new service JAR with which you can
replace the old one without needing to restart your application server.

Using Service Builder can save developers lots of time since it completely
eliminates the need to write and maintain database access code. The database
access code generated by Service Builder is database-agnostic, as is Liferay
itself. Developers using Service Builder just need to create or edit a
`service.xml` file and run Service Builder to generate a new service JAR for
their project. The service JAR generated by Service Builder includes a model
layer, a persistence layer, a service layer, and related infrastructure. Service
Builder uses Spring for dependency injection and Hibernate for object-relational
mapping but it hides the complexities of using these technologies. The remote
services generated by Service Builder include SOAP utilities and can be accessed
via SOAP, JSON, and Java RMI. Although the number of files generated by Service
Builder can seem intimidating at first, developers only need to work with a few
files in order to make customizations and add business logic.

Originally, Service Builder was built when Liferay used Enterprise Java Beans
(EJBs) for everything. Back then, using EJBs, making even simple changes often
required editing many XML configuration files and Java classes. Service Builder
has evolved since then to use Spring and Hibernate, gaining a lot a flexibility
and allowing changes to be made very simply--in many cases, all that's required
is a change to `service.xml` and a re-run of Service Builder. Liferay isn't a
generic code generation tool; it's specifically designed to meet the needs of
Liferay and Liferay plugin developers. Service Builder may not be the best tool
for everyone but it provides a great degree of consistency to any plugin
developed with it.

In summary, we encourage developers to use Service Builder because it solves the
class loader issue for separate web applications and saves development time.
It's also the technology used to generated Liferay's internal database
persistence code. However, you don't have to use Service Builder for plugin or
portlet development. It's entirely possible to develop plugins by writing custom
code for database persistence using your persistence framework of choice, such
as JPA, Hibernate, or Ibatis. If you're inclined to take this approach, just
remember that you'll have to solve the problem of sharing services across
classloaders on your own. You'll also have to implement your own
object-relational mapping solution as well as Spring configuration, if you'd
like to use Spring for dependency injection. Finally, if you intend to use a
service-oriented architecture for your custom services, you'll have to manually
create the interfaces for your Impl-classes to implement that Service Builder
could have auto-generated for you. You'll also have to manually keep your
interfaces and Impl-classes in sync. Next, let's roll up our sleeves and learn
how to use Service Builder.

## Configuring Service Builder and Defining Portlet Data

In order to demonstrate how to use Service Builder, let's create an example
portlet project that the Nose-ster organization can use to schedule social
events. For our example, we'll create a new Liferay portlet project for managing
and listing events. We'll define two entities called *events* and *locations*,
representing events that can be scheduled and locations at which the events can
take place. Since events take place at specific locations, an event entity
should be able to take a location entity as an attribute. If you'd like to
examine the finished example project, you can view the code on Github
[https://github.com/liferay/liferay-docs/tree/master/devGuide/code/devGuide-sdk/portlets/event-listing-portlet](https://github.com/liferay/liferay-docs/tree/master/devGuide/code/devGuide-sdk/portlets/event-listing-portlet)
or download the `.war` file from
[https://github.com/liferay/liferay-docs/tree/master/devGuide/code/devGuide-sdk/dist/event-listing-portlet-6.2.0.1.war](https://github.com/liferay/liferay-docs/tree/master/devGuide/code/devGuide-sdk/dist/event-listing-portlet-6.2.0.1.war).
But we'll guide you through creating the project, its portlets, and its entities
step-by-step using Liferay IDE/Developer Studio. 

---

 ![Tip](../../images/tip-pen-paper.png)**Note:** If you're actually looking for
 a portlet application that can manage events, please consider using Liferay's
 Calendar portlet. The example described in this section is only intended to
 demonstrate how to use Service Builder. The Calendar portlet provides many more
 features than the simple example application described here. For information
 about the Calendar portlet, please refer to the chapter on Liferay's
 collaboration suite in [Using Liferay
 Portal](http://www.liferay.com/documentation/liferay-portal/6.1/user-guide).

---

Liferay portlet projects can contain multiple portlets. We'll create two
portlets in our event-listing-portlet project: an Event Listing portlet and a
Location Listing portlet. These portlets will allow users to add, edit, or
remove events or locations, display lists of events or locations, search for
particular events or locations, and view the details of individual events or
locations. We'll start by creating the Event Listing portlet in a new portlet
plugin project. 

To follow this example, create a new Liferay portlet project in your Liferay
Plugins SDK using Liferay IDE or Developer Studio. Go to *File* &rarr; *New
Liferay Project* and a wizard will appear. We'll use this wizard to create both
the event-listing-portlet project and the Event Listing portlet. After we finish
with the first wizard, we'll use a second wizard to create a second portlet in
this project, the Location Listing portlet. Here's some key information
to specify for the event-listing-portlet project in the first wizard:

- Project name: *event-listing-portlet*
- Display name: *Event Listing*
- Project type: *Portlet*
- Portlet framework: *Liferay MVC*
- Create custom portlet class: *yes*

After you flag the *Create custom portlet class* checkbox, the rest of the
wizard lets you specify details about the Event Listing portlet class:

- Portlet class: *EventListingPortlet*
- Java package: *com.nosester.portlet.eventlisting*
- Superclass: *com.liferay.util.bridges.mvc.MVCPortlet*
- Portlet name: *eventlisting*
- Display name: *Event Listing Portlet*
- Title: *Event Listing Portlet*
- Portlet modes: *View*
- Create JSP files: yes
- Create resources bundle file: *yes*
- Category: *Sample*

Flagging the checkbox for creating a resource bundle file creates a file for
adding different language translations for your portlet's textual display
values. Leave the portlet's category set to *Sample*, then click *Finish* to
create your Liferay portlet plugin project and the Event Listing portlet.

Next, we'll create a second portlet in the event-listing-portlet project.
Select the project in the Package Explorer and then select *File* &rarr; *New*
&rarr; *Liferay Portlet*. We'll call the second portlet the Location Listing
portlet. Creating the Location Listing portlet in the IDE is similar to how you
created the Event Listing portlet. Only the portlet class name and a few other
name values will be different.

Here is a summary of the values to specify in the Liferay Portlet wizard for
creating the Location Listing portlet:

- Portlet class: *LocationListingPortlet*
- Java package: *com.nosester.portlet.eventlisting*
- Superclass: *com.liferay.util.bridges.mvc.MVCPortlet*
- Portlet name: *locationlisting*
- Display name: *Location Listing Portlet*
- Title: *Location Listing Portlet*
- Portlet modes: *View*
- Create JSP files: *yes*
- Create resources bundle file: *yes*
- Category: *Sample*

After you've finished using the second wizard to create the Location Listing
portlet, expand your project's `docroot/WEB-INF/src` folder and the
`com.nosester.portlet.eventlisting` package. Notice that Liferay IDE created the
`EventListingPortlet.java` and `LocationListingPortlet.java` files in this
package. We'll add some business logic to these portlet classes after using
Service Builder to create a service layer for our event and location entities.

The first step in using Service Builder is to define your model classes and
their attributes in a `service.xml` file in your project's `docroot/WEB-INF`
folder. In Service Builder terminology, your model classes (events and
locations) are called entities. We've kept the requirements for our event and
location entities fairly simple. Events should have the attributes specified in
the following table:

**Event Attributes**

Attribute | Attribute Type | Attribute Description
:------------: | :------------: | :-------------------
`name` | String | The name of the event
`description` | String | A description of the event
`date` | Date | The date and time the event takes place
`locationId` | long | An event takes place at a location and we use a location Id to specify the location

Locations should have the attributes specified in the following table:

**Location Attributes**

Attribute | Attribute Type | Attribute Description
:------------: | :------------: | :-------------------
`name` | String | The name of the location
`description` | String | A description of the location
`streetAddress` | String | The street address of the location
`city` | String | The city of the location
`stateOrProvince` | String | The state or province of the location
`country` | String | The country of the location

Let's create a `service.xml` file for our project and specify our services and
their entities. Liferay IDE makes it easy.

To create a `service.xml` file for your project, use the following steps: 

1.  Create the `service.xml` file in your project's `docroot/WEB-INF` folder.

2.  Define global information for the service.

3.  Define service entities. 

4.  Define the columns (attributes) for each service entity.

5.  Define relationships between entities.

6.  Define a default order for entities to be retrieved from the database.

7.  Define finder methods that retrieve objects from the database using
    specified parameters.

<!--
8.  Provide the means to associate an asset and tags. //AssetEntry and AssetTag
See sample-service-builder-portlet. - Jim
-->

Let's start creating our service by using Liferay IDE to create a `service.xml`
file. 

### Step 1: Create the `service.xml` file

To define a service for your portlet project, you must create a `service.xml`
file. The DTD (Document Type Declaration) file
[http://www.liferay.com/dtd/liferay-service-builder_6_1_0.dtd](http://www.liferay.com/dtd/liferay-service-builder_6_1_0.dtd)
specifies the format and requirements of the XML to use in `service.xml`. You
can create your `service.xml` file manually, following the DTD, or you can use
Liferay IDE. Liferay IDE helps you build `service.xml` piece-by-piece and takes
the guesswork out of creating XML that adheres to the DTD. For our tutorial,
we'll use Liferay IDE to build the `service.xml` file.

To create `service.xml` using Liferay IDE, select your `event-listing-portlet`
project in the Package Explorer and then select *File* &rarr; *New* &rarr;
*Liferay Service Builder*. Service Builder creates a `service.xml` file in your
`docroot/WEB-INF/src` folder and displays the file in overview mode.

Liferay IDE also provides a diagram mode and a source mode for `service.xml`.
Diagram mode is helpful for creating and visualizing relationships between
service entities. Source mode brings up the `service.xml` file's raw XML content
in the editor. You can switch between these modes as you wish. Since overview
mode facilitates creating service elements, we'll use it throughout most of the
steps in creating our service.

Let's start filling out the global information for our service next. 

### Step 2: Define global service information

A service's global information applies to all of its entities. So, let's specify
this information first. Select the *Service Builder* node in the upper left
corner of the overview mode of `service.xml`. The main section of our view now
shows the Service Builder form in which we can enter our service's global
information. The fields include the service's package path, author, and
namespace options. Here are the values we'll use for our example:

- Package path: *com.nosester.portlet.eventlisting*
- Auto namespace tables: *no*
- Author: [your name]
- Namespace: *Event*

The *package path* specifies the package in which the service and persistence
classes will be generated. For our example, enter
`com.nosester.portlet.eventlisting` for the package path. This assures that the
service classes will be generated in the `com.nosester.portlet.eventlisting`
package under the `docroot/WEB-INF/service` folder. The persistence classes will
be generated in a package of that name under the `docroot/WEB-INF/src` folder.
The complete file paths for the service and persistence classes will be
`docroot/WEB-INF/service/com/nosester/portlet/eventlisting` and
`docroot/WEB-INF/src/com/nosester/portlet/eventlisting`, respectively. Please
refer to next section, *Generating the Services*, for a description of the
contents of these packages. 

Service Builder uses the service *namespace* in naming the database tables it
generates for the service. Enter *Event* as the namespace for your example
service. Service Builder uses the namespace in the following SQL scripts it
generates in our `docroot/WEB-INF/sql` folder: 

- `indexes.sql`
- `sequences.sql`
- `tables.sql`

Liferay Portal uses these scripts to create database tables for all the entities
we've defined in `service.xml`. Service Builder prepends the namespace to the
database table names. Since our namespace value is `Event`, the names of the
database tables created for our entities will start with `Event_`. The namespace
for each Service Builder project must be unique. Separate plugins should use
separate namespaces and should not use a namespace already used by Liferay (such
as `Users` or `Groups`). Check the table names of Liferay's database if you're
wondering whether or not a namespace is already in use.

As the last piece of global information, enter your name as the *author* in
`service.xml`. Service Builder adds `@author` annotations with the specified
name to all of the generated Java classes and interface. Save your `service.xml`
file to preserve the information you added. Next, we'll add entities for our
service's events and locations. 

### Step 3: Define service entities

Entities are the heart and soul of a service. Entities represent the models
created, modified, and persisted for the service. For our example, we'll create
two entities--one for events and one for locations. 

Here's a summary of the information we'll enter for the Event entity:

- Name: *Event*
- Local service: *yes*
- Remote service: *yes* 

And here's what we'll enter for the Location entity:

- Name: *Location*
- Local service: *yes*
- Remote service: *yes* 

To create these entities, select the *Entities* node from under the Service
Builder node in the outline on the left side of the overview mode of
`service.xml`. In the main part of the view, notice that the Entities table is
empty. Create an entity by clicking on the *add icon* (a green plus sign) to the
right of the table. Enter *Event* for your entity's name and select both the
*Local Service* and the *Remote Service* options. Create a second entity named
`Location`, and select the *Local Service* and the *Remote Service* options
for it too. 

![Figure 4.1: Adding service entities is easy with Liferay IDE's *Overview* mode of `service.xml`](../../images/service-add-entity.png)

An entity's name is used in naming the database table for persisting instances
of it. The actual name of the database table is prefixed with the namespace; so
in our example, we'll have one database table named `Event_Event` and another
named `Event_Location`. 

Setting the *local service* attribute to `true` instructs Service Builder to
generate local interfaces for our entity's service. The default value for
local service is `false`. However, the generated service will reside in our
portlet's `.war` file and our portlet will be deployed to our Liferay server. So
the service will be local from our Liferay server's point of view.

Setting the *remote service* attribute to `true` instructs Service Builder to
generate remote interfaces for the service. The default value for remote service
is `true`. We could build a fully-functional event listing application without
generating remote services so we could set local service to `true` and remote
service to `false` for both of our entities. However, since we want to
demonstrate how to use the web services that Service Builder generates for our
entities, we'll set both local service and remote service to `true`.

---

 ![Tip](../../images/tip-pen-paper.png) **Tip:** Suppose you have an existing
 DAO service for an entity built using some other framework such as JPA or
 JingDAO. You can set local service to `false` and remote service to `true` so
 that the methods of your remote Impl class can call the methods of your
 existing DAO. This enables your entity to integrate with Liferay's permission
 checking system and provides access to the web service APIs generated by
 Service Builder. This is a very handy, quite powerful, and often used feature
 of Liferay. 

---

Now that we've created our Event and Location entities, let's describe their
attributes using entity columns. 

### Step 4: Define the columns (attributes) for each service entity

Each entity is described by its columns, which represent attributes. For our
example, we'll add attributes for both our Event and Location entities. To add
attributes for our Event entity, we need to drill down to its columns in the
overview mode outline of `service.xml`. From the outline, expand the *Entities*
node and expand the new *Event* entity node. Then, select the *Columns* node.
Liferay IDE displays a table of the Event entity's columns. 

Service Builder creates database columns per each column we add to the
`service.xml` file. It maps a database value type appropriate to the Java type
specified for each column. Hibernate handles the object-relational mapping.
Accessors in the model class are automatically generated for these attributes.
The Name column specifies the name used in the getters and setters that are
created for the entity's Java field. The Type column indicates the Java type of
this field for the entity. If a column's Primary (i.e., primary key) attribute
value is set to `true`, then the column becomes part of the primary key for the
entity. An entity's primary key is a unique identifier for the entity. If only
one column has Primary set to `true`, then that column represents the entire
primary key for the entity. This is the case in our example. However, it's
possible to use multiple columns as the primary key for an entity. In this case,
the combination of columns makes up a compound key for the entity.

Similar to the way we used the form table for adding entities, we'll add
attribute columns for our entities as follows:

**Event attribute columns**

  Name        | Type   | Primary
:-----------: | :----: | :------:
`eventId`     | long   | yes
`name`        | String | no
`description` | String | no
`date`        | Date   | no
`locationId`  | long   | no

**Location attribute columns**

  Name            | Type   | Primary
:---------------: | :----: | :------:
`locationId`      | long   | yes
`name`            | String | no
`description`     | String | no
`streetAddress  ` | String | no
`city`            | String | no
`stateOrProvince` | String | no
`country`         | String | no

Create each attribute by clicking on the *add* icon. Then fill in the name of
the attribute, select its type, and specify whether it is a primary key for the
entity. Note, while your cursor is in a column's *Type* field, an option icon
shows within field. Click this icon to select the appropriate type for the
column. Create a column for each attribute of our Event entity. Repeat similar
steps to create columns for each attribute of our Location entity. 

In addition to columns for your entity's primary key and attributes, it's always
worthwhile to consider including columns for site ID and portal instance ID.
They allow your portlet to support the multi-tenancy features of Liferay so that
each portal instance and each site within a portal instance can have independent
sets of portlet data. To hold the site's ID, add a column called `groupId` of
type `long`. To hold the portal instance's ID, add a column called `companyId`
of type `long`. Add both of these columns to our Event and Location entities.

**Portal and site scope columns**

  Name      | Type   | Primary
:---------: | :----: | :------:
`companyId` | long   | no
`groupId`   | long   | no

Lastly, let's add columns to help audit both of our Event and Location entities.
Add a column named `createDate` of type `Date` to note the date an entity
instance was created. And add a column named `modifiedDate` of type `Date` to
track the last time an entity instance was modified.

**Audit columns**

  Name         | Type   | Primary
:------------: | :----: | :------:
`createDate`   | Date   | no
`modifiedDate` | Date   | no

Great! Our entities are set with the columns that not only represent their
attributes, but also support multi-tenancy, and entity auditing. Next, we'll
specify the relationship between our Event entity and Location entity. 

### Step 5: Define relationships between service entities

Often you'll want to reference one type of entity in the context of another
entity. That is, you'll want to *relate* the entities. We'll show you how to do
this in our example event listing portlet. 

As we mentioned earlier for our example, each of our event entities must have a
location. Therefore, each Event entity must relate to a Location entity. The
good news is that Liferay IDE's *Diagram* mode for `service.xml` makes relating
entities very easy. First, select *Diagram* mode for our `service.xml`. Then,
select the *Relationship* option under *Connections* in the palette on the right
side of the view. This relationship tool, helps you draw relationships between
entities in the diagram. Click the Event entity and move your cursor over the
Location entity. Liferay IDE draws a dashed line from the Event entity to the
cursor. Click the Location entity to complete drawing the relationship. Liferay
IDE turns the dashed line into a solid line, with an arrow pointing to the
Location entity. Save the `service.xml` file. 

![Figure 4.2: Relating entities is a snap in Liferay IDE's *Diagram* mode for `service.xml`.](../../images/service-builder-relate-entities.png)

Switch to *Source* mode in `service.xml` and note that Liferay IDE created a
column element for a location ID in the Event entity:

     <column name="locationId" type="long"></column>

Now that our entity columns are in place, let's specify a default order for the
entity instances retrieved from the database. 

### Step 6: Define ordering of service entity instances

Often, you'll want to list multiple instances of a given entity. And you may
want to list them in a particular order. Liferay lets you specify a default
ordering for each entity in your `service.xml` file. We'll demonstrate using the
Event Listing portlet. 

For our example, we want to return Event entities in order by date, earliest to
latest. And we want to return Location entities alphabetically by name. It's
easy to specify these default orderings using Liferay IDE. Switch back to
*Overview* mode in `service.xml`. Then, select the *Order* node under the
*Event* entity node in the outline on the left side of the view. The IDE
displays a form for ordering the Event entity. Select the *Specify ordering*
checkbox to show the form for specifying the ordering. Create an order column by
clicking the *add icon* (a green plus sign) to the right of the table. Enter
*date* for the column name to use in ordering the Event entity. Click the
*Browse icon* to the right of the By field and choose the *asc* option. This
orders the Event entity by ascending date. To specify a Location entity
ordering, follow similar steps but specify *name* as the column and *asc* as the
*select by* value. 

The last thing do for our service entities is define the finder methods for
retrieving them from the database. 

### Step 7: Define service entity finder methods

Finder methods retrieve entity objects from the database based on specified
parameters. You'll probably want to create at least one finder method for each
entity you create in your services. Service Builder generates several methods
based on each finder you create for an entity. It creates methods to fetch,
find, remove, and count entity instances based on the parameters of each finder.

For our example, we want to find Event and Location entities per site. We'll
specify these finders using Liferay IDE's overview mode of `service.xml`. Select
the *Finders* node under the Event entity node in the outline on the left side
of the screen. The IDE displays an empty *Finders* table in the main part of the
view. Create a new finder by clicking the *add icon* (a green plus sign) to the
right of the table. Name the finder *GroupId* and enter *Collection* as its
return type. We use the Java camel-case naming convention in naming finders
since the finder's name will be used in the names of the methods Service Builder
creates. The IDE creates a new *GroupId* node under the *Finders* node in the
outline. We'll specify the finder column for this group ID node next. 

Under the new *GroupId* node, the IDE created a *Finder Columns* node. Select
*Finder Columns* node to specify the columns for our finder's parameters. Create
a new finder column by clicking the *add icon* (a green plus sign) and
specifying the column name *groupId*. Keep in mind that you can specify multiple
parameters (columns) for a finder. We're keeping things simple by specifying
finders for entities by site only. Follow similar steps to create a finder to
retrieve Location entities by `groupId`. Save the `service.xml` file to preserve
the new finders. 

When we run Service Builder, it will generate finder-related methods
(`fetchByGroupId`, `findByGroupId`, `removeByGroupId`, `countByGroupId`) for our
Event and Location entities in `-Persistence` and `-PersistenceImpl` classes.
The first of these classes is the interface, the second is its implementation.
Our entities finder methods will be generated in the following classes for our
Event and Location entities: 

- `/docroot/WEB-INF/service/com/nosester/portlet/eventlisting/service/persistence/*Persistence.java`
- `/docroot/WEB-INF/src/com/nosester/portlet/eventlisting/service/persistence/*PersistenceImpl.java`

Terrific! You've created the service and its event and location entities for the
event listing portlet.

We've posted the source code for the service to
[https://github.com/liferay/liferay-docs/tree/master/devGuide/code/devGuide-sdk/portlets/event-listing-portlet/docroot/WEB-INF/service.xml](https://github.com/liferay/liferay-docs/tree/master/devGuide/code/devGuide-sdk/portlets/event-listing-portlet/docroot/WEB-INF/service.xml).
But we've also listed it here for your convenience. Note, we've added some
comments to highlight the service's various elements. But your `service.xml`
should look similar to this one: 

    <?xml version="1.0" encoding="UTF-8"?>
    <!DOCTYPE service-builder PUBLIC "-//Liferay//DTD Service Builder 6.1.0//EN" "http://www.liferay.com/dtd/liferay-service-builder_6_1_0.dtd">
    <service-builder package-path="com.nosester.portlet.eventlisting">
        <author>Joe Bloggs</author>
        <namespace>Event</namespace>

        <entity name="Event" local-service="true" remote-service="true">

            <!-- PK fields -->

            <column name="eventId" type="long" primary="true" />

            <!-- Audit fields -->

            <column name="companyId" type="long" />
            <column name="groupId" type="long" />
            <column name="userId" type="long" />
            <column name="createDate" type="long" />
            <column name="modifiedDate" type="long" />

            <!-- Other fields -->

            <column name="name" type="String" />
            <column name="description" type="String" />
            <column name="date" type="Date" />
            <column name="locationId" type="long" />

            <!-- Order -->

            <order by="asc">
                    <order-column name="date" />
            </order>

            <!-- Finder methods -->

            <finder name="GroupId" return-type="Collection">
                    <finder-column name="groupId" />
            </finder>
        </entity>

        <entity name="Location" local-service="true" remote-service="true">

            <!-- PK fields -->

            <column name="locationId" type="long" primary="true" />

            <!-- Audit fields -->

            <column name="companyId" type="long" />
            <column name="groupId" type="long" />
            <column name="userId" type="long" />
            <column name="createDate" type="Date" />
            <column name="modifiedDate" type="Date" />

            <!-- Other fields -->

            <column name="name" type="String" />
            <column name="description" type="String" />
            <column name="streetAddress" type="String" />
            <column name="city" type="String" />
            <column name="stateOrProvince" type="String" />
            <column name="country" type="String" />
            
            <!-- Order -->

            <order by="asc">
                    <order-column name="name" />
            </order>

            <!-- Finder methods -->

            <finder name="GroupId" return-type="Collection">
                    <finder-column name="groupId" />
            </finder>
        </entity>
    </service-builder>

Now that you've specified the service for the event listing portlet, let's build
the service by running Service Builder. Then we'll take a closer look at the
code it generates.

## Generating the Services

To build a service using our `service.xml`, you can either use *Liferay IDE* or
*Liferay Developer Studio* or use a terminal window.

***Using Liferay IDE or Developer Studio:*** From the *Package Explorer*, open
the `service.xml` file found in your `event-listing-portlet/docroot/WEB-INF`
folder. By default, the file opens up in the *Service Builder Editor*. Make sure
you are in *Overview* mode. Then, click on the *Build Services* button at the
top right corner of the window. The *Build Services* button has an image of a
document with numerical sequence *0101* in front of it. 

Make sure to click on the *Build Services* button as opposed to the *Build WSDD*
button that appears next to it. Building the WSDDs won't hurt anything, but
you'll be wondering where all the generated files are for your service. For
information about WSDDs (web service deployment descriptors), please refer to
the section on remote Liferay services later in this chapter. 

![Figure 4.3: The *Overview* mode in the editor provides a nested outline which you can expand, a form for editing basic Service Builder attributes, and buttons for building services or building web service deployment descriptors.](../../images/service-xml-overview.png)

After running Service Builder, your Plugins SDK prints messages listing the
generated files and a message stating `BUILD SUCCESSFUL`. We'll discuss these
files in detail later on in this section. 

***Using the terminal:*** Open a terminal window, navigate to your
`portlets/event-listing-project-portlet` directory, and enter this command:

    ant build-service

When the service has been successfully generated, a `BUILD SUCCESSFUL` message
appears in your terminal window. You should also see that a large number of
files have been generated in your project.

Let's examine the files Service Builder generated for your Event entity. Note
that the files listed under Local Service and Remote Service below are only
generated for an entity which has `local-service` and `remote-service`
attributes set to `true`, respectively. Service Builder generates services for
these entities to two locations in your project. These locations incorporate the
the package path that you specified in `service.xml`:

- `docroot/WEB-INF/service/com/nosester/portlet/eventlisting`
- `docroot/WEB-INF/src/com/nosester/portlet/eventlisting`

The `docroot/WEB-INF/service/com/nosester/portlet/eventlisting/` package
contains utility classes and interfaces for the Event Listing project.  All of
the classes and interfaces in the service folder are packaged in a `.jar` file
called `event-listing-project-portlet-service.jar` in your `docroot/WEB-INF/lib`
folder. This `.jar` file is generated each time you run Service Builder. It's
possible to place this `.jar` file on your application server's global classpath
to make your project's services available to other projects. This allows
portlets in different project, for example, to create, update, and delete Events
and Locations. Of course, you should consider the security implications of
placing your project's service `.jar` on your application server's global
classpath: do you *really* want to allow other plugins to access your project's
services? 

The `docroot/WEB-INF/src/com/nosester/portlet/eventlisting` package contains the
implementation of the interfaces defined in the
`docroot/WEB-INF/service/com/nosester/portlet/eventlisting` package. It belongs
to the Event Listing project's classpath but is not available outside of the
Event Listing project. Service Builder generates classes and interfaces
belonging to the persistence layer, service layer, and model layer in the
`docroot/WEB-INF/service/com/nosester/portlet/eventlisting` and
`docroot/WEB-INF/src/com/nosester/portlet/eventlisting` packages. Let's take a
closer look at the classes and interfaces generated for Events. The ones
generated for Locations are similar.

-   Persistence
    - `EventPersistence`: Event persistence interface which defines CRUD methods
      for the Event entity such as `create`, `remove`, `countAll`, `find`,
      `findAll`, etc. `@generated`
    - `EventPersistenceImpl`: Event persistence implemenation class which
      implements `EventPersistence`. `@generated`
    - `EventUtil`: Event persistence utility class which wraps
      `EventPersistenceImpl` and provides direct access to the database for CRUD
      operations. This utility should only be used by the service layer; in your
      portlet classes, use `EventLocalServiceUtil` or `EventServiceUtil`
      instead. `@generated`

    ![Figure 4.4: Service Builder generates these persistence classes and interfaces. You shouldn't (and won't need to) customize any of these classes or interfaces.](../../images/service-builder-persistence-diagram.uml.png)

-   Local Service (only generated for an entity if an entity's `local-service`
    attribute is set to `true` in `service.xml`)
    - `EventLocalService`: Event local service interface. `@generated`
    - **`EventLocalServiceImpl`**: Event local service implementation. This is
      the only class within the local service that you should modify manually.
      You can add custom business logic here. For any custom methods added here,
      Service Builder adds corresponding methods to the `EventLocalService`
      interface the next time you run it.
    - `EventLocalServiceBaseImpl`: Event local service base implementation. This
      is an abstract class. Service Builder injects a number of instances of
      various service and persistence classes into this class. `@generated`
      `@abstract`
    - `EventLocalServiceUtil`: Event local service utility class which wraps
      `EventLocalServiceImpl` and serves as the primary local access point to
      the service layer. `@generated`
    - `EventLocalServiceWrapper`: Event local service wrapper which implements
      `EventLocalService`. This class is designed to be extended and it allows
      developers to customize the local Event services. Customizing services
      should be done via a hook plugin. `@generated` 

    ![Figure 4.5: Service Builder generates these service classes and interfaces. Only EventLocalServiceImpl allows custom methods to be added to the service layer.](../../images/service-builder-service-diagram.uml.png)

-   Remote Service (only generated for an entity if an entity's `remote-service`
    attribute is set to `true` in `service.xml`)
    - `EventService`: Event remote service interface. `@generated`
    - **`EventServiceImpl`**: Event remote service implementation. This is the
      only class within the remote service that you should modify manually.
      Here, you can write code that adds additional security checks and invokes
      the local services. For any custom methods added here, Service Builder
      adds corresponding methods to the `EventService` interface the next time
      you run it. 
    - `EventServiceBaseImpl`: Event remote service base implementation. This is
      an abstract class. `@generated` `@abstract`
    - `EventServiceUtil`: Event remote service utility class which wraps
      `EventServiceImpl` and serves as the primary remote access point to the
      service layer. `@generated`
    - `EventServiceWrapper`: Event remote service wrapper which implements
      `EventService`. This class is designed to be extended and it allows
      developers to customize the remote Event services.  Customizing services
      should be done in a hook plugin. `EventServiceImpl` `@generated`
    - `EventServiceSoap`: Event SOAP utility which the remote `EventServiceUtil`
      remote service utility can access. `EventServiceUtil` `@generated`
    - `EventSoap`: Event SOAP model, similar to `EventModelImpl`. `EventSoap` is
      serializable; it does not implement `Event`. `@generated`

-   Model
    - `EventModel`: Event base model interface. This interface and its
      `EventModelImpl` implementation serve only as a container for the default
      property accessors generated by Service Builder. Any helper methods and
      all application logic should be added to `EventImpl`. `@generated`
    - `EventModelImpl`: Event base model implementation. `@generated`
    - `Event`: Event model interface which extends `EventModel`. `@generated`
    - **`EventImpl`**: Event model implementation. You can use this class to add
      helper methods and application logic to your model. If you don't add any
      helper methods or application logic, only the auto-generated field getters
      and setters will be available. Whenever you add custom methods to this
      class, Service Builder adds corresponding methods to the `Event` interface
      the next time you run it.
    - `EventWrapper`: Event wrapper, wraps `Event`. `@generated`

    ![Figure 4.6: Service Builder generates these model classes and interfaces. Only `EventImpl` allows custom methods to be added to the service layer.](../../images/service-builder-model-diagram.uml.png)

Each file that Service Builder generates is assembled from an associated
Freemarker template. You can find Service Builder's Freemarker templates in the
`com.liferay.portal.tools.servicebuilder.dependencies` package of Liferay's
`portal-impl/src` folder. For example, if you want to find out how a
`-ServiceImpl.java` file is generated, just look at the `service_impl.ftl`
template.

Out of all of all the classes generated by Service Builder, only three should be
manually modified: `EventLocalServiceImpl`, `EventServiceImpl` and `EventImpl`.
If you manually modify the other classes, your changes will be overwritten the
next time you run Service Builder. Next, let's add some local service methods to
`EventLocalServiceImpl` and learn how to call them. After that, we'll add
some remote service methods to `EventServiceImpl` and learn how to invoke them.

## Writing the Local Service Class 

The heart of your service is its `-LocalServiceImpl` class. Within it, you put
core business logic for working with your model. Throughout this chapter, we've
been constructing services for the Nose-ster Event Listing portlet. We'll start
by examining the initial service classes we generated for it using Service
Builder. 

Note that Service Builder created an `EventLocalService` class which is is the
interface for the local service. It contains the signatures of every method in
`EventLocalServiceBaseImpl` and `EventLocalServiceImpl`.
`EventLocalServiceBaseImpl` contains a few automatically generated methods
providing common functionality. Since this class is generated, you should never
modify it, or your changes will be overwritten the next time you run Service
Builder. Instead, all custom code should be placed in `EventLocalServiceImpl`.

Open the following file:

    /docroot/WEB-INF/src/com/nosester/portlet/eventlisting/service/impl/EventLocalServiceImpl.java

Add the following database interaction methods to the `EventLocalServiceImpl`
class:

    public Event addEvent(Event event) throws SystemException {
        
        long eventId = counterLocalService.increment(Event.class.getName());
        event.setEventId(eventId);
        
        Date now = new Date();
        event.setCreateDate(now);
        event.setModifiedDate(now);
        
        return super.addEvent(event);
    }

    public Event updateEvent(Event event) throws SystemException {
        
        Date now = new Date();
        event.setModifiedDate(now);
        
        return super.updateEvent(event);
    }

    public List<Event> getEventsByGroupId(long groupId) throws SystemException {
        
        return eventPersistence.findByGroupId(groupId);
    }

    public List<Event> getEventsByGroupId(long groupId, int start, int end) throws SystemException {
        
        return eventPersistence.findByGroupId(groupId, start, end);
    }

    public int getEventsCountByGroupId(long groupId) throws SystemException {
        
        return eventPersistence.countByGroupId(groupId);
    }	

Remember to import the required classes. These include the following:

    com.nosester.portlet.eventlisting.model.Event
    com.liferay.portal.kernel.exception.SystemException
    java.util.Date
    java.util.List

In order to add an Event to the database, we need an ID for the Event. Liferay
provides a counter service which we call to obtain a unique ID for adding a new
entities. It's possible to use the `increment` method of Liferay's
`CounterLocalServiceUtil` class but Service Builder already makes a
`CounterLocalService` instance available to `EventLocalServiceBaseImpl` by
Spring via dependency injection. Since our `EventLocalServiceImpl` class extends
`EventLocalServiceBaseImpl`, we can access this `CounterLocalService` instance.
See `EventLocalServiceBaseImpl` for a list of all the beans that Spring makes
available for use. These include the following:

- `eventLocalService`
- `eventPersistence`
- `locationLocalService`
- `locationPersistence`
- `counterLocalService`
- `resourceLocalService`
- `resourceService`
- `resourcePersistence`
- `userLocalService`
- `userService`
- `userPersistence`

It's a best practice to use the injected class's `increment` method rather than
calling Liferay's `CounterLocalService`'s `increment` method since using the
injected class does not require an extra database transaction. Calling Liferay's
`CounterLocalServiceUtil` class, on the other hand, does require an extra
database transaction. 

    long eventId = counterLocalService.increment(Event.class.getName());

We use the generated `eventId` as the ID for the new Event:

    event.setEventId(eventId);

Next, we set the `createDate` and `modifiedDate` of our Event to the current time.
Lastly, we return the Event created by the generated `addEvent` method of
`EventLocalServiceBaseImpl`.

Note: Our `addEvent` method only sets the creation data and modified date of the
Event. It doesn't populate its name and description, or associate a location with
it. We could overload `addEvent` by creating another `addEvent` method that
takes name, description, and a location ID as parameters. In this method, we
could call the `eventPersistence` object's `create` method to create a new
Event. Then we could use the method's parameters to populate the new Event's
name, description, and a location ID fields and return the Event.
(`eventPersistence` is one of the Spring beans injected into
`EventLocalServiceBaseImpl` by Service Builder.) To see this implementation of`
addEvent`, please examine the complete `EventListingServiceImpl` class
on [Github](https://github.com/liferay/liferay-docs/tree/master/devGuide/code/devGuide-sdk/portlets/event-listing-portlet/docroot/WEB-INF/src/com/nosester/portlet/eventlisting/service/impl/EventLocalServiceImpl.java).

Before you can use any custom methods that you added to `EventLocalServiceImpl`
class, you must add its signature to the `EventLocalService` interface by
running Service Builder again.

***Using Developer Studio:*** As we did before, open your `service.xml` file and
make sure you are in the *Overview* mode. Then, select *Build Services*.

***Using the terminal:*** Navigate to the root directory of your portlet in the
terminal and run:

    ant build-service

Service Builder looks through `EventLocalServiceImpl` and automatically copies
the signatures of each method into the interface. You can now add a new Event to
the database by making the following call:

    EventLocalServiceUtil.addEvent(event);

Of course, we need to create an event before we can make this call. This is one
reason to replace or overload the `addEvent` method we added to
`EventLocalServiceImpl`, which we noted as an option above. In addition to all
of the Java classes, Service Builder also generates a `service.properties` file
which we'll examine later in this chapter. Next, let's call our newly
implemented local service. 

## Calling Local Liferay Services

Once Service Builder has generated our portlet project's services, we can call
them in our project's `-Portlet` classes. We can call any methods of
`EventLocalServiceUtil` or `LocationLocalServiceUtil` in our
`EventListingPortlet` and `LocationListingPortlet` classes. For our example,
we'd like the Event Listing portlet to be able to perform CRUD operations on
Events and our Location Listing portlet to be able to perform CRUD operations on
Locations. To this end, we'll create the following methods for our
`EventListingPortlet` class and similar ones for our `LocationListingPortlet`
class:

- `addEvent`
- `updateEvent`
- `deleteEvent`

Replace the contents of your `EventListingPortlet.java` file with the following:

    package com.nosester.portlet.eventlisting;

    import java.text.SimpleDateFormat;

    import javax.portlet.ActionRequest;
    import javax.portlet.ActionResponse;

    import com.liferay.portal.kernel.util.ParamUtil;
    import com.liferay.portal.kernel.util.WebKeys;
    import com.liferay.portal.theme.ThemeDisplay;
    import com.liferay.util.bridges.mvc.MVCPortlet;
    import com.nosester.portlet.eventlisting.model.Event;
    import com.nosester.portlet.eventlisting.model.impl.EventImpl;
    import com.nosester.portlet.eventlisting.service.EventLocalServiceUtil;

    public class EventListingPortlet extends MVCPortlet {

        public void addEvent(ActionRequest request, ActionResponse response)
                        throws Exception {

            EventImpl event = new EventImpl();

            event.setEventId(ParamUtil.getLong(request, "eventId"));
            event.setName(ParamUtil.getString(request, "name"));
            event.setDescription(ParamUtil.getString(request, "description"));
            event.setLocationId(ParamUtil.getLong(request, "locationId"));
            
            SimpleDateFormat dateFormat = new SimpleDateFormat();
            event.setDate(ParamUtil.getDate(request, "date", dateFormat));
            
            ThemeDisplay themeDisplay = (ThemeDisplay) request
                            .getAttribute(WebKeys.THEME_DISPLAY);

            event.setUserId(themeDisplay.getUserId());
            event.setCompanyId(themeDisplay.getCompanyId());
            event.setGroupId(themeDisplay.getScopeGroupId());

            EventLocalServiceUtil.addEvent(event);

            sendRedirect(request, response);
        }
            
        public void updateEvent(ActionRequest request, ActionResponse response)
                throws Exception {
            
            long eventId = ParamUtil.getLong(request, "eventId");

            Event event = EventLocalServiceUtil.fetchEvent(eventId);
            
            event.setEventId(ParamUtil.getLong(request, "eventId"));
            event.setName(ParamUtil.getString(request, "name"));
            event.setDescription(ParamUtil.getString(request, "description"));
            event.setLocationId(ParamUtil.getLong(request, "locationId"));
            
            SimpleDateFormat dateFormat = new SimpleDateFormat();
            event.setDate(ParamUtil.getDate(request, "date", dateFormat));
            
            ThemeDisplay themeDisplay = (ThemeDisplay) request
                            .getAttribute(WebKeys.THEME_DISPLAY);

            event.setUserId(themeDisplay.getUserId());
            event.setCompanyId(themeDisplay.getCompanyId());
            event.setGroupId(themeDisplay.getScopeGroupId());	

            EventLocalServiceUtil.updateEvent(event);

            sendRedirect(request, response);
        }

        public void deleteEvent(ActionRequest request, ActionResponse response)
                throws Exception {

            long eventId = ParamUtil.getLong(request, "eventId");

            EventLocalServiceUtil.deleteEvent(eventId);

            sendRedirect(request, response);
        }	

    }

Your Event Listing portlet's `addEvent`, `updateEvent`, and `deleteEvent`
methods now call the appropriate methods of `EventLocalServiceUtil`. The getter
methods of Liferay's ParamUtil class such as `getLong` and `getString` return
default values like `0` or `""` if the specified request parameter is not
available from the portlet request. When adding a new event, for example, no
event ID is available so `ParamUtil.getLong("request", "eventId")` returns `0`.
The Event portlet's `addEvent` method calls `EventLocalServiceUtil`'s `addEvent`
method. The event ID for the new event is generated at the service layer in the
`addEvent` method that we added to the `EventLocalServiceImpl` class. The
`EventLocalServiceUtil` generated for us by Service Builder contains various
CRUD methods including the following:

- `createEvent`
- `addEvent`
- `deleteEvent`
- `updateEvent`
- `fetchEvent`
- `getEvent`

The methods listed in the following figure are all generated by Service Builder
and are available to be called by our Event Listing portlet class.

![Figure 4.7: Our Event Listing portlet class can access these methods of `EventLocalServiceUtil`, many of which enable CRUD operations.](../../images/local-service-util-outline.png)

Portlet classes should only have access to the `-LocalServiceUtil` classes.
`-LocalServiceUtil` classes, in turn, call their injected `-LocalServiceImpl` classes.
Notice in the figure above that `EventLocalServiceUtil` has a private instance
variable called `_service`. `_service` is an instance variable of type
`EventLocalService` which gets an instance of `EventLocalServiceImpl` at runtime
via dependency injection. So all the methods of `EventLocalServiceUtil`
internally call corresponding methods of `EventLocalServiceImpl` at runtime to
perform CRUD operations.

<!-- Consider removing this or moving it. - Jim

## Invoking the API Locally 

Each service provides a local interface to clients running in the same JVM as
Liferay Portal. There are two ways to invoke a service API's methods: 

- Spring injection: If your application uses Spring and has access to the portal
context. 

- `-ServiceUtil` classes: These classes mask the complexity of service
implementations. This is a good option if you're not familiar with Spring. 

Let's invoke a service using its `-ServiceUtil` class. The following JSP code
snippet demonstrates how to get a list of the most recent bloggers from an
organization. 

    <%@ page import="com.liferay.portlet.blogs.service.BlogsStatsUserLocalServiceUtil" %>
    <%@ page import="com.liferay.portlet.blogs.util.comparator.StatsUserLastPostDateComparator" %>
    ...
    <%@
    List statsUsers = BlogsStatsUserLocalServiceUtil.getOrganizationStatsUsers(
        organizationId, 0, max, new StatsUserLastPostDateComparator());
    %>

This JSP code invokes the static method `getOrganizationStatsUsers()` from the
`-LocalServiceUtil` class `BlogsStatsUserLocalServiceUtil`. 

---

![note](../../images/tip-pen-paper.png) **Note:** Permission checks are not
performed when you invoke services locally (i.e., from the same JVM that's
Liferay Portal runs on). To ensure permission checks are performed, use the
remote variant of the API, even from a local context. 

---

-->

<!-- I don't believe the above tip is true anymore. If the -ServiceUtil class
uses the filterFindBy implementation, permission checks are performed. -Rich --> 

<!--
Next, find out how you can invoke Liferay's service APIs remotely.
-->

## Writing the Remote Service Class

Many default Liferay services are available as web services. Liferay exposes its
web services via SOAP and JSON web services. If you're running Liferay locally
on port 8080, visit the following URL to browse Liferay's default SOAP web
services:

    http://localhost:8080/api/axis

To browse Liferay's default JSON web services, visit this URL:

    http://localhost:8080/api/jsonws/

These web services APIs can be accessed by many different kinds of clients
including non-portlet and even non-Java clients. You can use Service Builder to
generate similar remote services for your projects' custom entities. When you
run Service Builder with the `remote-service` attribute set to `true` for an
entity, all the classes, interfaces, and files required to support both SOAP and
JSON web services are generated for your entity. Service Builder generates
methods that call existing services, but it's up to you to implement
the methods that are exposed remotely. Let's use Service Builder to generate
remote services for the Nose-ster Event Listing portlet project's custom
entities. We'll implement a few methods for the Event Listing portlet that can
be called remotely via SOAP and JSON web services.

We implemented our local service methods in `EventLocalServiceImpl`. Similarly,
we'll implement our remote service methods in `EventServiceImpl`. Add the
following methods to your `EventServiceImpl` class:

    public Event addEvent(Event event) throws SystemException {
        
        long eventId = counterLocalService.increment(Event.class.getName());
        event.setEventId(eventId);
        
        Date now = new Date();
        event.setCreateDate(now);
        event.setModifiedDate(now);
        
        return eventLocalService.addEvent(event);
    }
    
    public Event update(Event event) throws SystemException {
        
        Date now = new Date();
        event.setModifiedDate(now);
        
        return eventLocalService.updateEvent(event);
    }	
    
    public Event delete(Event event) throws SystemException {
        
        return eventLocalService.deleteEvent(event);
    }	

    public Event deleteEvent(long eventId) throws PortalException, SystemException {
            
        return eventLocalService.deleteEvent(eventId);
    }

Notice the calls to `eventLocalService`'s `addEvent`, `updateEvent`, and
`deleteEvent` methods. `eventLocalService` is a Spring bean of type
`EventLocalServiceImpl` that's injected into `EventServiceBaseImpl` by Service
Builder. See `EventServiceBaseImpl` for a complete list of the Spring beans
available in `EventServiceImpl`. These include the following:

- `eventLocalService`
- `eventService`
- `eventPersistence`
- `locationLocalService`
- `locationService`
- `locationPersistence`
- `counterLocalService`
- `resourceLocalService`
- `resourceService`
- `resourcePersistence`
- `userLocalService`
- `userService`
- `userPersistence`

Notice also that we overloaded the `deleteEvent` method of
`EventServiceImpl`. We did this to simplify our example of calling remote web
services in the next section; it's much more efficient to pass an event ID as a
parameter over web services than to pass an entire event object.

After you finish adding imports to `EventServiceImpl`, save the class, and run
Service Builder again. 

Liferay uses Apache Axis to make SOAP web services available. Axis requires a
Web Service Deployment Descriptor (WSDD) to be generated in order to make the
SOAP web services available. Liferay provides a `build-wsdd` Ant target which
generates the WSDD. In Liferay IDE or Developer Studio, when viewing
`service.xml` from the Overview tab, there's a button in the top-right corner of
the screen that's a shortcut for calling the Build WSDD target. Liferay Portal
makes your service's Web Services Definition Language (WSDL) available after
you've built its WSDD and deployed your portlet project. Let's learn how to call
our remote services next. 

## Calling Remote Liferay Services

After you've built your portlet project's WSDDs and deployed the project as a
plugin, its services are available on the portal server. If you've been
implementing the Nose-ster Event Listing example portlet used throughout this
chapter, you'll be anxious to try out its remote web services. First, let's see
what remote web services it has available.

To list your Nose-ster Event Listing plugin's SOAP web services, go to the
following URL: 

    http://localhost:8080/event-listing-portlet/api/axis

Liferay portal lists the services available for all of your entities and
provides links to each of their WSDL documents. Clicking on the WSDL link for
your Event service takes you to the following URL: 

    http://localhost:8080/event-listing-portlet/api/axis/Plugin_Event_EventService?wsdl 

This WSDL document lists all of the Event entity's SOAP web services. Once your
SOAP web service's WSDL is available, any SOAP web service client can access it.
In production, make sure to integrate your applications with Liferay's
permissions system to perform security checks for all your remote service
methods.

You can also call your plugin's remote Service Builder-generated web services
using the JSON-based protocol. To view the JSON web services available for your
Event Listing plugin, visit the following URL:

    http://localhost:8080/event-listing-portlet/api/jsonws

Each entity's available operations are listed on the plugin's JSON web services
API page. You can invoke JSON web services directly from your browser. For
example, bring up a test form for your Event entity's *delete-event* operation
and click on its link. 

![Figure 4.8: You'll see a page displaying the name of the service method, its required parameters, its return type, possible exceptions it can throw, and a form for entering its parameters.](../../images/invoking-sb-generated-json-ws.png)

The only parameter required for the `delete-event` operation is a event ID.
Since we haven't covered creating the UI for adding our Event entities, you
probably don't have any events in your database. But if you did, you could check
for an event's ID in your `Event_Event` database table. Then you could enter the
value into the *eventId* field in the *Execute* section of the test page and
click *Invoke* to delete that event. Liferay returns feedback from the
invocation. 

Finding a portlet's web services is easy with Liferay's SOAP and JSON web
service. Invoking a portlet's web services via Liferay's JSON web service
interface is a great way to test them. You can also examine alternate equivalent
methods of calling the SOAP and JSON web services via JavaScript, curl, and
URLs. Next, we'll consider how to implement custom SQL queries in your portlet,
so you can easily leverage information from multiple entity types. 

## Custom SQL Queries

Service Builder allows searching for entities via custom SQL queries. For
example, consider our Nose-ster Event Listing portlet project. Suppose we'd like
to add a search form to allow searching for events based on the event's name,
description, and location name. Since the location name is not in the
`Event_Event` table (although the locationId is), we can't implement this kind
of search using the event entity's finder methods. We need to perform a joined
searched across both the `Event_Event` and the `Event_Location` tables. To
accomplish this, we can implement a custom SQL query using the following steps:

1. Create a folder called `custom-sql` in our project's `docroot/WEB-INF/src`
   folder and create a file called `default.xml` in this new folder.

2. Write the SQL query to be used by our custom finder and add it to
   `default.xml`.

3. Create a custom finder class called `EventFinderImpl` extending
   `BasePersistenceImpl`, run Service Builder to generate the required
   `EventFinder` interface and then make `EventFinderImpl` implement
   `EventFinder`.

4. Create a custom finder method in `EventFinderImpl` and run Service Builder
   again to generate a corresponding method in `EventFinderUtil`.

5. Since business logic should only be implemented in service classes and not in
   portlet classes or JSPs, add a finder method to `EventLocalServiceImpl` that
   calls the one created in `EventFinderImpl` and propagated by Service Builder
   to `EventFinderUtil`.
   
6. Run Service Builder a third time to make the custom finder method available
   to `EventLocalServiceUtil`. Portlet classes and JSPs can call
   `EventLocalServiceUtil`'s custom finder method to perform the custom SQL
   query.

In order to use a custom SQL query in our portlet, our first step is to add the
query in the appropriate location in our project. Let's create this file in our
project in the appropriate location: create a folder called `custom-sql` in our
project's `docroot/WEB-INF/src` folder and create the `default.xml` file in this
folder.  Now let's add our custom SQL to this file:

    <?xml version="1.0" encoding="UTF-8"?>
    <custom-sql>
        <sql id="com.nosester.portlet.eventlisting.service.persistence.EventFinder.findByEventNameEventDescriptionLocationName">
            SELECT Event_Event.*
            FROM Event_Event
            INNER JOIN 
                Event_Location ON Event_Event.locationId = Event_Location.locationId
            WHERE
                (Event_Event.name LIKE ?) AND
                (Event_Event.description LIKE ?) AND
                (Event_Location.name LIKE ?)
        </sql>
    </custom-sql>

Notice that the SQL query we define in `default.xml` has a unique id. It's
possible to define multiple SQL queries in `default.xml` so long as each one has
a unique id. Liferay has a class called `CustomSQLUtil` with methods that
retrieve SQL queries by id.

Next, we need to create a custom finder class. This class should be created in
the `com.nosester.portlet.eventlisting` package of our project's
`docroot/WEB-INF/src` folder. This package was created by Service Builder. The
class we create should extend
`com.liferay.portal.service.persistence.impl.BasePersistenceImpl<Event>`. For
our example, we'll create a class called `EventFinderImpl` in this folder with
the following contents:

    package com.nosester.portlet.eventlisting.service.persistence;

    import com.liferay.portal.service.persistence.impl.BasePersistenceImpl;
    import com.nosester.portlet.eventlisting.model.Event;

    public class EventFinderImpl extends BasePersistenceImpl<Event> {

    }

Once you've created this class, run Service Builder again. Service Builder
generates `EventFinder` interface and the `EventFinderUtil` class for us in our
project's `docroot/WEB-INF/service` folder. After running Service Builder again,
make your `EventFinderImpl` class implement the generated `EventFinder`
interface:

    public class EventFinderImpl extends BasePersistenceImpl<Event> implements EventFinder {

    }

Make sure not to forget this step! Now we can create our custom query method in
our `EventFinderImpl` class:

    public List<Event> findByEventNameEventDescriptionLocationName(String eventName, String eventDescription, String locationName, int begin, int end) {
                
        Session session = null;
        try {
            session = openSession();

            String sql = CustomSQLUtil.get(FIND_BY_EVENTNAME_EVENTDESCRIPTON_LOCATIONNAME);
            
            SQLQuery q = session.createSQLQuery(sql);
            q.setCacheable(false);
            q.addEntity("Event_Event", EventImpl.class);

            QueryPos qPos = QueryPos.getInstance(q);  
            qPos.add(eventName);
            qPos.add(eventDescription);
            qPos.add(locationName);
            
            return (List<Event>) QueryUtil.list(q, getDialect(), begin, end);
        } catch (Exception e) {
            try {
                throw new SystemException(e);
            } catch (SystemException se) {
                se.printStackTrace();
            }
        } finally {
            closeSession(session);
        }

        return null;
    }	

    public static final String FIND_BY_EVENTNAME_EVENTDESCRIPTON_LOCATIONNAME = EventFinder.class.getName() + ".findByEventNameEventDescriptionLocationName";

In this custom finder method, we open a new Hibernate session and use Liferay's
`CustomSQLUtil`'s `get(String id)` method to get the custom SQL to use for the
database query. The `FIND_BY_EVENTNAME_EVENTDESCRIPTON_LOCATIONNAME` string
contains the id of our custom SQL query. We define the
`FIND_BY_EVENTNAME_EVENTDESCRIPTON_LOCATIONNAME` string based on the name of the
`EventFinder` class and the name of the finder method.

So far, we have created a `EventFinderImpl` class and generated a
`EventFinderUtil` class. However, our Event Listing portlet class cannot use the
`EventFinderUtil` class directly; only a local (`EventLocalServiceImpl`) or
remote (`EventServiceImpl`) service class can. This encourages a proper
separation of concerns: since only the service classes should contain a
portlet's business logic, finders should not be directly accessed by portlet
classes. A portlet should be able to call the finders only indirectly through
the Util classes which wrap the \*ServiceImpl classes. Add the following method
to `EventLocalServiceImpl`:

    public List<Event> findByEventNameEventDescriptionLocationName(String eventName, String eventDescription, String locationName, 
        int begin, int end) throws SystemException {
		
    return EventFinderUtil.findByEventNameEventDescriptionLocationName(eventName, eventDescription, locationName, begin, end);
    }	

Run Service Builder after adding this method to generate the interface and make
this finder method available in `EventLocalServiceUtil`. Now we can indirectly
call this finder method from our portlet class or from a JSP by calling
`EventLocalServiceUtil.findByEventNameEventDescriptionLocationName(...)`.

## Overview of `portlet-model-hints.xml`

Service Builder generates a number of XML configuration files in your project's
`docroot/WEB-INF/src/META-INF` folder. Service Builder uses most of these files
to manage Spring and Hibernate configurations. Don't modify the Spring or
Hibernate configuration files; your changes will be overwritten the next time
Service Builder runs. However, there's one configuration file that you can
safely edit which allows you to customize details of your Service Builder
generated models: `portlet-model-hints.xml`. This file allows you to configure
how model fields are displayed using the `aui` taglib. It also allows you to
adjust the size of the columns of database tables. Liferay has its own model
hints XML configuration file called `portal-model-hints.xml` which you can find
in Liferay's `portal-impl/classes/META-INF` folder. Liferay's model hints
configuration file contains many hint examples so you can refer to it for
reference when customizing your `portlet-model-hints.xml`.

Examine your project's `docroot/WEB-INF/src/META-INF/portlet-model-hints.xml`
file. If you're following the Event Listing portlet example, Service Builder
should have created the file with the following contents:

    <?xml version="1.0"?>

    <model-hints>
        <model name="com.nosester.portlet.eventlisting.model.Event">
            <field name="eventId" type="long" />
            <field name="companyId" type="long" />
            <field name="groupId" type="long" />
            <field name="userId" type="long" />
            <field name="createDate" type="long" />
            <field name="modifiedDate" type="long" />
            <field name="name" type="String" />
            <field name="description" type="String" />
            <field name="date" type="Date />
            <field name="locationId" type="long" />
        </model>
        <model name="com.nosester.portlet.eventlisting.model.Location">
            <field name="locationId" type="long" />
            <field name="companyId" type="long" />
            <field name="groupId" type="long" />
            <field name="userId" type="long" />
            <field name="createDate" type="long" />
            <field name="modifiedDate" type="long" />
            <field name="name" type="String" />
            <field name="description" type="String" />
            <field name="streetAddress" type="String" />
            <field name="city" type="String" />
            <field name="stateOrProvince" type="String" />
            <field name="country" type="String" />
        </model>
    </model-hints>

Your `portlet-model-hints.xml` file has a root-level model-hints tag that
contains model tags. Each model tag must have a name attribute specifying the
full package name of the model class. Each model tag must also contain a field
name for attribute of the model specifying the field name and type as
attributes. To add hints to a field, add a hint tag inside of a field tag,
specify the hint's name as an attribute and the value of the hint within in the
hint tag. For example, the display-width hint allows you to specify the width of
a model's field as it appears on an AUI form. The default is 350. To specify a
display-width of 50 pixels for the Event model's name field, replace the `<field
name="name" type="String" />` line with the following:

    <field name="name" type="String">
        <hint name="display-width">50</hint>
    </field>

In order to see the effect of the display-width hint on the Event model's name
field, you have to run Service Builder again and redeploy your portlet project.
Changing the display-width doesn't actually limit the number of characters that
can be entered into the name field; it's just a way to control the width of the
AUI input form field. To configure the maximum size of a model field's database
column (i.e., the maximum number of characters that can be saved in the field),
use the max-length hint. The default max-length is 75. If you'd like to allow
Event names of up to 100 characters to be saved, add another hint element inside
of your name field element:

    <field name="name" type="String">
        <hint name="display-width">50</hint>
        <hint name="max-length">100</hint>
    </field>

Remember to run Service Builder and redeploy your portlet project after updating
`portlet-model-hints.xml`. To test your max length setting, add a new event with
a name consisting of between 75 and 100 characters. The following table
describes some commonly used model hints.

**Model Hint Values and Descriptions**

Name | Value Type | Description | Default
:--: | :--------: | :---------: | :-----:
auto-escape | boolean | sets whether text values should be escaped via HtmlUtil.escape | true
day-nullable | boolean | allows the day to be null in a date field | false
default-value | String | sets the default value for a field | (empty String)
display-height | integer | sets the display height of the form field rendered using the aui taglib | 15
display-width | integer | sets the display width of the form field rendered using the aui taglib | 350
max-length | integer | sets the maximum column size for SQL file generation | 75
month-nullable | boolean | allows the month to be null in a date field | false
upper-case | boolean | converts all characters to upper case | false
year-nullable | boolean | allows the year to be null in a date field | false
year-range-delta | integer | specifies the number of years to display from today's date in a date field rendered with the aui taglib | 5

You can use the default-hints element to define a list of hints to be applied to
every field of a model. For example, adding the following element inside of a
model element applies a display-width of 300 to each element of the model:

    <default-hints>
        <hint name="display-width">300</hint>
    </default-hints>

You can define hint-collection elements inside of the model-hints element to
define a list of hints that can applied together. A hint collection must be
specified with a name. Model fields can apply a hint collection by referring to
the hint collection's name. For example, Liferay's `portal-model-hints.xml`
defines the following hint collections:

    <hint-collection name="CLOB">
        <hint name="max-length">2000000</hint>
    </hint-collection>
    <hint-collection name="URL">
        <hint name="max-length">4000</hint>
    </hint-collection>
    <hint-collection name="TEXTAREA">
        <hint name="display-height">105</hint>
        <hint name="display-width">500</hint>
        <hint name="max-length">4000</hint>
    </hint-collection>
    <hint-collection name="SEARCHABLE-DATE">
        <hint name="month-nullable">true</hint>
        <hint name="day-nullable">true</hint>
        <hint name="year-nullable">true</hint>
        <hint name="show-time">false</hint>
    </hint-collection>

If you define the same SEARCHABLE-DATE collection as above, you can apply it to
your Event model's date field by using a hint-collection element:

    <field name="date" type="Date">
        <hint-collection name="SEARCHABLE-DATE" />
    </field>

Remember to run Service Builder and redeploy your project after updating your
`portlet-model-hints.xml` file.

## Overview of `service.properties`

Service Builder generates the properties file `service.properties` in the `src`
directory of your service. Liferay Portal uses the properties in this file to
alter your service's database schema and load Spring configuration files to
support deployment of your service. You should not modify this file, but rather
make any necessary overrides in a `service-ext.properties` file in the `src`
folder.

The only property that you may need to override from this file is
`build.auto.upgrade`. Setting `build.auto.upgrade=false` in your
`service-ext.properties` prevents Liferay from trying to automatically apply any
changes to the database model when a new version of the plugin is deployed. This
is needed in projects in which it is preferred to manually manage the changes to
the database or in which the SQL schema has been modified manually after
generation by Service Builder.

Other properties included in the `service.properties` file include the
following:

- `build.namespace`: This is the namespace you defined in
  `docroot/WEB-INF/service.xml`. Liferay distinguishes different plugins from
  each other using their namespaces.
- `build.number`: Liferay distinguishes different builds of your plugin. Each
  time a distinct build of your plugin is deployed to Liferay, Liferay
  increments this number.
- `build.date`: This is the time of the latest build of your plugin.
- `spring.configs`: This is a comma-delimited list of Spring configurations. If
  you'd like to alter this list or the any of the values in
  `service.properties`, don't edit `service.properties` directly. Instead,
  create a `service-ext.properties`. The values for the properties that you
  define there will override the ones in `service.properties`.
- `include-and-override`: The default value of this property defines
  `service-ext.properties` as an override file for `service.properties`.

## Built-In Liferay Services 

In addition to the services you create using Service Builder, your portlets may
also access a variety of services built into Liferay. These include the
following:

- `UserService`

- `OrganizationService`

- `GroupService`

- `CompanyService`

- `ImageService`

- `LayoutService`

- `PermissionService`

- `UserGroupService`

- `RoleService`

For more information on these services, see Liferay's Javadocs at
[http://docs.liferay.com/portal/6.1/javadocs/](http://docs.liferay.com/portal/6.1/javadocs/).
