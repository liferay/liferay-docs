
# Liferay Frameworks

This chapter provides you with a brief overview of several of the essential frameworks provided by Liferay to developers. A framework, in the context of an API, is a set of APIs and configuration that is designed for an specific purpose such as enhancing your applications with a permission system, with tags, with categories, comments, etc.

This chapter will keep evolving with more information about the existing APIs and frameworks and how to use it. So look back for more information often.

## Service Builder

Service Builder is a model-driven code generation tool built by Liferay to automate the creation of interfaces and classes for database persistence and a service layer. Service Builder will generate most of the common code needed to implement find, create, update, and delete operations on the database, allowing you to focus on the higher level aspects of service design.

The service layer generated by Service Builder, has an implementation class that is responsible for retrieving and storing data classes and adding the necessary business logic around them. This layer can optionally be composed of two layers, a local service and a remote service layer. The local service contains the business logic and accesses the persistence layer. It can be invoked by client code running in the same Java Virtual Machine. The remote service usually has additional code to check security and is meant to be accessible from anywhere over the Internet or your local network. Service Builder automatically generates the code necessary to allow access to the remote services using SOAP, JSON and Java RMI.

### Define the Model

The first step in using Service Builder is to define your model classes and their attributes in a `service.xml` file. For convenience, we will define the service within the *my-greeting* portlet, although it should be placed inside a new portlet. Create a file named `service.xml` in `portlets/my-greeting-portlet/docroot/WEB-INF` within the Plugins SDK and add the following content:

    <?xml version="1.0"?>
    <!DOCTYPE service-builder PUBLIC
    "-//Liferay//DTD Service Builder 6.1.0//EN"
    "http://www.liferay.com/dtd/liferay-service-builder_6_1_0.dtd">
    <service-builder package-path="com.sample.portlet.library">
        <namespace>Library</namespace>
        <entity name="Book" local-service="true" remote-service="true">

            <!-- PK fields -->

            <column name="bookId" type="long" primary="true" />

            <!-- Group instance -->

            <column name="groupId" type="long" />

            <!-- Audit fields -->

            <column name="companyId" type="long" />
            <column name="userId" type="long" />
            <column name="userName" type="String" />
            <column name="createDate" type="Date" />
            <column name="modifiedDate" type="Date" />

            <!-- Other fields -->

            <column name="title" type="String" />
        </entity>
    </service-builder>

#### Overview of *service.xml*

    <service-builder package-path="com.sample.portlet.library">

This specifies the package path to which the class will be generated. In this example, classes will generate to `WEB-INF/src/com/sample/portlet/library/`

    <namespace>Library</namespace>

The namespace element must be a unique namespace for this component. Table names will be prepended with this namepace.

    <entity name="Book" local-service="true" remote-service="false">

The entity name is the database table you want to create.

    <column name="title" type="String" />

Columns specified in `service.xml` will be created in the database with a data type appropriate to the specified Java type. Accessors in the model class will automatically be generated for these attributes.

---
![tip](../../images/tip-pen-paper.png) Always consider adding two long fields called *groupId* and *companyId* to your data models. These two fields will allow your portlet to support the multi-tenancy features of Liferay so that each organization (for each portal instance) can have its own independent data.
---

### Generate the Service

Open a terminal window in your `portlets/my-greeting-portlet` directory and enter this command:

	ant build-service

The service has been generated successfully when you see BUILD SUCCESSFUL In the terminal window, you should see that a large number of files have been generated. An overview of these files is provided below:

-   Persistence

    -   `BookPersistence` - book persistence interface `@generated`

    -   `BookPersistenceImpl` - book persistence `@generated`

    -   `BookUtil` - book persistence util, instances BookPersistenceImpl `@generated`

-   Local Service

    -   **`BookLocalServiceImpl`** - local service implementation. This is the only class within the local service that you will be able to modify manually. Your business logic will be here.

    -   `BookLocalService` - local service interface `@generated`

    -   `BookLocalServiceBaseImpl` - local service base `@generated` `@abstract`

    -   `BookLocalServiceUtil` - local service util, instances `BookLocalServiceImpl` `@generated`

    -   `BookLocalServiceWrapper` - local service wrapper, wraps `BookLocalServiceImpl` `@generated`

-   Remote Service

    -   **`BookServiceImpl`** - remove service implementation. Put here the code that adds additional security checks and invokes the local service.

    -   `BookService` - remote service interface `@generated`

    -   `BookServiceBaseImpl` - remote service base `@generated` `@abstract`

    -   `BookServiceUtil` - remote service util, instances `BookServiceImpl` `@generated`

    -   `BookServiceWrapper` - remote service wrapper, wraps `BookServiceImpl` `@generated`

    -   `BookServiceSoap` - soap remote service, proxies `BookServiceUtil` `@generated`

    -   `BookSoap` - soap book model, similar to `BookModelImpl`, does not implement Book `@generated`

    -   `BookServiceHttp` - http remote service, proxies `BookServiceUtil` `@generated`

    -   `BookJSONSerializer` - json serializer, converts `Book` to JSON array `@generated`

-   Model

    -   `BookModel` - book base model interface `@generated`

    -   `BookModelImpl` - book base model `@generated`

    -   `Book` - book model interface `@generated`

    -   **`BookImpl`** - book model implementation. You can use this class to add additional methods to your model other than the auto-generated field getters and setters.

    -   `BookWrapper` - book wrapper, wraps `Book` `@generated`

Out of all of these classes only three can be manually modified: `BookLocalServiceImpl`, `BookServiceImpl` and `BookImpl`.

### Write the Local Service Class

In the file overview above, you will see that `BookLocalService` is the interface for the local service. It contains the signatures of every method in `BookLocalServiceBaseImpl` and `BookLocalServiceImpl`. `BookLocalServiceBaseImpl` contains a few automatically generated methods providing common functionality. Since this class is generated, you should never modify it, or your changes will be overwritten the next time you run Service Builder. Instead, all custom code should be placed in `BookLocalServiceImpl`.

Open the following file:

    /docroot/WEB-INF/src/com/sample/portlet/library/service/impl/BookLocalServiceImpl.java

We will add the database interaction methods to this service layer class. Add the following method to the `BookLocalServiceImpl` class:

    public Book addBook(long userId, String title)
        throws PortalException, SystemException {
        User user = UserUtil.findByPrimaryKey(userId);
        Date now = new Date();
        long bookId = CounterLocalServiceUtil.increment(Book.class.getName());

        Book book = bookPersistence.create(bookId);

        book.setTitle(title);
        book.setCompanyId(user.getCompanyId());
        book.setUserId(user.getUserId());
        book.setUserName(user.getFullName());
        book.setCreateDate(now);
        book.setModifiedDate(now);
        book.setTitle(title);

        return bookPersistence.update(book);
    }

Before you can use this new method, you must add its signature to the `BookLocalService` interface by running service builder again.

Navigate to the root directory of your portlet in the terminal and run:

    ant build-service

Service Builder looks through `BookLocalServiceImpl` and automatically copies the signatures of each method into the interface. You can now add a new book to the database by making the following call

    BookLocalServiceUtil.addBook(userId, "A new title");

### Overview of *service.properties*

Service Builder generates the properties file `service.properties` in the `src` directory of your service. Liferay Portal uses these properties to alter your service's database schema and load Spring configuration files to support deployment of your service. You should not modify this file, but rather make any necessary overrides in a `service-ext.properties` file in the `src` folder.

The only property that you may need to overwrite from this file is `build.auto.upgrade`. Setting `build.auto.upgrade=false` in your `service-ext.properties` prevents Liferay from trying to automatically apply any changes to the database model when a new version of the plugin is deployed. This is needed in projects in which it is preferred to manually manage the changes to the database or in which the SQL schema has been modified manually after generation by Service Builder.

### Built-In Liferay Services

In addition to the services you create using Service Builder, your portlets may also access a variety of services built into Liferay. These include the following:

- `UserService`

- `OrganizationService`

- `GroupService`

- `CompanyService`

- `ImageService`

- `LayoutService`

- `OrganizationService`

- `PermissionService`

- `UserGroupService`

- `RoleService`

For more information on these services, see *Liferay in Action* and Liferay's Javadocs.

## Security and Permissions

JSR-286 (and JSR-168) defines a simple security scheme using portlet roles and their mapping to portal roles. On top of that, Liferay provides a fine-grained permissions system, which developers can use to implement access security in their custom portlets. This section of the document gives an overview of the JSR-286 (JSR-168) security system, Liferay's permission system, and how to use them in your own portlets.

### JSR Portlet Security

The JSR specification defines the means to specify the roles that will be used by each portlet within its definition in `portlet.xml`. For example, the Liferay's Blogs portlet definition references 3 roles - *guest*, *power-user*, and *user*:

	<portlet>
		<portlet-name>33</portlet-name>
		<display-name>Blogs</display-name>
		<portlet-class>com.liferay.portlet.StrutsPortlet</portlet-class>
		<init-param>
			<name>view-action</name>
			<value>/blogs/view</value>
		</init-param>
		<init-param>
			<name>config-jsp</name>
			<value>/html/portlet/blogs/configuration.jsp</value>
		</init-param>
		<expiration-cache>0</expiration-cache>
		<supports>
			<mime-type>text/html</mime-type>
		</supports>
		<resource-bundle>com.liferay.portlet.StrutsResourceBundle</resource-bundle>
		<security-role-ref>
			<role-name>guest</role-name>
		</security-role-ref>
		<security-role-ref>
			<role-name>power-user</role-name>
		</security-role-ref>
		<security-role-ref>
			<role-name>user</role-name>
		</security-role-ref>
		<supported-public-render-parameter>categoryId</supported-public-render-parameter>
		<supported-public-render-parameter>tag</supported-public-render-parameter>
	</portlet>

These roles need to be mapped to specific roles within the portal. The reason for this mapping is to provide a means for the deployer of a portlet to resolve conflicts between roles that have the same name but are from different portlets (e.g., portlets from different developers).

---
![tip](../../images/tip-pen-paper.png) Each role named in a portlet's `<security-role-ref>` element is given permission to add the portlet to a page.
---

In order to do the mapping, it is necessary to use *portal-specific* configuration files. In the case of Liferay, you can define the mapping in `liferay-portlet.xml`. For an example, see the mapping defined inside `liferay-portlet.xml` found in `portal-web/docroot/WEB-INF`:

	<role-mapper>
		<role-name>administrator</role-name>
		<role-link>Administrator</role-link>
    </role-mapper>
    <role-mapper>
		<role-name>guest</role-name>
		<role-link>Guest</role-link>
    </role-mapper>
    <role-mapper>
		<role-name>power-user</role-name>
		<role-link>Power User</role-link>
    </role-mapper>
    <role-mapper>
		<role-name>user</role-name>
		<role-link>User</role-link>
	</role-mapper>

This means that if a portlet definition references the role `power-user`, that portlet will be mapped to the Liferay role in its database called *Power User*.

In your portlet's code, you can then use methods as defined in portlet specification:

- `getRemoteUser()`

- `isUserInRole()`

- `getUserPrincipal()`

For example, the following code could be used to check if the current user has the `power-user` role:

    if (renderRequest.isUserInRole("power-user")) {
        // ...
    }

Note by default, Liferay doesn't use the `isUserInRole()` method in any of the built-in portlets. Instead Liferay uses its own permission system directly to achieve more *fine-grained* security. The next section describes Liferay's Permission System and how to use it in your portlets, so that you can decide which option fits your needs best.

### Liferay's Permission System Overview

Adding permissions to custom portlets consists of four main steps (also known as DRAC):

1.  **D**efine all resources and their permissions.

2.  **R**egister all the resources defined in step 1 in the permissions system. This is also known as *adding resources.*

3.  **A**ssociate the necessary permissions with resources.

4.  **C**heck permission before returning resources.

### Implementing Permissions

Before you can add permissions to a portlet, let's get an understanding of the following two critical terms used throughout this section:

-	**Resource** - A generic term for any object represented in the portal. Examples of resources include portlets (e.g., Message Boards, Calendar, etc.), Java classes (e.g., Message Board Topics, Calendar Events, etc.), and files (e.g., documents, images, etc.)

-	**Permission** - An action on a resource. For example, the *view* action with respect to *viewing the calendar portlet* is defined as a permission in Liferay.

Keep in mind that permissions for a *portlet* resource are implemented a little differently from other resources such as Java classes and files. In each of the subsections below, the permission implementation for the *portlet* resource is explained first, then the model (and file) resource.

The first step is to define your resources and permissions (or *actions*). So let's consider how this is done for the blogs portlet.  Look at resource-actions XML file `blogs.xml` in `portal-impl/src/resource-actions` to see the following mapping of resources to actions:

	<?xml version="1.0"?>
	<!DOCTYPE resource-action-mapping PUBLIC "-//Liferay//DTD Resource Action Mapping 6.1.0//EN" "http://www.liferay.com/dtd/liferay-resource-action-mapping_6_1_0.dtd">

	<resource-action-mapping>
		<portlet-resource>
			<portlet-name>33</portlet-name>
			<permissions>
				<supports>
					<action-key>ADD_TO_PAGE</action-key>
					<action-key>CONFIGURATION</action-key>
					<action-key>VIEW</action-key>
				</supports>
				<site-member-defaults>
					<action-key>VIEW</action-key>
				</site-member-defaults>
				<guest-defaults>
					<action-key>VIEW</action-key>
				</guest-defaults>
				<guest-unsupported>
					<action-key>CONFIGURATION</action-key>
				</guest-unsupported>
			</permissions>
		</portlet-resource>
		<portlet-resource>
			<portlet-name>161</portlet-name>
			<permissions>
				<supports>
					<action-key>ACCESS_IN_CONTROL_PANEL</action-key>
					<action-key>CONFIGURATION</action-key>
					<action-key>VIEW</action-key>
				</supports>
				<site-member-defaults>
					<action-key>VIEW</action-key>
				</site-member-defaults>
				<guest-defaults>
					<action-key>VIEW</action-key>
				</guest-defaults>
				<guest-unsupported>
					<action-key>ACCESS_IN_CONTROL_PANEL</action-key>
					<action-key>CONFIGURATION</action-key>
				</guest-unsupported>
			</permissions>
		</portlet-resource>
		<model-resource>
			<model-name>com.liferay.portlet.blogs</model-name>
			<portlet-ref>
				<portlet-name>33</portlet-name>
			</portlet-ref>
			<permissions>
				<supports>
					<action-key>ADD_ENTRY</action-key>
					<action-key>PERMISSIONS</action-key>
					<action-key>SUBSCRIBE</action-key>
				</supports>
				<site-member-defaults />
				<guest-defaults />
				<guest-unsupported>
					<action-key>ADD_ENTRY</action-key>
					<action-key>PERMISSIONS</action-key>
					<action-key>SUBSCRIBE</action-key>
				</guest-unsupported>
			</permissions>
		</model-resource>
		<model-resource>
			<model-name>com.liferay.portlet.blogs.model.BlogsEntry</model-name>
			<portlet-ref>
				<portlet-name>33</portlet-name>
			</portlet-ref>
			<permissions>
				<supports>
					<action-key>ADD_DISCUSSION</action-key>
					<action-key>DELETE</action-key>
					<action-key>DELETE_DISCUSSION</action-key>
					<action-key>PERMISSIONS</action-key>
					<action-key>UPDATE</action-key>
					<action-key>UPDATE_DISCUSSION</action-key>
					<action-key>VIEW</action-key>
				</supports>
				<site-member-defaults>
					<action-key>ADD_DISCUSSION</action-key>
					<action-key>VIEW</action-key>
				</site-member-defaults>
				<guest-defaults>
					<action-key>ADD_DISCUSSION</action-key>
					<action-key>VIEW</action-key>
				</guest-defaults>
				<guest-unsupported>
					<action-key>DELETE</action-key>
					<action-key>DELETE_DISCUSSION</action-key>
					<action-key>PERMISSIONS</action-key>
					<action-key>UPDATE</action-key>
					<action-key>UPDATE_DISCUSSION</action-key>
				</guest-unsupported>
			</permissions>
			...
		</model-resource>
	</resource-action-mapping>

Permissions in the blogs portlet are defined at several different levels, coinciding with the different sections of the resource-actions XML file. In the `<portlet-resource>` level, actions and default permissions are defined on the portlet itself. Changes to portlet level permissions are performed on a per-site basis. These settings affect whether users can add the portlet to a page, edit the portlet's configuration, or view the portlet at all, regardless of portlet's content. All these actions are defined inside the `<supports>` tag for the permissions of the portlet resource. The default portlet-level permissions for members of the site are defined inside the `<site-member-defaults>` tag. In the case of this blogs portlet, members of the site should be able to view any blogs in the site. Likewise, default guest permissions are defined in the `<guest-defaults>` tag. Lastly, the `<guest-unsupported>` tag contains permissions forbidden to guests. So in the case of this portlet, guests cannot be given permission to configure the portlet, even by a user with the administrator role.

The next level of permissions is defined in the `<model-resource>` section. This level of permissions is based on the *scope* of an individual instance of the portlet. A *scope* in Liferay is simply a way of specifying how widely the data from an instance of a portlet is shared. For example, if you place a blogs portlet on a page in the guest site and then place another blogs portlet on another page in the *same* site, the two blogs will share the same set of posts. This demonstrates the default or *site-level* scope. However, if you reconfigure one of the two blogs changing its scope to the current page, that blogs portlet instance will no longer share content with the other instance (or any of the other blogs instances in that site). Thus, with respect to permissions, a portlet *instance* can either span an entire site or be restricted  to a single page.

The differences between the portlet instance permissions defined in the `<model-resource>` section and the portlet permissions defined in the `<portlet-resource>` section are subtle, but critical. Notice that permissions, such as the ability to *add* or *subscribe to* a blog entry, are defined at the portlet instance level. This makes it possible to have multiple distinct blog instances within a site, each with different permissions for site users. For example, a food site could have one blog open to posts from any site member, but also have a separate informational blog about the site itself restricted to posts from administrators.

After defining the portlet and portlet instance as resources, we move on to defining models within the portlet that also require permissions.  The model resource is surrounded by the `<model-resource>` tag. Within this tag, we first define the model name. Notice that the `<model-name>` is not the name of an actual Java class, but simply the fully qualified name of the portlet's package (e.g., the blog portlet's package `com.liferay.portlet.blogs`). This is the recommended convention for permissions that refer to an instance of the portlet as a whole. Next is the `<portlet-ref>` element which contains a `<portlet-name>`. The value of the `<portlet-name>` references the name of the portlet to which the model resource belongs; though unlikely, a model resource can belong to multiple portlets referenced with multiple `<portlet-name>` elements. Similar to the portlet resource, the model resource also allows you to define a list of supported actions that require permission to perform. You must list out all the performable actions that require a permission check. As you can see for a blog entry, users must belong to appropriate roles for permission to *add comments* to an entry, *delete* an entry, *change the permission* setting of an entry, *update* an entry, or simply to *view* an entry. The `<site-member-defaults>` tag, `<guest-defaults>` tag, and `<guest-unsupported>` tag have similar meaning for a *model resource* as they do for a *portlet resource*.

After defining resource permissions for your custom portlet, you then need to refer Liferay to the resource-actions XML file that provides these definitions (e.g., `blogs.xml` for the blogs portlet). For Liferay core, the resource-actions XML files would normally reside in `portal/portal-impl/classes/resource-actions` and a a file named `default.xml` file would refer to each of these files. Here is an excerpt from the `default.xml` that references the resource permission definition files for all of the Liferay built-in portlets (including the blogs portlet):

	<?xml version="1.0"?>
	<!DOCTYPE resource-action-mapping PUBLIC "-//Liferay//DTD Resource Action Mapping 6.1.0//EN" "http://www.liferay.com/dtd/liferay-resource-action-mapping_6_1_0.dtd">
	
	<resource-action-mapping>
		<resource file="resource-actions/portal.xml" />
		<resource file="resource-actions/announcements.xml" />
		<resource file="resource-actions/asset.xml" />
		<resource file="resource-actions/blogs.xml" />
		...
	</resource-action-mapping>

For your plugin, you should put your resource-actions XML file(s) (e.g. `default.xml` and `blogs.xml`) in a directory that is in your project's classpath. Then create a properties file (typically named `portlet.properties`) for your portlet that references the the file that specifies your `<resource-action-mapping>` element (e.g. `default.xml`). Within this portlet properties file, create a property named `resource.actions.configs` with the relative path to your portlet's resource-action mapping file (e.g., `default.xml`) as its value. For example, you could specify the property in this manner:

    resource.actions.configs=resource-actions/default.xml


To see an example of a portlet that defines its resources and permissions in the manner we just described, check out a copy of the Liferay source code from the Liferay  public Subversion repository and start by looking at the definition files found in the `portal-impl/src/resource-actions` directory. For an example of how permissions are defined in the context of a portlet plugin, checkout `plugins/trunk` , and look at the portlet `sample-permissions-portlet`.

Next, let's consider the permission algorithm for this version of Liferay Portal.

### Permission Algorithms

There are 6 permission algorithms that Liferay has used over the years for checking permissions. Liferay 5 introduced algorithm 5 that was based on RBAC system. Liferay 6 used algorithm 6 which was an optimized version of algorithm 5 that improved performance by using a reduced set of database tables.

It's important to note that once a permission algorithm is configured and resources are created, the algorithm cannot be changed; otherwise the existing permissions will be lost (and some system features may fail).

For all new deployments it is strongly recommended you use algorithm 6. For deployments that are using other algorithms it's recommended you migrate to algorithm 6 using the migration tools provided in the Control Panel (see Control Panel -\> Server Administration -\> Data Migration.)

For more information see options for `permissions.user.check.algorithm` in the `portal.properties` file. But next, we'll cover how to add resources.

### Adding a Resource

After defining resources and actions, the next task is to writing code that adds resources into the permissions system. A lot of the logic to add resources is encapsulated in the `ResourceLocalServiceImpl` class. So adding resources is as easy as calling the `addResources(...)` method of the `ResourceLocalServiceUtil` class. Here is the signature of that method:

	public void addResources(
			long companyId, long groupId, long userId, String name,
			String primKey, boolean portletActions,
			boolean addGroupPermissions, boolean addGuestPermissions)

For all the Java objects that require access permission, you need to make sure that they are added as resources every time a new object is created. For example, every time a user adds a new entry to her blog, the `addResources(...)` method should be called to add the new entry object to the resource system. Here's an example of the call from the `BlogsEntryLocalServiceImpl` class:

    resourceLocalService.addResources(
			entry.getCompanyId(), entry.getGroupId(), entry.getUserId(),
			BlogsEntry.class.getName(), entry.getEntryId(), false,
			addGroupPermissions, addGuestPermissions);

In the `addResources(...)` method, the parameters `companyId`, `groupId`, and `userId` should be self explanatory. The `name` parameter is the fully qualified Java class name for the resource object being added. The `primKey` parameter is the primary key of the resource object. As for the `portletActions` parameter, set this to `true` if you're adding portlet action permissions. In our example, we set it to `false` because we're adding a model resource, which should be associated with permissions related to the model action defined in `blogs.xml`. The `addGroupPermissions` and the  `addGuestPermissions` parameters are inputs from the user. If set to `true`, `ResourceLocalService` will then add the default permissions to the current group and the guest group for this resource, respectively.

To give your user the ability to choose whether to add the default site permission and/or the guest permission for the your custom portlet resources, Liferay has a custom JSP tag `<liferay-ui:input-permissions />` that you can use to quickly add that functionality. Simply insert the tag into the appropriate JSP and the checkboxes will show up on that JSP. Make sure, of course, that the tag is within the appropriate `<form>` tags.

When removing entities from the database it is also good to remove permissions mapped directly to the entity. To prevent having a lot of dead resources taking up space in the `Resource_` database table, you must remember to remove them from the `Resource_` table when the resource is no longer applicable. Perform this operation by calling the `deleteResource(...)` method of `ResourceLocalServiceService`. Here's an example of a blogs entry being removed:

	resourceLocalService.deleteResource(
		entry.getCompanyId(), BlogsEntry.class.getName(),
		ResourceConstants.SCOPE_INDIVIDUAL, entry.getEntryId());

Great! Now that you know how to work with resource permissions, let's consider how to provide a user interface for managing resource permissions.

### Adding Permission

On the portlet level, no code needs to be written in order to have the permission system work for your custom portlet. Your custom portlet will automatically have all the permission features. If you've defined any custom permissions (supported actions) in your `portlet-resource` tag, they are automatically added to a list of permissions that users can readily choose. Of course, for your custom permissions to have any value, you'll need to show or hide certain functionality in your portlet. You can do that by checking the permission *before* performing the intended action on the resource.

In order to allow a user to set permissions on model resources, you will need to expose the permission interface to the user. This can be done by adding two Liferay UI tags to your JSP. The first one is the `<liferay-security:permissionsURL>` tag which returns a URL that takes the user to the page to configure the permission settings. The second tag is the `<liferay-ui:icon>` tag that shows a permission icon to the user. The example below demonstrates using these two tags and is from the file `view_entry_content.jspf`.

    <liferay-security:permissionsURL
	modelResource="<%= BlogsEntry.class.getName() %>"
	modelResourceDescription="<%= entry.getTitle() %>"
	resourcePrimKey="<%= entry.getPrimaryKey().toString() %>"
	var="entryURL"
	/>

    <liferay-ui:icon image="permissions" url="<%= entryURL %>" />

The attributes you need to specify for the first tag are `modelResource`, `modelResourceDescription`, `resourcePrimKey`, and `var`. The `modelResource` attribute is the fully qualified Java object class name. This class name gets translated into its more readable name as specified in file `Language.properties`.

As for the `modelResourceDescription` attribute, you can pass in anything that best describes this model instance. In this example, the blogs title was passed in. The `resourcePrimKey` attribute is simply the primary key of your model instance. The `var` attribute specifies the name of the variable to be assigned the resulting URL String. This variable is then passed to the `<liferay-ui:icon>` tag so the permission icon will have the proper URL link. There's also an optional attribute redirect that's available if you want to override the default behavior of the upper right arrow link. That is all you need to do to allow users to configure the permission settings for model resources.

Next, we'll show you how to implement permissions checking.

### Checking Permissions

The last major step to implementing permissions for your custom portlet is to add some checks that guarantee that the configured permissions are enforced. This may be done in a couple of places. For example, your business layer should check for permission before deleting a resource, or your user interface should hide a button that adds a model (e.g., a calendar event) if the user does not have permission to do so.

Similar to the other steps, the default permissions for the portlet resources are automatically checked for you. You do not need to implement anything for your portlet to discriminate whether a user is allowed to view or to configure the portlet itself. However, you do need to implement checking of any custom permission you have defined in your resource-actions XML file. In the blogs portlet, one custom supported action is `ADD_ENTRY`. There are two places in the source code to check for this permission. The first place to check for the add entry permission is in your JSP files. The presence of the add entry button is contingent on whether the user has permission to add entry.

    <%
	if (permissionChecker.hasPermission(
	scopeGroupId, "com.liferay.portlet.blogs.model",
	scopeGroupId, "ADD_ENTRY") {
	// Show add entry button
	}
    %>

The second place to check for the add entry permission is in the business logic. If the check fails, a `PrincipalException` is thrown `and the add entry request is aborted.`

    if (!permissionChecker.hasPermission(
	scopeGroupId, "com.liferay.portlet.blogs.model",
	scopeGroupId, "ADD_ENTRY")) {
	    throw new PrincipalException();
    }

    blogsEntryLocalService.addEntry(...);

The `PermissionChecker` class has a method called `hasPermission(...)` that checks whether a user making a resource request has the necessary access permission. If the user is not signed in (guest user), it checks for guest permissions. Otherwise, it checks for user permissions.  Let's do a quick review of the parameters of this method:

-   `groupId`:  represents the scope in which the permission check is being performed.  In Liferay, the scopes can be a specific site, an organization, a personal site of a user, etc.  This is important because a user may be allowed to add blog entries in a given site but not in another. For resources that do not belong to an scope like those mentioned, the value of this parameter should be `0`. There are several ways to obtain the `groupId` of the current scope:

    -   JSP that uses the `<theme:defineObjects/>` tag: there is an implicit variable called `scopeGroupId`.

    -   Business logic class: When using the ServiceContext pattern, it can be obtained using `serviceContext.getScopeGroupId()`.          -   Other cases: it can be obtained from the theme display request object:

            ThemeDisplay themeDisplay = (ThemeDisplay)request.getAttribute(
            	WebKeys.THEME_DISPLAY);
            long scopeGroupId = themeDisplay.getScopeGroupId();

-   `name`:  The name of the resource as specified in the XML file of the previous sections.

-   `primKey`:  The primary key of the resource. In this example, since the resource doesn't exist as an entry in the database we use the groupId again. If we were checking for a permission on a given blog entry, we would use the primary key of that blog entry instead.

-   `actionId`:  The name of the action as entered in the XML file.  It is a common practice to create a helper class with constants for all the actions defined, so that it's easier to search usages.

In the examples above, we are assuming that there is a variable called `permissionChecker` already available.  Liferay automatically creates a `PermissionChecker` instance for every request that has all the necessary information from the user and caches the security checks to ensure good performance. There are several ways to obtain this instance:

-   In a JSP that uses the `<theme:defineObjects/>` tag: there is an implicit variable called `permissionChecker`.

-   When using ServiceBuilder, every service implementation class can access the `PermissionChecker` instance by using the method `getPermissionChecker()`.

-   Other cases: it can be obtained from the theme display request object:

        ThemeDisplay themeDisplay = (ThemeDisplay)request.getAttribute(WebKeys.THEME_DISPLAY);
        PermissionChecker permissionChecker =
        	themeDisplay.getPermissionChecker();

### Creating Helper Classes for Permission Checking

Often, it is a good practice to create helper classes that encapsulate the use of permissionChecker and the names of the resources for a specific portlet. This is especially useful when there are complex parent/child relationships or if your permission logic calls for checking multiple action types. `BlogsPermission` is an example of a permission helper class. See how `BlogsPermission` may be used in a JSP.

    <%
	if (BlogsPermission.contains(permissionChecker, scopeGroupId,
	    ActionKeys.ADD_ENTRY)) {
		// show add entry button
	    }
    %>

Now, let's take a look at how a `ServiceImpl` class `BlogsEntryServiceImpl` uses the `BlogsPermission` helper class. In method `BlogsEntryServiceImpl.addEntry(...)`, a call is made to check whether the incoming request has permission to add entry.  The check is done using helper class `BlogsPermission`.  If the check fails, it throws a `PrincipalException` and the add entry request aborts.

	public BlogsEntry addEntry(
			String title, String description, String content,
			int displayDateMonth, int displayDateDay, int displayDateYear,
			int displayDateHour, int displayDateMinute, boolean allowPingbacks,
			boolean allowTrackbacks, String[] trackbacks, boolean smallImage,
			String smallImageURL, String smallImageFileName,
			InputStream smallImageInputStream, ServiceContext serviceContext)
		throws PortalException, SystemException {

		BlogsPermission.check(
			getPermissionChecker(), serviceContext.getScopeGroupId(),
			ActionKeys.ADD_ENTRY);

		return blogsEntryLocalService.addEntry(
			getUserId(), title, description, content, displayDateMonth,
			displayDateDay, displayDateYear, displayDateHour, displayDateMinute,
			allowPingbacks, allowTrackbacks, trackbacks, smallImage,
			smallImageURL, smallImageFileName, smallImageInputStream,
			serviceContext);
	}

Note the parameters passed into the `check(...)` method. Again, the `getPermissionChecker()` method is readily available in all `ServiceImpl` classes. The blogs entry ID is available in the serviceContext indicating that the permission check is against the blogs portlet. `ActionKeys.ADD_ENTRY` is a static String to indicate the action requiring the permission check. Likewise, you are encouraged to use custom portlet action keys.

Let's review what we've just covered. Implementing permission into your custom portlet consists of four main steps. First step is to define any custom resources and actions. Next step is to implement code to register (or add) any newly created resources such as a `BlogsEntry` object. The third step is to provide an interface for the user to configure permission. Lastly, implement code to check permission before returning resources or showing custom features. Two major resources are portlets and Java objects. There is not a lot that needs to be done for the portlet resource to implement the permission system since Liferay Portal has a lot of that work done for you. You mainly focus your efforts on any custom Java objects you've built. You're now well equipped to implement security in your custom Liferay portlets!

Next, let's learn how to use the Asset Framework.

## Asset Framework

The asset framework provides a set of functionalities that are common to several different content types. It was initially created to be able to add tags to blog entries, wiki pages, web content, etc without having to re-implement this same functionality over and over. Since then, it has grown to include more functionalities and it has been made possible to use the framework for custom applications even if they are implemented within a plugin.

The term *asset* is used as a generic way to refer to any type of content regardless of whether it's purely text, an external file, a URL, an image, an record in an online book library, etc. From now on, whenever the word asset is used, think of it as a generic way to refer to documents, blog entries, bookmarks, wiki pages, etc.

Here are the main functionalities that you will be able to reuse thanks to the asset framework:

-   Associate tags to custom content types (new tags will be created automatically when the author assigns them to the content).

-   Associate categories to custom content types (authors will only be allowed to select from predefined categories within several predefined vocabularies)

-   Manage tags from the control panel (including merging tags)

-   Manage categories from the control panel (including creating complex hierarchies).

-   Keep track of the number of visualizations of an asset.

-   Publish your content using the Asset Publisher portlet. Asset Publisher is able to publish dynamic lists of assets or manually selected lists of assets. It is also able to show a summary view of an asset and offer a link to the full view if desired. Because of this it will save you time since for many use cases it will make it unnecessary to develop custom portlets for your custom content types.

If these functionalities seem useful for your case, then you might be wondering, what do I have to do to benefit from them?

The following subsections describe the steps involved in using the asset framework. The first one is mandatory and consists on letting the framework know whenever one of your custom content entries is added, updated or deleted. The second part is optional but can save a lot of time so most developers will probably make use of it. It consists on using a set of taglibs to provide widgets that allow authors to enter tags and categories as well as how to show the entered tags and categories along with the content. The rest of the sections are also optional but offer interesting functionalities such as how to allow your custom assets to be published through the Asset Publisher. Next, let's dive into adding, updating, and deleting assets.

#### Adding, updating and deleting assets

Whenever one of your custom content is created you need to let the asset framework know. Don't worry, it is simple. You just need to invoke a method of the asset framework. When invoking this method you will also let the framework know about the tags and/or categories of the content that was just authored.

All the methods that you will need to invoke are part of the `AssetEntryLocalService`. In particular you should access these methods using either the static methods of `AssetLocalServiceUtil` or by using an instance of the `AssetEntryLocalService` injected by Spring. To make this section simpler we will be using the former, since it doesn't require any special setup in your application.

The method that you need to invoke when one of your custom content has been added or updated is the same and is called `updateEntry`. Here is the full signature:

    AssetEntry updateEntry(
            long userId, long groupId, String className, long classPK,
            String classUuid, long classTypeId, long[] categoryIds,
            String[] tagNames, boolean visible, Date startDate, Date endDate,
            Date publishDate, Date expirationDate, String mimeType,
            String title, String description, String summary, String url,
            String layoutUuid, int height, int width, Integer priority,
            boolean sync)
        throws PortalException, SystemException

Here is an example invocation of this method extracted from the blogs portlet that comes bundled with Liferay:

    assetEntryLocalService.updateEntry(
            userId, entry.getGroupId(), BlogsEntry.class.getName(),
            entry.getEntryId(), entry.getUuid(), 0, assetCategoryIds,
            assetTagNames, visible, null, null, entry.getDisplayDate(), null,
            ContentTypes.TEXT_HTML, entry.getTitle(), null, summary, null, null,
            0, 0, null, false);

Here is a quick summary of the most important parameters of this method:

-   *userId*: is the identifier of the user who created the content

-   *groupId*: identifies the scope in which the content has been created. If your content does not support scopes, you can just pass `0` as the value.

-   *className*: identifies the type of asset. By convention we recommend that it is the name of the Java class that represents your content type, but you can actually use any String you want as long as you are sure that it is unique.

-   *classPK*: identifies the specific content being created among any other of the same type. It is usually the primary key of the table where the custom content is stored. The *classUuid* parameter can optionally be used to specify a secondary identifier that is guaranteed to be universally unique. This type of identifier is especially useful if your contents will be exported and imported across separate portals.

-   *assetCategoryIds* and *assetTagNames*: represent the categories and tags that have been selected by the author of the content. The asset framework will sotre them for you.

-   *visible*: specifies whether this content should be shown at all by Asset Publisher.

-   *title,* *description* and *summary:* are descriptive fields that will be used by the Asset Publisher when displaying entries of your content type.

-   *publishDate* and *expirationDate:* can optionally be specified to let the Asset Publisher know that it should not show the content before a given publication date of after a given expiration date.

-   All other fields are optional and might not make sense to include in some cases. The *sync* parameter should always be false unless you are doing something very advanced (look at the code if you are really curious).

When one of your custom content is deleted you should also let the Asset Framework know, to clean up the information stored and also to make sure that the Asset Publisher doesn't show any information for the content that has been deleted. The signature of method to delete an asset entry is:

    void deleteEntry(String className, long classPK)

Here is an example invocation extracted again from the blogs portlet:

    assetEntryLocalService.deleteEntry(
    	BlogsEntry.class.getName(), entry.getEntryId());

Now that you've learned how to create and modify assets, have you considered tagging and categorizing them? Let's tackle that next.

#### Entering and displaying tags and categories

The previous section showed how you can let the asset framework know about the tags and categories that have been associated with a given asset; but how does a content author specify such tags and categories?

The answer is that you can choose any method that you prefer, but Liferay provides a set of JSP tags that you can use to make this task very easy. The following Liferay UI tags can be used within your forms to create content that can be associated with new/existing tags or predefined categories:

    <label>Tags</label>
    <liferay-ui:asset-tags-selector
        className="<%= entry.getClass().getName() %>"
        classPK="<%= entry.getPrimaryKey() %>"
    />

    <label>Categories</label>
        <liferay-ui:asset-categories-selector
            className="<%= entry.getClass().getName() %>"
            classPK="<%= entry.getPrimaryKey() %>"
    />

These two taglibs create appropriate form controls that allow the user to search for a tag or create a new tag, and select a existing category.

---
![tip](../../images/tip-pen-paper.png) If you are using Liferay's Alloy Form taglibs, creating fields to enter tags and categories is even simpler. You just need to use <aui:input name="tags" type="assetTags" /> and <aui:input name="categories" type="assetCategories" /> respectively.
---

Once the tags and categories have been entered you will want to show them along with the content of the asset. The following demonstrates how to display the tags and categories:

    <label>Tags</label>
    <liferay-ui:asset-tags-summary
        className="<%= entry.getClass().getName() %>"
        classPK="<%= entry.getPrimaryKey() %>"
    />

    <label>Categories</label>
    <liferay-ui:asset-categories-summary
        className="<%= entry.getClass().getName() %>"
        classPK="<%= entry.getPrimaryKey() %>"
    />

In both tags, you can also specify an optional `portletURL` parameter. Each tag that uses the `portletURL` parameter will be a link containing the `portletURL` *and* `tag` or `categoryId` parameter value respectively. This supports tags navigation and categories navigation within your portlet. But you will need to implement the look-up functionality in your portlet code by reading the values of those two parameters and using the `AssetEntryService` to query the database for entries based on the specified tag or category.

Great! You'll have no problem associating tags and categories with your assets. So let's get them published in your portal.

#### Publishing assets with Asset Publisher

One of the nice benefits of using the asset framework is leveraging the Asset Publisher portlet to publish lists of your custom asset types. The lists can be dynamically specified (for example, based on the asset tags or categories) by the user or statically specified by an administrator.  The Asset Publisher portlet is part of the Liferay distribution.

In order to be able to display your assets, the Asset Publisher needs to know how to access the metadata of your assets.  Additionally, you need to provide the Asset Publisher with templates for the types of views (e.g., *full* view and abstract view) available to display your assets.

You can provide all this to the Asset Publisher by implementing the following pair of interfaces - AssetRendererFactory and AssetRenderer:

-   **AssetRendererFactory:**     this class knows how to retrieve specific assets from the persistent storage via the class `classPK`. The `classPK` is typically the asset's primary  key, but can be anything you have specified to the `updateAsset` method used to add or update the asset. Your factory implementation should be able to grab the asset from a `groupId` (identifies a scope of data) and a `urlTitle` (a title that can be used in friendly URLs to refer uniquely to the asset within a given scope). Finally, the asset renderer factory can provide a URL for the Asset Publisher to use when a user wants to add a new asset of your custom type. This URL should point to your own portlet. There are other less important methods of the interface, but you can avoid implementing them by extending **BaseAssetRendererFactory**. Extending this *base* class, instead of implementing the interface directly, will make your code more robust to possible interface changes in future versions of Liferay, since the base implementation will already be updated to accommodate the interface changes.

-   **AssetRenderer:** this is the class that provides metadata information about one specific asset. It verifies whether the current user has permission to edit or view the asset. And this class is responsible for rendering the asset for the different templates (e.g. abstract and full content view) by forwarding to a specific an appropriate JSP. It is recommended that you extend the **BaseAssetRenderer**  class rather than directly implementing the interface. The *base* class provides nice defaults and robustness for methods that could be added to the interface in the future.

Let's see an example of these two classes. Again we will pick Liferay's Blogs portlet. Lets start with the implementation for the `AssetRendererFactory`:

    public class BlogsEntryAssetRendererFactory extends BaseAssetRendererFactory {

        public static final String CLASS_NAME = BlogsEntry.class.getName();

        public static final String TYPE = "blog";

        public AssetRenderer getAssetRenderer(long classPK, int type)
            throws PortalException, SystemException {

            BlogsEntry entry = BlogsEntryLocalServiceUtil.getEntry(classPK);

            return new BlogsEntryAssetRenderer(entry);
        }

        @Override
        public AssetRenderer getAssetRenderer(long groupId, String urlTitle)
            throws PortalException, SystemException {

            BlogsEntry entry = BlogsEntryServiceUtil.getEntry(groupId, urlTitle);

            return new BlogsEntryAssetRenderer(entry);
        }

        public String getClassName() {
            return CLASS_NAME;
        }

        public String getType() {
            return TYPE;
        }

        @Override
        public PortletURL getURLAdd(
                LiferayPortletRequest liferayPortletRequest,
                LiferayPortletResponse liferayPortletResponse)
            throws PortalException, SystemException {

            HttpServletRequest request =
                liferayPortletRequest.getHttpServletRequest();

            ThemeDisplay themeDisplay = (ThemeDisplay)request.getAttribute(
                WebKeys.THEME_DISPLAY);

            if (!BlogsPermission.contains(
                themeDisplay.getPermissionChecker(),
                themeDisplay.getScopeGroupId(), ActionKeys.ADD_ENTRY)) {

                return null;
            }

        PortletURL portletURL = PortletURLFactoryUtil.create(
            request, PortletKeys.BLOGS, getControlPanelPlid(themeDisplay),
            PortletRequest.RENDER_PHASE);

            portletURL.setParameter("struts_action", "/blogs/edit_entry");

            return portletURL;
        }

        @Override
        public boolean hasPermission(
                PermissionChecker permissionChecker, long classPK, String actionId)
            throws Exception {

            return BlogsEntryPermission.contains(
                permissionChecker, classPK, actionId);
        }

        @Override
        public boolean isLinkable() {
            return _LINKABLE;
        }

        @Override
        protected String getIconPath(ThemeDisplay themeDisplay) {
            return themeDisplay.getPathThemeImages() + "/blogs/blogs.png";
        }

        private static final boolean _LINKABLE = true;
    }

And here is the AssetRenderer implementation:

    public class BlogsEntryAssetRenderer extends BaseAssetRenderer {

        public BlogsEntryAssetRenderer(BlogsEntry entry) {
            _entry = entry;
        }

        public long getClassPK() {
            return _entry.getEntryId();
        }

        @Override
        public String getDiscussionPath() {
            if (PropsValues.BLOGS_ENTRY_COMMENTS_ENABLED) {
                return "edit_entry_discussion";
            }
            else {
                return null;
            }
        }

        public long getGroupId() {
            return _entry.getGroupId();
        }

        public String getSummary(Locale locale) {
            return HtmlUtil.stripHtml(_entry.getDescription());
        }

        public String getTitle(Locale locale) {
            return _entry.getTitle();
        }

        @Override
        public PortletURL getURLEdit(
                LiferayPortletRequest liferayPortletRequest,
                LiferayPortletResponse liferayPortletResponse)
            throws Exception {

            PortletURL portletURL = liferayPortletResponse.createLiferayPortletURL(
                getControlPanelPlid(liferayPortletRequest), PortletKeys.BLOGS,
                PortletRequest.RENDER_PHASE);

            portletURL.setParameter("struts_action", "/blogs/edit_entry");
            portletURL.setParameter("entryId", String.valueOf(_entry.getEntryId()));

            return portletURL;
        }

        @Override
        public String getUrlTitle() {
            return _entry.getUrlTitle();
        }

        @Override
        public PortletURL getURLView(
                LiferayPortletResponse liferayPortletResponse,
                WindowState windowState)
            throws Exception {

            PortletURL portletURL = liferayPortletResponse.createLiferayPortletURL(
                PortletKeys.BLOGS, PortletRequest.RENDER_PHASE);

            portletURL.setWindowState(windowState);

            portletURL.setParameter("struts_action", "/blogs/view_entry");
            portletURL.setParameter("entryId", String.valueOf(_entry.getEntryId()));

            return portletURL;
        }

        @Override
        public String getURLViewInContext(
            LiferayPortletRequest liferayPortletRequest,
            LiferayPortletResponse liferayPortletResponse,
            String noSuchEntryRedirect) {

            ThemeDisplay themeDisplay =
                (ThemeDisplay)liferayPortletRequest.getAttribute(
                    WebKeys.THEME_DISPLAY);

            return themeDisplay.getPortalURL() + themeDisplay.getPathMain() +
                "/blogs/find_entry?noSuchEntryRedirect=" +
                    HttpUtil.encodeURL(noSuchEntryRedirect) + "&entryId=" +
                        _entry.getEntryId();
        }

        public long getUserId() {
            return _entry.getUserId();
        }

        public String getUuid() {
            return _entry.getUuid();
        }

        @Override
        public boolean hasEditPermission(PermissionChecker permissionChecker) {
            return BlogsEntryPermission.contains(
                permissionChecker, _entry, ActionKeys.UPDATE);
        }

        @Override
        public boolean hasViewPermission(PermissionChecker permissionChecker) {
            return BlogsEntryPermission.contains(
                permissionChecker, _entry, ActionKeys.VIEW);
        }

        @Override
        public boolean isPrintable() {
            return true;
        }

        public String render(
                RenderRequest renderRequest, RenderResponse renderResponse,
                String template)
            throws Exception {

            if (template.equals(TEMPLATE_ABSTRACT) ||
                template.equals(TEMPLATE_FULL_CONTENT)) {

                renderRequest.setAttribute(WebKeys.BLOGS_ENTRY, _entry);

                return "/html/portlet/blogs/asset/" + template + ".jsp";
            }
            else {
                return null;
            }
        }

        @Override
        protected String getIconPath(ThemeDisplay themeDisplay) {
            return themeDisplay.getPathThemeImages() + "/blogs/blogs.png";
        }

        private BlogsEntry _entry;

    }

Note that in the render method, there is a forward to a JSP in the case of the abstract and the full content templates. The abstract is not mandatory and if it is not provided, the Asset Publisher will show the title and the summary obtained through the appropriate methods of the renderer. The full content template should always be provided. Here is how it looks like for blogs entries:

    <%@ include file="/html/portlet/blogs/init.jsp" %>

    <%
    BlogsEntry entry = (BlogsEntry)request.getAttribute(WebKeys.BLOGS_ENTRY);
    %>

    <%= entry.getContent() %>

    <liferay-ui:custom-attributes-available className="<%= BlogsEntry.class.getName() %>">
        <liferay-ui:custom-attribute-list
            className="<%= BlogsEntry.class.getName() %>"
            classPK="<%= (entry != null) ? entry.getEntryId() : 0 %>"
            editable="<%= false %>"
            label="<%= true %>"
        />
    </liferay-ui:custom-attributes-available>

That's about it. It wasn't that hard, right? Now, to get really fancy, you may need to extend the capabilities of the `AssetRendererFactory` for one of Liferay's core portlets. If so, check out article [Extending an AssetRendererFactory](http://www.liferay.com/web/juan.fernandez/blog/-/blogs/extending-an-assetrendererfactory) by Juan Fern&agrave;ndez that talks about doing just that.

Now you can start enjoying the benefits of the asset framework in your custom portlets. Next we'll learn how to leverage the File Storage Framework of Liferay Portal.

## File Storage Framework

The File Storage Framework: Allows storing files using the back-end of the Document Library. By using this framework you won't have to worry yourself about clustering or backups since that will already be taken care of for the Document Library itself. This framework is used, for example, by the wiki and the message boards of Liferay to store attached files in pages and posts respectively. You can check the source code of these two portlets for great real-life examples of how to use the framework.

## Other frameworks

Liferay has a wide variety of frameworks that make it much easier to develop complex functionalities for your own applications with little effort. These frameworks have evolved from the applications bundled with Liferay out of the box so they have been proven in the real world, even in very high performance portals.

This chapter is a placeholder that provides a quick description to the main frameworks provided with Liferay 6. Note that what follows is a work in progress since more sections will be added over time and some of the current sections will evolve into its own chapter as we add more information and detailed instructions on how to use them over time.

-   Workflow Framework: Allows adding Workflow functionality to your own portlets. One great benefit of using this framework is that you will be able to reuse all of the workflow management UIs provided by Liferay. Also you will be able to abstract your code from the specific workflow engine that will be used (JBPM, Liferay Kaleo, ...). Many Liferay portlets use this framework. If you want a simple example to learn how to use it, the blogs portlet is a good start.

-   Comments Framework: Allows adding comments easily in any portlet without any database code. Many Liferay portlets use this functionality, for example the blogs portlet for the comments of each entry.

-   Custom fields: A portlet that uses custom fields will allow the end user to extend the fields of its data entries with custom ones defined by the end user. To see a list of data types in Liferay that support this functionality just go to the Control Panel -\> Custom Fields.

-   Report abuse: Allow end users to report that some information published in a page should not be there.

-   Inline permissions Framework: Allows enhancing your SQL queries so that the database takes care of checking for view permissions. This is particularly useful when doing queries for data entries that could result in a large number of items (and thus checking of permissions afterward would be very inefficient) or when you want to implement pagination (which would not work fine if permissions are checked afterward and an item is removed). The Document Library or the Message Boards of Liferay are examples of portlets that use this functionality.

Check in the near future for new editions of the Developer's Guide for extended information on each of these frameworks.

