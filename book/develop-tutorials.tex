\chapter{Introduction to Liferay
Development}\label{introduction-to-liferay-development}

How many times have you had to start over from scratch? Probably almost
as many times as you've started a new project, because each time you
have to write not only the code to build the project, but also the
underlying code that supports the project. It's never a good feeling to
have to write the same kind of code over and over again. But each new
project that you do after a while can feel like that: you're writing a
new set of database tables, a new API, a new set of CSS classes and
HTML, a new set of JavaScript functions.

Wouldn't it be great if there were a platform that provided a baseline
set of features that gave you a head start on all that repetitive code?
Something that lets you get right to the features of your app or site,
rather than making you start over every time with the basic building
blocks? There is such a thing, and it's called Liferay DXP.

\begin{figure}
\centering
\includegraphics{./images/dont-start-from-scratch.jpg}
\caption{With Liferay DXP, you never have to start from scratch.}
\end{figure}

\section{Leveraging a Suite of Products, Frameworks and
Libraries}\label{leveraging-a-suite-of-products-frameworks-and-libraries}

Liferay DXP offers developers a complete platform for building web apps,
mobile apps, and web services quickly, using features and frameworks
designed for rapid development, good performance, and ease of use. The
base platform is already there, and it's built as a robust container for
applications that you can put together in far less time than you would
from scratch.

It also ships with a default set of common applications you can make use
of right away: web experience management, collaboration applications
such as forums and wikis, documents and media, blogs, and more. All of
these applications are designed to be customized, as is the system
itself. You can also extend them to include your own functionality, and
this is no hack: because of Liferay's extensible design, customization
is by design.

\begin{figure}
\centering
\includegraphics{./images/liferay-suites.png}
\caption{Liferay DXP ships with suites of applications to get you
started building your site quickly.}
\end{figure}

In short, Liferay was written by developers for developers, to help you
get your work done faster and more easily, to take the drudgery out of
web and mobile app development, so that writing code becomes enjoyable
again.

\section{Build Websites, Intranets, Collaborative Environments, Mobile
Apps, and
More}\label{build-websites-intranets-collaborative-environments-mobile-apps-and-more}

One of the most often cited best characteristics of Liferay is how
versatile it is. It can be used to build websites of all sorts, from
very large websites with hundreds of thousands of articles, to smaller,
highly dynamic and interactive sites. This includes public sites,
internal sites like intranets, or mixed environments like collaboration
platforms.

Developers often choose Liferay for one of these cases and quickly find
that Liferay is a great fit for completely different projects.

\section{Creating Your Own Applications and Extending the Existing
Ones}\label{creating-your-own-applications-and-extending-the-existing-ones}

Liferay DXP is based on the Java platform and can be extended by adding
new applications, customizing existing applications, modifying its
behavior, or creating new themes. You can do this with any programming
language supported by the JVM, such as Java itself, Scala, jRuby,
Jython, Groovy, and others. Liferay DXP is lightweight, can be deployed
to a variety of Java EE containers and app servers, and it supports a
variety of databases. Because of its ability to be customized, you can
add support for more app servers or databases without modifying its
source code: just develop and deploy a module with the features you
need.

Speaking of code and deploying, here are some of the most common ways of
expanding or customizing Liferay DXP's features:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Developing a new full-blown web application. The most common way to
  develop web applications for Liferay DXP is with portlets, because
  they integrate well with other existing applications. You are not,
  however, limited to portlets if you don't need to integrate your apps
  with others.
\item
  Customizing an existing web application or feature. Liferay DXP is
  designed to be extended. Many extension points can be leveraged to
  modify existing behavior, and most of these can be developed through a
  single Java class with some annotations (more details later).
\item
  Creating a new web service~for an external system, a mobile app, an
  IoT device, or anything else.
\item
  Developing a mobile app~that leverages Liferay as its back-end, which
  you can write in a fraction of the normal time thanks to Liferay
  Screens and Liferay Mobile SDK.
\item
  Developing a custom theme~that adapts the look and feel of the
  platform to the visual needs of your project.
\end{enumerate}

\begin{figure}
\centering
\includegraphics{./images/liferay-developer-roles-diagram.png}
\caption{Liferay DXP can be used by developers in many ways.}
\end{figure}

The Liferay platform can be used as a headless platform to develop web
or mobile apps with any technology of your choice (Angular, React,
Backbone, Cocoa, Android's Material Design components, Apache Cordova,
etc). It can also be used as a web integration layer, leveraging
technologies such as portlets to allow several applications to coexist
on the same web page.

\section{Fundamentals}\label{fundamentals}

What are the fundamentals that every Liferay developer should know?

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  It's Open Source and puts a strong emphasis on following standards,
  instead of reinventing the wheel.
\item
  It's based on JavaEE and heavily leverages OSGi and several other
  popular technologies for the Java Platform.
\item
  It is based on a modular architecture and facilitates following a
  modular development paradigm for your own projects.
\item
  You can build your own web applications, portlets, or mobile apps on
  top of it.
\item
  It provides mature development tools, while staying agnostic so each
  developer can use his or her preferred tools.
\item
  It's all about reusing, providing reusable frameworks and libraries
  and allowing you to create your own.
\end{enumerate}

Interested? More details below.

\subsection{Open Source and based on
Standards}\label{open-source-and-based-on-standards}

Liferay DXP is both open source and built in the open, following a
collaborative development model. That means that you can follow new
development as it's happening, make comments on it, and contribute! Here
are some tools that you can use to do all this:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Our ticketing system. All the changes made to the product, including
  all bug fixes, improvements, and new features start with a ticket
  created in JIRA. We have several projects there, but the main one for
  tracking the work of Liferay DXP or for reporting bugs you have found
  (with as many details as you can and steps to reproduce, of course) is
  \href{https://issues.liferay.com/browse/LPS}{LPS}
\item
  \href{http://github.com/liferay}{GitHub}: The home of our source code.
  You can use it to see the code changes as they happen and also to send
  pull requests for improvements. There are also many repos, but the
  main one is
  \href{http://github.com/liferay/liferay-portal}{liferay-portal}
\item
  \href{http://forums.liferay.com}{Forums}: It's where our community
  gets together to share ideas, discuss, and collaborate. Go ahead and
  ask your questions and help others ask theirs.
\item
  \href{http://blogs.liferay.com}{Blogs}: Read the latest news, advice,
  and best practices from key core developers and our most active
  community members.
\item
  \href{https://portal.liferay.dev/participate/}{Participate}: Learn how
  to get started participating. You will find options for all levels of
  expertise and time available.
\end{enumerate}

In addition to being Open Source, Liferay is also heavily based on
standards. This is great news for your project, since it significantly
reduces the lock-in on Liferay. That also encourages us to improve
constantly.

Here are some key standards supported by Liferay DXP:

\begin{itemize}
\item
  \href{https://jcp.org/en/jsr/detail?id=168}{Portlets 1.0} (JSR-168)
  and \href{https://jcp.org/en/jsr/detail?id=286}{Portlets 2.0}
  (JSR-286): Liferay DXP can run any portlets that follow these two
  versions of the specification. Liferay is also heavily involved in the
  upcoming Portlets 3.0 specification.
\item
  \href{http://www.oracle.com/technetwork/java/javaee/javaserverfaces-139869.html}{JSF}~(JSR-127,
  JSR-314, JSR-344): The Java standard for building component based web
  applications. Liferay is an active contributor to the standard and
  lead of the JSF-Portlet Bridge specification.
\item
  \href{http://www.ecma-international.org/ecma-262/6.0/}{EcmaScript
  2015}: The latest incarnation of the JavaScript standard. Liferay's
  tooling provides the ability to use it in all modern browsers thanks
  to the integration of Babel JS.
\item
  \href{https://www.oasis-open.org/committees/cmis}{Content Management
  Interoperability Services}~(CMIS): Liferay's Documents and Media can
  behave as an interface for any external Documents Repository that
  supports this widely adopted standard.
\item
  \href{https://jcp.org/en/jsr/detail?id=170}{Java Content
  Repository}~(JSR-170): Files stored in the internal repository of
  Liferay's Documents and Media can be configured to be stored in a
  JSR-170 compatible repository if desired.
\item
  \href{http://www.webdav.org}{WebDAV}: Any Documents \& Media folder
  can be mounted anywhere WebDAV is supported, such as Windows explorer
  or WebDAV-specific clients.
\item
  \href{http://saml.xml.org}{SAML}~and
  \href{http://oauth.net/core/1.1}{OAuth 1.1}: These are the most widely
  adopted security protocols for SSO and application sign in, supported
  through specific Apps that can be installed from
  \href{http://marketplace.liferay.com}{Liferay's Marketplace}.
\item
  JAX-RS and JAX-WS: Incorporated since Liferay 7 as the preferred
  tooling to create web services.
\item
  \href{https://www.oasis-open.org/committees/wsrp}{WSRP}~1 and 2:
  Allows execution of portlets running in a remote container.
\item
  \href{https://www.osgi.org}{OSGi r6}: Liferay supports a wide range of
  the OSGi family of standards through its own implementations and also
  integrates the high quality implementations of the Apache Felix and
  Eclipse Equinox projects (which we also collaborate). Here are some of
  the most relevant supported standards:

  \begin{itemize}
  \tightlist
  \item
    OSGi runtime: Allowing any OSGi module to run in Liferay DXP
  \item
    Declarative Services: Supports a dynamic component model for Liferay
    development.
  \item
    Configuration Admin: Lets you create highly configurable
    applications that can be reconfigured on the fly. Liferay provides
    an auto-generated UI to change the configuration of any component
    that leverages this standard.
  \end{itemize}
\end{itemize}

\subsection{Technologies}\label{technologies}

Like any open source application, Liferay is built on the shoulders of
giants. When we choose the technology on which to build our platform, it
must have the following characteristics:

\begin{itemize}
\tightlist
\item
  It must balance being modern and being mature enough for demanding and
  critical enterprise environments.
\item
  It should be widely adopted and have a mature community.
\item
  It should be as easy as possible to contribute back, since we love to
  contribute to the open source projects we use.
\item
  It should be possible to use only the piece of the project we need if
  we don't need the whole thing. That way, it's easier to replace that
  piece in the future if we find something that works better.
\end{itemize}

The goal, of course, is to give our developers and users the most up to
date, easy-to-use, and stable platform to build your services on.

\begin{figure}
\centering
\includegraphics{./images/liferay-technologies.png}
\caption{Liferay is based on popular, well known, and well supported
technologies.}
\end{figure}

At its base, Liferay is a JavaEE application that also includes an OSGi
container. This offers the best of both worlds: access to the world's
most robust and fully featured enterprise platform, along with the
benefits of the world's most fully featured and stable modular
container. Now developers can develop and deploy enterprise-ready,
scalable web and mobile-based applications in a dynamic, component-based
environment.

With JavaEE and OSGi at the bottom of the stack, we build the rest of
our core on well known or widely used products:

\begin{itemize}
\tightlist
\item
  Spring for transactions (and Dependency Injection in the core)
\item
  Hibernate for database access (along with direct JDBC access for
  optimized queries)
\item
  Elasticsearch for indexing and searching
\item
  Ehcache for caching.
\end{itemize}

In the application layer, developers have access to many of the
libraries they're familiar with and have been using for years:

\begin{itemize}
\tightlist
\item
  Xalan
\item
  Xerces
\item
  Apache Commons
\item
  Tika
\item
  dom4j
\end{itemize}

If you're approaching Liferay DXP with the intention of customizing it,
you can know that most if not all of the tools you're familiar with are
there. If you're writing applications on Liferay's platform, the sky's
the limit: you can use any web framework you like, and you can write
both servlet and portlet-based applications. If you're looking for a
recommendation, though, we're happy to point you to either our
MVCPortlet or our JSF-based LiferayFaces frameworks.

On the front-end, Liferay has kept pace with the most recent
progressions in that space. If you've used Liferay in the past, you can
of course continue to use Liferay's venerable Alloy UI, but you are also
free to use the front-end technologies you love the most:

\begin{itemize}
\tightlist
\item
  Bootstrap
\item
  SaSS
\item
  EcmaScript 2015 (using Babel.js)
\end{itemize}

You can also use any JavaScript library, including

\begin{itemize}
\tightlist
\item
  Metal.js (developed by Liferay)
\item
  jQuery (included)
\item
  Lodash (included)
\item
  Angular 1 or 2
\item
  React
\item
  Your library of choice
\end{itemize}

Liferay DXP follows a design language created by our designers at
Liferay called \href{https://lexicondesign.io/}{Lexicon Experience
Language}, which has been implemented for use of the web as
\href{https://liferay.github.io/clay/}{Lexicon}.

Lexicon is automatically made available to application developers
through a set of CSS classes and markup, although it's even easier to
use our tag library.

For templating, JavaEE's JSP is there as expected as well as FreeMarker,
but the modularity of the platform allows you to use Google's Soy (aka
Closure Templates) or whatever else you like.

Liferay has also chosen build tools that give you freedom to use any
development environment. Gradle along with bnd powers the product's
build, but project layouts are dynamic, which means you can use anything
from Maven to Ant/Ivy to build applications for Liferay.

In short, Liferay has done a lot to make sure its users and developers
have access to the most widely used, robust tools possible--as well as
the freedom to use the tools they like the most. Know that Liferay has
your back and will do everything we can to provide you with the most
flexible technology platform possible, so that you have the freedom to
go and build great things on it--things we never could have expected or
imagined.

\subsection{Architecture}\label{architecture}

Liferay's design goals have from the beginning been to give you all the
tools to create exactly the web presence you have in mind. To achieve
this, the product must do these things:

\begin{itemize}
\tightlist
\item
  Provide a usable default configuration and interface
\item
  Ship with best-of-breed apps that can be used to build sites quickly
\item
  Make the UI customizable at any level of detail from small tweaks to a
  complete replacement
\item
  Make the apps customizable at any level of detail
\item
  Provide a robust development platform upon which new best-of-breed
  apps can be built and shared
\end{itemize}

\includegraphics{./images/liferay-architecture.png} These goals are now
achieved to the furthest extent ever in Liferay's history, and it's all
because of our new modular architecture.

Imagine an environment where every piece of functionality is an
independent module. The modules declare three important things:

\begin{itemize}
\tightlist
\item
  The functionality they implement or define
\item
  Their dependency on other modules
\item
  Their priority relative to their functionality
\end{itemize}

Using this information, the container can start all the modules that
fulfill their definitions, implementations, dependencies, and
priorities.

Anything a developer wants to do is implemented as one or more modules.
If it's a new application, that application can depend on existing
modules and
\href{/docs/7-0/tutorials/-/knowledge_base/t/configuring-dependencies}{define
a dependency} on them. This enables you to use functionality that's
already there without rewriting it yourself for your app. If it's a
customization, in many cases it's just a simple matter of defining your
customization with a higher priority than the existing functionality.

This is the power of a modular architecture.

\subsubsection{Modules}\label{modules}

All new applications, extensions, and customizations built on Liferay
are built in a modular way. A module is the single unit of distribution
and deployment in a modular architecture.

In the spirit of following existing standards, Liferay has leveraged a
set of very powerful standards known as OSGi. OSGi defines, among other
things, how modules can depend on each other and communicate. It also
defines the packaging format for modules: OSGi bundles. An OSGi module
is just a typical JAR file, familiar to Java developers as a ZIP file
containing compiled code, templates, resources, and some meta
information.

\subsubsection{Services}\label{services}

One aspect of modern software architecture is the notion of services.
These are independently running pieces of code that provide specific
functionality when called. They operate just like services in the real
world do. For example, you might call a service to come mow your lawn.
You know how to call the service and to give it what it needs (money) in
order to receive the service (a mown lawn). Software-based services work
the same way.

Liferay's services are standard services as defined by the OSGi
Alliance. Writing anything, whether it be an application, an interface
to a database, or even a ``service'' as you define it, is easy to
implement as an OSGi service, because they're both incredibly powerful
and easy to develop. If you understand Java interfaces and how they are
implemented--which is introductory Java material--you already understand
more than 90\% of what you need to know. First, you define the
interface, or contract for the service: what it returns, and what it
needs to return what it returns. Next, you define an implementation
class that implements the contract.

In the services model, a class requests the service that provides the
functionality it needs. This functionality is provided (often injected)
with the right implementation automatically. It's similar to Spring or
EJBs with one important addition: implementations can be changed at
runtime, without restarting the system. This is achieved because when
a~service is deployed, it becomes part of a service registry~maintained
by Liferay's OSGi container. The container dynamically manages the
lifecycle of the service and can start and stop services~when
appropriate.

The real power of services shines when they are extended. You can
replace existing implementations or in advanced use cases have several
implementations of a service. The developer can then choose to invoke
all implementations or just the one with the highest priority (specified
with what is called the service ranking).~This means that if Liferay has
a service that does something, you can customize or override that
service by implementing its interface yourself and then deploying it
with a higher ranking than the original service. The container then
instantiates your implementation when the service is called by existing
code. This simple, clean method is how most customizations are made to
Liferay 7.

\subsubsection{Components}\label{components}

In OSGi, possibly the best and certainly the easiest way to create
services is through Declarative Services. In Declarative Services (aka
DS), you create Components. A Component is a Java class (marked with an
\texttt{@Component} annotation) that provides an implementation of a
Service (as described above) and whose instantiation is handled
automatically by DS. This is similar to what you might be used to if you
have used Spring Beans or EJBs. DS also provides dependency injection
using annotations (\texttt{@Reference}). This is convenient because the
``wiring'' of components is done by the container but can be changed
while the server is running (unlike Spring).

Modules may contain as many service declarations and as many components
as desired (or zero, of course).

In software engineering terms, a component is the smallest building
block of a larger application, and that application is itself made up of
many small components. This makes it easier to develop an application
because you only have to deal with small, well-defined, bite-sized
chunks of code at a time.

\subsubsection{Real Life Benefits of Modular
Development}\label{real-life-benefits-of-modular-development}

The next question then becomes, so what? Why is this a big deal? Why
should I have components, and what do I need them for?

It helps to examine two common development scenarios: a customization
task and a full-blown application. Picture this: you have a system that
generates a report in PDF format from data in a database. The data is
captured from a web application running in Liferay. You come in to work
in the morning and something's happened (it doesn't matter what it is;
it could be corrupt data, the company has been bought, or a national
emergency). You need to change that report as fast as possible, either
to insert a new title page, add a warning to the existing title page, or
whatever.

In the monolithic model you'd have to modify the application to change
the report and then you'd have to redeploy the complete application. If
this was a temporary change, to restore the application to its original
state you'd again have to modify the application and redeploy it.

With a modular and component-based application, you'd fix a simple,
small component--probably one Java class--that provides the
functionality you need. You'd then deploy its module to the server. If
you need to roll back that change in the future, you'd just do the same
thing in reverse. In each case, you're only changing and redeploying the
small piece of functionality that needs to change, not the whole
application. At no time would you ever have to redeploy the whole
application or take the server down.

For a full-blown application, the benefits are even greater. Modular
development helps developers be more efficient in three important ways:

\begin{itemize}
\tightlist
\item
  An application made up of components can be written in parallel by
  multiple developers working on different components.
\item
  An existing application can be extended by writing new components to
  implement features in different ways.
\item
  Components can be enabled and disabled, allowing administrators to
  choose which features to enable in production.
\end{itemize}

For example, Liferay's Documents and Media library is a file repository
that supports many back-ends. Each back-end is a component that can be
maintained by different developers. They can be added and removed on the
fly while the server is running.

Similarly, the services provided by the application are independent of
the front-end technology. In fact, there can be multiple front-ends,
from the web-based front-end Liferay provides out of the box, to a new
front-end you might develop for either the web or mobile.

As you can see, many components running inside Liferay's OSGi container
form something of an ecosystem of complementary services. Much of
Liferay's functionality is in components, and when you deploy your code,
it sits in the same ecosystem as Liferay's, with the same extension
points. You can write components to provide new services or to override
existing services with your own implementation, and the container
manages it all. Liferay is an exciting platform that empowers developers
to be more productive.

\section{Liferay as a Development
Platform}\label{liferay-as-a-development-platform}

If you've been reading everything up to this point, you've heard all
about Liferay DXP's architecture, modularity, and technologies. What's
left is to tell you what it's like to use Liferay's platform as a basis
for your site by customizing it or by developing applications on it. The
platform is designed to make this easy and pleasant, and to integrate
with the tools developers use every day.

But you're likely not interested in a bunch of prolegomena about it.
Read on to learn the details.

\subsection{Web Applications and
Portlets}\label{web-applications-and-portlets}

Liferay as a development platform has always provided flexibility for
both administrators and developers by making it easy to have more than
one application on a single page. Applications written this way are
called \emph{portlets}, and are a mainstay of Liferay's platform. You
can use Liferay's MVC Portlet framework or common frameworks such as
Spring MVC or JSF to write portlets. If you plan to have a web-based
interface to your application,~and want its administrator to have a lot
of flexibility configuring it, portlets provide a very powerful model.
In this model you can create several portlets instead of a larger
application and let the administrator choose how to combine them with
other pre-existing portlets into a larger interface.

That's not to say you don't have other choices. Since Liferay decouples
its business logic from its UI (which is provided in separate modules),
you have freedom to implement the UI in any other technology.

Because of this, you can use Liferay as a headless platform, because
it's easy to create web services based on Service Builder, JAX-RS, and
JAX-WS. Then you can build standalone web applications using any
front-end technology or mobile technology you like.

\subsection{Extensibility}\label{extensibility}

As you might imagine, the system described above contains all the tools
necessary to make a well designed system that allows developers not only
to create applications based on modules, but also to extend the existing
functionality of the system. Liferay can benefit from this now because
the platform on which it rests is designed for both application
development and customization.

Components make developing extensions and customizations convenient. If
you compare this model to other products that aren't designed for
customization, you'll see just how convenient it can be.

To customize an existing service, the only thing you need to do is
deploy a component that extends the existing implementation. If you want
to remove your implementation and revert back to the default behavior,
you simply un-deploy your component.

Compare that with the traditional way of customizing software by
downloading its source and maintaining a set of patches against it. Each
time the software is updated, you have to re-download the source,
re-apply your patches, and recompile the software.

With Liferay, your custom code is kept in your own modules, which the
container takes care of applying based on metadata you supply.

\subsection{Developer Tools}\label{developer-tools}

As you learned above, Liferay's OSGi container gives you these benefits:

\begin{itemize}
\tightlist
\item
  The container can start and stop components.
\item
  A component implements~an OSGi service.
\item
  A component may use or consume OSGi services.
\item
  The framework manages~the binding of the services a component consumes
  (just like Spring or EJBs, but dynamically).
\end{itemize}

If all of this sounds great to you (as it does to us), there's only one
thing left: how do you get started developing components? We believe in
providing an easy path for new developers while at the same time
preserving flexibility for experienced developers with strong tooling
preferences. To achieve that, Liferay provides some great tools, and if
you're an experienced developer, these also integrate into what you
likely already use. If you use any of the standard build tools like
Gradle or Maven, any text editor or common Java IDEs like Eclipse,
intelliJ, or NetBeans, or any testing framework like Spock or JUnit, you
can use them with Liferay to develop components.

Liferay's tools add some important enhancements:

\begin{itemize}
\tightlist
\item
  Blade CLI speeds you up by creating Gradle-based Liferay projects from
  templates.
\item
  Liferay Workspace is an opinionated SDK based on Gradle that~uses
  Blade CLI to integrate your projects and your runtime into one
  convenient, distributable and sharable place.
\item
  Liferay IDE is an Eclipse-based development environment that
  integrates all the convenience of Blade CLI and Liferay Workspace into
  a best-of-breed graphical environment with all the bells and whistles
  you'd expect.
\item
  Liferay Developer Studio provides all that Liferay IDE provides, plus
  additional tools that enterprise developers need.
\item
  Liferay Service Builder helps you create your back-end faster by
  generating all your database tables, local services, and web services
  from a single XML file.
\end{itemize}

You can choose to use or ignore Liferay's tools. The point is you have
the freedom to do that, because Liferay provides an open development
framework that's designed to meet you where you are. We hate proprietary
lock-in as much as you do, so our tools are designed to complement the
tools you're using already instead of replacing them.

Beyond build tools and IDEs are the frameworks you'll use to build
applications. Liferay's development frameworks include a lot of
functionality--comments, social relationships, user management, and lots
more--to speed up development of your applications. They help you build
applications out of well-tested, modern, scalable, skinnable building
blocks. You wind up not only with a great, functional application, but
also with one that took less time to develop, looks the way you want it
to, and performs well. This doesn't mean you're limited only to what
Liferay provides; again, you can use third-party frameworks if that's
what you like to use.

To develop portlets, Liferay provides a convenient and easy-to-use
framework called MVCPortlet to make writing portlets easy, but
developers are free to use any other framework, such as Spring MVC, to
create portlets. MVCPortlet uses components to handle requests,
benefiting from all the characteristics described above (lifecycle,
extensibility, ease of composition, etc.). If you don't have a strong
opinion on which framework to use, we recommend that you try it out.

Liferay also includes a utility called Service Builder that makes it
easy to create back-end database tables, an object-relational map in
Java for accessing them, and a place to put your business logic. It can
also generate JSON or SOAP web services, giving developers a full stack
for storing and retrieving data using web or mobile clients. But that
doesn't prevent you from using Java Persistence (JPA) and generating
JAX-WS web services.

In addition to the tooling, Liferay also provides many reusable
frameworks.

\subsection{Frameworks and APIs}\label{frameworks-and-apis}

Liferay's development platform provides a great framework for
application development and also offers APIs. Lots of them. Applications
can be created by leveraging Liferay's many frameworks that encapsulate
features that are commonly needed by today's applications. For example,
a commenting system allows developers to attach comments to any asset
that they define, whether they be assets they develop or assets that
ship with the system. Assets are shared by the system and are used to
represent many common elements, such as Users, Organizations, Sites,
User Groups, blog entries, and even folders and files.

Liferay also includes many frameworks for operating on assets. A
workflow system makes it easy to create applications that require an
approval process for users to follow. The recycle bin stores deleted
assets for a specified period of time, making it easy for users to
restore data without the intervention of an administrator. A file
storage API with multiple available back-ends makes storing and sharing
files trivial. Search is built into the system as well, and it is
designed for developers to integrate it with their applications. Many of
the frameworks you might need when developing complex applications are
already there; you just need to take advantage of them: a Social
Networking API, user-generated forms with data lists, a message bus, an
audit system, and much more.

\subsection{Example Liferay Projects}\label{example-liferay-projects}

Enough theory. It's time for practice. A good way to get the flavor of
developing on Liferay's platform across is to show you some projects.
First, you'll see a portlet developed with MVCPortlet, showcasing the
use of components as well. Once you've seen that, the next best thing is
to see an extension. Both of these examples serve to show you how easy
it is to build functionality following a modular paradigm.

It would be nice to show you the standard Hello World project, Liferay
style, but that would be too easy: the default template that Blade or
Liferay IDE creates already does that by default. Instead, you'll see
the Hello \emph{You} portlet. This does the same thing as Hello World,
except it adds the first name of the user to the message. If your name
therefore is John, it'll return Hello, John.

Here's what the project layout looks like:

\begin{figure}
\centering
\includegraphics{./images/hello-you-portlet-layout.png}
\caption{The Hello You portlet has a simple project structure.}
\end{figure}

No new files were created after this project was generated~by Liferay's
Blade CLI tool, so this is as simple as it gets. You have your portlet
class, which is in the .java file. You also have two different kinds of
resources: language properties and JSP files. Finally, the
\texttt{bnd.bnd} file describes the application's metadata for the OSGi
container, and the \texttt{build.gradle} file builds the project.

Any web developer that's familiar with Java can understand the JSPs, but
some explanation is in order because of the style. Liferay's coding
style defines a single \texttt{init.jsp} that contains all the imports
and tag library initializations necessary for the front-end. This way,
any JSP can simply include \texttt{init.jsp}, and all of its imports are
satisfied. The \texttt{init.jsp} for this project was not modified from
the generated project, and it looks like this:

\begin{verbatim}
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %>

<%@ taglib uri="http://java.sun.com/portlet\_2\_0" prefix="portlet" %>

<%@ taglib uri="http://liferay.com/tld/aui" prefix="aui" %>

<%@ taglib uri="http://liferay.com/tld/portlet" prefix="liferay-portlet" %>

<%@ taglib uri="http://liferay.com/tld/theme" prefix="liferay-theme" %>

<%@ taglib uri="http://liferay.com/tld/ui" prefix="liferay-ui" %>

<liferay-theme:defineObjects />

<portlet:defineObjects />
\end{verbatim}

As you can see, all it does is declare the tag libraries you probably
want to use, and then it calls a couple of tags that makes objects from
the portlet framework available. Since there's nothing really
interesting here, you'll want to look at \texttt{view.jsp} next:

\begin{verbatim}
<%@ include file="/init.jsp" %>

<jsp:useBean id="userName" type="java.lang.String" scope="request" />

<p>

    <b>Hello, <%=userName %>!</b>

</p>
\end{verbatim}

Now we've got something. The portlet class (the Controller, in MVC
terms) has made a \texttt{userName} string available in the request, and
this JSP retrieves it and uses it to say hello to the user. The real
functionality, therefore is in the portlet class:

\begin{verbatim}
@Component(
    immediate = true,
    property = {
        "com.liferay.portlet.display-category=category.sample",
        "com.liferay.portlet.instanceable=true",
        "javax.portlet.display-name=hello-you Portlet",
        "javax.portlet.init-param.template-path=/",
        "javax.portlet.init-param.view-template=/view.jsp",
        "javax.portlet.resource-bundle=content.Language",
        "javax.portlet.security-role-ref=power-user,user"
    },
    service = Portlet.class
)
public class HelloYouPortlet extends MVCPortlet {

    @Override
    public void render(RenderRequest renderRequest, 
                    RenderResponse renderResponse)
            throws IOException, PortletException
    {
        ThemeDisplay themeDisplay = (ThemeDisplay)
                    renderRequest.getAttribute(WebKeys.THEME\_DISPLAY);

        User user = themeDisplay.getUser();

        renderRequest.setAttribute("userName", 
                    user.getFirstName());



        super.render(renderRequest, renderResponse);
    }

}
\end{verbatim}

Now we're talking; here's the real stuff. At the top is the
\texttt{@Component} annotation, which tells the OSGi container how it
should treat this module. By specifying \texttt{immediate=true}, you're
saying that when this module is deployed and all of its dependencies are
satisfied, it should be started immediately instead of being
lazy-loaded. Next are several
\href{/docs/7-0/reference/-/knowledge_base/r/portlet-descriptor-to-osgi-service-property-map}{properties
specific to portlets}: the category in which it should appear in
Liferay's UI, its display name, its default view, and more. Finally, the
service--which is just a Java Interface--that it implements is defined,
which is the portlet class.

Next, you have the class itself, which extends Liferay's
\texttt{MVCPortlet} class (that extends \texttt{GenericPortlet}, that
implements \texttt{Portlet}). The only method overridden is the
\texttt{render()} method, and Liferay's API is used to get the user's
first name and put it in a request attribute called \texttt{userName}.

So you can see how this works: the portlet runs and retrieves the user's
first name, puts that in the request, and then by the use of the
template path and view template properties specified in the
\texttt{@Component} annotation, forwards processing to
\texttt{view.jsp}, where the user's first name is retrieved and
displayed.

The only other item of interest is the \texttt{bnd.bnd} file:

\begin{verbatim}
Bundle-SymbolicName: com.liferay.docs.hello.you
Bundle-Version: 1.0.0
\end{verbatim}

This declares the name of the module (sometimes also called a bundle).
It's a good practice to namespace it properly to avoid name conflicts in
the container. The version is also declared, which allows the container
to manage dependencies down to the version level of a module. This is
called Semantic Versioning, and is a discussion by itself.

That's all there is to this portlet. Next, you'll see an extension,
which in many cases is even simpler than a portlet.

Liferay's UI is divided up into several areas. There's the control menu
and the product menu, which contains the add menu and the simulation
menu. If you want to extend the UI, you can do that by deploying a
module that adds what you want. In this example, you'll add a link to
the product menu, which is the menu that by default sits in the top
right of the browser:

\begin{figure}
\centering
\includegraphics{./images/product-menu-unchanged.png}
\caption{The product menu appears beneath the user's profile link.}
\end{figure}

To this, you'll add a link to this website:

\begin{figure}
\centering
\includegraphics{./images/product-menu-with-link.png}
\caption{You can add links to the product menu by deploying a
component.}
\end{figure}

As with the portlet project, this project's layout contains only a few
items that are easy to understand.

\begin{figure}
\centering
\includegraphics{./images/product-menu-project-layout.png}
\caption{The product menu project is simpler than the portlet was.}
\end{figure}

As before, you have a build script, a \texttt{bnd.bnd} file that
declares the module's name and version, and this time, only a Java class
and a language properties file.

The Java class defines only four methods:

\begin{verbatim}
@Component(
    immediate = true,
    property = {
        "product.navigation.control.menu.category.key=" +
                 ProductNavigationControlMenuCategoryKeys.USER,
        "product.navigation.control.menu.entry.order:Integer=1"
    },
    service = ProductNavigationControlMenuEntry.class
)
public class DevProductNavigationControlMenuEntry
    extends BaseProductNavigationControlMenuEntry
    implements ProductNavigationControlMenuEntry {

    @Override
    public String getIcon(HttpServletRequest request) {

        return "link";
    }

    @Override
    public String getLabel(Locale locale) {

        ResourceBundle resourceBundle = ResourceBundleUtil.getBundle(
            "content.Language", locale, getClass());

        return LanguageUtil.get(resourceBundle, "custom-message");
    }

    @Override
    public String getURL(HttpServletRequest request) {

        return "https://portal.liferay.dev";

    }

    @Override
    public boolean isShow(HttpServletRequest request) throws 
        PortalException {

        return true;
    }

}
\end{verbatim}

As before, this project was generated using a template from Blade CLI.
The source code is part of the template; the only thing you'll need to
do is provide the link.

The first method gets the Font Awesome icon you want to use in the menu.
The next gets the ``label,'' the text that appears when a user hovers
the mouse over the link. This text is the value of the only property in
the \texttt{Language.properties} file:

\begin{verbatim}
custom-message=Liferay Developer Network
\end{verbatim}

The next method returns the URL that's the destination for this link,
and the final method returns a boolean for showing or hiding the link.

When you deploy this module, the link is added to the menu when the
module starts. You don't have to mess around looking in Liferay's JSP or
JavaScript files to customize the menu: it's an extension point, and it
is designed to be customized.

This is the modular paradigm for development. It helps you keep a clean
separation of your code, whether it be applications or extensions, from
the code that ships by default, and it gives you the power to customize
the system dynamically, while it's running, to avoid downtime. It is a
different way of doing things, but we believe it's a better way. When
you start working with modules and see the benefits you can gain, we
think you'll agree.

Now you're ready to explore some more about Liferay. We're not planning
to leave you here, as though this were a dead site. Please feel free to
use the suggestions link at the bottom of every article you'll encounter
if you think something could be improved about that article. If you have
feedback about the site itself, the feedback button is always floating
at the bottom right. There are living, breathing people behind all the
content on this site, and we stand ready to assist you on your Liferay
journey.

\chapter{Introduction to Front-End
Development}\label{introduction-to-front-end-development}

When approaching the development of your application's front-end,
Liferay DXP offers a wide range of approaches, frameworks, utilities,
and mechanisms to make your life easier.

\section{JavaScript}\label{javascript}

If you've used Liferay in the past, you can of course continue to use
Liferay's venerable Alloy UI, but you are also free to use the front-end
technologies you love the most:

\begin{itemize}
\tightlist
\item
  ECMAScript 2015
\item
  Metal.js (developed by Liferay)
\item
  AlloyUI (developed by Liferay)
\item
  jQuery (included)
\item
  Lodash (included)
\end{itemize}

\section{Lexicon}\label{lexicon}

Liferay DXP follows a design language created by our designers at
Liferay called \href{https://lexicondesign.io/}{Lexicon Experience
Language}, which has been implemented for use of the web as
\href{https://liferay.github.io/clay/}{Lexicon}.

Lexicon is automatically made available to application developers
through a set of CSS classes and markup, although it's even easier to
use our tag library.

\section{Templates}\label{templates}

For templating, Java EE's JSP is there as expected as well as
FreeMarker, but the platform's modularity enables using Google's Soy
(aka Closure Templates) or whatever else you like.

\section{Themes}\label{themes}

A Liferay Theme is the overall look and feel for a site. Themes are a
combination of CSS, JavaScript, HTML, and FreeMarker templates. Although
the default themes are nice, you may wish to create your own look and
feel for your site.

In Liferay DXP, Liferay provides an easy-to-use tool called the
\href{/docs/7-0/tutorials/-/knowledge_base/t/themes-generator}{Liferay
Theme Generator} that helps automate the theme development process.

Themes created with the Liferay Theme Generator give you access to
\href{/docs/7-0/reference/-/knowledge_base/r/theme-gulp-tasks}{theme
gulp tasks} that offer basic functions, such as \texttt{build} and
\texttt{deploy}, along with more complex interactions, such as auto
deploying when a change is made and setting the base theme.

\section{Front-End Extensions}\label{front-end-extensions}

Liferay DXP's modularity has many benefits for the front-end developer,
in the form of development customizations and extension points. These
extensions assure the stability, conformity, and future evolution of
your applications.

Below are some of the available front-end extensions:

\begin{itemize}
\tightlist
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/theme-contributors}{Theme
  Contributors}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/context-contributors}{Context
  Contributors}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/portlet-decorators}{Portlet
  Decorators}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/modifying-an-editors-configuration}{Editor
  Config Contributors}
\end{itemize}

\chapter{JavaScript in Liferay DXP}\label{javascript-in-liferay-dxp}

Liferay DXP's front-end is extendable, flexible, and future ready.

Like previous versions, many components are written using
\href{http://alloyui.com}{AlloyUI}. AlloyUI is based on
\href{http://yuilibrary.com/}{YUI}, and is no longer under active
development. Because of this, we have included
\href{https://jquery.com}{jQuery} and also have developed a new
framework called \href{http://metaljs.com}{MetalJS}.

\section{MetalJS}\label{metaljs}

Metal.js is a JavaScript library for building UI components in a solid
and flexible way. Metal is built from the ground up with performance in
mind and is flexible enough to be built as global objects, AMD modules,
or jQuery plugins. Metal is cutting edge JavaScript, using
\href{http://www.ecma-international.org/ecma-262/6.0/}{ECMAScript 6
(ES6)/ ECMAScript 2015 (ES2015)}, which provides you with clean code
that's easy-to-read.

\begin{figure}
\centering
\includegraphics{./images/metaljs-website.png}
\caption{Metal.js is a new framework for building UI components.}
\end{figure}

For more information see the \href{http://metaljs.com/docs/}{Metal.js
docs}.

\section{ES2015}\label{es2015}

\href{http://www.ecma-international.org/ecma-262/6.0/}{ECMAScript 6
(ES6)/ ECMAScript 2015 (ES2015)} is enabled by default in your plugins,
so you can write your own modules using the latest improvements to the
language.

You can learn more about how to leverage ES6 in your modules in the
\href{/docs/7-0/tutorials/-/knowledge_base/t/preparing-your-javascript-files-for-es2015}{Preparing
Your JavaScript Files for ES2015} and
\href{/docs/7-0/tutorials/-/knowledge_base/t/using-es2015-modules-in-your-portlet}{Using
ES2015 Modules in your Portlet} tutorials.

\section{AlloyUI}\label{alloyui}

AlloyUI is an open source front-end framework built on top of
\href{http://yuilibrary.com}{Yahoo! User Interface Library (YUI)}. It
leverages all of YUI's modules and adds even more cutting edge
components and features to help you build terrific UIs. AlloyUI provides
the following key benefits:

\begin{itemize}
\tightlist
\item
  Create modern UI components that provide a consistent look \& feel
  across Liferay DXP.
\item
  Server-agnostic, so you can use it with any technology.
\end{itemize}

As of 7.0, AlloyUI has been officially sunsetted. This means that we are
no longer developing new features for it, but it is still included in
the product and actively maintained.

\begin{figure}
\centering
\includegraphics{./images/alloyui-website.png}
\caption{AlloyUI is sunsetted as of 7.0.}
\end{figure}

\section{jQuery}\label{jquery}

jQuery is a cross-platform JavaScript library designed to simplify the
client-side scripting of HTML. It is the most popular JavaScript library
in use today. The syntax is designed to make it easier to navigate a
document, select DOM elements, create animations, handle events, and
develop Ajax applications.

While jQuery is great for small websites, once you start creating highly
scalable applications like Java portals, you'll need a more robust
solution. That being the case, we strongly recommend you to use one of
our other provided solutions mentioned above.

\begin{figure}
\centering
\includegraphics{./images/jquery-website.png}
\caption{jQuery is a fast, small, and feature-rich JavaScript library.}
\end{figure}

\chapter{Metal.js}\label{metal.js}

Metal.js is a lightweight, easy-to-use JavaScript framework that lets
you create UI Components with ease, thanks to its integration with
templating languages.

\begin{figure}
\centering
\includegraphics{./images/metal-js-home-page.png}
\caption{You can create UI's easily, thanks to Metal.js.}
\end{figure}

Metal.js is built with you in mind, offering flexibility with how your
rendering logic is handled. You can use template languages to write your
rendering logic or keep your rendering logic and business logic within
the same file if you prefer.

By default, Metal.js offers integration points with Google closure
templates and Facebook JSX templates. The rendering layer is completely
customizable though, so you can add more rendering options if needed.

Below is an example of a closure(Soy) template written for Metal.js:

\begin{verbatim}
{template .render}
// ...
<button onClick="{$close}" type="button" class="close">
// ...
{/template}
\end{verbatim}

Metal.js has two main classes: \texttt{State}, and \texttt{Component}
which extends from \texttt{State}. The \texttt{Component} class adds
additional rendering features for your Component. If your Component
doesn't require rendering, you can just use \texttt{State}.

The figure below illustrates the architecture for Metal.js:

\includegraphics{./images/metal-js-architecture.png}

Metal.js takes full advantage of the
\href{http://www.ecma-international.org/ecma-262/6.0/}{ECMAScript 6}
(AKA ECMAScript 2015) language, so you can use the latest features that
the language has to offer. Below is a list of some of the great features
that you get with ES6:

\begin{itemize}
\item
  Class syntax like other OO languages. Classes support prototype-based
  inheritance, super calls, instance and static methods and
  constructors.
\item
  Arrow method syntax.
  \texttt{var\ odds\ =\ numbers.map(v\ =\textgreater{}\ v\ +\ 1);}
\item
  Language-level support for modules for Component definition. Codifies
  patterns from popular JavaScript module loaders like AMD (as shown
  below):

\begin{verbatim}
  export function sum(x, y) {
    return x + y;
  }
  export var pi = 3.141593;
\end{verbatim}
\end{itemize}

These are just a few of the ES6 features available that you can use in
your Metal.js components.

\section{Related Topics}\label{related-topics}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-a-soy-portlet}{Creating
a Soy Portlet}

\href{/docs/7-0/tutorials/-/knowledge_base/t/javascript-module-loaders}{JavaScript
Module Loaders}

\chapter{Starting Module Development}\label{starting-module-development}

Developing modules for Liferay DXP requires:

\begin{itemize}
\item
  \textbf{Creating a folder structure}: A good folder structure
  facilitates evolving and maintaining code, especially in
  collaboration. Popular tools use pre-defined folder structures
  familiar to developers.
\item
  \textbf{Writing code and configuration files}: A manifest, Java
  classes, and resources. Modules stubbed out with them let developers
  focus on implementing logic.
\item
  \textbf{Compilation}:
  \href{/docs/7-0/tutorials/-/knowledge_base/t/configuring-dependencies}{Acquiring
  dependencies} and building the module. Common build tools that manage
  dependencies include Gradle, Maven, and Ant/Ivy.
\item
  \textbf{Deployment}: Interacting with the runtime environment to
  install, monitor, and modify modules.
\end{itemize}

There are several good build tools for developing modules on Liferay
DXP. This tutorial demonstrates starting a new module using Liferay
Workspace. It's Liferay's opinionated build environment based on Gradle
and BndTools that simplifies module development and automates much of
it.

\noindent\hrulefill

\textbf{Note}: Liferay supports developers using their build tool of
choice. In addition to providing Liferay Workspace for those who don't
already have a preferred build environment, Liferay provides good
support for Maven and Gradle. The following tutorials and samples
demonstrate developing in these environments.

\begin{itemize}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/maven}{Maven tutorials}
  and
  \href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-sample-modules}{samples}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/using-gradle-in-liferay-ide}{Gradle
  in Liferay @ide@} and
  \href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-sample-modules}{samples}
\end{itemize}

\noindent\hrulefill

\noindent\hrulefill

\textbf{Note}: Themes and Layout Templates are not built as modules. To
learn how to create them, see the
\href{/docs/7-0/tutorials/-/knowledge_base/t/themes-and-layout-templates}{Themes
and Layout Templates tutorials}.

\noindent\hrulefill

Here are the steps for starting module development:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \hyperref[setting-up-a-liferay-workspace]{Set up a Liferay Workspace}
\item
  \hyperref[creating-a-module]{Create a module}
\item
  \hyperref[building-and-deploying-a-module]{Build and deploy the
  module}
\end{enumerate}

On completing this tutorial you'll have created a module and deployed it
to a local Liferay DXP bundle.

\section{Setting up a Liferay
Workspace}\label{setting-up-a-liferay-workspace}

Creating and configuring a Liferay Workspace (Workspace) is
straightforward using a tool called Blade CLI (Blade). Blade is a
command line tool that creates Workspaces and performs common tasks.

Follow the steps in
\href{/docs/7-0/tutorials/-/knowledge_base/t/installing-blade-cli}{this
tutorial to install Blade} if you don't already have it.

The \texttt{blade} executable is now in the system path.

You can create a Workspace in the current directory by executing this
command:

\begin{verbatim}
blade init <workspaceName>
\end{verbatim}

You've created a Workspace! Its directory structure looks like the one
shown in the figure below.

\begin{figure}
\centering
\includegraphics{./images/starting-module-dev-workspace-structure.png}
\caption{Liferay Workspace aggregates projects so they can leverage the
Gradle build environment.}
\end{figure}

Workspace can be configured to use a Liferay DXP installation bundle
anywhere on the local file system. The
\texttt{liferay.workspace.home.dir} property in
\texttt{gradle.properties} sets the default bundle location to a folder
\texttt{\textless{}workspace\textgreater{}/bundles} (not yet created).
For convenience it's suggested to
\href{/docs/7-0/deploy/-/knowledge_base/d/preparing-for-install}{install
a Liferay DXP bundle} there. If you install it to a different location,
uncomment the \texttt{liferay.workspace.home.dir} property and set it to
that location.

\noindent\hrulefill

\textbf{Note}: User interfaces in Liferay @ide@ lets developers create
and import Liferay Workspace projects.

To create a project, follow the tutorial
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-a-liferay-workspace-with-liferay-ide}{Creating
a Liferay Workspace Project with Liferay @ide@}.

To import a project, use the wizard from \emph{File → Import → Liferay →
Liferay Workspace Project}.

\noindent\hrulefill

The Workspace is ready for creating modules.

\section{Creating a Module}\label{creating-a-module}

Blade provides module \emph{templates} and module \emph{samples}. The
templates stub out files for different types of modules. The samples can
be generated in a Workspace and demonstrate many module types.
Developers can use templates and samples to develop modules.

\subsection{Using Module Templates}\label{using-module-templates}

The Blade command \texttt{blade\ create\ -l} lists the module templates.

\begin{figure}
\centering
\includegraphics{./images/starting-module-dev-blade-templates.png}
\caption{Blade's \texttt{create} command generates a module based on a
template. Executing \texttt{create\ -l} lists the template names.}
\end{figure}

\noindent\hrulefill

\textbf{Note}: Liferay @ide@'s module wizard lets developers select a
template for their module project. For details, see the tutorial
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-modules-with-liferay-ide}{Creating
a Module with Liferay @ide@}.

\noindent\hrulefill

Here's the command syntax for creating a module:

\begin{verbatim}
blade create [options] moduleName
\end{verbatim}

Module templates and their options are described
\href{/docs/7-0/reference/-/knowledge_base/r/project-templates}{here}.

Here's an example of creating a Liferay MVC Portlet module:

\begin{verbatim}
blade create -t mvc-portlet -p com.liferay.docs.mymodule -c MyMvcPortlet my-module
\end{verbatim}

Module projects are created in the \texttt{modules} folder by default.

Here's the module project anatomy:

\begin{itemize}
\item
  \texttt{src/main/java/} → Java package root
\item
  \texttt{src/main/resources/content/} (optional) → Language resource
  bundle root
\item
  \texttt{src/main/resources/META-INF/resources/} (optional) → Root for
  UI templates, such as JSPs
\item
  \texttt{bnd.bnd} → Specifies essential OSGi module manifest headers
\item
  \texttt{build.gradle} →
  \href{/docs/7-0/tutorials/-/knowledge_base/t/configuring-dependencies}{Configures
  dependencies} and more using Gradle
\end{itemize}

The figure below shows an MVC portlet module project.

\begin{figure}
\centering
\includegraphics{./images/starting-module-dev-module-structure.png}
\caption{Liferay modules use the standard Maven directory structure.}
\end{figure}

Sample modules are another helpful development resource.

\subsection{Using Module Samples}\label{using-module-samples}

An alternative to creating a module from a template is to generate a
\emph{sample} module. Developers can examine or modify sample modules as
desired.

This command lists the sample names:

\begin{verbatim}
blade samples
\end{verbatim}

The figure below shows the listing.

\begin{figure}
\centering
\includegraphics{./images/starting-module-dev-blade-samples.png}
\caption{The \texttt{blade\ samples} command lists the names of sample
modules developers can create, examine, and modify to meet their needs.}
\end{figure}

Here's the Blade samples command syntax:

\begin{verbatim}
blade samples <sampleName>
\end{verbatim}

It creates the sample project in a subfolder of the current folder.

Building a module and deploying it to Liferay DXP is easy.

\section{Building and Deploying a
Module}\label{building-and-deploying-a-module}

Liferay Workspace provides Gradle tasks for building and deploying
modules. Blade's \texttt{blade\ gw} command solves a common need in
Gradle projects: invoking the Gradle wrapper from any project directory.
You can use \texttt{blade\ gw} just as you would invoke
\texttt{gradlew}, without having to specify the wrapper path.

\noindent\hrulefill

\textbf{Note}: For an even simpler Gradle wrapper command, install
\emph{gw}.

\texttt{(sudo)\ jpm\ install\ gw@1.0.1}

Usage: \texttt{gw\ \textless{}task\textgreater{}}

\noindent\hrulefill

In a module folder, execute this command to list the Gradle tasks
available:

\begin{verbatim}
blade gw tasks
\end{verbatim}

Workspace uses BndTools to generate the module's OSGi
\texttt{MANIFEST.MF} file and package it in the module JAR. To compile
the module and generate the module JAR, execute the \texttt{jar} Gradle
task:

\begin{verbatim}
blade gw jar
\end{verbatim}

The generated JAR is in the module project's \texttt{build/libs} folder
and ready for deployment to Liferay DXP.

Start your Liferay DXP server, if you haven't already started it.

\noindent\hrulefill

\textbf{Tip}: To open a new terminal window and the Workspace's Liferay
DXP server (bundled with Tomcat or JBoss/Wildfly), execute this command:

\texttt{blade\ server\ start\ -b}

\noindent\hrulefill

Blade can deploy modules to any local Liferay DXP server. It
communicates with Liferay DXP's OSGi framework using Felix Gogo shell
and deploys modules directly to the OSGi container using Felix File
Install commands. The command uses the default port \texttt{11311}.

To deploy the module, execute this command:

\begin{verbatim}
blade deploy
\end{verbatim}

Also Blade lets developers deploy all modules in the current folder
tree. To deploy all modules in a Workspace's modules folder, for
example, execute \texttt{blade\ deploy} in the
\texttt{\textless{}workspace\textgreater{}/modules} folder.

If you're using Liferay @ide@, you can deploy modules by dragging them
from the Package Explorer onto the Liferay DXP server. @ide@ provides
access to
\href{/docs/7-0/tutorials/-/knowledge_base/t/managing-module-projects-with-liferay-ide}{Liferay
Workspace Gradle tasks} too.

\begin{figure}
\centering
\includegraphics{./images/starting-module-dev-drag-module.png}
\caption{Liferay @ide@ lets developers deploy modules using
drag-and-drop.}
\end{figure}

\noindent\hrulefill

\textbf{Note:} When deploying a module to Liferay DXP using Blade CLI,
the module is directly installed into Liferay DXP's OSGi container. This
means that the module is stored differently in Liferay DXP than if it
were copied into the \texttt{LIFERAY\_HOME/deploy} folder. See the
\href{/docs/7-0/tutorials/-/knowledge_base/t/deploying-modules-with-blade-cli}{Deploying
Modules with Blade CLI} tutorial for more information.

\noindent\hrulefill

Once you've deployed a portlet module, it's available in the Liferay DXP
UI under the application category and name you specified via the portlet
component's \texttt{com.liferay.portlet.display-category} and
\texttt{javax.portlet.display-name} properties in the
\texttt{@Component} annotation.

\begin{figure}
\centering
\includegraphics{./images/starting-module-dev-portlet.png}
\caption{Here's a bare-bones portlet based on one of Liferay's module
templates.}
\end{figure}

\section{Redeploying Module Changes
Automatically}\label{redeploying-module-changes-automatically}

Blade lets developers set a \emph{watch} on changes to a module
project's output files. If they're modified, Blade redeploys the module
automatically. To set a watch on a module at deployment, execute this
command in the module project:

\begin{verbatim}
blade deploy -w
\end{verbatim}

Here's output from deploying (and watching) a module named
\emph{com.liferay.docs.mymodule}:

\begin{verbatim}
E:\workspaces\my-liferay-workspace\modules\my-module-project>blade deploy -w

:modules:my-module-project:compileJava UP-TO-DATE
:modules:my-module-project:buildCSS UP-TO-DATE
:modules:my-module-project:processResources UP-TO-DATE
:modules:my-module-project:transpileJS SKIPPED
:modules:my-module-project:configJSModules SKIPPED
:modules:my-module-project:classes UP-TO-DATE
:modules:my-module-project:jar UP-TO-DATE
:modules:my-module-project:assemble UP-TO-DATE
:modules:my-module-project:build

BUILD SUCCESSFUL

Total time: 2.962 secs
install file:/E:/workspaces/my-liferay-workspace/modules/my-module-project/build/libs/com.liferay.docs.mymodule-1.0.0.jar
Bundle ID: 505
start 505

Scanning E:\workspaces\my-liferay-workspace\modules\my-module-project

...

Waiting for changes to input files of tasks... (ctrl-d then enter to exit)
\end{verbatim}

Output from the \texttt{blade\ deploy\ -w} command indicates that the
module is installed and started, reports the module's OSGi bundle ID,
and stands ready to redeploy the module if its output files change.

Congratulations on a great start to developing your module!

\section{Related Articles}\label{related-articles}

\href{/docs/7-0/tutorials/-/knowledge_base/t/configuring-dependencies}{Configuring
Dependencies}

\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-workspace}{Liferay
Workspace}

\href{/docs/7-0/tutorials/-/knowledge_base/t/tooling}{Tooling}

\href{/docs/7-0/tutorials/-/knowledge_base/t/osgi-basics-for-liferay-development}{OSGi
Basics for Liferay Development}

\href{/docs/7-0/tutorials/-/knowledge_base/t/portlets}{Portlets}

\chapter{Configuring Dependencies}\label{configuring-dependencies}

Using external artifacts in your project requires configuring their
dependencies. To do this, look up the artifact's attributes and plug
them into dependency entries for your build system (either
\href{https://gradle.org/}{Gradle},
\href{https://maven.apache.org/}{Maven}, or
\href{http://ant.apache.org/ivy/}{Ant/Ivy}). Your build system downloads
the dependency artifacts your project needs to compile successfully.

Before specifying an artifact as a dependency, you must first find its
attributes. Artifacts have these attributes:

\begin{itemize}
\tightlist
\item
  \emph{Group ID}: Authoring organization
\item
  \emph{Artifact ID}: Name/identifier
\item
  \emph{Version}: Release number
\end{itemize}

This tutorial shows you how to make sure your projects have the right
dependencies:

\begin{itemize}
\tightlist
\item
  Find Core artifacts
\item
  Find Liferay app and independent artifacts
\item
  Configure dependencies
\end{itemize}

\section{Finding Core Artifacts}\label{finding-core-artifacts}

Each Liferay artifact is a JAR file whose \texttt{META-INF/MANIFEST.MF}
file contains the artifact's OSGi metadata. The manifest also specifies
the artifact's attributes. For example, these two OSGi headers specify
the artifact ID and version:

\begin{verbatim}
Bundle-SymbolicName:  [artifact ID]
Bundle-Version: [version]
\end{verbatim}

\noindent\hrulefill

\textbf{Important:} Artifacts in Liferay DXP fix packs override
Liferay DXP installation artifacts. Subfolders of a fix pack ZIP file's
\texttt{binaries} folder hold the artifacts. If an installed fix pack
provides an artifact you depend on, specify the version of that fix pack
artifact in your dependency.

\noindent\hrulefill

This table lists the group ID, artifact ID, version, and origin for each
core Liferay DXP artifact:

\emph{Core Liferay DXP Artifacts}:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 8\tabcolsep) * \real{0.2364}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 8\tabcolsep) * \real{0.2909}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 8\tabcolsep) * \real{0.1636}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 8\tabcolsep) * \real{0.1818}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 8\tabcolsep) * \real{0.1273}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
File
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Group ID
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Artifact ID
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Version
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Origin
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{portal-kernel.jar} & \texttt{com.liferay.portal} &
\texttt{com.liferay.portal.kernel} & (see JAR's \texttt{MANIFEST.MF}) &
fix pack ZIP, Liferay DXP installation, or Liferay DXP dependencies ZIP \\
\texttt{portal-impl.jar} & \texttt{com.liferay.portal} &
\texttt{com.liferay.portal.impl} & (see JAR's \texttt{MANIFEST.MF}) &
fix pack ZIP or Liferay DXP \texttt{.war} \\
\texttt{portal-test.jar} & \texttt{com.liferay.portal} &
\texttt{com.liferay.portal.test} & (see JAR's \texttt{MANIFEST.MF}) &
fix pack ZIP or Liferay DXP \texttt{.war} \\
\texttt{portal-test-integration.jar} & \texttt{com.liferay.portal} &
\texttt{com.liferay.portal.test.integration} & (see JAR's
\texttt{MANIFEST.MF}) & fix pack ZIP or Liferay DXP \texttt{.war} \\
\texttt{util-bridges.jar} & \texttt{com.liferay.portal} &
\texttt{com.liferay.util.bridges} & (see JAR's \texttt{MANIFEST.MF}) &
fix pack ZIP or Liferay DXP \texttt{.war} \\
\texttt{util-java.jar} & \texttt{com.liferay.portal} &
\texttt{com.liferay.util.java} & (see JAR's \texttt{MANIFEST.MF}) & fix
pack ZIP or Liferay DXP \texttt{.war} \\
\texttt{util-slf4j.jar} & \texttt{com.liferay.portal} &
\texttt{com.liferay.util.slf4j} & (see JAR's \texttt{MANIFEST.MF}) & fix
pack ZIP or Liferay DXP \texttt{.war} \\
\texttt{util-taglibs.jar} & \texttt{com.liferay.portal} &
\texttt{com.liferay.util.taglib} & (see JAR's \texttt{MANIFEST.MF}) &
fix pack ZIP or Liferay DXP \texttt{.war} \\
\texttt{com.liferay.*} JAR files & \texttt{com.liferay} & (see JAR's
\texttt{MANIFEST.MF}) & (see JAR's \texttt{MANIFEST.MF}) & fix pack ZIP,
Liferay DXP installation, Liferay DXP dependencies ZIP, or the OSGi ZIP \\
\end{longtable}

Next, you'll learn how to find artifacts for Liferay DXP apps and
independent modules.

\section{Finding Liferay App and Independent
Artifacts}\label{finding-liferay-app-and-independent-artifacts}

Independent modules and modules that make up Liferay DXP's apps aren't
part of the Liferay DXP core. You must still, however, find their
artifact attributes if you want to declare dependencies on them. The
resources below provide the artifact details for Liferay DXP's apps and
independent modules:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.3750}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.6250}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Resource
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Artifact Type
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\hyperref[app-manager]{App Manager} & Deployed modules \\
\hyperref[reference-docs]{Reference Docs} & Liferay DXP modules (per
release) \\
\hyperref[maven-central]{Maven Central} & All artifact types: Liferay
DXP and third party, module and non-module \\
\end{longtable}

\noindent\hrulefill

\textbf{Important}: \texttt{com.liferay} is the group ID for all Liferay
DXP's apps and independent modules.

\noindent\hrulefill

The App Manager is the best source for information on deployed modules.
You'll learn about it next.

\subsection{App Manager}\label{app-manager}

\href{/docs/7-0/user/-/knowledge_base/u/managing-and-configuring-apps\#using-the-app-manager}{The
App Manager} knows what's deployed on your Liferay DXP server. You can
use it to find whatever modules you're looking for.

Follow these steps to get a deployed module's information:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In Liferay DXP, navigate to \emph{Control Panel} → \emph{Apps} →
  \emph{App Manager}.
\item
  Search for the module by its display name, symbolic name, or related
  keywords. You can also browse for the module in its app. Whether
  browsing or searching, the App Manager shows the module's artifact ID
  and version number.
\end{enumerate}

\begin{figure}
\centering
\includegraphics{./images/intro-configuring-dependencies-search-app-manager-for-module.png}
\caption{You can inspect deployed module artifact IDs and version
numbers.}
\end{figure}

\begin{figure}
\centering
\includegraphics{./images/intro-configuring-dependencies-indep-modules-in-app-manager.png}
\caption{The App Manager aggregates Liferay and independent modules.}
\end{figure}

If you don't know a deployed module's group, use the
\href{/docs/7-0/reference/-/knowledge_base/r/using-the-felix-gogo-shell}{Felix
Gogo Shell} to find it:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open a Gogo Shell session by entering the following into a command
  prompt:

\begin{verbatim}
telnet localhost 11311
\end{verbatim}

  This results in a \texttt{g!}: the Felix Gogo Shell command prompt.
\item
  Search for the module by its display name (e.g.,
  \texttt{Liferay\ Bookmarks\ API}) or a keyword. In the results, note
  the module's number. You can use it in the next step. For example,
  these results show the Liferay Bookmarks API module's number is
  \texttt{52}:

\begin{verbatim}
g! lb | grep "Liferay Bookmarks API"

   52|Active     |   10|Liferay Bookmarks API (2.0.1)
\end{verbatim}
\item
  To list the module's manifest headers, pass the module number to the
  \texttt{headers} command. In the results, note the
  \texttt{Bundle-Vendor} value: you'll match it with an artifact group
  in a later step:

\begin{verbatim}
g! headers 52

Liferay Bookmarks API (52)
--------------------------
Manifest-Version = 1.0
Bnd-LastModified = 1464725366614
Bundle-ManifestVersion = 2
Bundle-Name = Liferay Bookmarks API
Bundle-SymbolicName = com.liferay.bookmarks.api
Bundle-Vendor = Liferay, Inc.
Bundle-Version = 2.0.1
...
\end{verbatim}
\item
  Disconnect from the Gogo Shell session:

\begin{verbatim}
g! disconnect
\end{verbatim}
\item
  On \href{https://search.maven.org/}{Maven Central} or
  \href{https://mvnrepository.com}{MVNRepository}, search for the module
  by its artifact ID.
\item
  Determine the group ID by matching the \texttt{Bundle-Vendor} value
  from step 3 with a group listed that provides the artifact.
\end{enumerate}

Next, you'll learn how to use Liferay DXP's reference documentation to
find a Liferay DXP app module's attributes.

\subsection{Reference Docs}\label{reference-docs}

Liferay DXP's app Javadoc lists each app module's artifact ID, version
number, and display name. This is the best place to look up Liferay DXP
app modules that aren't yet deployed to your Liferay DXP instance.

\noindent\hrulefill

\textbf{Note:} To find artifact information on a Core Liferay DXP
artifact, refer to the previous section
\hyperref[finding-core-artifacts]{Finding Core artifacts}.

\noindent\hrulefill

Follow these steps to find a Liferay DXP app module's attributes in the
Javadoc:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Navigate to Javadoc for an app module class. If you don't have a link
  to the class's Javadoc, find it by browsing
  \href{@app-ref@}{@app-ref@}.
\item
  Copy the class's package name.
\item
  Navigate to the \emph{Overview} page.
\item
  On the \emph{Overview} page, search for the package name you copied in
  step 2.
\end{enumerate}

The heading above the package name shows the module's artifact ID,
version number, and display name. Remember, the group ID for all app
modules is \texttt{com.liferay}.

\begin{figure}
\centering
\includegraphics{./images/intro-configuring-dependencies-module-info-in-javadoc-overview.png}
\caption{Liferay DXP app Javadoc overviews list each app module's
display name, followed by its group ID, artifact ID, and version number
in a colon-separated string. It's a Gradle artifact syntax.}
\end{figure}

\noindent\hrulefill

\textbf{Note}: Module version numbers aren't currently included in any
tag library reference docs.

\noindent\hrulefill

Next, you'll learn how to look up artifacts on MVNRepository and Maven
Central.

\subsection{Maven Central}\label{maven-central}

Most artifacts, regardless of type or origin, are on
\href{https://mvnrepository.com/}{MVNRepository} and
\href{https://search.maven.org/}{Maven Central}. These sites can help
you find artifacts based on class packages. It's common to include an
artifact's ID in the start of an artifact's package names. For example,
if you depend on the class
\texttt{org.osgi.service.component.annotations.Component}, search for
the package name \texttt{org.osgi.service.component.annotations} on one
of the Maven sites.

\noindent\hrulefill

\textbf{Note:} Make sure to follow the instructions listed earlier to
determine the version of Liferay artifacts you need.

\noindent\hrulefill

Now that you have your artifact's attribute values, you're ready to
configure a dependency on it.

\section{Configuring Dependencies}\label{configuring-dependencies-1}

Specifying dependencies to build systems is straightforward. Edit your
project's build file, specifying a dependency entry that includes the
group ID, artifact ID, and version number.

\noindent\hrulefill

\textbf{Note}: To configure third-party libraries in a module, see the
tutorial
\href{/docs/7-0/tutorials/-/knowledge_base/t/adding-third-party-libraries-to-a-module}{Adding
Third Party Libraries to a Module}.

\noindent\hrulefill

Note that different build systems use different artifact attribute
names, as shown below:

\emph{Artifact Terminology}

\begin{longtable}[]{@{}llll@{}}
\toprule\noalign{}
Framework & Group ID & Artifact ID & Version \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Gradle & \texttt{group} & \texttt{name} & \texttt{version} \\
Maven & \texttt{groupId} & \texttt{artifactId} & \texttt{version} \\
Ivy & \texttt{org} & \texttt{name} & \texttt{rev} \\
\end{longtable}

The following examples demonstrate configuring a dependency on Liferay's
Journal API module for Gradle, Maven, and Ivy.

\subsection{Gradle}\label{gradle}

Here's the dependency configured in a \texttt{build.gradle} file:

\begin{verbatim}
dependencies {
    compileOnly group: "com.liferay", name: "com.liferay.journal.api", version: "1.0.1"
    ...
}
\end{verbatim}

\subsection{Maven}\label{maven}

Here's the dependency configured in a \texttt{pom.xml} file:

\begin{verbatim}
<dependency>
    <groupId>com.liferay</groupId>
    <artifactId>com.liferay.journal.api</artifactId>
    <version>1.0.1</version>
</dependency>
\end{verbatim}

\subsection{Ivy}\label{ivy}

Here's the dependency configured in an \texttt{ivy.xml} file:

\begin{verbatim}
<dependency name="com.liferay.journal.api" org="com.liferay" rev="1.0.1" />
\end{verbatim}

\noindent\hrulefill

\textbf{Important:}
\href{/docs/7-0/reference/-/knowledge_base/r/third-party-packages-portal-exports}{Liferay
DXP exports many third-party packages}. If you're developing a WAR,
deploy it to check if the packages you're using are in the OSGi runtime
container already. If they are already in there, specify their
corresponding artifacts as being ``provided''. Here's how to specify a
provided dependency:

Maven:
\texttt{\textless{}scope\textgreater{}provided\textless{}/scope\textgreater{}}

Gradle: \texttt{providedCompile}

Don't deploy a provided package's JAR again or embed the JAR in your
project. Exporting the same package from different JARs leads to ``split
package'' issues, whose side affects differ from case to case. If the
package is in a third-party library (not an OSGi module), refer to
{[}Resolving Third

\noindent\hrulefill Party Library
Dependencies{]}(/docs/7-0/tutorials/-/knowledge\_base/t/adding-third-party-libraries-to-a-module).

\noindent\hrulefill

If you're developing a WAR that requires a different version of a
third-party package that
\href{/docs/7-0/reference/-/knowledge_base/r/third-party-packages-portal-exports}{Liferay
DXP or another module exports}, specify that package in your
\href{/docs/7-0/tutorials/-/knowledge_base/t/importing-packages}{\texttt{Import-Package:}
list}. If the package provider is an OSGi module, publish its exported
packages by deploying that module. Otherwise, follow the instructions
for
\href{/docs/7-0/tutorials/-/knowledge_base/t/adding-third-party-libraries-to-a-module}{adding
a third-party library (not an OSGi module)}.

\noindent\hrulefill

Nice! Now you know how to find artifacts and configure them as
dependencies. Now that's a skill you can depend on!

\section{Related Topics}\label{related-topics-1}

\href{/docs/7-0/tutorials/-/knowledge_base/t/importing-packages}{Importing
Packages}

\href{/docs/7-0/reference/-/knowledge_base/r/development-reference}{Reference}

\href{/docs/7-0/reference/-/knowledge_base/r/finding-liferay-api-modules}{Liferay
API Modules}

\href{/docs/7-0/tutorials/-/knowledge_base/t/adding-third-party-libraries-to-a-module}{Adding
Third Party Libraries to a Module}

\href{/docs/7-0/reference/-/knowledge_base/r/third-party-packages-portal-exports}{Third
Party Packages Portal Exports}

\href{/docs/7-0/reference/-/knowledge_base/r/classes-moved-from-portal-service-jar}{Classes
Moved from portal-service.jar}

\href{/docs/7-0/tutorials/-/knowledge_base/t/tooling}{Tooling}

\href{/docs/7-0/tutorials/-/knowledge_base/t/portlets}{Portlets}

\chapter{Finding Extension Points}\label{finding-extension-points}

Liferay DXP provides many features that help users accomplish their
tasks. Sometimes, however, you may find it necessary to customize a
built-in feature. It's easy to \textbf{find} an area you want to
customize, but it may seem like a daunting task to figure out
\textbf{how} to customize it. Liferay DXP was developed for easy
customization, meaning there are many extension points you can use to
add your own flavor.

There's a process you can follow that makes finding an extension point a
breeze.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Locate the bundle (module) that provides the functionality you want to
  change.
\item
  Find the components available in the module.
\item
  Discover the extension points for the chosen component.
\end{enumerate}

In this tutorial, you'll learn how to find an extension point. You'll
step through a simple example that locates an extension point for
importing LDAP users. This will require the use of Liferay DXP's
\href{/docs/7-0/user/-/knowledge_base/u/managing-and-configuring-apps\#using-the-app-manager}{Application
Manager} and
\href{/docs/7-0/reference/-/knowledge_base/r/using-the-felix-gogo-shell}{Felix
Gogo Shell}.

\section{Locate the Related Module and
Component}\label{locate-the-related-module-and-component}

You must first think of words that describe the application behavior you
want to change. With the right keywords, you can easily track down the
desired module and its component. Consider the example for importing
LDAP users. Some candidate keywords for finding the component are
\emph{import}, \emph{user}, and \emph{LDAP}.

The easiest way to discover the module responsible for a particular
feature in Liferay DXP is to use the Application Manager. The
Application Manager lists app suites and their included
modules/components in an easy-to-use interface. It even lists third
party apps! You'll use your keywords to target the applicable component.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open the App Manager by navigating to \emph{Control Panel} →
  \emph{Apps} → \emph{App Manager}. The top level lists app suites,
  independent apps, and independent modules.
\item
  Navigate the app suites, apps, and modules, or use Search to find
  components that might provide your desired extension point. Remember
  to check for your keywords in element names and descriptions. The
  keyword \emph{LDAP} resides under the Liferay Foundation app suite;
  select it.

  \begin{figure}
  \centering
  \includegraphics{./images/ldap-keyword-app-manager.png}
  \caption{The Liferay Foundation app suite contains the LDAP
  Authentication application.}
  \end{figure}
\item
  Select the \emph{LDAP} application from the app listing.
\item
  The LDAP application only has one module, but typically, applications
  have more than one module to inspect. Select the \emph{Liferay Portal
  Security LDAP} module.

  \begin{figure}
  \centering
  \includegraphics{./images/app-manager-breakdown.png}
  \caption{The App Manager lists the module, package name, version, and
  status.}
  \end{figure}
\item
  Search through the components, applying your keywords as a guide. Copy
  the component name you think best fits the functionality you want to
  customize; you'll inspect it later using the Gogo shell.

  \begin{figure}
  \centering
  \includegraphics{./images/usermodellistener-component.png}
  \caption{The component name can be found using the App Manager.}
  \end{figure}
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** When using the Gogo shell later, understand that it can take
 several tries to find the component for which you're looking; naming
 conventions should allow you to find your desired extension point in a
 manageable time frame.
\end{verbatim}

\noindent\hrulefill

Next, you'll begin using the Gogo shell to inspect the component for
extension points.

\section{Finding Extension Points in a
Component}\label{finding-extension-points-in-a-component}

Once you have the component that relates to the functionality you want
to extend, you can use the Gogo shell's Service Component Runtime (SCR)
commands to inspect it. You can execute SCR commands using
\href{/docs/7-0/tutorials/-/knowledge_base/t/blade-cli}{Liferay Blade
CLI} or in
\href{/docs/7-0/reference/-/knowledge_base/r/using-the-felix-gogo-shell}{Gogo
shell via telnet}. This tutorial assumes you're using the Gogo shell via
telnet.

Execute the following command:

\begin{verbatim}
scr:info [COMPONENT_NAME]
\end{verbatim}

For the LDAP example component you copied previously, the command would
look like this:

\begin{verbatim}
scr:info com.liferay.portal.security.ldap.internal.messaging.UserImportMessageListener
\end{verbatim}

The output includes a lot of information. For this exercise, you're
interested in the services the component references. These are extension
points. For example, here's the reference for the service that imports
LDAP users:

\begin{verbatim}
...
Reference: LdapUserImporter
Interface Name: com.liferay.portal.security.ldap.exportimport.LDAPUserImporter
Cardinality: 1..1
Policy: static
Policy option: reluctant
Reference Scope: bundle
...
\end{verbatim}

The \texttt{LDAPUserImporter} is the extension point needed to customize
the process of importing users with LDAP! If none of the references
satisfy what you're looking for, search other components from the App
Manager.

If you plan on overriding the referenced service, you'll need to
understand the reference's policy and policy option. If the policy is
\texttt{static} and the policy option is \texttt{reluctant}, binding a
new higher ranking service in place of a bound service requires
reactivating the component or changing the target. For information on
the other policies and policy options, visit the
\href{https://osgi.org/download/r6/osgi.enterprise-6.0.0.pdf}{OSGi
specification}, in particular, sections 112.3.5 and 112.3.6. If you want
to learn how to override a component's service reference, visit the
following
\href{/docs/7-0/tutorials/-/knowledge_base/t/overriding-service-references}{tutorial}.

\textbf{Important} Not all Extension points in Liferay DXP are available
as referenced services. Referenced services are common extension points
when using Declarative Services (DS), but there are extension points not
exposed this way. If your project does not use the DS component
framework, you'd need to look for the API that describes its service
consumption from the OSGi registry. Here's a brief list of other
potential extension points in Liferay DXP:

\begin{itemize}
\tightlist
\item
  Instances of
  \texttt{org.osgi.util.tracker.ServiceTracker\textless{}S,\ T\textgreater{}}
\item
  Uses of Liferay's \texttt{Registry.getServiceTracker}
\item
  Uses of Liferay's \texttt{ServiceTrackerMap} or
  \texttt{ServiceTrackerCollection}
\item
  Any other component framework or whiteboard implementation (e.g.,
  HTTP, JAX-RS) that supports tracking services; Blueprint, Apache
  Dependency Manager, etc. could also introduce extension points.
\end{itemize}

There you have it! You successfully formulated keywords that described
the functionality you wanted to customize, used those keywords in the
App Manager to target the applicable module component, and used the Gogo
shell to inspect the component for extension points.

\chapter{From Liferay Portal 6 to 7}\label{from-liferay-portal-6-to-7}

Becoming familiar with a platform as large and fully featured as Liferay
is a big task. You learn the ins and outs of what it can do, the tips
and best practices of the experts, and you work your way through the
APIs. As you do this, you become more and more familiar with how things
work, become more proficient with the platform as you multiply successes
on it, and start to think in terms of how you'd solve problems most
effectively using the tools the platform gives you. Eventually, if you
use it long enough, it can seem like an old friend that's ready to stand
by you and help you succeed in your projects.

7.0 was designed as an enhancement that builds off of what you already
know. Its Upgrade Planner and this tutorial series--or Learning
Path--help get your existing plugins running on 7.0 right away. The tool
automates much of the process. After you upgrade your plugins, you can
build and deploy them as you always have.

7.0 has exciting improvements for developers too. This Learning Path
shows you how to leverage them. Since you already know previous versions
of Liferay Portal, you're several steps ahead of everybody else.

This Learning Path describes the benefits of 7.0 for developers compared
to previous versions, the architectural improvements, the benefits that
modularity brings, and how to develop modules and how they differ from
traditional plugins. You'll see all the options for leveraging new
developer features, learn the pros and cons of each, and examine steps
for optimizing your existing plugins for 7.0.

In the end, we believe you'll both want to adopt 7.0, and you'll see how
you can thrive using it.

\noindent\hrulefill

\textbf{Note}: If you want to learn about 7.0's architectural
improvements, OSGi and modularity, and tooling improvements, read on. If
you're more interested in upgrading your plugins first, skip to
\href{/docs/7-0/tutorials/-/knowledge_base/t/migrating-existing-code-to-liferay-7}{Planning
Plugin Upgrades and Optimizations}.

\noindent\hrulefill

You'll start by seeing the familiar, good things that remain the same
and then examine what's changed the most since Liferay Portal 6.

\chapter{What Hasn't Changed and What
Has}\label{what-hasnt-changed-and-what-has}

7.0 is a new major version of the Liferay platform and as such it
includes many improvements over previous versions. Having said that,
most of the characteristics from Liferay Portal 6 that you have learned
to love are preserved, having been changed only slightly or not at all.
Any experienced Liferay developer will be able to reuse most of his/her
existing knowledge to developing for 7.0.

What has not changed? Even though there are many improvements in 7.0,
there are also many great familiar aspects from previous versions that
have been preserved. Here are some of the most relevant ones:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  The Portal Core and each Liferay app continue to use the three layer
  architecture: presentation, services, and persistence. The
  presentation layer is now always provided as an independent module,
  facilitating replacing it with a different presentation, if desired.
\item
  Support remains for previously supported standards such as Portlets
  (JSR-168, JSR-286), CMIS, WebDAV, LDAP, JCP (JSR-170), etc.
\item
  Most Liferay APIs have remained functionally similar to those of 6.2,
  even if many of their classes have moved to new packages, as part of
  the modularization effort.
\item
  Liferay @ide@ is still the preferred tool to develop for Liferay, even
  though you are still free to use tools that best fit your needs.
\item
  Service Builder and other developer tools and libraries continue to
  work as they have in 6.2.
\item
  Traditional plugins for portlets and hooks still work (once they're
  adapted to 7.0's API) through a compatibility layer.
\item
  The Plugins SDK can also still be used and transition to the new
  Liferay Workspace, if desired, is easy.
\end{enumerate}

Here are some key changes of interest to existing Liferay developers:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Extraction of many features as modules: So far you have been used to
  working with Liferay as a large web application, of which all of it
  had to be deployed or none of it. In 7.0, many out of the box
  portlets, features, and associated APIs have been extracted as OSGi
  modules. You can choose which ones to deploy and use.
\item
  Adoption of modern OSGi standards: OSGi is a set of standards for
  building modular systems. It's very powerful. Although it was
  previously difficult to learn and use, its modernized standards, such
  as Declarative Services, have made learning and using it much easier.
\item
  Core Public APIs are provided through portal-kernel (previously known
  as portal-service); all other public APIs are provided by their own
  modules.
\item
  You can reuse modules and libraries, and manage the dependencies among
  them.
\item
  Registration of classes implementing extension points is now simpler
  and more consistent; it's based on the standard \texttt{@Component}
  annotation instead of declarations in \texttt{portal.properties} or
  \texttt{portlet.xml}. Note, previous registration mechanisms have been
  preserved where possible. See the
  \href{/docs/7-0/reference/-/knowledge_base/r/breaking-changes}{Breaking
  Changes} article to examine where extensions and configurations that
  have not kept backwards compatibility.
\item
  Third party extensions and applications are now first-class citizens.
  Traditional plugins had some limitations that developments done in the
  core (or done as Ext Plugins) did not have. Modules don't have these
  limitations and are much more powerful than plugins ever were.
\item
  Complete integration of Liferay specific tools (such as Service
  Builder) within Maven and Gradle. Additionally we've adopted some new
  tools such as Bnd.
\end{enumerate}

Since the modularization of the Liferay web application is the change
most relevant to you as a developer, let's dig deeper into that change
and how it affects Liferay's architecture.

\section{Embracing a Modular
Architecture}\label{embracing-a-modular-architecture}

The largest improvement in Liferay's architecture is the adoption of a
modular development paradigm. Within each Liferay module (or group of
modules that form an app), as well as within what remains as Liferay's
core, the existing great characteristics of previous versions of Liferay
prevail.

\subsection{Tiered Architecture}\label{tiered-architecture}

Liferay Portal 6's architecture diagrams often focused on the tiers for
the frontend, services layer (for the business logic), and persistence
layer (mostly auto-generated by Service Builder). These layers still
exist and have been embraced throughout the modularization effort.

\begin{figure}
\centering
\includegraphics{./images/from-liferay-6-liferay-6-architecture.png}
\caption{Liferay Portal 6's architecture, shown in this figure, is still
generally valid in 7.0.}
\end{figure}

The most significant change (and improvement) over this architecture is
that the portal is no longer a single large Java EE Web Application.
Liferay has been broken down into many modules to benefit from the
Modular Development Paradigm. Those benefits are described in the next
section. The modules are often grouped into apps (such as Wiki or
Message Boards) and the main apps are grouped into suites (such as Web
Experience, Collaboration, and Forms \& Workflow).

\subsection{Modular Architecture}\label{modular-architecture}

The figure below represents 7.0's architecture from a structural
perspective.

\begin{figure}
\centering
\includegraphics{./images/from-liferay-6-core-suites-and-apps.png}
\caption{7.0 is composed of the Liferay Core, independent application
modules, and App Suites, each with their own set of application and
framework modules.}
\end{figure}

\subsubsection{Liferay Core}\label{liferay-core}

As its name implies, it's 7.0's central and most important part. The
Liferay Core is a Java EE application in charge of bootstrapping the
system and receiving and delegating all requests. It also contains
Liferay's OSGi Engine on top of which all applications run.

\subsubsection{Foundation}\label{foundation}

The Foundation suite sits on top of the core, providing administrative
interfaces and familiar development building blocks. It includes modules
for user and role administration, LDAP integration, authentication,
licensing, upgrades, clustering, DAO, and front-end mainstays for
themes, CSS, taglibs, and JavaScript. The Foundation suite's modules
depend on Liferay Core, as do all the App Suites and non-core modules.

Most of the apps, frameworks, and APIs you've come to know and love have
been aggregated in App Suites. The suites are available in Liferay
bundles and are also available on the Marketplace. Here are the
different App Suites:

\subsubsection{Liferay Web Experience}\label{liferay-web-experience}

Contains apps such as Web Content and Site management, Web Content
Display, Asset Publisher, and Breadcrumbs and features and frameworks
such as Application Display Templates, Tags, and Recycle Bin.

\subsubsection{Liferay Collaboration}\label{liferay-collaboration}

Comprises Liferay's social apps and collaboration apps, such as Message
Boards, Wiki, and Blogs. It also contains Liferay's Documents \& Media
Library.

\subsubsection{Liferay Forms and
Workflow}\label{liferay-forms-and-workflow}

Provides apps such as Forms (New!), Dynamic Data Lists, Kaleo Workflow,
and Calendar. It also contains the Dynamic Data Mapping framework used
by Web Content and Documents \& Media to provide custom form and
templating capabilities.

\subsubsection{Independent Apps}\label{independent-apps}

Last but not least, Liferay's independent apps and modules also play a
part. They provide unique functionality and stand on their own; it would
be unnatural to add any one of them to a particular suite. Apps such as
Liferay Sync, the Marketplace Client, Knowledge Base, and many more apps
available on the Marketplace are independent Liferay apps.

The beauty of the 7.0 ecosystem is that it is made up of simple
easy-to-use modules that depend on and communicate with each other. And
you as a third-party developer can create and deploy your own modules
into the mix.

You can continue developing traditional WAR-style apps for 7.0 too.
Liferay DXP's Portlet Compatibility Layer converts each plugin WAR to a
Web Application Bundle (WAB), which is a module.

Let's consider the structure of a 7.0 modular app.

\subsection{The Structure of a Modular
App}\label{the-structure-of-a-modular-app}

As mentioned, each app can be formed by one or more modules. This
section explains the most common way to structure an app.

The best practice for structuring an app is in several modules. In
particular the following modules are the often the best way of
structuring an app:

\begin{itemize}
\item
  \textbf{Service}: Contains the service (business logic) and
  persistence implementations.
\item
  \textbf{API}: Contains the public API of the application. By being
  separate from the service it's simpler and faster to deploy new
  versions of the implementation without affecting any module using the
  API. It also allows changing the versioning of the implementation
  independent from the versioning of the API.
\item
  \textbf{Web}: Contains the presentation tier, very often the portlets
  provided by this app.
\item
  \textbf{Test}: Contains the tests. These are not included in the app
  for production.
\item
  \textbf{Specific purpose modules}: Other modules are also often
  created for specific purposes or to provide alternative
  implementations of some of the app's features. For example the Wiki
  app has one module for each of the supported Wiki Engines.
\end{itemize}

All the modules in an app usually sit in directories next to each other
in the source to facilitate referencing them.

For deployment to production Liferay provides the LPKG packaging format
that allows bundling a set of modules into a single file and add
additional metadata about it. This format can also be used to upload
apps to \href{http://marketplace.liferay.com}{Liferay's Marketplace}.

Now you have a basic understanding of the architectural changes
introduced in 7.0 and have become acquainted with the new structure used
in Liferay's apps. You have learned some key concepts that are new for
Liferay Portal 6 developers and have been assured about developer
features you've used in previous Liferay releases that have been carried
into 7.0.

Next, you'll explore how these new concepts and the new modular
architecture benefit you as a developer.

\chapter{Benefits of 7.0 for Liferay Portal 6
Developers}\label{benefits-of-7.0-for-liferay-portal-6-developers}

More than in any other Liferay release, 7.0 centers on you, the
developer. Liferay's platform has been rebuilt, making it easier to
build on and maintain, and providing more new developer features than
any previous Liferay release.

Here are some key benefits of this release for developers:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{Simpler and Leaner}
\item
  \textbf{Modular Development Paradigm}
\item
  \textbf{Enhanced Reusability}
\item
  \textbf{More extensible, easier to maintain}
\item
  \textbf{Optimized for your tooling of choice}
\item
  \textbf{Powerful Configurability}
\end{enumerate}

Let's consider how they make development easier for you.

\section{Simpler and Leaner}\label{simpler-and-leaner}

Liferay has always been simple and lean, compared to the proprietary
alternatives; this version widens the gap even more.

7.0 is simpler than its predecessors, thanks to a streamlined and
modular architecture. In addition, many Liferay specific ways of
creating extensions and applications have evolved to follow official or
de-facto standards. As a result, developers can now more easily reuse
their existing knowledge and use what they learn developing for Liferay
outside of it.

7.0 is also leaner. Its modularized core allows developers and system
administrators to remove parts they don't need or don't want; this
facilitates deployment, reduces startup times and memory footprints, and
results in more efficiencies and performance improvements.

\section{Modular Development
Paradigm}\label{modular-development-paradigm}

If you have been using Liferay, you've already experienced some of the
benefits of modular development, thanks to plugins. 7.0 takes these
benefits to a whole new level.

In addition to building plugins as you have previously, you can take
advantage of a complete module development and runtime system based on
OSGi standards. 7.0 facilitates creating applications of all types by
composing and reusing modules.

And don't worry, modules are easy to understand. A module is distributed
as a JAR file and can be as small as one Java class or as large as any
application you can think of. An application for Liferay can comprise
one single module or as many modules as you want. The cool thing is that
modules can cooperate, allowing you to build applications by combining
smaller pieces that are easier to develop, deploy, maintain, and reuse.

\section{Enhanced Reusability}\label{enhanced-reusability}

If you have worked on large developments on top of Liferay you have
probably experienced situations in which you wanted to share a subset of
classes from from one plugin with another.

Java EE does not provide any standard way to achieve this, but Liferay
provided certain capabilities to achieve it with a mechanism known as
CLP that used class loader \emph{magic} to allow plugins to invoke
services in other plugins created with Service Builder. This mechanism,
however, is still a bit limited (Java EE's class loader doesn't allow
for much more) and doesn't give you the freedom to specify any or all
classes from one module to use from within another module.

7.0 enables greater reusability, both in code and runtime memory,
several folds. For any desired reusable functionality you just
\href{/docs/7-0/tutorials/-/knowledge_base/t/starting-module-development\#creating-a-module}{create
a module} (remember, it's just a JAR file with some metadata) with the
classes you want and deploy it. Other modules need only declare that
they use the classes in that module (by specifying their packages) and
7.0 automatically wires them together. All invocations are regular Java
calls! Try it out; it's beautiful. :)

This mechanism eliminates the dreaded ``JAR/classpath hell'' issue. No
longer do you have to jockey JAR files in classpaths; nor do you have to
implement intricate class loaders. The runtime environment uses separate
class spaces per module; it even accommodates using multiple versions of
libraries in the same application (as long as they can coexist).

\section{More Extensible, Easier to
Maintain}\label{more-extensible-easier-to-maintain}

Whenever we ask Liferay developers what is their favorite characteristic
of Liferay, ``Great extensibility'' is one of the top three most popular
responses. You can customize almost every detail and add your own
functionality on top.

Is 7.0 more extensible? You bet! Many more extension points have been
added. But not only that, all new extension points and many existing
ones which have been upgraded, use a new extension mechanism based on
OSGi's service model. Here are some of the mechanism's benefits:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{Simpler}: An implementation of an extension point is now
  always a Java class that implements an interface and has one
  annotation (@Component). That's it; it couldn't be any easier.
\item
  \textbf{Easier to maintain}: Extension points are now more strictly
  defined through a Java interface that uses Semantic Versioning rules.
  This means that your extensions can work without changes, even across
  several Liferay versions, as long as the specific extension API is
  backwards compatible.
\item
  \textbf{Dynamic}: Extensions can be loaded and removed at any time
  during development or in production.
\end{enumerate}

But that is not all. Your own developments can now also leverage this
model and become extensible. You can create simple extension points by
just creating an interface and annotating a setter method with an
annotation (@Reference). Implementing extensibility has never been
easier.

\section{Optimized for Your Tooling of
Choice}\label{optimized-for-your-tooling-of-choice}

7.0 empowers you to use the tools you like.

If you don't have strong preferences and are open to our suggestions, we
offer Liferay Workspace. It provides an opinionated directory structure
and build system based on Gradle and Bnd. Liferay Workspace can be used
standalone through the command line or with Liferay @ide@, which runs on
Eclipse.

And if you want to continue using the Plugins SDK, we've got you
covered. The Plugins SDK is available to facilitate your transition to
7.0. In fact, a Plugins SDK structure can reside in a Liferay Workspace
alongside new developments that use the new build environment; you can
switch between traditional projects and new projects at your own pace.

Finally, we have also developed a lightweight tool called Blade CLI,
which facilitates starting new projects from templates -- it's
especially useful for Gradle which doesn't have Maven's concept of
archetypes. Blade CLI also offers commands to start/stop the server and
deploy and administer modules.

\section{Powerful Configurability}\label{powerful-configurability}

Creating configurable code is a breeze with 7.0. And applications that
use Liferay's new Configuration API allow administrators to change the
configuration on the fly, through an auto-generated user interface
called System Settings.

Now you understand how 7.0 enriches your experience as a developer and
makes developing apps and customizations fun.

Next, we'll take a look at OSGi and modularity to discuss key concepts
and demonstrate how easy and gratifying it is to build modules.

\chapter{OSGi and Modularity for Liferay Portal 6
Developers}\label{osgi-and-modularity-for-liferay-portal-6-developers}

To create a powerful, reliable platform for developing modular
applications, Liferay sought best-of-breed standards-based frameworks
and technologies. It was imperative not only to meet demands for
enterprise digital experiences but also to offer developers, both
experienced with Liferay and new to Liferay, a clear and elegant way to
create apps.

Here were some of the key goals:

\begin{itemize}
\item
  Allow breaking down a large system into smaller pieces of code, whose
  boundaries and relationships could be clearly defined.
\item
  Explicitly differentiate public APIs from private APIs.
\item
  Facilitate extensibility of existing code.
\item
  Modernize the development environment, leveraging more
  state-of-the-art tools to provide a great developer experience.
\end{itemize}

It wasn't long before Liferay discovered that OSGi and its supporting
tools/technologies fit the bill!

In this tutorial, you'll learn how 7.0 uses OSGi to meet these
objectives. And equally important, you'll find out how easy and fun
modular development can be.

Here are the topics you'll dig into:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/osgi-and-modularity-for-liferay-6-developers\#modules-as-an-improvement-over-traditional-plugins}{Modules
  as an Improvement over Traditional Plugins}: Development and
  customization of applications for Liferay has been done traditionally
  in WAR-style plugins (Portlet, Hook, Ext, and Web). In 7.0,
  traditional Liferay plugins can be replaced with (or can be
  automatically converted to) modules. You'll see the similarities and
  differences of plugins and modules, and you'll learn the benefits of
  using modules.
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/osgi-and-modularity-for-liferay-6-developers\#leveraging-dependencies}{Leveraging
  Dependencies}: In 7.0, you can both declare dependencies among modules
  and combine modules to create applications. Since leveraging
  dependencies provides huge benefits, it's important to devote a large
  section for it.
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/osgi-and-modularity-for-liferay-6-developers\#osgi-services-and-dependency-injection-with-declarative-services}{OSGi
  Services and Dependency Injection}: OSGi provides a powerful concept
  called OSGi Services (also known as microservices). OSGi's Declarative
  Services standard provides a clean way to inject dependencies in a
  dynamic environment. This is similar to Spring DI, except the changes
  happen while the system is running. It also offers an elegant
  extensibility model that 7.0 leverages extensively.
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/osgi-and-modularity-for-liferay-6-developers\#dynamic-deployment}{Dynamic
  Deployment}: Module deployment is managed by 7.0 (not the application
  server). This section demonstrates how to use dynamic deployment for
  better control and efficiency.
\end{enumerate}

After investigating these topics, you'll get hands-on experience
creating and deploying an OSGi module.

Let's start with learning how modules are better than traditional
plugins.

\section{Modules as an Improvement over Traditional
Plugins}\label{modules-as-an-improvement-over-traditional-plugins}

In 7.0, you can develop applications using OSGi modules or using
traditional Liferay plugins (WAR-style portlets, hooks, EXT, and web
applications). Liferay's Plugin Compatibility Layer (explained later)
makes it possible to deploy traditional plugins to the OSGi runtime
framework. To benefit from all 7.0 and OSGi offer, however, you should
use OSGi modules.

Modules offer these benefits:

\begin{itemize}
\item
  \textbf{Better Encapsulation} - The only classes a module exposes
  publicly are those it exports explicitly. This lets you define
  internal public classes transparent to external clients.
\item
  \textbf{Dependencies by Package} - Dependencies are specified by Java
  package, not by JAR file. In traditional plugins, you had to add
  \emph{all} of a JAR file's classes to the classpath to use \emph{any}
  of its classes. With OSGi, you need only import packages containing
  the classes you need. Only the classes in those packages are added to
  the module's classpath.
\item
  \textbf{Lightweight} - A module can be as small as you want it to be.
  In contrast to a traditional plugin, which may require several
  descriptor files, a module requires only a single descriptor file--a
  standard JAR manifest. Also, traditional plugins are typically larger
  than modules and deployed on app server startup, which can slow down
  that process considerably. Modules deploy more quickly and require
  minimal overhead cost.
\item
  \textbf{Easy Reuse} - Modules lend themselves well to developing
  small, highly cohesive chunks of code. They can be combined to create
  applications that are easier to test and maintain. Modules can be
  distributed publicly (e.g., on Maven Central) or privately. And since
  modules are versioned, you can specify precisely the modules you want
  to use.
\item
  \textbf{In-Context Descriptors} - Where plugins use descriptor files
  (e.g., \texttt{web.xml}, \texttt{portlet.xml}, etc.) to describe
  classes, module classes use OSGi annotations to describe themselves.
  For example, a module portlet class can use
  \href{/docs/7-0/reference/-/knowledge_base/r/portlet-descriptor-to-osgi-service-property-map}{OSGi
  Service annotation properties} to specify its name, display name,
  resource bundle, public render parameters, and much more. Instead of
  specifying that information in descriptor files separate from the
  code, you specify them in context in the code.
\end{itemize}

These are just a few ways modules outshine traditional plugins. Note,
however, that developers experienced with Liferay plugins have the best
of both worlds. 7.0 supports traditional plugins \emph{and} modules.
Existing Liferay developers can find comfort in the simplicity of
modules and their similarities with plugins.

Here are some fundamental characteristics modules share with plugins:

\begin{itemize}
\item
  Developers use them to create applications (portlets for Liferay)
\item
  They're zipped up packages of classes and resources
\item
  They're packaged as a standard Java JARs
\end{itemize}

Now that you've compared and contrasted modules with plugins, it's time
to tour the module anatomy.

\subsection{Module Structure: A JAR File with a
Manifest}\label{module-structure-a-jar-file-with-a-manifest}

A module's structure is extremely simple. It has one mandatory file:
\texttt{META-INF/MANIFEST.MF}. You add code and resources to the module
and organize them as desired.

Here's the essential structure of a module JAR file:

\noindent\hrulefill

\begin{verbatim}
- [Module's files]
_ META-INF
    _ MANIFEST.MF
\end{verbatim}

\noindent\hrulefill

The \texttt{MANIFEST.MF} file describes the module to the system. The
manifest's \href{https://www.osgi.org/bundle-headers-reference/}{OSGi
headers} identify the module and its relationship to other modules.

Here are some of the most commonly used headers:

\begin{itemize}
\item
  \texttt{Bundle-Name}: User friendly name of the module.
\item
  \texttt{Bundle-SymbolicName}: Globally unique identifier for the
  module. Java package conventions (e.g.,
  \texttt{com.liferay.journal.api}) are commonly used.
\item
  \texttt{Bundle-Version}: Version of the module.
\item
  \texttt{Export-Package}: Packages from this module to make accessible
  to other modules.
\item
  \texttt{Import-Package}: Packages this module requires that other
  modules provide.
\end{itemize}

Other headers can be used to specify more characteristics, such as how
the module was built, development tools used, etc.

For example, here are some headers from the Liferay Journal Web module
manifest:

\begin{verbatim}
Manifest-Version: 1.0
Bundle-ManifestVersion: 2
Bundle-Name: Liferay Journal Web
Bundle-SymbolicName: com.liferay.journal.web
Bundle-Vendor: Liferay, Inc.
Bundle-Version: 1.1.2
Export-Package:\
    com.liferay.journal.web.asset,\
    com.liferay.dynamic.data.mapping.util,\
    com.liferay.journal.model,
    com.liferay.journal.service,com.liferay.journal.util, [..]
Import-Package:\
    aQute.bnd.annotation.metatype,\
    com.liferay.announcements.kernel.model,
    com.liferay.application.list,\
    com.liferay.asset.kernel,\
    com.liferay.asset.kernel.exception, [..]
\end{verbatim}

Note: to remove unnecessary ``noise'' from this example, some headers
have been abbreviated (\texttt{{[}..{]}}) and some have been removed.

You can organize and build a module's Java code and resources however
you like. You're free to use any directory structure conventions, such
as those used in Maven or by your development team. And you can use any
build tool, such as Gradle or Maven, to
\href{/docs/7-0/tutorials/-/knowledge_base/t/configuring-dependencies}{manage
dependencies}.

\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-workspace}{Liferay
Workspace} is an environment for managing module projects (and theme
projects). A default Workspace provides Gradle build scripts and a
Workspace created from the Liferay Project Templates Workspace archetype
provides Maven build scripts for developing on Liferay. Workspace can be
used from the command line or from within
\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-ide}{Liferay
@ide@}. Note also that Liferay @ide@ provides plugins for Gradle, Maven,
and BndTools. Tooling details are covered later in this series.

Now that you're familiar with the module structure and manifest, it's
time to explore how to build modules.

\subsection{Building Modules with Bnd}\label{building-modules-with-bnd}

The most common way to build modules is with a little tool called
\href{http://bnd.bndtools.org/}{Bnd}. It's an engine that, among other
things, simplifies generating manifest metadata. Instead of manually
creating a \texttt{MANIFEST.MF} file, developers use Bnd to generate it.
Bnd can be used on its own or along with other build tools, such as
Gradle or Maven. Liferay Workspace uses Bnd together with Gradle or
Maven.

One of Bnd's best features is that it automatically transverses a
module's code to identify external classes the module uses and adds them
to the manifest's list of packages to import. Bnd also provides several
OSGi-specific operations that simplify module development.

Bnd generates the manifest based on a file called \texttt{bnd.bnd} in
the project root. This file's header list is similar to (but shorter
than) that of the \texttt{MANIFEST.MF}. Compare the Liferay Journal Web
module's \texttt{bnd.bnd} file content (simplified a bit) below to its
\texttt{MANIFEST.MF} file content that was listed earlier:

\begin{verbatim}
Bundle-Name: Liferay Journal Web
Bundle-SymbolicName: com.liferay.journal.web
Bundle-Version: 1.1.2
Export-Package:\
    com.liferay.journal.web.asset,\
    com.liferay.journal.web.dynamic.data.mapping.util,\
    com.liferay.journal.web.social,\
    com.liferay.journal.web.util
\end{verbatim}

The main difference is that the \texttt{bnd.bnd} file doesn't specify an
\texttt{Import-Package} header. It's unnecessary because Bnd generates
it in the \texttt{MANIFEST.MF} file automatically. It's metadata made
easy!

Bnd plugins are available to use with Gradle and Maven. And since
Liferay Workspace includes Bnd, developers can use Bnd from the command
line and from Liferay @ide@.

Now that you're familiar with Bnd and the \texttt{Export-Package} and
\texttt{Import-Package} manifest headers, let's explore how to use them
to leverage dependencies.

\section{Leveraging Dependencies}\label{leveraging-dependencies}

Using an OSGi manifest, a module declares the Java packages it consumes
and shares. The manifest's \texttt{Import-Package} and
\texttt{Export-Package} settings expose this information. As you
determine whether to use a particular module, you know up-front what it
offers and what it depends on. As an improvement over Java EE, OSGi
takes away dependency guesswork.

This part of the tutorial explains:

\begin{itemize}
\item
  \textbf{\hyperref[how-dependencies-work]{How dependencies work}}
\item
  \textbf{\hyperref[dependencies-facilitate-modular-development]{How to
  develop modular apps using dependencies}}
\end{itemize}

Let's start by learning how dependencies operate in 7.0.

\subsection{How Dependencies Work}\label{how-dependencies-work}

Since all of 7.0 leverages dependencies, it also demonstrates how to use
them. As mentioned previously, all of what was in Liferay Portal 6 and
its apps has been refactored into OSGi modules. The
\texttt{portal-service} API (the main API in Liferay Portal 6) has been
replaced by the \texttt{portal-kernel} module (7.0's kernel API) and
many small, highly-cohesive modules that provide frameworks, utilities,
apps, and more.

Not only do Liferay DXP modules depend on third-party modules but they
also depend on each other. You can likewise leverage dependencies in
your projects. Whether you're developing new OSGi modules or continuing
to develop traditional apps, you need only set dependencies on modules
whose packages you need.

Each module's manifest lists the packages the module depends on. Using a
build environment such as Gradle, Maven, or Ant/Ivy, you can set
dependencies on each package's module. At build time, the dependency
framework verifies the entire dependency chain, downloading all newly
specified modules. The same thing happens at runtime: the OSGi runtime
knows exactly which modules depend on which other modules (failing fast
if any dependency is unmet). Dependency management is explicit and
enforced automatically upfront.

Versioning is independent for each Liferay module and its exported
packages. You can use a specific package version by depending on the
version of the module that exports it. And you're free to use a mix of
Liferay modules in the versions you want (but remember, ``With great
power comes great responsibility,'' so unless you really know what
you're doing, use the same version of each module you depend on).

For all its modules, Liferay DXP uses \href{http://semver.org}{Semantic
Versioning}. It's a standard that enables API authors to communicate
programmatic compatibility of a package or module automatically as it
relates to dependent consumers and API implementations. If a package is
programmatically (i.e., semantically) incompatible with a project, Bnd
(used in Liferay Workspace) fails that project's build immediately.
Developers not using Bnd can check package versions manually in each
dependency module's manifest.

Semantic Versioning also gives module developers flexibility to specify
a version range of packages and modules to depend on. In other words, if
several versions of a package work for an app, the developer can
configure the app to use any of them. What's more, Bnd automatically
determines the semantically compatible range of each package a module
depends on and records the range to the module's manifest.

On testing your project, you might find a new version of a dependency
package has bugs or behaves differently than you'd like. No problem. You
can adjust the package version range to include versions up to, but not
including, the one you don't want.

Next you want to consider when to modularize existing apps and when to
combine modules to create apps.

\subsection{Dependencies Facilitate Modular
Development}\label{dependencies-facilitate-modular-development}

7.0's support of dependencies and semantic versioning facilitates
modular development. The dependency frameworks enable you to use modules
and link them together. You can use these modules throughout your
organization and distribute them to others. 7.0's integration with
dependency management frees you to modularize existing apps and develop
apps that combine modules. It's a powerful and fun way to develop apps
on Liferay DXP.

Here are some general steps to consider when modularizing an existing
app:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{Start by putting the entire app in a single module}: This is a
  minimal first step that acquaints you with 7.0's module framework.
  You'll gain confidence as you build, deploy, and test your app in an
  environment of your choice, such as a Liferay Workspace, Gradle, or
  Maven project.
\item
  \textbf{Split the front-end from the back-end}: Modularizing front-end
  portlets and servlets and back-end implementations (e.g., Service
  Builder or OSGi component) is a logical next step. This enables each
  code area to evolve separately and allows for varying implementations.
\item
  \textbf{Extract non-essential features to modules}: You may have
  functionality or API extensions that need not be tied to an app's core
  codebase. They can be refactored as independent modules that implement
  APIs you provide. Examples might be connectors to third-party systems
  or support for various data export/import formats.
\end{enumerate}

The principles listed above also apply to developing new modular-based
apps. As you design an app, consider possible implementation variations
with respect to its features, front-end, and back-end. Encapsulate the
variations using APIs. Then develop the APIs and implementations as
separate modules. You can wire them together using dependencies.

\textbf{Liferay's Blogs application} exemplifies modularization in the
manner we've described:

\textbf{API}:

\begin{itemize}
\tightlist
\item
  \texttt{blogs-api} - Encapsulates the core implementation
\end{itemize}

\textbf{Back-end}:

\begin{itemize}
\tightlist
\item
  \texttt{blogs-service} - Implements \texttt{blogs-api}
\end{itemize}

\textbf{Front-end}:

\begin{itemize}
\tightlist
\item
  \texttt{blogs-web} - Provides the app's UI
\end{itemize}

\textbf{Non-essential features and extensions}:

\begin{itemize}
\item
  \texttt{blogs-editor-configuration} - Extends the
  \texttt{portal-kernel} module for extending editors
\item
  \texttt{blogs-recent-bloggers-web} - Provides the Recent Bloggers app
\item
  \texttt{blogs-item-selector-api} - Encapsulates the item-selector
  implementation
\item
  \texttt{blogs-item-selector-web} - Renders the Blogs app's
  item-selector
\item
  \texttt{blogs-layout-prototype} - Creates a Page Template showcasing
  blog entries
\end{itemize}

The Blogs app, like many modular apps, separates concerns into modules.
In this way, front-end developers concentrate on front-end code,
back-end developers concentrate on that code, and so on. These logical
boundaries free developers to design, implement, and test the modules
independently.

As you develop app-centered modules, you can consider bundling them with
your app (e.g., as part of a Liferay Marketplace app). Including them as
part of the app is convenient for the consumer. By bundling a module
with an app, however, you're committing to the app's release schedule.
In other words, you can't directly deploy a new version of a module for
the app--you must release it as part of the app's next release.

So far, you've learned how dependencies and Semantic Versioning work.
You've considered guidelines for modularizing existing apps and creating
new modular apps. Now, to add to the momentum around OSGi and
modularity, you'll explore OSGi Services and dependency injection using
OSGi Declarative Services.

\section{OSGi Services and Dependency Injection with Declarative
Services}\label{osgi-services-and-dependency-injection-with-declarative-services}

In 7.0, the OSGi framework registers objects as \emph{services}. Each
service offers functionality and can leverage functionality other
services provide. The OSGi Services model supports a collaborative
environment for objects.

Declarative Services (DS) provides a service component model on top of
OSGi Services. DS service components are marked with the
\texttt{@Component} annotation and implement or extend a service class.
Service component can refer to and use each other's services. The
Service Component Runtime (SCR) registers component services and handles
binding them to other components that reference them.

Here's how the ``magic'' happens:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{Service registration:} On installing a module that contains a
  service component, the SCR creates a component configuration that
  associates the component with its specified service type and stores it
  in a service registry.
\item
  \textbf{Service reference handling:} On installing a module whose
  service component references another service type, the SCR searches
  the registry for a component configuration that matches the service
  type and on finding a match binds an instance of that service to the
  referring component.
\end{enumerate}

It's publish, find, and bind at its best!

How does a developer use DS to register and bind services? Does it
involve creating XML files? No, it's much easier than that. The
developer uses two annotations: \texttt{@Component} and
\texttt{@Reference}.

\begin{itemize}
\item
  \texttt{@Component}: Add this annotation to a class definition to make
  the class a component--a service provider.
\item
  \texttt{@Reference}: Add this annotation to a field to inject it with
  a service that matches the field's type.
\end{itemize}

The \texttt{@Component} annotation makes the class an OSGi component.
Setting a \texttt{service} property to a particular service type in the
annotation, allows other components to reference the service component
by the specified service type.

For example, the following class is a service component of type
\texttt{SomeApi.class}.

\begin{verbatim}
@Component(
    service = SomeApi.class
)
public class Service1 implements SomeApi {

   ...
}
\end{verbatim}

On deploying this class's module, the SCR creates a component
configuration that associates the class with the service type
\texttt{SomeApi}.

Specifying a service reference is easy too. Applying the
\texttt{@Reference} annotation to a field marks it to be injected with a
service matching the field's type.

\begin{verbatim}
@Reference
SomeApi _someApi;
\end{verbatim}

On deploying this class's module, the SCR finds a component
configuration of the class type \texttt{SomeApi} and binds the service
to this referencing component class.

At build time, Bnd creates a \emph{component description} file for each
module's components automatically. The file specifies the component's
services, dependencies, and activation characteristics. On module
deployment, the OSGi framework reads the component description to create
the component and manage its dependency on other components.

The SCR stands ready to pair service components with each other. For
each referencing component, the SCR binds an instance of the targeted
service to it.

As an improvement over dependency injection with Spring, OSGi
Declarative Services supports dynamic dependency injection. Developers
can create and publish service components for other classes to use.
Developers can update the components and even publish alternative
component implementations for a service. This kind of dynamism is a
powerful part of 7.0.

\section{Dynamic Deployment}\label{dynamic-deployment}

In OSGi, all components, Java classes, resources, and descriptors are
deployed via modules. The \texttt{MANIFEST.MF} file describes the
module's physical characteristics, such as the packages it exports and
imports. The module's component description files specify its functional
characteristics (i.e., the services its components offer and consume).
Also modules and their components have their own lifecycles and
administrative APIs. Declarative Services and shell tools give you
fine-grained control over module and component deployment.

Since a module's contents depend on its activation, consider the
activation steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \emph{Installation}: Copying the module JAR into Liferay DXP's
  \texttt{deploy} folder installs the module to the OSGi framework,
  marking the module \texttt{INSTALLED}.
\item
  \emph{Resolution}: Once all the module's requirements are met (e.g.,
  all packages it imports are available), the framework publishes the
  module's exported packages and marks it \texttt{RESOLVED}.
\item
  \emph{Activation}: Modules are activated \emph{eagerly} by default.
  That is, they're started in the framework and marked \texttt{ACTIVE}
  on resolution. An active module's components are enabled. If a module
  specifies a \texttt{lazy} activation policy, as shown in the manifest
  header below, it's activated only after another module requests one of
  its classes.

\begin{verbatim}
Bundle-ActivationPolicy: lazy
\end{verbatim}
\end{enumerate}

The figure below illustrates the module lifecycle.

\begin{figure}
\centering
\includegraphics{./images/module-state-diagram.png}
\caption{This state diagram illustrates the module lifecycle.}
\end{figure}

The
\href{/docs/7-0/reference/-/knowledge_base/r/using-the-felix-gogo-shell}{Apache
Felix Gogo Shell} lets developers manage the module lifecycle. They can
install/uninstall modules and start/stop them. Developers can update a
module and notify dependent modules to use the update. Liferay's tools,
including Liferay @ide@, Liferay Workspace, and Blade CLI offer similar
shell commands that use the OSGi Admin API.

On activating a module, its components are enabled. But only
\emph{activated} components can be used. Component activation requires
all its referenced services be satisfied. That is, all services it
references must be registered. The highest ranked service that matches a
reference is bound to the component. When the container finds and binds
all the services the component references, it registers the component.
It's now ready for activation.

Components can use \emph{delayed} (default) or \emph{immediate}
activation policies. To specify immediate activation, the developer adds
the attribute \texttt{immediate=true} to the \texttt{@Component}
annotation.

\begin{verbatim}
@Component(
    immediate = true,
    ...)
\end{verbatim}

Unless immediate activation is specified, the component's activation is
delayed. That is, the component's object is created and its classes are
loaded once the component is requested. In this way delayed activation
can improve startup times and conserve resources.

Gogo Shell's
\href{http://felix.apache.org/documentation/subprojects/apache-felix-service-component-runtime.html\#shell-command}{Service
Component Runtime commands} let you manage components:

\begin{itemize}
\item
  \texttt{scr:list\ {[}bundleID{]}}: Lists the module's (bundle's)
  components.
\item
  \texttt{scr:info\ {[}componentID\textbar{}fullClassName{]}}: Describes
  the component, including its status and the services it provides.
\item
  \texttt{scr:enable\ {[}componentID\textbar{}fullClassName{]}}: Enables
  the component.
\item
  \texttt{scr:disable\ {[}componentID\textbar{}fullClassName{]}}:
  Disables the component. It's disabled on the server (or current server
  node in a cluster) until the server is restarted.
\end{itemize}

Service references are static and reluctant by default. That is, an
injected service remains bound to the referencing component until the
service is disabled. Alternatively, developers can specify \emph{greedy}
service policies for references. Every time a higher ranked matching
service is registered, the framework unbinds the lower ranked service
from the component and binds the new service in its place automatically.
Here's a \texttt{@Reference} annotation that uses a greedy policy:

\begin{verbatim}
@Reference(policyOption = ReferencePolicyOption.GREEDY)
\end{verbatim}

Declarative Services annotations let you specify component activation
and service policies. Gogo Shell commands let you control modules and
components. Next, you'll create and deploy a module and component to
Liferay DXP.

\section{Example: Building an OSGi
Module}\label{example-building-an-osgi-module}

The previous sections explained some of the most important concepts for
Liferay Portal 6 developers to understand about OSGi and modularity. Now
it's time to put this knowledge to practice by creating and deploying a
module.

The module includes a Java class that implements an OSGi service using
Declarative Services. The project uses Gradle and Bnd, and can be built
and deployed from within a
\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-workspace}{Liferay
Workspace}.

Here's the module project's anatomy:

\begin{itemize}
\item
  \texttt{bnd.bnd}
\item
  \texttt{build.gradle}
\item
  \texttt{src/main/java/com/liferay/docs/service/MyService.java}
\end{itemize}

On building the module JAR, Bnd generates the module manifest
automatically.

Here's the Java class:

\begin{verbatim}
package com.liferay.docs.service;

import org.osgi.service.component.annotations.Activate;
import org.osgi.service.component.annotations.Component;

@Component(
    immediate = true,
    service = MyService.class
)
public class MyService {

    @Activate
    void activate() throws Exception {

        System.out.println("Activating " + this.getDescription());
    }

    public String getDescription() {

        return this.getClass().getSimpleName();
    }

}
\end{verbatim}

It contains these methods:

\begin{itemize}
\item
  \texttt{getDescription} - returns the class's name
\item
  \texttt{activate} - prints the console message \emph{Activating
  MyService}. The \texttt{@Activate} annotation signals the OSGi runtime
  environment to invoke this method on component activation.
\end{itemize}

The \texttt{@Component} annotation defines the class as an OSGi service
component. The following properties specify its details:

\begin{itemize}
\item
  \texttt{service=MyService.class} - designates the component to be a
  service component for registering under the type \texttt{MyService}.
  In this example, the class implements a service of itself. Note,
  service components typically implement services for interface classes.
\item
  \texttt{immediate=true} - signals the Service Component Runtime to
  activate the component immediately after the component's dependencies
  are resolved.
\end{itemize}

The \texttt{bnd.bnd} file is next:

\begin{verbatim}
Bundle-SymbolicName: my.service.project
Bundle-Version: 1.0.0
\end{verbatim}

The \texttt{Bundle-SymbolicName} is the arbitrary name for the module.
The module's version value \texttt{1.0.0} is appropriate.

Bnd generates the module's OSGi manifest to the file
\texttt{META-INF/MANIFEST.MF} in the module's JAR. In this project, the
JAR is created in the \texttt{build/libs} folder.

The last file to examine is the Gradle build file \texttt{build.gradle}:

\begin{verbatim}
dependencies {
    compileOnly group: "org.osgi", name: "org.osgi.service.component.annotations", version: "1.3.0"
}
\end{verbatim}

Since the \texttt{MyService} class uses the \texttt{@Component}
annotation, the project depends on the OSGi service component
annotations module. The build script is so simple because Liferay
Workspace module projects leverage the Workspace's Gradle build
infrastructure.

Although this module project was created in a Liferay Workspace, it can
easily be modified to use in other build environments. To keep the focus
on what's most important, it was created in a Liferay Workspace.

Place the project files in a folder under the \texttt{modules} folder
(e.g., \texttt{{[}Liferay\_Workspace{]}/modules/my.service.project}).

To build the module JAR and deploy it to Liferay DXP, execute the
\texttt{deploy} Gradle task:

\begin{verbatim}
../../gradlew deploy
\end{verbatim}

\noindent\hrulefill

\textbf{Note}: If Blade is installed (recommended), Gradle can be
executed by entering \texttt{blade\ gw} followed by a task name (e.g.,
\texttt{blade\ gw\ deploy}). For details on Blade commands, see
\href{/docs/7-0/tutorials/-/knowledge_base/t/blade-cli}{Blade CLI}.

\noindent\hrulefill

On deploying the module, the following message is printed to the server
console:

\texttt{Activating\ MyService}

Congratulations! You've successfully built and deployed an OSGi module
to Liferay DXP.

\section{Learning More about OSGi}\label{learning-more-about-osgi}

There is much more to learn about developing apps using OSGi. Several
resources are listed below and many more abound. To make the best of
your time, however, avoid OSGi service articles that explain techniques
that are older and more complicated than Declarative Services.

Developers new to OSGi should check out these resources:

\begin{itemize}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/introduction-to-liferay-development}{Introduction
  to Liferay Development}: For using OSGi to develop on Liferay DXP.
\item
  \href{http://enroute.osgi.org/}{OSGi enRoute} is a site the OSGi
  Alliance provides to the OSGi community. Its
  \href{https://enroute.osgi.org/Tutorial/}{Tutorials} provide hands-on
  experience with OSGi modules and Declarative Services.
\item
  \href{https://www.osgi.org/developer}{OSGi Alliance's Developer}
  section explains OSGi's architecture and modularity.
\end{itemize}

Developers ready to dive deep into OSGi should read the OSGi
specifications. They're well-written and provide comprehensive details
on all that OSGi offers.
\href{https://osgi.org/download/r6/osgi.cmpn-6.0.0.pdf}{\emph{The OSGi
Alliance OSGi Compendium: Release 6}} specifies the following services
that 7.0 leverages extensively.

\begin{itemize}
\item
  \emph{Declarative Services Specification}
\item
  \emph{Configuration Admin Service Specification}: For modifying
  deployed bundles. Since Configuration Admin services are already
  integrated with Declarative Services, however, Liferay developers need
  not use the low-level API.
\item
  \emph{Metatype Service Specification}: For describing attribute types
  as metadata.
\end{itemize}

\chapter{Improved Developer Tooling: Liferay Workspace, Maven Plugins
and
More}\label{improved-developer-tooling-liferay-workspace-maven-plugins-and-more}

Creating applications is fun when you have the right tools. Here are
some key ingredients:

\begin{itemize}
\tightlist
\item
  Rich templates for stubbing out projects
\item
  Extensible build environments that offer state-of-the-art plugins
\item
  Deployment and runtime management tools
\item
  Application upgrade automation
\end{itemize}

\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-workspace}{Liferay
Workspace} (Workspace) boils over with all these things! It's a
Gradle-based development environment that integrates with
\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-ide}{Liferay @ide@}
and can be used in conjunction with other IDEs, such as a ``vanilla''
Eclipse, IntelliJ, and NetBeans. You can extend Workspace's Gradle
environment with community-developed (or home-grown)
\href{/docs/7-0/reference/-/knowledge_base/r/gradle}{plugins} for
testing, code coverage analysis, and more.

Workspace comes with
\href{/docs/7-0/tutorials/-/knowledge_base/t/blade-cli}{Blade CLI}: a
command line tool for creating and deploying modules, managing the
runtime environment, and more. It provides all kinds of module
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-modules-with-blade-cli\#project-templates}{templates},
to create modules for developing in any Gradle environment.

Liferay's tools also streamline the application upgrade process. Liferay
@ide@'s
\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-upgrade-planner}{Upgrade
Planner} adapts traditional plugins to 7.0 APIs.
\href{/docs/7-0/tutorials/-/knowledge_base/t/themes-generator}{Liferay's
Liferay Theme Generator}
\href{/docs/7-0/tutorials/-/knowledge_base/t/migrating-a-6-2-theme-to-liferay-7}{migrates}
themes and layout templates to the new NodeJS-based environment and
\href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-themes\#running-the-upgrade-task-for-themes-that-use-liferay-js-theme-toolkit}{adapts}
them to 7.0.

Liferay DXP offers you more with
\href{/docs/7-0/tutorials/-/knowledge_base/t/maven}{Maven} too. The
archetype Liferay Project Templates Workspace lets you develop in
Liferay Workspace using Maven. 7.0's' lean artifacts and new project
\href{/docs/7-0/tutorials/-/knowledge_base/t/generating-new-projects-using-archetypes}{archetypes}
and \href{/docs/7-0/reference/-/knowledge_base/r/maven}{Maven plugins}
make Liferay DXP development with Maven easier than ever.

Here are the tooling improvement topics:

\begin{itemize}
\tightlist
\item
  \hyperref[from-the-plugins-sdk-to-liferay-workspace]{Moving from the
  Plugins SDK to Liferay Workspace}
\item
  \hyperref[developing-modules-with-liferay-workspace]{Developing
  modules with Liferay Workspace}
\item
  \hyperref[whats-new-in-product-ver-for-maven-users]{What's new in
  Liferay DXP for Maven Users}
\item
  \hyperref[using-other-build-systems-and-ides]{Using other build
  systems and IDEs}
\end{itemize}

\section{From the Plugins SDK to Liferay
Workspace}\label{from-the-plugins-sdk-to-liferay-workspace}

The Liferay Plugins SDK is deprecated as of 7.0. You can continue
developing on it, but should plan to eventually move to a new
environment.
\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-workspace}{Liferay
Workspace} succeeds the Plugins SDK as Liferay's opinionated development
environment. You should use it if you're not using an alternative build
system like Gradle or Maven.

Here are Workspace's key features:

\begin{itemize}
\tightlist
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/creating-modules-with-blade-cli\#project-templates}{Module
  and component templates}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-sample-modules}{Sample
  projects}
\item
  Portal server configurations
\item
  Folder structure flexibility
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/blade-cli}{Commands} to
  migrate plugins, install Liferay DXP bundles, and start/stop Portal
  instances
\end{itemize}

The
\href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-plugins-to-liferay-7}{plugin
upgrade} tutorials later in this series show how
\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-ide}{Liferay 7.0}
automatically adapts existing plugins to @product-ver@. There's also a
tutorial that demonstrates how you can optionally
\href{/docs/7-0/tutorials/-/knowledge_base/t/migrating-traditional-plugins-to-workspace-web-applications}{migrate
traditional plugins to Workspace}.

\begin{figure}
\centering
\includegraphics{./images/improved-tooling-code-upgrade-configure-proj.png}
\caption{Liferay @ide@'s Upgrade Planner automates many aspects of the
plugin upgrade process.}
\end{figure}

Here's an example Workspace folder structure:

\begin{figure}
\centering
\includegraphics{./images/improved-tooling-workspace-structure.png}
\caption{Liferay Workspace aggregates projects to use the same server
configurations and Gradle build environment.}
\end{figure}

Here's the Workspace anatomy:

\begin{itemize}
\tightlist
\item
  \texttt{bundles/} (generated) → default folder for Liferay DXP bundles
\item
  \texttt{configs/} → holds Portal server configurations
\item
  \texttt{gradle/} → holds the Gradle wrapper files
\item
  \texttt{modules/} → holds module projects
\item
  \texttt{plugins-sdk/} (generated) → holds plugins from previous
  releases
\item
  \texttt{themes/} → holds NodeJS-based theme projects
\item
  \texttt{wars/} (generated) → holds traditional web application
  projects
\item
  \texttt{build.gradle} → common Gradle build file
\item
  \texttt{gradle.properties} → specifies the Portal server configuration
  and project locations
\item
  \texttt{gradlew\ /\ gradlew.bat} → executes the Gradle command wrapper
\item
  \texttt{pom.xml} (only in Workspaces generated by Maven) → common
  Maven build file
\item
  \texttt{settings.gradle} → applies plugins to the Workspace and
  configures its dependencies
\end{itemize}

Workspace module, theme, and war projects use the same Portal server
configurations. Developers can create configurations for module
development, user acceptance testing, production, and more.

Each subfolder under \texttt{configs} holds a Portal server
configuration defined by its \texttt{portal-ext.properties} file. Gradle
property \texttt{liferay.workspace.environment} in Workspace's
\texttt{gradle.properties} file specifies the configuration to use.

Other Gradle properties let you set root locations for the Liferay DXP
bundle, modules, themes, and a Plugins SDK.

\subsection{Workspace Folder Structure
Properties}\label{workspace-folder-structure-properties}

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.4167}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.5833}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Property
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Description
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{liferay.workspace.environment} & Name of a \texttt{configs}
subfolder holding the Portal server configuration to use \\
\texttt{liferay.workspace.home.dir} & Liferay DXP bundle root folder \\
\texttt{liferay.workspace.modules.dir} & Module projects root folder \\
\texttt{liferay.workspace.plugins.sdk.dir} & Plugins SDK root folder \\
\texttt{liferay.workspace.themes.dir} & Theme projects root folder \\
\end{longtable}

Workspace has Gradle tasks equivalent to the Plugins SDK Ant targets.

\subsection{Plugins SDK to Workspace Task
Map}\label{plugins-sdk-to-workspace-task-map}

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.3889}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.3750}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.2361}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Plugins SDK Ant Target
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Workspace Gradle Task
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Task Description
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{build-css} & \texttt{buildCSS} & Builds CSS files \\
\texttt{build-lang} & \texttt{buildLang} & Translates language keys
using Language Builder \\
\texttt{build-service} & \texttt{buildService} & Runs Service Builder \\
\texttt{clean} & \texttt{clean} & Deletes all build outputs \\
\texttt{compile} & \texttt{classes} & Compiles classes \\
\texttt{deploy} & \texttt{deploy} (or \texttt{blade\ deploy}) & Installs
the current module to Liferay DXP's module framework \\
\texttt{jar} & \texttt{jar} & Compiles the project and packages it as a
JAR file \\
\texttt{war} & \texttt{assemble} & Assembles project output \\
\end{longtable}

Other Workspace Gradle tasks provide additional functionality.

\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Workspace Gradle Task & Task Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{buildSoy} & Compiles Closure Templates in JavaScript
functions \\
\texttt{components} & Lists the project's components \\
\texttt{dependencies} & Lists the project's declared dependencies \\
\texttt{initBundle} & Downloads and installs a Liferay DXP bundle \\
\texttt{model} & Lists the project's configuration model \\
\texttt{transpileJS} & Transpiles the project's JavaScript files \\
\end{longtable}

Next, learn how Workspace facilitates module development.

\section{Developing Modules with Liferay
Workspace}\label{developing-modules-with-liferay-workspace}

Workspace is a great Liferay module development environment because of
these features:

\begin{itemize}
\tightlist
\item
  Templates that bootstrap module creation
\item
  Gradle and Maven build systems for managing dependencies and
  assembling modules
\item
  Module deployment and runtime management capabilities
\end{itemize}

\href{/docs/7-0/tutorials/-/knowledge_base/t/blade-cli}{Blade CLI}
(Blade), which is a part of Workspace, has over twenty templates for
Gradle-based module projects--and more are being added. The templates
stub out classes and resource files for you to fill in with business
logic and key information.

Here are some of the template's names:

\begin{itemize}
\tightlist
\item
  Activator
\item
  API
\item
  Content Targeting Report
\item
  Content Targeting Rule
\item
  Content Targeting Tracking Action
\item
  Control Menu Entry
\item
  MVC Portlet
\item
  Panel App
\item
  Portlet
\item
  Portlet Configuration Icon
\item
  Portlet Provider
\item
  Portlet Toolbar Contributor
\item
  Service
\item
  Service Builder
\item
  Service Wrapper
\item
  Simulation Panel Entry
\item
  Template Context Contributor
\end{itemize}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-modules-with-blade-cli}{Blade
creates modules} based on these templates.

For example, the following Blade command creates a Liferay MVC Portlet
module called \texttt{my-module}:

\begin{verbatim}
blade create -t mvc-portlet -p com.liferay.docs.mymodule -c MyMvcPortlet my-module
\end{verbatim}

Liferay @ide@'s
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-modules-with-liferay-ide}{module
project wizard} creates Workspace modules from the templates too.

\begin{figure}
\centering
\includegraphics{./images/improved-tooling-module-wizard.png}
\caption{Liferay @ide@ lets developers select templates to stub out
modules.}
\end{figure}

Liferay @ide@'s component wizard facilitates
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-modules-with-liferay-ide\#creating-component-classes}{creating
component classes} for portlets, service wrappers, Struts actions, and
more.

\begin{figure}
\centering
\includegraphics{./images/improved-tooling-component-wizard.png}
\caption{Liferay @ide@'s component wizard facilitates creating component
classes.}
\end{figure}

Building and deploying modules in a Workspace is a snap using
\href{/docs/7-0/tutorials/-/knowledge_base/t/deploying-modules-with-liferay-ide}{Liferay
@ide@} and
\href{/docs/7-0/tutorials/-/knowledge_base/t/deploying-modules-with-blade-cli}{Blade}.
Workspace uses BndTools to generate each module's OSGi headers in a
\texttt{META-INF/MANIFEST.MF} file. Workspace deploy modules to the OSGi
container using Felix File Install commands.

Liferay @ide@ lets you deploy modules by dragging them onto your Portal
server.

\begin{figure}
\centering
\includegraphics{./images/improved-tooling-drag-n-drop-onto-server.png}
\caption{Liferay @ide@ lets you deploy modules using drag-and-drop.}
\end{figure}

In a terminal, you can deploy modules using Blade's \texttt{deploy}
command. For example, the following command deploys the current module
and
\href{/docs/7-0/tutorials/-/knowledge_base/t/starting-module-development\#redeploying-module-changes-automatically}{``watches''
for module changes to redeploy automatically}.

\begin{verbatim}
blade deploy -w
\end{verbatim}

To learn more about Workspace and using it in Liferay @ide@, see these
tutorials:

\begin{itemize}
\tightlist
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-workspace}{Workspace}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/blade-cli}{Blade CLI}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-ide}{Liferay
  @ide@}
\end{itemize}

And make sure to check out the tutorial
\href{/docs/7-0/tutorials/-/knowledge_base/t/starting-module-development}{Starting
Module Development}.

Next, you'll learn new features for developing on Liferay DXP using
Maven.

\section{What's New in 7.0 for Maven
Users}\label{whats-new-in-7.0-for-maven-users}

7.0 fully supports Maven development and offers several new and improved
features:

\begin{itemize}
\tightlist
\item
  Liferay Workspace for Maven
\item
  New archetypes
\item
  New Maven plugins
\item
  More granular dependency management
\end{itemize}

The new archetype Liferay Project Templates Workspace generates a
Liferay Workspace that includes a POM file for developing in Workspace
using Maven. You can develop modules and themes in the Workspace
subfolders.

7.0 provides many new Maven archetypes for various Liferay module
projects. There are over twenty-five Maven archetypes for 7.0, and more
are in development. Here are some popular ones:

\begin{itemize}
\tightlist
\item
  Portlets
\item
  Themes
\item
  Configuration Icons
\item
  Menu Buttons
\item
  Service Builder
\end{itemize}

Liferay's Maven archetypes cover many different Liferay frameworks and
service types. These make Maven a first-class tool for creating Liferay
modules and themes. Visit the
\href{/docs/7-0/tutorials/-/knowledge_base/t/generating-new-projects-using-archetypes}{Generating
New Projects Using Archetypes} tutorial to learn more about Liferay's
Maven archetypes and how to use them.

Liferay also provides several new and updated
\href{/docs/7-0/reference/-/knowledge_base/r/maven}{Maven plugins} that
simplify the build process. The following plugins build style sheets,
services, and themes respectively:

\begin{itemize}
\tightlist
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/compiling-sass-files-in-a-maven-project}{CSS
  Builder}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/using-service-builder-in-a-maven-project}{Service
  Builder}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/building-themes-in-a-maven-project}{Theme
  Builder}
\end{itemize}

7.0's modularity provides a more granular dependency management
experience. You no longer need to depend on \texttt{portal-impl} or
\texttt{portal-service} (now \texttt{portal-kernel}) for everything. For
example, to use Liferay's Wiki framework, you need only depend on the
Wiki module. You set dependencies on concise modules that provide the
functionality you want without inheriting extra baggage.

Liferay's new Workspace environment, Maven archetypes, Maven plugins,
and streamlined modules make developing on Liferay DXP easier than ever.
To learn more, see the
\href{/docs/7-0/tutorials/-/knowledge_base/t/maven}{Maven tutorials}.

\section{Using Other Build Systems and
IDEs}\label{using-other-build-systems-and-ides}

Liferay DXP is tool agnostic--you can use whatever tools you like to
develop on it. You can use any IDE and even use Gradle, Bnd, or BndTools
if you don't want to use Workspace. The drawback is you lose the
Liferay-specific project templates that you get with Blade and
Workspace.

Blade lets you create modules to develop anywhere, not only in Liferay
Workspace.

Here are some new Gradle features Liferay provides that are independent
of Workspace:

\begin{itemize}
\tightlist
\item
  Liferay's \href{/docs/7-0/reference/-/knowledge_base/r/gradle}{Gradle
  plugins}
\item
  Buildship plugins in Liferay @ide@
\item
  Liferay @ide@'s
  \href{/docs/7-0/tutorials/-/knowledge_base/t/using-gradle-in-liferay-ide}{new
  Gradle views} for developing modules and working with Gradle tasks
\end{itemize}

Liferay has worked hard to make Liferay DXP IDE-agnostic. There are
Liferay module developers who use IntelliJ and some enjoy using
NetBeans.

Finally, you can copy and modify
\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-sample-modules}{Liferay
sample projects} to serve as templates in place of the Blade templates.
They're available for these build systems:

\begin{itemize}
\tightlist
\item
  Maven
\item
  Gradle
\item
  Liferay's Gradle environment based on the \texttt{com.liferay.plugin}
  plugin
\end{itemize}

Liferay's approach to tooling has vastly improved for 7.0. Our tools
help you upgrade to 7.0, continue developing traditional plugins the way
you have been, and migrate to optimal development environments. Liferay
Workspace and the improved Maven support facilitate module development.
And developing on Liferay DXP using other tools is easier than ever.
Your tool options are wide open.

\chapter{Planning Plugin Upgrades and
Optimizations}\label{planning-plugin-upgrades-and-optimizations}

If you've explored 7.0's features and possibly created new portlet
modules themes with Liferay's new
\href{/docs/7-0/tutorials/-/knowledge_base/t/improved-developer-tooling-liferay-workspace-maven-plugins-and-more}{tooling}
and
\href{/docs/7-0/tutorials/-/knowledge_base/t/osgi-and-modularity-for-liferay-6-developers}{techniques},
you may be wondering how you'd upgrade existing plugins. The great thing
is that Liferay has automated much of the upgrade process. In addition,
you can continue developing plugins in traditional ways and adopt new
development tooling and techniques when you're ready.

This tutorial guides you through phases of \emph{upgrading} plugins and
optionally \emph{optimizing} them.

\textbf{Upgrade}: A process for deploying an existing plugin on 7.0 with
minimal changes.

\textbf{Optimization}: An optional but recommended process for modifying
a plugin or migrating it to a new environment to improve the plugin or
facilitate developing it.

Importantly, you should \emph{upgrade} a plugin before applying any
optimizations to it.

The good news is that upgrading plugins to 7.0 is straightforward. For
Plugins SDK and Maven projects, Liferay @ide@'s
\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-upgrade-planner}{Upgrade
Planner} automates much of the process. In addition, the
\href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-plugins-to-liferay-7}{upgrade
tutorials} demonstrate any remaining upgrade steps.

You can deploy plugins to 7.0 as you have for previous releases (e.g.,
\texttt{ant\ clean\ deploy}). Since everything in 7.0 runs as OSGi
modules, however, you might wonder how traditional WAR-style plugins can
run on it. The answer: Liferay's Plugin Compatibility Layer.

The Plugin Compatibility Layer converts standard WARs to Web Application
Bundles (WABs). WABs are full-fledged OSGi modules. The Plugin
Compatibility Layer's
\href{/docs/7-0/tutorials/-/knowledge_base/t/using-the-wab-generator}{WAB
Generator} supports deploying traditional plugins and web applications
that contain Servlets, JSPs, and other Java web technologies without
making any OSGi specific changes to them.

Note, you can still use an application server's mechanisms to deploy
regular web applications along with Liferay DXP, without using the
Plugin Compatibility Layer.

After upgrading your plugins you can consider optimizations such as
these:

\begin{itemize}
\tightlist
\item
  Migrating plugins to
  \href{/docs/7-0/tutorials/-/knowledge_base/t/migrating-traditional-plugins-to-workspace-web-applications}{Gradle}
  or Maven to leverage their development commands and rich
  \href{/docs/7-0/tutorials/-/knowledge_base/t/improved-developer-tooling-liferay-workspace-maven-plugins-and-more\#developing-modules-with-liferay-workspace}{Liferay
  plugin templates}.
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/migrating-a-6-2-theme-to-liferay-7}{Migrating
  themes to the Liferay Theme Generator} to add
  \href{/docs/7-0/tutorials/-/knowledge_base/t/themelets}{Themelets}
  (new) and to leverage
  \href{/docs/7-0/tutorials/-/knowledge_base/t/themes-generator}{Node.js,
  Yeoman, and Gulp}.
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/modularizing-an-existing-portlet}{Converting
  plugins to modules} to leverage Declarative Services, extendability,
  and more
  \href{/docs/7-0/tutorials/-/knowledge_base/t/osgi-and-modularity-for-liferay-6-developers}{modularity
  benefits}.
\item
  Using the
  \href{/docs/7-0/tutorials/-/knowledge_base/t/applying-lexicon-styles-to-your-app}{Lexicon},
  to apply a clean consistent application user experience.
\end{itemize}

See the
\href{/docs/7-0/tutorials/-/knowledge_base/t/optimizing-plugins-for-liferay-7}{optimization
tutorials} for more options and details.

You \emph{can} continue using the Plugins SDK to develop plugins. But
the Plugins SDK is deprecated as of 7.0. In light of the deprecation,
you should consider migrating plugins from the Plugins SDK to one of the
new environments:

\begin{itemize}
\tightlist
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/improved-developer-tooling-liferay-workspace-maven-plugins-and-more\#from-the-plugins-sdk-to-liferay-workspace}{Liferay
  Workspace} is a Gradle environment that supports developing modules
  and traditional plugins.
  \href{/docs/7-0/tutorials/-/knowledge_base/t/migrating-traditional-plugins-to-workspace-web-applications}{Blade's}
  \href{/docs/7-0/tutorials/-/knowledge_base/t/migrating-traditional-plugins-to-workspace-web-applications}{\texttt{migrateWar\ \ command}}
  moves Plugins SDK portlets to Liferay Workspace (Workspace) in a snap.
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/improved-developer-tooling-liferay-workspace-maven-plugins-and-more\#whats-new-in-product-ver-for-maven-users}{Liferay's
  Maven} plugins and archetypes support developing modules and
  traditional plugins. There's also a Liferay Workspace archetype for
  generating a Workspace that uses Maven.
\end{itemize}

\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-ide}{Liferay @ide@}
supports developing in Workspaces using Gradle or
\href{/docs/7-0/tutorials/-/knowledge_base/t/using-maven-in-liferay-ide}{Maven}.

In short, there's plenty of time to move plugins out of the Plugins SDK,
but you should at least plan for migrating to a new environment that
works best for you.

Speaking of planning, properly planned upgrades and optimizations reduce
the time and effort they take. To help guide you through the upgrade and
optimization tutorials, you get these things:

\begin{itemize}
\tightlist
\item
  Upgrade and optimization phase descriptions
\item
  Upgrade and optimization paths
\end{itemize}

\section{Upgrade and Optimization
Phases}\label{upgrade-and-optimization-phases}

Follow these upgrade and optimization phases:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Read the applicable
  \href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-plugins-to-liferay-7}{upgrade
  tutorials} for your plugin. Examine the upgrade and optimization
  paths.
\item
  Upgrade the plugin, making only the minimal changes necessary for it
  to work on 7.0.
\item
  (Optional) Identify and apply only the most beneficial
  \href{/docs/7-0/tutorials/-/knowledge_base/t/optimizing-plugins-for-liferay-7}{optimizations}
  for your plugin.
\item
  (Optional) Apply additional optimizations as desired.
\end{enumerate}

\section{Upgrade and Optimization
Paths}\label{upgrade-and-optimization-paths}

The following tables provide upgrade and optimization paths for 6.2
plugins and features.

\subsection{Plugin Upgrade and Optimization
Paths}\label{plugin-upgrade-and-optimization-paths}

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.2222}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.4444}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Plugin
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Upgrade path
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Optimizations (optional)
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Ext &
\href{/docs/7-0/tutorials/-/knowledge_base/t/advanced-customization-with-ext-plugins}{Customization
with Ext Plugins} & None \\
Hook - Language files & -
\href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-core-language-key-hooks}{Upgrading
Core Language Key Hooks}-
\href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-portlet-language-key-hooks}{Upgrading
Portlet Language Key Hooks} & Same \\
Hook - Override a Liferay DXP Core JSP &
\href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-core-jsp-hooks}{Upgrading
Core JSP Hooks} & Same \\
Hook - Override an app's JSP &
\href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-app-jsp-hook-plugins}{Upgrading
App JSP Hooks} & Same \\
Hook - Event Actions (Portal/Session/Servlet Service/Shutdown/Startup) &
\href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-portal-property-and-event-action-hooks}{Upgrading
Portal Property and Event Action Hooks} & None \\
Hook - Model Listeners &
\href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-model-listener-hooks}{Upgrading
Model Listener Hooks} & Same \\
Hook - Portal Properties &
\href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-portal-property-and-event-action-hooks}{Upgrading
Portal Property and Event Action Hooks} & Same \\
Hook - Properties & - If the property is now a
\href{/docs/7-0/user/-/knowledge_base/u/system-settings}{System
Setting}, edit it there and/or use a \texttt{.config} file- If the
property is in the
\href{@platform-ref@/7.0-latest/definitions/liferay-hook_7_0_0.dtd.html}{liferay-hook.xml's
DTD}, then
\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-upgrade-planner}{adapt
code to API} and
\href{/docs/7-0/tutorials/-/knowledge_base/t/resolving-a-plugins-dependencies}{resolve
dependencies} & None \\
Hook - Service Wrappers &
\href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-service-wrappers}{Upgrading
Service Wrappers} & None \\
Hook - Servlet Filter &
\href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-servlet-filter-hooks}{Upgrading
Servlet Filter Hooks} & None \\
Hook - Struts actions & -
\href{/docs/7-0/tutorials/-/knowledge_base/t/converting-strutsactionwrappers-to-mvccommands}{StrutsAction
→ StrutsActionWrapper} -
\href{/docs/7-0/tutorials/-/knowledge_base/t/overriding-mvc-commands\#overriding-mvcactioncommand}{processAction
→ MVCActionCommand} -
\href{/docs/7-0/tutorials/-/knowledge_base/t/overriding-mvc-commands\#overriding-mvcrendercommand}{render
→ MVCRenderCommand} -
\href{/docs/7-0/tutorials/-/knowledge_base/t/overriding-mvc-commands\#overriding-mvcresourcecommand}{serveResource
→ MVCResourceCommand} & Same \\
Layout Template & 1.
\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-upgrade-planner}{Adapt
code to API}2.
\href{/docs/7-0/tutorials/-/knowledge_base/t/resolving-a-plugins-dependencies}{Resolve
dependencies}3.
\href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-layout-templates}{Update
Layout Template} & -
\href{/docs/7-0/tutorials/-/knowledge_base/t/migrating-a-6-2-theme-to-liferay-7}{Migrate
to Liferay Theme Generator} (Node.js/Gulp/Yeoman) \\
Portlet - GenericPortlet &
\href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-a-genericportlet}{Upgrading
a GenericPortlet} & -
\href{/docs/7-0/tutorials/-/knowledge_base/t/migrating-traditional-plugins-to-workspace-web-applications}{Migrate
to Workspace/Gradle}-
\href{/docs/7-0/tutorials/-/knowledge_base/t/applying-lexicon-styles-to-your-app}{Apply
Lexicon}-
\href{/docs/7-0/tutorials/-/knowledge_base/t/modularizing-an-existing-portlet}{Convert
to OSGi modules} \\
Portlet - Liferay MVC &
\href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-a-liferay-mvc-portlet}{Upgrading
a Liferay MVC Portlet} & -
\href{/docs/7-0/tutorials/-/knowledge_base/t/migrating-traditional-plugins-to-workspace-web-applications}{Migrate
to Workspace/Gradle}-
\href{/docs/7-0/tutorials/-/knowledge_base/t/applying-lexicon-styles-to-your-app}{Apply
Lexicon}-
\href{/docs/7-0/tutorials/-/knowledge_base/t/modularizing-an-existing-portlet}{Convert
to OSGi modules} \\
Portlet - JSF &
\href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-a-liferay-jsf-portlet}{Upgrading
a Liferay JSF Portlet} & None \\
Portlet - Servlet/JSP &
\href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-a-servlet-based-portlet}{Upgrading
a Servlet-based Portlet} & None \\
Portlet - Spring MVC &
\href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-a-spring-mvc-portlet}{Upgrading
a Spring MVC Portlet} & None \\
Portlet - Struts 1 &
\href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-a-struts-portlet}{Upgrading
a Struts Portlet} & None \\
Theme & 1.
\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-upgrade-planner}{Adapt
code to API}2.
\href{/docs/7-0/tutorials/-/knowledge_base/t/resolving-a-plugins-dependencies}{Resolve
dependencies}3.
\href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-themes}{Upgrade
Theme} & -
\href{/docs/7-0/tutorials/-/knowledge_base/t/migrating-a-6-2-theme-to-liferay-7}{Migrate
to Liferay Theme Generator} (Node.js/Gulp/Yeoman)-
\href{/docs/7-0/tutorials/-/knowledge_base/t/themelets}{Use
Themelets} \\
Web plugin & 1.
\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-upgrade-planner}{Adapt
code to API}2.
\href{/docs/7-0/tutorials/-/knowledge_base/t/resolving-a-plugins-dependencies}{Resolve
dependencies} &
\href{/docs/7-0/tutorials/-/knowledge_base/t/modularizing-an-existing-portlet}{Convert
to OSGi module}, e.g., \texttt{portlet-x-web} \\
\end{longtable}

\subsection{Feature Upgrade and Optimization
Paths}\label{feature-upgrade-and-optimization-paths}

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.2222}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.4444}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Feature
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Upgrade path
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Optimizations (optional)
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
JNDI data source &
\href{/docs/7-0/tutorials/-/knowledge_base/t/connecting-to-data-sources-using-jndi}{Use
Liferay DXP's classloader to access the app server's JNDI API} & None \\
Resources Importer &
\href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-themes\#updating-the-resources-importer}{Update
the Resources Importer} & None \\
Services - Invoke a service from Liferay DXP Core or another portlet or
module &
\href{/docs/7-0/tutorials/-/knowledge_base/t/service-trackers}{Implement
a Service Tracker} &
\href{/docs/7-0/tutorials/-/knowledge_base/t/finding-and-invoking-liferay-services}{Invoke
Liferay services from a module} \\
Services - Module dependency & Copy \texttt{x-service.jar} to
\texttt{WEB-INF/lib} & -
\href{/docs/7-0/tutorials/-/knowledge_base/t/migrating-traditional-plugins-to-workspace-web-applications}{Migrate
to Gradle/Maven} and
\href{/docs/7-0/tutorials/-/knowledge_base/t/configuring-dependencies}{add
dependency} on the OSGi service \\
Services - Service Builder &
\href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-portlets-that-use-service-builder}{Upgrading
Portlets that use Service Builder} &
\href{/docs/7-0/tutorials/-/knowledge_base/t/modularizing-an-existing-portlet}{Convert
to OSGi modules}, e.g., \texttt{x-api} and \texttt{x-service} \\
Services - Web services & 1.
\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-upgrade-planner}{Adapt
code to API}2.
\href{/docs/7-0/tutorials/-/knowledge_base/t/resolving-a-plugins-dependencies}{Resolve
dependencies} &
\href{/docs/7-0/tutorials/-/knowledge_base/t/jax-ws-and-jax-rs}{Use a
Service Builder service with JAX-RS with a REST service in front} \\
Template - FreeMarker & -
\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-upgrade-planner}{Adapt
code to API}-
\href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-themes\#updating-theme-templates}{Adapt
Theme templates} & None \\
Template - Velocity (deprecated) &
\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-upgrade-planner}{Adapt
code to API} &
\href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-themes\#updating-theme-templates}{Convert
to FreeMarker} \\
\end{longtable}

Now you have a game plan and a cheat sheet for upgrading and optimizing
plugins with confidence.

\section{Upgrading Plugins to 7.0}\label{upgrading-plugins-to-7.0}

Upgrading to 7.0 involves migrating your installation and code (your
custom apps) to the new version. You'll learn how to upgrade your code
in this section.

The first upgrade process step is to adapt your existing plugin's code
to 7.0's APIs. The great news is that Liferay's Upgrade Planner makes
this easier than ever. It identifies Liferay API changes affecting your
code, explains the API changes, and offers resolution steps. And the
tool offers auto-correction where it can.

You might be tempted to optimize your existing plugins right away to
benefit from the new things Liferay DXP offers, but you shouldn't. It's
much better to upgrade your plugins according to these tutorials. In
this way, you'll get your plugins running in Liferay as fast as
possible, and at the same time you'll have prepared the plugins for the
optimizations you can implement later.

These tutorials assume you're using the
\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-upgrade-planner}{Liferay
Upgrade Planner}. To follow along with this section, install the planner
and step through the upgrade instructions.

For convenience, this tutorial section also references documentation and
outlined steps to aid those opting to upgrade their code manually.

Here are the code upgrade steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-your-development-environment}{Upgrade
  Your Development Environment}

  Legacy project environments should be upgraded to the latest version
  of Liferay Workspace to ensure you leverage all available features.

  \begin{enumerate}
  \def\labelenumii{\arabic{enumii}.}
  \item
    \href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-your-development-environment\#setting-up-liferay-workspace}{Set
    Up Liferay Workspace}

    A Liferay Workspace is a generated environment that is built to hold
    and manage your Liferay projects. Create/import a workspace to get
    started.

    \begin{enumerate}
    \def\labelenumiii{\arabic{enumiii}.}
    \item
      \href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-your-development-environment\#creating-new-liferay-workspace}{Create
      New Liferay Workspace}

      If you don't have an existing 7.x Liferay Workspace, you must
      create one. Skip to the next step if you have an existing
      workspace.
    \item
      \href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-your-development-environment\#importing-existing-liferay-workspace}{Import
      Existing Liferay Workspace}

      Import an existing Liferay Workspace. If you don't have one,
      revisit the previous step.
    \end{enumerate}
  \item
    \href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-your-development-environment\#configuring-liferay-workspace-settings}{Configure
    Liferay Workspace Settings}

    Set the Liferay DXP version in workspace's configuration you intend
    to upgrade to.

    \begin{enumerate}
    \def\labelenumiii{\arabic{enumiii}.}
    \item
      \href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-your-development-environment\#configuring-bundle-url}{Configure
      Bundle URL}

      Configure your bundle URL that the Liferay DXP bundle is
      downloaded from.
    \item
      \href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-your-development-environment\#configuring-target-platform-version}{Configure
      Target Platform Version}

      Configure your Target Platform version, which provides the
      specific artifacts associated with a Liferay DXP release.
    \item
      \href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-your-development-environment\#initializing-server-bundle}{Initialize
      Server Bundle}

      Download the Liferay DXP bundle you're upgrading to.
    \end{enumerate}
  \end{enumerate}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/migrating-plugins-sdk-projects-to-liferay-workspace}{Migrate
  Plugins SDK Projects}

  Copy your Plugins SDK projects into workspace and convert them to
  Gradle/Maven projects.

  \begin{enumerate}
  \def\labelenumii{\arabic{enumii}.}
  \item
    \href{/docs/7-0/tutorials/-/knowledge_base/t/migrating-plugins-sdk-projects-to-liferay-workspace\#importing-existing-plugins-sdk-projects}{Import
    Existing Plugins SDK Projects}

    Import your existing Plugins SDK projects.
  \item
    \href{/docs/7-0/tutorials/-/knowledge_base/t/migrating-plugins-sdk-projects-to-liferay-workspace\#migrating-existing-plugins-to-workspace}{Migrate
    Existing Plugins to Workspace}

    Migrate your existing plugins to workspace. This involves moving the
    plugin to workspace and converting it to the workspace's build
    environment.
  \end{enumerate}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-build-dependencies}{Upgrade
  Build Dependencies}

  Optimize your workspace's build environment for the most efficient
  code upgrade experience.

  \begin{enumerate}
  \def\labelenumii{\arabic{enumii}.}
  \item
    \href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-build-dependencies\#updating-the-repository-url}{Update
    Repository URL}

    Update your repository URL to Liferay's frequently updated CDN
    repository.
  \item
    \href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-build-dependencies\#updating-the-workspace-plugin-version}{Update
    Workspace Plugin Version}

    Update your Workspace plugin version to leverage the latest features
    of Liferay Workspace.
  \item
    \href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-build-dependencies\#removing-your-projects-build-dependency-versions}{Remove
    Dependency Versions}

    Remove the project's dependency versions since it's leveraging
    target platform.
  \end{enumerate}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/fixing-upgrade-problems}{Fix
  Upgrade Problems}

  Fix common upgrade problems dealing with your project's dependencies
  and breaking changes.

  \begin{enumerate}
  \def\labelenumii{\arabic{enumii}.}
  \item
    \href{/docs/7-0/tutorials/-/knowledge_base/t/fixing-upgrade-problems\#auto-correcting-upgrade-problems}{Auto-Correct
    Upgrade Problems}

    Auto-correct straightforward upgrade problems.
  \item
    \href{/docs/7-0/tutorials/-/knowledge_base/t/fixing-upgrade-problems\#finding-upgrade-problems}{Find
    Upgrade Problems}

    Find upgrade problems. These are problems that cannot be
    auto-corrected; you can update them manually according to the
    breaking changes documentation.
  \item
    \href{/docs/7-0/tutorials/-/knowledge_base/t/fixing-upgrade-problems\#resolving-upgrade-problems}{Resolve
    Upgrade Problems}

    Mark upgrade problems as resolved after addressing them.
  \item
    \href{/docs/7-0/tutorials/-/knowledge_base/t/fixing-upgrade-problems\#removing-problem-markers}{Remove
    Problem Markers}

    After fixing your upgrade problems, remove the problem markers.
  \item
    \href{/docs/7-0/tutorials/-/knowledge_base/t/resolving-a-plugins-dependencies}{Resolving
    a Plugin's Dependencies}
  \item
    \href{/docs/7-0/tutorials/-/knowledge_base/t/resolving-breaking-changes}{Resolving
    Breaking Changes}
  \end{enumerate}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-hook-plugins}{Upgrade
  Customization Plugins}

  Upgrade your customization plugins so they're deployable to 7.0.

  \begin{enumerate}
  \def\labelenumii{\arabic{enumii}.}
  \item
    \href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-customization-modules}{Upgrade
    Customization Modules}
  \item
    \href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-core-jsp-hooks}{Upgrade
    Core JSP Hooks}
  \item
    \href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-app-jsp-hook-plugins}{Upgrade
    Portlet JSP Hooks}
  \item
    \href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-service-wrappers}{Upgrade
    Service Wrapper Hooks}
  \item
    \href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-core-language-key-hooks}{Upgrade
    Core Language Key Hooks}
  \item
    \href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-app-jsp-hook-plugins}{Upgrade
    Portlet Language Key Hooks}
  \item
    \href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-model-listener-hooks}{Upgrade
    Model Listener Hooks}
  \item
    \href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-portal-property-and-event-action-hooks}{Upgrade
    Event Action Hooks}
  \item
    \href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-servlet-filter-hooks}{Upgrade
    Servlet Filter Hooks}
  \item
    \href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-portal-property-and-event-action-hooks}{Upgrade
    Portal Properties Hooks}
  \item
    \href{/docs/7-0/tutorials/-/knowledge_base/t/converting-strutsactionwrappers-to-mvccommands}{Upgrade
    Struts Action Hooks}
  \end{enumerate}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-themes-intro}{Upgrade
  Themes}

  Upgrade your themes so they're deployable to 7.0.

  \begin{enumerate}
  \def\labelenumii{\arabic{enumii}.}
  \item
    \href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-your-theme-from-6-1-to-7-0}{Upgrading
    Your Theme from Liferay Portal 6.1 to 7.0}
  \item
    \href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-themes}{Upgrading
    Your Theme from Liferay Portal 6.2 to 7.0}
  \end{enumerate}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-layout-templates}{Upgrade
  Layout Templates}

  Upgrade your layout templates so they're deployable to 7.0.
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-frameworks-and-features}{Upgrade
  Frameworks \& Features}

  \begin{enumerate}
  \def\labelenumii{\arabic{enumii}.}
  \item
    \href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-jndi-data-source-usage}{Upgrade
    JNDI Data Source Usage}

    Use Liferay DXP's class loader to access the app server's JNDI API.
  \item
    \href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-service-builder-service-invocation}{Upgrade
    Service Builder Service Invocation}

    For Service Builder logic remaining in a WAR, you must implement a
    service tracker to call services. For logic divided into OSGi
    modules, you can leverage Declarative Services.
  \item
    \href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-service-builder}{Upgrade
    Service Builder}

    Adapt your app to account for Service Builder-specific changes.
  \item
    \href{/docs/7-0/tutorials/-/knowledge_base/t/migrating-off-of-velocity-templates}{Migrate
    Off of Velocity Templates}

    Velocity template usage is deprecated for 7.0. You should convert
    your template to FreeMarker.
  \end{enumerate}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-portlet-plugins}{Upgrade
  Portlets}

  Upgrade your portlets so they're deployable to 7.0.

  \begin{enumerate}
  \def\labelenumii{\arabic{enumii}.}
  \item
    \href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-a-genericportlet}{Upgrade
    Generic Portlets}
  \item
    \href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-a-liferay-mvc-portlet}{Upgrade
    Liferay MVC Portlets}
  \item
    \href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-a-liferay-jsf-portlet}{Upgrade
    JSF Portlets}
  \item
    \href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-a-servlet-based-portlet}{Upgrade
    Servlet-based Portlets}
  \item
    \href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-a-spring-mvc-portlet}{Upgrading
    Spring MVC Portlets}
  \item
    \href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-a-struts-portlet}{Upgrade
    Struts Portlets}
  \end{enumerate}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-web-plugins}{Upgrade
  Web Plugins}

  Upgrade web plugins previously stored in the \texttt{webs} folder of
  your legacy Plugins SDK.
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-ext-plugins}{Upgrade
  Ext Plugins}

  Attempt to leverage an extension point instead of upgrading your Ext
  plugin. If an Ext plugin is necessary, you must review all changes
  between the previous Liferay Portal instance you were using and 7.0,
  and then manually modify your Ext plugin to merge your changes with
  Liferay DXP's.
\end{enumerate}

Once you've finished the code upgrade steps, your custom apps will be
compatible with 7.0!

\section{Upgrading Your Development
Environment}\label{upgrading-your-development-environment}

A
\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-workspace}{Liferay
Workspace} is a generated environment that is built to hold and manage
your Liferay projects. It is intended to aid in the management of
Liferay projects by providing various build scripts and configured
properties.

Liferay Workspace is the recommended environment for your code
migration; therefore, it will be the assumed development environment in
this section.

Continue on to set up a workspace.

\subsection{Setting Up Liferay
Workspace}\label{setting-up-liferay-workspace}

You must set up your workspace development environment before you begin
upgrading your custom apps. If you don't have an existing workspace,
follow the step for creating one. If you have an existing workspace,
follow the step on importing it into the Upgrade Planner.

\subsubsection{Creating New Liferay
Workspace}\label{creating-new-liferay-workspace}

Initiating this step in the Upgrade Planner loads the Liferay Workspace
Project wizard.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Give your new workspace a name.
\item
  Choose the build type (Gradle or Maven) you prefer for your workspace
  environment and future Liferay projects.
\item
  Click Finish.
\end{enumerate}

You now have a new Liferay Workspace available in the Upgrade Planner!

For more information on creating a Liferay Workspace outside the
planner, see the
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-a-liferay-workspace-with-blade-cli}{Creating
a Liferay Workspace} section.

\subsubsection{Importing Existing Liferay
Workspace}\label{importing-existing-liferay-workspace}

If you already have an existing 7.x Liferay Workspace, you should import
it into the planner. Once you initiate this step, you're given a File
Explorer/Manager to select your existing workspace. After selecting it,
the workspace is imported into the Project Explorer.

For more information importing a workspace into your IDE, see
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-modules-with-liferay-ide}{this
article}.

\subsection{Configuring Liferay Workspace
Settings}\label{configuring-liferay-workspace-settings}

You must configure your workspace with the Liferay DXP version you
intend to upgrade to. You should verify the workspace's

\begin{itemize}
\tightlist
\item
  Bundle URL
\item
  Target Platform Version
\end{itemize}

The bundle URL version and target platform version must match.

Visit these steps to begin.

\subsubsection{Configuring Bundle URL}\label{configuring-bundle-url}

The bundle URL points to the Liferay DXP version you want workspace to
download. When initiating this step, your workspace's Bundle URL
property is updated to the latest release of 7.0.

For more information on configuring a workspace's bundle URL, see the
\href{/docs/7-0/tutorials/-/knowledge_base/t/configuring-a-liferay-workspace\#adding-a-liferay-bundle-to-a-workspace}{Adding
a Liferay Bundle to Liferay Workspace} article.

\subsubsection{Configuring Target Platform
Version}\label{configuring-target-platform-version}

The target platform is the Liferay DXP version you intend to develop for
in your workspace. This is used to specify dependencies associated with
a specific release. You set the target platform, define your
dependencies, and workspace automatically assigns the dependency
versions based on the set Liferay DXP version. When initiating this
step, your workspace's Target Platform property is updated to the latest
release of 7.0.

For more information on this, see the
\href{/docs/7-0/tutorials/-/knowledge_base/t/managing-the-target-platform-for-liferay-workspace}{Managing
the Target Platform} article.

\subsection{Initializing Server
Bundle}\label{initializing-server-bundle}

Once your workspace is configured for the Liferay DXP version you're
upgrading to, you can initialize the server bundle. This involves
downloading the bundle and extracting it into its folder (e.g.,
\texttt{bundles}). If you have an existing workspace already equipped
with an older Liferay bundle, this deletes the old bundle and
initializes the new one.

If you're upgrading your code manually and working in Dev Studio, you
can do this by right-clicking the workspace project and selecting
\emph{Liferay} → \emph{Initialize Server Bundle}. See the
\href{/docs/7-0/tutorials/-/knowledge_base/t/installing-a-server-in-intellij-idea}{Installing
a Server in IntelliJ} article if you use IntelliJ instead. Visit the
\href{/docs/7-0/tutorials/-/knowledge_base/t/managing-module-projects-with-blade-cli}{Managing
Your Liferay Server with Blade CLI} article for information on how to do
this via the command line.

\section{Migrating Plugins SDK Projects to Liferay
Workspace}\label{migrating-plugins-sdk-projects-to-liferay-workspace}

The Plugins SDK was deprecated for Liferay DXP 7.0. Therefore, to
upgrade your custom apps to 7.0, it's recommended to migrate them to a
new environment.
\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-workspace}{Liferay
Workspace} is the recommended environment for your code migration and
will be the assumed choice in this section.

There are two steps you must follow to migrate your custom code to
workspace:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Import the Plugins SDK project into the Upgrade Planner.
\item
  Convert the Plugins SDK project to a supported workspace build type.
\end{enumerate}

You'll step through importing a Plugins SDK project first.

\subsection{Importing Existing Plugins SDK
Projects}\label{importing-existing-plugins-sdk-projects}

Initiating this step in the Upgrade Planner imports your Plugins SDK
projects into the Upgrade Planner. These projects originate from the
Plugins SDK you set when the Upgrade Planner process was started.

If you're manually upgrading your code, you can skip this step.

You're now ready to migrate your Plugins SDK projects to your new
workspace!

\subsection{Migrating Existing Plugins to
Workspace}\label{migrating-existing-plugins-to-workspace}

Liferay Workspace can be generated as a Gradle or Maven environment, but
it does not support the Plugins SDK's Ant build. Because of this, you
must convert your projects to one of the supported build tools:

\begin{itemize}
\tightlist
\item
  Gradle
\item
  Maven
\end{itemize}

When initiating this step for a Gradle-based workspace, your Ant-based
Plugins SDK project is copied to the applicable workspace folder based
on its project type (e.g., \texttt{wars}) and is converted to a Gradle
project. There is also a Blade CLI command that completes this via the
command line. Visit the
\href{/docs/7-0/tutorials/-/knowledge_base/t/converting-plugins-sdk-projects-with-blade-cli}{Converting
Plugins SDK Projects with Blade CLI} article for more information.

If you're migrating your Ant project to a Maven workspace, you must
manually copy the project to the applicable folder based on the project
type (e.g., \texttt{wars}). The majority of Plugins SDK projects belong
in the workspace's \texttt{wars} folder. You can consult the
\href{/docs/7-0/tutorials/-/knowledge_base/t/configuring-a-liferay-workspace}{Workspace
Anatomy} section for a full overview of a workspace's folder structure
and choose where your custom app should reside. Once you've made the
decision, copy your custom app to the applicable workspace folder.

Then you must convert your project from Ant to Maven. You'll have to
complete this conversion manually.

Once you're finished, you should have your project(s) residing in the
applicable workspace folders as Gradle/Maven projects.

\section{Upgrading Build
Dependencies}\label{upgrading-build-dependencies}

Now that your projects are readily available in a workspace, you must
ensure your project build dependencies are upgraded. Your workspace
streamlines the build dependency upgrade process by only requiring three
modifications:

\begin{itemize}
\tightlist
\item
  \hyperref[updating-the-repository-url]{Update the repository URL}
  (Gradle only)
\item
  \hyperref[updating-the-workspace-plugin-version]{Update the workspace
  plugin version}
\item
  \hyperref[removing-your-projects-build-dependency-versions]{Remove
  your project's build dependency versions} (Gradle only)
\end{itemize}

If you're upgrading a recently created workspace, only a subset of these
tasks may be required.

You'll start by updating the repository URL.

\subsection{Updating the Repository
URL}\label{updating-the-repository-url}

Initiating this step in the Upgrade Planner updates the repository URL
used to download artifacts for your workspace.

If you're using a Gradle-based workspace, the repository URL is updated
to point to the latest Liferay CDN repository. This is set in your
workspace's \texttt{settings.gradle} file within the
\texttt{buildscript} block like this:

\begin{verbatim}
repositories {
    maven {
        url "https://repository-cdn.liferay.com/nexus/content/groups/public"
    }
}
\end{verbatim}

Once the repository URL is set to the proper CDN repository, your build
dependencies will be downloaded from Liferay's own managed repo.

For Maven-based workspaces, Maven Central is the default repository, so
no action is required.

\subsection{Updating the Workspace Plugin
Version}\label{updating-the-workspace-plugin-version}

For the best upgrade experience, you should ensure you're leveraging the
latest Liferay Workspace version so all the latest features are
available to you. Initiate this step to upgrade the appropriate plugin.

See the
\href{/docs/7-0/tutorials/-/knowledge_base/t/updating-liferay-workspace}{Updating
Liferay Workspace} article to do this for Gradle-based workspaces
manually. For Maven-based workspaces, make sure you set the latest
\href{/docs/7-0/reference/-/knowledge_base/r/bundle-support-plugin}{Bundle
Support plugin} version in your root \texttt{pom.xml} file.

\subsection{Removing Your Project's Build Dependency
Versions}\label{removing-your-projects-build-dependency-versions}

\noindent\hrulefill

\textbf{Note:} This step only applies to Gradle-based workspaces since
the target platform feature is only available for Gradle projects at
this time.

\noindent\hrulefill

Since your workspace is leveraging the target platform feature, there is
no need to set your plugin's dependency versions in its
\texttt{build.gradle} file. This is because the target platform version
you set already defines the artifact versions your project uses.
Therefore, if dependency versions are present in any of your projects'
\texttt{build.gradle} files, you must remove them.

Initiate this step to remove your dependency versions from your
project's \texttt{build.gradle} file

As an example of what a \texttt{build.gradle}'s \texttt{dependencies}
block should look like, see the below snippet:

\begin{verbatim}
dependencies {
    compileOnly group: "com.liferay.portal", name: "com.liferay.portal.kernel"
    compileOnly group: "com.liferay.portal", name: "com.liferay.util.taglib"
    compileOnly group: "javax.portlet", name: "portlet-api"
    compileOnly group: "javax.servlet", name: "javax.servlet-api"
    compileOnly group: "jstl", name: "jstl"
    compileOnly group: "org.osgi", name: "osgi.cmpn"
}
\end{verbatim}

If you have not set the target platform feature in your workspace, see
the
\href{/docs/7-0/tutorials/-/knowledge_base/t/managing-the-target-platform-for-liferay-workspace}{Managing
the Target Platform} article for more information.

Great! You've successfully upgraded your build dependencies! You likely
have compile errors in your project; this is because your dependencies
may have changed. You'll learn how to update that and more next.

\section{Fixing Upgrade Problems}\label{fixing-upgrade-problems}

Now that your development environment build configuration is settled,
you can start upgrading your project(s). The two most common upgrade
problems are

\begin{itemize}
\tightlist
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/resolving-a-plugins-dependencies}{Broken
  project dependencies}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/resolving-breaking-changes}{Breaking
  changes}
\end{itemize}

Visit these upgrade problem tutorials for tips on how to fix them.

This tutorial is heavily focused on the Liferay Upgrade Planner. If
you're upgrading your code manually, continue to the listed tutorials
above to fix your code upgrade problems.

You'll begin auto-correcting upgrade problems first.

\subsection{Auto-Correcting Upgrade
Problems}\label{auto-correcting-upgrade-problems}

Initiate this step to auto-correct straightforward updates like

\begin{itemize}
\tightlist
\item
  package imports
\item
  JSP tag names
\item
  Liferay descriptor versions
\item
  XML descriptor content
\item
  etc.
\end{itemize}

If you choose to preview the auto-correct upgrade problems first, you
can view them in the Project Explorer under the \emph{Liferay Upgrade
Problems} dropdown. If you click one of the upgrade problems listed with
the preview, you're offered documentation in the \emph{Liferay Upgrade
Plan Info} window on the proposed change.

Once you've performed this step, the result list is removed.

\subsection{Finding Upgrade Problems}\label{finding-upgrade-problems}

Initiating this step finds the upgrade problems that were not eligible
for auto-correction. The problems are listed under the \emph{Liferay
Upgrade Problems} dropdown. If you click one of the upgrade problems
listed with the preview, you're offered documentation in the
\emph{Liferay Upgrade Plan Info} window on the proposed change.

These upgrade problems are available in the
\href{/docs/7-0/tutorials/-/knowledge_base/t/resolving-breaking-changes}{breaking
changes} for the version upgrade you're performing.

The next step is resolving the reported upgrade problems.

\subsection{Resolving Upgrade
Problems}\label{resolving-upgrade-problems}

Now that the upgrade problems have been located, you must resolve them.
As you select each upgrade problem, the documentation for how to adapt
your code is displayed in the \emph{Liferay Upgrade Plan Info} window.

For each upgrade problem node, you're also given the version the upgrade
problem applies to (e.g., when upgrading to Liferay DXP 7.2 from Liferay
Portal 6.2, you could have upgrade problems from the 7.0, 7.1, or 7.2
upgrade). As you step through the reported problems, mark them as
resolved/skipped using the context menu. You can right-click on the
problem in the Project Explorer and choose from four options:

\begin{itemize}
\tightlist
\item
  Mark done
\item
  Mark undone
\item
  Ignore
\item
  Ignore all problems of this type
\end{itemize}

Leave this step marked as \emph{Incomplete} until you have resolved all
upgrade problems accordingly.

\subsection{Removing Problem Markers}\label{removing-problem-markers}

After resolving all the reported upgrade problems, you must remove all
previously found markers because, in most cases, the line number and
other accompanying marker information are out of date and must be
removed before continuing. Initiate this step to remove all the problem
markers.

Great! You've fixed all the upgrade problems that could be automatically
detected by the Upgrade Planner. Next, you'll take a deeper look at
resolving project dependency errors.

\section{Resolving a Plugin's
Dependencies}\label{resolving-a-plugins-dependencies}

Now that you've imported your plugin project to Liferay @ide@, you
probably see compile errors for some of the Liferay classes it uses.
These classes are listed as undefined classes or unresolved symbols
because they've been moved, renamed, or removed. As a part of
modularization in Liferay DXP, many of these classes reside in new
modules.

You must resolve all of these Liferay classes for your plugin. Some of
the class changes are quick and easy to fix. Changes involving the new
modules require more effort to resolve, but doing so is still
straightforward.

Liferay class changes and required adaptations are described here:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{Class moved to a package that's in the classpath}: This change
  is common and easy to fix. Since the module is already on your
  classpath, you need only update the class import. You can do this by
  using the Liferay Code Upgrade Tool or by organizing imports in @ide@.
  The Upgrade Planner reports each moved class for you to address one by
  one. Organizing imports in @ide@ automatically resolves multiple
  classes at once.

  It's typically faster to resolve moved classes using the mentioned
  Eclipse feature. Since Liferay @ide@ is based on Eclipse, you can
  generate imports of classes in your classpath with the \emph{Organize
  Imports} keyboard sequence \emph{Ctrl-Shift-o}. Comment out or remove
  any imports marked as errors, then press \emph{Ctrl-Shift-o}. If
  there's only one match for the import, @ide@ automatically generates
  its import statement. Otherwise, a wizard appears that lets you select
  the correct import.
\item
  \textbf{Class moved to a module that's \emph{not} in the classpath}:
  You must resolve the new module as a dependency for your project. This
  requires identifying the module and specifying your project's
  dependency on it.
\item
  \textbf{Class replaced or removed}: The class has been replaced by
  another class or removed from the product. The Upgrade Planner
  (discussed later) explains what happened to the class, how to handle
  the change, and why the change was made.
\end{enumerate}

Resolving a class that's moved within your classpath is straightforward.
Consider resolving such classes first. The remainder of this tutorial
explains how to resolve the last two cases and starts with configuring
your plugin project to declare the modules it needs.

\subsection{Identifying Module
Dependencies}\label{identifying-module-dependencies}

Before 7.0, all the platform APIs were in \texttt{portal-service.jar}.
Many of these APIs are now in independent modules. Modularization has
resulted in many benefits, as described in the article
\href{/docs/7-0/tutorials/-/knowledge_base/t/benefits-of-liferay-7-for-liferay-6-developers\#modular-development-paradigm}{Benefits
of 7.0 for Liferay Portal 6 Developers}. One such advantage is that
these API modules can evolve separately from the platform kernel. They
also simplify future upgrades. For example, instead of having to check
all of Liferay's APIs, each module's \href{http://semver.org}{Semantic
Versioning} indicates whether the module contains any
backwards-incompatible changes. You need only adapt your code to such
modules (if any).

As part of the modularization, \texttt{portal-service.jar} has been
renamed appropriately to \texttt{portal-kernel.jar}, as it continues to
hold the portal kernel's APIs.

\begin{figure}
\centering
\includegraphics{./images/from-liferay-6-portal-apis-before-after.png}
\caption{Liferay refactored the portal-service JAR for 7.0. Application
APIs now exist in their own modules, and the portal-service JAR is now
\emph{portal-kernel}.}
\end{figure}

Each app module consists of a set of classes that are highly cohesive
and have a specific purpose, such as providing the app's API,
implementation, or UI. The app modules are therefore much easier to
understand. Next, you'll track down the modules that now hold the
classes referenced by your plugin.

The reference article
\href{/docs/7-0/reference/-/knowledge_base/r/classes-moved-from-portal-service-jar}{Classes
Moved from \texttt{portal-service.jar}} contains a table that maps each
class moved from \texttt{portal-service.jar} to its new module. The
table includes each class's new package and symbolic name (artifact ID).
You'll use this information to configure your plugin's dependencies on
these modules.

Your plugin might reference classes that are in Liferay utility modules
such as \texttt{util-java}, \texttt{util-bridges}, \texttt{util-taglib},
or \texttt{util-slf4j}.

The following table shows each Liferay utility module's symbolic name.

\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
\textbf{Liferay Utility} & ~\textbf{Symbolic Name (Artifact ID)} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
util-bridges & \texttt{com.liferay.util.bridges} \\
util-java & \texttt{com.liferay.util.java} \\
util-slf4j & \texttt{com.liferay.util.slf4j} \\
util-taglib & \texttt{com.liferay.util.taglib} \\
\end{longtable}

You can use Liferay DXP's
\href{/docs/7-0/tutorials/-/knowledge_base/t/configuring-dependencies\#finding-liferay-app-and-independent-artifacts}{App
Manager},
\href{/docs/7-0/reference/-/knowledge_base/r/using-the-felix-gogo-shell}{Felix
Gogo Shell}, or
\href{/docs/7-0/tutorials/-/knowledge_base/t/configuring-dependencies\#finding-core-artifacts}{module
JAR file manifests} to find versions of modules deployed on your Liferay
DXP instance.

\noindent\hrulefill

\textbf{Note:} Previous versions of the Plugins SDK made
\texttt{portal-service.jar} available to projects. The 7.0 Plugins SDK
similarly makes \texttt{portal-kernel.jar} available. If you're using a
Liferay DXP bundle (Liferay DXP pre-installed on an app server), the
Liferay utility modules are already on your classpath. If you manually
installed Liferay DXP on your app server, the Liferay utility modules
might not be on your classpath. If a utility module you need is not on
your classpath, note its symbolic name (artifact ID) and version.

\noindent\hrulefill

\subsection{Resolving Dependencies}\label{resolving-dependencies}

Now that you have the module artifact IDs and versions, you can make the
modules available to your plugin project. The modules your plugin uses
must be available to it at compile time and run time. Here are two
options for resolving module dependencies in your traditional plugin
project:

\hyperref[using-a-dependency-management-tool]{\textbf{Option 1: Use a
dependency management tool}}

\hyperref[managing-dependencies-manually]{\textbf{Option 2: Manage
dependencies manually}}

The next sections explain and demonstrate these options.

\subsubsection{Using a Dependency Management
Tool}\label{using-a-dependency-management-tool}

Dependency management tools such as
\href{http://ant.apache.org/ivy/}{Ant/Ivy},
\href{/docs/7-0/tutorials/-/knowledge_base/t/maven}{Maven}, and
\href{https://gradle.org/}{Gradle} facilitate acquiring Java artifacts
that provide packages your plugins need. They can download artifacts
from public repositories or from internal repositories you configure as
a proxies. From internal repositories you can audit dependencies.

\noindent\hrulefill

The following links provide proxy details:

\begin{itemize}
\tightlist
\item
  \href{http://ant.apache.org/ivy/}{Ant/Ivy} - See documentation on
  proxy configuration, the \texttt{Setproxy} task, and
  \href{http://ant.apache.org/ivy/history/latest-milestone/settings/resolvers.html}{resolvers}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/creating-a-maven-repository}{Maven}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/setting-proxy-requirements-for-liferay-workspace}{Liferay
  Workspace (Gradle)}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/setting-proxy-requirements-for-liferay-ide}{Setting
  proxies in Liferay @ide@}
\end{itemize}

\noindent\hrulefill

The Liferay Plugins SDK provides an Ant/Ivy infrastructure. You declare
your dependencies in an \texttt{ivy.xml} file in your plugin project's
root folder. The Plugins SDK's Ant tasks leverage the \texttt{ivy.xml}
file and the Plugins SDK's Ivy scripts to download the specified modules
and their dependencies and make them available to your plugin.

\noindent\hrulefill

\textbf{Note}: You can use Gradle or Maven in place of Ivy for
dependency management, but this isn't in this tutorial's scope.
Liferay's \href{/docs/7-0/tutorials/-/knowledge_base/t/maven}{Maven} and
\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-workspace}{Liferay
Workspace} tutorials demonstrate using these tools.

Additionally, Liferay Workspace provides a command for migrating Ant/Ivy
projects to Gradle-based Liferay Workspace projects. See the tutorial
\href{/docs/7-0/tutorials/-/knowledge_base/t/migrating-traditional-plugins-to-workspace-web-applications}{Migrating
Traditional Plugins to Workspace Web Applications}.

\noindent\hrulefill

Here's an example dependency element for the Liferay Journal API module,
version 2.0.1:

\begin{verbatim}
<dependency name="com.liferay.journal.api" org="com.liferay" rev="2.0.1" />
\end{verbatim}

Each dependency includes the module's name (\texttt{name}), organization
(\texttt{org}), and revision number (\texttt{rev}). The
\href{/docs/7-0/tutorials/-/knowledge_base/t/configuring-dependencies}{Configuring
Dependencies} tutorial explains how to determine the module's
organization (\texttt{org}).

At compile time, Ivy downloads the dependency JAR files to a cache
folder so you can compile against them.

At deployment, Liferay DXP's WAB Generator creates an OSGi Web
Application Bundle (WAB) for the plugin. The WAB generator detects the
Java packages your plugin uses and declares dependencies on them. Your
plugin can use the packages once a registered OSGi service provides
them.

If your project doesn't already have an \texttt{ivy.xml} file, you can
get one by creating a new plugin project in Liferay @ide@ and copying
the \texttt{ivy.xml} file it generates.

Here's an example of an \texttt{ivy.xml} file from the Liferay Portal
6.2 Knowledge Base portlet:

\begin{verbatim}
<?xml version="1.0"?>

<ivy-module
    version="2.0"
    xmlns:m2="http://ant.apache.org/ivy/maven"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:noNamespaceSchemaLocation="http://ant.apache.org/ivy/schemas/ivy.xsd"
>
    <info module="knowledge-base-portlet" organisation="com.liferay">
        <extends extendType="configurations,description,info" location="${sdk.dir}/ivy.xml" module="com.liferay.sdk" organisation="com.liferay" revision="latest.integration" />
    </info>

    <dependencies defaultconf="default">
        <dependency org="com.liferay" name="com.liferay.markdown.converter" rev="1.0.2" />
    </dependencies>
</ivy-module>
\end{verbatim}

The Plugins SDK works with project Ivy files to store artifacts and make
them accessible to your plugin projects.

If you don't want to use Ivy or some other dependency management
framework, you can store dependency JARs within your plugin project
manually. You'll learn about this next.

\subsubsection{Managing Dependencies
Manually}\label{managing-dependencies-manually}

Plugins rely on their dependencies' availability at compile time and run
time. To compile your plugin, you must make sure the dependencies are
available in the plugin's \texttt{WEB-INF/lib} folder. To run your
plugin, the container must be able to find them: either 1) the
dependency Java packages must already be active in Liferay DXP's OSGi
framework or 2) the dependency JARs must be included in the WAB
generated for the plugin. Your plugin can use both the JARs it currently
has and the packages Liferay DXP exports.

\paragraph{Using Packages Liferay DXP
Exports}\label{using-packages-liferay-dxp-exports}

The Plugins SDK for Liferay Portal 6 provided a way to compile against
JARs it had. You'd specify these JARs in the
\texttt{portal-dependency-jars} property in your
\href{@platform-ref@/7.0-latest/propertiesdoc/liferay-plugin-package_7_0_0.properties.html}{\texttt{liferay-plugin-package.properties}}
file. On seeing a plugin's \texttt{portal-dependency-jars} list, the
Liferay Plugins SDK copied the JARs into the plugin's
\texttt{WEB-INF/lib}. The Plugins SDK refrained from adding the JARs to
the plugin WAR. This kept the WARs small for deploying faster. It was
especially useful for deploying WARs remotely or to cluster nodes.

In 7.0, the \texttt{portal-dependency-jars} property is deprecated and
behaves differently from previous versions. Because importing and
exporting Java packages has replaced wholesale use of JARs, modules and
WABs can import packages without concerning themselves with JARs.
\href{/docs/7-0/reference/-/knowledge_base/r/third-party-packages-portal-exports}{Liferay
DXP exports many third party packages for plugins can use}.

If you're still using the \texttt{portal-dependency-jars} property, you
may run into one of the scenarios below. Follow the instructions below
the scenario to fix the issue.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{I've specified a JAR, but in 7.0 none of the classes are
  available to my plugin.}

  Some JARs that Liferay Portal 6.2 used were removed in 7.0. If you
  specify them in your \texttt{portal-dependency-jars}, Liferay DXP
  can't provide them. If you still need them, remove them from the
  \texttt{portal-dependency-jars} property and add the JARs you need to
  your plugin's \texttt{WEB-INF/lib} folder.
\item
  \textbf{I've specified JARs, and 7.0 also exports all the JAR's
  packages my plugin imports}

  Keep the JAR in your \texttt{portal-dependency-jars} list. The Plugins
  SDK copies the JAR to your plugin's \texttt{WEB-INF/lib} folder at
  compile time but refrains from adding the JAR to the plugin WAB. The
  WAB generated for the plugin imports the packages from a registered
  provider at run time.
\item
  \textbf{7.0 provides the JAR but doesn't export a package my plugin
  imports}

  Keep the JAR in your \texttt{portal-dependency-jars} property. The
  Plugins SDK copies the JAR to your plugin's \texttt{WEB-INF/lib}
  folder at compile time and adds the JAR to the plugin WAB at
  deployment.
\end{enumerate}

\paragraph{Understanding Excluded
JARs}\label{understanding-excluded-jars}

\href{http://docs.liferay.com/ce/portal/7.0-latest/propertiesdoc/portal.properties.html\#Module\%20Framework}{Portal
property \texttt{module.framework.web.generator.excluded.paths}}
declares JARs that are stripped from all Liferay DXP generated WABs.
These JARs are excluded from WABs because Liferay DXP provides them
already. All JARs listed for this property are excluded from the WABs,
even if the plugins listed the JAR in their
\texttt{portal-dependency-jars} property.

If your plugin requires different versions of the packages Liferay DXP
exports, you must include them in JARs named differently from the ones
\texttt{module.framework.web.generator.excluded.paths} excludes.

For example, Liferay DXP's
\href{https://github.com/liferay/liferay-portal/blob/7.0.3-ga4/modules/core/portal-bootstrap/system.packages.extra.bnd}{\texttt{system.packages.extra.bnd}
file} exports Spring Framework version 4.1.9 packages:

\begin{verbatim}
Export-Package:\
    ...
    org.springframework.*;version='4.1.9',\
    ...
\end{verbatim}

Liferay DXP uses the
\texttt{module.framework.web.generator.excluded.paths} portal property
to exclude their JARs.

\begin{verbatim}
module.framework.web.generator.excluded.paths=\
    ...
    WEB-INF/lib/spring-aop.jar,\
    WEB-INF/lib/spring-aspects.jar,\
    WEB-INF/lib/spring-beans.jar,\
    WEB-INF/lib/spring-context.jar,\
    WEB-INF/lib/spring-context-support.jar,\
    WEB-INF/lib/spring-core.jar,\
    WEB-INF/lib/spring-expression.jar,\
    WEB-INF/lib/spring-jdbc.jar,\
    WEB-INF/lib/spring-jms.jar,\
    WEB-INF/lib/spring-orm.jar,\
    WEB-INF/lib/spring-oxm.jar,\
    WEB-INF/lib/spring-tx.jar,\
    WEB-INF/lib/spring-web.jar,\
    WEB-INF/lib/spring-webmvc.jar,\
    WEB-INF/lib/spring-webmvc-portlet.jar,\
    ...
\end{verbatim}

To use a different Spring Framework version in your WAB, you must name
the corresponding Spring Framework JARs differently from the
glob-patterned JARs
\texttt{module.framework.web.generator.excluded.paths} lists.

For example, to use Spring Framework version 3.0.7's Spring AOP JAR,
include it in your plugin's \texttt{WEB-INF/lib} but name it something
other than \texttt{spring-aop.jar}. Adding the version to the JAR name
(i.e., \texttt{spring-aop-3.0.7.RELEASE.jar}) differentiates it from the
excluded JAR and prevents it from being stripped from the WAB.

\paragraph{Using Packages Liferay DXP Doesn't
Export}\label{using-packages-liferay-dxp-doesnt-export}

You must download and install to your plugin's \texttt{WEB-INF/lib}
folder JARs that provide packages Liferay DXP doesn't export that your
plugin requires.

Follow these steps to do this:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Go to Maven Central at \url{https://search.maven.org/}.
\item
  Search for the module by its artifact ID and group ID.
\item
  Navigate the search results to find the version of the module you
  want.
\item
  Click the \emph{jar} link to download the module's JAR file.
\item
  Add the JAR to your project's \texttt{WEB-INF/lib} folder.
\end{enumerate}

\begin{figure}
\centering
\includegraphics{./images/resolving-plugin-dependencies-using-maven-central.png}
\caption{After searching Maven Central, download an artifact's JAR file
by clicking the \emph{jar} link.}
\end{figure}

As you manage module JARs, make sure \textbf{not} to deploy any OSGi
framework JARs or Liferay module JARs (e.g.,
\texttt{com.liferay.journal.api.jar}). If you deploy these, they'll
conflict with the JARs already installed in the OSGi framework.
Identical JARs in two different classloaders can cause class cast
exceptions. The easiest way to exclude such JARs from your plugin's
deployment is to list them in a \texttt{deploy-excludes} property in
your plugin's \texttt{liferay-plugin-package.properties}. You must
otherwise remove the JARs manually from the plugin WAR file. To exclude
JARs in your plugin's \texttt{liferay-plugin-package.properties} file,
add an entry like the one below, replacing the square-bracketed items
with the names of JAR files to exclude:

\begin{verbatim}
deploy-excludes=\
    **/WEB-INF/lib/[module-artifact.jar],\
    **/WEB-INF/lib/[another-module-artifact.jar]
\end{verbatim}

For example, here's an example property that excludes the OSGi framework
JAR \texttt{osgi.core.jar} and the Liferay app module JAR
\texttt{com.liferay.journal.api.jar}:

\begin{verbatim}
deploy-excludes=\
    **/WEB-INF/lib/com.liferay.portal.journal.api.jar,\
    **/WEB-INF/lib/org.osgi.core.jar
\end{verbatim}

How do you know what modules are already installed in Liferay DXP? If
your Liferay DXP instance has a particular Liferay app suite installed,
then don't deploy module JARs you know are in that app suite. For
example, if the Web Experience Management App Suite is already installed
(which is the case for a Liferay DXP bundle), then don't deploy Web
Content module JARs such as \texttt{com.liferay.journal.api.jar}.
Searching for a module in Liferay DXP's
\href{/docs/7-0/user/-/knowledge_base/u/managing-and-configuring-apps}{App
Manager} is a sure-fire way to verify existing module installations.

\subsection{Using Liferay DXP's Tag Library
Definitions}\label{using-liferay-dxps-tag-library-definitions}

Before adding Tag Library Definition (TLD) files to your plugin, check
Liferay DXP for them. The Liferay DXP web application folder
\texttt{WEB-INF/TLD} has over twenty TLDs, including Struts TLDs.

You can use Liferay DXP's TLDs in a traditional plugin by adding them to
the \texttt{portal-dependency-tlds} property in the plugin's
\texttt{liferay-plugin-package.properties} file.

Way to go! You've fixed class imports and resolved dependencies on all
the modules and tag libraries your plugin uses.

\subsection{Related Topics}\label{related-topics-2}

\href{/docs/7-0/tutorials/-/knowledge_base/t/importing-packages}{Importing
Packages}

\href{/docs/7-0/tutorials/-/knowledge_base/t/exporting-packages}{Exporting
Packages}

\href{/docs/7-0/reference/-/knowledge_base/r/development-reference}{Development
Reference}

\href{/docs/7-0/tutorials/-/knowledge_base/t/modularizing-an-existing-portlet}{Modularizing
an Existing Portlet}

\href{/docs/7-0/tutorials/-/knowledge_base/t/invoking-local-services}{Invoking
Local Services}

\href{/docs/7-0/tutorials/-/knowledge_base/t/finding-and-invoking-liferay-services}{Finding
and Invoking Liferay Services}

\href{/docs/7-0/tutorials/-/knowledge_base/t/tooling}{Tooling}

\section{Resolving Breaking Changes}\label{resolving-breaking-changes}

Liferay goes to great lengths to maintain backwards compatibility.
Sometimes, breaking changes are necessary to improve Liferay DXP. There
may be cases where breaking changes affect your code upgrade process and
must be resolved. A breaking change can include

\begin{itemize}
\tightlist
\item
  Functionality that is removed or replaced
\item
  API incompatibilities: Changes to public Java or JavaScript APIs
\item
  Changes to context variables available to templates
\item
  Changes in CSS classes available to Liferay themes and portlets
\item
  Configuration changes: Changes in configuration files, like
  \texttt{portal.properties}, \texttt{system.properties}, etc.
\item
  Execution requirements: Java version, J2EE Version, browser versions,
  etc.
\item
  Deprecations or end of support: For example, warning that a certain
  feature or API will be dropped in an upcoming version.
\item
  Recommendations: For example, recommending using a newly introduced
  API that replaces an old API, in spite of the old API being kept in
  Liferay Portal for backwards compatibility.
\end{itemize}

Liferay provides a list of breaking changes for every major release to
ensure you can easily adapt your code during the upgrade process.

\begin{itemize}
\tightlist
\item
  \href{/docs/7-0/reference/-/knowledge_base/r/breaking-changes}{7.0
  Breaking Changes}
\item
  \href{/docs/7-1/reference/-/knowledge_base/r/breaking-changes}{Liferay
  DXP 7.1 Breaking Changes}
\item
  \href{/docs/7-2/reference/-/knowledge_base/r/breaking-changes}{Liferay
  DXP 7.2 Breaking Changes}
\end{itemize}

The easiest way to resolve breaking changes is by using the
\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-upgrade-planner}{Liferay
Upgrade Planner}. It automatically finds all documented breaking changes
and can automatically resolve some of them on its own.

If you're resolving breaking changes manually, make sure to investigate
each breaking change document if you're upgrading code across multiple
versions. For example, if you're upgrading from Liferay Portal 6.2 to
7.0, you must resolve all the breaking changes listed in the three
documents listed above.

Now that you've resolved your breaking changes, you'll learn how to
upgrade service builder services next.

\chapter{Upgrading Hook Plugins}\label{upgrading-hook-plugins}

Liferay DXP has more extension points than ever, and connecting existing
hook plugins to them takes very few steps. In most cases, after you
upgrade your hook using the Liferay Upgrade Planner, it's ready to run
on Liferay DXP. The following tutorials show you how to upgrade each
type of hook plugin.

\begin{itemize}
\tightlist
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-customization-modules}{Override/Extension
  Modules}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-core-jsp-hooks}{Core
  JSP Hooks}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-app-jsp-hook-plugins}{App
  JSP Hooks}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-service-wrappers}{Service
  Wrapper Hooks}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-core-language-key-hooks}{Core
  Language Key Hooks}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-portlet-language-key-hooks}{Portlet
  Language Key Hooks}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-model-listener-hooks}{Model
  Listener Hooks}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-servlet-filter-hooks}{Servlet
  Filter Hooks}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-portal-property-and-event-action-hooks}{Portal
  Property and Event Action Hooks}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/converting-strutsactionwrappers-to-mvccommands}{Struts
  Action Hooks}
\end{itemize}

Continue on to get started!

\section{Upgrading Customization
Modules}\label{upgrading-customization-modules}

Customization modules include any module extension or override used to
customize another module. For examples of these types of modules, visit
the
\href{https://github.com/liferay/liferay-blade-samples/tree/7.0/liferay-workspace/extensions}{\texttt{extensions}}
and
\href{https://github.com/liferay/liferay-blade-samples/tree/7.0/liferay-workspace/overrides}{\texttt{overrides}}
sample projects.

Getting a customization module running on 7.0 takes two steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Adapt your code to 7.0's API using the Liferay Upgrade Planner. When
  you ran the planner's \emph{Fix Upgrade Problems} step, many of the
  existing issues were autocorrected or flagged. For any remaining
  errors, consult the
  \href{/docs/7-0/tutorials/-/knowledge_base/t/resolving-a-plugins-dependencies}{Resolving
  a Plugin's Dependencies} article.
\item
  Deploy your module.
\end{enumerate}

\noindent\hrulefill

\textbf{Note:} A fragment was a common customization module in past
versions of Liferay DXP. Fragments are no longer recommended; you should
upgrade a fragment to a dynamic include or portlet filter. For more
information on recommended ways of customizing JSPs in 7.0, see the
\href{/docs/7-0/tutorials/-/knowledge_base/t/overriding-jsps}{Customizing
JSPs} section.

\noindent\hrulefill

Great! Your customization module is upgraded for 7.0!

\section{Upgrading Core JSP Hooks}\label{upgrading-core-jsp-hooks}

Getting a core JSP hook running on 7.0 takes two steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Adapt your code to 7.0's API using the Liferay Upgrade Planner. When
  you ran the planner's \emph{Fix Upgrade Problems} step, many of the
  existing issues were autocorrected or flagged. For any remaining
  errors, consult the
  \href{/docs/7-0/tutorials/-/knowledge_base/t/resolving-a-plugins-dependencies}{Resolving
  a Plugin's Dependencies} article.
\item
  Deploy your hook plugin.
\end{enumerate}

Liferay DXP's Plugin Compatibility Layer converts the plugin WAR to a
Web Application Bundle (WAB) and installs it to Liferay's OSGi Runtime.

It's just that easy!

\subsection{Related Topics}\label{related-topics-3}

\href{/docs/7-0/tutorials/-/knowledge_base/t/overriding-core-jsps}{JSP
Overrides Using Custom JSP Bags}

\href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-app-jsp-hook-plugins}{Upgrading
App JSP Hooks}

\href{/docs/7-0/tutorials/-/knowledge_base/t/resolving-a-plugins-dependencies}{Resolving
a Plugin's Dependencies}

\href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-the-liferay-maven-build}{Upgrading
the Liferay Maven Build}

\section{Upgrading App JSP Hooks}\label{upgrading-app-jsp-hooks}

JSPs in OSGi modules are customized using module fragments. The module
fragment attaches to the host module to alter the JSPs. To the OSGi
runtime, the fragment is part of the host module. Section 3.14 of the
\href{https://www.osgi.org/developer/downloads/release-6/}{OSGi
Alliance's core specification document} explains module fragments in
detail. This tutorial shows you how to upgrade your app JSP hooks to
7.0.

Liferay @ide@'s Upgrade Planner's
\href{/docs/7-0/tutorials/-/knowledge_base/t/fixing-upgrade-problems}{\emph{Fixing
Upgrade Problems} step} generates module fragments from app JSP hook
plugins. The tool creates module fragments in the same folder as your
Plugins SDK root if your hook is in a Plugins SDK or in the
\texttt{{[}liferay\_workspace{]}/modules} folder if your hook is in a
Liferay Workspace.

Module fragments follow this name convention:
\texttt{{[}plugin\_name{]}-{[}app{]}-fragment}. For example, if the
plugin's name is \texttt{app-jsp-hook} and it modifies a JSP in the
Blogs app, the Upgrade Planner generates a module fragment named
\texttt{app-jsp-hook-blogs-fragment}.

Here are the steps for upgrading app JSP hook plugins:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \hyperref[declare-the-fragment-host]{Declare the Fragment Host}
\item
  \hyperref[update-the-jsp]{Update the JSP}
\end{enumerate}

\subsection{Declare the Fragment Host}\label{declare-the-fragment-host}

The module fragment's \texttt{bnd.bnd} file must specify an OSGi header
\texttt{Fragment-Host} set to the host module name and version.

If the host module belongs to one of Liferay DXP's app suites, the Code
Upgrade Tool generates a \texttt{bnd.bnd} file that specifies an
appropriate \texttt{Fragment-Host} header automatically.

For example, here's a \texttt{Fragment-Host} that attaches a module
fragment to the Blogs Web module.

\begin{verbatim}
Fragment-Host: com.liferay.blogs.web;bundle-version="1.1.9"
\end{verbatim}

Updating the JSP is straightforward too.

\subsection{Update the JSP}\label{update-the-jsp}

The Upgrade Planner creates a module fragment that contains an upgraded
version of your custom app JSP.

The following table shows the old and new JSP paths.

Liferay Portal version \textbar{} JSP File Path \textbar{} \textbf{6.2}
\textbar{}
\texttt{docroot/META-INF/custom\_jsps/html/portlet/{[}jsp\_file\_path{]}}
\textbf{7.0} \textbar{}
\texttt{src/main/resources/META-INF/resources/{[}jsp\_file\_path{]}}

For example, the Upgrade Planner generates a customized version of the
Blogs app's \texttt{init-ext.jsp} file here:

\begin{verbatim}
src/main/resources/META-INF/resources/blogs/init-ext.jsp
\end{verbatim}

The tool's
\href{/docs/7-0/tutorials/-/knowledge_base/t/fixing-upgrade-problems}{\emph{Fixing
Upgrade Problems} step} lets you compare custom JSPs with originals:

\begin{itemize}
\tightlist
\item
  Compare your custom 6.2 JSP with the original 6.2 JSP.
\item
  Compare your custom 7.0 JSP with your custom 6.2 JSP.
\end{itemize}

\begin{figure}
\centering
\includegraphics{./images/upgrading-app-jsp-hook-convert-custom-jsp-hook.png}
\caption{The Upgrade Planner lets you compare custom JSPs with
originals.}
\end{figure}

Make any additional needed changes in your 7.0 custom JSP. Then
\href{/docs/7-0/tutorials/-/knowledge_base/t/starting-module-development\#building-and-deploying-a-module}{deploy}
your module fragment. This stops the host module momentarily, attaches
the fragment to the host, and then restarts the host module. The console
output reflects this process.

Here's output from deploying a module fragment that attaches to the
Blogs web module.

\begin{verbatim}
19:23:11,740 INFO  [Refresh Thread: Equinox Container: 00ce6547-2355-0017-1884-846599e789c4][BundleStartStopLogger:38] STOPPED com.liferay.blogs.web_1.1.9 [535]
19:23:12,910 INFO  [Refresh Thread: Equinox Container: 00ce6547-2355-0017-1884-846599e789c4][BundleStartStopLogger:35] STARTED com.liferay.blogs.web_1.1.9 [535]
\end{verbatim}

Your custom JSP is live.

\subsection{Related Topics}\label{related-topics-4}

\href{/docs/7-0/tutorials/-/knowledge_base/t/overriding-a-modules-jsps}{JSP
Overrides Using OSGi Fragments}

\href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-core-jsp-hooks}{Upgrading
Core JSP Hooks}

\href{/docs/7-0/tutorials/-/knowledge_base/t/resolving-a-plugins-dependencies}{Resolving
a Plugin's Dependencies}

\href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-the-liferay-maven-build}{Upgrading
the Liferay Maven Build}

\section{Upgrading Service Wrappers}\label{upgrading-service-wrappers}

Upgrading traditional
\href{/docs/6-2/tutorials/-/knowledge_base/t/overriding-a-portal-service-using-a-hook}{service
wrapper hook plugins} to 7.0 is quick and easy.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Adapt your code to 7.0's API using the Liferay Upgrade Planner. When
  you ran the planner's \emph{Fix Upgrade Problems} step, many of the
  existing issues were autocorrected or flagged. For any remaining
  errors, consult the
  \href{/docs/7-0/tutorials/-/knowledge_base/t/resolving-a-plugins-dependencies}{Resolving
  a Plugin's Dependencies} article.
\item
  Deploy the plugin.
\end{enumerate}

Liferay DXP's Plugin Compatibility Layer converts the plugin WAR to a
Web Application Bundle (WAB) and installs it to Liferay's OSGi Runtime.

\subsection{Related Articles}\label{related-articles-1}

\href{/docs/7-0/tutorials/-/knowledge_base/t/customizing-liferay-services-service-wrappers}{Overriding
Liferay Services (Service Wrappers)}

\href{/docs/7-0/tutorials/-/knowledge_base/t/resolving-a-plugins-dependencies}{Resolving
a Plugin's Dependencies}

\href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-the-liferay-maven-build}{Upgrading
the Liferay Maven Build}

\section{Upgrading Core Language Key
Hooks}\label{upgrading-core-language-key-hooks}

Here are the steps for upgrading a core language key hook to 7.0.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a new module based on the Blade sample \texttt{resource-bundle}
  in
  \href{https://github.com/liferay/liferay-blade-samples/tree/7.0/gradle/extensions/resource-bundle}{Gradle}
  or
  \href{https://github.com/liferay/liferay-blade-samples/tree/7.0/maven/extensions/resource-bundle}{Maven}.

  Here are the main parts of the module folder structure:

  \begin{itemize}
  \tightlist
  \item
    \texttt{src/main/java/{[}resource\ bundle\ path{]}} → Custom
    resource bundle class goes here
  \item
    \texttt{src/main/resources/content}

    \begin{itemize}
    \tightlist
    \item
      \texttt{Language.properties}
    \item
      \texttt{Language\_xx.properties}
    \item
      \ldots{}
    \end{itemize}
  \end{itemize}
\item
  Copy all your plugin's language properties files into the module
  folder \texttt{src/main/resources/content/}.
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/overriding-language-keys\#create-a-resource-bundle-service-component}{Create
  a resource bundle loader}.
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/starting-module-development\#building-and-deploying-a-module}{Deploy
  your module}.
\end{enumerate}

Your core language key customizations are deployed to 7.0.

\subsection{Related Topics}\label{related-topics-5}

\href{/docs/7-0/tutorials/-/knowledge_base/t/overriding-language-keys\#modifying-global-language-keys}{Overriding
Global Language Keys}

\href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-portlet-language-key-hooks}{Upgrading
Portlet Language Key Hooks}

\href{/docs/7-0/tutorials/-/knowledge_base/t/resolving-a-plugins-dependencies}{Resolving
a Plugin's Dependencies}

\href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-the-liferay-maven-build}{Upgrading
the Liferay Maven Build}

\section{Upgrading Portlet Language Key
Hooks}\label{upgrading-portlet-language-key-hooks}

You can upgrade your portlet language key hooks to 7.0 by following
these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a new module based on the Blade sample \texttt{resource-bundle}
  (\href{https://github.com/liferay/liferay-blade-samples/tree/7.0/gradle/extensions/resource-bundle}{Gradle}
  or
  \href{https://github.com/liferay/liferay-blade-samples/tree/7.0/maven/extensions/resource-bundle}{Maven}
  project).

  Here are the module folder structure's main files:

  \begin{itemize}
  \tightlist
  \item
    \texttt{src/main/java/{[}resource\ bundle\ path{]}} →
    \href{@platform-ref@/7.0-latest/javadocs/portal-kernel/}{\texttt{ResourceBundleLoader}
    extension} goes here
  \item
    \texttt{src/main/resources/content}

    \begin{itemize}
    \tightlist
    \item
      \texttt{Language.properties}
    \item
      \texttt{Language\_xx.properties}
    \item
      \ldots{}
    \end{itemize}
  \end{itemize}
\item
  Copy your language properties files into module folder
  \texttt{src/main/resources/content/}.
\item
  In your \texttt{bnd.bnd} file,
  \href{/docs/7-0/tutorials/-/knowledge_base/t/overriding-language-keys\#overriding-a-modules-language-keys}{specify
  OSGi manifest headers} that target the portlet module's resource
  bundle, but prioritize yours.
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/starting-module-development\#building-and-deploying-a-module}{Deploy
  your module}.
\end{enumerate}

Your portlet language key customizations are deployed in your new module
on 7.0.

\subsection{Related Topics}\label{related-topics-6}

\href{/docs/7-0/tutorials/-/knowledge_base/t/overriding-language-keys\#overriding-a-modules-language-keys}{Overriding
a Module's Language Keys}

\href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-core-language-key-hooks}{Upgrading
Core Language Key Hooks}

\href{/docs/7-0/tutorials/-/knowledge_base/t/resolving-a-plugins-dependencies}{Resolving
a Plugin's Dependencies}

\href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-the-liferay-maven-build}{Upgrading
the Liferay Maven Build}

\section{Upgrading Model Listener
Hooks}\label{upgrading-model-listener-hooks}

Developers have been creating model listeners for several Liferay Portal
versions. Upgrading Model Listener Hooks from previous portal versions
has never been easier.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Adapt your code to 7.0's API using the Liferay Upgrade Planner. When
  you ran the planner's \emph{Fix Upgrade Problems} step, many of the
  existing issues were autocorrected or flagged. For any remaining
  errors, consult the
  \href{/docs/7-0/tutorials/-/knowledge_base/t/resolving-a-plugins-dependencies}{Resolving
  a Plugin's Dependencies} article.
\item
  Deploy the plugin.
\end{enumerate}

Liferay DXP's Plugin Compatibility Layer converts the plugin WAR to a
Web Application Bundle (WAB) and installs it to Liferay's OSGi Runtime.

Your model listener hook is ``all ears'' and ready to act.

\subsection{Related Topics}\label{related-topics-7}

\href{/docs/7-0/tutorials/-/knowledge_base/t/model-listeners}{Creating
Model Listeners}

\href{/docs/7-0/tutorials/-/knowledge_base/t/resolving-a-plugins-dependencies}{Resolving
a Plugin's Dependencies}

\href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-the-liferay-maven-build}{Upgrading
the Liferay Maven Build}

\section{Upgrading Servlet Filter
Hooks}\label{upgrading-servlet-filter-hooks}

If you have Servlet Filter Hooks ready to be upgraded, this tutorial's
for you. The process is quite simple:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Adapt your code to 7.0's API using the Liferay Upgrade Planner. When
  you ran the planner's \emph{Fix Upgrade Problems} step, many of the
  existing issues were autocorrected or flagged. For any remaining
  errors, consult the
  \href{/docs/7-0/tutorials/-/knowledge_base/t/resolving-a-plugins-dependencies}{Resolving
  a Plugin's Dependencies} article.
\item
  Deploy the plugin.
\end{enumerate}

Liferay DXP's Plugin Compatibility Layer converts the plugin WAR to a
Web Application Bundle (WAB) and installs it to Liferay's OSGi Runtime.

Your Servlet Filter is running on 7.0!

\subsection{Related Topics}\label{related-topics-8}

\href{/docs/7-0/tutorials/-/knowledge_base/t/resolving-a-plugins-dependencies}{Resolving
a Plugin's Dependencies}

\href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-the-liferay-maven-build}{Upgrading
the Liferay Maven Build}

\section{Upgrading Portal Property and Event Action
Hooks}\label{upgrading-portal-property-and-event-action-hooks}

All portal properties in Liferay Portal 6.2 that are also used in 7.0
can be overridden. Portal property and portal event action hooks that
use these properties can be upgraded to 7.0 by following these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Adapt your code to 7.0's API using the Liferay Upgrade Planner. When
  you ran the planner's \emph{Fix Upgrade Problems} step, many of the
  existing issues were autocorrected or flagged. For any remaining
  errors, consult the
  \href{/docs/7-0/tutorials/-/knowledge_base/t/resolving-a-plugins-dependencies}{Resolving
  a Plugin's Dependencies} article.
\item
  Deploy your hook plugin.
\end{enumerate}

Liferay DXP's Plugin Compatibility Layer converts the plugin WAR to a
Web Application Bundle (WAB) and installs it to Liferay's OSGi Runtime.

Your custom property values and actions are live.

\subsection{Related Topics}\label{related-topics-9}

\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-ide}{Liferay @ide@}

\href{/docs/7-0/tutorials/-/knowledge_base/t/resolving-a-plugins-dependencies}{Resolving
a Plugin's Dependencies}

\href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-the-liferay-maven-build}{Upgrading
the Liferay Maven Build}

\section{Converting StrutsActionWrappers to
MVCCommands}\label{converting-strutsactionwrappers-to-mvccommands}

Since Liferay Portal 6.1, developers could customize the Portal and
Portlet Struts Actions using a Hook and \texttt{StrutsActionWrappers}.
For example, the \texttt{liferay-hook.xml} file for a hook that overrode
the login portlet's login action had this entry:

\begin{verbatim}
<struts-action>
    <struts-action-path>/login/login</struts-action-path>
    <struts-action-impl>
    com.liferay.sample.hook.action.ExampleStrutsPortletAction
    </struts-action-impl>
</struts-action>
\end{verbatim}

The \texttt{liferay-hook.xml} contains the struts mapping and the new
class that overrides the default login action.

The wrapper could extend either \texttt{BaseStrutsAction} or
\texttt{BaseStrutsPortletAction}, depending on whether the struts action
was a portal or portlet action respectively.

Starting in 7.0, this mechanism no longer applies for most of the portal
portlets because they are no longer using Struts Actions, but instead
use \texttt{MVCCommands}.

This tutorial demonstrates how to convert your existing
\texttt{StrutsActionWrappers} to \texttt{MVCCommands}.

\subsection{Converting Your old wrapper to
MVCCommands}\label{converting-your-old-wrapper-to-mvccommands}

Converting \texttt{StrutsActionWrappers} to \texttt{MVCCommands} is
easier than you may think.

As a review, legacy \texttt{StrutsActionWrappers} needed to implement
all the methods, such as \texttt{processAction}, \texttt{render}, and
\texttt{serveResource}, even if only one method was being customized.
Each of these methods can now be customized independently, using
different classes, making the logic simpler and easier to maintain.
Depending on the method you customized in your
\texttt{StrutsActionWrapper}, you need to use the matching MVCCommand
shown below:

\begin{itemize}
\tightlist
\item
  processAction → ~MVCActionCommand
\item
  render → MVCRenderCommand
\item
  serveResource → MVCResourceCommand
\end{itemize}

Look at the
\href{/docs/6-2/tutorials/-/knowledge_base/t/overriding-and-adding-struts-actions}{ExampleStrutsPortletAction
class} for a \texttt{StrutsActionWrapper} example. Depending on the
actions overridden, the user must use different \texttt{MVCCommands}. In
this example, the action and render were overridden, so in order to
migrate to the new pattern, you would need to create two classes:
\texttt{MVCActionCommand} and \texttt{MVCRenderCommand}.

Next you'll need to determine the associated mapping that is used by the
\texttt{MVCCommand}.

\subsection{Mapping Your MVCCommand
URLs}\label{mapping-your-mvccommand-urls}

For most cases, the \texttt{MVCCommand} mapping is the same mapping
defined in the legacy struts action.

Using the beginning login example once again, the
\texttt{struts-action-path} mapping, \texttt{/login/login}, remains the
same for the \texttt{MVCCommand} mapping in 7.0, but some of the
mappings may have changed. It's best to check Liferay's source code to
determine the correct mapping.

Depending on the URL it is a different parameter:

\begin{itemize}
\item
  \texttt{RenderURL}s contain a parameter named
  \texttt{mvcRenderCommandName}. For example:

\begin{verbatim}
<portlet:renderURL var="editEntryURL">
    <portlet:param name="mvcRenderCommandName" value="/hello/edit_entry" 
    />
    <portlet:param name="entryId" value="<%= String.valueOf(
    entry.getEntryId()) %>" />
</portlet:renderURL>    
\end{verbatim}
\item
  \texttt{ActionURL}s are contained in the attribute \texttt{name} of
  the tag library or with the parameter
  \texttt{ActionRequest.ACTION\_NAME}. For example:

\begin{verbatim}
<portlet:actionURL name="/blogs/edit_entry" var="editEntryURL" />
\end{verbatim}
\item
  \texttt{ResourceURL}s are contained as the attribute \texttt{id}. For
  example:

\begin{verbatim}
<portlet:resourceURL id="/login/captcha" var="captchaURL" />
\end{verbatim}
\end{itemize}

Once you have this information, you can override the \texttt{MVCCommand}
by following the instructions found in these sections of the Overriding
MVC Commands tutorial:

\begin{itemize}
\tightlist
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/overriding-mvc-commands\#overriding-mvcactioncommand}{Overriding
  MVCActionCommands}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/overriding-mvc-commands\#overriding-mvcresourcecommand}{Overriding
  MVCResourceCommands}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/overriding-mvc-commands\#adding-logic-to-an-existing-mvc-render-command}{Overriding
  MVCRenderCommands}
\end{itemize}

Now you know how to convert your \texttt{StrutsActionWrapper}s to
\texttt{MVCCommand}s!

\subsection{Related Topics}\label{related-topics-10}

\href{/docs/7-0/tutorials/-/knowledge_base/t/overriding-mvc-commands}{Overriding
MVC Commands}

\chapter{Upgrading Themes}\label{upgrading-themes}

If you've developed themes in Liferay Portal 6.1 or Liferay Portal 6.2,
as part of your upgrade you'll want to use them in 7.0. The upgrade
process requires several modifications. To help automate this process
you'll use the
\href{/docs/7-0/tutorials/-/knowledge_base/t/themes-generator}{Liferay
Theme Generator}.

The following tutorials show you how to upgrade your Liferay Portal 6.1
and Liferay Portal 6.2 themes to 7.0.

\section{Upgrading Your Theme from Liferay Portal 6.1 to
7.0}\label{upgrading-your-theme-from-liferay-portal-6.1-to-7.0}

This tutorial guides you through the process of upgrading your 6.1 theme
to run on 7.0.

For a more in depth tutorial that covers upgrading 6.2 themes, please
see the
\href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-themes}{Upgrading
Themes} tutorial.

\subsection{Setting Up Your Theme With Liferay Theme
Generator}\label{setting-up-your-theme-with-liferay-theme-generator}

You'll use Liferay Theme Generator to get the upgrade process started.
Liferay Theme Generator supplies your theme with the necessary tools to
deploy and make quick modifications.

In this tutorial, you'll use Liferay Theme Generator's Import feature to
help set up the upgrade process.

\subsubsection{Preparing Your Theme}\label{preparing-your-theme}

Before you import your theme, you need to make some modifications to
your theme to ensure Liferay Theme Generator sets up the correct version
and template language.

Make sure these settings are present in your theme:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open your \texttt{liferay-look-and-feel.xml} file and make sure the
  template language (\texttt{vm}, \texttt{ftl}, \texttt{jsp}) is
  defined:

\begin{verbatim}
<look-and-feel>
    ...
    <theme id="my-theme-name" name="My Theme Name">
        <template-extension>vm</template-extension>
        ...
\end{verbatim}
\item
  Also in \texttt{liferay-look-and-feel.xml}, set the theme version to
  6.2+:

\begin{verbatim}
<look-and-feel>
    <compatibility>
        <version>6.2+</version>
    </compatibility>
    ...
\end{verbatim}
\item
  Finally, open your \texttt{liferay-plugin-package.properties} file and
  update the Liferay Portal version to 6.2+, as well:

\begin{verbatim}
liferay-versions=6.2+
\end{verbatim}
\end{enumerate}

\noindent\hrulefill

\textbf{Note:} Liferay Theme Generator's importer only recognizes 6.2
themes. Therefore, 6.1 themes must be versioned as 6.2+ to be recognized
by the importer.

The importer only supports importing 6.2 themes generated with the
Plugins SDK. If your theme was not generated with the Plugins SDK, such
as those created with Maven, you must modify your theme to match the
Plugins SDK structure before importing.

\noindent\hrulefill

Now that your theme is prepped, you can start the import process next.

\subsubsection{Importing Your Theme}\label{importing-your-theme}

Follow these steps to import your theme:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Install Liferay Theme Generator and its required dependencies, as
  explained in the
  \href{/docs/7-0/tutorials/-/knowledge_base/t/themes-generator}{Liferay
  Theme Generator} tutorial.
\item
  Navigate to the folder where you want your theme imported:

\begin{verbatim}
$ cd /where/i/want/my-theme/imported
\end{verbatim}
\item
  Import your theme by running this command:

\begin{verbatim}
$ yo liferay-theme:import
\end{verbatim}
\item
  Follow the prompts to complete your theme import.
\end{enumerate}

Your theme has been imported into a folder named after your original
theme. For example, a theme named \texttt{my-awesome-theme-for-61} would
be imported into a folder called \texttt{my-awesome-theme-for-61-theme}.

Next, you can learn how to update your theme for 7.0.

\subsection{Updating Your Theme For
7.0}\label{updating-your-theme-for-7.0}

Now that you've successfully imported your theme, you have the tools
necessary to develop your theme for 7.0. These tools are provided by the
\href{/docs/7-0/reference/-/knowledge_base/r/theme-gulp-tasks}{Liferay
Theme Tasks}, part of the
\href{https://github.com/liferay/liferay-themes-sdk/tree/master/packages}{Liferay
JS Theme Toolkit}.

The first of these tools you'll use is the Upgrade task. This task does
a few things:

\begin{itemize}
\item
  Backs up your files so you can revert them later if needed.
\item
  Modifies and renames some files for compatibility.
\item
  Creates a \texttt{css.diff} file under \texttt{/\_backup}, so you can
  easily see what's been changed.
\item
  Updates NPM dependencies.
\item
  Creates a ``compatibility'' file for Compass mixins, which may have
  been used in your 6.1 theme.
\end{itemize}

\noindent\hrulefill

\textbf{Important}: Before you run the Update task, read the section
below titled
\href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-your-theme-from-6-1-to-7-0\#an-important-note-about-core-stylesheets}{An
Important Note About Core Stylesheets} for advice on renaming
(effectively overriding) ``core'' stylesheets.

\noindent\hrulefill

Upgrade your theme, by running these commands:

\begin{verbatim}
$ cd my-awesome-theme-for-62-theme

$ gulp upgrade
\end{verbatim}

If the Upgrade task didn't update your files like you expected, you can
easily revert them back using the Upgrade Revert task:

\begin{verbatim}
$ gulp upgrade:revert
\end{verbatim}

The Upgrade task automates some of the steps for you, but some manual
changes are still required. These are covered next.

\subsection{Additional Manual Changes To Your
Theme}\label{additional-manual-changes-to-your-theme}

When the Upgrade task finishes, the console may output additional manual
changes you may need to make to your theme.

\noindent\hrulefill

\textbf{Note:} Because Liferay Portal 7.0 uses Bootstrap 3, the default
\href{https://css-tricks.com/box-sizing/}{box model} has been changed to
box-sizing: border-box. If you were using width or height and padding
together on an element, you may need to make changes, or those elements
may have unexpected sizes.

\noindent\hrulefill

There are likely changes that you still need to make, which these tools
and this guide can't realistically cover. Therefore, it's recommended
that you make changes gradually, rather than all at once. This allows
you to more easily identify any issues your theme may have.

Please refer to the
\href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-your-theme-from-6-1-to-7-0\#appendix-making-manual-compatibility-adjustments-to-your-theme}{Appendix}
below for ways on how to update your theme manually.

Follow the instructions in the next section to build and deploy your
theme.

\subsection{Building And Deploying Your
Theme}\label{building-and-deploying-your-theme}

Follow these steps to build and deploy your theme:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  To check that everything is running smoothly, run this command:

\begin{verbatim}
$ gulp build
\end{verbatim}
\item
  If all goes well, you can now deploy your theme by running this
  command:

\begin{verbatim}
$ gulp deploy
\end{verbatim}
\end{enumerate}

If you're using Velocity as your template language, you'll notice this
message on your server console when deploying your theme:

\emph{Support of Velocity is deprecated. Update your theme to use
FreeMarker for forward compatibility.}

It's recommended that you migrate to using Freemarker for your theme
templates. For more details, please see the
\href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-your-theme-from-6-1-to-7-0\#upgrading-theme-templates}{Upgrading
Theme Templates} section in the Appendix.

Additional tasks and info can be found in the
\href{/docs/7-0/reference/-/knowledge_base/r/theme-gulp-tasks}{Liferay
Gulp Tasks reference guide}.

Congratulations! You've now completed a major step in upgrading your
theme.

\subsection{Appendix: Making Manual Compatibility Adjustments To Your
Theme}\label{appendix-making-manual-compatibility-adjustments-to-your-theme}

This appendix covers the changes you need to make to your theme if you
manually update your files, or if you need to make additional changes
after using the Liferay JS Theme Toolkit's Upgrade task.

\subsubsection{Upgrading Theme Metadata}\label{upgrading-theme-metadata}

Your theme contains metadata about its capabilities and requirements.
This metadata needs to be updated to ensure your theme is available for
use in Liferay DXP.

\paragraph{Liferay Portal Version}\label{liferay-portal-version}

Your theme must target the proper Liferay DXP version: in your case,
7.0.0+. You must update the theme version in two places:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In the file \texttt{liferay-plugin-package.properties}, add the
  following property to ensure Liferay DXP deploys your theme:

\begin{verbatim}
liferay-versions=7.0.0+
\end{verbatim}
\item
  Add the following version information to your
  \texttt{liferay-look-and-feel.xml} to ensure Liferay DXP makes your
  theme available for use:

\begin{verbatim}
<look-and-feel>
    <compatibility>
        <version>7.0.0+</version>
    </compatibility>
    ...
\end{verbatim}
\end{enumerate}

\paragraph{Template Extension}\label{template-extension}

If you're not using the default Theme Template language, Freemarker
(.ftl), you must add a \texttt{template-extension} tag to your
\texttt{liferay-look-and-feel.xml} file:

\begin{verbatim}
<look-and-feel>
    ...
    <theme id="my-theme-name" name="My Theme Name">
        <template-extension>vm</template-extension>
        ...
\end{verbatim}

\paragraph{Required Deployment
Contexts}\label{required-deployment-contexts}

If you have any Required Deployment Contexts listed in your
\texttt{liferay-plugin-package.properties} file, these will likely need
to be removed.

\begin{itemize}
\item
  \texttt{resources-importer-web}: Portal Compatibility Hook is for
  previous versions of Liferay Portal.
\item
  \texttt{portal-compat-hook}: Because this tutorial is focused on
  upgrading a theme rather than importing content and assets, it does
  not cover the Resources Importer. You can learn more about the
  Resources Importer in the
  \href{/docs/7-0/tutorials/-/knowledge_base/t/importing-resources-with-a-theme}{Importing
  Resources with a Theme} tutorial.
\end{itemize}

\subsubsection{Upgrading Stylesheets}\label{upgrading-stylesheets}

\paragraph{An Important Note About ``Core''
Stylesheets}\label{an-important-note-about-core-stylesheets}

If you've made customizations to ``core'' Liferay DXP stylesheets, it's
recommended that you not use these customizations right away. Liferay
DXP's UI has changed significantly since version 6.1, and any
customizations you may have are either not likely to work, or will cause
problems in the UI.

These ``core'' files would be:

\begin{itemize}
\item
  \texttt{application.css}
\item
  \texttt{aui.css}
\item
  \texttt{base.css}
\item
  \texttt{dockbar.css}
\item
  \texttt{extras.css}
\item
  \texttt{layout.css}
\item
  \texttt{main.css}
\item
  \texttt{navigation.css}
\item
  \texttt{portal.css}
\item
  \texttt{portlet.css}
\item
  \texttt{taglib.css}
\end{itemize}

\noindent\hrulefill

\textbf{Important:} Rename these files to something like
\texttt{my\_application.css}, \texttt{my\_aui.css}, etc. If you don't
rename these files, you may get an error when building your theme. This
is because Sass is importing ambiguous names like application, aui, etc.

\noindent\hrulefill

It's recommended that you get your theme working in 7.0 first, and then
audit the styles in these ``core'' CSS files to see if they're still
necessary and don't cause any issues.

\paragraph{Renaming CSS Files}\label{renaming-css-files}

7.0 now uses the \texttt{.scss} extension for Sass stylesheets.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Under \texttt{my-imported-theme/src/css}, rename your
  \texttt{custom.css} file to \texttt{\_custom.scss}.
\item
  If you have any additional CSS files that need to take advantage of
  Sass and \href{http://bourbon.io/}{Bourbon}, you must rename those as
  well.

  For example, \texttt{my-feature.css} becomes
  \texttt{\_my-feature.scss}, and \texttt{fonts.css} becomes
  \texttt{\_fonts.scss}.
\end{enumerate}

\paragraph{Imported Stylesheet
References}\label{imported-stylesheet-references}

If you've imported any renamed stylesheets into another, you'll want to
update those references.

For example \texttt{\_my-fonts.scss} needs to be updated from:

\begin{verbatim}
@import url(my-fonts.css);
\end{verbatim}

to:

\begin{verbatim}
@import "my-fonts";
\end{verbatim}

\paragraph{Sass Framework Import}\label{sass-framework-import}

Beginning with version 7.0, Liferay Portal now uses
\href{http://bourbon.io/}{Bourbon} for mixins, rather than Compass.
Bourbon is being imported in a core stylesheet,
\href{https://github.com/liferay/liferay-portal/blob/7.0.2-ga3/modules/apps/foundation/frontend-theme/frontend-theme-styled/src/main/resources/META-INF/resources/_styled/css/_imports.scss}{\_imports.scss},
so you shouldn't need to import it yourself.

Also, files with the \texttt{.scss} extension are processed by Sass
automatically. But you must still import or link to these to use them.

Remove \texttt{@import\ "compass"} from all your Sass files, and don't
worry about importing Bourbon.

\paragraph{Mixins}\label{mixins}

When Liferay Portal switched from using Compass to
\href{http://bourbon.io/}{Bourbon}, some mixins changed syntax, became
unsupported, or became unnecessary in modern browsers. These mixins
should be updated or removed.

For example:

\begin{verbatim}
.my-component {

    @include border-radius(8px);

    @include opaque;

    @include scale(0.9);

}

input[type="text"] {

    @include input-placeholder {

        color: #bfbfbf;

    }

}
\end{verbatim}

becomes:

\begin{verbatim}
.my-component {

    border-radius: 8px;

    opacity: 1;

    @include transform(scale(0.9));

input[type="text"] {

    @include placeholder {

        color: #bfbfbf;

    }

}
\end{verbatim}

Please refer to \href{http://compass-style.org/index/mixins/}{Compass}
and \href{http://bourbon.io/docs/\#mixins}{Bourbon} documentation for
more details.

\paragraph{Bootstrap 3}\label{bootstrap-3}

If you've used Bootstrap 2.3.2 in your theme, a
\href{http://getbootstrap.com/migration/}{migration guide} is available.

\paragraph{\texorpdfstring{Remove \texttt{.aui} Class Used In Descendant
Selectors}{Remove .aui Class Used In Descendant Selectors}}\label{remove-.aui-class-used-in-descendant-selectors}

The class \texttt{.aui} is no longer in use. Selectors that contain
\texttt{.aui} as a parent qualifier must be modified, or those selectors
will not match the expected elements.

For example:

\begin{verbatim}
.aui{

    my-component {

        // ...

    }

}

.aui my-other-component {

    // ...

}
\end{verbatim}

becomes:

\begin{verbatim}
html {

    my-component {

        // ...

    }

}

html my-other-component {

    // ...

}
\end{verbatim}

or maybe:

\begin{verbatim}
my-component {

    // ...

}

my-other-component {

    // ...
}
\end{verbatim}

\subsubsection{Upgrading JavaScript}\label{upgrading-javascript}

In August 2014
\href{https://yahooeng.tumblr.com/post/96098168666/important-announcement-regarding-yui}{Yahoo
stopped all new development of YUI}, which AlloyUI was built on. Because
of this announcement, Liferay has decided to sunset AlloyUI and
deprecate it as of Liferay Portal 7.

Although AlloyUI is deprecated, it's still available by default, and
existing AlloyUI 3 based code continues to work.

To further research changes to an AlloyUI module, you can find a
\texttt{HISTORY.md} file under each component's directory.

Moving forward, it's recommended to migrate your AlloyUI/YUI code to
either Metal.js or the framework of your choice. Below, you'll find some
libraries used in Liferay DXP. Feel free to use them as well.

\paragraph{jQuery}\label{jquery-1}

\href{https://jquery.com/}{jQuery} is a fast, small, and feature-rich
JavaScript library. It makes things like HTML document traversal and
manipulation, event handling, animation, and Ajax much simpler. It's
also popular among front-end developers, making it ideal for getting
started quickly.

For more in depth coverage, see \href{http://api.jquery.com/}{jQuery's
documentation}.

\paragraph{Lodash}\label{lodash}

\href{https://lodash.com/}{Lodash} is a modern JavaScript utility
library delivering modularity, performance \& extras. It's used in
Liferay DXP to fill the void left by YUI's utility modules.

For more in depth coverage, see \href{http://lodash.com/docs/}{Lodash's
documentation}.

\paragraph{Metal.js}\label{metal.js-1}

Written by Liferay to specifically to meet the needs of Liferay DXP,
\href{http://www.metaljs.com/}{Metal.js} is a JavaScript library for
building UI components in a solid, flexible way.

For more in depth coverage, see
\href{http://metaljs.com/docs/}{Metal.js's documentation}

\subsubsection{Upgrading Theme
Templates}\label{upgrading-theme-templates}

In prior versions of Liferay Portal, Velocity templates (\texttt{.vm}
files) were the default template language for writing theme markup. But
Velocity had limitations. In 7.0, Freemarker templates (\texttt{.ftl}
files) are the default template language, and Velocity templates are
deprecated.

With that in mind, if your themes are written in \texttt{.vm} files,
they should still work, but you're missing out on additional theme
features. In a future release, support for Velocity templates will be
removed.

\paragraph{Migrating to Freemarker
Templates}\label{migrating-to-freemarker-templates}

For a typical theme, migrating to Freemarker should be simple. The
syntaxes of both languages are relatively similar.

Here's a comparison:

\textbf{Velocity:}

\begin{verbatim}
$theme.include($my_template_include)

#if ($show_site_name)

    <span title="#language_format ("go-to-x", [$site_name])">

        $site_name

    </span>

#end

#parse ("$full_templates_path/navigation.vm")

#breadcrumbs()

$theme.wrapPortlet("portlet.vm", $content_include)

#foreach ($nav_item in $nav_items)

    $nav_item.getName()

#end
\end{verbatim}

\textbf{Freemarker:}

\begin{verbatim}
<@liferay_util["include"] page=my_template_include />

<#if show_site_name>

    <span title="<@liferay.language_format arguments="${site_name}" key="go-to-x" />">

        ${site_name}

    </span>

</#if>

<#include "${full_templates_path}/navigation.ftl" />

<@liferay.breadcrumbs />

<@liferay_theme["wrap-portlet"] page="portlet.ftl">

    <@liferay_util["include"] page=content_include />

</@>

<#list nav_items as nav_item>

    ${nav_item.getName()}

</#list>
\end{verbatim}

Whichever language you decide to use, there are several convenient
macros included with Liferay DXP:

\begin{itemize}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/freemarker-macros}{Freemarker
  macros on LDN}
\item
  \href{https://github.com/liferay/liferay-portal/blob/7.0.2-ga3/modules/apps/foundation/portal-template/portal-template-freemarker/src/main/resources/FTL_liferay.ftl}{Freemarker
  macros source}
\item
  \href{https://github.com/liferay/liferay-portal/blob/7.0.2-ga3/modules/apps/foundation/portal-template/portal-template-velocity/src/main/resources/VM_liferay.vm}{Velocity
  macros source}
\end{itemize}

\subsubsection{Noteworthy Breaking
Changes}\label{noteworthy-breaking-changes}

There are many changes since Liferay Portal 6.1 which break in version
7.0. Some of these changes are documented in
\href{/docs/7-0/reference/-/knowledge_base/r/breaking-changes}{Liferay
DXP's Breaking Changes}. Below are some notable ones.

\paragraph{Dockbar Is Now Called Control
Menu}\label{dockbar-is-now-called-control-menu}

In \texttt{portal\_normal.vm}, admin controls are now called using
\texttt{\#control\_menu()}.

Liferay Portal 6.1:

\begin{verbatim}
#if ($is_signed_in)

    #dockbar()

#end
\end{verbatim}

7.0:

\begin{verbatim}
#control_menu()
\end{verbatim}

\paragraph{Portlet Configuration
Options}\label{portlet-configuration-options}

In \texttt{portlet.vm}, portlet menu icons have been condensed into a
single call and are now controlled using the
\texttt{PortletConfigurationIcon} classes.

Liferay Portal 6.1:

\begin{verbatim}
$theme.iconOptions()

$theme.iconMinimize()

$theme.iconMaximize()

$theme.iconClose()
\end{verbatim}

7.0:

\begin{verbatim}
$theme.portletIconOptions()
\end{verbatim}

See Liferay Portal's Breaking Changes for more details:

\begin{itemize}
\tightlist
\item
  \href{/docs/7-0/reference/-/knowledge_base/r/breaking-changes\#removed-the-tags-that-start-with-portleticon-}{Removed
  the Tags that Start with portlet:icon-}
\item
  \href{/docs/7-0/reference/-/knowledge_base/r/breaking-changes\#portlet-configuration-options-may-not-always-be-displayed}{Portlet
  Configuration Options May Not Always Be Displayed}
\end{itemize}

\paragraph{Navigation Item Icons}\label{navigation-item-icons}

In \texttt{navigation.vm}, access to icons have been changed, to
minimize dependency on taglibs.

Liferay Portal 6.1:

\begin{verbatim}
nav_item.icon()
\end{verbatim}

7.0:

\begin{verbatim}
$theme.layoutIcon($nav_item.getLayout())
\end{verbatim}

See
\href{/docs/7-0/reference/-/knowledge_base/r/breaking-changes\#removed-the-icon-method-from-navitem}{Liferay
Portal's Breaking Changes} for more details.

\subsubsection{Upgrading Layout
Templates}\label{upgrading-layout-templates}

The only significant change to Layout Templates has been the addition of
\href{https://getbootstrap.com/docs/3.3/css/\#grid}{Bootstrap's Grid
system}.

If you're using any custom Layout Templates, you'll want to integrate
Bootstrap into them.

A comparison between Layout Templates in Liferay Portal 6.1 and Liferay
Portal 7.0 is shown in the example below:

Liferay Portal 6.1:

\begin{verbatim}
<div class="portlet-layout">

    <div class="portlet-column portlet-column-only" id="column-1">

        $processor.processColumn("column-1", "portlet-column-content portlet-column-content-only")

    </div>

</div>
\end{verbatim}

Liferay Portal 7.0:

\begin{verbatim}
<div class="portlet-layout row">

    <div class="col-md-12 portlet-column portlet-column-only" id="column-1">

        $processor.processColumn("column-1", "portlet-column-content portlet-column-content-only")

    </div>

</div>
\end{verbatim}

\subsection{Related Topics}\label{related-topics-11}

\href{/docs/7-0/tutorials/-/knowledge_base/t/themes-generator}{Themes
Generator}

\href{/docs/7-0/tutorials/-/knowledge_base/t/themelets}{Themelets}

\href{/docs/7-0/tutorials/-/knowledge_base/t/importing-resources-with-a-theme}{Importing
Resources with a Theme}

\section{Upgrading Your Theme from Liferay Portal 6.2 to
7.0}\label{upgrading-your-theme-from-liferay-portal-6.2-to-7.0}

This tutorial guides you through the process of upgrading your 6.2 theme
to run on 7.0. While you're at it, you should leverage theme
improvements, including support for Sass, Bootstrap 3, and Lexicon
(Liferay's UI design language). This tutorial demonstrates upgrading a
Liferay Portal 6.2 theme to 7.0.

Theme upgrades involve these steps:

\begin{itemize}
\tightlist
\item
  Updating project metadata
\item
  Updating CSS
\item
  Updating theme templates
\item
  Updating resources importer configuration and content
\item
  Applying Lexicon design patterns
\end{itemize}

As an example, this tutorial applies the steps to a Liferay Portal 6.2
theme called the Lunar Resort theme---developed in the Liferay Portal
6.2 Learning Path
\href{/docs/6-2/tutorials/-/knowledge_base/t/developing-a-liferay-theme}{Developing
a Liferay Theme}. It's similar to many Liferay Portal 6.2 themes as it
extends the
\href{https://github.com/liferay/liferay-portal/tree/6.2.x/portal-web/docroot/html/themes/_styled}{\texttt{\_styled}
theme}, adding configurable settings and incorporating a responsive
design that leverages Font Awesome icons and Bootstrap. The theme
\href{/documents/10184/656312/lunar-resort-theme-migration-6.2.zip}{ZIP
file} contains its original source code.

\begin{figure}
\centering
\includegraphics{./images/finished-theme.png}
\caption{The Lunar Resort example theme upgraded in this tutorial uses a
clean, minimal design.}
\end{figure}

Before upgrading a theme, consider
\href{/docs/7-0/tutorials/-/knowledge_base/t/migrating-a-6-2-theme-to-liferay-7}{migrating
the theme} to use the
\href{https://github.com/liferay/liferay-themes-sdk/tree/master/packages}{Liferay
JS Theme Toolkit}, such as those created with the
\href{/docs/7-0/tutorials/-/knowledge_base/t/themes-generator}{Liferay
Theme Generator}. 7.0 doesn't require this migration, but the Liferay JS
Theme Toolkit's Gulp \texttt{upgrade} task automates many upgrade steps.
Themes that use the Liferay JS Theme Toolkit can also leverage exclusive
new features, such as the Liferay Theme Generator's sub-generators, and
\href{/docs/7-0/tutorials/-/knowledge_base/t/themelets}{Themelets}. If
you migrate your theme, return here afterward to upgrade it.

No matter the environment in which you're developing your theme, this
tutorial explains everything required to upgrade it. The easiest option
is to use the Liferay JS Theme Toolkit's Gulp \texttt{upgrade} task, so
you'll see that first. Then you'll see \emph{all} upgrade steps, in case
you want to run them manually.

\subsection{Running the Upgrade Task for Themes that Use Liferay JS
Theme
Toolkit}\label{running-the-upgrade-task-for-themes-that-use-liferay-js-theme-toolkit}

A Liferay Portal 6.2 theme can be upgraded to 7.0, regardless of its
project environment (Liferay JS Theme Toolkit, Plugins SDK, Maven,
etc.). But a theme that's been migrated to use the Liferay JS Theme
Toolkit can leverage the Gulp \texttt{upgrade} task. If you're not going
to leverage Liferay JS Theme Toolkit, skip to the \emph{Updating Project
Metadata} section.

Here's what the Upgrade task does:

\begin{itemize}
\tightlist
\item
  Updates the theme's Liferay version
\item
  Updates the CSS
\item
  Suggests specific code updates
\end{itemize}

The Upgrade task automatically upgrades CSS code that it can identify.
For everything else, it suggests manual upgrades that you can make.

Here are the steps for using the theme \texttt{gulp\ upgrade} task:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In your theme's root directory, run this command:

\begin{verbatim}
gulp upgrade
\end{verbatim}

  Here's what it does initially:

  \begin{itemize}
  \tightlist
  \item
    Copies the existing theme to a folder called \texttt{backup}
  \item
    Creates core code for generating theme base files
  \item
    Updates Liferay version references
  \end{itemize}
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note**: An upgraded theme can be restored to its original state by
 executing `gulp upgrade:revert`.
\end{verbatim}

\noindent\hrulefill

\begin{verbatim}
The task continues upgrading CSS files, prompting you to update CSS file
names.
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  For 7.0, Sass files should use the \texttt{.scss} extension and file
  names for Sass partials should start with an underscore (e.g.,
  \texttt{\_custom.scss}). The \texttt{upgrade} task prompts you for
  each CSS file to rename.
\end{enumerate}

The Upgrade task makes a best effort to upgrade the theme's Bootstrap
code from version 2 to 3. For other areas of the code it suspects might
need updates, it logs suggestions (covered later). The task also reports
changes that may affect theme templates.

A \emph{breaking change} is a code modification between versions of
Liferay DXP that might be incompatible with existing plugins, including
themes. Liferay minimized the number of breaking changes, but couldn't
avoid some. The
\href{/docs/7-0/reference/-/knowledge_base/r/breaking-changes}{Breaking
Changes} reference document describes them. The theme's
\texttt{gulp\ upgrade} command and the
\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-upgrade-planner}{Upgrade
Planner}, in Liferay @ide@ identify and address these changes.

The Gulp \texttt{upgrade} task jump-starts the upgrade process, but it
doesn't complete it. Manual updates are required.

The rest of this tutorial explains all the theme upgrade steps,
regardless of whether the Gulp \texttt{upgrade} task performs them.
Steps the Upgrade task performs are noted in context. Even if you've
already executed the Upgrade task, it's best to learn all the steps and
make sure they're applied to your theme.

The next step is to update the theme's metadata.

\subsection{Updating Project Metadata}\label{updating-project-metadata}

If you're developing your theme in an environment other than the Plugins
SDK, skip this section.

A theme's Liferay version must be updated to \texttt{7.0.0+} for the
theme to run on 7.0.

If you're using the Plugins SDK, open the
\texttt{liferay-plugin-package.properties} file and change the
\texttt{liferay-versions} property value to \texttt{7.0.0+}:

\begin{verbatim}
    liferay-versions=7.0.0+
\end{verbatim}

If you're using the Liferay JS Theme Toolkit, open the
\texttt{liferay-look-and-feel.xml} file and specify
\texttt{liferay-look-and-feel\_7\_0\_0.dtd} as the DTD and
\texttt{7.0.0+} as the compatibility version:

\begin{verbatim}
    <?xml version="1.0"?>
    <!DOCTYPE look-and-feel PUBLIC "-//Liferay//DTD Look and Feel 7.0.0//EN"
    "http://www.liferay.com/dtd/liferay-look-and-feel_7_0_0.dtd">

    <look-and-feel>
            <compatibility>
                    <version>7.0.0+</version>
            </compatibility>

            ...

    </look-and-feel>
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\tightlist
\item
  If your theme uses the Liferay JS Theme Toolkit and has a
  \texttt{package.json} file, update the file's Liferay version
  references to \texttt{7.0}.
\end{enumerate}

Your theme's Liferay version references are updated for 7.0. Next,
you'll update the CSS.

\subsection{Updating CSS Code}\label{updating-css-code}

7.0's UI improvements required these CSS-related changes:

\begin{itemize}
\tightlist
\item
  Adding new CSS files
\item
  Removing unneeded CSS files
\item
  Class variable changes (required by Bootstrap 3)
\item
  Modifications to CSS responsiveness tokens
\end{itemize}

The theme upgrade process involves conforming to these changes.

In this section, you'll update your theme's CSS to leverage the styling
improvements. Start with updating CSS file names for Sass.

\subsubsection{Updating CSS File Names for
Sass}\label{updating-css-file-names-for-sass}

Although Sass was available in Liferay Portal 6.2, only Sass partial
files followed the Sass naming convention (using file suffix
\texttt{.scss}). In 7.0 themes, all Sass files must end in
\texttt{scss}.

\noindent\hrulefill

\textbf{Note}: The Gulp \texttt{upgrade} task renames Sass files
automatically.

\noindent\hrulefill

For each CSS file you've modified in your theme, except
\texttt{main.scss} and \texttt{aui.scss}, change its suffix from
\texttt{.css} to \texttt{.scss}.

Then prepend an underscore (\texttt{\_}) to all Sass partial file names.

For example, rename \texttt{custom.css} to \texttt{\_custom.scss}.

Here are the Lunar Resort theme's renamed CSS files:

\begin{itemize}
\tightlist
\item
  \texttt{css/}

  \begin{itemize}
  \tightlist
  \item
    \texttt{\_aui\_variables.scss}
  \item
    \texttt{\_custom.scss}
  \end{itemize}
\end{itemize}

Refer to the
\href{/docs/7-0/reference/-/knowledge_base/r/theme-reference-guide}{Theme
Reference Guide} for a complete list of expected theme CSS files.

Next, the CSS rules must be updated to use Bootstrap 3 syntax.

\subsubsection{Updating CSS Rules}\label{updating-css-rules}

7.0 uses Bootstrap 3's CSS rule syntax. The new syntax lets developers
leverage Bootstrap 3 features and improvements.

If your theme does not use the Liferay JS Theme Toolkit, you can refer
to the
\href{http://getbootstrap.com/migration/\#migrating-from-2x-to-30}{Migrating
from 2.x to 3.0 guide} for updating CSS rules to Bootstrap 3.

If your theme uses the Liferay JS Theme Toolkit, the Gulp
\texttt{upgrade} task reports automatic CSS updates and suggested manual
updates. For example, here is part of the task log for the Lunar Resort
theme:

\begin{verbatim}
----------------------------------------------------------------
 Bootstrap Upgrade (2 to 3)
----------------------------------------------------------------

File: src/css/_aui_variables.scss
    Line 5: "$white" has been removed
    Line 11: "$baseBorderRadius" has changed to "$border-radius-base"
    Line 15: "$btnBackground" has changed to "$btn-default-bg"
    Line 16: "$btnBackgroundHighlight" has been removed
    Line 17: "$btnBorder" has changed to "$btn-default-border"
    Line 18: "$btnDangerBackground" has changed to "$btn-danger-bg"
    Line 19: "$btnDangerBackgroundHighlight" has been removed
    Line 21: "$btnInfoBackgroundHighlight" has been removed
    Line 21: "$btnInfoBackground" has changed to "$btn-info-bg"
    Line 22: "$btnPrimaryBackground" has changed to "$btn-primary-bg"
    Line 23: "$btnPrimaryBackgroundHighlight" has been removed
    Line 24: "$btnSuccessBackground" has changed to "$btn-success-bg"
    Line 25: "$btnSuccessBackgroundHighlight" has been removed
    Line 26: "$btnWarningBackground" has changed to "$btn-warning-bg"
    Line 27: "$btnWarningBackgroundHighlight" has been removed
    Line 29: "$dropdownLinkBackgroundActive" has changed to
    "$dropdown-link-active-bg"
    Line 30: "$dropdownLinkBackgroundHover" has changed to
    "$dropdown-link-hover-bg"
    Line 31: "$dropdownLinkColorActive" has changed to
    "$dropdown-link-active-color"
    Line 31: "$white" has been removed
    Line 34: "$navbarBackgroundHighlight" has been removed
    Line 35: "$navbarBorder" has changed to "$navbar-default-border"
    Line 36: "$navbarBackground" has changed to "$navbar-default-bg"
    Line 36: "$navbarLinkBackgroundActive" has changed to
    "$navbar-default-link-active-bg"
    Line 38: "$linkColorHover" has changed to "$link-hover-color"
    Line 38: "$navbarLinkColorHover" has changed to
    "$navbar-default-link-hover-color"
    Line 39: "$navbarLinkColor" has changed to
    "$navbar-default-link-color"
    Line 39: "$navbarText" has changed to "$navbar-default-color"
    Line 41: "$errorBackground" has changed to "$error-bg"
    Line 45: "$infoBackground" has changed to "$info-bg"
    Line 47: "$successBackground" has changed to "$success-bg"
    Line 50: "$warningBackground" has changed to "$warning-bg"
File: src/css/custom.css
    Line 201: Padding no longer affects width or height, you may need to
    change your rule (lines 201-227)
    Line 207: Padding no longer affects width or height, you may need to
    change your rule (lines 207-226)
    Line 212: You would change height from "62px" to "82px"
    Line 305: Padding no longer affects width or height, you may need to
    change your rule (lines 305-314)
    Line 308: You would change height from "39px" to "46px"
    Line 403: "nav-collapse" has changed to "navbar-collapse"
    Line 409: Padding no longer affects width or height, you may need to
    change your rule (lines 409-418)
    Line 490: "btn-navbar" has changed to "navbar-btn"
    Line 490: "btn" has changed to "btn btn-default"
    Line 586: "nav-collapse" has changed to "navbar-collapse"
\end{verbatim}

For each update performed and suggested, the task reports a file name
and line number range.

Since Bootstrap 3 adopts the \texttt{box-sizing:\ border-box} property
for all elements and pseudo-elements (e.g., \texttt{:before} and
\texttt{:after}), padding no longer affects dimensions.
\href{https://getbootstrap.com/docs/3.3/css/\#less-mixins-box-sizing}{Bootstrap's
documentation} describes the box sizing changes. Consider the padding
updates the \texttt{upgrade} task reports for CSS rules.

\noindent\hrulefill

\textbf{Note:} For individual elements, you can overwrite the
\texttt{box-sizing:\ \ border-box} rule with
\texttt{box-sizing:\ content-box}.

\noindent\hrulefill

In all CSS rules that use padding, make sure to update the width and
height.

For example, examine the \texttt{height} value change in this CSS rule
from the Lunar Resort theme's \texttt{\_custom.scss} file.

Old way:

\begin{verbatim}
#reserveBtn {
    background-color: #00C4FB;
    border-radius: 10px;
    color: #FFF;
    font-size: 1.5em;
    height: 62px;
    margin: 30px;
    padding: 10px 0;
    ...
}
\end{verbatim}

New way:

\begin{verbatim}
#reserveBtn {
    background-color: #00C4FB;
    border-radius: 10px;
    color: #FFF;
    font-size: 1.5em;
    height: 82px;
    margin: 30px;
    padding: 10px 0;
    ...
}
\end{verbatim}

After updating your theme's CSS rules, you should update its CSS
responsiveness.

\subsubsection{Updating the
Responsiveness}\label{updating-the-responsiveness}

In 7.0, Bootstrap 3 explicit media queries replace Bootstrap 2
\texttt{respond-to} mixins for CSS responsiveness. Follow these steps to
update CSS responsiveness:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open your \texttt{\_custom.scss} file.
\item
  Replace all \texttt{respond-to} mixins with corresponding media
  queries shown below:

  \textbf{Media Query Replacements}
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 Liferay Portal 6.2 Mixin                            |  &nbsp;7.0 Media Query                                     |
\end{verbatim}

\noindent\hrulefill --------------------------------------
\textbar:----------------------------------------------------------
\textbar{} \texttt{@include\ respond-to(phone)} \textbar{}
\texttt{@include\ media-query(null,\ \$screen-xs-max)} \textbar{}
\texttt{@include\ respond-to(tablet)} \textbar{}
\texttt{@include\ media-query(sm,\ \$screen-sm-max)} \textbar{}
\texttt{@include\ respond-to(phone,\ tablet)} \textbar{}
\texttt{@include\ media-query(null,\ \$breakpoint\_tablet\ -\ 1)}
\textbar{} \texttt{@include\ respond-to(desktop,\ tablet)} \textbar{}
\texttt{@include\ sm} \textbar{} \texttt{@include\ respond-to(desktop)}
\textbar{} \texttt{@include\ media-query(\$breakpoint\_tablet,\ null)}
\textbar{}

For example, here is a responsiveness update to the Lunar Resort's
\texttt{\_custom.scss} file:

Old:

\begin{verbatim}
@include respond-to(phone, tablet) {
    html #wrapper #banner #navigation {
    ...
    }
    ...
}
\end{verbatim}

New:

\begin{verbatim}
@include media-query(null, $breakpoint_tablet - 1) {
    html #wrapper #banner #navigation {
    ...
    }
    ...
}
\end{verbatim}

The new media query
\texttt{@include\ media-query(null,\ \$breakpoint\_tablet\ -\ 1)}
replaces the old mixin \texttt{@include\ respond-to(phone,\ tablet)}.

The Liferay JS Theme Toolkit's Gulp \texttt{upgrade} task generates a
file \texttt{\_deprecated\_mixins.scss}. The file provides deprecated
compass mixins that your migrated theme might be using. Consider
upgrading your use of these mixins. Keep the
\texttt{\_deprecated\_mixins.scss} file if you're using any of its
mixins, but delete all unused mixins. If you're not using any of the
mixins, delete the \texttt{\_deprecated\_mixins.scss} file.

You've updated the theme's responsiveness. Next, you'll update its Font
Awesome settings.

\subsubsection{Updating Font Awesome
Icons}\label{updating-font-awesome-icons}

Liferay DXP uses Font Awesome icons extensively. For example, the Lunar
Resort theme's design incorporates Font Awesome icons in its social
media links.

\begin{figure}
\centering
\includegraphics{./images/lunar-resort-social-media-links.png}
\caption{Font Awesome icons facilitate creating social media links.}
\end{figure}

The icons are easy to use in themes too.

In Liferay Portal 6.2, the CSS file \texttt{aui.css} defined the Font
Awesome icon paths. In 7.0, the Sass file \texttt{\_aui\_variables.scss}
defines them.

\noindent\hrulefill

\textbf{Note:} In 7.0, the \texttt{aui.css} file holds the
\texttt{lexicon-base} style import. The
\href{/docs/7-0/reference/-/knowledge_base/r/theme-reference-guide}{Theme
Reference Guide} describes all the Liferay DXP theme files.

\noindent\hrulefill

The top of the \texttt{\_aui\_variables.scss} file must start with the
Font Awesome Icons imports. If you modified the
\texttt{\_aui\_variables.scss} file in your Liferay Portal 6.2 theme,
add these Font Awesome imports to the top of it:

\begin{verbatim}
// Icon paths
$FontAwesomePath: "aui/lexicon/fonts/alloy-font-awesome/font";
$font-awesome-path: "aui/lexicon/fonts/alloy-font-awesome/font";
$icon-font-path: "aui/lexicon/fonts/";
\end{verbatim}

Next, you'll update the theme templates.

\subsection{Updating Theme Templates}\label{updating-theme-templates}

7.0 theme templates are essentially the same as Liferay Portal 6.2 theme
templates. Here are the main changes:

\begin{itemize}
\item
  Velocity templates are now deprecated in favor of FreeMarker
  templates.
\item
  The Dockbar has been replaced and reorganized into a set of three
  distinct menus.
\end{itemize}

Key reasons for using FreeMarker templates and deprecating Velocity
templates are these:

\begin{itemize}
\item
  FreeMarker is developed and maintained regularly, while Velocity is no
  longer actively being developed.
\item
  FreeMarker is faster and supports more sophisticated macros.
\item
  FreeMarker supports using taglibs directly rather than requiring a
  method to represent them. You can pass body content to them,
  parameters, etc.
\end{itemize}

The menus that replace the Dockbar supports a more flexible and
responsive design for creating better user experiences.

You should start by addressing the Velocity templates. Since Velocity
templates have been deprecated, \textbf{you should convert your Velocity
theme templates to FreeMarker}.

If you're using the Liferay JS Theme Toolkit, the \texttt{gulp\ upgrade}
command reports the required theme template changes in the log.

For example, here is the command's output for the Lunar Resort theme:

\begin{verbatim}
----------------------------------------------------------------
Liferay Upgrade (6.2 to 7)
----------------------------------------------------------------

File: portal_normal.ftl
    Warning: <@liferay.dockbar /> is deprecated, replace with
    <@liferay.control_menu /> for new admin controls.
    Warning: not all admin controls will be visible without
    <@liferay.control_menu />
    Warning: ${theme} variable is no longer available in FreeMarker
    templates, see https://goo.gl/9fXzYt for more information.
\end{verbatim}

For all the theme's templates, it suggests replacement code for
deprecated code.

Next, you'll learn how to update various theme templates to 7.0. If you
didn't modify any theme templates, you can skip these sections.

\subsubsection{Updating Portal Normal
FTL}\label{updating-portal-normal-ftl}

The first one to update is the \texttt{portal\_normal.ftl} theme
template. If you didn't customize \texttt{portal\_normal.ftl}, you can
skip this section.

In FreeMarker templates, the new syntax for including taglibs lets you
use them directly rather than accessing them via the \texttt{theme}
variable. The change is described in the
\href{/docs/7-0/reference/-/knowledge_base/r/breaking-changes\#taglibs-are-no-longer-accessible-via-the-theme-variable-in-freemarker}{Breaking
Changes} reference document. All modified \texttt{portal\_normal.ftl}
theme templates must be updated to use the new syntax.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open your modified \texttt{portal\_normal.ftl} file and replace the
  following 6.2 directives with the corresponding 7.0 directives:

  \textbf{FreeMarker Theme Variable Replacements}

  \begin{longtable}[]{@{}
    >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.2209}}
    >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.7791}}@{}}
  \toprule\noalign{}
  \begin{minipage}[b]{\linewidth}\raggedright
  6.2
  \end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
  ~7.0
  \end{minipage} \\
  \midrule\noalign{}
  \endhead
  \bottomrule\noalign{}
  \endlastfoot
  \texttt{\$\{theme.include(top\_head\_include)\}} &
  \texttt{\textless{}@liferay\_util{[}"include"{]}\ page=top\_head\_include\ /\textgreater{}} \\
  \texttt{\$\{theme.include(body\_top\_include)\}} &
  \texttt{\textless{}@liferay\_util{[}"include"{]}\ page=body\_top\_include\ /\textgreater{}} \\
  \texttt{\$\{theme.include(content\_include)\}} &
  \texttt{\textless{}@liferay\_util{[}"include"{]}\ page=content\_include\ /\textgreater{}} \\
  \texttt{\$\{theme.wrapPortlet("portlet.ftl",\ content\_include)\}} &
  \texttt{\textless{}@liferay\_theme{[}"wrap-portlet"{]}\ page="portlet.ftl"\textgreater{}\ \textless{}@liferay\_util{[}"include"{]}\ page=content\_include\ /\textgreater{}\ \textless{}/@\textgreater{}} \\
  \texttt{\$\{theme.include(body\_bottom\_include)\}} &
  \texttt{\textless{}@liferay\_util{[}"include"{]}\ page=body\_bottom\_include\ /\textgreater{}} \\
  \texttt{\$\{theme.include(bottom\_include)\}} &
  \texttt{\textless{}@liferay\_util{[}"include"{]}\ page=bottom\_include\ /\textgreater{}} \\
  \texttt{\$\{theme.getSetting("my-theme-setting")\}} &
  \texttt{\$\{theme\_settings{[}"my-theme-setting"{]}\}} \\
  \texttt{\$\{theme.runtime("56",\ "articleId="\ +\ my\_article\_id)\}}
  &
  \texttt{\textless{}@liferay\_portlet{[}"runtime"{]}\ portletName=}\texttt{"com\_liferay\_journal\_content\_web\_portlet\_JournalContentPortlet"}
  \texttt{queryString="articleId="\ +\ my\_article\_id\ /\textgreater{}} \\
  \end{longtable}
\item
  Replace the following link type.

  Old:

  \texttt{\textless{}a\ href="\#main-content"\ id="skip-to-content"\textgreater{}\textless{}@liferay.language\ key="skip-to-content"\ /\textgreater{}\textless{}/a\textgreater{}}

  New:

  \texttt{\textless{}@liferay\_ui{[}"quick-access"{]}\ contentId="\#main-content"\ /\textgreater{}}.

  The \texttt{liferay-ui:quick-access} tag provides a keyboard shortcut
  to the page's main content.
\item
  Replace all Dockbar references with Control Menu references.

  Old:

\begin{verbatim}
<#if is_signed_in>
        <@liferay.dockbar />
</#if>
\end{verbatim}

  New:

\begin{verbatim}
<@liferay.control_menu />
\end{verbatim}

  The Dockbar was an all-in-one component that contained the page
  administration menus and the user/portal administration menus. This UI
  has since been split and reorganized into three menus:

  \begin{itemize}
  \item
    \emph{The Product Menu}: Manage site and page navigation, content,
    settings and pages for the current site, and navigate to user
    account settings, etc.
  \item
    \emph{The Control Menu}: Configure and add content to the page and
    view the page in a simulation window.
  \item
    \emph{The User Personal Bar}: Display notifications and the user's
    avatar and name.
  \end{itemize}

  \begin{figure}
  \centering
  \includegraphics{./images/upgrading-themes-dockbar.png}
  \caption{The Dockbar was removed in 7.0 and must be replaced with the
  new Control Menu.}
  \end{figure}

  The new design enhances the user experience by providing clear and
  purposeful menus.
\item
  If you used the split Dockbar in your Liferay Portal 6.2 theme, remove
  \texttt{dockbar-split} from the \texttt{body} element's \texttt{class}
  value.

  For example, remove \texttt{dockbar-split} from
  \texttt{\textless{}body\ class="...\ dockbar-split"\textgreater{}}. .
\item
  Remove the page title code shown below:

\begin{verbatim}
<h2 class="page-title">
    <span>${the_title}</span>
</h2>
\end{verbatim}

  Rather than include the page title on every page, it was decided that
  this decision should be left up to developers. With the introduction
  of modularization in themes, this feature can easily be implemented
  however you like.
\item
  To ensure navigation is only rendered when there are pages, wrap the
  \texttt{\textless{}\#include\ "\$\{full\_templates\_path\}/navigation.ftl"\ /\textgreater{}}
  include with an \texttt{if} statement as demonstrated below:

\begin{verbatim}
<#if has_navigation && is_setup_complete>
    <#include "${full_templates_path}/navigation.ftl" />
</#if>
\end{verbatim}
\item
  Finally, replace content \texttt{div} elements (e.g.,
  \texttt{\textless{}div\ \ \ \ \ id="content"\textgreater{}...\textless{}div\textgreater{}})
  with HTML 5 \texttt{section} elements.

  The \texttt{div} element works but the \texttt{section} element is
  more accurate and provides better accessibility for screen readers.

  For example, here's a new content \texttt{section} element:

\begin{verbatim}
<section id="content">
    <h1 class="hide-accessible">${the_title}</h1>
    ...
</section>
\end{verbatim}

  To support accessibility, consider adding an \texttt{h1} element like
  the one above.
\end{enumerate}

\noindent\hrulefill

\textbf{Note}: The Liferay JS Theme Toolkit's \texttt{gulp\ upgrade}
command reports suggested theme template changes.

\noindent\hrulefill

If you modified the navigation template for your theme, follow the steps
in the next section.

\subsubsection{Updating Navigation FTL}\label{updating-navigation-ftl}

Follow these steps to update your modified \texttt{navigation.ftl} file:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Below the
  \texttt{\textless{}nav\ class="\$\{nav\_css\_class\}"\ id="navigation"\ role="navigation"\textgreater{}}
  element, add the following hidden heading for accessibility screen
  readers:

\begin{verbatim}
<h1 class="hide-accessible">
    <@liferay.language key="navigation" />
</h1>
\end{verbatim}
\item
  To access the layout, add the following variable declaration below the
  \texttt{\textless{}\#assign\ nav\_item\_css\_class\ =\ ""\ /\textgreater{}}
  variable declaration:

\begin{verbatim}
<#assign nav_item_layout = nav_item.getLayout() />
\end{verbatim}

  This variable grabs the layout for navigation. You can use this
  variable to retrieve an icon for the navigation menu next.
\item
  To retrieve an icon for the navigation menu, replace the
  \texttt{\$\{nav\_item.icon()\}} variable in the
  \texttt{\textless{}a\ aria-labelledby="layout\_\$\{nav\_item.getLayoutId()\}"...\textless{}/a\textgreater{}}
  anchor with the following element:

\begin{verbatim}
<@liferay_theme["layout-icon"] layout=nav_item_layout />
\end{verbatim}
\end{enumerate}

The navigation template is updated.

That covers most, if not all, of the required theme template changes. If
you modified any other FreeMarker theme templates, you can compare them
with templates in the
\href{https://github.com/liferay/liferay-portal/tree/7.0.x/modules/apps/foundation/frontend-theme/frontend-theme-unstyled/src/main/resources/META-INF/resources/_unstyled/templates}{\texttt{\_unstyled}
theme}. And if your theme uses the Liferay JS Theme Toolkit, refer to
the suggested changes that the \texttt{gulp\ upgrade} command reports.

After updating the theme templates, you can update your theme's
resources importer code.

\subsection{Updating the Resources
Importer}\label{updating-the-resources-importer}

Liferay's resources importer is now an OSGi module in Liferay's Web
Experience application suite. Since the suite is bundled with Liferay
DXP, developers no longer need to download the resources importer
separately.

API changes and upgrades to Bootstrap 3 affect the following resources
importer components:

\begin{itemize}
\tightlist
\item
  Plugin properties
\item
  Web content article files and directory structure
\item
  Sitemap
\end{itemize}

This section shows you how to update these components.

\noindent\hrulefill

\textbf{Note:} The example Lunar Resort theme's resources importer web
content articles have been modified to avoid known issue
\href{https://issues.liferay.com/browse/LPS-64859}{LPS-64859}. Articles
in the Liferay Portal 6.2 theme link to pages in the site's layout. Due
to the page and article import order, the links cause a null pointer
exception. To avoid this issue with the example theme, the offending
links have been removed from its articles.

\noindent\hrulefill

Start updating the plugin properties for the resources importer.

\subsubsection{Updating
liferay-plugin-package.properties}\label{updating-liferay-plugin-package.properties}

If you're upgrading a Plugins SDK theme, follow these instructions to
update resources importer properties. Otherwise, skip this section.

Make the following updates to the theme's
\texttt{liferay-plugin-package.properties} file:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Remove the \texttt{required-deployment-contexts} property.

  The plugin no longer needs this property as the resources importer is
  now an
  \href{https://github.com/liferay/liferay-portal/tree/7.0.x/modules/apps/web-experience/export-import/export-import-resources-importer}{OSGi
  module} built-in and deployed with 7.0.
\item
  Since the group model class's fully-qualified class name has changed,
  replace the \texttt{resources-importer-target-class-name} property's
  value with the following class name:

\begin{verbatim}
com.liferay.portal.kernel.model.Group
\end{verbatim}
\end{enumerate}

Now that the resources importer's properties are configured properly,
you can update your theme's web content.

\subsubsection{Updating Web Content}\label{updating-web-content}

All 7.0 web content articles must be written in XML and have a structure
and template. Article creation requires a structure and article content
rendering requires a template. Follow these steps to update your web
content:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In the \texttt{/resources-importer/journal/articles/} folder, create a
  subfolder, for example \texttt{BASIC\_WEB\_CONTENT}, to hold the basic
  HTML articles.
\item
  Move all basic HTML articles into the folder you just created in step
  1.
\item
  In the \texttt{/resources-importer/journal/templates/} and
  \texttt{/resources-importer/journal/structures/} folders, create a
  subfolder with the same name as the folder you created in step 1.

  For the web content to work properly, the articles, structure, and
  template folder names must match.
\item
  In previous Liferay versions, article structures were written in XML.
  Now they're written in JSON.

  Create a file \texttt{{[}structure-name{]}.json}, for example
  \texttt{BASIC\_WEB\_CONTENT.json}, in the structure subfolder you
  created in the previous step.

  For web content articles that use complicated structures and
  templates, create the structures and templates in Liferay DXP.
\item
  In the JSON file you just created, add a JSON structure for the web
  content. For example, you can use a JSON structure like the one below
  for basic web content articles.

\begin{verbatim}
{
    "availableLanguageIds": [
        "en_US"
    ],
    "defaultLanguageId": "en_US",
    "fields": [
        {
            "label": {
                "en_US": "Content"
            },
            "predefinedValue": {
                "en_US": ""
            },
            "style": {
                "en_US": ""
            },
            "tip": {
                "en_US": ""
            },
            "dataType": "html",
            "fieldNamespace": "ddm",
            "indexType": "keyword",
            "localizable": true,
            "name": "content",
            "readOnly": false,
            "repeatable": false,
            "required": false,
            "showLabel": true,
            "type": "ddm-text-html"
        }
    ]
}
\end{verbatim}

  This structure identifies the articles' language and field settings
  and specifies a \texttt{name} value to identify the content. This
  example structure's content is named \texttt{content}.
\item
  In the template subfolder you created in step 3 (e.g.,
  \texttt{/resources-importer/journal/templates/{[}template-folder-name{]}/}),
  create a FreeMarker template file (e.g.,
  \texttt{{[}template-folder-name{]}.ftl}) and add a method in it to get
  the article's data.

  For example, this method accesses content from the variable named
  \texttt{content} and renders it as HTML:

\begin{verbatim}
${content.getData()}
\end{verbatim}

  You've created the basic web content structure and template.
\item
  Follow this pattern for basic web content articles you convert from
  HTML to XML:

\begin{verbatim}
<?xml version="1.0"?>

<root available-locales="en_US" default-locale="en_US">
        <dynamic-element name="content" type="text_area"
        index-type="keyword" index="0">
                <dynamic-content language-id="en_US">
                        <![CDATA[
                        HTML CONTENT GOES HERE
                        ]]>
                </dynamic-content>
        </dynamic-element>
</root>
\end{verbatim}

  For example, the \texttt{2\ column\ description.html} Lunar Resort
  article's HTML content should be converted to an XML file (e.g.,
  \texttt{2\ column\ description.xml}) whose content looks like this:

\begin{verbatim}
<?xml version="1.0"?>

<root available-locales="en_US" default-locale="en_US">
    <dynamic-element name="content" type="text_area"
    index-type="keyword" index="0">
        <dynamic-content language-id="en_US">
            <![CDATA[
                <div class="container-fluid">
    <div class="span4" id="columnLeft">Out of This World</div>
    <div class="span8" id="columnRight">Come to the Lunar Resort and
    live out your childhood dream of being an astronaut on the Moon. If
    that's not enough incentive, you'll enjoy a luxurious 3 day 2 night
    stay in our fabulous Lunar accommodations. Enjoy a round of Lunar
    Golf on our one of a kind course. Have a blast on our Rover Racing
    track. Make your reservation now. The rest of your life starts
    today!</div>
</div>
]]>
        </dynamic-content>
    </dynamic-element>
</root>
\end{verbatim}
\item
  7.0's migration from Bootstrap 2 to Bootstrap 3 requires that you
  replace all \texttt{div} element \texttt{class} attribute values of
  Bootstrap 2 format \texttt{span{[}number{]}} with values that use the
  Bootstrap 3 format:

\begin{verbatim}
col-[device-size]-[number]
\end{verbatim}

  \texttt{device-size} can be \texttt{xs}, \texttt{sm}, \texttt{md}, or
  \texttt{lg}. \texttt{md} works for most cases. Bootstrap's site at
  \url{https://getbootstrap.com/docs/3.3/css/\#grid} explains the
  Bootstrap 3 grid system

  Continuing with the \texttt{2\ column\ description.xml} article
  example, here is its updated content:

\begin{verbatim}
<?xml version="1.0"?>

<root available-locales="en_US" default-locale="en_US">
    <dynamic-element name="content" type="text_area"
    index-type="keyword" index="0">
        <dynamic-content language-id="en_US">
            <![CDATA[
                <div class="container-fluid">
    <div class="col-md-4" id="columnLeft">Out of This World</div>
    <div class="col-md-8" id="columnRight">Come to the Lunar Resort and
    live out your childhood dream of being an astronaut on the Moon. If
    that's not enough incentive, you'll enjoy a luxurious 3 day 2 night
    stay in our fabulous Lunar accommodations. Enjoy a round of Lunar
    Golf on our one of a kind course. Have a blast on our Rover Racing
    track. Make your reservation now. The rest of your life starts
    today!</div>
</div>
]]>
        </dynamic-content>
    </dynamic-element>
</root>
\end{verbatim}
\end{enumerate}

That's all that is needed for most basic web content articles. If you're
following along with the Lunar Resort example, the updated XML articles
are in the ZIP file's
\texttt{/resources-importer/journal/articles/Basic\ Web\ Content/}
folder.

\noindent\hrulefill

\textbf{Note:} Although Liferay Portal 6.2 used AlloyUI 2.0.x, 7.0 uses
AlloyUI 3.0.x. As a result, you may need to update your code that uses
AlloyUI. Refer to AlloyUI's
\href{http://alloyui.com/examples/}{examples} and
\href{http://alloyui.com/api/}{API docs} for details.

\noindent\hrulefill

Next, you must update your resources importer's sitemap file.

\subsubsection{Updating the Sitemap}\label{updating-the-sitemap}

In Liferay Portal 6.2, portlet IDs were incremental numbers. In 7.0,
they're explicit class names. The new IDs are intuitive and unique. But
you must update your \texttt{sitemap.json} file with the new portlet
IDs.

Some of common portlet IDs are specified in the \texttt{sitemap.json}
example in the
\href{/docs/7-0/tutorials/-/knowledge_base/t/importing-resources-with-a-theme}{Importing
Resources with a Theme} tutorial.

You can also retrieve a portlet's ID from the UI:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In the portlet's \emph{Options} menu, select \emph{Look and Feel
  Configuration}.

  \begin{figure}
  \centering
  \includegraphics{./images/upgrading-themes-look-and-feel-menu.png}
  \caption{You can find the portlet ID in the the \emph{Look and Feel
  Configuration} menu.}
  \end{figure}
\item
  Select the \emph{Advanced Styling} tab.

  The \texttt{Portlet\ ID} value is listed in the blue box.
\end{enumerate}

\begin{figure}
\centering
\includegraphics{./images/upgrading-themes-portlet-id.png}
\caption{The portlet ID is listed within the blue box in the
\emph{Advanced Styling} tab.}
\end{figure}

The
\href{/docs/7-1/reference/-/knowledge_base/r/fully-qualified-portlet-ids}{Portlet
ID quick reference} lists all the default portlet IDs.

Next, you can learn how to update your theme's UI to follow Lexicon
design patterns.

\subsection{Applying Lexicon Design
Patterns}\label{applying-lexicon-design-patterns}

7.0 uses \href{https://liferay.github.io/clay/}{Lexicon}, a web
implementation of Liferay's \href{https://lexicondesign.io/}{Lexicon
Experience Language}. The Lexicon Experience Language provides styling
guidelines and best practices for application UIs. While Lexicon's CSS,
HTML, and JavaScript components enable developers to build
fully-realized UIs quickly and effectively. This section demonstrates
how to apply Lexicon to a form.

For example, this is the Liferay Portal 6.2 Lunar Resort's reservation
form:

\begin{verbatim}
<p>
Thanks for choosing to stay at the Liferay Lunar Resort! Please fill out the
form below to book your stay. We know you have a choice in where to stay on
the
Moon... oh wait no you don't. Thanks for picking us anyways. We'll see you
soon on the Moon!
</p>

<form class="form-horizontal">
        <fieldset>
          <legend>Reservation Form</legend>
          <div class="control-group">
              <label class="control-label" for="inputName">Name</label>
              <div class="controls">
                      <input type="text" id="inputName"
                      placeholder="Enter your Name here" required="required">
                  </div>
          </div>
          <div class="control-group">
              <label class="control-label" for="inputEmail">Email</label>
              <div class="controls">
                  <input type="email" id="inputEmail"
                  placeholder="Enter your E-Mail here" required="required">
              </div>
          </div>
          <div class="control-group">
              <div class="controls">
                  <button type="submit" class="btn">Submit</button>
              </div>
          </div>
        </fieldset>
</form>

<p style="padding-bottom:25px;">
Thanks again for booking with Liferay. When you book with Liferay, you
remember your stay. Please take a moment to fill out our guestbook below.
</p>
\end{verbatim}

The HTML code above uses Bootstrap 2's markup and CSS classes.

Lexicon extends Bootstrap 3. Here's the Lunar Resort form updated to
Lexicon:

\begin{verbatim}
<?xml version="1.0"?>

<root available-locales="en_US" default-locale="en_US">
        <dynamic-element name="content" type="text_area"
        index-type="keyword" index="0">
                <dynamic-content language-id="en_US">
                        <![CDATA[
                                <p>Thanks for choosing to stay at the
                                Liferay Lunar Resort! Please fill out the
                                form below to book your stay. We know you
                                have a choice in where to stay on the Moon...
                                oh wait no you don't. Thanks for picking us
                                anyways. We'll see you soon on the Moon!</p>
<form role="form-horizontal">
        <fieldset>
          <legend>Reservation Form</legend>
          <div class="form-group">
              <label for="inputName">Name</label>
              <input type="text" id="inputName" class="form-control"
              placeholder="Enter your Name here" required="required">
          </div>
          <div class="form-group">
              <label for="inputEmail">Email</label>
              <input type="email" id="inputEmail" class="form-control"
              placeholder="Enter your E-Mail here" required="required">
          </div>
          <div class="form-group">
                  <button type="submit" class="btn btn-primary">Submit
                  </button>
          </div>
        </fieldset>
</form>

<p style="padding-bottom:25px;">Thanks again for booking with Liferay. When
you book with Liferay, you remember your stay. Please take a moment to fill
out our guestbook below.</p>
                        ]]>
                </dynamic-content>
        </dynamic-element>
</root>
\end{verbatim}

The Lexicon updates applied to the form are as follows:

\begin{itemize}
\tightlist
\item
  The \texttt{control-group} classes were updated to \texttt{form-group}
  classes.
\item
  The \texttt{control-label} classes were removed from the
  \texttt{label} elements.
\item
  The \texttt{\textless{}div\ class=""controls\textgreater{}} elements
  were removed.
\item
  The \texttt{form-control} class was added to each \texttt{input}
  element.
\item
  To emphasize the form's submit button, the \texttt{btn-primary} class
  was added to it.
\end{itemize}

You can apply similar Lexicon design patterns to your theme's HTML
files.

You've updated your theme to 7.0! You can deploy it from your theme
project.

Liferay JS Theme Toolkit-based project:

\begin{verbatim}
gulp deploy
\end{verbatim}

Plugins SDK project:

\begin{verbatim}
ant deploy
\end{verbatim}

Now your users can continue enjoying the visual styles you've created in
your upgraded themes.

\subsection{Related Topics}\label{related-topics-12}

\href{/docs/7-0/tutorials/-/knowledge_base/t/themes-generator}{Liferay
Theme Generator}

\href{/docs/7-0/tutorials/-/knowledge_base/t/migrating-a-6-2-theme-to-liferay-7}{Migrating
a theme to 7.0}

{[}Upgrading to 7.0{]}
(/docs/7-0/deploy/-/knowledge\_base/d/upgrading-to-liferay-7)

\section{Upgrading Layout Templates}\label{upgrading-layout-templates-1}

Layout templates for 7.0 differ slightly from layout templates for
Liferay Portal 6. The layout template's rows and columns are affected by
Bootstrap's new grid system syntax.

This tutorial demonstrates the following:

\begin{itemize}
\tightlist
\item
  How to upgrade your layout template to 7.0
\end{itemize}

Upgrading a layout template involves updating its Liferay version and
updating the class syntax for its rows and columns.

Follow these steps to upgrade your layout template:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open your \texttt{liferay-plugin-package.properties} file and update
  the \texttt{liferay-versions} property to \texttt{7.0.0+}:

\begin{verbatim}
liferay-versions=7.0.0+
\end{verbatim}
\item
  Open your layout template's \texttt{.tpl} file and replace
  \texttt{row-fluid} with \texttt{row}, in each row's class value.
\item
  Previously, column size was denoted using a class value of format
  \texttt{span{[}number{]}}. The new Bootstrap grid system uses the
  format \texttt{col-{[}device-size{]}-{[}number{]}}.

  The \texttt{{[}device-size{]}} value must be \texttt{xs}, \texttt{sm},
  \texttt{md}, or \texttt{lg}. In most cases, an \texttt{md} device size
  works well. You can read more about the Bootstrap grid system on their
  site at \url{https://getbootstrap.com/docs/3.3/css/\#grid}.

  The \texttt{{[}number{]}} value must be an integer from \texttt{1} to
  \texttt{12}. A row's width is divisible by twelve; so the combined
  width of a row's columns must equal \texttt{12}.

  Inside the \texttt{.tpl} file, replace each \texttt{span-{[}number{]}}
  class value with \texttt{col-{[}device-size{]}-{[}number{]}}, where
  \texttt{{[}device-size{]}} is \texttt{xs}, \texttt{sm}, \texttt{md},
  or \texttt{lg} and \texttt{{[}number{]}} is an integeter from
  \texttt{1} to \texttt{12}.

  Here's an example column that uses the \texttt{md} device size and a
  column that is a third (\texttt{4/12}) of the row's total width:

\begin{verbatim}
<div class="portlet-column portlet-column-last col-md-4" id="column-3">
\end{verbatim}
\end{enumerate}

As an example, here's Liferay Portal 6 layout template
\href{https://github.com/liferay/liferay-portal/blob/Portal\%206.2.x/portal-web/docroot/layouttpl/custom/1_2_1_columns.tpl}{1\_2\_1\_columns.tpl}
upgraded to 7.0:

\begin{verbatim}
<div class="columns-1-2-1" id="main-content" role="main">
        <div class="portlet-layout row">
                <div class="col-md-12 portlet-column portlet-column-only" 
                id="column-1">
                        $processor.processColumn("column-1", 
                        "portlet-column-content portlet-column-content-only")
                </div>
        </div>

        <div class="portlet-layout row">
                <div class="col-md-6 portlet-column portlet-column-first" 
                id="column-2">
                        $processor.processColumn("column-2", 
                        "portlet-column-content portlet-column-content-first")
                </div>

                <div class="col-md-6 portlet-column portlet-column-last" 
                id="column-3">
                        $processor.processColumn("column-3", 
                        "portlet-column-content portlet-column-content-last")
                </div>
        </div>

        <div class="portlet-layout row">
                <div class="col-md-12 portlet-column portlet-column-only" 
                id="column-4">
                        $processor.processColumn("column-4", 
                        "portlet-column-content portlet-column-content-only")
                </div>
        </div>
</div>
\end{verbatim}

Your layout template is ready to use in 7.0!

\subsection{Related Topics}\label{related-topics-13}

\href{/docs/7-0/tutorials/-/knowledge_base/t/migrating-existing-code-to-liferay-7}{Planning
Plugin Upgrades and Optimizations}

\href{/docs/7-0/tutorials/-/knowledge_base/t/benefits-of-liferay-7-for-liferay-6-developers}{Benefits
of 7.0 for Liferay Portal 6 Developers}

\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-upgrade-planner}{Liferay
Upgrade Planner}

\section{Upgrading Frameworks and
Features}\label{upgrading-frameworks-and-features}

Your upgrade process not only relies on portlet technology, themes, and
customization plugins, but also the frameworks your project leverages.
The following frameworks and their upgrade processes are discussed in
this section:

\begin{itemize}
\tightlist
\item
  JNDI data source usage
\item
  Service Builder service invocation
\item
  Service Builder
\item
  Velocity templates
\end{itemize}

Continue on to learn more about upgrading these frameworks.

\section{Upgrading JNDI Data Source
Usage}\label{upgrading-jndi-data-source-usage}

In Liferay DXP's OSGi environment, you must use the portal's class
loader to load the application server's JNDI classes. An OSGi bundle's
attempt to connect to a JNDI data source without using Liferay DXP's
class loader results in a \texttt{java.lang.ClassNotFoundException}.

For more information on how to do this, see the
\href{/docs/7-0/tutorials/-/knowledge_base/t/connecting-to-data-sources-using-jndi}{Connecting
to JNDI Data Sources} article.

\section{Upgrading Service Builder Service
Invocation}\label{upgrading-service-builder-service-invocation}

When upgrading a portlet leveraging
\href{/docs/7-0/tutorials/-/knowledge_base/t/service-builder}{Service
Builder}, you must first decide if you're building your Service Builder
logic as a WAR or modularizing it.

\noindent\hrulefill

\textbf{Note:} Service Builder portlets automatically migrated to
Liferay Workspace using the Upgrade Planner or Blade CLI's
\texttt{convert} command automatically have its Service Builder logic
converted to API and implementation modules. This is a best practice for
7.0.

\noindent\hrulefill

If you prefer keeping your Service Builder logic as a WAR, you must
implement a service tracker to call services. See the
\href{/docs/7-0/tutorials/-/knowledge_base/t/service-trackers}{Service
Trackers} article for more information.

If you're optimizing your Service Builder logic to invoke Liferay
services from a module, see the
\href{/docs/7-0/tutorials/-/knowledge_base/t/invoking-local-services}{Invoking
Local Services} article for more information.

\section{Upgrading Service Builder}\label{upgrading-service-builder}

7.0 continues to use
\href{/docs/7-0/tutorials/-/knowledge_base/t/service-builder}{Service
Builder}, so you can focus on your application's business logic instead
of its persistence details. It still generates model classes, local and
remote services, and persistence.

Upgrading most Service Builder portlets involves these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \hyperref[step-1-adapt-the-code-to-product-vers-api]{Adapt the code to
  7.0's API}
\item
  \hyperref[step-2-resolve-dependencies]{Resolve dependencies}
\item
  \hyperref[step-3-build-the-services]{Build the services}
\end{enumerate}

Start by adapting the code.

\subsection{Step 1: Adapt the Code to 7.0's
API}\label{step-1-adapt-the-code-to-7.0s-api}

Adapt the portlet to 7.0's API using the Upgrade Planner. When running
the planner's \emph{Fix Upgrade Problems} step, many of the existing
issues are autocorrected. For remaining issues, the planner identifies
code affected by the new API and ways to adapt it.

For example, consider an example portlet with the following compilation
error:

\begin{verbatim}
/html/guestbook/view.jsp(58,1) PWC6131: Attribute total invalid for tag search-container-results according to TLD
\end{verbatim}

The \texttt{view.jsp} file specifies a tag library attribute
\texttt{total} that doesn't exist in 7.0's \texttt{liferay-ui} tag
library. Notice the second attribute \texttt{total}.

\begin{verbatim}
<liferay-ui:search-container-results
    results="<%=EntryLocalServiceUtil.getEntries(scopeGroupId,
                    guestbookId, searchContainer.getStart(),
                    searchContainer.getEnd())%>"
    total="<%=EntryLocalServiceUtil.getEntriesCount(scopeGroupId,
                    guestbookId)%>" />
\end{verbatim}

Remove the \texttt{total} attribute assignment to make the tag like
this:

\begin{verbatim}
<liferay-ui:search-container-results
    results="<%=EntryLocalServiceUtil.getEntries(scopeGroupId,
                    guestbookId, searchContainer.getStart(),
                    searchContainer.getEnd())%>" />
\end{verbatim}

Resolve these error types and others until your code is adapted to the
new API.

\subsection{Step 2: Resolve
Dependencies}\label{step-2-resolve-dependencies}

To adapt your app's dependencies, refer to the
\href{/docs/7-0/tutorials/-/knowledge_base/t/resolving-a-plugins-dependencies}{Resolving
a Plugin's Dependencies} tutorial. Once your dependencies are upgraded,
rebuild your services!

\subsection{Step 3: Build the Services}\label{step-3-build-the-services}

To rebuild your portlet's services, see the
\href{/docs/7-0/tutorials/-/knowledge_base/t/running-service-builder-and-understanding-the-generated-code\#running-service-builder}{Running
Service Builder} article.

An example change where upgrading legacy Service Builder code can
produce differing results is explained below.

A Liferay Portal 6.2 portlet's \texttt{service.xml} file specifies
exception class names in \texttt{exception} elements like this:

\begin{verbatim}
<service-builder package-path="com.liferay.docs.guestbook">
    ...
    <exceptions>
        <exception>GuestbookName</exception>
        <exception>EntryName</exception>
        <exception>EntryMessage</exception>
        <exception>EntryEmail</exception>
    </exceptions>
</service-builder>
\end{verbatim}

In Liferay Portal 6.2, Service Builder generates exception classes to
the path attribute \texttt{package-path} specifies. In 7.0, Service
Builder generates them to \texttt{{[}package-path{]}/exception}.

Old path:

\begin{verbatim}
[package-path]
\end{verbatim}

New path:

\begin{verbatim}
[package-path]/exception 
\end{verbatim}

For example, the example portlet's package path is
\texttt{com.liferay.docs.guestbook}. Its exception class for
\texttt{exception} element \texttt{GuestbookName} is generated to
\texttt{docroot/WEB-INF/service/com/liferay/docs/guestbook/exception}.
Classes that use the exception must import
\texttt{com.liferay.docs.guestbook.exception.GuestbookNameException}. If
this upgrade is required in your Service Builder project, you must
update the references to your portlet's exception classes.

Once your Service Builder portlet is upgraded, deploy it.

\noindent\hrulefill

\textbf{Note:} Service Builder portlets automatically migrated to
Liferay Workspace using the Upgrade Planner or Blade CLI's
\texttt{convert} command automatically has its Service Builder logic
converted to API and implementation modules. This is a best practice for
7.0.

\noindent\hrulefill

The portlet is now available on Liferay DXP. Congratulations on
upgrading a portlet that uses Service Builder!

\section{Migrating Off of Velocity
Templates}\label{migrating-off-of-velocity-templates}

Velocity templates were deprecated in Liferay Portal 7.0 and are now
removed in favor of FreeMarker templates in 7.0. Below are the key
reasons for this move:

\begin{itemize}
\item
  FreeMarker is developed and maintained regularly, while Velocity is no
  longer actively being developed.
\item
  FreeMarker is faster and supports more sophisticated macros.
\item
  FreeMarker supports using taglibs directly rather than requiring a
  method to represent them. You can pass body content to them,
  parameters, etc.
\end{itemize}

Although Velocity templates still work in 7.0, we highly recommend
migrating to FreeMarker templates. For more information on this topic,
see the
\href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-layout-templates}{Upgrading
Layout Templates} section.

\chapter{Upgrading Portlet Plugins}\label{upgrading-portlet-plugins}

All portlet plugin types developed for Liferay Portal 6 can be upgraded
and deployed to 7.0.

Upgrading most portlets involves these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Adapt the code to 7.0's API
\item
  Resolve dependencies
\end{enumerate}

Liferay's Upgrade Planner helps you adapt your code to 7.0's API. And
resolving a portlet's dependencies is straightforward. In most cases,
after you finish the above steps, you can deploy your portlet to Liferay
DXP.

The portlet upgrade tutorials show you how to upgrade the following
common portlets:

\begin{itemize}
\tightlist
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-a-genericportlet}{GenericPortlet}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-a-servlet-based-portlet}{Servlet-based
  portlet}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-a-liferay-mvc-portlet}{Liferay
  MVC Portlet}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-portlets-that-use-service-builder}{Portlet
  that uses Service Builder}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-a-liferay-jsf-portlet}{Liferay
  JSF Portlet}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-a-struts-portlet}{Struts
  Portlet}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-a-spring-mvc-portlet}{Spring
  MVC Portlet}
\end{itemize}

The tutorials provide example portlet source code from before and after
upgrading the example portlet. Each tutorial's steps were applied to the
example portlet. You can refer to example code as you upgrade your
portlet.

Let's get your portlet running on 7.0!

\section{Upgrading a GenericPortlet}\label{upgrading-a-genericportlet}

It's common to create portlets that extend
\texttt{javax.portlet.GenericPortlet}. After all,
\texttt{GenericPortlet} provides a default
\texttt{javax.portlet.Portlet} interface implementation. Upgrading a
\texttt{GenericPortlet} is straightforward and takes only two steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Adapt the portlet to 7.0's API using the Upgrade Planner.
\item
  Resolve its dependencies.
\end{enumerate}

This tutorial demonstrates upgrading a Liferay Plugins SDK 6.2 sample
portlet called \emph{Sample DAO} (project \texttt{sample-dao-portlet}).

\begin{figure}
\centering
\includegraphics{./images/upgrading-portlets-sample-dao-portlet.png}
\caption{The \texttt{sample-dao-portlet} lets users manage food items.}
\end{figure}

The sample portlet lets users view, add, edit, and delete food items
from a listing. For reference, you can download the
\href{https://portal.liferay.dev/documents/113763090/114000186/sample-dao-portlet-pre-7-0-upgrade.zip}{pre-upgraded
portlet code} and the
\href{https://portal.liferay.dev/documents/113763090/114000186/sample-json-portlet-post-7-0-upgrade.zip}{upgraded
code}.

The sample portlet has the following characteristics:

\begin{itemize}
\tightlist
\item
  Extends \texttt{GenericPortlet}
\item
  View layer implemented by JSPs
\item
  Persists models using the Data Access Object (DAO) design pattern
\item
  Specifies database connection information in a properties file
\item
  Manages dependencies via Ant/Ivy
\item
  Developed in a Liferay Plugins SDK 6.2
\end{itemize}

The portlet uses a traditional Plugins SDK portlet project folder
structure.

\begin{figure}
\centering
\includegraphics{./images/upgrading-a-genericportlet-folder-structure.png}
\caption{The \texttt{sample-dao-portlet} project uses a typical Plugins
SDK portlet folder structure}
\end{figure}

Upgrading most \texttt{GenericPortlet} portlets involves these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/fixing-upgrade-problems}{Adapt
  the code to 7.0's API}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/resolving-a-plugins-dependencies}{Resolve
  dependencies}
\end{enumerate}

Since the sample portlet's dependencies haven't changed, upgrading it
involves only adapting the code to 7.0's API. The
\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-upgrade-planner}{Upgrade
Planner} facilitates updating the code and resolving compilation issues
quickly.

\noindent\hrulefill

\textbf{Note}: Refer to tutorial
\href{/docs/7-0/tutorials/-/knowledge_base/t/resolving-a-plugins-dependencies}{Resolving
a Plugin's Dependencies} if you need to adapt to dependency changes.

\noindent\hrulefill

You deploy a \texttt{GenericPortlet} to 7.0 in the same way you deploy
to Portal 6.x. When the plugin WAR file lands in the
\texttt{{[}Liferay\_Home{]}/deploy} folder, Liferay DXP's Plugin
Compatibility Layer converts the WAR to a Web Application Bundle (WAB)
and installs the portlet as a WAB to Liferay DXP's OSGi runtime.

On deploying an upgraded portlet, the server prints messages that
indicate the following portlet status:

\begin{itemize}
\tightlist
\item
  WAR processing
\item
  WAB startup
\item
  Availability to users
\end{itemize}

Deploying the sample portlet produces messages like these:

\begin{verbatim}
20:57:02,571 INFO ... [com.liferay.portal.kernel.deploy.auto.AutoDeployScanner][AutoDeployDir:252] Processing sample-dao-portlet-7.0.0.1.war
...
20:57:12,639 INFO  [fileinstall-C:/portals/liferay-dxp-digital-enterprise-7.0-sp1/osgi/war][BundleStartStopLogger:35] STARTED sample-dao-portlet_7.0.0.1 [996]
...
20:57:13,480 INFO  [fileinstall-C:/portals/liferay-dxp-digital-enterprise-7.0-sp1/osgi/war][PortletHotDeployListener:313] 1 portlet for sample-dao-portlet is available for use 
\end{verbatim}

The portlet is now available on Liferay DXP.

You've learned how to upgrade and deploy a portlet that extends
\texttt{GenericPortlet}. You adapt the code, resolve dependencies, and
deploy the portlet as you always have. It's just that easy!

\textbf{Related Topics}

\href{/docs/7-0/tutorials/-/knowledge_base/t/migrating-traditional-plugins-to-workspace-web-applications}{Migrating
Plugins SDK Projects to Workspace and Gradle}

\href{/docs/7-0/tutorials/-/knowledge_base/t/resolving-a-plugins-dependencies\#using-a-dependency-management-tool}{Using
Dependency Management Tools}

\href{/docs/7-0/tutorials/-/knowledge_base/t/using-the-wab-generator}{Using
the WAB Generator}

\href{/docs/7-0/tutorials/-/knowledge_base/t/optimizing-app-upgrade-processes}{Migrating
Data Upgrade Processes}

\section{Upgrading a Servlet-based
Portlet}\label{upgrading-a-servlet-based-portlet}

Servlet-based portlets have little overhead and are easy to upgrade.
This tutorial shows you how to upgrade them and refers to code from
before and after upgrading a sample servlet-based portlet called
\emph{Sample JSON} (project \texttt{sample-json-portlet}). The portlet
shows a \emph{Click me} link. When users click the link, the Liferay
logo appears.

\begin{figure}
\centering
\includegraphics{./images/upgrading-portlets-sample-servlet-json-initial-view.png}
\caption{The Sample JSON portlet displays text stating \emph{Click me}
that you can click to initiate an action.}
\end{figure}

To get the most from this tutorial, you can download and refer to the
\href{https://portal.liferay.dev/documents/113763090/114000186/sample-json-portlet-pre-7-0-upgrade.zip}{original
sample portlet source code} and the
\href{https://portal.liferay.dev/documents/113763090/114000186/sample-json-portlet-post-7-0-upgrade.zip}{upgraded
source code}.

Here are the sample portlet's characteristics:

\begin{itemize}
\tightlist
\item
  Processes requests using a servlet that extends
  \texttt{javax.servlet.HttpServlet}
\item
  View layer implemented by JSPs
\item
  Processes data using JSON objects
\item
  Relies on manual dependency management
\item
  Depends on third-party libraries that Liferay Portal 6.2 provides
\item
  Embeds additional dependencies in its \texttt{WEB-INF/lib} folder
\item
  Developed in a Liferay Plugins SDK 6.2
\end{itemize}

Follow these steps to upgrade a servlet-based portlet:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/fixing-upgrade-problems}{Adapt
  the code to 7.0's API}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/resolving-a-plugins-dependencies}{Resolve
  dependencies}
\end{enumerate}

The
\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-upgrade-planner}{Upgrade
Planner} makes adapting a portlet's code straightforward, and it
automates much of the process.

The sample portlet relied on Liferay Portal to provide several
dependency JAR files. Here's the \texttt{portal-dependency-jars}
property from the portlet's \texttt{liferay-plugin-package.properties}
file:

\begin{verbatim}
portal-dependency-jars=\
    dom4j.jar,\
    jabsorb.jar,\
    json-java.jar
\end{verbatim}

Instructions for using packages that Liferay DXP exports are found
\href{resolving-a-plugins-dependencies\#using-packages-liferay-portal-exports}{here}.
7.0's core system exports the package this portlet needs from each of
the above dependency JARs.

The upgraded sample portlet continues to specify these JARs in the
\texttt{portal-dependency-jars} property. They're made available to the
portlet at compile time. But to avoid packages from compile time
conflicting with the core system's exported packages, the Liferay
Plugins SDK 7.0 excludes the JARs from the plugin WAR.

Next, deploy your portlet as you always have.

The server prints messages that indicate the following portlet status:

\begin{itemize}
\tightlist
\item
  WAR processing
\item
  WAB startup
\item
  Availability to users
\end{itemize}

\noindent\hrulefill

Note: On deploying the sample upgraded portlet, the
\href{/docs/7-0/tutorials/-/knowledge_base/t/using-the-wab-generator}{WAB
processor} warns that the \texttt{portal-dependency-jars} property is
deprecated.

\begin{verbatim}
 21:40:25,347 WARN  [fileinstall-...][WabProcessor:564] The property "portal-dependency-jars" is deprecated. Specified JARs may not be included in the class path.
\end{verbatim}

For running on 7.0, it's fine to specify
the\texttt{portal-dependency-jars} property per the
\href{resolving-a-plugins-dependencies\#using-packages-liferay-portal-exports}{instructions}
for using packages that @portal@ exports. After upgrading, consider
\href{/docs/7-0/tutorials/-/knowledge_base/t/resolving-a-plugins-dependencies\#using-a-dependency-management-tool}{using
a dependency management tool} in your project. This helps prepare it for
future Liferay DXP versions and facilitates managing dependencies.

\noindent\hrulefill

The portlet is installed to Liferay DXP's OSGi runtime and is available
to users.

\begin{figure}
\centering
\includegraphics{./images/upgrading-portlets-sample-servlet-json.png}
\caption{Clicking on the sample portlet's \emph{Click me} link shows the
Liferay logo.}
\end{figure}

Congratulations! You've upgraded and deployed your servlet-based portlet
to 7.0.

\textbf{Related Topics}

\href{/docs/7-0/tutorials/-/knowledge_base/t/migrating-traditional-plugins-to-workspace-web-applications}{Migrating
Plugins SDK Projects to Workspace and Gradle}

\href{/docs/7-0/tutorials/-/knowledge_base/t/resolving-a-plugins-dependencies\#using-a-dependency-management-tool}{Using
Dependency Management Tools}

\href{/docs/7-0/tutorials/-/knowledge_base/t/using-the-wab-generator}{Using
the WAB Generator}

\href{/docs/7-0/tutorials/-/knowledge_base/t/optimizing-app-upgrade-processes}{Migrating
Data Upgrade Processes}

\section{Upgrading a Liferay MVC
Portlet}\label{upgrading-a-liferay-mvc-portlet}

Liferay's MVC Portlet framework is used extensively in Liferay's
portlets and is a popular choice for Liferay Portal 6.2 portlet
developers. The
\href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/bridges/mvc/MVCPortlet.html}{\texttt{MVCPortlet}
class} is a lightweight extension of
\texttt{javax.portlet.GenericPortlet}. Its \texttt{init} method saves
you from writing a lot of boilerplate code. MVC portlets can upgraded to
7.0 without a hitch.

Upgrading a Liferay MVC Portlet involves these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/fixing-upgrade-problems}{Adapt
  the code to 7.0's API}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/resolving-a-plugins-dependencies}{Resolve
  dependencies}
\end{enumerate}

Liferay's
\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-upgrade-planner}{Upgrade
Planner} identifies code affected by the new API, explains the API
changes and how to adapt to them, and in many cases, provides options
for adapting the code automatically.

After upgrading your portlet, deploy it the same way you always do.

The server prints messages that indicate the following portlet status:

\begin{itemize}
\tightlist
\item
  WAR processing
\item
  WAB startup
\item
  Availability to users
\end{itemize}

You've upgraded and deployed your Liferay MVC Portlet on your 7.0
instance. Have fun showing off your upgraded portlet!

\textbf{Related Topics}

\href{/docs/7-0/tutorials/-/knowledge_base/t/migrating-traditional-plugins-to-workspace-web-applications}{Migrating
Plugins SDK Projects to Workspace and Gradle}

\href{/docs/7-0/tutorials/-/knowledge_base/t/resolving-a-plugins-dependencies\#using-a-dependency-management-tool}{Using
Dependency Management Tools}

\href{/docs/7-0/tutorials/-/knowledge_base/t/using-the-wab-generator}{Using
the WAB Generator}

\href{/docs/7-0/tutorials/-/knowledge_base/t/optimizing-app-upgrade-processes}{Migrating
Data Upgrade Processes}

\section{Upgrading Portlets that use Service
Builder}\label{upgrading-portlets-that-use-service-builder}

7.0 continues to use
\href{/docs/7-0/tutorials/-/knowledge_base/t/service-builder}{Service
Builder}, so you can focus on your application's business logic instead
of its persistence details. It still generates model classes, local and
remote services, and persistence.

This tutorial demonstrates upgrading a Liferay Plugins SDK 6.2 portlet
called Guestbook portlet (project \texttt{guestbook-portlet}). It's from
the
\href{/docs/6-2/tutorials/-/knowledge_base/t/writing-a-data-driven-application}{Writing
a Data-Driven Application} section of the Liferay Portal 6.2 Learning
Path
\href{/docs/6-2/tutorials/-/knowledge_base/t/writing-a-liferay-mvc-application}{Writing
a Liferay MVC Application}.

\begin{figure}
\centering
\includegraphics{./images/upgrade-service-builder-portlet-guestbook.png}
\caption{The Guestbook portlet to model guestbooks and guestbook
entries.}
\end{figure}

To get the most from this tutorial, you can download and refer to the
\href{https://portal.liferay.dev/documents/113763090/114000186/guestbook-portlet-pre-7-0-upgrade.zip}{original
portlet source code} and the
\href{https://portal.liferay.dev/documents/113763090/114000186/guestbook-portlet-post-7-0-upgrade.zip}{upgraded
source code}.

The Guestbook portlet has the following characteristics:

\begin{itemize}
\tightlist
\item
  Extends \texttt{MVCPortlet}
\item
  Separate Model, View, and Controller layers
\item
  Persistence by Hibernate under Service Builder
\item
  View layer implemented by JSPs
\item
  Relies on manual dependency management
\item
  Developed in a Liferay Plugins SDK 6.2
\end{itemize}

Upgrading most Service Builder Portlets involves these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \hyperref[1-adapt-the-code-to-product-vers-api]{Adapt the code to
  7.0's API}
\item
  \hyperref[2-resolve-dependencies]{Resolve dependencies}
\item
  \hyperref[3-build-the-services]{Build the services}
\end{enumerate}

Start by adapting the code.

\subsection{1. Adapt the code to 7.0's
API}\label{adapt-the-code-to-7.0s-api}

Use the
\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-upgrade-planner}{Upgrade
Planner} to update the code and resolve compilation issues quickly. Then
fix any remaining compilation errors manually.

The Guestbook portlet has the following compilation error:

\begin{verbatim}
/html/guestbook/view.jsp(58,1) PWC6131: Attribute total invalid for tag search-container-results according to TLD
\end{verbatim}

The \texttt{view.jsp} file specifies a tag library attribute
\texttt{total} that doesn't exist in 7.0's \texttt{liferay-ui} tag
library. Notice the second attribute \texttt{total}.

\begin{verbatim}
<liferay-ui:search-container-results
    results="<%=EntryLocalServiceUtil.getEntries(scopeGroupId,
                    guestbookId, searchContainer.getStart(),
                    searchContainer.getEnd())%>"
    total="<%=EntryLocalServiceUtil.getEntriesCount(scopeGroupId,
                    guestbookId)%>" />
\end{verbatim}

Remove the \texttt{total} attribute assignment to make the tag like
this:

\begin{verbatim}
<liferay-ui:search-container-results
    results="<%=EntryLocalServiceUtil.getEntries(scopeGroupId,
                    guestbookId, searchContainer.getStart(),
                    searchContainer.getEnd())%>" />
\end{verbatim}

That's the Guestbook portlet's only compilation error you need to fix
manually.

\subsection{2. Resolve dependencies}\label{resolve-dependencies}

Since the Guestbook portlet's dependencies haven't changed, there aren't
any dependencies to resolve.

If you need to adapt a portlet's dependencies, refer to tutorial
\href{/docs/7-0/tutorials/-/knowledge_base/t/resolving-a-plugins-dependencies}{Resolving
a Plugin's Dependencies}.

\subsection{3. Build the services}\label{build-the-services}

\href{/docs/7-0/tutorials/-/knowledge_base/t/running-service-builder-and-understanding-the-generated-code}{Build
the services} as you did in Liferay Portal 6.2.

The Guestbook portlet's \texttt{service.xml} file specifies exception
class names in \texttt{exception} elements.

\begin{verbatim}
<service-builder package-path="com.liferay.docs.guestbook">
    ...
    <exceptions>
        <exception>GuestbookName</exception>
        <exception>EntryName</exception>
        <exception>EntryMessage</exception>
        <exception>EntryEmail</exception>
    </exceptions>
</service-builder>
\end{verbatim}

In Liferay Portal 6.2, Service Builder generates exception classes to
the path attribute \texttt{package-path} specifies. In 7.0, Service
Builder generates them to \texttt{{[}package-path{]}/exception}.

Old path:

\begin{verbatim}
[package-path]
\end{verbatim}

New path:

\begin{verbatim}
[package-path]/exception 
\end{verbatim}

For example, the Guestbook portlet's package path is
\texttt{com.liferay.docs.guestbook}. Its exception class for
\texttt{exception} element \texttt{GuestbookName} is generated to
\texttt{docroot/WEB-INF/service/com/liferay/docs/guestbook/exception}.
Classes that use the exception must import
\texttt{com.liferay.docs.guestbook.exception.GuestbookNameException}.

Update references to your portlet's exception classes.

Deploy the portlet as you normally would. The server prints messages
indicating the following portlet status:

\begin{itemize}
\tightlist
\item
  WAR processing
\item
  WAB startup
\item
  Availability to users
\end{itemize}

Deploying the Guestbook portlet produces these messages:

\begin{verbatim}
19:36:27,591 INFO  [RMI TCP Connection(27)-192.168.1.110][BaseAutoDeployListener:42] Copying portlets for C:\portals\liferay-ce-portal-7.0-ga3-upgrading-portlets\tomcat-8.0.32\temp\20170710193627556LFQNRFGO\guestbook-portlet-7.0.0.1.war
19:36:27,973 INFO  [RMI TCP Connection(27)-192.168.1.110][BaseDeployer:873] Deploying guestbook-portlet-7.0.0.1.war
19:36:29,449 INFO  [RMI TCP Connection(27)-192.168.1.110][BaseAutoDeployListener:50] Portlets for C:\portals\liferay-ce-portal-7.0-ga3-upgrading-portlets\tomcat-8.0.32\temp\20170710193627556LFQNRFGO\guestbook-portlet-7.0.0.1.war copied successfully
19:36:31,231 INFO  [pool-23-thread-2][BundleStartStopLogger:35] STARTED guestbook-portlet_7.0.0.1 [496]
19:36:31,459 INFO  [pool-23-thread-2][HotDeployImpl:226] Deploying guestbook-portlet from queue
19:36:31,459 INFO  [pool-23-thread-2][PluginPackageUtil:1006] Reading plugin package for guestbook-portlet
10-Jul-2017 19:36:31.470 INFO [pool-23-thread-2] org.apache.catalina.core.ApplicationContext.log Initializing Spring root WebApplicationContext
19:36:31,934 INFO  [pool-23-thread-2][PortletHotDeployListener:202] Registering portlets for guestbook-portlet
19:36:32,008 INFO  [pool-23-thread-2][PortletHotDeployListener:331] 1 portlet for guestbook-portlet is available for use
\end{verbatim}

The portlet is now available on Liferay DXP.

Congratulations on upgrading and deploying a portlet that uses Service
Builder.

\subsection{Related Topics}\label{related-topics-14}

\href{/docs/7-0/tutorials/-/knowledge_base/t/migrating-traditional-plugins-to-workspace-web-applications}{Migrating
Plugins SDK Projects to Workspace and Gradle}

\href{/docs/7-0/tutorials/-/knowledge_base/t/resolving-a-plugins-dependencies\#using-a-dependency-management-tool}{Using
Dependency Management Tools}

\href{/docs/7-0/tutorials/-/knowledge_base/t/using-the-wab-generator}{Using
the WAB Generator}

\href{/docs/7-0/tutorials/-/knowledge_base/t/optimizing-app-upgrade-processes}{Migrating
Data Upgrade Processes}

\section{Upgrading a Liferay JSF
Portlet}\label{upgrading-a-liferay-jsf-portlet}

Liferay JSF portlets are easy to upgrade and require few changes. They
interface with the
\href{/docs/7-0/reference/-/knowledge_base/r/liferay-faces}{Liferay
Faces} project, which encapsulates Liferay DXP's Java API and JavaScript
code. Because of this, upgrading JSF portlets to 7.0 requires only
updating dependencies.

There are two ways to find a JSF portlet's dependencies for 7.0:

\begin{itemize}
\tightlist
\item
  The \url{http://liferayfaces.org/} home page lets you look up the
  dependencies (Gradle or Maven) by Liferay DXP version, JSF version,
  and component suites.
\item
  The
  \href{/docs/7-0/reference/-/knowledge_base/r/liferay-faces-version-scheme}{Liferay
  Faces Version Scheme} article's tables list artifacts by Liferay DXP
  version, JSF version, portlet version, and AlloyUI and Metal component
  suite version.
\end{itemize}

In this tutorial, you'll see how easy it is to upgrade a Liferay Portal
6.2 JSF portlet (JSF 2.2) to 7.0 by upgrading the sample JSF Applicant
portlet. This portlet provides a job application users can submit.

\begin{figure}
\centering
\includegraphics{./images/jsf-applicant-6-2.png}
\caption{The JSF Applicant portlet provides a job application for users
to submit.}
\end{figure}

For reference, you can download the
\href{/documents/10184/656312/jsf-applicant-portlet-6.2/b5e38053-229c-98db-a05e-ebccbcc6ce6b}{pre-upgraded
portlet code} and the
\href{/documents/10184/656312/jsf-applicant-portlet-7.0/10e4c0d3-51a0-4605-e7e9-5b306f9701fc}{upgrade
portlet code}. This sample project uses Maven.

Follow these steps to upgrade your Liferay JSF portlet.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open your Liferay JSF portlet's build file (e.g., \texttt{pom.xml},
  \texttt{build.gradle}) to where the dependencies are configured.
\item
  Navigate to the \url{http://liferayfaces.org/} site and generate a
  dependency list by choosing the environment to which you want to
  upgrade your portlet.

  \begin{figure}
  \centering
  \includegraphics{./images/jsf-dependency-generation.png}
  \caption{The Liferay Faces site gives you options to generate
  dependencies for many environments.}
  \end{figure}
\item
  Compare the generated dependencies with your portlet's dependencies
  and make any necessary updates. For the sample JSF Applicant portlet,
  only one Liferay Faces dependency requires updating:

\begin{verbatim}
<dependency>
    <groupId>com.liferay.faces</groupId>
    <artifactId>com.liferay.faces.bridge.ext</artifactId>
    <version>3.0.0</version>
</dependency>
\end{verbatim}

  The Liferay Faces Bridge EXT dependency must be updated to version
  5.0.0 for 7.0. The updated dependency should look like this:

\begin{verbatim}
<dependency>
    <groupId>com.liferay.faces</groupId>
    <artifactId>com.liferay.faces.bridge.ext</artifactId>
    <version>5.0.0</version>
</dependency>
\end{verbatim}
\end{enumerate}

That's it! Your Liferay JSF portlet is upgraded and deployable to 7.0!

You deploy a Liferay JSF portlet to 7.0 the same way you deploy to
Portal 6.x. When the plugin WAR file lands in the
\texttt{{[}Liferay\_Home{]}/deploy} folder, Liferay DXP's Plugin
Compatibility Layer converts the WAR to a Web Application Bundle (WAB)
and installs the portlet as a WAB to Liferay DXP's OSGi runtime.

On deploying an upgraded portlet, the server prints messages that
indicate the following portlet status:

\begin{itemize}
\tightlist
\item
  WAR processing
\item
  WAB startup
\item
  Availability to users
\end{itemize}

Deploying a Liferay JSF portlet produces messages like these:

\begin{verbatim}
13:41:43,690 INFO ... [com.liferay.portal.kernel.deploy.auto.AutoDeployScanner][AutoDeployDir:252] Processing com.liferay.faces.demo.jsf.applicant.portlet-1.0.war
...
13:42:03,522 INFO  [fileinstall-C:/liferay-ce-portal-7.0-ga4/osgi/war][BundleStartStopLogger:35] STARTED com.liferay.faces.demo.jsf.applicant.portlet-1.0_4.1.0 [503]
...
13:42:05,169 INFO  [fileinstall-C:/liferay-ce-portal-7.0-ga4/osgi/war][PortletHotDeployListener:293] 1 portlet for com.liferay.faces.demo.jsf.applicant.portlet-1.0 is available for use
\end{verbatim}

After the portlet deployment is complete, it's available on Liferay DXP.

You've learned how to upgrade and deploy a Liferay JSF portlet. You
resolved dependencies and deployed the portlet as you always have. It's
just that easy!

\section{Upgrading a Struts Portlet}\label{upgrading-a-struts-portlet}

Struts is a stable, widely adopted framework that implements the Model
View Controller (MVC) design pattern. If you have a Struts portlet for
Liferay Portal 6.2, you can upgrade it to 7.0.

Upgrading Struts portlets to 7.0 is easier than you might think. Liferay
DXP lets you continue working with Struts portlets as Java EE web
applications. On deploying a Struts portlet Web Application aRchive
(WAR), Liferay DXP's Web Application Bundle (WAB) Generator creates an
OSGi module (bundle) for the portlet and installs it to Liferay's OSGi
framework. The Struts portlet behaves just as it did in 6.2 on your 7.0
site.

This tutorial demonstrates how to upgrade a portlet that uses the Struts
1 Framework and refers to Liferay's Sample Struts portlet (Sample
Struts) as an example. Sample Struts uses several Struts features to
show page navigation, \texttt{Action} and \texttt{ActionForm} Controller
classes, exceptions, and more.

\begin{figure}
\centering
\includegraphics{./images/upgrading-struts-portlets.png}
\caption{The Sample Struts portlet's charts compare fictitious soft
drink survey results.}
\end{figure}

Here are the sample portlet's characteristics:

\begin{itemize}
\tightlist
\item
  Model class (\texttt{Book})
\item
  View comprised of JSPs that leverage Struts tag libraries
\item
  \texttt{Action} classes (Controllers) for handling requests and
  responses
\item
  \texttt{ActionForm} classes for interacting with models and forwarding
  requests to \texttt{Action}s
\item
  Visual component reuse with Tiles
\item
  Internationalization using Action Messages and resource bundles
\item
  Form validation using the Validator Framework
\item
  Error management through Action Errors
\end{itemize}

You can follow this tutorial to upgrade your Struts portlet. Along the
way, you can examine the Sample Struts portlet source code from before
and after its upgrade:

\begin{itemize}
\item
  \href{https://portal.liferay.dev/documents/113763090/114000186/sample-struts-portlet-pre-7-0-upgrade.zip}{Liferay
  Portal 6.2 Sample Struts portlet code}
\item
  \href{https://portal.liferay.dev/documents/113763090/114000186/sample-struts-portlet-post-7-0-upgrade.zip}{7.0
  Sample Struts portlet code}
\end{itemize}

Here's the Sample Struts portlet's folder structure:

\begin{itemize}
\tightlist
\item
  \texttt{sample-struts-portlet}

  \begin{itemize}
  \tightlist
  \item
    \texttt{docroot/}

    \begin{itemize}
    \tightlist
    \item
      \texttt{html/portlet/sample\_struts\_portlet/} → JSPs
    \item
      \texttt{WEB-INF/}

      \begin{itemize}
      \tightlist
      \item
        \texttt{lib/} → Required third-party libraries unavailable in
        the Liferay DXP system
      \item
        \texttt{src/}

        \begin{itemize}
        \tightlist
        \item
          \texttt{com/liferay/samplestruts/model/} → Model classes
        \item
          \texttt{com/liferay/samplestruts/servlet/} → Test servlet and
          servlet context listener
        \item
          \texttt{com/liferay/samplestruts/struts/}

          \begin{itemize}
          \tightlist
          \item
            \texttt{action/} → \texttt{Action} classes that return View
            pages to the client
          \item
            \texttt{form/} → \texttt{ActionForm} classes for model
            interaction
          \item
            \texttt{render/} → \texttt{Action} classes that present
            additional pages and handle input
          \item
            \texttt{SampleException.java} → Exception class
          \end{itemize}
        \item
          \texttt{content/test/} → Resource bundles
        \item
          \texttt{META-INF/} → Javadoc
        \end{itemize}
      \item
        \texttt{tld/} → Tag library definitions
      \item
        \texttt{liferay-display.xml} → Sets the application category
      \item
        \texttt{liferay-plugin-package.properties} → Sets metadata and
        portal dependencies
      \item
        \texttt{liferay-portlet.xml} → Maps descriptive role names to
        roles
      \item
        \texttt{liferay-releng.properties} → (internal) Release
        properties
      \item
        \texttt{portlet.xml} → Defines the portlet and its
        initialization parameters and security roles
      \item
        \texttt{struts-config.xml} → Struts configuration
      \item
        \texttt{tiles-defs.xml} → Struts Tile definitions
      \item
        \texttt{validation.xml} → Defines form inputs for validation
      \item
        \texttt{validation-rules.xml} → Struts validation rules
      \item
        \texttt{web.xml} → Web application descriptor
      \end{itemize}
    \end{itemize}
  \item
    \texttt{build.xml} → Apache Ant build file
  \end{itemize}
\end{itemize}

Upgrading a Struts portlet involves these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Adapt the code to Liferay 7.0's API
\item
  Resolve dependencies
\end{enumerate}

\subsection{Adapting the code to Liferay 7.0's
API}\label{adapting-the-code-to-liferay-7.0s-api}

Liferay's
\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-upgrade-planner}{Upgrade
Planner} identifies code affected by the new API, explains the API
changes and how to adapt to them, and in many cases, provides options
for adapting the code automatically.

Adapting the Sample Struts portlet's code is straightforward. Resolving
its dependencies is more involved.

\subsection{Resolving dependencies}\label{resolving-dependencies-1}

The Liferay Portal 6.2 Sample Struts portlet depends on Liferay Portal
to provide required third-party libraries and tag library definitions
(TLDs). The \texttt{portal-dependency-jars} and
\texttt{portal-dependency-tlds} properties in the portlet's
\texttt{liferay-plugin-package.properties} specifies them:

\begin{verbatim}
portal-dependency-jars=\
    antlr2.jar,\
    commons-beanutils.jar,\
    commons-collections.jar,\
    commons-digester.jar,\
    commons-fileupload.jar,\
    commons-io.jar,\
    commons-lang.jar,\
    commons-validator.jar,\
    jcommon.jar,\
    jfreechart.jar,\
    oro.jar,\
    portals-bridges.jar,\
    struts.jar

portal-dependency-tlds=\
    struts-bean.tld,\
    struts-bean-el.tld,\
    struts-html.tld,\
    struts-html-el.tld,\
    struts-logic.tld,\
    struts-logic-el.tld,\
    struts-nested.tld,\
    struts-tiles.tld,\
    struts-tiles-el.tld
\end{verbatim}

Resolving the tag libraries is easy.

\subsubsection{Resolving Tag Library
Definitions}\label{resolving-tag-library-definitions}

7.0 continues to provide many of the same TLDs Liferay Portal 6.2
provided.

If the 7.0 application's \texttt{WEB-INF/tld} folder contains a TLD you
need, add it to your portlet's \texttt{portal-dependency-tlds} property
in the \texttt{liferay-plugin-package.properties} file. If the folder
doesn't contain the TLD, find the TLD on the web, download it, and add
it to your portlet's \texttt{WEB-INF/tld} folder.

\subsubsection{Resolving Third-Party
Libraries}\label{resolving-third-party-libraries}

Third-party libraries listed as \texttt{portal-dependency-jars} in a 6.x
portlet's \texttt{liferay-plugin-package.properties} file might not be
provided by 7.0. Providing fewer libraries streamlines Liferay DXP.
Liferay DXP has replaced some of its libraries with newer ones.

7.0 exposes (exports) Java packages instead of sharing JAR content
wholesale. If you need packages Liferay DXP doesn't export, you can find
and download the artifact (JAR) that provides them and add it to your
portlet's \texttt{docroot/WEB-INF/lib} folder.

Here are steps for resolving the Sample Struts portlet's Java package
dependencies:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Liferay DXP doesn't export Antlr packages. Replace the portlet's JAR
  file \texttt{antlr2.jar} with newer JAR \texttt{antlr.jar} from
  \href{https://search.maven.org/}{Maven Central}.
\item
  Liferay DXP doesn't export packages from \texttt{portals-bridges.jar}.
  Replace the portlet's JAR file \texttt{portals-bridges.jar} with these
  JARs from \href{https://search.maven.org/}{Maven Central}:

  \begin{itemize}
  \tightlist
  \item
    \texttt{portals-bridges-common.jar}
  \item
    \texttt{portals-bridges-struts.jar}
  \end{itemize}
\item
  Liferay DXP doesn't export packages from \texttt{struts.jar}. Replace
  the portlet's JAR file \texttt{struts.jar} with the following ones
  from \href{https://search.maven.org/}{Maven Central}:

  \begin{itemize}
  \tightlist
  \item
    \texttt{struts-taglib.jar}
  \item
    \texttt{struts-tiles.jar}
  \end{itemize}
\item
  The \texttt{Import-Packages} heading in the
  \texttt{com.liferay.portal.bootstrap} module's
  \href{https://github.com/liferay/liferay-portal/blob/7.0.x/modules/core/portal-bootstrap/system.packages.extra.bnd}{\texttt{system.packages.extra.bnd}
  file} lists the following JAR files Sample Struts requires. Since the
  bootstrap module exports packages from these JARs, add their names to
  the \texttt{portal-dependency-jars} property in the portlet's
  \texttt{liferay-plugin-package.properties} file. :

  \begin{itemize}
  \tightlist
  \item
    \texttt{commons-beanutils.jar}
  \item
    \texttt{commons-collections.jar}
  \item
    \texttt{commons-lang.jar}
  \end{itemize}
\item
  Add all the rest of the JARs the Sample Struts portlet depends on to
  the portlet's \texttt{WEB-INF/lib} folder.
\end{enumerate}

The following table summarizes the sample portlet's Java dependency
resolution.

\textbf{Sample Struts Portlet's Dependency Resolution:}

JAR \textbar{}
\href{https://github.com/liferay/liferay-portal/blob/7.0.x/modules/core/portal-bootstrap/system.packages.extra.bnd}{System
exports the packages} theportletneeds from this JAR? \textbar{}
Resolution \textbar{} \texttt{antlr.jar} \textbar{} No \textbar{} add to
\texttt{WEB-INF/lib} \texttt{commons-beanutils.jar} \textbar{} Yes
\textbar{} List in \texttt{portal-dependency-jars} \textbar{}
\texttt{commons-collections.jar} \textbar{} Yes \textbar{} List in
\texttt{portal-dependency-jars} \textbar{} \texttt{commons-digester.jar}
\textbar{} No \textbar{} add to \texttt{WEB-INF/lib} \textbar{}
\texttt{commons-fileupload.jar} \textbar{} No \textbar{} add to
\texttt{WEB-INF/lib} \textbar{} \texttt{commons-io.jar} \textbar{} No
\textbar{} add to \texttt{WEB-INF/lib} \textbar{}
\texttt{commons-lang.jar} \textbar{} Yes \textbar{} List in
\texttt{portal-dependency-jars} \textbar{}
\texttt{commons-validator.jar} \textbar{} No \textbar{} Add to
\texttt{WEB-INF/lib} \textbar{} \texttt{jcommon.jar} \textbar{} No
\textbar{} Add to \texttt{WEB-INF/lib} \textbar{}
\texttt{jfreechart.jar} \textbar{} No \textbar{} Add to
\texttt{WEB-INF/lib} \textbar{} \texttt{oro.jar} \textbar{} No
\textbar{} Add to \texttt{WEB-INF/lib} \textbar{}
\texttt{portals-bridges-common.jar} \textbar{} No \textbar{} Add to
\texttt{WEB-INF/lib} \textbar{} \texttt{portals-bridges-struts.jar}
\textbar{} No \textbar{} Add to \texttt{WEB-INF/lib} \textbar{}
\texttt{struts-core.jar} \textbar{} No \textbar{} Add to
\texttt{WEB-INF/lib} \textbar{} \texttt{struts-extras.jar} \textbar{} No
\textbar{} Add to \texttt{WEB-INF/lib} \textbar{}
\texttt{struts-taglib.jar} \textbar{} No \textbar{} Add to
\texttt{WEB-INF/lib} \textbar{} \texttt{struts-tiles.jar} \textbar{} No
\textbar{} Add to \texttt{WEB-INF/lib} \textbar{}

\noindent\hrulefill

Note: The official
\href{https://github.com/liferay/liferay-plugins/tree/master/portlets/sample-struts-portlet}{Sample
Struts portlet} for 7.0 uses
\href{/docs/7-0/tutorials/-/knowledge_base/t/resolving-a-plugins-dependencies\#using-a-dependency-management-tool}{Apache
Ant/Ivy} to manage dependencies.

\noindent\hrulefill

For more details on resolving dependencies, see the tutorial
\href{/docs/7-0/tutorials/-/knowledge_base/t/resolving-a-plugins-dependencies}{Resolving
a Plugin's Dependencies}.

You've resolved the Sample Struts portlet's dependencies. It's ready to
deploy.

\noindent\hrulefill

\textbf{Important}: Setting Portal property
\texttt{jsp.page.context.force.get.attribute} (described in the
\href{@platform-ref@/7.0-latest/propertiesdoc/portal.properties.html\#JSP}{JSP
section}) to \texttt{true} (default) forces calls to
\texttt{com.liferay.taglib.servlet.\ \ PageContextWrapper\#findAttribute(String)}
to use \texttt{getAttribute(String)}. Although this improves performance
by avoiding unnecessary fall-backs, it can cause attribute lookup
problems in Struts portlets. To use Struts portlets in your sites, makes
sure to set the Portal property
\texttt{jsp.page.context.force.get.attribute} to \texttt{false} in a
file \texttt{{[}Liferay-Home{]}/portal-ext.properties}.

\begin{verbatim}
 jsp.page.context.force.get.attribute=false
\end{verbatim}

\noindent\hrulefill

Deploy the Struts portlet as you normally would. The server prints
messages indicating the following portlet status:

\begin{itemize}
\tightlist
\item
  WAR processing
\item
  WAB startup
\item
  Availability to users
\end{itemize}

Deploying the Sample Struts portlet produces these messages:

\begin{verbatim}
00:15:20,344 INFO  [com.liferay.portal.kernel.deploy.auto.AutoDeployScanner][AutoDeployDir:252] Processing sample-struts-portlet-7.0.0.1.war
00:15:26,871 INFO  [fileinstall-C:/portals/liferay-dxp-digital-enterprise-7.0-sp1/osgi/war][BaseAutoDeployListener:42] Copying portlets for C:\portals\liferay-dxp-digital-enterprise-7.0-sp1\tomcat-8.0.32\temp\20170727241526847GURDCOLU\sample-struts-portlet-7.0.0.1.war
00:15:27,282 INFO  [fileinstall-C:/portals/liferay-dxp-digital-enterprise-7.0-sp1/osgi/war][BaseDeployer:863] Deploying sample-struts-portlet-7.0.0.1.war
00:15:29,627 INFO  [fileinstall-C:/portals/liferay-dxp-digital-enterprise-7.0-sp1/osgi/war][BaseAutoDeployListener:50] Portlets for C:\portals\liferay-dxp-digital-enterprise-7.0-sp1\tomcat-8.0.32\temp\20170727241526847GURDCOLU\sample-struts-portlet-7.0.0.1.war copied successfully
00:15:29,644 WARN  [fileinstall-C:/portals/liferay-dxp-digital-enterprise-7.0-sp1/osgi/war][WabProcessor:564] The property "portal-dependency-jars" is deprecated. Specified JARs may not be included in the class path.
00:15:33,123 INFO  [fileinstall-C:/portals/liferay-dxp-digital-enterprise-7.0-sp1/osgi/war][BundleStartStopLogger:35] STARTED sample-struts-portlet_7.0.0.1 [1230]
00:15:34,063 INFO  [fileinstall-C:/portals/liferay-dxp-digital-enterprise-7.0-sp1/osgi/war][HotDeployImpl:226] Deploying sample-struts-portlet from queue
00:15:34,065 INFO  [fileinstall-C:/portals/liferay-dxp-digital-enterprise-7.0-sp1/osgi/war][PluginPackageUtil:1007] Reading plugin package for sample-struts-portlet
00:15:34,106 INFO  [fileinstall-C:/portals/liferay-dxp-digital-enterprise-7.0-sp1/osgi/war][PortletHotDeployListener:201] Registering portlets for sample-struts-portlet
00:15:34,424 INFO  [fileinstall-C:/portals/liferay-dxp-digital-enterprise-7.0-sp1/osgi/war][PortletHotDeployListener:313] 1 portlet for sample-struts-portlet is available for use
\end{verbatim}

The Struts portlet is available on your Liferay DXP instance.

Congratulations on upgrading your Struts portlet to 7.0!

\subsection{Related Topics}\label{related-topics-15}

\href{/docs/7-0/tutorials/-/knowledge_base/t/using-the-wab-generator}{Using
the WAB Generator}

\href{/docs/7-0/tutorials/-/knowledge_base/t/resolving-a-plugins-dependencies\#using-a-dependency-management-tool}{Using
Dependency Management Tools}

\section{Upgrading a Spring MVC
portlet}\label{upgrading-a-spring-mvc-portlet}

The
\href{https://docs.spring.io/spring/docs/current/spring-framework-reference/html/portlet.html}{Spring
Portlet MVC framework} facilitates injecting dependencies and
implementing the Model View Controller pattern in portlets. If you use
this framework in a portlet for Liferay Portal 6.x, you can upgrade it
to 7.0.

This tutorial demonstrates upgrading a Spring MVC portlet called My
Spring MVC (project \texttt{my-spring-mvc-portlet}). It's a bare-bones
portlet created from the Plugins SDK's \texttt{spring\_mvc} template.

\begin{figure}
\centering
\includegraphics{./images/upgraded-spring-mvc-portlet.png}
\caption{My Spring MVC portlet shows its name and Liferay DXP's
information.}
\end{figure}

To follow along, download and refer to the
\href{https://portal.liferay.dev/documents/113763090/114000186/my-spring-mvc-portlet-pre-7-0-upgrade.zip}{original
source code} and the
\href{https://portal.liferay.dev/documents/113763090/114000186/my-spring-mvc-portlet-post-7-0-upgrade.zip}{upgraded
source code}.

The figure below shows the \texttt{my-spring-mvc-portlet} project.

\begin{figure}
\centering
\includegraphics{./images/upgrading-spring-mvc-portlets-folder-structure.png}
\caption{The \texttt{my-spring-mvc-portlet} project has traditional
Liferay plugin files, Spring Portlet MVC application contexts (in
\texttt{spring-context/}), and a controller class
\texttt{MySpringMVCPortletviewController}.}
\end{figure}

These files have Spring-related content:

\begin{itemize}
\tightlist
\item
  \texttt{view.jsp} → Shows the portlet's name and Liferay DXP's release
  information.
\item
  \texttt{my-spring-mvc-portlet.xml} → Liferay DXP uses this context
  file for the portlet.
\item
  \texttt{portlet-applications-context.xml} → Spring's
  \texttt{SpringContextLoaderListener} class uses this context file.
\item
  \texttt{MySpringMVCPortletviewController} → Maps \texttt{VIEW}
  requests to the \texttt{view.jsp} and assigns Liferay DXP release
  information to a model attribute.
\item
  \texttt{portlet.xml} → References context configuration file
  \texttt{my-spring-mvc-portlet.xml} and specifies a dispatcher for
  registered portlet request handlers.
\item
  \texttt{web.xml} → References context configuration file
  \texttt{portlet-application-context.xml} and specifies a
  \texttt{ViewRendererServlet} to convert portlet requests and responses
  to HTTP servlet requests and responses.
\end{itemize}

Here are the Spring MVC portlet upgrade steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Adapt the code to Liferay 7.0's API
\item
  Resolve dependencies
\end{enumerate}

\subsection{Adapt the code to Liferay 7.0's
API}\label{adapt-the-code-to-liferay-7.0s-api}

The
\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-upgrade-planner}{Upgrade
Planner} facilitates updating the code and resolving compilation issues
quickly.

The Upgrade Planner detects if the value of the
\texttt{liferay-versions} property in your plugin's
\texttt{liferay-plugin-package.properties} file needs updating and it
provides an option to fix it automatically. This is the only code
adaptation required by \texttt{my-spring-mvc-portlet}.

\subsection{Resolve Dependencies}\label{resolve-dependencies-1}

In Liferay Portal 6.2, \texttt{my-spring-mvc-portlet} leveraged Portal's
JARs by specifying them in the
\texttt{liferay-plugin-package.properties} file's
\texttt{portal-dependency-jars} property. Since the property is
deprecated in 7.0, you should acquire dependencies using a dependency
management framework, such as Gradle, Maven, or Apache Ant/Ivy.

\href{/docs/7-0/tutorials/-/knowledge_base/t/migrating-traditional-plugins-to-workspace-web-applications}{Converting
the sample portlet plugin from a traditional plugin to a Liferay
Workspace web application} facilitated resolving its dependencies.

Here's the updated \texttt{my-spring-mvc-portlet}'s
\texttt{build.gradle} file:

\begin{verbatim}
dependencies {
    compileOnly group: 'aopalliance', name: 'aopalliance', version: '1.0'
    compileOnly group: 'commons-logging', name: 'commons-logging', version: '1.2'
    compileOnly group: "com.liferay.portal", name: "com.liferay.portal.kernel", version: "2.0.0"
    compileOnly group: "javax.portlet", name: "portlet-api", version: "2.0"
    compileOnly group: "javax.servlet", name: "javax.servlet-api", version: "3.0.1"
    compile group: 'org.jboss.arquillian.junit', name: 'arquillian-junit-container', version: '1.1.3.Final'
    compile group: 'org.jboss.arquillian.container', name: 'arquillian-tomcat-remote-7', version: '1.0.0.CR6'
    compile group: 'com.liferay', name: 'com.liferay.ant.arquillian', version: '1.0.0-SNAPSHOT'
    compile group: 'org.springframework', name: 'spring-aop', version: '4.1.9.RELEASE'
    compile group: 'org.springframework', name: 'spring-beans', version: '4.1.9.RELEASE'
    compile group: 'org.springframework', name: 'spring-context', version: '4.1.9.RELEASE'
    compile group: 'org.springframework', name: 'spring-core', version: '4.1.9.RELEASE'
    compile group: 'org.springframework', name: 'spring-expression', version: '4.1.9.RELEASE'
    compile group: 'org.springframework', name: 'spring-web', version: '4.1.9.RELEASE'
    compile group: 'org.springframework', name: 'spring-webmvc', version: '4.1.9.RELEASE'
    compile group: 'org.springframework', name: 'spring-webmvc-portlet', version: '4.1.9.RELEASE'
}
\end{verbatim}

Some of \texttt{my-spring-mvc-portlet}'s dependency artifacts have new
names.

\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Old name & New name \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{spring-web-portlet} & \texttt{spring-webmvc-portlet} \\
\texttt{spring-web-servlet} & \texttt{spring-webmvc} \\
\end{longtable}

\href{https://search.maven.org/}{Maven Central} provides artifact
dependency information.

\noindent\hrulefill

\textbf{Note}: If the Spring Framework version you're using differs from
the version Liferay DXP uses, you must name your Spring Framework JARs
differently from Liferay DXP's Spring Framework JARs. If you don't
rename your JARs, Liferay DXP assumes you're using its Spring Framework
JARs and excludes yours from the generated WAB (Web Application Bundle).
\href{https://docs.liferay.com/ce/portal/7.0-latest/propertiesdoc/portal.properties.html\#Module\%20Framework}{Portal
property \texttt{module.framework.web.generator.excluded.paths}} lists
Liferay DXP's Spring Framework JARs.
\href{/docs/7-0/tutorials/-/knowledge_base/t/resolving-a-plugins-dependencies\#understanding-excluded-jars}{Understanding
Excluded JARs} explains how to detect the Spring Framework version
Liferay DXP uses.

\noindent\hrulefill

\noindent\hrulefill

\textbf{Note}: If a dependency is an OSGi module JAR and Liferay DXP
already exports your plugin's required packages, \emph{exclude} the JAR
from your plugin's WAR file. This prevents your plugin from exporting
the same package(s) that Liferay is already exporting. This prevents
class loader collisions. To exclude a JAR from deployment, add its name
to the your project's \texttt{liferay-plugin-package.properties} file's
\texttt{deploy-excludes} property.

\begin{verbatim}
 deploy-excludes=\
     **/WEB-INF/lib/module-a.jar,\
     **/WEB-INF/lib/module-b.jar
\end{verbatim}

Since \texttt{my-spring-mvc-portlet}'s dependencies aren't OSGi modules,
no JARs must be excluded.

\noindent\hrulefill

To import class packages referenced by your portlet's descriptor files,
add the packages to an \texttt{Import-Package} header in the
\texttt{liferay-plugin-package.properties} file. See
\href{/docs/7-0/tutorials/-/knowledge_base/t/spring-mvc\#packaging-a-spring-mvc-portlet}{Packaging
a Spring MVC Portlet} for details.

If you depend on a package from Java's \texttt{rt.jar} other than its
\texttt{java.*} packages, override
\href{@platform-ref@/7.0-latest/propertiesdoc/portal.properties.html\#Module\%20Framework}{portal
property \texttt{org.osgi.framework.bootdelegation}} and add it to the
property's list. Go
\href{/docs/7-0/tutorials/-/knowledge_base/t/resolving-classnotfoundexception-and-noclassdeffounderror-in-osgi-bundles\#case-4-the-missing-class-belongs-to-a-java-runtime-package}{here}
for details.

\noindent\hrulefill

\textbf{Note}: Spring MVC portlets whose embedded JARs contain
properties files (e.g., \texttt{spring.handlers},
\texttt{spring.schemas}, \texttt{spring.tooling}) might be affected by
issue \href{https://issues.liferay.com/browse/LPS-75212}{LPS-75212}. The
last JAR that has properties files is the only JAR whose properties are
added to the resulting WAB's classpath. Properties in other JARs aren't
added.

\href{/docs/7-0/tutorials/-/knowledge_base/t/spring-mvc\#packaging-a-spring-mvc-portlet}{Packaging
a Spring MVC Portlet} explains how to add all the embedded JAR
properties.

\noindent\hrulefill

The portlet is ready to deploy. Deploy it as you always have.

Liferay DXP's
\href{/docs/7-0/tutorials/-/knowledge_base/t/using-the-wab-generator}{WAB
Generator} converts the portlet WAR to a Web Application Bundle (WAB)
and installs the WAB to Liferay's OSGi Runtime Framework.

\begin{verbatim}
21:12:23,775 INFO  [com.liferay.portal.kernel.deploy.auto.AutoDeployScanner][AutoDeployDir:252] Processing my-spring-mvc-portlet-7.0.0.1.war
...
21:12:36,159 INFO  [fileinstall-C:/portals/liferay-dxp-digital-enterprise-7.0-sp1/osgi/war][PluginPackageUtil:1007] Reading plugin package for my-spring-mvc-portlet
07-Aug-2017 21:12:36.170 INFO [fileinstall-C:/portals/liferay-dxp-digital-enterprise-7.0-sp1/osgi/war] org.apache.catalina.core.ApplicationContext.log Initializing Spring root WebApplicationContext
07-Aug-2017 21:12:36.181 INFO [fileinstall-C:/portals/liferay-dxp-digital-enterprise-7.0-sp1/osgi/war] org.apache.catalina.core.ApplicationContext.log Initializing Spring root WebApplicationContext
21:12:36,365 INFO  [fileinstall-C:/portals/liferay-dxp-digital-enterprise-7.0-sp1/osgi/war][PortletHotDeployListener:201] Registering portlets for my-spring-mvc-portlet
21:12:36,707 INFO  [fileinstall-C:/portals/liferay-dxp-digital-enterprise-7.0-sp1/osgi/war][PortletHotDeployListener:313] 1 portlet for my-spring-mvc-portlet is available for use
21:12:36,868 INFO  [fileinstall-C:/portals/liferay-dxp-digital-enterprise-7.0-sp1/osgi/war][BundleStartStopLogger:35] STARTED my-spring-mvc-portlet_7.0.0.1 [1309]
\end{verbatim}

You've upgraded a Spring MVC portlet to 7.0. Way to go!

\subsection{Related Topics}\label{related-topics-16}

\href{/docs/7-0/tutorials/-/knowledge_base/t/spring-mvc}{Spring MVC}

\href{/docs/7-0/tutorials/-/knowledge_base/t/migrating-traditional-plugins-to-workspace-web-applications}{Migrating
Plugins SDK Projects to Workspace and Gradle}

\href{/docs/7-0/tutorials/-/knowledge_base/t/resolving-a-plugins-dependencies\#using-a-dependency-management-tool}{Using
Dependency Management Tools}

\href{/docs/7-0/tutorials/-/knowledge_base/t/using-the-wab-generator}{Using
the WAB Generator}

\section{Upgrading Web Plugins}\label{upgrading-web-plugins}

Web plugins are regular
\href{https://docs.oracle.com/cd/E19226-01/820-7627/bnadx/index.html}{Java
EE web modules} designed to work with Liferay DXP. These plugins were
stored in the \texttt{webs} folder of the legacy Plugins SDK.

Upgrading a Liferay web plugin involves these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Adapt the plugin to 7.0's API using the Liferay Upgrade Planner. When
  running the planner's \emph{Fix Upgrade Problems} step, many of the
  existing issues are autocorrected. For remaining issues, the planner
  identifies code affected by the new API and ways to adapt it.
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/resolving-a-plugins-dependencies}{Resolve
  its dependencies}
\item
  Deploy it.
\end{enumerate}

After deploying the upgraded portlet, the server prints messages that
indicate the following portlet status:

\begin{itemize}
\tightlist
\item
  WAR processing
\item
  WAB startup
\item
  Availability to users
\end{itemize}

You've upgraded and deployed your Liferay web plugin on your 7.0
instance. Great job!

\section{Upgrading Ext Plugins}\label{upgrading-ext-plugins}

Ext plugins let you use internal APIs and even let you overwrite Liferay
DXP core files. This puts your deployment at risk of being incompatible
with security, performance, or feature updates released by Liferay. When
upgrading to a new version of Liferay DXP, you must review all changes
and manually modify your Ext projects to merge your changes with Liferay
DXP's.

During your upgrade to 7.0, it's highly recommended to leverage an
extension point to customize Liferay DXP instead of using you existing
Ext plugin, if possible. 7.0 provides many extension points that let you
customize almost every detail of Liferay DXP. If there's a way to
customize what you want with an extension point, do it that way instead.
See the
\href{/docs/7-0/tutorials/-/knowledge_base/t/benefits-of-liferay-7-for-liferay-6-developers\#more-extensible-easier-to-maintain}{More
Extensible, Easier to Maintain} section for more details on the
advantages of using Liferay DXP's extension points.

For more information on Ext projects, how to decide if you need one, and
how to manage them, see the
\href{/docs/7-0/tutorials/-/knowledge_base/t/advanced-customization-with-ext-plugins}{Customization
with Ext} section.

\section{Upgrading the Liferay Maven
Build}\label{upgrading-the-liferay-maven-build}

If you're an avid Maven user and have been using it for Liferay Portal
6.2 project development, you must upgrade your Maven build to be
compatible with 7.0 development. There are two main parts of the Maven
environment upgrade process that you must address:

\begin{itemize}
\tightlist
\item
  Upgrading to new 7.0 Maven plugins
\item
  Updating Liferay Maven artifact dependencies
\end{itemize}

For more information on using Maven with 7.0, see the
\href{/docs/7-0/tutorials/-/knowledge_base/t/maven}{Maven tutorial
section}. For a guided and expedited upgrade process for your Maven
build, try the
\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-upgrade-planner}{Upgrade
Planner}.

You'll start off by upgrading your Maven environment's Liferay Maven
plugins.

\subsection{Upgrading to New 7.0 Maven
Plugins}\label{upgrading-to-new-7.0-maven-plugins}

The biggest change for your project's build plugins is the removal of
the \texttt{liferay-maven-plugin}. Liferay now provides several
individual Maven plugins that accomplish specific tasks. For example,
you can configure Maven plugins for Liferay's CSS Builder, Service
Builder, Theme Builder, etc. With smaller plugins available to
accomplish specific tasks in your project, you no longer have to rely on
one large plugin that provides many things you may not want.

For example, suppose your Liferay Portal 6.2 project was using the
\texttt{liferay-maven-plugin} for Liferay CSS Builder only. First, you
should remove the legacy \texttt{liferay-maven-plugin} plugin dependency
from your project's \texttt{pom.xml} file:

\begin{verbatim}
<plugin>
    <groupId>com.liferay.maven.plugins</groupId>
    <artifactId>liferay-maven-plugin</artifactId>
    <version>${liferay.version}</version>
    <configuration>
        <autoDeployDir>${liferay.auto.deploy.dir}</autoDeployDir>
        <liferayVersion>${liferay.version}</liferayVersion>
        <pluginType>portlet</pluginType>
    </configuration>
</plugin>
\end{verbatim}

Then, add the CSS Builder plugin dependency to your project's
\texttt{pom.xml} file:

\begin{verbatim}
<plugin>
    <groupId>com.liferay</groupId>
    <artifactId>com.liferay.css.builder</artifactId>
    <version>1.0.21</version>
    <executions>
        <execution>
            <id>default-build</id>
            <phase>generate-sources</phase>
            <goals>
                <goal>build</goal>
            </goals>
        </execution>
    </executions>
        <configuration>
            <docrootDirName>src/main/webapp</docrootDirName>
        </configuration>
</plugin>
\end{verbatim}

Some common Liferay Maven plugins are listed below, with their
corresponding artifact IDs and tutorials explaining how to configure
them:

\textbf{Common Liferay Maven Plugins}

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.2083}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.4583}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.3333}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Name
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Artifact ID
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Tutorial
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
CSS Builder &
\href{https://search.maven.org/\#search\%7Cga\%7C1\%7Ccom.liferay.css.builder}{com.liferay.css.builder}
&
\href{/docs/7-0/tutorials/-/knowledge_base/t/compiling-sass-files-in-a-maven-project}{Compiling
SASS Files in a Maven Project} \\
Lang Builder &
\href{https://search.maven.org/\#search\%7Cga\%7C1\%7Ccom.liferay.lang.builder}{com.liferay.lang.builder}
& Coming Soon \\
Service Builder &
\href{https://search.maven.org/\#search\%7Cga\%7C1\%7Ccom.liferay.portal.tools.service.builder}{com.liferay.portal.tools.service.builder}
&
\href{/docs/7-0/tutorials/-/knowledge_base/t/using-service-builder-in-a-maven-project}{Using
Service Builder in a Maven Project} \\
Theme Builder &
\href{https://search.maven.org/\#search\%7Cga\%7C1\%7Ccom.liferay.portal.tools.theme.builder}{com.liferay.portal.tools.theme.builder}
&
\href{/docs/7-0/tutorials/-/knowledge_base/t/building-themes-in-a-maven-project}{Building
Themes in a Maven Project} \\
\end{longtable}

In Liferay Portal 6.2, you were also required to specify all your app
server configuration settings. For example, your parent POM probably
contained settings similar to these:

\begin{verbatim}
<properties>
    <liferay.app.server.deploy.dir>
        E:\liferay-portal-6.2.0-ce-ga1\tomcat-7.0.42\webapps
    </liferay.app.server.deploy.dir>

    <liferay.app.server.lib.global.dir>
        E:\liferay-portal-6.2.0-ce-ga1\tomcat-7.0.42\lib\ext
    </liferay.app.server.lib.global.dir>

    <liferay.app.server.portal.dir>
        E:\liferay-portal-6.2.0-ce-ga1\tomcat-7.0.42\webapps\root
    </liferay.app.server.portal.dir> 

    <liferay.auto.deploy.dir>
        E:\liferay-portal-6.2.0-ce-ga1\deploy
    </liferay.auto.deploy.dir>

    <liferay.version>
        6.2.0
    </liferay.version>

    <liferay.maven.plugin.version>
        6.2.0
    </liferay.maven.plugin.version

</properties>
\end{verbatim}

This is no longer required in 7.0 because Liferay's Maven tools no
longer rely on your Liferay DXP installation's specific versions. You
should remove them from your POM file.

Awesome! You've learned about the new Maven plugins available to you for
7.0 development. Next, you'll learn about updating your Liferay Maven
artifacts.

\subsection{Updating Liferay Maven Artifact
Dependencies}\label{updating-liferay-maven-artifact-dependencies}

Many Liferay Portal 6.2 artifact dependencies you were using have
changed in 7.0. See the table below for popular Liferay Maven artifacts
that have changed:

\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Liferay Portal 6.2 Artifact ID & 7.0 Artifact ID \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{portal-service} & \texttt{com.liferay.portal.kernel} \\
\texttt{util-bridges} & \texttt{com.liferay.util.bridges} \\
\texttt{util-java} & \texttt{com.liferay.util.java} \\
\texttt{util-slf4j} & \texttt{com.liferay.util.slf4j} \\
\texttt{util-taglib} & \texttt{com.liferay.util.taglib} \\
\end{longtable}

For more information on resolving dependencies in 7.0, see the
\href{/docs/7-0/tutorials/-/knowledge_base/t/resolving-a-plugins-dependencies}{Resolving
a Plugin's Dependencies} tutorial.

Of course, you must also update the artifacts you're referencing for
your projects. If you're using the Central Repository to install Liferay
Maven artifacts, you won't need to do anything more than update the
artifacts in your POMs. If, however, you're working behind a proxy or
don't have Internet access, you must update your company-shared or local
repository with the latest 7.0 Maven artifacts. See the
\href{/docs/7-0/tutorials/-/knowledge_base/t/installing-liferay-maven-artifacts}{Installing
Liferay Maven Artifacts} tutorial for instructions.

With these updates, you can easily upgrade your Liferay Maven build so
you can begin developing traditional plugin projects for 7.0.

\chapter{Optimizing Plugins for 7.0}\label{optimizing-plugins-for-7.0}

Once you've
\href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-plugins-to-liferay-7}{upgraded
your plugin} to 7.0, you can optimize it to take advantage of all
@product-ver@ offers. If you haven't yet familiarized yourself with
\href{/docs/7-0/tutorials/-/knowledge_base/t/whats-changed-and-what-hasnt}{what's
changed from Liferay Portal 6}, the
\href{/docs/7-0/tutorials/-/knowledge_base/t/benefits-of-liferay-7-for-liferay-6-developers}{new
benefits for developers},
\href{/docs/7-0/tutorials/-/knowledge_base/t/osgi-and-modularity-for-liferay-6-developers}{OSGi
and modularity}, and the
\href{/docs/7-0/tutorials/-/knowledge_base/t/improved-developer-tooling-liferay-workspace-maven-plugins-and-more}{improved
tooling}, make sure to do so as they'll help you understand and
appreciate the optional improvements for plugins and plugin development
the optimization tutorials demonstrate.

Here are some common optimizations to consider:

\begin{itemize}
\tightlist
\item
  Migrating to environments that help you develop and test more quickly,
  such as the
  \href{/docs/7-0/tutorials/-/knowledge_base/t/migrating-a-6-2-theme-to-liferay-7}{Liferay
  Theme Generator} for themes and
  \href{/docs/7-0/tutorials/-/knowledge_base/t/improved-developer-tooling-liferay-workspace-maven-plugins-and-more\#from-the-plugins-sdk-to-liferay-workspace}{Liferay
  Workspace} for modules and web applications.
\item
  Adapting plugins to
  \href{/docs/7-0/tutorials/-/knowledge_base/t/whats-changed-and-what-hasnt\#embracing-a-modular-architecture}{7.0's
  modular architecture} and updated frameworks, such as Service Builder.
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/applying-lexicon-styles-to-your-app}{Styling
  your app consistently using Lexicon} --the web implementation of
  Liferay's Lexicon Experience Language.
\item
  Modularizing apps to reap the
  \href{/docs/7-0/tutorials/-/knowledge_base/t/osgi-and-modularity-for-liferay-6-developers\#modules-as-an-improvement-over-traditional-plugins}{benefits
  of modularity} and all that 7.0 offers.
\end{itemize}

Several optimization tutorials are here and more are coming soon.

\section{Migrating Traditional Plugins to Workspace Web
Applications}\label{migrating-traditional-plugins-to-workspace-web-applications}

After you've
\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-upgrade-planner}{adapted
your traditional plugin} to Liferay DXP's API, you can continue
maintaining it in the Plugins SDK. The Plugins SDK, however, is
deprecated as of 7.0. Maintaining plugins in the SDK will become
increasingly difficult.
\href{/docs/7-0/tutorials/-/knowledge_base/t/improved-developer-tooling-liferay-workspace-maven-plugins-and-more\#from-the-plugins-sdk-to-liferay-workspace}{Liferay
Workspace replaces the Plugins SDK}, providing a comprehensive Gradle
development environment and more. A simple command migrates traditional
plugins (such as portlets) to Gradle-based web application projects.
From there you can build and deploy them to 7.0 as Web ARchives (WARs).

\subsection{Running the Migration
Command}\label{running-the-migration-command}

\href{/docs/7-0/tutorials/-/knowledge_base/t/blade-cli}{Blade CLI's}
\texttt{convert} command migrates Plugins SDK plugins to web application
projects in Workspace's \texttt{wars} folder. Plugin files are
re-organized to follow the standard web application folder structure.

\textbf{Standard Web Application Anatomy:}

\begin{itemize}
\tightlist
\item
  \texttt{{[}project\ root{]}}

  \begin{itemize}
  \tightlist
  \item
    \texttt{src}

    \begin{itemize}
    \tightlist
    \item
      \texttt{main}

      \begin{itemize}
      \tightlist
      \item
        \texttt{webapp}

        \begin{itemize}
        \tightlist
        \item
          \texttt{WEB-INF}

          \begin{itemize}
          \tightlist
          \item
            \texttt{classes}
          \item
            \texttt{lib} → Libraries
          \item
            descriptor files
          \end{itemize}
        \end{itemize}
      \item
        \texttt{css} → CSS files
      \item
        \texttt{js} → JavaScript files
      \item
        \texttt{icons}
      \item
        JSP files
      \end{itemize}
    \item
      \texttt{java} → Java source
    \end{itemize}
  \item
    build files
  \end{itemize}
\end{itemize}

In a terminal, navigate to the Liferay Workspace root folder. Then pass
your Plugins SDK project's name to Blade's \texttt{convert} command:

\begin{verbatim}
blade convert [PLUGIN_PROJECT_NAME]
\end{verbatim}

Blade extracts the plugin from the Plugins SDK and reorganizes it in a
standard web application project in Workspace's \texttt{wars} folder.

\textbf{Note:} You can execute \texttt{blade\ convert\ -l} to show a
list of projects that can be migrated in your Plugins SDK. Run
\texttt{blade\ convert\ -\/-all} to migrate all plugin projects in your
Plugins SDK to Workspace.

The image below shows the plugin files before and after they're migrated
to Workspace.

\begin{figure}
\centering
\includegraphics{./images/migrate-war-compare-folder-structure.png}
\caption{The \texttt{convert} command migrates a Plugins SDK project to
a Workspace web application project. It moves Java source files to
\texttt{src/main/java} and all other files/folders to
\texttt{src/main/webapp}.}
\end{figure}

The following table maps traditional plugin source files to the standard
web application folder structure Workspace uses.

\textbf{Plugins SDK folders to web application folders:}

\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Files & Plugins SDK folder (old) & Web app folder (new) \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Java & \texttt{docroot/WEB-INF/src} & \texttt{src/main/java} \\
JSPs & \texttt{docroot} & \texttt{src/main/webapp} \\
icons & \texttt{docroot} & \texttt{src/main/webapp} \\
CSS & \texttt{docroot/css} & \texttt{src/main/webapp/css} \\
JS & \texttt{docroot/js} & \texttt{src/main/webapp/js} \\
descriptors & \texttt{docroot/WEB-INF} &
\texttt{src/main/webapp/WEB-INF} \\
libraries & \texttt{docroot/WEB-INF/lib} &
\texttt{src/main/webapp/lib} \\
\end{longtable}

From your plugin's new location, you can invoke
\href{/docs/7-0/tutorials/-/knowledge_base/t/improved-developer-tooling-liferay-workspace-maven-plugins-and-more\#plugins-sdk-to-workspace-task-map}{Workspace
Gradle tasks} on it and build its \texttt{.war} file.

\begin{verbatim}
blade gw war 
\end{verbatim}

To deploy the \texttt{.war}, copy it from the plugin's
\texttt{build/libs} folder to the \texttt{{[}LIFERAY\_HOME{]}/deploy}
folder.

Welcome to your plugin's new home in Workspace!

\subsection{Related Topics}\label{related-topics-17}

\href{/docs/7-0/tutorials/-/knowledge_base/t/development-lifecycle-for-a-liferay-workspace\#building-modules}{Workspace
Development lifecycle}

\href{/docs/7-0/tutorials/-/knowledge_base/t/improved-developer-tooling-liferay-workspace-maven-plugins-and-more\#plugins-sdk-to-workspace-task-map}{Workspace
Gradle Tasks}

\chapter{Modularizing Plugins}\label{modularizing-plugins}

As described in
\href{/docs/7-0/tutorials/-/knowledge_base/t/benefits-of-liferay-7-for-liferay-6-developers}{Benefits
of Liferay 7 for Liferay 6 Developers}, applications that comprise OSGi
modules offer considerable advantages over monolithic applications.

The main benefit is that modular development practices structure code in
ways that reduce maintenance costs. These practices involve, for
example, defining contracts (such as APIs) more clearly, hiding internal
classes, and handling dependencies more carefully. Related to this,
module dependencies are explicitly listed within a module. Modules run
only when all their dependencies are met--this can eliminate many
obscure run time errors.

Splitting large applications into small independent modules lets you
focus on smaller release cycles for those modules. Individual modules
can be updated independently of the others. For instance, you might fix
a JSP's security issue in an application's web (client) module. The
issue only affects that module--none of the application's other modules
need change.

The scenarios described below can help you decide whether to convert an
application to modules.

\textbf{When not to convert?}

\begin{itemize}
\tightlist
\item
  You have a portlet that's JSR-168/286 compatible and you still want to
  be able to deploy it to another portlet container. In this case, it's
  best to stay with the traditional WAR model. (To eliminate this reason
  for not converting, Liferay is discussing with other vendors the
  possibility of making modular portlets a standard.)
\item
  You're using a complex web framework that is heavily tied to the Java
  EE programming model and the amount of effort necessary to make it
  work with OSGi is more than you feel is necessary or warranted.
\item
  You want to minimize effort to get your application to working on 7.0.
\end{itemize}

\textbf{When to convert?}

\begin{itemize}
\tightlist
\item
  You have a very large application with many lines of code. If you've
  got lots of developers making changes, separating the code into
  modules can make it easier and faster to get releases out.
\item
  Your application has reusable parts that you want to consume outside
  of it. For instance, you have business logic that you're reusing in
  different projects. Modules let you consume their services from other
  modules.
\item
  In general, you want to start reaping the benefits of modular
  development.
\end{itemize}

You can now make an informed decision on whether to stick with your
upgraded traditional application as is or modularize it to leverage
7.0's modularity features.

\section{Modularizing an Existing
Portlet}\label{modularizing-an-existing-portlet}

An application with properly modularized plugins offers several
benefits. You can release individually its plugins without releasing the
entire application. External clients can consume services from
particular plugins, without having to depend on an entire application.
And by splitting up large amounts of code into concise modules, teams
can more easily focus on particular areas of the application. These are
just a few reasons to modularize application plugins.

In this tutorial, you'll learn how to convert your traditional
application into modules. Before getting started, it's important to
reiterate that the module structure shown in this tutorial is just one
of many ways for structuring your application's modules. It's also
important to remember that applications come in all different shapes and
sizes. There may be special actions that some applications require. This
tutorial provides the general process for converting to modules using
Liferay's module structure.

Here's what's involved:

\begin{itemize}
\tightlist
\item
  Converting portlet classes and the UI
\item
  Converting Service Builder interfaces and implementations
\item
  Building and deploying modules
\end{itemize}

The instructions covered in this tutorial apply to both the commercial
and open source versions of Liferay.

The first thing you'll do is create your application's web (client)
module.

\subsection{Converting Your Application's Portlet Classes and
UI}\label{converting-your-applications-portlet-classes-and-ui}

The first thing you'll do is create your application's parent directory
and the directory structure for your application's \emph{web} client
module. This module holds your application's portlet classes and is
responsible for its UI. Before you start creating a skeleton structure
for your application's modules, you should determine which modules will
comprise this version of your application. If your application provides
service and API classes (which is the case for all Liferay Service
Builder applications), you should create separate modules for your
service implementation and service API classes. This tutorial assumes
the Maven project model, although any build tools or directory setup is
permissible.

\noindent\hrulefill

\textbf{Note:} It's recommended that you use the build plugin versions
that support the latest OSGi features. The following Gradle or Maven
build plugin versions should be used in their respective build
frameworks:

\textbf{Gradle} - biz.aQute.bnd:biz.aQute.bnd.gradle:3.1.0 \textbf{or} -
org.dm.gradle:gradle-bundle-plugin:0.8.1

\textbf{Maven} - biz.aQute.bnd:bnd-maven-plugin:3.1.0 \textbf{or} -
org.apache.felix:maven-bundle-plugin:3.0.1

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create your application's parent folder. It is home for your
  application's independent modules and configuration files. For
  example, if your application's name is \emph{Tasks}, then your parent
  folder could be \emph{tasks}.

  If your application uses Liferay Service Builder, use the following
  \href{/docs/7-0/tutorials/-/knowledge_base/t/blade-cli}{Blade CLI}
  command to generate the parent folder and service implementation and
  service API modules in it. If the parent folder already exists, it
  must be empty. This command names the parent folder after the
  \texttt{APPLICATION\_NAME}:

\begin{verbatim}
blade create -t service-builder -p [ROOT_PACKAGE] [APPLICATION_NAME]
\end{verbatim}

  The \texttt{*-service} and \texttt{*-api} module folders are described
  later in this tutorial.
\item
  Create the folder structure for your web client module. You can do
  this automatically by using Blade CLI. The
  \href{/docs/7-0/tutorials/-/knowledge_base/t/portlets}{portlet
  tutorials} demonstrate creating all different kinds of portlets.

  Navigate to your parent directory (e.g., \texttt{tasks}) and run the
  following Blade CLI command to generate a generic web client module
  structure:

\begin{verbatim}
blade create -t mvc-portlet -p [ROOT_PACKAGE] [APPLICATION_NAME]-web
\end{verbatim}
\item
  Replace the \texttt{/src/main/java/{[}APPLICATION\_NAME{]}} folder
  with your root package. For instance, if your application's root
  package name is \texttt{com.liferay.tasks.web}, your class's directory
  should be \texttt{/src/main/java/com/liferay/tasks/web}. Also, remove
  the \texttt{init.jsp} and \texttt{view.jsp} files located in the
  \texttt{src/main/resources/META-INF/resources} folder. You'll insert
  your traditional application's Java code and JSPs, so the generated
  default code is not necessary.
\item
  Verify that your current directory structure for your application's
  \texttt{*-web} module matches the structure listed below:

  \begin{itemize}
  \tightlist
  \item
    \texttt{tasks}

    \begin{itemize}
    \tightlist
    \item
      \texttt{tasks-web}

      \begin{itemize}
      \tightlist
      \item
        \texttt{src}

        \begin{itemize}
        \tightlist
        \item
          \texttt{main}

          \begin{itemize}
          \tightlist
          \item
            \texttt{java}

            \begin{itemize}
            \tightlist
            \item
              \texttt{{[}ROOT\_PACKAGE{]}}
            \end{itemize}
          \item
            \texttt{resources}

            \begin{itemize}
            \tightlist
            \item
              \texttt{content}

              \begin{itemize}
              \tightlist
              \item
                \texttt{Language.properties}
              \end{itemize}
            \item
              \texttt{META-INF}

              \begin{itemize}
              \tightlist
              \item
                \texttt{resources}
              \end{itemize}
            \end{itemize}
          \end{itemize}
        \end{itemize}
      \item
        \texttt{bnd.bnd}
      \item
        \texttt{build.gradle}
      \end{itemize}
    \end{itemize}
  \end{itemize}

  The instructions in the rest of this sub-section only affect your
  application's web client module.
\item
  Open the \texttt{bnd.bnd} file. This is used to generate your module's
  \texttt{MANIFEST.MF} file that is generated when you build your
  project. Edit your module's \texttt{bnd.bnd} file to fit your
  application. For more information about configuring your module's
  \texttt{bnd.bnd}, visit \url{http://bnd.bndtools.org/}. You can view
  the \texttt{dictionary-web} module's \texttt{bnd.bnd} for a simple
  example below:

\begin{verbatim}
Bundle-Name: Liferay Dictionary Web
Bundle-SymbolicName: com.liferay.dictionary.web
Bundle-Version: 1.0.6
\end{verbatim}

  For a more advanced example, examine the \texttt{journal-web} module's
  \texttt{bnd.bnd}:

\begin{verbatim}
Bundle-Name: Liferay Journal Web
Bundle-SymbolicName: com.liferay.journal.web
Bundle-Version: 2.0.0
Export-Package:\
    com.liferay.journal.web.asset,\
    com.liferay.journal.web.dynamic.data.mapping.util,\
    com.liferay.journal.web.social,\
    com.liferay.journal.web.util
Liferay-JS-Config: /META-INF/resources/js/config.js
Liferay-Releng-Module-Group-Description:
Liferay-Releng-Module-Group-Title: Web Content
Web-ContextPath: /journal-web
\end{verbatim}
\item
  Open the \texttt{build.gradle} file. This is used to
  \href{/docs/7-0/tutorials/-/knowledge_base/t/configuring-dependencies}{specify
  all your module's dependencies}. The \texttt{build.gradle} file that
  was generated for you is pre-populated with content and default
  dependencies related to OSGi and Liferay DXP. In the
  \texttt{dependencies\ \{...\}} block, you need to add the web client
  module's dependencies. To learn how to find and specify dependencies
  on Liferay API modules, refer to the reference document
  \href{/docs/7-0/reference/-/knowledge_base/r/finding-liferay-api-modules}{Finding
  Liferay API Modules}. When deploying your module into the OSGi
  container, OSGi checks if the dependencies are available in the
  container. If the dependencies are not available in the container,
  your module will be unavailable. Therefore, your dependencies are not
  bundled with your module. Instead, they're available from Liferay's
  OSGi container.
\item
  Copy your traditional application's JSP files into the
  \texttt{/src/main/resources/META-INF/resources} directory. In most
  cases, all of your application's JSP files should reside in the web
  client module.
\item
  Your next task is to add your portlet classes, non-service classes,
  and non-implementation classes into your client module. Copy your
  portlet classes into their respective directories and ensure their
  package names within the class are specified correctly. Your client
  module can hold one class or many classes, depending on how large your
  application is. It's a good practice to organize your classes into
  sub-packages of the main package, to more easily manage them. You'll
  examine the \texttt{journal-web} module for an example of a client
  module holding many different Java classes:

  \begin{itemize}
  \tightlist
  \item
    \texttt{journal-web}

    \begin{itemize}
    \tightlist
    \item
      \ldots{}
    \item
      \texttt{src/main/java/com/liferay/journal/web/}

      \begin{itemize}
      \tightlist
      \item
        \texttt{asset}

        \begin{itemize}
        \tightlist
        \item
          {[}classes{]}
        \end{itemize}
      \item
        \texttt{configuration}

        \begin{itemize}
        \tightlist
        \item
          {[}classes{]}
        \end{itemize}
      \item
        \texttt{dynamic/data/mapping/util}

        \begin{itemize}
        \tightlist
        \item
          {[}classes{]}
        \end{itemize}
      \item
        \texttt{internal}

        \begin{itemize}
        \tightlist
        \item
          \texttt{application/list}

          \begin{itemize}
          \tightlist
          \item
            {[}classes{]}
          \end{itemize}
        \item
          \texttt{custom/attributes}

          \begin{itemize}
          \tightlist
          \item
            {[}classes{]}
          \end{itemize}
        \item
          \texttt{dao/search}

          \begin{itemize}
          \tightlist
          \item
            {[}classes{]}
          \end{itemize}
        \item
          \ldots{}
        \end{itemize}
      \item
        \texttt{social}

        \begin{itemize}
        \tightlist
        \item
          {[}classes{]}
        \end{itemize}
      \item
        \texttt{util}

        \begin{itemize}
        \tightlist
        \item
          {[}classes{]}
        \end{itemize}
      \end{itemize}
    \item
      \ldots{}
    \end{itemize}
  \end{itemize}
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** Many applications have service and API classes. These classes
 need to live in separate implementation and API modules. You'll learn more
 about creating these later in this tutorial.
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{8}
\item
  Now that you have the necessary classes in your client module, you
  need to edit these classes to be compliant with OSGi. First, you need
  to choose a component framework to work with. Using a component
  framework lets you easily harness the power of OSGi. Liferay DXP uses
  the \href{http://wiki.osgi.org/wiki/Declarative_Services}{Declarative
  Services} component framework and recommends that Liferay developers
  use it too. This tutorial assumes that you're using Declarative
  Services. You can, however, use any other OSGi component framework in
  Liferay DXP.

  Review your traditional application's XML files and migrate the
  configuration and metadata information to the portlet class as
  properties. You can do this by adding the \texttt{@Component}
  annotation to your portlet class and adding the necessary properties
  to that annotation. The end result should look similar to the
  following example:

\begin{verbatim}
@Component(
    immediate = true,
    property = {
        "com.liferay.portlet.display-category=category.sample",
        "com.liferay.portlet.icon=/icon.png",
        "javax.portlet.name=1",
        "javax.portlet.display-name=Tasks Portlet",
        "javax.portlet.security-role-ref=administrator,guest,power-user",
        "javax.portlet.init-param.clear-request-parameters=true",
        "javax.portlet.init-param.view-template=/view.jsp",
        "javax.portlet.expiration-cache=0",
        "javax.portlet.supports.mime-type=text/html",
        "javax.portlet.resource-bundle=content.Language",
        "javax.portlet.info.title=Tasks Portlet",
        "javax.portlet.info.short-title=Tasks",
        "javax.portlet.info.keywords=Tasks",
    },
    service = Portlet.class
)
public class TasksPortlet extends MVCPortlet {
\end{verbatim}
\item
  Convert all references of the \texttt{portletId} (e.g.,
  \texttt{58\_INSTANCE\_4gtH}) to the class name of the portlet,
  replacing all periods with underscores (e.g.,
  \texttt{com\_liferay\_web\_proxy\_portlet\_WebProxyPortlet}).
\item
  If your traditional application has resource actions, you'll need to
  migrate those into your client module. Create the
  \texttt{/src/main/resources/resource-actions/default.xml} file, and
  copy your resource actions there. Make sure to create the
  \texttt{src/portlet.properties} file and add the following property:

\begin{verbatim}
resource.actions.configs=resource-actions/default.xml
\end{verbatim}

  As an example, you can view the Directory application's
  \href{https://github.com/liferay/liferay-portal/blob/7.0.6-ga7/modules/apps/collaboration/directory/directory-web/src/main/resources/resource-actions/default.xml}{\texttt{default.xml}}
  file.
\item
  Add any language keys that your application uses to the
  \texttt{src/main/resources/content/Language.properties} file. You
  should only include the language keys that are unique to your
  application. Your application will use the default language keys in
  Liferay when it is deployed.
\end{enumerate}

Awesome! You've created your application's web client module and
navigated through some of the most common tasks necessary to modularize
your portlet classes and UI. There are certain parts of your application
that may not be covered in this tutorial that you must account for.
Liferay's Developer Network provides developer tutorials divided into
popular areas so you can easily find the correct way to transform your
legacy code to use Liferay DXP's updated best practices.

The table below serves as a quick reference guide. It summarizes the
migration process for many of your application's directories, packages,
and files. This is a sample table for a fictitious \emph{tasks}
applications.

\noindent\hrulefill

Plugin Package \textbar{} Module Package \textbar{}
\texttt{tasks-portlet/docroot/WEB-INF/src/com.liferay.tasks.asset}
\textbar{} \texttt{tasks-web/src/main/java/com.liferay.tasks.asset}
\textbar{}
\texttt{tasks-portlet/docroot/WEB-INF/src/com.liferay.tasks.portlet}
\textbar{} \texttt{tasks-web/src/main/java/com.liferay.tasks.portlet}
\textbar{} \texttt{tasks-portlet/docroot/WEB-INF/src/content} \textbar{}
\texttt{tasks-web/src/main/resources/content} \textbar{}
\texttt{tasks-portlet/docroot/WEB-INF/src/resource-actions} \textbar{}
\texttt{tasks-web/src/main/resources/resource-actions} \textbar{}
\texttt{tasks-portlet/docroot/WEB-INF/src/portlet.properties} \textbar{}
\texttt{tasks-web/src/main/resources/portlet.properties} \textbar{}
\texttt{tasks-portlet/docroot/init.jsp} \textbar{}
\texttt{tasks-web/src/main/resources/META-INF/resources/init.jsp}
\textbar{} \texttt{tasks-portlet/docroot/tasks} \textbar{}
\texttt{tasks-web/src/main/resources/META-INF/resources/tasks}
\textbar{} \texttt{tasks-portlet/docroot/upcoming\_tasks} \textbar{}
\texttt{tasks-web/src/main/resources/META-INF/resources/upcoming\_tasks}
\textbar{}

\noindent\hrulefill

Many applications only have a web client module. Larger, more complex
applications, such as Liferay Service Builder applications, require
additional modules to hold their service API and service implementation
logic. You'll learn how to create these modules next.

\subsection{Converting Your Application's Service Builder API and
Implementation}\label{converting-your-applications-service-builder-api-and-implementation}

In this section, you'll learn about converting a Liferay Portal 6
Service Builder application to a 7.0 style application. In the previous
section, you learned how to generate your implementation and API
modules. If you haven't yet run the \texttt{service-builder} Blade CLI
command outlined in step 2 of the previous section, run it now. The API
module holds your application's Service Builder generated API and the
implementation module holds your application's Service Builder
implementation.

Before you begin editing the API and implementation modules, you'll need
to configure your root project (e.g., \texttt{tasks}) to recognize the
multiple modules residing there. A multi-module Gradle project must have
a \texttt{settings.gradle} file in the root project for building
purposes. Luckily, when you generated your Service Builder project's
modules using Blade CLI, the \texttt{settings.gradle} file was inserted
and pre-configured for the \texttt{api} and \texttt{service} modules.
You should add your \texttt{web} module into the Service Builder
project's generated parent folder and define it in the
\texttt{settings.gradle} file too. You'll configure your \texttt{web}
module via Gradle settings later, but for now, go ahead and copy the
module into the project generated by the \texttt{service-builder}
template. For example, an example \texttt{tasks} project's root folder
would look like this:

\begin{itemize}
\tightlist
\item
  \texttt{tasks}

  \begin{itemize}
  \tightlist
  \item
    \texttt{gradle}
  \item
    \texttt{tasks-api}
  \item
    \texttt{tasks-service}
  \item
    \texttt{tasks-web}
  \item
    \texttt{build.gradle}
  \item
    \texttt{gradlew}
  \item
    \texttt{settings.gradle}
  \end{itemize}
\end{itemize}

Your root project directory should now be in good shape. Next, you'll
learn how to use Service Builder to generate your application's service
API and service implementation code.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Copy your traditional application's \texttt{service.xml} file and
  paste it into the implementation module's root directory (e.g.,
  \texttt{tasks/tasks-service}).
\item
  Blade CLI generated a \texttt{bnd.bnd} file for your service
  implementation module. Make sure to edit this \texttt{bnd.bnd} file to
  fit your application. For an example of a service implementation
  module's BND file, examine the \texttt{export-import-service} module's
  BND below:

\begin{verbatim}
Bundle-Name: Liferay Export Import Service
Bundle-SymbolicName: com.liferay.exportimport.service
Bundle-Version: 4.0.0
Export-Package:\
    com.liferay.exportimport.content.processor.base,\
    com.liferay.exportimport.controller,\
    com.liferay.exportimport.data.handler.base,\
    com.liferay.exportimport.lar,\
    com.liferay.exportimport.lifecycle,\
    com.liferay.exportimport.messaging,\
    com.liferay.exportimport.portlet.preferences.processor.base,\
    com.liferay.exportimport.portlet.preferences.processor.capability,\
    com.liferay.exportimport.search,\
    com.liferay.exportimport.staged.model.repository.base,\
    com.liferay.exportimport.staging,\
    com.liferay.exportimport.xstream
Liferay-Releng-Module-Group-Description:
Liferay-Releng-Module-Group-Title: Data Management
Liferay-Require-SchemaVersion: 1.0.0
-includeresource: content=../../staging/staging-lang/src/main/resources/content
\end{verbatim}
\item
  Blade CLI also generated your service implementation module's
  \texttt{build.gradle} file. In this file, Service Builder is already
  configured to generate code both in this module and in your service
  API module. When you run Service Builder, Java classes, interfaces,
  and related files are generated in your \texttt{*api} and
  \texttt{*service} modules. Open your service implementation module's
  \texttt{build.gradle} file to view the default configuration.

  As you've learned already, you don't have to accept the generated
  build files' defaults. Blade CLI simply generated some standard OSGi
  and Liferay configurations.

  For example, Service Builder is already available for you by default.
  Blade CLI applies the Service Builder plugin automatically when a
  project contains the \texttt{service.xml} file. With the Service
  Builder plugin already available, you don't have to worry about
  configuring it in your project.
\item
  Another important part of your service implementation module's
  \texttt{build.gradle} file is the \texttt{buildService\{...\}} block.
  This block configures how Service Builder runs for your project. The
  current configuration will generate your API module successfully, but
  extra configuration might be necessary in certain cases.
\item
  Open a terminal and navigate to your root project folder. Then run
  \texttt{gradlew\ \ \ \ \ buildService}.

  Your \texttt{service.xml} file's configuration is used to generate
  your application's service API and service implementation classes in
  their respective modules. You've also generated other custom files
  (related to SQL, Hibernate, Spring, etc.), depending on your
  \texttt{buildService\ \{...)} block's configuration. For more
  information on configuration options for the Service Builder plugin,
  see the
  \href{/docs/7-0/reference/-/knowledge_base/r/service-builder-gradle-plugin}{Service
  Builder Gradle Plugin} reference article.
\item
  Now that you've run Service Builder, continue copying custom classes
  into your implementation module. The table below highlights popular
  Liferay Portal 6 classes and packages and where they should be placed
  in your application. This table is intended to aid in the organization
  of your classes and configuration files; however, remember to follow
  the organizational methodologies that make the most sense for your
  application. One size does not fit all with your modules' directory
  schemes.
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 Plugin Package | Module Package |
----------------|----------------|
 `tasks-portlet/docroot/WEB-INF/src/com.liferay.tasks.model.impl` | `tasks-service/src/main/java/com.liferay.tasks.model.impl` | 
 `tasks-portlet/docroot/WEB-INF/src/com.liferay.tasks.service.impl` | `tasks-service/src/main/java/com.liferay.tasks.service.impl` |
 `tasks-portlet/docroot/WEB-INF/src/com.liferay.tasks.service.permission` | `tasks-service/src/main/java/com.liferay.tasks.service.permission` |
 `tasks-portlet/docroot/WEB-INF/src/com.liferay.tasks.service.persistence.impl` | `tasks-service/src/main/java/com.liferay.tasks.service.persistence.impl` |
 `tasks-portlet/docroot/WEB-INF/src/com.liferay.tasks.social` | `tasks-service/src/main/java/com.liferay.tasks.social` |
 `tasks-portlet/docroot/WEB-INF/src/com.liferay.tasks.util` | `tasks-service/src/main/java/com.liferay.tasks.util` |
 `tasks-portlet/docroot/WEB-INF/src/custom-sql` | `tasks-service/src/main/resources/META-INF/custom-sql` |
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{6}
\tightlist
\item
  Once you've copied all of your custom classes over, run
  \texttt{gradlew\ \ \ \ \ buildService} again to generate the remaining
  services.
\end{enumerate}

Now that your services are generated, you'll need to wire up your
modules so they can reference each other when deployed to Liferay's OSGi
container. Blade CLI has already partially completed this task. For
example, it assumes that the service implementation module depends on
the service API module.

You still need to associate the client module with the \texttt{api} and
\texttt{service} modules, since they were generated separately. To do
this, follow the steps below:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In your project's \texttt{settings.gradle} file, you must add the
  \texttt{web} module with the \texttt{api} and \texttt{service} modules
  so it's included in the Gradle build lifecycle:

\begin{verbatim}
include "tasks-api", "tasks-service", "tasks-web"
\end{verbatim}
\item
  Add the \texttt{api} and \texttt{service} modules as dependencies in
  you client module:

\begin{verbatim}
dependencies {
    compileOnly  project(':tasks-api')
    compileOnly  project(':tasks-service')
}
\end{verbatim}
\end{enumerate}

Excellent! You've successfully generated your application's services
using Service Builder. They now reside in modules, and can be deployed
to 7.0.

\subsection{Building Your Module JARs for
Deployment}\label{building-your-module-jars-for-deployment}

Now it's time to build your modules and deploy them to your Liferay DXP
instance. To build your project, run \texttt{gradlew\ build} from your
project's root directory.

Once your project successfully builds, check all of your modules'
\texttt{/build/libs} folders. There should be a newly generated JAR file
in each, which is the file you'll need to deploy to Liferay DXP. You can
deploy each JAR by running \texttt{blade\ deploy} from each module's
root directory.

\noindent\hrulefill

\textbf{Note:} If you deploy your modules out of order, you might
receive error messages. For instance, if you try deploying your web
client module first, you'll receive errors if it relies on the service
implementation and service API modules. Once each module's dependencies
are met, they will successfully be deployed for use in Liferay. For more
information on checking each module's dependencies, see the
\href{/docs/7-0/reference/-/knowledge_base/r/using-the-felix-gogo-shell}{Using
the Felix Gogo Shell} article.

\noindent\hrulefill

Once you've successfully deployed your modules, you can list them from
the Gogo shell as shown below.

\begin{figure}
\centering
\includegraphics{./images/deploy-converted-modules.png}
\caption{Once you've connected to your Liferay instance in your Gogo
shell prompt, run \emph{lb} to list your new converted modules.}
\end{figure}

This tutorial explained how to convert your traditional application into
the modular format of a 7.0 style applicaton. Specifically, you learned
how to

\begin{itemize}
\tightlist
\item
  Create a web client (\texttt{*-web}) module that holds your
  application's portlet classes and UI.
\item
  Create a service implementation module (\texttt{*-service}) and a
  service API module (\texttt{*-api}).
\item
  Run Service Builder to generate code for your application's service
  and API modules.
\item
  Wire your modules together by declaring their dependencies on each
  another.
\item
  Build your modules and deploy them to your Liferay DXP installation.
\end{itemize}

Great job!

\subsection{Related Topics}\label{related-topics-18}

\href{/docs/7-0/tutorials/-/knowledge_base/t/portlets}{Portlets}

\href{/docs/7-0/tutorials/-/knowledge_base/t/service-builder}{Service
Builder}

\section{Migrating Data Upgrade Processes to the New Framework for
Modules}\label{migrating-data-upgrade-processes-to-the-new-framework-for-modules}

When you make changes to your plugin that affect the database, you can
use a \emph{data upgrade process} to upgrade data to the new database
schema. 7.0 has a new data upgrade framework for modules. While the old
framework required several classes, the new framework lets you
orchestrate the upgrade steps from a single class. Managing the steps
from one class facilitates developing upgrade processes. The data
upgrade framework you use depends on your development framework.

\begin{itemize}
\item
  If your
  \href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-plugins-to-liferay-7}{upgraded
  plugin} is a traditional WAR, you don't need to do anything special;
  existing upgrade processes
  \href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-upgrade-planner}{adapted
  to 7.0's API} work as is. The new data upgrade framework is for
  modules only.
\item
  If you converted your upgraded plugin to a module or you have an
  upgraded module, you must migrate any upgrade processes you want to
  continue using to the new data upgrade framework.
\end{itemize}

You can migrate any number of old upgrade processes (starting with the
most recent ones) to the new framework. For example, if your module has
versions 1.0, 1.1, 1.2, and 1.3, but you only expect customers on
versions 1.2 and newer to upgrade, you might migrate upgrade processes
for versions 1.2 and 1.3 only. This tutorial shows you how to migrate to
the new framework.

Before beginning, make sure you know how to create an upgrade process
that uses the new framework.
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-an-upgrade-process-for-your-app}{Click
here} to read the tutorial on creating these upgrade processes.

\noindent\hrulefill

\textbf{Note:} Liferay Portal 6 plugins may also include verify
processes. Although you can migrate the verify processes to 7.0 without
any changes, it's a best practice to perform verification in your
upgrade processes instead.

\noindent\hrulefill

First, you'll review how Liferay Portal 6 upgrade processes work.

\subsection{Understanding Liferay Portal 6 Upgrade
Processes}\label{understanding-liferay-portal-6-upgrade-processes}

Before getting started, it's important to understand how Liferay Portal
6 upgrade processes are structured. As an example, you'll use the
Liferay Portal 6.2 upgrade process for the Knowledge Base Portlet.
\href{https://github.com/liferay/liferay-plugins/tree/6.2.x/portlets/knowledge-base-portlet/docroot/WEB-INF/src/com/liferay/knowledgebase/hook/upgrade}{Click
here} to access it in GitHub.

\begin{figure}
\centering
\includegraphics{./images/upgrade-process-6-2.png}
\caption{The Knowledge Base Portlet's Liferay Portal 6.2 upgrade
process.}
\end{figure}

In Liferay Portal 6 upgrade processes, the upgrade step classes for each
schema version are in folders named after their schema version. For
example, the Knowledge Base Portlet's upgrade step classes are in
folders named \texttt{v1\_0\_0}, \texttt{v1\_1\_0}, \texttt{v1\_2\_0},
and so on. Each upgrade step class extends \texttt{UpgradeProcess} and
overrides the \texttt{doUpgrade} method. The code in \texttt{doUpgrade}
performs the upgrade. For example, the Knowledge Base Portlet's
\href{https://github.com/liferay/liferay-plugins/blob/6.2.x/portlets/knowledge-base-portlet/docroot/WEB-INF/src/com/liferay/knowledgebase/hook/upgrade/v1_0_0/UpgradeRatingsEntry.java}{\texttt{v1\_0\_0/UpgradeRatingsEntry}
upgrade step} extends \texttt{UpgradeProcess} and performs the upgrade
via the \texttt{updateRatingsEntries()} call in its \texttt{doUpgrade}
method:

\begin{verbatim}
public class UpgradeRatingsEntry extends UpgradeProcess {

    @Override
    protected void doUpgrade() throws Exception {
        updateRatingsEntries();
    }

    ...

    protected void updateRatingsEntries() throws Exception {
        // Upgrade code
    }

    ...

}
\end{verbatim}

The upgrade process classes are on the same level as the folders
containing the upgrade steps and are also named after their schema
version. For example, the Knowledge Base Portlet's upgrade process
classes are named \texttt{UpgradeProcess\_1\_0\_0},
\texttt{UpgradeProcess\_1\_1\_0}, \texttt{UpgradeProcess\_1\_2\_0}, and
so on. Each upgrade process class also extends \texttt{UpgradeProcess}
and runs the upgrade process in the \texttt{doUpgrade} method. It runs
the upgrade process by passing the appropriate upgrade step to the
\texttt{upgrade} method. For example, the \texttt{doUpgrade} method in
the Knowledge Base Portlet's
\href{https://github.com/liferay/liferay-plugins/blob/6.2.x/portlets/knowledge-base-portlet/docroot/WEB-INF/src/com/liferay/knowledgebase/hook/upgrade/UpgradeProcess_1_0_0.java}{\texttt{UpgradeProcess\_1\_0\_0}
class} runs the upgrade steps \texttt{UpgradeRatingsEntry} and
\texttt{UpgradeRatingsStats} via the \texttt{upgrade} method:

\begin{verbatim}
@Override
protected void doUpgrade() throws Exception {
    upgrade(UpgradeRatingsEntry.class);
    upgrade(UpgradeRatingsStats.class);
}
\end{verbatim}

Now that you know how Liferay Portal 6 upgrade processes are defined,
you'll learn how to convert them to the new upgrade process framework in
7.0.

\subsection{Converting your Liferay Portal 6 Upgrade Process to
7.0}\label{converting-your-liferay-portal-6-upgrade-process-to-7.0}

So how do Liferay Portal 6 upgrade processes compare to those that use
the new upgrade process framework in 7.0? First, the upgrade step
classes are the same, so you can leave them unchanged. The big change in
7.0's new upgrade processes is that upgrade process classes no longer
exist. Instead, you must combine your upgrade process classes'
functionality into a single registrator class. Recall from
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-an-upgrade-process-for-your-app\#writing-the-upgrade-step-registrator}{the
data upgrade process tutorial} that registrators define an upgrade
process that the upgrade process framework executes. Each
\texttt{registry.register} call in the registrator registers the
appropriate upgrade steps for each schema version. You must therefore
transfer the functionality of your old upgrade process classes'
\texttt{doUpgrade} methods into a registrator's
\texttt{registry.register} calls.

For example,
\href{https://github.com/liferay/liferay-portal/tree/7.0.x/modules/apps/knowledge-base/knowledge-base-service/src/main/java/com/liferay/knowledge/base/internal/upgrade}{click
here} to see the Knowledge Base Portlet's new 7.0 upgrade process in
GitHub.

\begin{figure}
\centering
\includegraphics{./images/upgrade-process-7-0.png}
\caption{The Knowledge Base Portlet's new 7.0 upgrade process.}
\end{figure}

Besides some additional upgrade step classes to handle changes made to
the portlet for 7.0, the only difference in this upgrade process is that
it contains a single registrator class,
\texttt{KnowledgeBaseServiceUpgrade}, instead of multiple upgrade
process classes.
\href{https://github.com/liferay/liferay-portal/blob/7.0.x/modules/apps/knowledge-base/knowledge-base-service/src/main/java/com/liferay/knowledge/base/internal/upgrade/KnowledgeBaseServiceUpgrade.java}{The
\texttt{KnowledgeBaseServiceUpgrade} class}, like all registrators,
calls the appropriate upgrade steps for each schema version in its
\texttt{registry.register} calls. For example, the first
\texttt{registry.register} call registers the upgrade process for the
\texttt{1.0.0} schema version:

\begin{verbatim}
registry.register(
        "com.liferay.knowledge.base.service", "0.0.1", "1.0.0",
        new com.liferay.knowledge.base.internal.upgrade.v1_0_0.
            UpgradeRatingsEntry(),
        new com.liferay.knowledge.base.internal.upgrade.v1_0_0.
            UpgradeRatingsStats());
\end{verbatim}

Compare this to the above \texttt{doUpgrade} method from
\href{https://github.com/liferay/liferay-plugins/blob/6.2.x/portlets/knowledge-base-portlet/docroot/WEB-INF/src/com/liferay/knowledgebase/hook/upgrade/UpgradeProcess_1_0_0.java}{the
corresponding Liferay Portal 6 upgrade process class
\texttt{UpgradeProcess\_1\_0\_0}}. Both call the same upgrade steps.
\href{https://github.com/liferay/liferay-portal/blob/7.0.x/modules/apps/knowledge-base/knowledge-base-service/src/main/java/com/liferay/knowledge/base/internal/upgrade/KnowledgeBaseServiceUpgrade.java}{Click
here} to see the complete \texttt{KnowledgeBaseServiceUpgrade}
registrator class and all its \texttt{registry.register} calls.

That's it! For instructions on creating new upgrade processes for 7.0,
including complete steps on creating a registrator,
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-an-upgrade-process-for-your-app}{click
here}.

\subsection{Related Topics}\label{related-topics-19}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-an-upgrade-process-for-your-app}{Creating
Data Upgrade Processes for Modules}

\href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-plugins-to-liferay-7}{Upgrading
Plugins to 7.0}

\href{/docs/7-0/tutorials/-/knowledge_base/t/from-liferay-6-to-liferay-7}{From
Liferay Portal 6 to 7}

\section{Migrating a Theme from the Plugins SDK to the Liferay Theme
Generator}\label{migrating-a-theme-from-the-plugins-sdk-to-the-liferay-theme-generator}

After you've upgraded your Liferay Portal 6 theme to 7.0, the Themes
Generator offers enhanced development features and tools for optimizing
your theme and streamlining theme management. To introduce one of its
most powerful features, we'll pose some questions.

\textbf{Questions}:

\begin{itemize}
\tightlist
\item
  Do you want to make a temporary change to your theme's UI?
\item
  Do you want to add the same UI modification to all of your themes
  without duplicating code?
\item
  Do you want to share your new theme designs with a colleague?
\item
  Do you want to test a new design concept in your theme without
  altering its code?
\end{itemize}

\textbf{Answer}:
\href{/docs/7-0/tutorials/-/knowledge_base/t/themelets}{Themelets} are
the answer! Themelets are small, extendable, reusable modular pieces of
code that let you make changes to your theme quickly. Because they are
modular, you can use the same themelet for multiple themes!

Themelets are just one of the features you gain from migrating your
existing Ant-based theme project to a
\href{/docs/7-0/tutorials/-/knowledge_base/t/themes-generator}{Liferay
Theme Generator} project. The Liferay Theme Generator is a Node.js-based
tool that gives you access to an array of
\href{/docs/7-0/reference/-/knowledge_base/r/theme-gulp-tasks}{theme
Gulp tasks} that facilitate developing and managing themes.

The \emph{upgrade} Gulp task upgrades Liferay Portal 6 themes to 7.0.
For details, refer to the
\href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-themes}{Upgrading
Themes} tutorial.

In addition to the \emph{upgrade} task, there are tasks for building and
deploying themes and for interacting with deployed themes. For instance,
you can automatically redeploy your theme as you make changes to it.

Do you periodically need to make changes to your theme's settings? No
problem. You can configure your theme's settings through the
command-line wizard that the Liferay Theme Generator provides. All you
have to do is answer a few questions about the settings.

As you can see, the Liferay Theme Generator, Node.js, and Gulp
development tools offer a lot to a Liferay theme developer.

This tutorial assumes that you have already installed the
\href{/docs/7-0/tutorials/-/knowledge_base/t/themes-generator}{Liferay
Theme Generator} and that your upgraded theme was developed with the
Plugins SDK. There are two ways you can migrate your Plugins SDK theme
to the Theme Generator: importing your theme manually into the Theme
Generator or converting it to a Theme Generator project from a
\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-workspace}{Liferay
Workspace}. You'll learn how to import it manually first.

\subsection{Importing Your Theme}\label{importing-your-theme-1}

The Liferay Theme Generator uses \href{http://yeoman.io/}{Yeoman} to
equip theme projects with the new development tools. Follow the steps
below to set up your existing theme in such a project:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Navigate to the directory you want to import your theme into and run
  the following command:

\begin{verbatim}
yo liferay-theme:import
\end{verbatim}

  This runs the import sub-generator for the themes generator.
\item
  Enter the absolute path of the theme you want to import and press
  \texttt{Enter}.
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** you must specify an absolute path, as the themes import
 sub-generator does not support relative paths.
\end{verbatim}

\noindent\hrulefill

\begin{verbatim}
The theme's modified files (the files it modified from the base theme) are
copied and reorganized in a newly created  `src` directory. A `gulpfile.js`,
`liferay-theme.json`, `package.json` file  and a `node_modules` directory
are also added.

Next, the `gulp init` task runs and prompts you with a couple questions.
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\item
  Enter the path to your app server.
\item
  Enter your site's URL (this can be your production site, development
  site, etc.), or press \texttt{Enter} to accept the default
  \texttt{http://localhost:8080}.
\end{enumerate}

Your theme is now set up to use the Node.js build tools and theme Gulp
tasks!

\subsection{Migrating Themes to the Theme Generator Using
Workspace}\label{migrating-themes-to-the-theme-generator-using-workspace}

If you're a theme developer who wants to use Liferay Workspace to
migrate your Plugins SDK theme to the Theme Generator, you can execute a
single command to convert the theme project. Before beginning, make sure
your Plugins SDK has been
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-a-liferay-workspace-with-blade-cli\#configuring-a-plugins-sdk-in-your-workspace}{converted
to a Liferay Workspace}.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Using a command line tool, navigate to the root folder of your
  workspace.
\item
  Execute the following command to migrate your Plugins SDK theme to a
  Theme Generator theme:

\begin{verbatim}
blade convert [PLUGINS_SDK_THEME_NAME]
\end{verbatim}

  Blade CLI extracts the theme from the nested Plugins SDK folder and
  reorganizes it into a standard Theme Generator project. The converted
  theme is available in the workspace's \texttt{themes} folder.
\end{enumerate}

That's it! Your Plugins SDK theme is now available as a Liferay Theme
Generator project residing in Liferay Workspace.

\subsection{Related Articles}\label{related-articles-2}

\href{/docs/7-0/tutorials/-/knowledge_base/t/introduction-to-themes}{Introduction
to Themes}

\href{/docs/7-0/tutorials/-/knowledge_base/t/themes-generator}{Liferay
Theme Generator}

\href{/docs/7-0/tutorials/-/knowledge_base/t/themelets}{Themelets}

\href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-themes}{Upgrading
Themes}

\section{Migrating a Theme from the Plugins SDK to
Workspace}\label{migrating-a-theme-from-the-plugins-sdk-to-workspace}

After you've adapted your Plugins SDK theme to Liferay DXP's API, you
can continue maintaining it in the Plugins SDK. The Plugins SDK,
however, is deprecated as of 7.0. Maintaining plugins in the SDK will
become increasingly difficult.
\href{/docs/7-0/tutorials/-/knowledge_base/t/improved-developer-tooling-liferay-workspace-maven-plugins-and-more\#from-the-plugins-sdk-to-liferay-workspace}{Liferay
Workspace replaces the Plugins SDK}, providing a comprehensive Gradle
development environment and more. A simple command migrates Plugins SDK
(Ant-based) themes to Workspace (Gradle-based) themes. From there you
can build and deploy them to 7.0 as Web ARchives (WARs).

\subsection{Running the Migration
Command}\label{running-the-migration-command-1}

\href{/docs/7-0/tutorials/-/knowledge_base/t/blade-cli}{Blade CLI's}
\texttt{convert} command migrates Plugins SDK themes to Workspace themes
in Workspace's \texttt{wars} folder. Theme files are re-organized to
follow the standard 7.0
\href{/docs/7-0/reference/-/knowledge_base/r/theme-reference-guide\#theme-anatomy}{theme
folder structure}.

In a terminal, navigate to the Liferay Workspace root folder. Then pass
your Plugins SDK theme's name to Blade CLI's \texttt{convert} command:

\begin{verbatim}
blade convert --themebuilder [THEME_PROJECT_NAME]
\end{verbatim}

Blade CLI extracts the plugin from the Plugins SDK and reorganizes it in
a standard web application project in Workspace's \texttt{wars} folder.
Blade CLI uses the
\href{/docs/7-0/tutorials/-/knowledge_base/t/theme-builder}{Theme
Builder} plugin to migrate your theme to a workspace. You can also
migrate your Plugins SDK theme to a Liferay Theme Generator theme using
Blade CLI. Follow the
\href{/docs/7-0/tutorials/-/knowledge_base/t/migrating-a-6-2-theme-to-liferay-7\#migrating-themes-to-the-theme-generator-using-workspace}{Migrating
Themes to the Theme Generator Using Workspace} tutorial for more
information.

The image below shows the theme files before and after they're migrated
to Workspace.

\begin{figure}
\centering
\includegraphics{./images/convert-theme-compare-folder-structure.png}
\caption{The \texttt{convert} command migrates a Plugins SDK theme
project to a Workspace theme project.}
\end{figure}

From your theme's new location, you can
\href{/docs/7-0/tutorials/-/knowledge_base/t/development-lifecycle-for-a-liferay-workspace\#building-modules}{deploy}
it to 7.0 and maintain it using
\href{/docs/7-0/tutorials/-/knowledge_base/t/improved-developer-tooling-liferay-workspace-maven-plugins-and-more\#plugins-sdk-to-workspace-task-map}{Workspace
Gradle tasks}. Welcome to your theme's new home in Workspace!

\subsection{Related Topics}\label{related-topics-20}

\href{/docs/7-0/tutorials/-/knowledge_base/t/migrating-a-6-2-theme-to-liferay-7}{Migrating
a Theme from the Plugins SDK to the Theme Generator}

\href{/docs/7-0/tutorials/-/knowledge_base/t/development-lifecycle-for-a-liferay-workspace\#building-modules}{Workspace
Development lifecycle}

\href{/docs/7-0/tutorials/-/knowledge_base/t/improved-developer-tooling-liferay-workspace-maven-plugins-and-more\#plugins-sdk-to-workspace-task-map}{Workspace
Gradle Tasks}

\section{Customization with Ext
Plugins}\label{customization-with-ext-plugins}

\noindent\hrulefill

\textbf{Ext plugins are deprecated for 7.0 and should only be used if
absolutely necessary. They are deployable to Liferay Portal 7.0 CE
GA4+.}

The following app servers should be used for Ext plugin development in
Liferay DXP:

\begin{itemize}
\tightlist
\item
  Tomcat 8.0
\end{itemize}

In most cases, Ext plugins are no longer necessary. There are, however,
certain cases that require the use of an Ext plugin. Liferay only
supports the following Ext plugin use cases:

\begin{itemize}
\tightlist
\item
  Providing custom implementations for any beans declared in Liferay
  DXP's Spring files (when possible, use
  \href{/docs/7-0/tutorials/-/knowledge_base/t/customizing-liferay-services-service-wrappers}{service
  wrappers} instead of an Ext plugin). 7.0 removed many beans, so make
  sure your overridden beans are still relevant if converting your
  legacy Ext plugin.
\item
  Overwriting a class in a 7.0 core JAR. For a list of core JARs, see
  the
  \href{/docs/7-0/tutorials/-/knowledge_base/t/configuring-dependencies\#finding-core-artifacts}{Finding
  Core Liferay DXP Artifacts} section.
\item
  Modifying Liferay DXP's \texttt{web.xml} file.
\item
  Adding to Liferay DXP's \texttt{web.xml} file.
\end{itemize}

\noindent\hrulefill

Ext plugins are powerful tools used to extend Liferay DXP. They,
however, increase the complexity of your Liferay DXP instance and are
not recommended unless there is absolutely no other way to accomplish
your task. 7.0 provides many extension points that let you customize
almost every detail of Liferay DXP. If there's a way to customize what
you want with an extension point, do it that way instead. See the
\href{/docs/7-0/tutorials/-/knowledge_base/t/benefits-of-liferay-7-for-liferay-6-developers\#more-extensible-easier-to-maintain}{More
Extensible, Easier to Maintain} section for more details on the
advantages of using Liferay DXP's extension points.

Before deciding to use an Ext plugin, weigh the cost. Ext plugins let
you use internal APIs and even let you overwrite Liferay DXP core files.
This puts your deployment at risk of being incompatible with security,
performance, or feature updates released by Liferay. When upgrading to a
new version of Liferay DXP (even if it's a maintenance version or a
service pack), you have to review all changes and manually modify your
Ext plugin to merge your changes with Liferay DXP's. Additionally, Ext
plugins aren't hot deployable. To deploy an Ext plugin, you must restart
your server. Additional steps are also required to deploy or redeploy to
production systems.

In this tutorial, you'll learn how to

\begin{itemize}
\tightlist
\item
  \hyperref[creating-an-ext-plugin]{Create an Ext plugin}
\item
  \hyperref[developing-an-ext-plugin]{Develop an Ext plugin}
\item
  \hyperref[deploying-in-production]{Deploy an Ext plugin in Production}
\end{itemize}

Before diving into creating an Ext plugin, however, first consider if an
Ext plugin is even necessary at all.

\subsection{Making the Decision to Use Ext
Plugins}\label{making-the-decision-to-use-ext-plugins}

There are many parts of Liferay DXP that now provide an extension point
via OSGi bundle. You should follow this three step process to decide
whether an Ext plugin is necessary:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Find the OSGi extension point that you need. You can follow the
  \href{/docs/7-0/tutorials/-/knowledge_base/t/finding-extension-points}{Finding
  Extension Points} tutorial as a guide.
\item
  If an OSGi extension point does not exist, use an Ext plugin.
\item
  Research new extension points after every release of Liferay DXP. When
  a new version of Liferay DXP provides the extension point you need,
  always use the extension point to replace the existing Ext plugin.
\end{enumerate}

So how do you find an OSGi extension point?

Your first step is to examine the custom module projects that extend
popular Liferay DXP extension points stored in the
\href{https://github.com/liferay/liferay-blade-samples}{Liferay Blade
Samples} repository. For more information on these sample projects, see
the
\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-sample-modules}{Liferay
Sample Projects} tutorial. Usable extension points are also documented
throughout Liferay's Developer Network categorized by the Liferay DXP
section involved. For example,
\href{/docs/7-0/tutorials/-/knowledge_base/t/overriding-mvc-commands}{Overriding
MVC Commands} and
\href{/docs/7-0/tutorials/-/knowledge_base/t/customizing-the-product-menu}{Customizing
the Product Menu} are articles describing how to extend a Liferay DXP
extension point. Want to learn how to
\href{/docs/7-0/tutorials/-/knowledge_base/t/overriding-a-modules-jsps}{override
module JSPs} or
\href{/docs/7-0/tutorials/-/knowledge_base/t/overriding-core-jsps}{Liferay
DXP core JSPs}? Those processes are documented too!

There are a few corner cases where you may need an Ext plugin to
customize a part of Liferay DXP that does not provide an extension
point. Refer to the top of this tutorial for Ext plugin use cases
supported by Liferay.

\noindent\hrulefill

\textbf{Note:} In previous versions of Liferay Portal, you needed an Ext
plugin to specify classes as portal property values (e.g.,
\texttt{global.starup.events.my.custom.MyStartupAction}), since the
custom class had to be added to the portal class loader. This is no
longer the case in 7.0 since all lifecycle events can use OSGi services
with no need to edit these legacy properties.

\noindent\hrulefill

Now that you know how to make an informed decision on using Ext plugins,
you'll learn how to create one next.

\subsection{Creating an Ext Plugin}\label{creating-an-ext-plugin}

An Ext plugin is a powerful tool for extending Liferay DXP. Because it
increases the complexity of your Liferay DXP installation, you should
only use an Ext plugin if you're sure you can't accomplish your goal in
a different way. You can only create Ext plugins from a Plugins SDK. If
you're using a
\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-workspace}{Liferay
Workspace} to create your @project@ projects, you can
\href{/docs/7-0/tutorials/-/knowledge_base/t/configuring-a-liferay-workspace\#using-a-plugins-sdk-from-your-workspace}{merge
a Plugins SDK instance} into the workspace.

\subsubsection{Creating an Ext Plugin Using Liferay
@ide@}\label{creating-an-ext-plugin-using-liferay-ide}

Follow the steps below, replacing the project name with your own, to
create a custom Ext plugin:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Go to \emph{File} → \emph{New} → \emph{Liferay Plugin Project}.
\item
  Enter your project's name and its display name. In the figure below,
  \emph{example} is used for both. Note that the Display name field is
  automatically filled in with the capitalized version of the Project
  name.

  \begin{figure}
  \centering
  \includegraphics{./images/ext-create-an-ext-plugin-project.png}
  \caption{You can create an Ext plugin project with Liferay @ide@.}
  \end{figure}
\item
  Select the \emph{Ant (liferay-plugins-sdk)} option for your build
  type.
\item
  Select the \emph{Ext} plugin type. Then click \emph{Next}.
\item
  If you have not yet configured a Plugins SDK, select \emph{Next} and
  choose the Plugins SDK for which you want to generate the Ext plugin.
  Once you have your Plugins SDK configured, click \emph{Finish}.
\end{enumerate}

The Plugins SDK automatically appends \texttt{-ext} to the plugin
project name when it creates your Ext plugin's project folder. Your Ext
plugin project is added to your configured Plugins SDK instance and is
also available via @ide@'s Package Explorer for further development.

\subsubsection{Creating an Ext Plugin Using the Command
Line}\label{creating-an-ext-plugin-using-the-command-line}

To create a new Ext plugin from the command line, navigate to the
\texttt{ext} folder in your Liferay Plugins SDK and enter the command
below appropriate for your operating system. The two arguments after the
\texttt{create} command are the project name and display name,
respectively. The examples below use the project name \emph{example} and
the display name \emph{Example}. Make sure to specify values you want to
use for your Ext plugin's project name and display name.

In Linux or Mac OS, enter:

\begin{verbatim}
./create.sh example "Example"
\end{verbatim}

In Windows, enter:

\begin{verbatim}
create.bat example "Example"
\end{verbatim}

A \texttt{BUILD\ SUCCESSFUL} message from Ant tells you there's a new
folder (e.g., folder \texttt{example-ext} for a project named
\emph{example}) inside your Plugins SDK's \texttt{ext} folder. The
Plugins SDK automatically appends \texttt{-ext} to the project name.

\subsubsection{Anatomy of an Ext Plugin}\label{anatomy-of-an-ext-plugin}

There are a few things to note about an Ext plugin's folder structure.
Below is a listing of an Ext folder structure:

\begin{itemize}
\tightlist
\item
  \texttt{{[}project\ name{]}-ext/}

  \begin{itemize}
  \tightlist
  \item
    \texttt{docroot/}

    \begin{itemize}
    \tightlist
    \item
      \texttt{WEB-INF/}

      \begin{itemize}
      \tightlist
      \item
        \texttt{ext-impl/}

        \begin{itemize}
        \tightlist
        \item
          \texttt{src/}
        \end{itemize}
      \item
        \texttt{ext-lib/}

        \begin{itemize}
        \tightlist
        \item
          \texttt{global/}
        \item
          \texttt{portal/}
        \end{itemize}
      \item
        \texttt{ext-service/}

        \begin{itemize}
        \tightlist
        \item
          \texttt{src/}
        \end{itemize}
      \item
        \texttt{ext-util-bridges/}

        \begin{itemize}
        \tightlist
        \item
          \texttt{src/}
        \end{itemize}
      \item
        \texttt{ext-util-java/}

        \begin{itemize}
        \tightlist
        \item
          \texttt{src/}
        \end{itemize}
      \item
        \texttt{ext-util-taglib/}

        \begin{itemize}
        \tightlist
        \item
          \texttt{src/}
        \end{itemize}
      \item
        \texttt{ext-web/}

        \begin{itemize}
        \tightlist
        \item
          \texttt{docroot/}
        \end{itemize}
      \end{itemize}
    \end{itemize}
  \end{itemize}
\end{itemize}

Here are detailed explanations of the \texttt{/docroot/WEB-INF/}
subfolders:

\begin{itemize}
\item
  \texttt{ext-impl/src}: Contains the custom implementation classes and
  classes that override core classes from \texttt{portal-impl.jar}.
\item
  \texttt{ext-lib/global}: Contains libraries to be copied to the
  application server's global classloader upon deployment of the Ext
  plugin.
\item
  \texttt{ext-lib/portal}: Contains libraries to be copied inside
  Liferay's main application. These libraries are usually necessary
  because they're invoked from classes you add in \texttt{ext-impl/src}.
\item
  \texttt{ext-kernel/src}: Contains classes that should be available to
  other plugins. In advanced scenarios, this folder can be used to hold
  classes that overwrite classes from \texttt{portal-kernel.jar}.
\item
  \texttt{ext-web/docroot}: Contains the web application's configuration
  files, including \texttt{WEB-INF/struts-config-ext.xml}, which lets
  you customize Liferay's core struts classes. Note that for 7.0, there
  are very few entities left to override in the
  \texttt{struts-config.xml} file. Any JSPs that you're customizing also
  belong here.
\item
  \texttt{ext-util-bridges}, \texttt{ext-util-java} and
  \texttt{ext-util-taglib}: These folders are needed only in scenarios
  where you must customize these Liferay libraries:
  \texttt{util-bridges.jar}, \texttt{util-java.jar} and
  \texttt{util-taglib.jar}, respectively. If you're not customizing any
  of these libraries, you can ignore these folders.
\end{itemize}

By default, several files are also added to the plugin. Here are the
most significant files:

\begin{itemize}
\item
  \texttt{build.xml}: The Ant build file for the Ext plugin project.
\item
  \href{@platform-ref@/7.0-latest/propertiesdoc/liferay-plugin-package_7_0_0.properties.html}{\texttt{docroot/WEB-INF/liferay-plugin-package.properties}}:
  Contains plugin-specific properties, including the plugin's display
  name, version, author, and license type.
\item
  \texttt{docroot/WEB-INF/ext-web/docroot/WEB-INF} files:

  \begin{itemize}
  \tightlist
  \item
    \texttt{portlet-ext.xml}: Used to overwrite the definition of a
    build-in portlet. The \texttt{portlet.xml} file contains very few
    portlet configurations in 7.0 because portlets were modularized and
    moved out of core. To override this file, copy the complete
    definition of the desired portlet from \texttt{portlet-custom.xml}
    in Liferay's source code, then apply the necessary changes.
  \item
    \texttt{liferay-portlet-ext.xml}: This file is similar to
    \texttt{portlet-ext.xml}, but is for additional definition elements
    specific to Liferay. The \texttt{liferay-portlet.xml} file contains
    very few definition elements in 7.0 because portlets were
    modularized and moved out of core. To override the remaining
    definition elements, copy the complete definition of the desired
    portlet from \texttt{liferay-portlet.xml} in Liferay's source code,
    then apply the necessary changes.
  \item
    \texttt{struts-config-ext.xml} and \texttt{tiles-defs-ext.xml}:
    These files are used to customize the struts actions used by core
    portlets. Since most portlets were modularized and moved out of core
    in 7.0, the \texttt{struts-config.xml} and \texttt{tiles-defs.xml}
    files are sparsely used.
  \item
    \texttt{web.xml}: Used to overwrite web application configurations
    and servlet information for 7.0.
  \end{itemize}
\end{itemize}

\noindent\hrulefill

\textbf{Note:} After creating an Ext plugin, remove the files from
\texttt{docroot/WEB-INF/ext-web/docroot/WEB-INF} that you don't need to
customize. Removing files you're not customizing prevents
incompatibilities that could manifest from Liferay DXP updates.

\noindent\hrulefill

Great! You've now created an Ext plugin and are familiar with its folder
structure and its most significant files. Next, you'll use your Ext
plugin to customize Liferay DXP.

\subsection{Developing an Ext Plugin}\label{developing-an-ext-plugin}

An Ext plugin changes Liferay DXP itself when the plugin is deployed;
it's not a separate component that you can easily remove at any time.
For this reason, the Ext plugin development process is different from
other plugin types. It's important to remember that once an Ext plugin
is deployed, some of its files are copied \emph{inside} the Liferay
installation; the only way to remove the changes is by
\emph{redeploying} an unmodified Liferay application. You're also
responsible for checking that patches and fix packs do not conflict with
your Ext plugin.

The 7.0 compatible Plugins SDK is designed to only develop/deploy one
Ext plugin. This means that all your customizations should live inside
one Ext plugin. The Plugins SDK does not check for conflicts among
multiple Ext plugins stored in the \texttt{/ext} folder, so do
\textbf{not} develop/deploy multiple Ext plugins at once.

The Plugins SDK lets you deploy and redeploy your Ext plugin during your
development phase. Redeployment involves \emph{cleaning} (i.e.,
removing) your application server and unzipping your specified Liferay
bundle to start from scratch. That way, any changes made to the Ext
plugin during development are properly applied, and files removed from
your plugin by previous changes aren't left behind in the Liferay DXP
application. Because of this added complexity, you should use another
plugin type to accomplish your goals whenever possible.

Before digging in to the details, here's an overview of the Ext plugin
development processes described below:

\begin{itemize}
\tightlist
\item
  \emph{Configure} your Plugins SDK environment to develop Ext plugins
  for Liferay DXP on your application server.
\item
  \emph{Deploy} and \emph{publish} your Ext plugins for the first time.
\item
  \emph{Redeploy} normally or use a \emph{clean redeployment} process
  after making changes to your Ext plugins.
\item
  \emph{Package} your Ext plugins for distribution.
\item
  A list of advanced customization techniques.
\end{itemize}

It's time to learn each step of the development process.

\subsubsection{Set Up the Build
Environment}\label{set-up-the-build-environment}

Before deploying an Ext plugin, you must edit the
\texttt{build.{[}username{]}.properties} file in the root folder of your
Plugins SDK. If the file doesn't yet exist, create it now. Substitute
\texttt{{[}username{]}} with your user ID on your computer. Once you've
opened your build properties file, add the following properties--make
sure the individual paths reflect the right locations on your system:

\begin{verbatim}
ext.work.dir=[work]

app.server.dir=[work]/liferay-ce-portal-[version]/[app server]

app.server.zip.name=[...]/liferay-ce-portal-[app server].zip
\end{verbatim}

Your \texttt{app.server.zip.name} property must specify the path to your
Liferay DXP \texttt{.zip} file. The \texttt{work} folder you specify for
the \texttt{ext.work.dir} property is where you've unzipped your Liferay
DXP runtime. The \texttt{app.server.dir} property must point to your
application server's directory in your work folder. Look in your Liferay
DXP bundle at the path to the application server to determine the value
to use for your \texttt{app.server.dir} property.

For example, if your work folder is \texttt{C:/work}, specify it as your
\texttt{ext.work.dir} property's value. If your Liferay DXP bundle
\texttt{.zip} file is
\texttt{C:/downloads/liferay-ce-portal-tomcat-7.0-ga4-{[}timestamp{]}.zip},
set the \texttt{app.server.zip.name} property to that file's path. If
the \emph{relative path} to the application server \emph{within} the
Liferay DXP bundle \texttt{.zip} file is
\texttt{liferay-ce-portal-7.0-ga4\textbackslash{}tomcat-8.0.32}, specify
an \texttt{app.server.dir} property value
\texttt{C:/work/liferay-ce-portal-7.0-ga4/tomcat-8.0.32}.

Next you'll modify the Ext plugin you created and deploy it.

\subsubsection{Initial Deployment}\label{initial-deployment}

Your environment is set up and you're ready to start customizing. Once
you're finished, you can deploy the plugin.

\paragraph{Deploy the Plugin}\label{deploy-the-plugin}

Now you'll learn how to deploy your plugin using Liferay @ide@ or the
command line.

\subparagraph{Deploying in Liferay
@ide@}\label{deploying-in-liferay-ide}

Drag your Ext plugin project from your Package Explorer onto your server
to deploy your plugin. Liferay @ide@ automatically restarts the server
for the server to detect and publish your Ext plugin.

After deploying, if you don't see your customizations in the portal,
your Ext plugin may not have successfully deployed. To confirm whether
the Ext plugin deploys successfully, try deploying from the command
line; the Ant deployment targets report success or failure.

\subparagraph{Deploying via the Command
Line}\label{deploying-via-the-command-line}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open a command line window in your Ext plugin project folder and enter
  one of these commands:

\begin{verbatim}
ant deploy

ant direct-deploy
\end{verbatim}

  The \texttt{direct-deploy} target deploys all changes directly to the
  appropriate folders in the Liferay application. The \texttt{deploy}
  target creates a \texttt{.war} file with your changes and then deploys
  it to your server. Either way, your server must be restarted after the
  deployment. Using \texttt{direct-deploy} is preferred for deploying an
  Ext plugin during development if your application server supports it.
  Direct deploy doesn't work in WebLogic or WebSphere application server
  environments.

  A \texttt{BUILD\ SUCCESSFUL} message indicates your plugin is now
  being deployed. Your console window running Liferay DXP shows a
  message like this:

\begin{verbatim}
    Extension environment for [your project]-ext has been applied. You must
    reboot the server and redeploy all other plugins
\end{verbatim}

  If any changes applied through the Ext plugin affect the deployment
  process itself, you must redeploy all other plugins. Even if the Ext
  plugin doesn't affect the deployment process, it's a best practice to
  redeploy all your other plugins following initial deployment of the
  Ext plugin.

  The \texttt{ant\ deploy} target builds a \texttt{.war} file with your
  changes and copies them to the auto-deploy folder inside the Liferay
  DXP installation. When the server starts, it detects the \texttt{.war}
  file, inspects it, and copies its contents to the appropriate
  destinations inside the deployed and running Liferay application.
\item
  Restart the server so that it detects and publishes your Ext plugin.

  Once your server restarts, open Liferay DXP to see the customizations
  you made with your Ext plugin.
\end{enumerate}

Frequently, you'll want to add further customizations to your original
Ext plugin. You can make unlimited customizations to an Ext plugin that
has already been deployed, but the redeployment process is different
from other project types. You'll learn more on redeploying your Ext
plugin next.

\subsubsection{Redeployment}\label{redeployment}

So far, Ext plugin development has been similar to the development of
other plugin types. You've now reached the point of divergence. When the
plugin is first deployed, some of its files are copied into the Liferay
DXP installation. After changing an Ext plugin, you'll either
\emph{clean redeploy} or \emph{redeploy}, depending on the modifications
you made to your plugin following the initial deployment. You'll learn
about each redeployment method and when to use each one.

\paragraph{Clean Redeployment}\label{clean-redeployment}

If you removed part(s) of your plugin, if there are changes to your
plugin that can affect plugin deployment, or if you want to start with a
clean Liferay DXP environment, \emph{undeploy} your plugin and
\emph{clean} your application server before redeploying your Ext plugin.
By cleaning the application server, the existing Liferay DXP
installation is removed and the bundle specified in your Plugins SDK
environment is unzipped in its place. See the instructions below to
learn more about this process.

\subparagraph{Using Liferay @ide@}\label{using-liferay-ide}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Remove the plugin from the server. While selecting the Ext plugin in
  the \emph{Servers} view, select the plugin's \emph{Remove} option.
\item
  Clean the application server. Remember to shut down the application
  server before cleaning it. This is required on Windows because the
  server process locks the installed Liferay bundle's files.

  While selecting the Ext plugin project in the \emph{Package Explorer}
  view, select the plugin's \emph{Liferay} → \emph{Clean App
  Server\ldots{}} option.

  \begin{figure}
  \centering
  \includegraphics{./images/ext-plugins-clean-app-server.png}
  \caption{How to clean your app server}
  \end{figure}
\item
  Start the Liferay server.
\item
  Drag the Ext plugin and drop it onto the Liferay server.
\item
  While selecting the Liferay server in the \emph{Servers} view, click
  the \emph{Publish} option.
\end{enumerate}

\subparagraph{Using the Command Line}\label{using-the-command-line}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Stop the Liferay DXP server.
\item
  To deploy your Ext plugin, enter the following commands into your
  console:

\begin{verbatim}
cd [your-plugin-ext]
ant clean-app-server
ant direct-deploy
\end{verbatim}
\item
  Start the Liferay DXP server.
\end{enumerate}

\paragraph{Redeployment}\label{redeployment-1}

If you only added to your plugin or made modifications that don't affect
the plugin deployment process, you can redeploy the Ext plugin. Follow
the steps based on the tool you're using.

\subparagraph{Using Liferay @ide@}\label{using-liferay-ide-1}

Right-click your plugin located underneath your server and select
\emph{Redeploy}.

\subparagraph{Using the Command Line}\label{using-the-command-line-1}

Using the same procedure as for initial deployment. Open a command line
window in your Ext plugin project's directory and execute either
\texttt{ant\ deploy} or \texttt{ant\ direct-deploy}.

After your plugin is published to Liferay DXP, verify that your
customizations are available.

Next you'll learn how to package an Ext plugin for distribution and
production.

\subsubsection{Distribution}\label{distribution}

Once you're finished developing an Ext plugin, you can package it in a
\texttt{.war} file for distribution and production deployment.

\paragraph{Using Liferay @ide@}\label{using-liferay-ide-2}

With your Ext plugin project selected in the \emph{Package Explorer}
view, select the project's \emph{Liferay} → \emph{SDK} → \emph{war}
option.

\paragraph{Using the Command Line}\label{using-the-command-line-2}

From your Ext plugin's directory execute

\begin{verbatim}
ant war
\end{verbatim}

The \texttt{.war} file is written to your
\texttt{{[}liferay-plugins{]}/dist} directory.

Now that you've learned the basics of Ext plugin development, you'll
look at some advanced customizations.

\subsubsection{Using Advanced Configuration
Files}\label{using-advanced-configuration-files}

Liferay DXP uses several internal configuration files for its own
architecture; in addition, there are configuration files for the
libraries and frameworks Liferay DXP depends on, like Struts and Spring.
Configuration could be accomplished using fewer files with more
properties in each, but maintenance and use is made easier by splitting
up the configuration properties into several files. For advanced
customization needs, it may be useful to override the configuration
specified in multiple configuration files. Liferay DXP provides a clean
way to do this from an Ext plugin without modifying the original files.

All the configuration files in Liferay DXP are listed below by their
path in an Ext plugin folder. Here are descriptions of what each file is
for and the path to the original file in Liferay DXP:

\begin{itemize}
\tightlist
\item
  \texttt{ext-impl/src/META-INF/ext-model-hints.xml}

  \begin{itemize}
  \tightlist
  \item
    \textbf{Description:} Overrides the default properties of the fields
    of the data models used by Liferay DXP's core portlets. These
    properties determine how the form fields for each model are
    rendered.
  \item
    \textbf{Original file in Liferay DXP:}
    \texttt{portal-impl/src/META-INF/portal-model-hints.xml}
  \end{itemize}
\item
  \texttt{ext-impl/src/META-INF/ext-spring.xml}

  \begin{itemize}
  \tightlist
  \item
    \textbf{Description:} Overrides the Spring configuration used by
    Liferay DXP and any of its core portlets. It's most commonly used to
    configure specific data sources or swap the implementation of a
    default service with a custom one.
  \item
    \textbf{Original file in Liferay DXP:}
    \texttt{portal-impl/src/META-INF/*-spring.xml}
  \end{itemize}
\item
  \texttt{ext-impl/src/META-INF/portal-log4j-ext.xml}

  \begin{itemize}
  \tightlist
  \item
    \textbf{Description:} Allows overriding the Log4j configuration. It
    can be used to configure appenders for log file location, naming,
    and rotation. See the
    \href{https://wiki.apache.org/logging-log4j/Log4jXmlFormat}{Log4j
    XML Configuration Primer}.
    \href{/docs/7-0/tutorials/-/knowledge_base/t/adjusting-module-logging}{Increasing
    or decreasing the log level of a class or class hierarchy} is best
    done outside of an Ext plugin, in Liferay DXP's' UI or a Log4j XML
    file in a module or the \texttt{osgi/log4j} folder.
  \item
    \textbf{Original file in Liferay:}
    \texttt{portal-impl/src/META-INF/portal-log4j.xml}
  \end{itemize}
\item
  \texttt{ext-web/docroot/WEB-INF/portlet-ext.xml}

  \begin{itemize}
  \tightlist
  \item
    \textbf{Description:} Overrides the core portlets' declarations.
    It's most commonly used to change the init parameters or the roles
    specified.
  \item
    \textbf{Original file in Liferay DXP:}
    \texttt{portal-web/docroot/WEB-INF/portlet-custom.xml}
  \end{itemize}
\item
  \texttt{ext-web/docroot/WEB-INF/liferay-portlet-ext.xml}

  \begin{itemize}
  \tightlist
  \item
    \textbf{Description:} Overrides the Liferay-specific core portlets'
    declarations. It core portlets included in Liferay DXP. Refer to the
    \href{@platform-ref@/7.0-latest/definitions/liferay-portlet-app_7_0_0.dtd.html}{liferay-portlet-app\_7\_0\_0.dtd}
    file for details on all the available options. Use this file with
    care; the code of the portlets may be assuming some of these options
    to be set to certain values.
  \item
    \textbf{Original file in Liferay DXP:}
    \texttt{portal-web/docroot/WEB-INF/liferay-portlet.xml}
  \end{itemize}
\item
  \texttt{ext-web/docroot/WEB-INF/liferay-display.xml}

  \begin{itemize}
  \tightlist
  \item
    \textbf{Description:} Overrides the portlets that are shown in the
    interface for adding applications and the categories in which
    they're organized.
  \item
    \textbf{Original file in Liferay DXP:}
    \texttt{portal-web/docroot/WEB-INF/liferay-display.xml}
  \end{itemize}
\end{itemize}

You'll learn how to deploy your Ext plugin in production next.

\subsection{Deploying in Production}\label{deploying-in-production}

Often, you can't use Ant to deploy web applications in production or
pre-production environments. Additionally, some application servers such
as WebSphere or WebLogic have their own deployment tools and don't work
with Liferay DXP's auto-deployment process. Here are two methods to
consider for deploying and redeploying an Ext plugin in production.

\subsubsection{Method 1: Redeploying Liferay's Web
Application}\label{method-1-redeploying-liferays-web-application}

You can use this method in any application server that supports
auto-deployment; What's the benefit? The only artifact that needs to be
transferred to the production system is your Ext plugin's \texttt{.war}
file, produced using the \texttt{ant\ war} target. This \texttt{.war}
file is usually small and easy to transport. Execute these steps on the
server:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Redeploy Liferay DXP:

  If this is your first time deploying your Ext plugin to this server,
  skip this step. Otherwise, start by executing the same steps you first
  used to deploy Liferay DXP on your app server. If you're using a
  bundle, unzip it again. If you installed Liferay DXP manually on an
  existing application server, you must redeploy the Liferay DXP
  \texttt{.war} file and copy both the libraries required globally by
  Liferay DXP and your Ext plugin to the appropriate folder within the
  application server.
\item
  Copy the Ext plugin \texttt{.war} into the auto-deploy folder. For a
  bundled Liferay DXP distribution, the \texttt{deploy} folder is in
  Liferay's \emph{root} folder of your bundle (e.g.,
  \texttt{liferay-ce-portal-{[}version{]}/}).
\item
  Once the Ext plugin is detected and deployed by Liferay DXP, restart
  your Liferay DXP server.
\end{enumerate}

\subsubsection{Method 2: Generate an Aggregated WAR
File}\label{method-2-generate-an-aggregated-war-file}

Some application servers don't support auto-deploy; WebSphere and
WebLogic are two examples. With an aggregated \texttt{.war} file, the
Ext plugin is merged before deployment to production. A single
\texttt{.war} file then contains Liferay DXP plus the changes from your
Ext plugin. Before you deploy the aggregated Liferay DXP \texttt{.war}
file, copy the dependency \texttt{.jar} files for Liferay DXP and your
Ext plugin to the global application server class loader in the
production server. The precise location varies from server to server;
refer to \href{/docs/7-2/deploy}{Deployment} to get the details for your
application server.

To create the aggregated \texttt{.war} file, deploy the Ext plugin first
to the Liferay DXP bundle you are using in your development environment.
Once it's deployed, restart the server so that the plugin is fully
deployed and shut it down again. Now the aggregated file is ready.

Create a \texttt{.war} file by zipping the Liferay web application
folder from within the app server. Copy into your application server's
global classpath all of the libraries on which your Ext plugin depends.

Now, perform these actions on your server:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Redeploy Liferay DXP using the aggregated \texttt{.war} file.
\item
  Stop the server and copy the new version of the global libraries to
  the appropriate directory in the application server.
\end{enumerate}

Next, you'll learn about Liferay's licensing and contributing standards.

\subsection{Licensing and
Contributing}\label{licensing-and-contributing}

Liferay DXP is Open Source software licensed under the
\href{http://www.gnu.org/licenses/lgpl-2.1.html}{LGPL 2.1 license}. If
you reuse any code snippet and redistribute it, whether publicly or to a
specific customer, make sure your modifications are compliant with the
license. One common way is to make the source code of your modifications
are available to the community under the same license. Make sure you
read the license text yourself to find the option that best fits your
needs.

If your goal in making changes is fixing a bug or improving Liferay DXP,
it could be of interest to a broader audience. Consider contributing it
back to the project. That benefits all users of the product including
you, since you won't have to maintain the changes with each newly
released version of Liferay DXP. You can notify Liferay of bugs or
improvements at \href{http://issues.liferay.com}{issues.liferay.com}.
Check out the
\href{https://portal.liferay.dev/participate/}{Participate} section of
\href{https://portal.liferay.dev}{portal.liferay.dev}, to learn all the
ways that you can contribute to the Liferay Portal project.

In summary, an Ext plugin is a powerful way to extend Liferay DXP. There
are no limits to what you can customize, so use it carefully. Before
using an Ext plugin, see if you can implement all or part of the desired
functionality through
\href{/docs/7-0/tutorials/-/knowledge_base/t/application-display-templates}{Application
Display Templates} or a different plugin type. OSGi modules offer you a
lot of extension capabilities themselves, without introducing the
complexity that's inherent with Ext plugins. If you need to use an Ext
plugin, make your customization as small as possible and follow the
instructions in this tutorial carefully to avoid issues.

\chapter{Developing a Web
Application}\label{developing-a-web-application}

In this Learning Path, you'll create the Liferay Guestbook Web
Application from scratch using tools like Liferay @ide@ and BLADE tools.
As you create this application, you'll learn how to create a back-end
database, web services, a security model, UI, and more using all the
best practices and standards for Liferay DXP. Completing this Learning
Path will prepare you to write your own application and further explore
Liferay's APIs.

To develop a web application with Liferay, start at the beginning:
setting up a Liferay development environment. Though you can use
anything from a text editor and the command line, to your Java IDE of
choice, Liferay provides Liferay @ide@ to optimize development on
Liferay's platform. It integrates Liferay's BLADE tools for modular
development.

Once your development environment is set up, you'll begin creating the
application. From modeling data to Service Builder, you'll learn
everything you need to know to create and run your application.

From there you'll see everything from UI standards to providing remote
services. Once everything is completed and wrapped up with a bow, you
can distribute the application on Marketplace.

Let's Go!{}

\section{Development Setup Overview}\label{development-setup-overview}

\begin{verbatim}
<p>Development Setup Overview<br>Step 1 of 1</p>
\end{verbatim}

Liferay's development tools aim to help you get started fast. The basic
steps for installing Liferay @ide@ are

\begin{itemize}
\item
  Download a Liferay @ide@ bundle.
\item
  Unzip the downloaded package to a location on your system.
\item
  Start @ide@.
\end{itemize}

You'll follow these steps, and then generate an environment for
developing your first Liferay DXP application.

\subsection{Installing a Liferay @ide@
Bundle}\label{installing-a-liferay-ide-bundle}

To install Liferay @ide@, follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Download and install
  \href{http://www.oracle.com/technetwork/java/javase/downloads/index.html}{the
  Java Development Kit (JDK)}. Liferay DXP runs on Java. The JDK is
  required because you'll be developing Liferay DXP apps in Liferay
  @ide@. The JDK is an enhanced version of the Java Environment used for
  developing new Java technology.
\item
  Download
  \href{https://www.liferay.com/downloads/liferay-projects/liferay-ide}{Liferay
  @ide@}. Installing it is easy: unzip it to a convenient location on
  your system.
\item
  To run Liferay @ide@, execute the \texttt{eclipse} executable.
\end{enumerate}

The first time you start Liferay @ide@, it prompts you to select an
Eclipse workspace. If you specify a folder where no workspace currently
exists, Liferay @ide@ creates a new workspace in that folder. Follow
these steps to create a new workspace:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  When prompted, indicate your workspace's path. Name your new workspace
  \texttt{guestbook-workspace} and click \emph{OK}.
\item
  When Liferay @ide@ first launches, it presents a welcome page. Click
  the \emph{Workbench} icon to continue.
\end{enumerate}

Nice job! Your development environment is installed and your workspace
is set up.

\subsection{Creating a Liferay
Workspace}\label{creating-a-liferay-workspace}

Now you'll create another kind of workspace--a
\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-workspace}{Liferay
Workspace}. By holding and managing your Liferay DXP projects, a Liferay
Workspace provides a simplified, straightforward way to develop Liferay
DXP applications. In the background, a Liferay Workspace uses
\href{/docs/7-0/tutorials/-/knowledge_base/t/blade-cli}{Blade CLI} and
\href{https://gradle.org/}{Gradle} to manage dependencies and organize
your build environment. Note that to avoid configuration issues, you can
only create one Liferay Workspace for each Eclipse Workspace.

Follow these steps to create a Liferay Workspace in Liferay @ide@:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Select \emph{File} → \emph{New} → \emph{Liferay Workspace Project}.
  Note: you may have to select \emph{File} → \emph{New} → \emph{Other},
  then choose \emph{Liferay Workspace Project} in the \emph{Liferay}
  category.

  \begin{figure}
  \centering
  \includegraphics{./images/selecting-liferay-workspace.png}
  \caption{By selecting \emph{Liferay Workspace}, you begin the process
  of creating a new workspace for your Liferay DXP projects.}
  \end{figure}

  A \emph{New Liferay Workspace} dialog appears, which presents several
  configuration options.
\item
  Give your workspace the name \texttt{com-liferay-docs-guestbook}.
\item
  Next, choose your workspace's location. Leave the default setting
  checked. This places your Liferay Workspace inside your Eclipse
  workspace.
\item
  Check the \emph{Download Liferay bundle} checkbox to automatically
  download and unzip a Liferay DXP instance in your workspace. When
  prompted, name the server \texttt{liferay-tomcat-bundle}.
\item
  Click \emph{Finish} to create your Liferay Workspace. This may take a
  while because Liferay Liferay DXP downloads the Liferay DXP bundle in
  the background.

  \begin{figure}
  \centering
  \includegraphics{./images/guestbook-workspace-menu.png}
  \caption{Liferay @ide@ provides an easy-to-follow menu to create your
  Liferay Workspace.}
  \end{figure}
\end{enumerate}

A dialog appears prompting you to open the Liferay Workspace
perspective. Click \emph{Yes}, and your perspective switches to Liferay
Workspace.

Congratulations! Your development environment is ready! Next, you'll get
started developing your first Liferay DXP application.

\chapter{Creating a Working
Prototype}\label{creating-a-working-prototype}

So far, you've installed and set up Liferay @ide@, and created a Liferay
Workspace. Next, you'll create your application and start adding basic
features to it. Here's what you'll do:

\begin{itemize}
\tightlist
\item
  Create your application and deploy it to your Liferay DXP instance.
\item
  Create a functional button for adding and removing guestbook entries.
\item
  Create a form for users to create and edit guestbook entries.
\item
  Create a UI for displaying guestbook entries.
\item
  Implement a prototype storage system (to be replaced later) for
  storing guestbook entries.
\end{itemize}

At the end, you'll have a fully functional prototype application ready
to be enhanced later! There's no time like now to get started.

Let's Go!{}

\section{Writing Your First Liferay DXP
Application}\label{writing-your-first-liferay-dxp-application}

\begin{verbatim}
<p>Developing Your First Portlet<br>Step 1 of 8</p>
\end{verbatim}

It's easy to get started developing your first Liferay DXP application.
Here, you'll learn step-by-step how to create your project and deploy
your application to Liferay DXP. Before you know it, you'll have your
application deployed alongside those that come with Liferay DXP.

Your first application is simple: you'll build a guestbook application
that looks like this:

\begin{figure}
\centering
\includegraphics{./images/first-guestbook-portlet.png}
\caption{You'll create this simple application.}
\end{figure}

By default, it shows guestbook messages that various users leave on your
website. To add a message, you click the \emph{Add Entry} button to show
a form that lets you enter and save a message.

Ready to write your first Liferay DXP application?

\subsection{Creating Your First Liferay DXP
Application}\label{creating-your-first-liferay-dxp-application}

Your first step is to create a \emph{Liferay Module Project}. Modules
are the core building blocks of Liferay DXP applications. Every
application is made from one or more modules. Each module encapsulates a
functional piece of an application, and then multiple modules form a
complete application. There's good reason for this: modules let you swap
out code implementations more or less at will. This makes your
applications easy to maintain and upgrade.

These modules are \href{https://www.osgi.org/}{OSGi} modules. The OSGi
container in Liferay DXP can run any OSGi module. Each module is
packaged as a JAR file that contains a manifest file. The manifest is
needed for the container to recognize the module. Technically, a module
that contains only a manifest is still valid. Of course, such a module
wouldn't be very interesting.

Now you'll create your first module. For the purpose of this Learning
Path, you'll create your modules inside your Liferay Workspace. Follow
these instructions to create your first Liferay Module Project:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In the Project Explorer in Liferay @ide@, right click on your Liferay
  Workspace and select \emph{New} → \emph{Liferay Module Project}.
\item
  Complete the first screen of the wizard with the following
  information:

  \begin{itemize}
  \tightlist
  \item
    Enter \texttt{guestbook-web} for the Project name.
  \item
    Use the \emph{Gradle} Build type.
  \item
    Select \texttt{mvc-portlet} for the Project Template.
  \end{itemize}

  Click \emph{Next}.
\item
  On the second screen of the wizard, enter \texttt{Guestbook} for the
  component class name, and \texttt{com.liferay.docs.guestbook.portlet}
  for the package name. Click \emph{Finish}.
\end{enumerate}

Note that it may take a while for @ide@ to create your project, because
Gradle downloads your project's dependencies for you during project
creation. Once this is done, you have a module project named
\texttt{guestbook-web}. The \texttt{mvc-portlet} template configured the
project with the proper dependencies and generated all the files you
need to get started:

\begin{itemize}
\tightlist
\item
  The portlet class (in the package you specified)
\item
  JSP files (in \texttt{/src/main/resources})
\item
  Language properties (also in \texttt{/src/main/resources})
\end{itemize}

\begin{figure}
\centering
\includegraphics{./images/guestbook-web-project.png}
\caption{Your new module project appears in your Liferay Workspace's
\texttt{modules} folder.}
\end{figure}

Your new module project is a \emph{portlet} application. Next, you'll
learn exactly what a portlet is.

\subsection{What is a Portlet?}\label{what-is-a-portlet}

When you access a web site, you interact with an application. That
application could be simple: it might only show you one piece of
information, such as an article. The application might be complex: you
could be doing your taxes, entering lots of data into an application
that calculates whether you owe or are due a refund. These applications
run on a \emph{platform} that provides application developers the
building blocks they need to make applications.

\begin{figure}
\centering
\includegraphics{./images/portlet-applications.png}
\caption{Many Liferay applications can run at the same time on the same
page.}
\end{figure}

Liferay DXP provides a platform that contains common features needed by
today's applications, including user management, security, user
interfaces, services, and more. Portlets are one of those basic building
blocks. Often a web application takes up the entire page. If you want,
you can do this with applications in Liferay DXP as well. Portlets,
however, allow Liferay DXP to serve many applications on the same page at
the same time. Liferay DXP's framework takes this into account at every
step. For example, features like platform-generated URLs exist to
support Liferay's ability to serve multiple applications on the same
page.

\subsection{What is a Component?}\label{what-is-a-component}

Portlets created in Liferay Module Projects are generated as
\emph{Components}. If the module (sometimes also called a \emph{bundle})
encapsulates pieces of your application, the component is the object
that contains the core functionality. A Component is an object that is
managed by a component framework or container. Components are deployed
inside modules, and they're created, started, stopped, and destroyed as
needed by the container. What a perfect model for a web application! It
can be made available only when needed, and when it's not, the container
can make sure it doesn't use any resources needed by other components.

In this case, you created a Declarative Services (DS) component. With
Declarative Services, you declare that an object is a component, and you
define some data about the component so the container knows how to
manage it. A default configuration was created for you; you'll examine
it later.

\subsection{Deploying the Application}\label{deploying-the-application}

Even though all you've done is generate it, the \texttt{guestbook-web}
project is ready to be built and deployed to Liferay DXP. Make sure that
your server is running, and if it isn't, select it in @ide@'s Servers
pane and click the start button. After it starts, drag and drop the
\texttt{guestbook-web} project from the Project Explorer to the server.
If this is your first time starting Liferay DXP, you'll go through a
short wizard to set up your server. In this wizard, make sure you use
the default database (Hypersonic). Although this database isn't intended
for production use, it works fine for development and testing.

Next, check that your application is available in Liferay DXP. Open a
browser, navigate to your portal (\url{http://localhost:8080} by
default), and add your application to a page. To add an application to a
page, click the \emph{Add} button in the upper right hand corner (it
looks like a plus sign), and then select \emph{Applications}. In the
Applications list, your application should appear in the Sample
category. Its name should be \texttt{guestbook-web-module\ Portlet}.

\begin{figure}
\centering
\includegraphics{./images/default-portlet-application.png}
\caption{This is the default Liferay homepage. It contains several
portlets, including the initial version of the Guestbook application
that you created.}
\end{figure}

Now you're ready to jump in and start developing your Guestbook portlet.

\section{Creating an Add Entry
Button}\label{creating-an-add-entry-button}

\begin{verbatim}
<p>Developing Your First Portlet<br>Step 2 of 8</p>
\end{verbatim}

A guestbook application is pretty simple, right? People come to your
site and post their names and brief messages. Other users can read these
entries and post their own.

When you created your project, it generated a file named
\texttt{view.jsp} in your project's
\texttt{src/main/resources/META-INF/resources} folder. This file creates
the default view for users when the portlet is added to the page. Right
now it only contains some sample content:

\begin{verbatim}
<%@ include file="/init.jsp" %>

<p>
    <b><liferay-ui:message key="guestbook-web.caption"/></b>
</p>
\end{verbatim}

First, \texttt{view.jsp} imports \texttt{init.jsp}. By convention,
imports and tag library declarations in Liferay DXP portlet applications
should be in an \texttt{init.jsp} file. The other JSP files in the
application import \texttt{init.jsp}. This lets you handle JSP
dependency management in a single file.

Besides importing \texttt{init.jsp}, \texttt{view.jsp} displays a
message defined by a language key. This key and its value are declared
in your project's
\texttt{src/main/resources/content/Language.properties} file.

It's time to start developing the Guestbook application. First, users
need a way to add a guestbook entry. In \texttt{view.jsp}, follow these
steps to add this button:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Remove everything under the include for \texttt{init.jsp}.
\item
  Below the include, add the following
  \href{http://alloyui.com/}{AlloyUI} tags to display an Add Entry
  button inside of a button row:

\begin{verbatim}
<aui:button-row>
    <aui:button value="Add Entry"></aui:button>
</aui:button-row>
\end{verbatim}
\end{enumerate}

You can use \texttt{aui} tags in \texttt{view.jsp} since
\texttt{init.jsp} declares the AlloyUI tag library by default (as well
as other important imports and tags):

\begin{verbatim}
    <%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %>
    <%@ taglib uri="http://java.sun.com/portlet_2_0" prefix="portlet" %>

    <%@ taglib uri="http://liferay.com/tld/aui" prefix="aui" %>
    <%@ taglib uri="http://liferay.com/tld/portlet" prefix="liferay-portlet" %>
    <%@ taglib uri="http://liferay.com/tld/theme" prefix="liferay-theme" %>
    <%@ taglib uri="http://liferay.com/tld/ui" prefix="liferay-ui" %>

    <portlet:defineObjects />

    <liferay-theme:defineObjects />
\end{verbatim}

Your application now displays a button instead of a message, but the
button doesn't do anything. Next, you'll create a URL for your button.

\begin{figure}
\centering
\includegraphics{./images/guestbook-new-button.png}
\caption{Your new button is awesome, but it doesn't work yet.}
\end{figure}

\section{Generating Portlet URLs}\label{generating-portlet-urls}

\begin{verbatim}
<p>Developing Your First Portlet<br>Step 3 of 8</p>
\end{verbatim}

Recall that users can place multiple portlets on a single page. As a
developer, you have no idea what other portlets will share a page with
yours. This means that you can't define URLs for various functions in
your application like you may be used to.

For example, consider a Calendar application that a user puts on the
same page as a Blog application. To implement the functionality for
deleting calendar events and blog entries in the respective application,
both application developers append the \texttt{del} parameter to the
URL, and give it a primary key value so the application can look up and
delete the calendar event or blog entry. Since both applications read
this parameter, their delete functionality clashes.

System-generated URLs are Liferay DXP's solution to this. By generating
a unique URL parameter for each piece of functionality, Liferay DXP lets
multiple applications with the same or similar functionality coexist in
perfect harmony. Unfortunately, for this to work in your portlet you
must manually add support for it. Fortunately, doing so is very
straightforward.

In \texttt{view.jsp}, follow these steps to enable system-generated URLs
in your portlet:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add these tags below
  \texttt{\textless{}\%@\ include\ file="/init.jsp"\ \%\textgreater{}},
  but above the \texttt{\textless{}aui:button-row\textgreater{}} tag:

\begin{verbatim}
<portlet:renderURL var="addEntryURL">
    <portlet:param name="mvcPath" value="/edit_entry.jsp"></portlet:param>
</portlet:renderURL>
\end{verbatim}
\item
  Add this attribute to the \texttt{\textless{}aui:button\textgreater{}}
  tag, before \texttt{value="Add\ Entry"}:

\begin{verbatim}
onClick="<%= addEntryURL.toString() %>"
\end{verbatim}

  Your \texttt{view.jsp} page should now look like this:

\begin{verbatim}
<%@ include file="/init.jsp" %>

<portlet:renderURL var="addEntryURL">
    <portlet:param name="mvcPath" value="/edit_entry.jsp"></portlet:param>
</portlet:renderURL>

<aui:button-row>
    <aui:button onClick="<%= addEntryURL.toString() %>" value="Add Entry"></aui:button>
</aui:button-row>
\end{verbatim}
\end{enumerate}

The \texttt{\textless{}portlet:renderURL\textgreater{}} tag's
\texttt{var} attribute creates the \texttt{addEntryURL} variable to hold
the system-generated URL. The
\texttt{\textless{}portlet:param\textgreater{}} tag defines a URL
parameter to append to the URL. In this example, a URL parameter named
\texttt{mvcPath} with a value of \texttt{/edit\_entry} is appended to
the URL.

Note that your \texttt{GuestbookPortlet} class (located in your
\texttt{guestbook-web} module's
\texttt{com.liferay.docs.guestbook.portlet} package) extends Liferay's
\texttt{MVCPortlet} class. In a
\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-mvc-portlet}{Liferay
MVC portlet}, the \texttt{mvcPath} URL parameter indicates a page within
your portlet. To navigate to another page in your portlet, use a portal
URL with the parameter \texttt{mvcPath} to link to the specific page.

In the example above, you created a \texttt{renderURL} that points to
your application's \texttt{edit\_entry.jsp} page, which you haven't yet
created. Note that using an AlloyUI button to follow the generated URL
isn't required. You can use any HTML construct that contains a link.
Users can click your button to access your application's
\texttt{edit\_entry.jsp} page. This currently produces an error since no
\texttt{edit\_entry.jsp} exists yet. Creating \texttt{edit\_entry.jsp}
is your next step.

\section{Linking to Another Page}\label{linking-to-another-page}

\begin{verbatim}
<p>Developing Your First Portlet<br>Step 4 of 8</p>
\end{verbatim}

In the same folder your \texttt{view.jsp} is in, create the
\texttt{edit\_entry.jsp} file:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Right-click your project's
  \texttt{src/main/resources/META-INF/resources} folder and choose
  \emph{New} → \emph{File}.
\item
  Name the file \texttt{edit\_entry.jsp} and click \emph{Finish}.
\item
  Add this line to the top of the file:

\begin{verbatim}
<%@ include file="init.jsp" %>
\end{verbatim}

  Remember, it's a best practice to add all JSP imports and tag library
  declarations to a single file that's imported by your application's
  other JSP files. For \texttt{edit\_entry.jsp}, you need these imports
  to access the portlet tags that create URLs and the Alloy tags that
  create the form.
\item
  You'll create two URLs: one to submit the form and one to go back to
  the \texttt{view.jsp}. To create the URL to go back to
  \texttt{view.jsp}, add the following tag below the first line you
  added:

\begin{verbatim}
<portlet:renderURL var="viewURL">
    <portlet:param name="mvcPath" value="/view.jsp"></portlet:param>
</portlet:renderURL>
\end{verbatim}
\end{enumerate}

Next, you must create a new URL for submitting the form. Before you do,
some explanation is in order.

\section{Triggering Portlet Actions}\label{triggering-portlet-actions}

\begin{verbatim}
<p>Developing Your First Portlet<br>Step 5 of 8</p>
\end{verbatim}

Recall that portlets run in a portion of a page, and a page can contain
multiple portlets. Because of this, portlets have \emph{phases} of
operation. Here, you'll learn about the most important two. The first
phase is the one you've already used: the \emph{render} phase. All this
means is that the portlet draws itself, using the JSPs you write for it.

The other phase is called the \emph{action} phase. This phase runs once,
when a user triggers a portlet action. The portlet performs whatever
action the user triggered, such as performing a search or adding a
record to a database. Then, based on what happened in the action, the
portlet goes back to the render phase and re-renders itself according to
its new state.

To save a guestbook entry, you must trigger a portlet action. For this,
you'll create an action URL.

Add the following tag in \texttt{edit\_entry.jsp} after the closing
\texttt{\textless{}/portlet:renderURL\textgreater{}} tag:

\begin{verbatim}
<portlet:actionURL name="addEntry" var="addEntryURL"></portlet:actionURL>
\end{verbatim}

You now have the two required URLs for your form.

\section{Creating a Form}\label{creating-a-form}

\begin{verbatim}
<p>Developing Your First Portlet<br>Step 6 of 8</p>
\end{verbatim}

The form for creating guestbook entries is pretty simple. All you need
are two fields: one for the name of the person submitting the entry, and
one for the entry itself.

Add the following tags to the end of your \texttt{edit\_entry.jsp} file:

\begin{verbatim}
<aui:form action="<%= addEntryURL %>" name="<portlet:namespace />fm">
        <aui:fieldset>
            <aui:input name="name"></aui:input>
            <aui:input name="message"></aui:input>
        </aui:fieldset>

        <aui:button-row>
            <aui:button type="submit"></aui:button>
            <aui:button type="cancel" onClick="<%= viewURL.toString() %>"></aui:button>
        </aui:button-row>
</aui:form>
\end{verbatim}

Save \texttt{edit\_entry.jsp} and redeploy your application. If you
refresh the page and click the \emph{Add Entry} button, your form
appears. If you click the \emph{Cancel} button, it works! However, don't
try the \emph{Save} button yet. You haven't yet created the action that
saves a guestbook entry, so clicking \emph{Save} produces an error.

\begin{figure}
\centering
\includegraphics{./images/first-guestbook-portlet-edit-entry.png}
\caption{This is the Guestbook application's form for adding entries.}
\end{figure}

Implementing the portlet action (what happens when the user clicks
\emph{Save}) is your next task.

\section{Implementing Portlet
Actions}\label{implementing-portlet-actions}

\begin{verbatim}
<p>Developing Your First Portlet<br>Step 7 of 8</p>
\end{verbatim}

When users submit the form, your application stores the form data for
display in the guestbook. To keep this first application simple, you'll
implement this using a part of the Portlet API called Portlet
Preferences. Normally, of course, you'd use a database. Liferay DXP's
Service Builder tool eliminates a great deal of complexity when working
with databases. For now, however, you can create the first iteration of
your guestbook application using portlet preferences.

To make your portlet do anything other than re-render itself, you must
implement portlet actions. An action defines some processing, usually
based on user input, that the portlet must perform before it renders
itself. In the case of the guestbook portlet, the action you'll
implement next saves a guestbook entry that a user typed into the form.
Saved guestbook entries can be retrieved and displayed later.

Since you're using Liferay's MVC Portlet framework, you have an easy way
to implement actions. Portlet actions are implemented in the portlet
class, which acts as the controller. In the form you just created, you
made an action URL, and you called it \texttt{addEntry}. To create a
portlet action, you create a method in the portlet class with the same
name. \texttt{MVCPortlet} calls that method when a user triggers its
matching URL.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open \texttt{GuestbookPortlet}. The project template generated this
  class when you created the portlet project.
\item
  Create a method with the following signature:

\begin{verbatim}
public void addEntry(ActionRequest request, ActionResponse response) {

}
\end{verbatim}
\item
  Press {[}CTRL{]}+{[}SHIFT{]}+O to organize imports and import the
  required \texttt{javax.portlet.ActionRequest} and
  \texttt{javax.portlet.ActionResponse} classes.
\end{enumerate}

You've now created a portlet action. It doesn't do anything, but at
least you won't get an error now if you submit your form. Next, you
should make the action save the form data.

Because of the limitations of the portlet preferences API, you must
store each guestbook entry as a \texttt{String} in a string array. Since
your form has two fields, you must use a delimiter to determine where
the user name ends and the guestbook entry begins. The caret symbol
(\texttt{\^{}}) makes a good delimiter because users are highly unlikely
to use that symbol in a guestbook entry.

\noindent\hrulefill

\textbf{Note:} The portlet preferences API is used here for prototyping
purposes only. In most cases, you'll need a more robust solution for
storing data. You'll learn how to implement such a solution later in the
\emph{Service Builder} section.

\noindent\hrulefill

The following method implements adding a guestbook entry to a portlet
preference called \texttt{guestbook-entries}:

\begin{verbatim}
public void addEntry(ActionRequest request, ActionResponse response) {
    try {
        PortletPreferences prefs = request.getPreferences();

        String[] guestbookEntries = prefs.getValues("guestbook-entries",
                new String[1]);

        ArrayList<String> entries = new ArrayList<String>();

        if (guestbookEntries[0] != null) {
            entries = new ArrayList<String>(Arrays.asList(prefs.getValues(
                    "guestbook-entries", new String[1])));
        }

        String userName = ParamUtil.getString(request, "name");
        String message = ParamUtil.getString(request, "message");
        String entry = userName + "^" + message;

        entries.add(entry);

        String[] array = entries.toArray(new String[entries.size()]);

        prefs.setValues("guestbook-entries", array);

        try {
            prefs.store();
        }
        catch (IOException ex) {
            Logger.getLogger(GuestbookPortlet.class.getName()).log(
                    Level.SEVERE, null, ex);
        }
        catch (ValidatorException ex) {
            Logger.getLogger(GuestbookPortlet.class.getName()).log(
                    Level.SEVERE, null, ex);
        }

    }
    catch (ReadOnlyException ex) {
        Logger.getLogger(GuestbookPortlet.class.getName()).log(
                Level.SEVERE, null, ex);
    }
}
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Replace your existing \texttt{addEntry} method with the above method.
\item
  Press {[}CTRL{]}+{[}SHIFT{]}+O to organize imports and select the
  \texttt{javax.portlet.PortletPreferences} and
  \texttt{java.util.logging.Logger} when prompted (not their Liferay
  equivalents).
\end{enumerate}

First, the preferences are retrieved. Then the
\texttt{guestbook-entries} preference is retrieved and converted to an
\texttt{ArrayList} so that you can add an entry without worrying about
exceeding the size of the array. Next, the name and message fields from
your form are retrieved. Note that Liferay's \texttt{ParamUtil} class
makes it very easy to retrieve URL parameters.

Finally, the fields are combined into a \texttt{String} delimited by a
caret, and the new entry is added to the \texttt{ArrayList}, which is
then converted back to an array so it can be stored as a preference. The
try/catch blocks are required by the portlet preferences API.

This isn't the normal way to use portlet preferences, but it provides a
quick and easy way for you to store guestbook entries in this first
version of your application. In a later step, you'll implement a robust
way to store guestbook entries in a database.

The next and final feature to implement is a mechanism for viewing
guestbook entries.

\section{Displaying Guestbook
Entries}\label{displaying-guestbook-entries}

\begin{verbatim}
<p>Developing Your First Portlet<br>Step 8 of 8</p>
\end{verbatim}

To display guestbook entries, you must do the reverse of what you did to
store them: retrieve them from portlet preferences, loop through them,
and present them on the page. The best way to do this with MVC Portlet
is to use the
\href{https://en.wikipedia.org/wiki/Model\%E2\%80\%93view\%E2\%80\%93controller}{Model-View-Controller}
paradigm. You already have the view (your JSP files) and your controller
(your portlet class). Now you need your model.

\subsection{Creating Your Model}\label{creating-your-model}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a new package called \texttt{com.liferay.docs.guestbook.model}.
  To do this, right-click your \texttt{src/main/java} folder and select
  \emph{New} → \emph{Package}. Then enter the package name in the dialog
  box that appears.
\item
  Next, create your model class. This is a simple class that models a
  guestbook entry. To do this, right-click your new package and select
  \emph{New} → \emph{Class}. Name the class \texttt{Entry}, and click
  \emph{Finish}.

  You now have a Java class for your guestbook entries. Next, you'll
  give it the fields you need to store entries.
\item
  Create two private String variables: \texttt{name} and
  \texttt{message}.

\begin{verbatim}
private String name;
private String message;
\end{verbatim}
\item
  Right-click a blank area of the editor and select \emph{Source} →
  \emph{Generate Getters and Setters}. Click \emph{Select All} in the
  dialog that pops up, and then click \emph{OK}.
\item
  Next, provide two constructors: one that initializes the class with no
  values for the two fields, and one that takes the two fields as
  parameters and sets their values:

\begin{verbatim}
public Entry() {
   this.name = null;
   this.message = null;
}

public Entry(String name, String message) {
   setName(name);
   setMessage(message);
}
\end{verbatim}
\end{enumerate}

Your completed model class looks like this:

\begin{verbatim}
package com.liferay.docs.guestbook.model;

public class Entry {

    private String name;
    private String message;

    public Entry() {
        this.name = null;
        this.message = null;
    }

    public Entry(String name, String message) {
        setName(name);
        setMessage(message);
    }

    public String getName() {
        return name;
    }

    public String getMessage() {
        return message;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void setMessage(String message) {
        this.message = message;
    }

}
\end{verbatim}

Now that you have your model, you have an easy way of encapsulating
guestbook entries so they can be processed by the controller layer and
displayed by the view layer. Your next step is to enhance the controller
(your portlet class) so that guestbook entries are processed and ready
to display when users see the guestbook application.

\subsection{Customizing How Your Application is
Rendered}\label{customizing-how-your-application-is-rendered}

As mentioned earlier, your application is using two portlet phases:
render and action. To make the guestbook show the saved guestbook
entries when users view the application, you need to customize your
portlet's render functionality, which it's currently inheriting from its
parent class, \texttt{MVCPortlet}.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open \texttt{GuestbookPortlet} and add the following method below your
  \texttt{addEntry} method:

\begin{verbatim}
@Override
public void render(RenderRequest renderRequest, RenderResponse renderResponse)
    throws PortletException, IOException {

    PortletPreferences prefs = renderRequest.getPreferences();
    String[] guestbookEntries = prefs.getValues("guestbook-entries", new String[1]);

    if (guestbookEntries[0] != null) {
        List<Entry> entries = parseEntries(guestbookEntries);
        renderRequest.setAttribute("entries", entries);
    }

    super.render(renderRequest, renderResponse);
}
\end{verbatim}

  This method retrieves the guestbook entries from the configuration,
  converts it to a \texttt{List} of \texttt{Entry} objects, and places
  that \texttt{List} into the request object. It then calls the parent
  class's \texttt{render} method.
\item
  Beneath the \texttt{render} method, add the following method that
  converts the array to a \texttt{List} of your model objects:

\begin{verbatim}
private List<Entry> parseEntries(String[] guestbookEntries) {
    List<Entry> entries = new ArrayList<Entry>();

    for (String entry : guestbookEntries) {
        String[] parts = entry.split("\\^", 2);
        Entry gbEntry = new Entry(parts[0], parts[1]);
        entries.add(gbEntry);
    }

    return entries;
}
\end{verbatim}
\item
  Press {[}CTRL{]}+{[}SHIFT{]}+O to organize imports.
\end{enumerate}

\noindent\hrulefill

Note: When you are prompted to choose imports, here are some guidelines:

\begin{itemize}
\item
  Always use \texttt{org.osgi...} packages instead of
  \texttt{aQute.bnd...}
\item
  Generally use \texttt{java.util...} or \texttt{javax.portlet...}
  packages.
\item
  You never use \texttt{java.awt...} in this project.
\item
  Only use \texttt{com.liferay...} when it is for a Liferay specific
  implementation or your custom implementation of a concept.
\end{itemize}

For example:

\begin{itemize}
\item
  If you are given the choice between \texttt{javax.portlet.Portlet} and
  \texttt{com.liferay.portlet.Portlet} choose
  \texttt{javax.portlet.Portlet}.
\item
  If you are given the choice between \texttt{org.osgi.component} and
  \texttt{aQute.bnd.annotation.component} choose
  \texttt{org.osgi.component}
\item
  However, if you are given the choice between
  \texttt{java.util.Map.Entry} and
  \texttt{com.liferay.docs.guestbook.model.Entry} (the custom class you
  created) choose \texttt{com.liferay.docs.guestbook.model.Entry}
\end{itemize}

If at some point you think you chose an incorrect import, but you're not
sure what it might be, you can erase all of the imports from the file
and press {[}CTRL{]}+{[}SHIFT{]}+O again and see if you can identify
where you went wrong.

\noindent\hrulefill

As you can see, this method splits the entries in the \texttt{String}
array into two parts based on the caret (\texttt{\^{}}) character.

Now that you have your controller preparing your data for display, your
next step is to implement the view so users can see guestbook entries.

\subsection{Displaying Guestbook
Entries}\label{displaying-guestbook-entries-1}

Liferay's development framework makes it easy to loop through data and
display it nicely to the end user. You'll use a Liferay UI construct
called \emph{Search Container} to make this happen.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add these tags to your \texttt{view.jsp} in between the
  \texttt{\textless{}/portlet:renderURL\textgreater{}} and
  \texttt{\textless{}aui:button-row\textgreater{}} tags:

\begin{verbatim}
<jsp:useBean id="entries" class="java.util.ArrayList" scope="request"/>

<liferay-ui:search-container>
    <liferay-ui:search-container-results results="<%= entries %>" />

    <liferay-ui:search-container-row
        className="com.liferay.docs.guestbook.model.Entry"
        modelVar="entry"
    >
        <liferay-ui:search-container-column-text property="message" />

        <liferay-ui:search-container-column-text property="name" />
    </liferay-ui:search-container-row>

    <liferay-ui:search-iterator />
</liferay-ui:search-container>
\end{verbatim}
\end{enumerate}

Save your work, deploy your application, and try adding some guestbook
entries.

Awesome! You've finished your working prototype! You have a working
application that adds and saves guestbook entries.

The way you're saving the entries isn't the best way to persist data in
your application. Next, you'll use Service Builder to generate your
persistence classes and the methods you need to store your application
data in the database.

\chapter{Generating the Back-end}\label{generating-the-back-end}

So far, you have a prototype application that uses Liferay's
Model-View-Controller (MVC) portlet framework. MVC is a great design
pattern for web applications because it splits your application into
three parts (the model, the view, and the controller). This lets you
swap out those parts if necessary.

A \emph{persistence} layer and a \emph{service} layer are added to these
three parts of your application. To get the prototype working, you used
Portlet Properties to create a rudimentary persistence layer. Since this
isn't a long-term solution, you'll now replace that layer by persisting
your guestbooks and their entries to a database.

\begin{figure}
\centering
\includegraphics{./images/application-layers.png}
\caption{Service Builder generates the shaded layers of your
application.}
\end{figure}

\emph{Service Builder} is Liferay's code generation tool for defining
object models and mapping those models to SQL databases. By defining
your model in a single XML file, you can generate your object model (the
M in MVC), your service layer, and your persistence layer all in one
shot. At the same time, you can generate web services (more on that
later) and support every database Liferay DXP supports.

Ready to begin?

Let's Go!{}

\section{What is Service Builder?}\label{what-is-service-builder}

\begin{verbatim}
<p>Generating the Back-end<br>Step 1 of 3</p>
\end{verbatim}

Now you'll use Service Builder to generate create, read, update, delete,
and find operations for your application. You'll also use Service
Builder to generate the necessary model, persistence, and service layers
for your application. Then you can add your application's necessary
business logic.

\subsection{Guestbook Application
Design}\label{guestbook-application-design}

In the prototype application, you defined a single guestbook's entries
and displayed them in a list. The full application will handle multiple
Guestbooks and their entries. To make this work, you'll create two
tables in the database: one for guestbooks, and one for guestbook
entries.

\subsection{Service Layer}\label{service-layer}

This application is data-driven. It uses services for storing and
retrieving data. The application asks for data, and the service fetches
it. The application can then display this data to the user, who reads or
modifies it. If the data is modified, the application passes it back to
the service, and the service stores it. The application doesn't need to
know anything about how the service does what it does.

To get started, you'll create a Service Builder project and populate its
\texttt{service.xml} file with all the necessary entities to generate
this code:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In Liferay @ide@, click \emph{File} → \emph{New} → \emph{Liferay
  Module Project}.
\item
  Name the project \texttt{guestbook}.
\item
  Select \texttt{service-builder} for the Project Template Name.
\item
  Click \emph{Next}.
\item
  Enter \texttt{com.liferay.docs.guestbook} for the \emph{Package Name}.
\item
  Click \emph{Finish}.
\end{enumerate}

This creates two modules: an API module (\texttt{guestbook-api}) and a
service module (\texttt{guestbook-service}). Next, you'll learn how to
use them.

\begin{figure}
\centering
\includegraphics{./images/guestbook-service-project.png}
\caption{Your current project structure.}
\end{figure}

\section{Generating Model, Service, and Persistence
Layers}\label{generating-model-service-and-persistence-layers}

\begin{verbatim}
<p>Generating the Back-end<br>Step 2 of 3</p>
\end{verbatim}

The persistence layer saves and retrieves your model data. The service
layer is a buffer between your application and persistence layers:
having it lets you swap out your persistence layer for a different
implementation without modifying anything but the calls in the service
layer.

To model the guestbooks and entries, you'll create guestbook and entry
model classes. But you won't do this directly in Java. Instead, you'll
define them in Service Builder, which generates your object model and
maps it to all the SQL databases Liferay DXP supports.

This application's design lets you create multiple guestbooks, each
containing different sets of entries. All users with permission to
access the application can add entries, but only administrative users
can add guestbooks.

It's time to get started. You'll create the \texttt{Guestbook} entity
first:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In your \texttt{guestbook-service} project, open \texttt{service.xml}.
\item
  When Liferay @ide@ generated your project, it filled this file with
  dummy entities, which you'll replace. First replace the file's opening
  contents (below the \texttt{DOCTYPE}) with the following code:

\begin{verbatim}
<service-builder auto-namespace-tables="true" package-path="com.liferay.docs.guestbook">
    <author>liferay</author>
    <namespace>GB</namespace>
    <entity name="Guestbook" local-service="true" uuid="true">
\end{verbatim}

  This defines the author, namespace, and the entity name. The namespace
  keeps the database field names from conflicting. The last tag is the
  opening tag for the \texttt{Guestbook} entity definition. In this tag,
  you enable local services for the entity, define its name, and specify
  that it should have a
  \href{https://en.wikipedia.org/wiki/Universally_unique_identifier}{universally
  unique identifier (UUID)}.
\item
  Next, replace the PK fields section:

\begin{verbatim}
<column name="guestbookId" primary="true" type="long" />
\end{verbatim}

  This defines \texttt{guestbookId} as the entity's primary key, of the
  type \texttt{long}.
\item
  The group instance can be left alone.

\begin{verbatim}
<column name="groupId" type="long" />
\end{verbatim}

  This defines the ID of the site in Liferay DXP that the entity
  instance belongs to (more on this in a moment).
\item
  Leave the Audit Fields section alone. Add status fields:

\begin{verbatim}
<!-- Status fields -->

<column name="status" type="int" />
<column name="statusByUserId" type="long" />
<column name="statusByUserName" type="String" />
<column name="statusDate" type="Date" />
\end{verbatim}

  The Audit section defines Liferay DXP metadata. The \texttt{companyId}
  is the primary key of a
  \href{/docs/7-0/user/-/knowledge_base/u/setting-up-a-liferay-instance}{portal
  instance}. The \texttt{userId} is the primary key of a user. The
  \texttt{createDate} and \texttt{modifiedDate} store the respective
  dates on which the entity instance is created and modified. The Status
  section is used later to implement workflow.
\item
  In the Other fields section, remove all the generated fields and put
  this one in their place:

\begin{verbatim}
 <column name="name" type="String" />
\end{verbatim}
\item
  Next, remove everything else from the Guestbook entity. Before the
  closing \texttt{\textless{}/entity\textgreater{}} tag, add this finder
  definition:

\begin{verbatim}
    <finder name="GroupId" return-type="Collection">
        <finder-column name="groupId" />
    </finder>
\end{verbatim}

  This defines a finder that generates a \texttt{get} method you'll use
  to retrieve Guestbook entities. The fields used by the finder define
  the scope of the data retrieved. This finder gets all Guestbooks by
  their \texttt{groupId}, which corresponds to the
  \href{/docs/7-0/user/-/knowledge_base/u/starting-site-development}{site}
  the application is on. This lets administrators put Guestbooks on
  multiple sites, and each \texttt{Guestbook} has its own data scoped to
  its site.
\end{enumerate}

The \texttt{Guestbook} entity is finished for now. Next, you'll create
the \texttt{Entry} entity:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add the opening entity tag:

\begin{verbatim}
<entity name="Entry" local-service="true" uuid="true">
\end{verbatim}

  As with the \texttt{Guestbook} entity, you enable local services,
  define the entity's name, and specify that it should have a UUID.
\item
  Add the tag to define the primary key and the \texttt{groupId}:

\begin{verbatim}
<column name="entryId" primary="true" type="long" />

<column name="groupId" type="long" />
\end{verbatim}
\item
  Add the audit fields as you did with the \texttt{Guestbook} entity:

\begin{verbatim}
<column name="companyId" type="long" />
<column name="userId" type="long" />
<column name="userName" type="String" />
<column name="createDate" type="Date" />
<column name="modifiedDate" type="Date" />
\end{verbatim}
\item
  Add status fields like you did for the guestbook:

\begin{verbatim}
 <!-- Status fields -->

 <column name="status" type="int" />
 <column name="statusByUserId" type="long" />
 <column name="statusByUserName" type="String" />
 <column name="statusDate" type="Date" />
\end{verbatim}
\item
  Add the fields that define an \texttt{Entry}:

\begin{verbatim}
<column name="name" type="String" />
<column name="email" type="String" />
<column name="message" type="String" />
<column name="guestbookId" type="long" />
\end{verbatim}

  The \texttt{name}, \texttt{email}, and \texttt{message} fields
  comprise an \texttt{Entry}. These fields define the name of the person
  creating the entry, their email address, and the Guestbook message,
  respectively. The \texttt{guestbookId} is assigned automatically by
  code you'll write, and is a \texttt{Guestbook} foreign key. This ties
  the \texttt{Entry} to a specific \texttt{Guestbook}.
\item
  Add your finder and closing entity tag:

\begin{verbatim}
    <finder name="G_G" return-type="Collection">
        <finder-column name="groupId" />
        <finder-column name="guestbookId" />
    </finder>
</entity>
\end{verbatim}

  Here, you define a finder that gets guestbook entries by
  \texttt{groupId} and \texttt{guestbookId}. As before, the
  \texttt{groupId} corresponds to the
  \href{/docs/7-0/user/-/knowledge_base/u/starting-site-development}{site}
  the application is on. The \texttt{guestbookId} defines the guestbook
  the entries come from. This finder returns a \texttt{Collection} of
  entries.
\item
  Define your exception types outside the
  \texttt{\textless{}entity\textgreater{}} tags, just before the closing
  \texttt{\textless{}/service-builder\textgreater{}} tag:

\begin{verbatim}
<exceptions>
    <exception>EntryEmail</exception>
    <exception>EntryMessage</exception>
    <exception>EntryName</exception>
    <exception>GuestbookName</exception>
</exceptions>
\end{verbatim}

  These generate exception classes you'll use later in try/catch
  statements.
\item
  Save your \texttt{service.xml} file.
\end{enumerate}

Now you're ready to run Service Builder to generate your model, service,
and persistence layers!

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In the Gradle Tasks pane on the right side of @ide@, open
  \texttt{guestbook-service} → \texttt{build}.
\item
  Run \texttt{buildService} by right-clicking it and selecting \emph{Run
  Gradle Tasks}. Make sure you're connected to the Internet, as Gradle
  downloads dependencies the first time you run it.
\item
  In the Project Explorer, right-click the \texttt{guestbook-service}
  module and select \emph{Refresh}. Repeat this step for the
  \texttt{guestbook-api} module. This ensures that the new classes and
  interfaces generated by Service Builder show up in @ide@.
\item
  In the Project Explorer, right-click the \texttt{guestbook-service}
  module and select \emph{Gradle} → \emph{Refresh Gradle Project}.
  Repeat this step for the \texttt{guestbook-api} module. This ensures
  that your modules' Gradle dependencies are up to date.
\end{enumerate}

Service Builder is based on a design philosophy called loose coupling.
It generates three layers of your application: the model, the service,
and the persistence layers. Loose coupling means you can swap out the
persistence layer with little to no change in the model and service
layers. The model is in the \texttt{-api} module, and the service and
persistence layers are in the \texttt{-service} module.

\begin{figure}
\centering
\includegraphics{./images/model-service-persistence.png}
\caption{The Model, Service, and Persistence Layer.}
\end{figure}

Each layer is implemented using Java Interfaces and implementations of
those interfaces. Rather than have one \texttt{Entry} class that
represents your model, Service Builder generates a system of classes
that include a \texttt{Guestbook} interface, a
\texttt{GuestbookBaseImpl} abstract class that Service Builder manages,
and a \texttt{GuestbookImpl} class that you can customize. This design
lets you customize your model, while Service Builder generates code
that's tedious to write. That's why Service Builder is a code generator
for code generator haters.

Next, you'll create the service implementations.

\section{Implementing Service
Methods}\label{implementing-service-methods}

\begin{verbatim}
<p>Generating the Back-end<br>Step 3 of 3</p>
\end{verbatim}

When you use Service Builder, you implement the services in the service
module. Because your application's projects are
\href{/docs/7-0/tutorials/-/knowledge_base/t/fundamentals\#components}{components},
you can reference your service layer from your web module.

You'll implement services for guestbooks and entries in the
\texttt{guestbook-service} module's \texttt{GuestbookLocalServiceImpl}
and \texttt{EntryLocalServiceImpl}, respectively.

Follow these steps to implement services for guestbooks in
\texttt{GuestbookLocalServiceImpl}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In the \texttt{com.liferay.docs.guestbook.service.impl} package, open
  \texttt{GuestbookLocalServiceImpl}. Then add this
  \texttt{addGuestbook} method:

\begin{verbatim}
public Guestbook addGuestbook(
    long userId, String name, ServiceContext serviceContext)
    throws PortalException {

    long groupId = serviceContext.getScopeGroupId();

    User user = userLocalService.getUserById(userId);

    Date now = new Date();

    validate(name);

    long guestbookId = counterLocalService.increment();

    Guestbook guestbook = guestbookPersistence.create(guestbookId);

    guestbook.setUuid(serviceContext.getUuid());
    guestbook.setUserId(userId);
    guestbook.setGroupId(groupId);
    guestbook.setCompanyId(user.getCompanyId());
    guestbook.setUserName(user.getFullName());
    guestbook.setCreateDate(serviceContext.getCreateDate(now));
    guestbook.setModifiedDate(serviceContext.getModifiedDate(now));
    guestbook.setName(name);
    guestbook.setExpandoBridgeAttributes(serviceContext);

    guestbookPersistence.update(guestbook);

    return guestbook;

}
\end{verbatim}

  This method adds a guestbook to the database. It retrieves metadata
  from the environment (such as the current user's ID, the group ID,
  etc.), along with data passed from the user. It validates this data
  and uses it to construct a \texttt{Guestbook} object. The method then
  persists this object to the database and returns the object. You only
  implement the business logic here because Service Builder already
  generated the model and all the code that maps that model to the
  database.
\item
  Add the methods for getting \texttt{Guestbook} objects:

\begin{verbatim}
public List<Guestbook> getGuestbooks(long groupId) {

    return guestbookPersistence.findByGroupId(groupId);
}

public List<Guestbook> getGuestbooks(long groupId, int start, int end, 
    OrderByComparator<Guestbook> obc) {

    return guestbookPersistence.findByGroupId(groupId, start, end, obc);
}

public List<Guestbook> getGuestbooks(long groupId, int start, int end) {

    return guestbookPersistence.findByGroupId(groupId, start, end);
}

public int getGuestbooksCount(long groupId) {

    return guestbookPersistence.countByGroupId(groupId);
}
\end{verbatim}

  These call the finders you generated with Service Builder. The first
  method retrieves a list of guestbooks from the site specified by
  \texttt{groupId}. The next two methods get paginated lists, optionally
  in a particular order. The final method gives you the total number of
  guestbooks for a given site.
\item
  Finally, add the guestbook validator method:

\begin{verbatim}
protected void validate(String name) throws PortalException {
    if (Validator.isNull(name)) {
        throw new GuestbookNameException();
    }
}
\end{verbatim}

  This method uses Liferay DXP's \texttt{Validator} to make sure the
  user entered text for the guestbook name.
\item
  Press {[}CTRL{]}+{[}SHIFT{]}+O to organize imports and select the
  following when prompted:

  \begin{itemize}
  \tightlist
  \item
    \texttt{java.util.Date}
  \item
    \texttt{com.liferay.portal.kernel.service.ServiceContext}
  \item
    \texttt{com.liferay.docs.guestbook.model.Entry}
  \item
    \texttt{com.liferay.portal.kernel.util.Validator}
  \end{itemize}
\end{enumerate}

Now you're ready to implement services for entries in
\texttt{EntryLocalServiceImpl}. Do so now by following these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In the \texttt{com.liferay.docs.guestbook.service.impl} package, open
  \texttt{EntryLocalServiceImpl}. Add this \texttt{addEntry} method:

\begin{verbatim}
public Entry addEntry(
    long userId, long guestbookId, String name, String email,
    String message, ServiceContext serviceContext)
    throws PortalException {

    long groupId = serviceContext.getScopeGroupId();

    User user = userLocalService.getUserById(userId);

    Date now = new Date();

    validate(name, email, message);

    long entryId = counterLocalService.increment();

    Entry entry = entryPersistence.create(entryId);

    entry.setUuid(serviceContext.getUuid());
    entry.setUserId(userId);
    entry.setGroupId(groupId);
    entry.setCompanyId(user.getCompanyId());
    entry.setUserName(user.getFullName());
    entry.setCreateDate(serviceContext.getCreateDate(now));
    entry.setModifiedDate(serviceContext.getModifiedDate(now));
    entry.setExpandoBridgeAttributes(serviceContext);
    entry.setGuestbookId(guestbookId);
    entry.setName(name);
    entry.setEmail(email);
    entry.setMessage(message);

    entryPersistence.update(entry);

    return entry;
}
\end{verbatim}

  Like the \texttt{addGuestbook} method, \texttt{addEntry} takes data
  from the current context along with data the user entered, validates
  it, and creates a model object. That object is then persisted to the
  database and returned.
\item
  Add this \texttt{updateEntry} method:

\begin{verbatim}
public Entry updateEntry (
    long userId, long guestbookId, long entryId, String name, String email,
    String message, ServiceContext serviceContext)
    throws PortalException, SystemException {

    Date now = new Date();

    validate(name, email, message);

    Entry entry = getEntry(entryId);

    User user = userLocalService.getUserById(userId);

    entry.setUserId(userId);
    entry.setUserName(user.getFullName());
    entry.setModifiedDate(serviceContext.getModifiedDate(now));
    entry.setName(name);
    entry.setEmail(email);
    entry.setMessage(message);
    entry.setExpandoBridgeAttributes(serviceContext);

    entryPersistence.update(entry);

    return entry;
}
\end{verbatim}

  This method first retrieves the entry and updates its data to reflect
  what the user submitted, including its date modified.
\item
  Add this \texttt{deleteEntry} method:

\begin{verbatim}
public Entry deleteEntry (long entryId, ServiceContext serviceContext)
    throws PortalException {

    Entry entry = getEntry(entryId);

    entry = deleteEntry(entryId);

    return entry;
}
\end{verbatim}

  This method retrieves the \texttt{entry} object defined by
  \texttt{entryId}, deletes it from the database, and then returns the
  deleted object.
\item
  Add the methods for getting \texttt{Entry} objects:

\begin{verbatim}
public List<Entry> getEntries(long groupId, long guestbookId) {
    return entryPersistence.findByG_G(groupId, guestbookId);
}

public List<Entry> getEntries(long groupId, long guestbookId, int start, int end)
    throws SystemException {

    return entryPersistence.findByG_G(groupId, guestbookId, start, end);
}

public List<Entry> getEntries(
    long groupId, long guestbookId, int start, int end, OrderByComparator<Entry> obc) {

    return entryPersistence.findByG_G(groupId, guestbookId, start, end, obc);
}

public int getEntriesCount(long groupId, long guestbookId) {
    return entryPersistence.countByG_G(groupId, guestbookId);
}
\end{verbatim}

  These methods, like the getters in \texttt{GuestbookLocalServiceImpl},
  call the finders you generated with Service Builder. These
  \texttt{getEntries*} methods, however, retrieve entries from a
  specified guestbook and site. The first method gets a list of entries.
  The next method gets a paginated list. The third method sorts the
  paginated list, and the last method gets the total number of entries
  as an integer.
\item
  Add the \texttt{validate} method:

\begin{verbatim}
protected void validate(String name, String email, String entry)
    throws PortalException {

    if (Validator.isNull(name)) {
        throw new EntryNameException();
    }

    if (!Validator.isEmailAddress(email)) {
        throw new EntryEmailException();
    }

    if (Validator.isNull(entry)) {
        throw new EntryMessageException();
    }
}
\end{verbatim}

  This method makes sure the user entered relevant data when creating an
  entry.
\item
  Press {[}CTRL{]}+{[}SHIFT{]}+O to organize imports and select the
  following when prompted:

  \begin{itemize}
  \tightlist
  \item
    \texttt{java.util.Date}
  \item
    \texttt{com.liferay.portal.kernel.service.ServiceContext}
  \item
    \texttt{com.liferay.docs.guestbook.model.Entry}
  \item
    \texttt{com.liferay.portal.kernel.util.Validator}
  \end{itemize}
\end{enumerate}

Nice work! These local service methods implement the services that are
referenced in the portlet class.

\subsection{Updating Generated
Classes}\label{updating-generated-classes}

Now that you've implemented the service methods, you must make them
available to the rest of your application. To do this, run
\texttt{buildService} again:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In \emph{Gradle Tasks} → \emph{guestbook-service} → \emph{build},
  right-click \texttt{buildService} and select \emph{Run Gradle Tasks}.
  In the utility classes, Service Builder populates calls to your newly
  created service methods.
\item
  In the Project Explorer, right-click the \texttt{guestbook-service}
  module and select \emph{Refresh}. Repeat this step for the
  \texttt{guestbook-api} module. This ensures that the changes made by
  Service Builder show up in Liferay @ide@.
\item
  In the Project Explorer, right-click the \texttt{guestbook-service}
  module and select \emph{Gradle} → \emph{Refresh Gradle Project}.
  Repeat this step for the \texttt{guestbook-api} module. This ensures
  that your modules' Gradle dependencies are up to date.
\end{enumerate}

\noindent\hrulefill

\textbf{Tip:} If something goes awry when working with Service Builder,
repeat these steps to run Service Builder again and refresh your api and
service modules.

\noindent\hrulefill

Excellent! Your new back-end has been generated. Now it's time to
refactor your prototype to use it.

\chapter{Refactoring the Prototype}\label{refactoring-the-prototype}

In an earlier section of this Learning Path, you created a Guestbook
portlet prototype. Then you wrote a \texttt{service.xml} file to define
your application's data model, and used Service Builder to generate the
back-end code (the model, service, and persistence layers). You also
added service methods using the appropriate extension points: your
entities' \texttt{*LocalServiceImpl} classes. Now you need to integrate
the original prototype with the new back-end to create a fully
functional application.

There are many differences between the prototype and the application
you'll create. In the back-end, you've already accounted for one big
difference: users can create multiple Guestbooks that each have their
own entries. In the front-end, however, only site administrators should
be able to create guestbooks. Therefore, you'll create another portlet
called Guestbook Admin and place it in the Content menu for sites.

To turn this application from a prototype into a full-fledged Liferay
web application, you'll make these changes:

\begin{itemize}
\tightlist
\item
  Modify your view layer's folder structure to account for the
  administrative portlet
\item
  Set the Display Category so users can find the application more easily
\item
  Create a file to store the application's text keys
\item
  Change the controller to call your new Service Builder-based back-end
\item
  Update the view so it can display multiple Guestbooks in tabs
\end{itemize}

Ready to begin?

Let's Go!{}

\section{Organizing Folders for Larger
Applications}\label{organizing-folders-for-larger-applications}

\begin{verbatim}
<p>Refactoring the Prototype<br>Step 1 of 6</p>
\end{verbatim}

Currently, all your JSPs sit in your web module's
\texttt{src/main/resources/META-INF/resources} folder, which serves as
the context root folder. To make a clear separation between the
Guestbook portlet and the Guestbook Admin portlet, you must place the
files that make up their view layers in separate folders:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In the \texttt{guestbook-web} project, right click the
  \texttt{src/main/resources/META-INF/resources} folder and select
  \emph{New} → \emph{Folder}. Name the new folder
  \texttt{guestbookwebportlet} and click \emph{Finish}.
\item
  Copy \texttt{view.jsp} and \texttt{edit\_entry.jsp} into the new
  folder by dragging and dropping them there.
\item
  Open both files and change the \texttt{init.jsp} location at the top
  of the file:

\begin{verbatim}
<%@include file="../init.jsp"%>        
\end{verbatim}
\item
  Check the other references to JSPs within the files to make sure that
  they point to the new locations.
\end{enumerate}

As you update your view layer to take full advantage of the new
back-end, you'll update any references to the old paths. In addition,
you must update the resource location in your component properties. In
the next step, you'll update all of those properties, including the one
that defines the resource location.

\section{Defining the Component Metadata
Properties}\label{defining-the-component-metadata-properties}

\begin{verbatim}
<p>Refactoring the Prototype<br>Step 2 of 6</p>
\end{verbatim}

When users add applications to a page, they pick them from a list of
\emph{display categories}.

\begin{figure}
\centering
\includegraphics{./images/display-categories.png}
\caption{Users choose applications from a list of display categories.}
\end{figure}

A portlet's display category is defined in its component class as a
metadata property. Since the Guestbook portlet lets users communicate
with each other, you'll add it to the Social category. Only one
Guestbook portlet should be added to a page, so you'll also define it as
a \emph{non-instanceable} portlet. Such a portlet can appear only once
on a page or site, depending on its scope.

Open the \texttt{GuestbookPortlet} class and update the component class
metadata properties to match this configuration:

\begin{verbatim}
@Component(
    immediate = true,
    property = {
        "com.liferay.portlet.display-category=category.social",
        "com.liferay.portlet.instanceable=false",
        "com.liferay.portlet.scopeable=true",
        "javax.portlet.display-name=Guestbook",
        "javax.portlet.expiration-cache=0",
        "javax.portlet.init-param.template-path=/",
        "javax.portlet.init-param.view-template=/guestbookwebportlet/view.jsp",
        "javax.portlet.resource-bundle=content.Language",
        "javax.portlet.security-role-ref=power-user,user",
        "javax.portlet.supports.mime-type=text/html"
    },
    service = Portlet.class
)
\end{verbatim}

The \texttt{com.liferay.portlet.display-category=category.social}
property sets the Guestbook portlet's display category to \emph{Social}.
The \texttt{com.liferay.portlet.instanceable=false} property specifies
that the Guestbook portlet is non-instanceable, so only one instance of
the portlet can be added to a page. In the property
\texttt{javax.portlet.init-param.view-template}, you also update the
location of the main \texttt{view.jsp} to its new location in
\texttt{/guestbookwebportlet}.

Since you edited the portlet's metadata, you must remove and re-add the
portlet to the page before continuing:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Go to \texttt{localhost:8080} in your web browser.
\item
  Sign in to your administrative account.
\item
  The Guestbook portlet now shows an error on the page. Click its
  portlet menu (at the top-right of the portlet), then select
  \emph{Remove} and click \emph{OK} to confirm.
\item
  Open the \emph{Add} menu and select \emph{Applications}.
\item
  Open the \emph{Social} category and drag and drop the \emph{Guestbook}
  application onto the page.
\end{enumerate}

Great! Now the Guestbook portlet appears in an appropriate category.
Though you were able to add it to the page before, the user experience
is better.

\section{Creating Portlet Keys}\label{creating-portlet-keys}

\begin{verbatim}
<p>Refactoring the Prototype<br>Step 3 of 6</p>
\end{verbatim}

\texttt{PortletKeys} let you manage important things like the portlet
name or other repeatable, commonly used variables in one place. This
way, if you need to change the portlet's name, you can do it in one
place, and then reference it in every class that needs it. Keys must be
referenced first as a component property, and then as a class.

Follow these steps to create your application's \texttt{PortletKeys}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In your \texttt{guestbook-web} module, open the
  \texttt{GuestbookPortlet} class and update the component class
  metadata properties by adding one new property:

\begin{verbatim}
"javax.portlet.name=" + GuestbookPortletKeys.GUESTBOOK,
\end{verbatim}

  Note that you need the trailing comma if you've added the property to
  the middle of the list. If you've added it to the end of the last,
  leave it off.
\item
  Save \texttt{GuestbookPortlet}. It now shows an error because you
  haven't added the key to the class.
\item
  Open the \texttt{com.liferay.docs.guestbook.constants} package.
\item
  Open \texttt{GuestbookPortletKeys} and create a public, static, final
  String called \texttt{GUESTBOOK} with a value of
  \texttt{com\_liferay\_docs\_guestbook\_portlet\_GuestbookPortlet}:

\begin{verbatim}
public static final String GUESTBOOK =
         "com_liferay_docs_guestbook_portlet_GuestbookPortlet";
\end{verbatim}
\item
  Save the file.
\end{enumerate}

Now \texttt{GuestbookPortlet}'s error has disappeared, and your
application can be deployed again. Nice job!

Next, you'll integrate your application with the new back-end you
generated with Service Builder.

\section{Integrating the New
Back-end}\label{integrating-the-new-back-end}

\begin{verbatim}
<p>Refactoring the Prototype<br>Step 4 of 6</p>
\end{verbatim}

It's a good practice to start with a working prototype as a proof of
concept, but eventually that prototype must transform into a real
application. Up to this point, you've made all the preparations to do
that, and now it's time to replace the prototype back-end with the real,
database-driven back-end you created with Service Builder.

For the prototype, you manually created the application's model. The
first thing you want to do is remove it, because Service Builder
generated a new one:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Find the \texttt{com.liferay.docs.guestbook.model} package in the
  \texttt{guestbook-web} module.
\item
  Delete it. You'll see errors in your project, but that's because you
  haven't replaced the model yet.
\end{enumerate}

Now you get to do some dependency management. For the web module to
access the generated services, you must make it aware of the API and
service modules. Then you can update the \texttt{addEntry} method in
\texttt{GuestbookPortlet} to use the new services:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  First, open \texttt{guestbook-web}'s \texttt{build.gradle} file and
  add these dependencies:

\begin{verbatim}
compileOnly project(":modules:guestbook:guestbook-api")
compileOnly project(":modules:guestbook:guestbook-service")
\end{verbatim}
\item
  Right-click on the \texttt{guestbook-web} project and select
  \emph{Gradle} → \emph{Refresh Gradle Project}.
\item
  Now you must add \emph{references} to the Service Builder services you
  need. To do this, add them as class variables with \texttt{@Reference}
  annotations on their setter methods. Open \texttt{GuestbookPortlet}
  and add these references to the bottom of the file:

\begin{verbatim}
    @Reference(unbind = "-")
    protected void setEntryService(EntryLocalService entryLocalService) {
        _entryLocalService = entryLocalService;
    }

    @Reference(unbind = "-")
    protected void setGuestbookService(GuestbookLocalService guestbookLocalService) {
        _guestbookLocalService = guestbookLocalService;
    }

    private EntryLocalService _entryLocalService;
    private GuestbookLocalService _guestbookLocalService;
\end{verbatim}

  Note that it's Liferay's code style to add class variables this way.
  The \texttt{@Reference} annotation on the setters allows Liferay's
  OSGi container to inject references to your generated services so you
  can use them. The \texttt{unbind} parameter tells the container
  there's no method for unbinding these services: the references can die
  with the class during garbage collection when they're no longer
  needed.
\item
  Now you can modify the \texttt{addEntry} method to use these service
  references:

\begin{verbatim}
public void addEntry(ActionRequest request, ActionResponse response)
            throws PortalException {

        ServiceContext serviceContext = ServiceContextFactory.getInstance(
            Entry.class.getName(), request);

        String userName = ParamUtil.getString(request, "name");
        String email = ParamUtil.getString(request, "email");
        String message = ParamUtil.getString(request, "message");
        long guestbookId = ParamUtil.getLong(request, "guestbookId");
        long entryId = ParamUtil.getLong(request, "entryId");

    if (entryId > 0) {

        try {

            _entryLocalService.updateEntry(
                serviceContext.getUserId(), guestbookId, entryId, userName,
                email, message, serviceContext);

            SessionMessages.add(request, "entryAdded");

            response.setRenderParameter(
                "guestbookId", Long.toString(guestbookId));

        }
        catch (Exception e) {
            System.out.println(e);

            SessionErrors.add(request, e.getClass().getName());

            PortalUtil.copyRequestParameters(request, response);

            response.setRenderParameter(
                "mvcPath", "/guestbookwebportlet/edit_entry.jsp");
        }

    }
    else {

        try {
            _entryLocalService.addEntry(
                serviceContext.getUserId(), guestbookId, userName, email,
                message, serviceContext);

            SessionMessages.add(request, "entryAdded");

            response.setRenderParameter(
                "guestbookId", Long.toString(guestbookId));

        }
        catch (Exception e) {
            SessionErrors.add(request, e.getClass().getName());

            PortalUtil.copyRequestParameters(request, response);

            response.setRenderParameter(
                "mvcPath", "/guestbookwebportlet/edit_entry.jsp");
        }
    }
}
\end{verbatim}

  This \texttt{addEntry} method gets the name, message, and email fields
  that the user submits in the JSP and passes them to the service to be
  stored as entry data. The \texttt{if-else} logic checks whether
  there's an existing \texttt{entryId}. If there is, the update service
  method is called, and if not, the add service method is called. In
  both cases, it sets a render parameter with the Guestbook ID so the
  application can display the guestbook's entries after this one has
  been added. This is all done in \texttt{try...catch} statements.
\item
  Now add \texttt{deleteEntry}, which you didn't have before:

\begin{verbatim}
public void deleteEntry(ActionRequest request, ActionResponse response) throws PortalException {
        long entryId = ParamUtil.getLong(request, "entryId");
        long guestbookId = ParamUtil.getLong(request, "guestbookId");

        ServiceContext serviceContext = ServiceContextFactory.getInstance(
            Entry.class.getName(), request);

        try {

            response.setRenderParameter(
                "guestbookId", Long.toString(guestbookId));

            _entryLocalService.deleteEntry(entryId, serviceContext);
        }

        catch (Exception e) {
            Logger.getLogger(GuestbookPortlet.class.getName()).log(
                Level.SEVERE, null, e);
        }
}
\end{verbatim}

  This method retrieves the entry object (using its ID from the request)
  and calls the service to delete it.
\item
  Next you must replace the \texttt{render} method:

\begin{verbatim}
@Override
public void render(RenderRequest renderRequest, RenderResponse renderResponse)
        throws IOException, PortletException {

        try {
            ServiceContext serviceContext = ServiceContextFactory.getInstance(
                Guestbook.class.getName(), renderRequest);

            long groupId = serviceContext.getScopeGroupId();

            long guestbookId = ParamUtil.getLong(renderRequest, "guestbookId");

            List<Guestbook> guestbooks = _guestbookLocalService.getGuestbooks(
                groupId);

            if (guestbooks.isEmpty()) {
                Guestbook guestbook = _guestbookLocalService.addGuestbook(
                    serviceContext.getUserId(), "Main", serviceContext);

                guestbookId = guestbook.getGuestbookId();
            }

            if (guestbookId == 0) {
                guestbookId = guestbooks.get(0).getGuestbookId();
            }

            renderRequest.setAttribute("guestbookId", guestbookId);
        }
        catch (Exception e) {
            throw new PortletException(e);
        }

        super.render(renderRequest, renderResponse);
}
\end{verbatim}

  This new \texttt{render} method checks for any guestbooks in the
  current site. If there aren't any, it creates one. Either way, it
  grabs the first guestbook so its entries can be displayed by your view
  layer.
\item
  Remove the \texttt{parseEntries} method. It's a remnant of the
  prototype application.
\item
  Hit Ctrl-Shift-O to organize your imports.
\end{enumerate}

Awesome! You've updated your controller to use services. Next, you'll
tackle the view.

\section{Updating the View}\label{updating-the-view}

\begin{verbatim}
<p>Refactoring the Prototype<br>Step 5 of 6</p>
\end{verbatim}

You updated more than just the basic mechanism behind creating the
entry--you completely changed its method and structure. You must,
therefore, update the UI as well. To do that, you must create a new JSP
for managing guestbooks, and update the existing JSPs.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  First, you must update your dependencies. In your
  \texttt{guestbook-web} module, open \texttt{init.jsp} from
  \texttt{/src/main/resources/META-INF/resources/}. In this file, add
  the following additional dependencies:

\begin{verbatim}
<%@ taglib uri="http://liferay.com/tld/frontend" prefix="liferay-frontend" %>
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %>
<%@ taglib uri="http://liferay.com/tld/security" prefix="liferay-security" %>
<%@ page import="java.util.List" %>
<%@ page import="com.liferay.portal.kernel.util.ParamUtil" %>
<%@ page import="com.liferay.portal.kernel.util.HtmlUtil" %>
<%@ page import="com.liferay.portal.kernel.util.StringPool" %>
<%@ page import="com.liferay.portal.kernel.model.PersistedModel" %>
<%@ page import="com.liferay.portal.kernel.dao.search.SearchEntry" %>
<%@ page import="com.liferay.portal.kernel.dao.search.ResultRow" %>
<%@ page import="com.liferay.docs.guestbook.model.Guestbook" %>
<%@ page import="com.liferay.docs.guestbook.service.EntryLocalServiceUtil" %>
<%@ page import="com.liferay.docs.guestbook.service.GuestbookLocalServiceUtil" %>
<%@ page import="com.liferay.docs.guestbook.model.Entry" %> 
\end{verbatim}
\item
  Open the \texttt{view.jsp} file found in
  \texttt{/resources/META-INF/resources/guestbookwebportlet}. Replace
  this file's contents with the following code:

\begin{verbatim}
<%@include file="../init.jsp"%>

<%
long guestbookId = Long.valueOf((Long) renderRequest
        .getAttribute("guestbookId"));
%>

<aui:button-row cssClass="guestbook-buttons">

    <portlet:renderURL var="addEntryURL">
        <portlet:param name="mvcPath" value="/guestbookwebportlet/edit_entry.jsp" />
        <portlet:param name="guestbookId"
            value="<%=String.valueOf(guestbookId)%>" />
    </portlet:renderURL>

    <aui:button onClick="<%=addEntryURL.toString()%>" value="Add Entry"></aui:button>

</aui:button-row>

<liferay-ui:search-container total="<%=EntryLocalServiceUtil.getEntriesCount()%>">
<liferay-ui:search-container-results
    results="<%=EntryLocalServiceUtil.getEntries(scopeGroupId.longValue(),
                    guestbookId, searchContainer.getStart(),
                    searchContainer.getEnd())%>" />

<liferay-ui:search-container-row
    className="com.liferay.docs.guestbook.model.Entry" modelVar="entry">

    <liferay-ui:search-container-column-text property="message" />

    <liferay-ui:search-container-column-text property="name" />

</liferay-ui:search-container-row>

<liferay-ui:search-iterator />

</liferay-ui:search-container>
\end{verbatim}
\end{enumerate}

This \texttt{view.jsp} now retrieves the entries from the guestbook it
gets from the \texttt{render} method. It does this inside a Liferay DXP
construct called a \emph{Search Container}. This is a front-end
component that makes it easy to display data in rows and columns. The
\texttt{EntryLocalServiceUtil} call retrieves the data from your new
Service Builder-based back-end. Otherwise, this JSP is much the same:
you still have an \emph{Add Entry} button with its corresponding URL.

Next, you need to edit the \texttt{edit\_entry.jsp}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open \texttt{edit\_entry.jsp} and replace the existing code with this:

\begin{verbatim}
<%@include file="../init.jsp" %>

<% 

long entryId = ParamUtil.getLong(renderRequest, "entryId");

Entry entry = null;
if (entryId > 0) {
  entry = EntryLocalServiceUtil.getEntry(entryId);
}

long guestbookId = ParamUtil.getLong(renderRequest, "guestbookId");

%>

<portlet:renderURL var="viewURL">

<portlet:param name="mvcPath" value="/guestbookwebportlet/view.jsp"></portlet:param>

</portlet:renderURL>

<portlet:actionURL name="addEntry" var="addEntryURL"></portlet:actionURL>

<aui:form action="<%= addEntryURL %>" name="<portlet:namespace />fm">

<aui:model-context bean="<%= entry %>" model="<%= Entry.class %>" />

    <aui:fieldset>

        <aui:input name="name" />
        <aui:input name="email" />
        <aui:input name="message" />
        <aui:input name="entryId" type="hidden" />
        <aui:input name="guestbookId" type="hidden" value='<%= entry == null ? guestbookId : entry.getGuestbookId() %>'/>

    </aui:fieldset>

    <aui:button-row>

        <aui:button type="submit"></aui:button>
        <aui:button type="cancel" onClick="<%= viewURL.toString() %>"></aui:button>

    </aui:button-row>
</aui:form>
\end{verbatim}

  This is much the same form, though there are more fields now. Using
  some AlloyUI tags, the form is linked to your \texttt{Entry} entity.
  The two hidden fields contain the new \texttt{entryId} and the
  \texttt{guestbookId} for the guestbook the new entry belongs to. The
  submit button is an \texttt{ActionURL} that executes the
  \texttt{addEntry} method in the controller (your portlet class).
\end{enumerate}

Congratulations! You've now successfully replaced your prototype
back-end with a real, database-driven back-end. Next, you'll do a quick
review and deploy your application.

\section{Fitting it All Together}\label{fitting-it-all-together}

\begin{verbatim}
<p>Refactoring the Prototype<br>Step 6 of 6</p>
\end{verbatim}

You've created a complete data-driven application from the back-end to
the display. It's a great time to review how everything connects
together.

\subsection{The Entry}\label{the-entry}

First, you defined your model in Service Builder's configuration file,
\texttt{service.xml}. The main part of this is your \texttt{Entry}
object:

\begin{verbatim}
<entity local-service="true" name="Entry" uuid="true">

    <!-- PK fields -->

    <column name="entryId" primary="true" type="long" />

    <!-- Group instance -->

    <column name="groupId" type="long" />

    <!-- Audit fields -->

    <column name="companyId" type="long" />
    <column name="userId" type="long" />
    <column name="userName" type="String" />
    <column name="createDate" type="Date" />
    <column name="modifiedDate" type="Date" />
    <column name="name" type="String" />
    <column name="email" type="String" />
    <column name="message" type="String" />
    <column name="guestbookId" type="long" />

    <finder name="G_G" return-type="Collection">
        <finder-column name="groupId" />
        <finder-column name="guestbookId" />
    </finder>
</entity>
\end{verbatim}

Next, you created a service implementation in
\texttt{EntryLocalServiceImpl} that defined how to get and store the
entry. Every field you defined was accounted for in the
\texttt{addEntry} method.

\begin{verbatim}
public Entry addEntry(long userId, long guestbookId, String name, String email,
        String message, ServiceContext serviceContext)
        throws PortalException {

        long groupId = serviceContext.getScopeGroupId();

        User user = userLocalService.getUserById(userId);

        Date now = new Date();

        validate(name, email, message);

        long entryId = counterLocalService.increment();

        Entry entry = entryPersistence.create(entryId);

        entry.setUuid(serviceContext.getUuid());
        entry.setUserId(userId);
        entry.setGroupId(groupId);
        entry.setCompanyId(user.getCompanyId());
        entry.setUserName(user.getFullName());
        entry.setCreateDate(serviceContext.getCreateDate(now));
        entry.setModifiedDate(serviceContext.getModifiedDate(now));
        entry.setExpandoBridgeAttributes(serviceContext);
        entry.setGuestbookId(guestbookId);
        entry.setName(name);
        entry.setEmail(email);
        entry.setMessage(message);
    
        entryPersistence.update(entry);

        return entry;
}
\end{verbatim}

Notice that all the fields you described in Service Builder (including
things like the \texttt{uuid}) are present here.

You also added ways to get entries:

\begin{verbatim}
    public List<Entry> getEntries(long groupId, long guestbookId) {
        return entryPersistence.findByG_G(groupId, guestbookId);
    }

    public List<Entry> getEntries(
        long groupId, long guestbookId, int start, int end, OrderByComparator<Entry> obc) {

        return entryPersistence.findByG_G(groupId, guestbookId, start, end, obc);
    }

    public List<Entry> getEntries(long groupId, long guestbookId, int start, int end)
        throws SystemException {

        return entryPersistence.findByG_G(groupId, guestbookId, start, end);
    }
\end{verbatim}

In \texttt{service.xml} you defined \texttt{groupId} and
\texttt{guestbookId} as the two finder fields, and in these methods you
called methods generated to the persistence layer.

After you implemented all that, Service Builder propagated your
implementation to the interfaces, so they could be called. Then, in the
portlet class, you created references to the service classes that
Service Builder generated, and used those references to access the
service to add an entry:

\begin{verbatim}
_entryLocalService.addEntry( serviceContext.getUserId(), guestbookId, 
    userName, email,message, serviceContext);
\end{verbatim}

Finally, you wrapped all this up in a user interface that lets users
enter the information they want, and displays the data they've entered.

Now that you've built the application, and you can see a clear picture
of how it all works, it's time to test it.

\subsection{Deploying and Testing the
Application}\label{deploying-and-testing-the-application}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Drag and drop the \texttt{guestbook-api} module onto the server.
\item
  Drag and drop the \texttt{guestbook-service} module onto the server.
\item
  Look for the STARTED messages from the console.
\item
  Go to your Liferay DXP instance at \texttt{localhost:8080} in your
  browser to test your updated application.
\item
  Click \emph{Add Entry}.
\item
  Enter a \emph{Name}, \emph{Message}, and \emph{Email Address}.
\item
  Click \emph{Submit}.
\item
  Verify that your entry appears.
\end{enumerate}

\begin{figure}
\centering
\includegraphics{./images/guestbook-entry-test.png}
\caption{A new guestbook and entry.}
\end{figure}

\subsection{What's Next?}\label{whats-next}

You've created a working web application and deployed it on Liferay DXP.
If you've created web applications before, though, you know that it's
missing some important features: security, front-end validation, and an
interface for administrators to create multiple guestbooks per portlet.
In the next section, you'll begin adding these (and more) features.

\chapter{Writing an Administrative
Portlet}\label{writing-an-administrative-portlet}

Like the prototype, the real application lets users add and view
guestbook entries. The application's back-end, however, is much more
powerful. It can support many guestbooks and their associated entries.
Despite this, there's no UI to support these added features. When you
create this UI, you must also make sure that only administrators can add
guestbooks.

To accomplish this, you must create a Guestbook Admin portlet and place
it in Liferay DXP's administrative interface--specifically, within the
Content menu. This way, the Guestbook Admin portlet is accessible only
to Site Administrators, and users can use the Guestbook portlet to
create entries.

In short, this is a simple application with a simple interface:

\begin{figure}
\centering
\includegraphics{./images/admin-app-start.png}
\caption{The Guestbook Admin portlet lets administrators manage
Guestbooks.}
\end{figure}

Are you ready to begin?

Let's Go!{}

\section{Creating the Classes}\label{creating-the-classes}

\begin{verbatim}
<p>Writing the Guestbook Admin App<br>Step 1 of 5</p>
\end{verbatim}

Because the Guestbook and Guestbook Admin applications should be bundled
together, you'll create the new application manually inside the
\texttt{guestbook-web} project, rather than by using a wizard. If you
disagree with this design decision, you can create a separate project
for Guestbook Admin; the project template you'd use is \emph{panel-app}.
For now, however, it's better to go through the process manually to
learn how it all works:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Right-click the \texttt{com.liferay.docs.guestbook.portlet} package in
  the \texttt{guestbook-web} project and select \emph{New} →
  \emph{Class}.
\item
  Name the class \texttt{GuestbookAdminPortlet}.
\item
  Click \emph{Browse} next to the Superclass and search for
  \texttt{MVCPortlet}. Click it and select \emph{OK}.
\item
  Click \emph{Finish}.
\end{enumerate}

You now have your Guestbook Admin application's portlet class. For an
administrative application, however, you need at least one more
component.

\subsection{Panels and Categories}\label{panels-and-categories}

As described in the
\href{/docs/7-0/tutorials/-/knowledge_base/t/customizing-the-product-menu}{product
menu tutorial}, there are three sections of the product menu as
illustrated below.

\begin{figure}
\centering
\includegraphics{./images/product-menu-parts.png}
\caption{The product menu is split into three sections: the Control
Panel, the User menu, and the Sites menu.}
\end{figure}

Each section is called a \emph{panel category}. A panel category can
hold various menu items called \emph{panel apps}. In the illustration
above, the Sites menu is open to reveal its panel apps and categories
(yes, you can nest them).

The most natural place for the Guestbook Admin portlet is in the
\emph{Content} panel category with Liferay DXP's other content-based
apps. This integrates it nicely in the spot where site administrators
expect it to be. This also means you don't have to create a new category
for it: you can just create the panel entry, which is what you'll do
next. If you'd like to learn more about panel categories and apps after
this, see the
\href{/docs/7-0/tutorials/-/knowledge_base/t/customizing-the-product-menu}{product
menu tutorial} and the
\href{/docs/7-0/tutorials/-/knowledge_base/t/customizing-the-control-menu}{control
menu tutorial}.

Follow these steps to create the panel entry for the Guestbook Admin
portlet:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add the dependency you need to extend Liferay DXP's panel categories
  and apps. To do this, open \texttt{guestbook-web}'s
  \texttt{build.gradle} file and add this dependency:

\begin{verbatim}
compileOnly group: "com.liferay", name: "com.liferay.application.list.api", version: "2.0.0"
\end{verbatim}
\item
  Right-click \texttt{guestbook-web} and select \emph{Gradle} →
  \emph{Refresh Gradle Project}.
\item
  Right-click \texttt{src/main/java} in the \texttt{guestbook-web}
  project and select \emph{New} → \emph{Package}. Name the package
  \texttt{com.liferay.docs.guestbook.application.list} and click
  \emph{Finish}.
\item
  Right-click your new package and select \emph{New} → \emph{Class}.
  Name the class \texttt{GuestbookAdminPanelApp}. Click \emph{Browse}
  next to Superclass, search for \texttt{BasePanelApp}, select it, and
  click \emph{OK}. Then click \emph{Finish}.
\end{enumerate}

Great! You've created the classes you need, and you're ready to begin
working on them.

\section{Adding Metadata}\label{adding-metadata}

\begin{verbatim}
<p>Writing the Guestbook Admin App<br>Step 2 of 5</p>
\end{verbatim}

Now that you've generated the classes, you must turn them into OSGi
components. Remember that because components are container-managed
objects, you must provide metadata that tells Liferay DXP's OSGi
container how to manage their lifecycles.

Follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add the following portlet key to the \texttt{GuestbookPortletKeys}
  class:

\begin{verbatim}
public static final String GUESTBOOK_ADMIN =
  "com_liferay_docs_guestbook_portlet_GuestbookAdminPortlet";
\end{verbatim}
\item
  Open the \texttt{GuestbookAdminPortlet} class and add the
  \texttt{@Component} annotation immediately above the class
  declaration:

\begin{verbatim}
@Component(
    immediate = true,
    property = {
            "com.liferay.portlet.display-category=category.hidden",
            "com.liferay.portlet.scopeable=true",
            "javax.portlet.display-name=Guestbooks",
            "javax.portlet.expiration-cache=0",
            "javax.portlet.init-param.portlet-title-based-navigation=true",
            "javax.portlet.init-param.template-path=/",
            "javax.portlet.init-param.view-template=/guestbookadminportlet/view.jsp",
            "javax.portlet.name=" + GuestbookPortletKeys.GUESTBOOK_ADMIN,
            "javax.portlet.resource-bundle=content.Language",
            "javax.portlet.security-role-ref=administrator",
            "javax.portlet.supports.mime-type=text/html",
            "com.liferay.portlet.add-default-resource=true"
    },
    service = Portlet.class
)
\end{verbatim}
\item
  Hit {[}CTRL{]}+{[}SHIFT{]}+O to add the \texttt{javax.portlet.Portlet}
  and other imports.
\end{enumerate}

There are only a few new things here. Note the value of the
\texttt{javax.portlet.display-name} property: \texttt{Guestbooks}. This
is the name that appears in the Site menu. Also note the value of the
\texttt{javax.portlet.name} property:
\texttt{+\ GuestbookPortletKeys.GUESTBOOK\_ADMIN}. This specifies the
portlet's title via the \texttt{GUESTBOOK\_ADMIN} portlet key that you
just created.

Pay special attention to the following metadata property:

\begin{verbatim}
com.liferay.portlet.display-category=category.hidden
\end{verbatim}

This is the same property you used before with the Guestbook portlet.
You placed that portlet in the Social category. The value
\texttt{category.hidden} specifies a special category that doesn't
appear anywhere. You're putting the Guestbook Admin portlet here because
it'll be part of the Site menu, and you don't want users adding it to a
page. This prevents them from doing that.

Next, you can configure the Panel app class. Follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open the \texttt{GuestbookAdminPanelApp} class and add the
  \texttt{@Component} annotation immediately above the class
  declaration:

\begin{verbatim}
@Component(
    immediate = true,
    property = {
        "panel.app.order:Integer=300",
        "panel.category.key=" + PanelCategoryKeys.SITE_ADMINISTRATION_CONTENT
    },
    service = PanelApp.class
)
\end{verbatim}

  The \texttt{panel.category.key} metadata property determines where to
  place the Guestbook Admin portlet in the Product Menu. Remember that
  the Product Menu is divided into three main sections: the Control
  Panel, the User Menu, and the Site Administration area. The value of
  the \texttt{panel.category.key} property is
  \texttt{PanelCategoryKeys.SITE\_ADMINISTRATION\_CONTENT}, which means
  Guestbook Admin is in \emph{Site Administration} → \emph{Content}. The
  key is provided by
  \href{https://github.com/liferay/liferay-portal/blob/7.0.x/modules/apps/web-experience/application-list/application-list-api/src/main/java/com/liferay/application/list/constants/PanelCategoryKeys.java}{the
  \texttt{PanelCategoryKeys} class}. The \texttt{panel.app.order} value
  determines the rank for the Guestbook Admin portlet in the list.
\item
  Finally, update the class to use the proper name and portlet keys:

\begin{verbatim}
public class GuestbookAdminPanelApp extends BasePanelApp {

    @Override
    public String getPortletId() {
        return GuestbookPortletKeys.GUESTBOOK_ADMIN;
    }

    @Override
    @Reference(
        target = "(javax.portlet.name=" + GuestbookPortletKeys.GUESTBOOK_ADMIN + ")",
        unbind = "-"
    )
    public void setPortlet(Portlet portlet) {
        super.setPortlet(portlet);
    }

}
\end{verbatim}
\item
  Hit {[}CTRL{]}+{[}SHIFT{]}+O to organize imports. This time, import
  \texttt{com.liferay.portal.kernel.model.Portlet} instead of
  \texttt{javax.portlet.Portlet}.
\end{enumerate}

Now that the configuration is out of the way, you're free to implement
the app's functionality: adding, editing, and deleting guestbooks.
That's the next step.

\section{Updating Your Service Layer}\label{updating-your-service-layer}

\begin{verbatim}
<p>Writing the Guestbook Admin App<br>Step 3 of 5</p>
\end{verbatim}

In an earlier section, you wrote an \texttt{addGuestbook} service method
in \texttt{GuestbookLocalServiceImpl}, but you never used it. To have
full functionality over guestbooks, you must also add methods for
updating and deleting guestbooks, as well as for returning the number of
guestbooks in a site.

\subsection{Adding Guestbook Service
Methods}\label{adding-guestbook-service-methods}

Remember that when working with Service Builder, you define your service
in the \texttt{*Impl} classes. After you add or remove a method from an
\texttt{*Impl} class, or change the signature of a method in an
\texttt{*Impl} class, you must run Service Builder. Service Builder
updates the affected interfaces and any other generated code.

Follow these steps to add the required guestbook service methods:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Go to the \texttt{guestbook-service} project and open
  \texttt{GuestbookLocalServiceImpl.java} in the
  \texttt{com.liferay.docs.guestbook.service.impl} package. Add the
  following method for updating a guestbook:

\begin{verbatim}
public Guestbook updateGuestbook(long userId, long guestbookId,
    String name, ServiceContext serviceContext) throws PortalException,
                SystemException {

        Date now = new Date();

        validate(name);

        Guestbook guestbook = getGuestbook(guestbookId);

        User user = userLocalService.getUser(userId);

        guestbook.setUserId(userId);
        guestbook.setUserName(user.getFullName());
        guestbook.setModifiedDate(serviceContext.getModifiedDate(now));
        guestbook.setName(name);
        guestbook.setExpandoBridgeAttributes(serviceContext);

        guestbookPersistence.update(guestbook);

        return guestbook;
}
\end{verbatim}

  The \texttt{updateGuestbook} method retrieves the \texttt{Guestbook}
  by its ID, replaces its data with what the user entered, and then
  calls the persistence layer to save it back to the database.
\item
  Next, add the following method for deleting a guestbook:

\begin{verbatim}
public Guestbook deleteGuestbook(long guestbookId,
                ServiceContext serviceContext) throws PortalException,
                SystemException {

        Guestbook guestbook = getGuestbook(guestbookId);

        List<Entry> entries = entryLocalService.getEntries(
                        serviceContext.getScopeGroupId(), guestbookId);

        for (Entry entry : entries) {
                entryLocalService.deleteEntry(entry.getEntryId());
        }

        guestbook = deleteGuestbook(guestbook);

        return guestbook;
}
\end{verbatim}

  It's important to consider what should happen if you delete a
  guestbook that has existing entries. If you just deleted the
  guestbook, the guestbook's entries would still exist in the database,
  but they'd be orphaned. Your \texttt{deleteGuestbook} service method
  makes a service call to delete a guestbook's entries before deleting
  that guestbook. This way, guestbook entries are never orphaned.
\item
  Use {[}CTRL{]}+{[}SHIFT{]}+O to update your imports, then save
  \texttt{GuestbookLocalServiceImpl.java}.
\item
  In the Gradle Tasks pane on the right side in Liferay @ide@, run
  Service Builder by opening the \texttt{guestbook-service} module and
  double-clicking \texttt{buildService}.
\end{enumerate}

Now that you've finished updating the service layer, it's time to work
on the Guestbook Admin portlet itself.

\section{Defining Portlet Actions}\label{defining-portlet-actions}

\begin{verbatim}
<p>Writing the Guestbook Admin App<br>Step 4 of 5</p>
\end{verbatim}

The Guestbook Admin portlet now needs action methods for adding,
updating, and deleting guestbooks. As with the Guestbook portlet, action
methods call the corresponding service methods. Note that since your
services and applications are all running in the same container, any
application can call the Guestbook services. This is an advantage of
Liferay DXP's OSGi-based architecture: different applications or modules
can call services published by other modules. If a service is published,
it can be used via \texttt{@Reference}. You'll take advantage of this
here in the Guestbook Admin portlet to consume one of the same services
consumed by the Guestbook portlet (the \texttt{addGuestbook} service).

\subsection{Adding Three Portlet
Actions}\label{adding-three-portlet-actions}

The Guestbook Admin portlet must let administrators add, update, and
delete \texttt{Guestbook} objects. You'll create portlet actions to meet
these requirements. Open \texttt{GuestbookAdminPortlet.java} and follow
these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add the following action method and instance variables needed for
  adding a new guestbook:

\begin{verbatim}
public void addGuestbook(ActionRequest request, ActionResponse response)
    throws PortalException {

    ServiceContext serviceContext = ServiceContextFactory.getInstance(
        Guestbook.class.getName(), request);

    String name = ParamUtil.getString(request, "name");

    try {
        _guestbookLocalService.addGuestbook(
            serviceContext.getUserId(), name, serviceContext);
    }
    catch (PortalException pe) {

        Logger.getLogger(GuestbookAdminPortlet.class.getName()).log(
            Level.SEVERE, null, pe);

        response.setRenderParameter(
            "mvcPath", "/guestbookadminportlet/edit_guestbook.jsp");
    }
}

private GuestbookLocalService _guestbookLocalService;

@Reference(unbind = "-")
protected void setGuestbookService(GuestbookLocalService guestbookLocalService) {
    _guestbookLocalService = guestbookLocalService;
}
\end{verbatim}

  Since \texttt{addGuestbook} is a portlet action method, it takes
  \texttt{ActionRequest} and \texttt{ActionResponse} parameters. To make
  the service call to add a new guestbook, the guestbook's name must be
  retrieved from the request. The \texttt{serviceContext} must also be
  retrieved from the request and passed as an argument in the service
  call. If an exception is thrown, you should display the Add Guestbook
  form and not the default view. That's why you add this line in the
  \texttt{catch} block:

\begin{verbatim}
response.setRenderParameter("mvcPath",
        "/guestbookadminportlet/edit_guestbook.jsp");
\end{verbatim}

  Later, you'll use this for field validation and to show error messages
  to the user. Note that
  \texttt{/guestbookadminportlet/edit\_guestbook.jsp} doesn't exist yet;
  you'll create it in the next section when you're designing the
  Guestbook Admin portlet's user interface.
\item
  Add the following action method for updating an existing guestbook:

\begin{verbatim}
public void updateGuestbook(ActionRequest request, ActionResponse response)
    throws PortalException {

    ServiceContext serviceContext = ServiceContextFactory.getInstance(
        Guestbook.class.getName(), request);

    String name = ParamUtil.getString(request, "name");
    long guestbookId = ParamUtil.getLong(request, "guestbookId");

    try {
        _guestbookLocalService.updateGuestbook(
            serviceContext.getUserId(), guestbookId, name, serviceContext);

    } catch (PortalException pe) {

        Logger.getLogger(GuestbookAdminPortlet.class.getName()).log(
            Level.SEVERE, null, pe);

        response.setRenderParameter(
            "mvcPath", "/guestbookadminportlet/edit_guestbook.jsp");
    }
}
\end{verbatim}

  This method retrieves the guestbook name, ID, and the
  \texttt{serviceContext} from the request. The \texttt{updateGuestbook}
  service call uses the guestbook's ID to identify the guestbook to
  update. If there's a problem with the service call, the Guestbook
  Admin portlet displays the Edit Guestbook form again so that the user
  can edit the form and resubmit:

\begin{verbatim}
response.setRenderParameter("mvcPath",
        "/guestbookadminportlet/edit_guestbook.jsp");
\end{verbatim}

  Note that the Edit Guestbook form uses the same JSP as the Add
  Guestbook form to avoid duplication of code.
\item
  Add the following action method for deleting a guestbook:

\begin{verbatim}
public void deleteGuestbook(ActionRequest request, ActionResponse response)
    throws PortalException {

    ServiceContext serviceContext = ServiceContextFactory.getInstance(
        Guestbook.class.getName(), request);

    long guestbookId = ParamUtil.getLong(request, "guestbookId");

    try {
        _guestbookLocalService.deleteGuestbook(guestbookId, serviceContext);
    }
    catch (PortalException pe) {

        Logger.getLogger(GuestbookAdminPortlet.class.getName()).log(
            Level.SEVERE, null, pe);
    }
}
\end{verbatim}

  This method uses the service layer to delete the guestbook by its ID.
  Since the \texttt{deleteGuestbook} action is invoked from the
  Guestbook Admin portlet's default view, there's no need to set the
  \texttt{mvcPath} render parameter to point to a particular JSP if
  there was a problem with the \texttt{deleteGuestbook} service call.
\item
  Hit {[}CTRL{]}+{[}SHIFT{]}+O to organize imports. Save the file.
\end{enumerate}

You now have your service methods and portlet action methods in place.
Your last task is to implement the Guestbook Admin portlet's user
interface.

\section{Creating a User Interface}\label{creating-a-user-interface}

\begin{verbatim}
<p>Writing the Guestbook Admin App<br>Step 5 of 5</p>
\end{verbatim}

It's time to create the Guestbook Admin portlet's user interface. The
portlet's default view has a button for adding new guestbooks. It must
also display the guestbooks that already exist.

Each guestbook's name is displayed along with an Actions button. The
Actions button reveals options for editing the guestbook, configuring
its permissions, or deleting it.

\subsection{Creating JSPs for the Guestbook Admin Portlet's User
Interface}\label{creating-jsps-for-the-guestbook-admin-portlets-user-interface}

The Guestbook Admin portlet's user interface is made up of three JSPs:
the default view, the Actions button, and the form for adding or editing
a guestbook.

Create the default view first:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a folder for the Guestbook Admin portlet's JSPs. In
  \texttt{src/main/resources/META-INF/resources}, create a folder called
  \texttt{guestbookadminportlet}.
\item
  Create a file in this folder called \texttt{view.jsp} and fill it with
  this code:

\begin{verbatim}
<%@include file="../init.jsp"%>

<liferay-ui:search-container
    total="<%= GuestbookLocalServiceUtil.getGuestbooksCount(scopeGroupId) %>">
    <liferay-ui:search-container-results
        results="<%= GuestbookLocalServiceUtil.getGuestbooks(scopeGroupId, 
            searchContainer.getStart(), searchContainer.getEnd()) %>" />

    <liferay-ui:search-container-row
        className="com.liferay.docs.guestbook.model.Guestbook" modelVar="guestbook">

        <liferay-ui:search-container-column-text property="name" />

        <liferay-ui:search-container-column-jsp
            align="right" 
            path="/guestbookadminportlet/guestbook_actions.jsp" />

    </liferay-ui:search-container-row>

    <liferay-ui:search-iterator />
</liferay-ui:search-container>

<aui:button-row cssClass="guestbook-admin-buttons">
    <portlet:renderURL var="addGuestbookURL">
        <portlet:param name="mvcPath"
            value="/guestbookadminportlet/edit_guestbook.jsp" />
        <portlet:param name="redirect" value="<%= "currentURL" %>" />
    </portlet:renderURL>

    <aui:button onClick="<%= addGuestbookURL.toString() %>"
        value="Add Guestbook" />
</aui:button-row>
\end{verbatim}

  First is the standard \texttt{init.jsp} include to gain access to the
  imports.

  Next is a button row with a single button for adding new guestbooks:
  \texttt{\textless{}aui:button-row\ cssClass="guestbook-admin-buttons"\textgreater{}}.
  The \texttt{cssClass} attribute lets you specify a custom CSS class
  for additional styling. The
  \texttt{\textless{}portlet:renderURL\textgreater{}} tag constructs a
  URL that points to the \texttt{edit\_guestbook.jsp}. You haven't
  created this JSP yet, but you'll use it for adding a new guestbook and
  editing an existing one.

  Finally, a Liferay search container is used to display the list of
  guestbooks. Three sub-tags define the search container:

  \begin{itemize}
  \tightlist
  \item
    \texttt{\textless{}liferay-ui:search-container-results\textgreater{}}
  \item
    \texttt{\textless{}liferay-ui:search-container-row\textgreater{}}
  \item
    \texttt{\textless{}liferay-ui:search-iterator\textgreater{}}
  \end{itemize}

  The
  \texttt{\textless{}liferay-ui:search-container-results\textgreater{}}
  tag's \texttt{results} attribute uses a service call to retrieve the
  guestbooks in the scope. The \texttt{total} attribute uses another
  service call to get a count of guestbooks.

  The \texttt{\textless{}liferay-ui:search-container-row\textgreater{}}
  tag defines what rows contain. In this case, the \texttt{className}
  attribute defines
  \texttt{com.liferay.docs.guestbook.model.Guestbook"}. The
  \texttt{modelVar} attribute defines \texttt{guestbook} as the variable
  for the currently iterated guestbook. In the search container row, two
  columns are defined. The
  \texttt{\textless{}liferay-ui:search-container-column-text\ property="name"\ /\textgreater{}}
  tag specifies the first column. This tag displays text. Its
  \texttt{property="name"} attribute specifies that the text to be
  displayed is the current guestbook object's \texttt{name} attribute.
  The tag \texttt{\textless{}liferay-ui:search-container-column-jsp}
  \texttt{path="/guestbookadminportlet/guestbook\_actions.jsp"\ align="right"\ /\textgreater{}}
  specifies the second (and last) column. This tag includes another JSP
  file within a search container column. Its \texttt{path} attribute
  specifies the path to the JSP file that should be displayed:
  \texttt{guestbook\_actions.jsp}.

  Finally, the
  \texttt{\textless{}liferay-ui:search-iterator\ /\textgreater{}} tag
  iterates through and displays the list of guestbooks. Using Liferay's
  search container makes the Guestbook Admin portlet look like a native
  Liferay DXP portlet. It also provides built-in pagination so that your
  portlet can automatically display large numbers of guestbooks on one
  site.

  Your next step is to add the \texttt{guestbook\_actions.jsp} file
  that's responsible for displaying the list of possible actions for
  each guestbook.
\item
  Create a new file called \texttt{guestbook\_actions.jsp} in your
  project's \texttt{/guestbookadminportlet} folder. Paste in this code:

\begin{verbatim}
<%@include file="../init.jsp"%>

<%
    String mvcPath = ParamUtil.getString(request, "mvcPath");

    ResultRow row = (ResultRow) request
                    .getAttribute("SEARCH_CONTAINER_RESULT_ROW");

    Guestbook guestbook = (Guestbook) row.getObject();
%>

<liferay-ui:icon-menu>

    <portlet:renderURL var="editURL">
        <portlet:param name="guestbookId"
            value="<%=String.valueOf(guestbook.getGuestbookId()) %>" />
        <portlet:param name="mvcPath"
            value="/guestbookadminportlet/edit_guestbook.jsp" />
    </portlet:renderURL>

    <liferay-ui:icon image="edit" message="Edit"
            url="<%=editURL.toString() %>" />

    <portlet:actionURL name="deleteGuestbook" var="deleteURL">
            <portlet:param name="guestbookId"
                value="<%= String.valueOf(guestbook.getGuestbookId()) %>" />
    </portlet:actionURL>

    <liferay-ui:icon-delete url="<%=deleteURL.toString() %>" />

</liferay-ui:icon-menu>
\end{verbatim}

  This JSP comprises the pop-up actions menu that shows the possible
  actions users can perform on a guestbook: editing it or deleting it.
  First, \texttt{init.jsp} is included because it contains all the JSP
  imports. Because \texttt{guestbook\_actions.jsp} is included for every
  Search Container row, it retrieves the guestbook in the current
  iteration. The scriptlet grabs that guestbook so its ID can be
  supplied to the menu tags.

  The \texttt{\textless{}liferay-ui:icon-menu} tag dominates
  \texttt{guestbook\_actions.jsp}. It's a container for menu items, of
  which there are currently only two (you'll add more later). The Edit
  menu item displays the Edit icon and the message \emph{Edit}:

\begin{verbatim}
<liferay-ui:icon image="edit" message="Edit"
        url="<%=editURL.toString() %>" />
\end{verbatim}

  The \texttt{editURL} variable comes from the
  \texttt{\textless{}portlet:renderURL\ var="editURL"\textgreater{}} tag
  with two parameters: \texttt{guestbookId} and \texttt{mvcPath}. The
  \texttt{guestbookId} parameter specifies the guestbook to edit (it's
  the one from the selected search container result row), and the
  \texttt{mvcPath} parameter specifies the Edit Guestbook form's path.

  The Delete menu item displays a delete icon and the default message
  \emph{Delete}:

\begin{verbatim}
<liferay-ui:icon-delete url="<%=deleteURL.toString() %>" />
\end{verbatim}

  Unlike the \texttt{editURL}, which is a render URL that links to the
  \texttt{edit\_guestbook.jsp}, the \texttt{deleteURL} is an action URL
  that invokes the portlet's \texttt{deleteGuestbook} action. The tag
  \texttt{\textless{}portlet:actionURL\ name="deleteGuestbook"\ var="deleteURL"\textgreater{}}
  creates this action URL, which only takes one parameter: the
  \texttt{guestbookId} of the guestbook to be deleted.

  Now there's just one more JSP file left to create: the
  \texttt{edit\_guestbook.jsp} that contains the form for adding a new
  guestbook and editing an existing one.
\item
  Create a new file called \texttt{edit\_guestbook.jsp} in your
  project's \texttt{/guestbookadminportlet} directory. Then add the
  following code to it:

\begin{verbatim}
<%@include file = "../init.jsp" %>

<%
        long guestbookId = ParamUtil.getLong(request, "guestbookId");

        Guestbook guestbook = null;

        if (guestbookId > 0) {
                guestbook = GuestbookLocalServiceUtil.getGuestbook(guestbookId);
        }
%>

<portlet:renderURL var="viewURL">
        <portlet:param name="mvcPath" value="/guestbookadminportlet/view.jsp" />
</portlet:renderURL>

<portlet:actionURL name='<%= guestbook == null ? "addGuestbook" : "updateGuestbook" %>' var="editGuestbookURL" />

<aui:form action="<%= editGuestbookURL %>" name="fm">

        <aui:model-context bean="<%= guestbook %>" model="<%= Guestbook.class %>" />

        <aui:input type="hidden" name="guestbookId"
            value='<%= guestbook == null ? "" : guestbook.getGuestbookId() %>' />

        <aui:fieldset>
             <aui:input name="name" />
        </aui:fieldset>

        <aui:button-row>
             <aui:button type="submit" />
             <aui:button onClick="<%= viewURL %>" type="cancel"  />
        </aui:button-row>
</aui:form>
\end{verbatim}

  After the \texttt{init.jsp} import, you declare a \texttt{null}
  guestbook variable. If there's a \texttt{guestbookId} parameter in the
  request, then you know that you're editing an existing guestbook, and
  you use the \texttt{guestbookId} to retrieve the corresponding
  guestbook via a service call. Otherwise, you know that you're adding a
  new guestbook.

  Next is a view URL that points to the Guestbook Admin portlet's
  default view. This URL is invoked if the user clicks \emph{Cancel} on
  the Add Guestbook or Edit Guestbook form. After that, you create an
  action URL that invokes either the Guestbook Admin portlet's
  \texttt{addGuestbook} method or its \texttt{updateGuestbook} method,
  depending on whether the \texttt{guestbook} variable is null.

  If a guestbook is being edited, the current guestbook's name should
  appear in the form's name field. You use the following tag to define a
  model of the guestbook that can be used in the AlloyUI form:

\begin{verbatim}
<aui:model-context bean="<%= guestbook %>" model="<%= Guestbook.class %>" />
\end{verbatim}

  The form itself is created with the following tag:

\begin{verbatim}
<aui:form action="<%= editGuestbookURL %>" name="<portlet:namespace />fm">
\end{verbatim}

  When the form is submitted, the \texttt{editGuestbookURL} is invoked,
  which calls the Guestbook Admin portlet's \texttt{addGuestbook} or
  \texttt{updateGuestbook} method, as discussed above.

  The \texttt{guestbookId} must appear on the form so that it can be
  submitted. The user, however, doesn't need to see it. Thus, you
  specify \texttt{type="hidden"}:

\begin{verbatim}
<aui:input type="hidden" name="guestbookId"
        value='<%= guestbook == null ? "" : guestbook.getGuestbookId() %>' />
\end{verbatim}

  The name, of course, should be editable by the user so it's not
  hidden.

  The last item on the form is a button row with two buttons. The
  \emph{Submit} button submits the form, invoking the
  \texttt{editGuestbookURL} which, in turn, invokes either the
  \texttt{addGuestbook} or \texttt{updateGuestbook} method. The
  \emph{Cancel} button invokes the \texttt{viewURL} which displays the
  default view.
\end{enumerate}

Excellent! You've now finished creating the UI for the Guestbook Admin
portlet. It should now match the figure below:

\begin{figure}
\centering
\includegraphics{./images/admin-app-start.png}
\caption{The Guestbook Admin portlet lets administrators add or edit
guestbooks, configure their permissions, or delete them.}
\end{figure}

Test out the Guestbook Admin portlet! Try adding, editing, and deleting
guestbooks.

Now all the Guestbook application's primary functions work. There are
still many missing features, however. For example, if there's ever an
error, users never see it: all the code written so far just prints
messages in the logs. Next, you'll learn how to display those errors to
the user.

\chapter{Using Resources and
Permissions}\label{using-resources-and-permissions}

You now have an application that uses the database for data storage.
This is a great foundation to build on. What comes next? What if users
want a Guestbook that's limited to certain trusted people? To do that,
you have to implement permissions.

Thankfully, with Liferay DXP you don't have to write an entire
permissions system from scratch: the framework provides a robust and
well-tested permissions system that you can implement quickly.

Ready to start?

Let's Go!{}

\section{Configuring Your Permissions
Scheme}\label{configuring-your-permissions-scheme}

\begin{verbatim}
<p>Implementing Permissions<br>Step 1 of 4</p>
\end{verbatim}

Liferay DXP's permissions framework is configured declaratively, like
Service Builder. You define all your permissions in an XML file that by
convention is called \texttt{default.xml} (but you could really call it
whatever you want). Then you implement permissions checks in the
following places in your code:

\begin{itemize}
\tightlist
\item
  In the view layer, when showing links or buttons to protected
  functionality
\item
  In the actions, before performing a protected action
\item
  Later, in your service, before calling the local service
\end{itemize}

You should first define the permissions you want. To get started, think
of your application's use cases and how access to that functionality
should be controlled:

\begin{itemize}
\item
  The Add Guestbook button should be available only to administrators.
\item
  The Guestbook tabs should be filtered by permissions so administrators
  can control who can see them.
\item
  To prevent anonymous users from spamming the guestbook, the Add Entry
  button should be available only to site members.
\item
  Users should be able to set permissions on their own entries.
\end{itemize}

Now you're ready to create the permissions configuration. Objects in
your application (such as \texttt{Guestbook} and \texttt{Entry}) are
defined as \emph{resources}, and \emph{resource actions} manage how
users can interact with those resources. There are therefore two kinds
of permissions: portlet permissions and resource (or model) permissions.
Portlet permissions protect access to global functions, such as
\emph{Add Entry}. If users don't have permission to access that global
function, they're missing a portlet permission. Resource permissions
protect access to objects, such as \texttt{Guestbook} and
\texttt{Entry}. A user may have permission to view one \texttt{Entry},
view and edit another \texttt{Entry}, and may not be able to access
another \texttt{Entry} at all. This is due to a resource permission.

\begin{figure}
\centering
\includegraphics{./images/permission-types.png}
\caption{Portlet permissions and resource permissions cover different
parts of the application.}
\end{figure}

The first thing you must do is tell the framework where your permissions
are defined. You'll define resource and model permissions in the module
where your model is defined:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In \texttt{guestbook-service}'s \texttt{src/main/resources} folder,
  create a file called \texttt{portlet.properties}.
\item
  In this file, place the following property:

\begin{verbatim}
resource.actions.configs=META-INF/resource-actions/default.xml
\end{verbatim}
\end{enumerate}

This property defines the name and location of your permissions
definition file.

Next, create the permissions file:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In the \texttt{META-INF} folder, create a subfolder called
  \texttt{resource-actions}.
\item
  Create a new file in this folder called \texttt{default.xml}.
\item
  Click the \emph{Source} tab. Add the following \texttt{DOCTYPE}
  declaration to the top of the file:

\begin{verbatim}
<?xml version="1.0"?>
<!DOCTYPE resource-action-mapping PUBLIC "-//Liferay//DTD Resource Action  
Mapping 7.0.0//EN" "http://www.liferay.com/dtd/liferay-resource-action-mapping_7_0_0.dtd">
\end{verbatim}
\item
  Place the following wrapper tags into your \texttt{default.xml} file,
  below the \texttt{DOCTYPE} declaration:

\begin{verbatim}
<resource-action-mapping>

</resource-action-mapping>
\end{verbatim}

  You'll define your resource and model permissions inside these tags.
\item
  Next, place the permissions for your
  \texttt{com.liferay.docs.guestbook} package between the
  \texttt{\textless{}resource-action-mapping\textgreater{}} tags:

\begin{verbatim}
<model-resource>
    <model-name>com.liferay.docs.guestbook</model-name>
    <portlet-ref>
        <portlet-name>com_liferay_docs_guestbook_portlet_GuestbookPortlet</portlet-name>
        <portlet-name>com_liferay_docs_guestbook_portlet_GuestbookAdminPortlet</portlet-name>
    </portlet-ref>
    <root>true</root>
    <permissions>
        <supports>
            <action-key>ADD_GUESTBOOK</action-key>
            <action-key>ADD_ENTRY</action-key>
            <action-key>VIEW</action-key>
        </supports>
        <site-member-defaults>
            <action-key>ADD_ENTRY</action-key>
        </site-member-defaults>
        <guest-defaults>
            <action-key>VIEW</action-key>
        </guest-defaults>
        <guest-unsupported>
            <action-key>ADD_GUESTBOOK</action-key>
            <action-key>ADD_ENTRY</action-key>
        </guest-unsupported>
    </permissions>
</model-resource>
\end{verbatim}

  This defines the baseline configuration for the \texttt{Guestbook} and
  \texttt{Entry} entities. The supported actions are
  \texttt{ADD\_GUESTBOOK}, \texttt{ADD\_ENTRY}, and \texttt{VIEW}. Site
  members can \texttt{ADD\_ENTRY} by default, while guests can't perform
  either add action (but they can view).
\item
  Below that, but above the closing
  \texttt{\textless{}/resource-action-mapping\textgreater{}}, place the
  \texttt{Guestbook} model permissions:

\begin{verbatim}
<model-resource>
    <model-name>com.liferay.docs.guestbook.model.Guestbook</model-name>
    <portlet-ref>
        <portlet-name>com_liferay_docs_guestbook_portlet_GuestbookPortlet</portlet-name>
        <portlet-name>com_liferay_docs_guestbook_portlet_GuestbookAdminPortlet</portlet-name>
    </portlet-ref>
    <permissions>
        <supports>
            <action-key>ADD_ENTRY</action-key>
            <action-key>DELETE</action-key>
            <action-key>PERMISSIONS</action-key>
            <action-key>UPDATE</action-key>
            <action-key>VIEW</action-key>
        </supports>
        <site-member-defaults>
            <action-key>ADD_ENTRY</action-key>
            <action-key>VIEW</action-key>
        </site-member-defaults>
        <guest-defaults>
            <action-key>VIEW</action-key>
        </guest-defaults>
        <guest-unsupported>
            <action-key>UPDATE</action-key>
        </guest-unsupported>
    </permissions>
</model-resource>
\end{verbatim}

  This defines the \texttt{Guestbook} specific actions, including
  adding, deleting, updating, and viewing. By default, site members and
  guests can view guestbooks, but guests can't update them.
\item
  Below the \texttt{Guestbook} model permissions, but still above the
  closing \texttt{\textless{}/resource-action-mapping\textgreater{}},
  place the \texttt{Entry} model permissions:

\begin{verbatim}
<model-resource>
    <model-name>com.liferay.docs.guestbook.model.Entry</model-name>
    <portlet-ref>
        <portlet-name>com_liferay_docs_guestbook_portlet_GuestbookPortlet</portlet-name>
    </portlet-ref>
    <permissions>
        <supports>
            <action-key>DELETE</action-key>
            <action-key>PERMISSIONS</action-key>
            <action-key>UPDATE</action-key>
            <action-key>VIEW</action-key>
        </supports>
        <site-member-defaults>
            <action-key>VIEW</action-key>
        </site-member-defaults>
        <guest-defaults>
            <action-key>VIEW</action-key>
        </guest-defaults>
        <guest-unsupported>
            <action-key>UPDATE</action-key>
        </guest-unsupported>
    </permissions>
</model-resource>
\end{verbatim}

  This defines \texttt{Entry} specific actions. By default, a site
  member can add or view an entry, and a guest can only view an entry.
\item
  Save the file.
\end{enumerate}

This defines permissions at the model level, but you must also define
portlet permissions. These are managed in the \texttt{guestbook-web}
module, which contains the portlet class. Follow these steps to add the
portlet permissions in the \texttt{guestbook-web} module:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In \texttt{guestbook-web}'s \texttt{src/main/resources} folder, create
  a file called \texttt{portlet.properties}.
\item
  In this file, place the following property:

\begin{verbatim}
resource.actions.configs=META-INF/resource-actions/default.xml
\end{verbatim}
\item
  Create a subfolder called \texttt{resource-actions} in the
  \texttt{src/main/resources/META-INF} folder.
\item
  Create a new file in this folder called \texttt{default.xml}.
\item
  Add the following \texttt{DOCTYPE} declaration to the top of the file:

\begin{verbatim}
<?xml version="1.0"?>
<!DOCTYPE resource-action-mapping PUBLIC "-//Liferay//DTD Resource Action  
Mapping 7.0.0//EN" "http://www.liferay.com/dtd/liferay-resource-action-mapping_7_0_0.dtd">
\end{verbatim}
\item
  Below the \texttt{DOCTYPE} declaration, add the following
  \texttt{resource-action-mapping} tags:

\begin{verbatim}
<resource-action-mapping>

</resource-action-mapping>
\end{verbatim}

  You'll define your portlet permissions inside these tags.
\item
  Insert this block of code inside the \texttt{resource-action-mapping}
  tags:

\begin{verbatim}
<portlet-resource>
    <portlet-name>com_liferay_docs_guestbook_portlet_GuestbookAdminPortlet</portlet-name>
    <permissions>
        <supports>
            <action-key>ACCESS_IN_CONTROL_PANEL</action-key>
            <action-key>CONFIGURATION</action-key>
            <action-key>VIEW</action-key>
        </supports>
        <site-member-defaults>
            <action-key>VIEW</action-key>
        </site-member-defaults>
        <guest-defaults>
            <action-key>VIEW</action-key>
        </guest-defaults>
        <guest-unsupported>
            <action-key>ACCESS_IN_CONTROL_PANEL</action-key>
            <action-key>CONFIGURATION</action-key>
        </guest-unsupported>
    </permissions>
</portlet-resource>
\end{verbatim}

  This defines the default permissions for the Guestbook Admin portlet.
  It supports the actions \texttt{ACCESS\_IN\_CONTROL\_PANEL},
  \texttt{CONFIGURATION}, and \texttt{VIEW}. While anyone can view the
  app, guests and site members can't configure it or access it in the
  Control Panel. Since it's a Control Panel portlet, this effectively
  means that only administrators are able to access it.
\item
  Below the Guestbook Admin permissions, insert this block of code:

\begin{verbatim}
<portlet-resource>
    <portlet-name>com_liferay_docs_guestbook_portlet_GuestbookPortlet</portlet-name>
    <permissions>
        <supports>
            <action-key>ADD_TO_PAGE</action-key>
            <action-key>CONFIGURATION</action-key>
            <action-key>VIEW</action-key>
        </supports>
        <site-member-defaults>
            <action-key>VIEW</action-key>
        </site-member-defaults>
        <guest-defaults>
            <action-key>VIEW</action-key>
        </guest-defaults>
        <guest-unsupported />
    </permissions>
</portlet-resource>
\end{verbatim}

  This defines permissions for the Guestbook portlet. It supports the
  actions \texttt{ADD\_TO\_PAGE}, \texttt{CONFIGURATION}, and
  \texttt{VIEW}. Site members and guests get the \texttt{VIEW}
  permission by default.
\item
  Save the file.
\end{enumerate}

Great job! You've now successfully designed and implemented a
permissions scheme for your application. Next, you'll create the Java
code to support permissions in the service layer.

\section{Permissions in the Service
Layer}\label{permissions-in-the-service-layer}

\begin{verbatim}
<p>Implementing Permissions<br>Step 2 of 4</p>
\end{verbatim}

The last step introduced the concept of \emph{resources}. Resources are
data stored with your entities that define how they can be accessed. For
example, when the configuration in your \texttt{default.xml} files is
applied to your application's entities in the database, resources are
created. These resources are then used in conjunction with Liferay DXP's
permissions system to determine who can do what to the entities.

Liferay DXP provides a complete API for managing resources that's
integrated with Service Builder. This API is injected into your
implementation classes automatically. To manage the resources, all you
must do is call the API in the service's add and delete methods. Follow
these steps to do this in your application:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In your \texttt{guestbook-service} module, open
  \texttt{GuestbookLocalServiceImpl.java} from the
  \texttt{com.liferay.docs.guestbook.service.impl} package.
\item
  Just before the \texttt{addGuestbook} method's \texttt{return}
  statement, add this code:

\begin{verbatim}
resourceLocalService.addResources(user.getCompanyId(), groupId, userId,
    Guestbook.class.getName(), guestbookId, false, true, true);
\end{verbatim}

  Note that the \texttt{resourceLocalService} object is already there,
  ready for you to use. This is one of several utilities that are
  injected automatically by Service Builder. You'll see the rest in the
  future.

  This code adds a resource to Liferay DXP's database to correspond with
  your entity (note that the \texttt{guestbookId} is included in the
  call). The three booleans at the end are settings. The first is
  whether to add portlet action permissions. This should only be
  \texttt{true} if the permission is for a portlet resource. Since this
  permission is for a model resource (an entity), it's \texttt{false}.
  The other two are settings for adding group and guest permissions. If
  you set these to \texttt{true}, you'll add the default permissions you
  defined in the permissions configuration file (\texttt{default.xml})
  in the previous step. Since you definitely want to do this, these
  booleans are set to \texttt{true}.
\item
  Next, go to the \texttt{updateGuestbook} method. Add a similar bit of
  code in between \texttt{guestbookPersistence.update(guestbook);} and
  the \texttt{return} statement:

\begin{verbatim}
resourceLocalService.updateResources(serviceContext.getCompanyId(),
                serviceContext.getScopeGroupId(), 
                Guestbook.class.getName(), guestbookId,
                serviceContext.getGroupPermissions(),
                serviceContext.getGuestPermissions());
\end{verbatim}
\item
  Now you'll do the same for \texttt{deleteGuestbook}. Add this code in
  between \texttt{guestbook\ =\ deleteGuestbook(guestbook);} and the
  \texttt{return} statement:

\begin{verbatim}
resourceLocalService.deleteResource(serviceContext.getCompanyId(),
                Guestbook.class.getName(), ResourceConstants.SCOPE_INDIVIDUAL,
                guestbookId);
\end{verbatim}
\item
  Hit {[}CTRL{]}+{[}SHIFT{]}+O to organize the imports and save the
  file.
\item
  Now you'll add resources for the \texttt{Entry} entity. Open
  \texttt{EntryLocalServiceImpl.java} from the same package. For
  \texttt{addEntry}, add a line of code that adds resources for this
  entity, just before the return statement:

\begin{verbatim}
resourceLocalService.addResources(user.getCompanyId(), groupId, userId,
    Entry.class.getName(), entryId, false, true, true);
\end{verbatim}
\item
  For \texttt{deleteEntry}, add this code just before the
  \texttt{return} statement:

\begin{verbatim}
resourceLocalService.deleteResource(
               serviceContext.getCompanyId(), Entry.class.getName(),
               ResourceConstants.SCOPE_INDIVIDUAL, entryId);
\end{verbatim}
\item
  Finally, find \texttt{updateEntry} and add its resource action, also
  just before the \texttt{return} statement:

\begin{verbatim}
resourceLocalService.updateResources(
      user.getCompanyId(), serviceContext.getScopeGroupId(), 
      Entry.class.getName(), entryId, serviceContext.getGroupPermissions(),
      serviceContext.getGuestPermissions());
\end{verbatim}
\end{enumerate}

That's all it takes to add permissions resources. Future entities added
to the database are fully permissions-enabled. Note, however, that any
entities you've already added to your Guestbook application in the
portal don't have resources and thus can't be protected by permissions.
You'll fix this at the end of this section.

Next, you'll create helper classes to make it easier to check
permissions.

\section{Creating Permissions Helper
Classes}\label{creating-permissions-helper-classes}

\begin{verbatim}
<p>Implementing Permissions<br>Step 3 of 4</p>
\end{verbatim}

You've now defined your permissions and made sure resources are added to
the database so permissions can be checked. Now you'll create the helper
classes needed to check permissions.

Here's how it works. You have a permission, such as \texttt{ADD\_ENTRY},
and a resource, such as a \texttt{Guestbook}. For a user to add an entry
to a guestbook, you must check whether that user has the
\texttt{ADD\_ENTRY} permission for that guestbook. Creating helper
classes to check permissions on particular models and entities makes
these checks more efficient. Creating such classes is therefore a best
practice. Now you'll create these classes for the Guestbook application:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Right-click the \texttt{guestbook-service} module and select
  \emph{New} → \emph{Package}. Name the package
  \texttt{com.liferay.docs.guestbook.service.permission}. This is where
  you'll place your helper classes.
\item
  Right-click the new package and select \emph{New} → \emph{Class}. Name
  the class \texttt{GuestbookModelPermission}.
\item
  Replace this class's contents with the following code:

\begin{verbatim}
package com.liferay.docs.guestbook.service.permission;

import org.osgi.service.component.annotations.Component;

import com.liferay.portal.kernel.exception.PortalException;
import com.liferay.portal.kernel.security.auth.PrincipalException;
import com.liferay.portal.kernel.security.permission.BaseResourcePermissionChecker;
import com.liferay.portal.kernel.security.permission.PermissionChecker;
import com.liferay.portal.kernel.security.permission.ResourcePermissionChecker;

@Component(immediate = true, property = {
    "resource.name=" + GuestbookModelPermission.RESOURCE_NAME
}, service = ResourcePermissionChecker.class)

public class GuestbookModelPermission extends BaseResourcePermissionChecker {

    public static final String RESOURCE_NAME = "com.liferay.docs.guestbook";

    public static void check(
        PermissionChecker permissionChecker, long groupId, String actionId)
        throws PortalException {

        if (!contains(permissionChecker, groupId, actionId)) {
            throw new PrincipalException.MustHavePermission(
                permissionChecker, RESOURCE_NAME, groupId, actionId);
        }
    }

    public static boolean contains(
        PermissionChecker permissionChecker, long groupId, String actionId) {

        return permissionChecker.hasPermission(
            groupId, RESOURCE_NAME, groupId, actionId);
    }

    @Override
    public Boolean checkResource(
        PermissionChecker permissionChecker, long classPK, String actionId) {

        return contains(permissionChecker, classPK, actionId);
    }
}
\end{verbatim}
\end{enumerate}

This class is a component that extends
\texttt{BaseResourcePermissionChecker} and defines two static methods
(so you don't have to instantiate the class) that encapsulate the model
you're checking permissions for. It also contains a boolean method that
checks your resources. Liferay's \texttt{PermissionChecker} class does
most of the work: you only need feed it the proper resource and action,
such as \texttt{ADD\_ENTRY}, and it returns whether the permission
exists or not.

There are three implementations here: a \texttt{check} method that
throws an exception if the user doesn't have permission, a
\texttt{contains} method that returns a boolean that's \texttt{true} if
the user has permission and \texttt{false} if not, and a
\texttt{checkResource} method that calls the \texttt{contains} method.

Next, you'll create helpers for your two entities. Follow these steps to
do so:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a class in the same package called
  \texttt{GuestbookPermission.java}.
\item
  Replace this class's contents with the following code:

\begin{verbatim}
package com.liferay.docs.guestbook.service.permission;

import com.liferay.docs.guestbook.model.Guestbook;
import com.liferay.docs.guestbook.service.GuestbookLocalService;
import com.liferay.portal.kernel.exception.PortalException;
import com.liferay.portal.kernel.exception.SystemException;
import com.liferay.portal.kernel.security.auth.PrincipalException;
import com.liferay.portal.kernel.security.permission.BaseModelPermissionChecker;
import com.liferay.portal.kernel.security.permission.PermissionChecker;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Reference;

@Component(
    immediate = true,
    property = {"model.class.name=com.liferay.docs.guestbook.model.Guestbook"}
)
public class GuestbookPermission implements BaseModelPermissionChecker {

    public static void check(
        PermissionChecker permissionChecker, long guestbookId, String actionId)
        throws PortalException, SystemException {

        if (!contains(permissionChecker, guestbookId, actionId)) {
            throw new PrincipalException();
        }
    }

    public static void check(
        PermissionChecker permissionChecker, long groupId, long guestbookId,
        String actionId)
        throws PortalException {

        if (!contains(permissionChecker, groupId, actionId)) {
            throw new PrincipalException.MustHavePermission(
                permissionChecker, Guestbook.class.getName(), guestbookId,
                actionId);
        }
    }

    public static boolean contains(
        PermissionChecker permissionChecker, long groupId, long guestbookId, String actionId) 
            throws PortalException {

        Guestbook guestbook = _guestbookLocalService.getGuestbook(guestbookId);

        return GuestbookModelPermission.contains(permissionChecker, groupId, actionId);
    }

    public static boolean contains(
        PermissionChecker permissionChecker, long guestbookId, String actionId)
        throws PortalException, SystemException {

        Guestbook guestbook
            = _guestbookLocalService.getGuestbook(guestbookId);
        return contains(permissionChecker, guestbook, actionId);
    }

    public static boolean contains(
        PermissionChecker permissionChecker, Guestbook guestbook, String actionId) 
            throws PortalException, SystemException {

        return permissionChecker.hasPermission(
        guestbook.getGroupId(), Guestbook.class.getName(), guestbook.getGuestbookId(), actionId);

    }

    @Reference(unbind = "-")
    protected void setGuestbookLocalService(GuestbookLocalService guestbookLocalService) {
        _guestbookLocalService = guestbookLocalService;
    }

    private static GuestbookLocalService _guestbookLocalService;

    @Override
    public void checkBaseModel(
        PermissionChecker permissionChecker, long groupId, long guestbookId, String actionId) throws PortalException {
            check(permissionChecker, guestbookId, actionId);
    }
}
\end{verbatim}
\end{enumerate}

As you can see, this class is similar to
\texttt{GuestbookModelPermission}. The difference is that
\texttt{GuestbookPermission} is for the model/resource permission, so
you supply the primary key of the entity you're checking permissions for
(\texttt{guestbookId}). The \texttt{check} and \texttt{contains} methods
in \texttt{GuestbookPermission} are also similar to those in
\texttt{GuestbookModelPermission}. In both classes, the \texttt{check}
method throws an exception if there's no permission, while the
\texttt{contains} method returns a boolean denoting whether the current
user has permission. The \texttt{contains} method in
\texttt{GuestbookPermission}, however, also retrieves the entity to
verify that it exists (if it doesn't, an exception is thrown).

Your final class is almost identical to \texttt{GuestbookPermission},
but it's for the \texttt{Entry} entity. Follow these steps to create it:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a class in the same package called
  \texttt{EntryPermission.java}.
\item
  Replace this class's contents with the following code:

\begin{verbatim}
package com.liferay.docs.guestbook.service.permission;

import com.liferay.docs.guestbook.model.Entry;
import com.liferay.docs.guestbook.service.EntryLocalService;
import com.liferay.portal.kernel.exception.PortalException;
import com.liferay.portal.kernel.exception.SystemException;
import com.liferay.portal.kernel.security.auth.PrincipalException;
import com.liferay.portal.kernel.security.permission.BaseModelPermissionChecker;
import com.liferay.portal.kernel.security.permission.PermissionChecker;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Reference;

@Component(
    immediate = true,
    property = {"model.class.name=com.liferay.docs.guestbook.model.Entry"}
)
public class EntryPermission implements BaseModelPermissionChecker {

    public static void check(
        PermissionChecker permissionChecker, long entryId, String actionId)
        throws PortalException, SystemException {

        if (!contains(permissionChecker, entryId, actionId)) {
            throw new PrincipalException();
        }
    }

    public static boolean contains(
        PermissionChecker permissionChecker, long entryId, String actionId)
        throws PortalException, SystemException {

        Entry entry = _entryLocalService.getEntry(entryId);

        return contains (permissionChecker, entry, actionId);

    }

    public static boolean contains(
        PermissionChecker permissionChecker, Entry entry, String actionId) throws
        PortalException, SystemException {

        return permissionChecker.hasPermission(entry.getGroupId(), Entry.class.getName(), entry.getEntryId(), actionId);
    }

    @Reference(unbind = "-")
    protected void setEntryLocalService (EntryLocalService entryLocalService) {

        _entryLocalService = entryLocalService;
    }

    private static EntryLocalService _entryLocalService; 

    @Override
    public void checkBaseModel(
        PermissionChecker permissionChecker, long groupId, long primaryKey, String actionId) throws PortalException {
            check(permissionChecker, primaryKey, actionId);
    }
}
\end{verbatim}
\end{enumerate}

This class is almost identical to \texttt{GuestbookPermission}. The only
difference is that \texttt{EntryPermission} is for the \texttt{Entry}
entity.

Now that you have these classes, you must build services and export the
permissions package so that other modules can access it. Follow these
steps to do so:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Save the permissions helper classes you just created. From the Gradle
  Tasks panel on the right side of Liferay @ide@, run
  \texttt{buildService} from the \texttt{guestbook-service} module's
  \texttt{build} folder.
\item
  In the Project Explorer, open the \texttt{bnd.bnd} file from the root
  folder of the \texttt{guestbook-service} module.
\item
  In the graphical view, under the \emph{Export Packages} section, click
  the plus button to add an export.
\item
  Select \texttt{com.liferay.docs.guestbook.service.permission} and
  click \texttt{OK}.
\item
  Save the file.
\end{enumerate}

Congratulations! You've now created helper classes for your permissions.
The only thing left is to implement permission checks in the
application's view layer. You'll do this next.

\section{Permissions in JSPs}\label{permissions-in-jsps}

\begin{verbatim}
<p>Implementing Permissions<br>Step 4 of 4</p>
\end{verbatim}

User interface components can be wrapped in permission checks pretty
easily. In this step, you'll learn how.

First go to the \texttt{init.jsp} in your \texttt{guestbook-web}
project. Add the following imports to the file:

\begin{verbatim}
<%@ page import="com.liferay.docs.guestbook.service.permission.GuestbookModelPermission" %>
<%@ page import="com.liferay.docs.guestbook.service.permission.GuestbookPermission" %>
<%@ page import="com.liferay.docs.guestbook.service.permission.EntryPermission" %>
<%@ page import="com.liferay.portal.kernel.util.WebKeys" %>
<%@ page import="com.liferay.portal.kernel.security.permission.ActionKeys" %>
\end{verbatim}

The first three are the permissions helper classes you just created. Now
it's time to implement permission checks.

\subsection{Checking Permissions in the
UI}\label{checking-permissions-in-the-ui}

Recall that you want to restrict access to three areas in your
application:

\begin{itemize}
\tightlist
\item
  The guestbook tabs across the top of your application
\item
  The Add Guestbook button
\item
  The Add Entry button
\end{itemize}

First, you'll create the guestbook tabs and check permissions for them.
Follow these steps to do so:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open \texttt{/guestbookwebportlet/view.jsp} and find the scriptlet
  that gets the \texttt{guestbookId} from the request. Just below this,
  add the following code:

\begin{verbatim}
<aui:nav cssClass="nav-tabs">

    <%
        List<Guestbook> guestbooks = GuestbookLocalServiceUtil.getGuestbooks(scopeGroupId);

            for (int i = 0; i < guestbooks.size(); i++) {

                Guestbook curGuestbook = (Guestbook) guestbooks.get(i);
                String cssClass = StringPool.BLANK;

                if (curGuestbook.getGuestbookId() == guestbookId) {
                    cssClass = "active";
                }

                if (GuestbookPermission.contains(
                    permissionChecker, curGuestbook.getGuestbookId(), "VIEW")) {

    %>

    <portlet:renderURL var="viewPageURL">
        <portlet:param name="mvcPath" value="/guestbookwebportlet/view.jsp" />
        <portlet:param name="guestbookId"
            value="<%=String.valueOf(curGuestbook.getGuestbookId())%>" />
    </portlet:renderURL>


    <aui:nav-item cssClass="<%=cssClass%>" href="<%=viewPageURL%>"
        label="<%=HtmlUtil.escape(curGuestbook.getName())%>" />

    <%  
                }

            }
    %>

</aui:nav>
\end{verbatim}

  This code gets a list of guestbooks from the database, iterates
  through them, checks the permission for each against the current
  user's roles, and adds the guestbooks the user can access to a list of
  tabs.

  You've now implemented your first permission check. As you can see,
  it's relatively straightforward thanks to the static methods in your
  helper classes. The code above shows the tab only if the current user
  has the \texttt{VIEW} permission for the guestbook.

  Next, you'll add permission checks to the Add Entry button.
\item
  Scroll down to the line that reads
  \texttt{\textless{}aui:button-row\ cssClass="guestbook-buttons"\textgreater{}}.
  Just below this line, add the following line of code to check for the
  \texttt{ADD\_ENTRY} permission:

\begin{verbatim}
<c:if test='<%= GuestbookPermission.contains(permissionChecker, guestbookId, "ADD_ENTRY") %>'>
\end{verbatim}
\item
  After this is the code that creates the \texttt{addEntryURL} and the
  Add Entry button. After the \texttt{aui:button} tag and above the
  \texttt{\textless{}/aui:button-row\textgreater{}} tag, add the closing
  tag for the \texttt{\textless{}c:if\textgreater{}} statement:

\begin{verbatim}
</c:if>
\end{verbatim}

  You've now implemented your permission check for the Add Entry button
  by using JSTL tags.
\end{enumerate}

Next, you'll implement an \texttt{entry\_actions.jsp} that's much like
the one in the Guestbook Admin portlet. This will determine what options
appear for logged in users who can see the actions menu in the portlet.
Just like before, you'll wrap each \texttt{renderURL} in a \texttt{if}
statement that checks the permissions against available actions. To do
this, follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In \texttt{src/main/resources/META-INF/resources/guestbookwebportlet},
  create a file called \texttt{entry\_actions.jsp}.
\item
  In this file, add the following code:

\begin{verbatim}
<%@include file="../init.jsp"%>

<%
String mvcPath = ParamUtil.getString(request, "mvcPath");

ResultRow row = (ResultRow)request.getAttribute(WebKeys.SEARCH_CONTAINER_RESULT_ROW);

Entry entry = (Entry)row.getObject(); 
%>

<liferay-ui:icon-menu>

    <portlet:renderURL var="viewEntryURL">
        <portlet:param name="entryId" value="<%= String.valueOf(entry.getEntryId()) %>" />
        <portlet:param name="mvcPath" value="/guestbookwebportlet/view_entry.jsp" />
    </portlet:renderURL>

    <liferay-ui:icon
        message="View"
        url="<%= viewEntryURL.toString() %>"
    />

    <c:if
        test="<%= EntryPermission.contains(permissionChecker, entry.getEntryId(), ActionKeys.UPDATE) %>">
        <portlet:renderURL var="editURL">
            <portlet:param name="entryId"
                value="<%= String.valueOf(entry.getEntryId()) %>" />
            <portlet:param name="mvcPath" value="/guestbookwebportlet/edit_entry.jsp" />
        </portlet:renderURL>

        <liferay-ui:icon image="edit" message="Edit"
            url="<%=editURL.toString() %>" />
    </c:if>

    <c:if
    test="<%=EntryPermission.contains(permissionChecker, entry.getEntryId(), ActionKeys.PERMISSIONS) %>">

        <liferay-security:permissionsURL
            modelResource="<%= Entry.class.getName() %>"
            modelResourceDescription="<%= entry.getMessage() %>"
            resourcePrimKey="<%= String.valueOf(entry.getEntryId()) %>"
            var="permissionsURL" />

        <liferay-ui:icon image="permissions" url="<%= permissionsURL %>" />

    </c:if>

    <c:if
        test="<%=EntryPermission.contains(permissionChecker, entry.getEntryId(), ActionKeys.DELETE) %>">

        <portlet:actionURL name="deleteEntry" var="deleteURL">
            <portlet:param name="entryId"
                value="<%= String.valueOf(entry.getEntryId()) %>" />
            <portlet:param name="guestbookId"
                value="<%= String.valueOf(entry.getGuestbookId()) %>" />
        </portlet:actionURL>

        <liferay-ui:icon-delete url="<%=deleteURL.toString() %>" />
    </c:if>

</liferay-ui:icon-menu>
\end{verbatim}

  This code defines several action buttons for viewing, updating,
  setting permissions on, and deleting entities. Each button is
  protected by a permissions check. If the current user can't perform
  the given action, the action doesn't appear.
\item
  Finally, in \texttt{view.jsp}, you must add the
  \texttt{entry\_actions.jsp} as the last column in the Search
  Container. Find the line defining the Search Container row. It looks
  like this:

\begin{verbatim}
<liferay-ui:search-container-row
    className="com.liferay.docs.guestbook.model.Entry" modelVar="entry">
\end{verbatim}

  Below that line are two columns. After the second column, add a third:

\begin{verbatim}
<liferay-ui:search-container-column-jsp path="/guestbookwebportlet/entry_actions.jsp" align="right" />
\end{verbatim}
\item
  Save all JSP files.
\end{enumerate}

Excellent! You've now implemented all the permissions checks for the
Guestbook portlet.

When testing the application, remember that any guestbook entries you
created without resources won't work with permissions. Add new
guestbooks and entries to test your application with different users.
Administrative users see all the buttons, regular users see the Add
Entry button, and guests see no buttons at all (but can navigate).

\noindent\hrulefill

\textbf{Note:} You may see an error where the Guestbook portlet doesn't
appear at all, and you see this error in the log:

\begin{verbatim}
 Someone may be trying to circumvent the permission checker.
\end{verbatim}

This is because any data you currently have in the Guestbook application
doesn't have resources. In this case, you must drop and re-create your
database. To do this, find your Liferay Workspace on your file system
(it should be inside your Eclipse workspace). Inside the
\texttt{bundles/data} folder is a \texttt{hypersonic} folder. Shut down
Liferay DXP, remove everything from this folder, and then restart. After
adding guestbook to a page, the portlet will work normally.

\noindent\hrulefill

Now see if you can do the same for the Guestbook Admin portlet. Don't
worry if you can't: at the end of this Learning Path is a link to the
completed project for you to examine.

Great! You're all done with permissions. The next step is to integrate
search and indexing into your application. This is a prerequisite for
the much more powerful stuff to come.

\chapter{Displaying Messages and
Errors}\label{displaying-messages-and-errors}

When users interact with your application, they perform tasks it
defines, like saving or editing things. The Guestbook application is no
different. Your application should also provide feedback on these
operations so users can know if they worked. Up to now, you've been
placing this information in logs that only administrators can access.
Wouldn't it be better to show users these messages?

That's exactly what you'll do next, in three steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Create language keys for your messages.
\item
  Add the error messages to your action methods.
\item
  Report those error messages in your JSPs.
\end{enumerate}

Ready to get started?

Let's Go!{}

\section{Creating Language Keys}\label{creating-language-keys}

\begin{verbatim}
<p>Displaying Messages and Errors<br>Step 1 of 3</p>
\end{verbatim}

Any modern application should place its messages and form field labels
in a language keys file that can be duplicated and then translated into
multiple languages. Here, you'll learn how to provide a \emph{default}
set of English language keys for your application. For more information
on language keys and providing automatically translated language keys,
\href{/docs/7-0/tutorials/-/knowledge_base/t/automatically-generating-language-files}{see
this tutorial}.

Language keys are stored in the \texttt{Language.properties} file
included in your \texttt{guestbook-web} module.
\texttt{Language.properties} is the default, but you can create a number
of translations by appending the ISO-639 language code to the file name
(e.g., \texttt{Language\_en.properties} for English or
\texttt{Language\_de.properties} for German). For now, stick to the
default language keys.

Follow these steps to create your language keys:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open \texttt{/src/main/resources/content/Language.properties} in your
  \texttt{guestbook-web} module. Remove the default keys in this file.
\item
  Paste in the following keys:

\begin{verbatim}
entry-added=Entry added successfully.
entry-deleted=Entry deleted successfully.
guestbook-added=Guestbook added successfully.
guestbook-updated=Guestbook updated successfully.
guestbook-deleted=Guestbook deleted successfully.
\end{verbatim}
\item
  Save the file.
\end{enumerate}

Your messages are now in place, and your application can use them. Next,
you'll add them to your action methods.

\section{Adding Failure and Success
Messages}\label{adding-failure-and-success-messages}

\begin{verbatim}
<p>Displaying Messages and Errors<br>Step 2 of 3</p>
\end{verbatim}

To display correct feedback to users properly, you must edit your
portlet classes to use Liferay DXP's \texttt{SessionMessages} and
\texttt{SessionErrors} classes. These classes collect messages that the
view layer shows to the user by using a simple tag.

You'll add these messages to code that runs when the user triggers a
system function that can succeed or fail, such as creating, editing, or
deleting an entry or guestbook. This generally happens in action
methods. You must update these methods to handle failure and success
states in \texttt{GuestbookPortlet.java} and
\texttt{GuestbookAdminPortlet.java}. Start by updating \texttt{addEntry}
and \texttt{deleteEntry} in \texttt{GuestbookPortlet.java}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Find the \texttt{addEntry} method in \texttt{GuestbookPortlet.java}.
  In the first \texttt{try...catch} block's \texttt{try} section, add a
  success message just before the closing \texttt{\}}:

\begin{verbatim}
SessionMessages.add(request, "entryAdded");
\end{verbatim}

  This uses Liferay's \texttt{SessionMessages} API to add a success
  message whenever a Guestbook is successfully added. It looks up the
  message you placed in the \texttt{Language.properties} file and
  inserts the message for the key \texttt{entry-added} (it automatically
  converts the key to camel case).
\item
  Below that, in the \texttt{catch} block, find the following code:

\begin{verbatim}
System.out.println(e);
\end{verbatim}
\item
  Beneath it, paste this line:

\begin{verbatim}
SessionErrors.add(request, e.getClass().getName());
\end{verbatim}

  Now you not only log the message to the console, you also use the
  \texttt{SessionErrors} object to show the message to the user.
\end{enumerate}

Next, do the same for the \texttt{deleteEntry} method:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  After the logic to delete the entry, add a success message:

\begin{verbatim}
SessionMessages.add(request, "entryDeleted");
\end{verbatim}
\item
  Find the same \texttt{Logger...} block of code in the
  \texttt{deleteEntry} method and after it, paste this line:

\begin{verbatim}
SessionErrors.add(request, e.getClass().getName());
\end{verbatim}
\item
  Hit {[}CTRL{]}+{[}SHIFT{]}+O to import
  \texttt{com.liferay.portal.kernel.servlet.SessionErrors} and
  \texttt{com.liferay.portal.kernel.servlet.SessionMessages}. Save the
  file.
\end{enumerate}

Well done! You've added the messages to \texttt{GuestbookPortlet}. Now
you must update \texttt{GuestbookAdminPortlet.java}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open \texttt{GuestbookAdminPortlet.java} and look for the same cues.
\item
  Add the appropriate success messages to the \texttt{try} section of
  the \texttt{try...catch} in \texttt{addGuestbook},
  \texttt{updateGuestbook}, and \texttt{deleteGuestbook}, respectively:

\begin{verbatim}
 SessionMessages.add(request, "guestbookAdded");

 SessionMessages.add(request, "guestbookUpdated");

 SessionMessages.add(request, "guestbookDeleted");
\end{verbatim}
\item
  In the \texttt{catch} section of those same methods, find
  \texttt{Logger.getlogger...} and paste the \texttt{SessionErrors}
  block beneath it:

\begin{verbatim}
SessionErrors.add(request, pe.getClass().getName());
\end{verbatim}
\item
  Hit {[}CTRL{]}+{[}SHIFT{]}+O to import \texttt{SessionErrors} and
  \texttt{SessionMessages}. Save the file.
\end{enumerate}

Great! The controller now makes relevant and detailed feedback
available. Now all you need to do is publish this feedback in the view
layer.

\section{Adding Messages to JSPs}\label{adding-messages-to-jsps}

\begin{verbatim}
<p>Displaying Messages and Errors<br>Step 3 of 3</p>
\end{verbatim}

Any messages the user should see are now stored in either
\texttt{SessionMessages} or \texttt{SessionErrors}. Next, you'll make
these messages appear in your JSPs.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In the \texttt{guestbook-web} module, open
  \texttt{guestbookwebportlet/view.jsp}. Add the following block of
  success messages to the top of the file, just below the
  \texttt{init.jsp} include statement:

\begin{verbatim}
<liferay-ui:success key="entryAdded" message="entry-added" />
<liferay-ui:success key="guestbookAdded" message="guestbook-added" />
<liferay-ui:success key="entryDeleted" message="entry-deleted" />
\end{verbatim}

  This tag accesses what's stored in \texttt{SessionMessages}. It has
  two attributes. The first is the \texttt{SessionMessages} key that you
  provided in the \texttt{GuestbookPortlet.java} class's add and delete
  methods. The second looks up the specified key in the
  \texttt{Language.properties} file. You could have specified a
  hard-coded message here, but it's far better to provide a localized
  key.
\item
  Now open \texttt{guestbookadminportlet/view.jsp}. Add the following
  block of success messages in the same spot below the include:

\begin{verbatim}
<liferay-ui:success key="guestbookAdded" message="guestbook-added" />
<liferay-ui:success key="guestbookUpdated" message="guestbook-updated" />
<liferay-ui:success key="guestbookDeleted" message="guestbook-deleted" />
\end{verbatim}

  Note that one of the \texttt{message} values is the same for both
  portlets. There's no need to write redundant messages--language keys
  are reusable.
\end{enumerate}

\begin{figure}
\centering
\includegraphics{./images/message-complete.png}
\caption{Now the message will display the value you specified in
\texttt{Language.properties}.}
\end{figure}

Congratulations! You've added useful feedback for operations in your
application. Next, you'll add permission checking for your guestbooks
and entries.

\chapter{Leveraging Search}\label{leveraging-search}

Now you have working Guestbook and Guestbook Admin portlets. The
Guestbook portlet lets users add, edit, delete, and configure
permissions for guestbook entries. The Guestbook Admin portlet lets site
administrators create, edit, delete, and configure permissions for
guestbooks. In the case of a very popular event (maybe a \emph{Lunar
Luau} dinner at the Lunar Resort), there could be many guestbook entries
in the portlet, and users might want to search for entries that
mentioned the delicious low-gravity ham that was served (melts in your
mouth). Searching for the word \emph{ham} should display these entries.
In short, guestbook entries must be searchable via a search bar in the
Guestbook portlet.

To enable search, you'll add an indexer for guestbooks and their
entries. Although you probably won't have enough guestbooks in a site to
warrant searching the Guestbook Admin portlet, creating a guestbook
indexer has other benefits. In a later section, you'll asset-enable
guestbooks and guestbook entries so Liferay DXP's Asset Publisher can
display them. Enabling search is a prerequisite for this--you must index
any entity that you want to make an asset.

But assets are for later. Right now it's time to create those indexers.
Ready?

\begin{figure}
\centering
\includegraphics{./images/guestbook-portlet-search.png}
\caption{You'll add a search bar to the Guestbook portlet so that users
can search for guestbook entries. If a guestbook entry's message or name
matches the search query, the entry is displayed in the search results.}
\end{figure}

Let's Go!{}

\chapter{Enabling Search and Indexing for
Guestbooks}\label{enabling-search-and-indexing-for-guestbooks}

In this section, you first create an indexer for guestbooks. You then
modify the service layer to use this indexer to update the search index
when a guestbook is persisted:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a \texttt{GuestbookIndexer} class that extends Liferay's
  \texttt{BaseIndexer} abstract class.
\item
  Update \texttt{GuestbookLocalServiceImpl}'s \texttt{addGuestbook},
  \texttt{updateGuestbook}, and \texttt{deleteGuestbook} methods to
  invoke the guestbook indexer.
\end{enumerate}

Since there's no reason to search for guestbooks in the UI, only the
back-end work is necessary.

Let's Go!{}

\section{Understanding Search and
Indexing}\label{understanding-search-and-indexing}

\begin{verbatim}
<p>Enabling Search and Indexing for Guestbooks<br>Step 1 of 3</p>
\end{verbatim}

By default, Liferay DXP uses Elasticsearch, a search engine backed by
the popular Lucene search library, to implement its search and indexing
functionality. To avoid the resource-hogging table merges necessary to
search the database, using a search engine like Elasticsearch lets you
convert searchable entities into \emph{documents}. In Elasticsearch,
documents are searchable database entities converted into JSON objects.
After you implement an indexer for guestbook entries, Liferay DXP
creates a document for each entry. This indexer specifies which
guestbook entry fields to add to each guestbook entry document. All the
guestbook entry documents are then added to an index. When the index is
searched, a \emph{hits} object is returned that contains pointers to the
documents matching the search query. Searching for entities with a
search engine via an index is faster than searching for entities in the
database. Elasticsearch provides some additional features like relevancy
scoring and fuzzy search queries.

Along with the search engine, Liferay DXP has its own search
infrastructure. Liferay DXP adds to the existing Elasticsearch API for a
few reasons:

\begin{itemize}
\tightlist
\item
  To ensure indexed documents include the fields needed by Liferay DXP
  (e.g., \texttt{entryClassName}, \texttt{entryClassPK},
  \texttt{assetTagNames}, \texttt{assetCategories}, \texttt{companyId},
  \texttt{groupId}, staging status).
\item
  To ensure the scope of returned search results is appropriate by
  applying the right filters to search requests.
\item
  To provide permission checking and hit summaries to display in the
  search portlet.
\end{itemize}

Next, you'll create the indexer for guestbooks.

\section{Creating a Guestbook
Indexer}\label{creating-a-guestbook-indexer}

\begin{verbatim}
<p>Enabling Search and Indexing for Guestbooks<br>Step 2 of 3</p>
\end{verbatim}

First, update your \texttt{build.gradle} to have all of the necessary
imports.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open the \texttt{build.gradle} file in your \texttt{guestbook-service}
  project.
\item
  Add the following line below the other imports:

\begin{verbatim}
compileOnly group: "com.liferay", name: "com.liferay.registry.api", version: "1.0.0"
compileOnly group: "javax.portlet", name: "portlet-api", version: "2.0"
compileOnly group: "javax.servlet", name: "javax.servlet-api", version: "3.0.1"
\end{verbatim}
\item
  Save the file and run \texttt{Refresh\ Gradle\ Project}.
\end{enumerate}

Now that you have the additional dependencies configured, follow these
steps to create the indexer for guestbooks:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a new package in the \texttt{guestbook-service} module
  project's \texttt{src/main/java} folder called
  \texttt{com.liferay.docs.guestbook.search}. In this package, create a
  new class called \texttt{GuestbookIndexer} that extends
  \texttt{com.liferay.portal.kernel.search.BaseIndexer} with
  \texttt{Guestbook} as a type argument. Add an \texttt{@Component}
  annotation to declare that the \texttt{GuestbookIndexer} class
  provides an implementation of the \texttt{Indexer} service. Also,
  define the \texttt{CLASS\_NAME} variable by getting the name of the
  \texttt{Guestbook} model class. This is necessary to override the
  \texttt{getClassName} method from \texttt{BaseIndexer}. Liferay DXP
  uses this method to determine the object this Indexer indexes:

\begin{verbatim}
@Component(
    immediate = true,
    service = Indexer.class
)
public class GuestbookIndexer extends BaseIndexer<Guestbook> {

    public static final String CLASS_NAME = Guestbook.class.getName();
}
\end{verbatim}
\item
  Add the \texttt{GuestbookIndexer} constructor:

\begin{verbatim}
public GuestbookIndexer() {
    setDefaultSelectedFieldNames(
        Field.ASSET_TAG_NAMES, Field.COMPANY_ID, Field.CONTENT,
        Field.ENTRY_CLASS_NAME, Field.ENTRY_CLASS_PK, Field.GROUP_ID,
        Field.MODIFIED_DATE, Field.SCOPE_GROUP_ID, Field.TITLE, Field.UID);
    setPermissionAware(true);
    setFilterSearch(true);
}
\end{verbatim}

  This constructor does several things:

  \begin{itemize}
  \tightlist
  \item
    Sets the default selected field names. These fields are used to
    retrieve results documents from the search engine.
  \item
    Sets the default selected localized field names. This ensures that
    the localized version of the field is searched and returned.
  \item
    Makes the search results permissions-aware at search time, as well
    as in the index. Without this, a search query returns \emph{all}
    matching guestbooks regardless of the user's permissions on the
    resource.
  \item
    Sets filter search to \texttt{true}, enabling a document-by-document
    check of the search results' \texttt{VIEW} permissions. This is
    redundant most of the time, but safeguards against unexpected
    problems like the search index becoming stale, or if permission
    inheritance doesn't happen fast enough. Most of Liferay DXP's
    internal apps use this setting. If not set, the indexer relies on
    the permissions information indexed in the search engine.
  \end{itemize}
\item
  Since you extend the abstract class \texttt{BaseIndexer} instead of
  implementing the \texttt{Indexer} interface directly, you must
  override its abstract methods. In the \texttt{getClassName} method,
  return the \texttt{CLASS\_NAME} constant defined at the top of the
  class:

\begin{verbatim}
@Override
public String getClassName() {
    return CLASS_NAME;
}
\end{verbatim}

  This returns \texttt{com.liferay.docs.guestbook.model.Guestbook}.
\item
  Next, you must override \texttt{hasPermission}. Call the
  \texttt{contains} method of the \texttt{GuestbookPermission} helper
  class that you created in an earlier Learning Path section:

\begin{verbatim}
@Override
public boolean hasPermission(
        PermissionChecker permissionChecker, String entryClassName, 
        long entryClassPK, String actionId) 
    throws Exception {

    return GuestbookPermission.contains(
        permissionChecker, entryClassPK, ActionKeys.VIEW);
}
\end{verbatim}

  Here, you ensure that the \texttt{VIEW} permission on guestbooks can
  be used to find and display appropriate search results.
\item
  Override the \texttt{postProcessContextBooleanFilter} method:

\begin{verbatim}
@Override
public void postProcessContextBooleanFilter(
        BooleanFilter contextBooleanFilter, SearchContext searchContext)
throws Exception {
    addStatus(contextBooleanFilter, searchContext);
}
\end{verbatim}

  This method is invoked while the main search query is being
  constructed. The base implementation of \texttt{addStatus} in
  \texttt{BaseIndexer} adds the workflow status to the filter. This
  ensures that entities with the status \texttt{STATUS\_IN\_TRASH}
  aren't added to the query. You'll learn more about workflow later.
\item
  Override \texttt{postProcessSearchQuery} to add clauses to the ongoing
  search query. It's best to add the localized value of any full text
  fields that might contribute to search relevance. By specifying the
  localized search term, you ensure that the regular search term has the
  locale appended (e.g., \texttt{title\_en\_US}). For the guestbook
  entity, add the title field (\texttt{Field.TITLE}):

\begin{verbatim}
@Override
public void postProcessSearchQuery(
    BooleanQuery searchQuery, BooleanFilter fullQueryBooleanFilter,
    SearchContext searchContext)
    throws Exception {

    addSearchLocalizedTerm(searchQuery, searchContext, Field.TITLE, false);
}
\end{verbatim}
\item
  Override the \texttt{doDelete()} method, which deletes the document
  corresponding to the \texttt{Guestbook} object parameter. Call
  \texttt{BaseIndexer}'s \texttt{deleteDocument} method with the
  guestbook's company ID and guestbook ID:

\begin{verbatim}
@Override
protected void doDelete(Guestbook guestbook) throws Exception {
    deleteDocument(guestbook.getCompanyId(), guestbook.getGuestbookId());
}
\end{verbatim}
\item
  Implement the \texttt{doGetDocument} method to select the entity's
  fields to build a search document that's indexed by the search engine.
  The main searchable field for guestbooks is the guestbook name, which
  is stored in a guestbook search document's title field:

\begin{verbatim}
@Override
protected Document doGetDocument(Guestbook guestbook)
    throws Exception {

    Document document = getBaseModelDocument(CLASS_NAME, guestbook);

    document.addDate(Field.MODIFIED_DATE, guestbook.getModifiedDate());

    Locale defaultLocale =
        PortalUtil.getSiteDefaultLocale(guestbook.getGroupId());
    String localizedField = LocalizationUtil.getLocalizedName(
        Field.TITLE, defaultLocale.toString());

    document.addText(localizedField, guestbook.getName());
    return document;
}
\end{verbatim}

  Because Liferay DXP supports localization, you should too. The above
  code gets the default locale from the site by passing the
  \texttt{Guestbook}'s group ID to the \texttt{getSiteDefaultLocale}
  method, then using it to get the localized name of the guestbook's
  title field. The retrieved site locale is appended to the field (e.g.,
  \texttt{title\_en\_US}), so the field gets passed to the search engine
  and goes through the right analysis and
  \href{https://www.elastic.co/guide/en/elasticsearch/reference/2.4/analysis-tokenizers.html}{tokenization}.
\item
  Implement the \texttt{doGetSummary} method to return a \emph{summary}.
  A summary is a condensed, text-based version of the entity that can be
  displayed generically. You create it by combining key parts of the
  entity's data so users can browse through search results to find the
  entity they want. Call \texttt{BaseIndexer}'s \texttt{createSummary}
  method, then use \texttt{summary.setMaxContentLength} to set the
  summary content's maximum size. Most Liferay DXP applications use a
  value of \texttt{200}, so it's a good idea to use the same to ensure
  uniform result summaries:

\begin{verbatim}
@Override
protected Summary doGetSummary(
    Document document, Locale locale, String snippet,
    PortletRequest portletRequest, PortletResponse portletResponse) {

    Summary summary = createSummary(document);
    summary.setMaxContentLength(200);
    return summary;
}
\end{verbatim}
\item
  Override the overloaded \texttt{doReindex} method, which gets called
  when an entity is updated or a user explicitly triggers a reindex. The
  first \texttt{doReindex} method takes a single object argument.
  Retrieve the associated document with \texttt{BaseIndexer}'s
  \texttt{getDocument} method, then invoke \texttt{IndexWriterHelper}'s
  \texttt{updateDocument} method to update (reindex) the document:

\begin{verbatim}
@Override
protected void doReindex(Guestbook guestbook)
    throws Exception {

    Document document = getDocument(guestbook);
    indexWriterHelper.updateDocument(
        getSearchEngineId(), guestbook.getCompanyId(), document,
        isCommitImmediately());
}
\end{verbatim}
\item
  The second \texttt{doReindex} method takes two arguments: a
  \texttt{className} string, and a \texttt{classPK} long. In this
  method, you retrieve the guestbook corresponding to the primary key by
  calling \texttt{GuestbookLocalService}'s \texttt{getGuestbook} method,
  passing in the \texttt{classPK} parameter. Then pass the guestbook to
  the first \texttt{doReindex} method (see above):

\begin{verbatim}
@Override
protected void doReindex(String className, long classPK)
    throws Exception {

    Guestbook guestbook = _guestbookLocalService.getGuestbook(classPK);
    doReindex(guestbook);
}
\end{verbatim}
\item
  The third (and final) \texttt{doReindex} method indexes all entities
  in the current Liferay DXP instance (\texttt{companyId}). It takes a
  string array (\texttt{ids}) as an argument.
  \texttt{GetterUtil.getLong(ids{[}0{]})} retrieves the first string in
  the array, casts it to a \texttt{long}, stores it in a
  \texttt{companyId} variable, and passes it as an argument to the
  \texttt{reindexGuestbooks} helper method:

\begin{verbatim}
@Override
protected void doReindex(String[] ids)
    throws Exception {

    long companyId = GetterUtil.getLong(ids[0]);
    reindexGuestbooks(companyId);
}
\end{verbatim}
\item
  To reindex guestbooks, provide the helper method
  \texttt{reindexGuestbooks}. In this method, use an actionable dynamic
  query helper method to retrieve all the guestbooks in the Liferay DXP
  instance. Service Builder generated this query method for you when you
  built the services. Each guestbook's document is then retrieved and
  added to a collection:

\begin{verbatim}
protected void reindexGuestbooks(long companyId)
  throws PortalException {

  final IndexableActionableDynamicQuery indexableActionableDynamicQuery =
    _guestbookLocalService.getIndexableActionableDynamicQuery();

  indexableActionableDynamicQuery.setCompanyId(companyId);

  indexableActionableDynamicQuery.setPerformActionMethod(

    new ActionableDynamicQuery.PerformActionMethod<Guestbook>() {
      @Override
      public void performAction(Guestbook guestbook) {
        try {
          Document document = getDocument(guestbook);
          indexableActionableDynamicQuery.addDocuments(document);
        }
        catch (PortalException pe) {
          if (_log.isWarnEnabled()) {
            _log.warn(
              "Unable to index guestbook " +
                guestbook.getGuestbookId(),
              pe);
          }
        }
      }
    });
  indexableActionableDynamicQuery.setSearchEngineId(getSearchEngineId());
  indexableActionableDynamicQuery.performActions();
}
\end{verbatim}
\item
  Get the log for the guestbook model and add the necessary service
  references at the bottom of the file:

\begin{verbatim}
private static final Log _log =
  LogFactoryUtil.getLog(GuestbookIndexer.class);

@Reference
protected IndexWriterHelper indexWriterHelper;

@Reference
private GuestbookLocalService _guestbookLocalService;
\end{verbatim}
\item
  Organize your imports ({[}CTRL{]}+{[}SHIFT{]}+O), and save the file.
  It will have errors.
\item
  Export the \texttt{com.liferay.docs.guestbook.search} package in the
  \texttt{guestbook-service} module's \texttt{bnd.bnd} file. The export
  section should look like this:

\begin{verbatim}
Export-Package:
  com.liferay.docs.guestbook.service.permission,\
  com.liferay.docs.guestbook.search
\end{verbatim}
\end{enumerate}

The guestbook indexer class is complete! Next, you can update the
service layer.

\section{Handling Indexing in the Guestbook Service
Layer}\label{handling-indexing-in-the-guestbook-service-layer}

\begin{verbatim}
<p>Enabling Search and Indexing for Guestbooks<br>Step 3 of 3</p>
\end{verbatim}

Whenever a guestbook database entity is added, updated, or deleted, the
search index must be updated accordingly. The Liferay DXP annotations
\texttt{@Indexable} and \texttt{@IndexableType} mark your service
methods so documents can be updated or deleted. You must update the
\texttt{addGuestbook}, \texttt{updateGuestbook}, and
\texttt{deleteGuestbook} service methods with these annotations.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open \texttt{GuestbookLocalServiceImpl} in the
  \texttt{guestbook-service} module's
  \texttt{com.liferay.docs.guestbook.service.impl} package, and add the
  following annotation above the method signature for the
  \texttt{addGuestbook} and \texttt{updateGuestbook} methods:

\begin{verbatim}
@Indexable(type = IndexableType.REINDEX)
public Guestbook addGuestbook(...)

@Indexable(type = IndexableType.REINDEX)
public Guestbook updateGuestbook(...)
\end{verbatim}

  The \texttt{@Indexable} annotation indicates that an index update is
  required following the method execution. The \texttt{GuestbookIndexer}
  controls exactly how the indexing happens. Setting the
  \texttt{@Indexable} annotation type to \texttt{IndexableType.REINDEX}
  updates the document in the index that corresponds to the updated
  guestbook.
\item
  Add the following annotation above the method signature for the
  \texttt{deleteGuestbook} method:

\begin{verbatim}
@Indexable(type = IndexableType.DELETE)
public Guestbook deleteGuestbook(...)
\end{verbatim}

  When a guestbook is deleted from the database, its document shouldn't
  remain in the search index. This ensures that it is deleted.
\item
  Add the necessary imports:

\begin{verbatim}
import com.liferay.portal.kernel.search.Indexable;
import com.liferay.portal.kernel.search.IndexableType;
\end{verbatim}

  Save the file.
\item
  In the Gradle Tasks pane on the right-hand side of Liferay @ide@,
  double-click \texttt{buildService} in \texttt{guestbook-service} →
  \texttt{build}. This re-runs Service Builder to incorporate your
  changes to \texttt{GuestbookLocalServiceImpl}.
\end{enumerate}

Great! Next, you'll enable search and indexing for guestbook entries.

\chapter{Enabling Search and Indexing for Guestbook
Entries}\label{enabling-search-and-indexing-for-guestbook-entries}

Enabling search for guestbook entries in the Guestbook portlet takes two
steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create an \texttt{EntryIndexer} class that extends Liferay DXP's
  \texttt{BaseIndexer} abstract class.
\item
  Update \texttt{EntryLocalServiceImpl}'s \texttt{addEntry} and
  \texttt{deleteEntry} methods to invoke the guestbook entry indexer.
\end{enumerate}

When you finish, all the back-end search and indexing work for both
entities will be complete, leaving only the UI changes to complete.

Let's Go!{}

\section{Creating an Entry Indexer}\label{creating-an-entry-indexer}

\begin{verbatim}
<p>Enabling Search and Indexing for Guestbook Entries<br>Step 1 of 2</p>
\end{verbatim}

The \texttt{EntryIndexer} class you'll complete here is very similar to
the \texttt{GuestbookIndexer} class you completed in the previous
section. Therefore, the instructions here only point out differences
between the indexing of guestbooks and entries.

Follow these steps to create the entry indexer:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In the \texttt{com.liferay.docs.guestbook.search} package of your
  \texttt{guestbook-service} module project's \texttt{src/main/java}
  folder, create a new\\
  class called \texttt{EntryIndexer} that extends
  \texttt{com.liferay.portal.kernel.search.BaseIndexer}. Replace the
  default contents of \texttt{EntryIndexer.java} with the following
  code:

\begin{verbatim}
package com.liferay.docs.guestbook.search;

@Component(immediate = true, service = Indexer.class)
public class EntryIndexer extends BaseIndexer<Entry> {

    public static final String CLASS_NAME = Entry.class.getName();

    public EntryIndexer() {

        setDefaultSelectedFieldNames(
            Field.COMPANY_ID, Field.ENTRY_CLASS_NAME, Field.ENTRY_CLASS_PK,
            Field.UID, Field.SCOPE_GROUP_ID, Field.GROUP_ID);
        setDefaultSelectedLocalizedFieldNames(Field.TITLE, Field.CONTENT);
        setFilterSearch(true);
        setPermissionAware(true);
    }

    @Override
    public String getClassName() {

        return CLASS_NAME;
    }

    @Override
    public boolean hasPermission(
        PermissionChecker permissionChecker, String entryClassName,
        long entryClassPK, String actionId)
        throws Exception {

        return EntryPermission.contains(
            permissionChecker, entryClassPK, ActionKeys.VIEW);
    }

    @Override
    public void postProcessContextBooleanFilter(
        BooleanFilter contextBooleanFilter, SearchContext searchContext)
        throws Exception {

        addStatus(contextBooleanFilter, searchContext);
    }

    @Override
    public void postProcessSearchQuery(
        BooleanQuery searchQuery, BooleanFilter fullQueryBooleanFilter,
        SearchContext searchContext)
        throws Exception {

        addSearchLocalizedTerm(searchQuery, searchContext, "guestbookName", false);
        addSearchLocalizedTerm(searchQuery, searchContext, Field.TITLE, false);
        addSearchLocalizedTerm(searchQuery, searchContext, Field.CONTENT, false);
    }

    @Override
    protected void doDelete(Entry entry)
        throws Exception {

        deleteDocument(entry.getCompanyId(), entry.getEntryId());
    }

    @Override
    protected Document doGetDocument(Entry entry)
        throws Exception {

        Document document = getBaseModelDocument(CLASS_NAME, entry);
        document.addDate(Field.MODIFIED_DATE, entry.getModifiedDate());
        document.addText("email", entry.getEmail());

        Locale defaultLocale =
            PortalUtil.getSiteDefaultLocale(entry.getGroupId());
        String localizedTitle = LocalizationUtil.getLocalizedName(
            Field.TITLE, defaultLocale.toString());
        String localizedMessage = LocalizationUtil.getLocalizedName(
            Field.CONTENT, defaultLocale.toString());

        document.addText(localizedTitle, entry.getName());
        document.addText(localizedMessage, entry.getMessage());

        long guestbookId = entry.getGuestbookId();
        Guestbook guestbook = _guestbookLocalService.getGuestbook(guestbookId);
        String guestbookName= guestbook.getName();
        String localizedGbName = LocalizationUtil.getLocalizedName(
            "guestbookName", defaultLocale.toString());

        document.addText(localizedGbName, guestbookName);

        return document;
    }
\end{verbatim}

  This is not all the code, but it contains the heart of the
  functionality: the \texttt{doGetDocument} method and its helper
  methods. The email, date, localized title, and message fields (based
  on the site's default language) are indexed. Finally, you get the
  entry's guestbook and index the localized version of the
  \texttt{guestbookName} field. Always support localization where
  possible--this ensures your entities are searchable in any language.
\item
  The rest of the code is very similar to the \texttt{GuestbookIndexer}.
  Paste in the following code to finish the entry indexer class:

\begin{verbatim}
    @Override
    protected Summary doGetSummary(
        Document document, Locale locale, String snippet,
        PortletRequest portletRequest, PortletResponse portletResponse)
        throws Exception {

        Summary summary = createSummary(document);

        summary.setMaxContentLength(200);

        return summary;
    }

    @Override
    protected void doReindex(Entry entry)
        throws Exception {

        Document document = getDocument(entry);
        indexWriterHelper.updateDocument(
            getSearchEngineId(), entry.getCompanyId(), document,
            isCommitImmediately());
    }

    @Override
    protected void doReindex(String className, long classPK)
        throws Exception {

        Entry entry = _entryLocalService.getEntry(classPK);
        doReindex(entry);
    }

    @Override
    protected void doReindex(String[] ids)
        throws Exception {

        long companyId = GetterUtil.getLong(ids[0]);
        reindexEntries(companyId);
    }

    protected void reindexEntries(long companyId)
        throws PortalException {

        final IndexableActionableDynamicQuery indexableActionableDynamicQuery =
            _entryLocalService.getIndexableActionableDynamicQuery();

        indexableActionableDynamicQuery.setCompanyId(companyId);

        indexableActionableDynamicQuery.setPerformActionMethod(
            new ActionableDynamicQuery.PerformActionMethod<Entry>() {

                @Override
                public void performAction(Entry entry) {

                    try {
                        Document document = getDocument(entry);
                        indexableActionableDynamicQuery.addDocuments(document);
                    }
                    catch (PortalException pe) {
                        if (_log.isWarnEnabled()) {
                            _log.warn(
                                "Unable to index entry " + entry.getEntryId(),
                                pe);
                        }
                    }
                }
            });
        indexableActionableDynamicQuery.setSearchEngineId(getSearchEngineId());
        indexableActionableDynamicQuery.performActions();
    }

    private static final Log _log = LogFactoryUtil.getLog(EntryIndexer.class);

    @Reference
    protected IndexWriterHelper indexWriterHelper;

    @Reference
    private EntryLocalService _entryLocalService;

    @Reference
    private GuestbookLocalService _guestbookLocalService;

}
\end{verbatim}
\end{enumerate}

As with the guestbook, you must update the entry's service layer to
support indexing when its service methods are called. That's your next
step.

\section{Handling Indexing in the Entry Service
Layer}\label{handling-indexing-in-the-entry-service-layer}

\begin{verbatim}
<p>Enabling Search and Indexing for Guestbook Entries<br>Step 2 of 2</p>
\end{verbatim}

Whenever a guestbook entry is added, updated, or deleted, the
corresponding document should also be updated or deleted. A minor update
to each of the \texttt{addEntry}, \texttt{updateEntry}, and
\texttt{deleteEntry} service methods for guestbook entries is all it
takes.

Follow these steps to update the methods:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open \texttt{EntryLocalServiceImpl} in the \texttt{guestbook-service}
  module's \texttt{com.liferay.docs.guestbook.service.impl} package, and
  add the annotation \texttt{@Indexable(type\ =\ IndexableType.REINDEX)}
  above the signature for the \texttt{addEntry} and \texttt{updateEntry}
  methods:

\begin{verbatim}
@Indexable(type = IndexableType.REINDEX)
public Entry addEntry(...)

@Indexable(type = IndexableType.REINDEX)
public Entry updateEntry(...)
\end{verbatim}

  The \texttt{@Indexable} annotation indicates that an index update is
  required following method execution. The \texttt{EntryIndexer}
  controls exactly how the indexing happens. Setting the
  \texttt{@Indexable} annotation's type to
  \texttt{IndexableType.REINDEX} updates the document in the index that
  corresponds to the updated entry.
\item
  Add the \texttt{@Indexable(type\ =\ IndexableType.DELETE)} annotation
  above the signature for the \texttt{deleteEntry} method. The indexable
  type \texttt{IndexableType.DELETE} ensures that the entry is deleted
  from the index:

\begin{verbatim}
@Indexable(type = IndexableType.DELETE)
public Entry deleteEntry(...)
\end{verbatim}
\item
  Add the required imports:

\begin{verbatim}
import com.liferay.portal.kernel.search.Indexable;
import com.liferay.portal.kernel.search.IndexableType;
\end{verbatim}

  Save the file.
\item
  In the Gradle Tasks pane on the right-hand side of Liferay @ide@,
  double-click \texttt{buildService} in \texttt{guestbook-service} →
  \texttt{build}. This re-runs Service Builder to incorporate your
  changes to \texttt{EntryLocalServiceImpl}.
\end{enumerate}

Awesome! Both guestbooks and their entries now have search and indexing
support in the back-end. Next, you'll enable search in the Guestbook
portlet's front-end.

\chapter{Updating Your User Interface For
Search}\label{updating-your-user-interface-for-search}

Updating the Guestbook portlet's user interface for search takes two
steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Update the Guestbook portlet's default view JSP to display a search
  bar for submitting queries.
\item
  Create a new JSP for the Guestbook portlet to display search results.
\end{enumerate}

You'll start by updating the Guestbook portlet's view JSP.

Let's Go!{}

\section{Adding a Search Bar to the Guestbook
Portlet}\label{adding-a-search-bar-to-the-guestbook-portlet}

\begin{verbatim}
<p>Updating Your UI for Search<br>Step 1 of 2</p>
\end{verbatim}

Follow these steps to create the search bar UI for the Guestbook
portlet:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In \texttt{guestbook-web}, open the file
  \texttt{src/main/resources/META-INF/resources/guestbookwebportlet/view.jsp}.
  Add a render URL near the top of the file, just after the scriptlet
  that gets the \texttt{guestbookId} from the request:

\begin{verbatim}
<liferay-portlet:renderURL varImpl="searchURL">
    <portlet:param name="mvcPath" 
    value="/guestbookwebportlet/view_search.jsp" />
</liferay-portlet:renderURL>
\end{verbatim}

  The render URL points to
  \texttt{/guestbookwebportlet/view\_search.jsp} (created in the next
  step). You construct the URL first because you must specify what
  happens when the user submits a search query.
\item
  Right after the render URL, create an AUI form that directs the user
  to the \texttt{view\_search.jsp} page for viewing search results:

\begin{verbatim}
<aui:form action="<%= searchURL %>" method="get" name="fm">
    <liferay-portlet:renderURLParams varImpl="searchURL" />

    <div class="search-form">
        <span class="aui-search-bar">
            <aui:input inlineField="<%= true %>" label="" 
            name="keywords" size="30" title="search-entries" type="text"
            />

            <aui:button type="submit" value="search" />
        </span>
    </div>
</aui:form>
\end{verbatim}

  The tag
  \texttt{\textless{}liferay-portlet:renderURLParams\ varImpl="searchURL"\ /\textgreater{}}
  includes the URL parameters of the \texttt{searchURL} as hidden input
  fields in the AUI form. This is important since the parameters of the
  \texttt{searchURL} are overwritten when the search query is submitted
  as a URL parameter.

  The body of the search form consists of a
  \texttt{\textless{}div\textgreater{}} containing a
  \texttt{\textless{}span\textgreater{}} that contains two elements: the
  search bar and the search button. The
  \texttt{\textless{}aui:input\textgreater{}} tag defines the search
  bar. Its \texttt{name="keywords"} attribute specifies the name of the
  URL parameter that contains the search query. The
  \texttt{\textless{}aui:button\textgreater{}} tag defines the search
  button. The \texttt{type="submit"} attribute specifies that when the
  button is clicked (or the \emph{Enter} key is pressed), the AUI form
  is submitted. The \texttt{value="search"} attribute specifies the name
  that appears on the button.
\end{enumerate}

That's all there is to the search form! When the form is submitted, the
\texttt{mvcPath} parameter pointing to the \texttt{view\_search.jsp} is
included in the URL along with the \texttt{keywords} parameter
containing the search query. Now it's time to create the
\texttt{view\_search.jsp} form to display the search results.

\section{Creating a Search Results JSP for the Guestbook
Portlet}\label{creating-a-search-results-jsp-for-the-guestbook-portlet}

\begin{verbatim}
<p>Updating Your UI for Search<br>Step 2 of 2</p>
\end{verbatim}

There are several design goals to implement in the search results JSP:

\begin{itemize}
\tightlist
\item
  Use a search container to display guestbook entries matching a search
  query.
\item
  Make the Actions button available for each guestbook entry in the
  results, like it is in the main view's search container.
\item
  Include the search bar so that users can edit and resubmit their
  queries without having to click the back link to go to the portlet's
  default view.
\end{itemize}

\begin{figure}
\centering
\includegraphics{./images/guestbook-portlet-search-results.png}
\caption{The search results should appear in a search container, and the
Actions button should appear for each entry. The search bar should also
be displayed.}
\end{figure}

Follow these steps to create the search results JSP:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a new file called \texttt{view\_search.jsp} in your
  \texttt{guestbook-web} module's \texttt{/guestbookwebportlet} folder.
  In this file, include the \texttt{init.jsp}:

\begin{verbatim}
<%@include file="../init.jsp"%>
\end{verbatim}
\item
  Extract the \texttt{keywords} and \texttt{guestbookId} parameters from
  the request. The \texttt{keywords} parameter contains the search
  query, and the \texttt{guestbookId} parameter contains the ID of the
  guestbook being searched:

\begin{verbatim}
<%
  String keywords = ParamUtil.getString(request, "keywords");
  long guestbookId = ParamUtil.getLong(renderRequest, "guestbookId");
%>
\end{verbatim}
\item
  Define the \texttt{searchURL} and \texttt{viewURL} as
  \texttt{renderURL}s. Both use the \texttt{mvcPath} parameter that's
  available to Liferay MVC Portlets:

\begin{verbatim}
<liferay-portlet:renderURL varImpl="searchURL">
        <portlet:param name="mvcPath" 
        value="/guestbookwebportlet/view_search.jsp" />
</liferay-portlet:renderURL>

<portlet:renderURL var="viewURL">
    <portlet:param 
        name="mvcPath" 
        value="/guestbookwebportlet/view.jsp" 
    />
</portlet:renderURL>
\end{verbatim}

  The \texttt{searchURL} points to the current JSP:
  \texttt{view\_search.jsp}. The \texttt{viewURL} points back to the
  Guestbook portlet's main view. These URLs are used in the AUI form
  that you'll create next.
\item
  Add this AUI form:

\begin{verbatim}
<aui:form action="<%= searchURL %>" method="get" name="fm">
    <liferay-portlet:renderURLParams varImpl="searchURL" />

<liferay-ui:header
    backURL="<%= viewURL.toString() %>"
    title="search"
/>

    <div class="search-form">
        <span class="aui-search-bar">
            <aui:input inlineField="<%= true %>" label="" name="keywords" 
            size="30" title="search-entries" type="text" />

            <aui:button type="submit" value="search" />
        </span>
    </div>
</aui:form>
\end{verbatim}

  This form is identical to the one that you added to the Guestbook
  portlet's \texttt{view.jsp}, except that this one contains a
  \texttt{\textless{}liferay-ui:header\textgreater{}} tag that displays
  the Back icon next to the word \emph{Search}. The \texttt{backURL}
  attribute in the header uses the \texttt{viewURL} defined above.
  Submitting the form invokes the \texttt{searchURL} with the user's
  search query added to the URL in the \texttt{keywords} parameter.
\item
  Start a scriptlet to get a search context and set some attributes in
  it:

\begin{verbatim}
<%
    SearchContext searchContext = SearchContextFactory
    .getInstance(request);

    searchContext.setKeywords(keywords);
    searchContext.setAttribute("paginationType", "more");
    searchContext.setStart(0);
    searchContext.setEnd(10);
\end{verbatim}

  To execute a search, you need a \texttt{SearchContext} object.
  \texttt{SearchContextFactory} lets you create a \texttt{SearchContext}
  from the request object. Add the user's search query to the
  \texttt{SearchContext} by passing the \texttt{keywords} URL parameter
  to the \texttt{setKeywords} method. Then specify details about
  pagination and how the search results should be displayed.
\item
  Still in the scriptlet, obtain an \texttt{Indexer} to run a search.
  Retrieve the entry indexer from the map in Liferay DXP's indexer
  registry by passing in the indexer's class or class name:

\begin{verbatim}
Indexer indexer = IndexerRegistryUtil.getIndexer(Entry.class);
\end{verbatim}
\item
  In the same scriptlet, use the indexer and the search context to run a
  search:

\begin{verbatim}
Hits hits = indexer.search(searchContext);

List<Entry> entries = new ArrayList<Entry>();

    for (int i = 0; i < hits.getDocs().length; i++) {
            Document doc = hits.doc(i);

            long entryId = GetterUtil
            .getLong(doc.get(Field.ENTRY_CLASS_PK));

            Entry entry = null;

            try {
                    entry = EntryLocalServiceUtil.getEntry(entryId);
            } catch (PortalException pe) {
                    _log.error(pe.getLocalizedMessage());
            } catch (SystemException se) {
                    _log.error(se.getLocalizedMessage());
            }

            entries.add(entry);
    }
\end{verbatim}

  The search results return as \texttt{Hits} objects containing pointers
  to documents that correspond to guestbook entries. You then loop
  through the hit documents, retrieving the corresponding guestbook
  entries and adding them to a list.
\item
  Finish the scriptlet by retrieving a list of all the guestbooks that
  exist in the current site. Create a map between the guestbook IDs and
  the guestbook names.

\begin{verbatim}
        List<Guestbook> guestbooks = GuestbookLocalServiceUtil.getGuestbooks(scopeGroupId);

        Map<String, String> guestbookMap = new HashMap<String, String>();

        for (Guestbook guestbook : guestbooks) {
                guestbookMap.put(Long.toString(guestbook.getGuestbookId()), guestbook.getName());
        }
%>
\end{verbatim}

  Making this single service call and creating a map is more efficient
  than making separate service calls for each guestbook.
\item
  Display the search results in a search container:

\begin{verbatim}
<liferay-ui:search-container delta="10" 
    emptyResultsMessage="no-entries-were-found" 
    total="<%= entries.size() %>">
        <liferay-ui:search-container-results
                results="<%= entries %>"
/>
\end{verbatim}

  This specifies three attributes for the
  \texttt{\textless{}liferay-ui:search-container\textgreater{}} tag:

  \begin{itemize}
  \tightlist
  \item
    \texttt{delta="10"}: specifies that at most, 10 entries can appear
    per page.
  \item
    \texttt{emptyResultsMessage}: specifies the message indicating there
    are no results.
  \item
    \texttt{total}: specifies the number of search results.
  \end{itemize}

  The \texttt{results} attribute of the tag
  \texttt{\textless{}liferay-ui:search-container-results\textgreater{}}
  specifies the search results. This is easy since you stored the
  entries resulting from the search in the \texttt{entries} list.
\item
  Use the
  \texttt{\textless{}liferay-ui:search-container-row\textgreater{}} tag
  to set the name of the class whose properties are displayed in each
  row:

\begin{verbatim}
<liferay-ui:search-container-row
        className="com.liferay.docs.guestbook.model.Entry"
        keyProperty="entryId" modelVar="entry" escapedModel="<%=true%>">
\end{verbatim}

  This uses the \texttt{className} attribute for the class name and
  specifies the entity's primary key attribute in the
  \texttt{keyProperty} attribute. The \texttt{modelVar} property
  specifies the name of the \texttt{Entry} variable that's available to
  each search container row. To ensure that each field of the
  \texttt{Entry} variable is escaped (sanitized), the
  \texttt{escapedModel} is \texttt{true}. This prevents potential hacks
  that could occur if users submitted malicious code into the Add
  Guestbook form, for example.
\item
  Inside the
  \texttt{\textless{}liferay-ui:search-container-row\textgreater{}} tag,
  specify the four columns to display: the guestbook entry's guestbook
  name, message, entry name, and the actions JSP. The guestbook name is
  retrieved from the map created in the scriptlet:

\begin{verbatim}
    <liferay-ui:search-container-column-text name="guestbook"
        value="<%=guestbookMap.get(Long.toString(entry.getGuestbookId()))%>" />

    <liferay-ui:search-container-column-text property="message" />

    <liferay-ui:search-container-column-text property="name" />

    <liferay-ui:search-container-column-jsp
        path="/guestbookwebportlet/entry_actions.jsp"
        align="right" />
</liferay-ui:search-container-row>
\end{verbatim}
\item
  Use the \texttt{\textless{}liferay-ui:search-iterator\textgreater{}}
  tag to iterate through the search results and handle pagination. Close
  the search container tag:

\begin{verbatim}
        <liferay-ui:search-iterator />
</liferay-ui:search-container>
\end{verbatim}
\item
  At the bottom of \texttt{view\_search.jsp}, declare a \texttt{Log}
  object. You used this log in the \texttt{catch} clauses of the
  \texttt{try} clause that calls the
  \texttt{EntryLocalServiceUtil.getEntry} method to retrieve the
  guestbook entries. If this service call throws an exception, it's best
  to log the error so a server administrator can determine what went
  wrong. Liferay DXP's convention is to declare custom logs for
  individual classes or JSPs at the bottom of the file:

\begin{verbatim}
<%!
        private static Log _log = LogFactoryUtil.getLog("html.guestbookwebportlet.view_search_jsp");
%>
\end{verbatim}
\item
  Finally, your \texttt{view\_search.jsp} requires some extra imports.
  Add the following imports to \texttt{init.jsp}:

\begin{verbatim}
<%@ page import="com.liferay.portal.kernel.dao.search.SearchContainer" %>
<%@ page import="com.liferay.portal.kernel.exception.PortalException" %>
<%@ page import="com.liferay.portal.kernel.exception.SystemException" %>
<%@ page import="com.liferay.portal.kernel.language.LanguageUtil" %>
<%@ page import="com.liferay.portal.kernel.log.Log" %>
<%@ page import="com.liferay.portal.kernel.log.LogFactoryUtil" %>
<%@ page import="com.liferay.portal.kernel.search.Indexer" %>
<%@ page import="com.liferay.portal.kernel.search.IndexerRegistryUtil" %>
<%@ page import="com.liferay.portal.kernel.search.SearchContext" %>
<%@ page import="com.liferay.portal.kernel.search.SearchContextFactory" %>
<%@ page import="com.liferay.portal.kernel.search.Hits" %>
<%@ page import="com.liferay.portal.kernel.search.Document" %>
<%@ page import="com.liferay.portal.kernel.search.Field" %>
<%@ page import="com.liferay.portal.kernel.util.StringPool" %>
<%@ page import="com.liferay.portal.kernel.util.GetterUtil" %>
<%@ page import="com.liferay.portal.kernel.util.Validator" %>
<%@ page import="com.liferay.portal.kernel.util.PortalUtil" %>

<%@ page import="java.util.ArrayList" %>
<%@ page import="java.util.Map" %>
<%@ page import="java.util.HashMap" %>

<%@ page import="javax.portlet.PortletURL" %>
\end{verbatim}
\end{enumerate}

Good work! The Guestbook portlet now supports search! Now your users can
find those Guestbook entries they were looking for.

The next section goes over Liferay DXP's asset framework, which provides
shared functionality across different types of content like blog posts,
message board posts, wiki articles, and more. This is the heart of
integration with Liferay DXP's development platform.

\chapter{Assets: Integrating with Liferay's
Framework}\label{assets-integrating-with-liferays-framework}

Liferay DXP's asset framework transforms entities into a common format
that can be published anywhere in your site. Web content articles, blog
posts, wiki articles, and documents are some asset-enabled entities that
come out-of-the-box. By asset-enabling your own applications, you can
take advantage of Liferay DXP's functionality for publishing your
application's data across your site in the form of asset publisher
entries, notifications, social activities, and more.

Liferay DXP's asset framework includes the following features:

\begin{itemize}
\tightlist
\item
  Tags and categories
\item
  Comments and ratings
\item
  Related assets (a.k.a. asset links)
\item
  Faceted search
\item
  Integration with Liferay DXP's Asset Publisher portlet
\item
  Integration with Liferay DXP's Search portlet
\item
  Integration with Liferay DXP's Tags Navigation, Tag Cloud, and
  Categories Navigation portlets
\end{itemize}

In this section, you'll asset-enable the guestbook and guestbook entry
entities. You'll implement tags, categories, and related assets for
guestbooks and guestbook entries. You'll implement comments and ratings
in guestbook entries. You'll also learn how asset-enabled guestbooks and
guestbook entries integrate with Liferay DXP core portlets like the
Asset Publisher, Tags Navigation, Tag Cloud, and Categories Navigation
portlets. Ready to start?

Let's Go!{}

\chapter{Enabling Assets at the Service
Layer}\label{enabling-assets-at-the-service-layer}

\begin{verbatim}
<p>Enabling Assets at the Service Layer<br>Step 1 of 3</p>
\end{verbatim}

Each row in the \texttt{AssetEntry} table represents an asset and has an
\texttt{entryId} primary key, and \texttt{classNameId} and
\texttt{classPK} foreign keys. The \texttt{classNameId} specifies the
asset's type. For example, an asset with a \texttt{classNameId} of
\texttt{JournalArticle} means that the asset represents a web content
article (in Liferay DXP, \texttt{JournalArticle} is the back-end name
for a web content article). An asset's \texttt{classPK} is the primary
key of the entity represented by the asset.

Follow these steps to make Liferay DXP's asset services available to
your entities' service layers:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In the \texttt{guestbook-service} module's \texttt{service.xml} file,
  add the following references directly above the closing
  \texttt{\textless{}/entity\textgreater{}} tags for \texttt{Guestbook}
  and \texttt{Entry}:

\begin{verbatim}
<reference package-path="com.liferay.portlet.asset" entity="AssetEntry" />
<reference package-path="com.liferay.portlet.asset" entity="AssetLink" />
\end{verbatim}

  As mentioned above, you must use Liferay DXP's \texttt{AssetEntry}
  service for your application to add asset entries that correspond to
  guestbooks and guestbook entries. You also use Liferay DXP's
  \texttt{AssetLink} service for your application to support related
  assets. \emph{Asset links} are Liferay DXP's back-end term for related
  assets.
\item
  You must add finders--two for \texttt{Guestbook}s and two for
  \texttt{Entity}s--so your assets show in Asset Publisher. Add these
  below the existing finders for the \texttt{Guestbook} entity:

\begin{verbatim}
<finder name="Status" return-type="Collection">
    <finder-column name="status" />
</finder>

<finder name="G_S" return-type="Collection">
    <finder-column name="groupId" />
    <finder-column name="status" />
</finder>
\end{verbatim}

  Add these below the existing finders for the \texttt{Entry} entity:

\begin{verbatim}
<finder name="Status" return-type="Collection">
    <finder-column name="status" />
</finder>
<finder name="G_S" return-type="Collection">
    <finder-column name="groupId" />
    <finder-column name="status" />
</finder>
\end{verbatim}
\item
  Right-click \texttt{build.gradle} and select \emph{Gradle} →
  \emph{Refresh Gradle Project}.
\item
  Run the \texttt{buildService} Gradle task. This task causes the
  objects referenced above to be injected into your services for use.
\end{enumerate}

Great! Next, you'll handle assets in your service layer.

\section{Handling Assets at the Guestbook Service
Layer}\label{handling-assets-at-the-guestbook-service-layer}

\begin{verbatim}
<p>Enabling Assets at the Service Layer<br>Step 2 of 3</p>
\end{verbatim}

In this section, you'll update the guestbook service layer to use
assets. You must update the add, update, and delete methods of your
project's \texttt{GuestbookLocalServiceImpl}. Follow these steps to do
so:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open your project's \texttt{GuestbookLocalServiceImpl} class and find
  the \texttt{addGuestbook} method. Add the call to add the asset
  entries below the call that adds resources:

\begin{verbatim}
  AssetEntry assetEntry = assetEntryLocalService.updateEntry(userId,
                      groupId, guestbook.getCreateDate(),
                      guestbook.getModifiedDate(), Guestbook.class.getName(),
                      guestbookId, guestbook.getUuid(), 0,
                      serviceContext.getAssetCategoryIds(),
                      serviceContext.getAssetTagNames(), true, true, null, null, null, null,
                      ContentTypes.TEXT_HTML, guestbook.getName(), null, null, null,
                      null, 0, 0, null);

  assetLinkLocalService.updateLinks(userId, assetEntry.getEntryId(),
                      serviceContext.getAssetLinkEntryIds(),
                      AssetLinkConstants.TYPE_RELATED);
\end{verbatim}

  Calling \texttt{assetEntryLocalService.updateEntry} adds a new row
  (corresponding to the guestbook that's being added) to the
  \texttt{AssetEntry} table in Liferay DXP's database.
  \texttt{AssetEntryLocalServiceImpl}'s \texttt{updateEntry} method both
  adds and updates asset entries because it checks to see whether the
  asset entry already exists in the database and then takes the
  appropriate action. If you check the
  \href{@platform-ref@/7.0-latest/javadocs/portal-impl/com/liferay/portlet/asset/service/impl/AssetEntryLocalServiceImpl.html}{Javadoc}
  for Liferay DXP's \texttt{AssetEntryLocalServiceUtil.updateEntry},
  you'll see that this method is overloaded. Now, why did you use a
  version of this method with such a long method signature? Because
  there's only one version of \texttt{updateEntry} that takes a
  \texttt{title} parameter (to set the asset entry's title). Since you
  want to set the asset title to \texttt{guestbook.getName()}, that's
  the version you use.

  Later, you'll update the Guestbook Admin portlet's form for adding
  guestbooks to allow the selection of related assets, which are stored
  in the database's \texttt{AssetLink} table. The
  \texttt{assetLinkLocalService.updateLinks} call adds the appropriate
  entries to the table so related assets work for your guestbook
  entities. The \texttt{updateEntry} method adds and updates asset
  entries the same way \texttt{updateLink} adds and updates asset links.
\item
  Next, add the asset calls to \texttt{GuestbookLocalServiceImpl}'s
  \texttt{updateGuestbook} method, directly after the resource call:

\begin{verbatim}
  AssetEntry assetEntry = assetEntryLocalService.updateEntry(guestbook.getUserId(),
                      guestbook.getGroupId(), guestbook.getCreateDate(),
                      guestbook.getModifiedDate(), Guestbook.class.getName(),
                      guestbookId, guestbook.getUuid(), 0,
                      serviceContext.getAssetCategoryIds(),
                      serviceContext.getAssetTagNames(), true, true, guestbook.getCreateDate(), 
                      null, null, null, ContentTypes.TEXT_HTML, guestbook.getName(), null, null, 
                      null, null, 0, 0, serviceContext.getAssetPriority());

  assetLinkLocalService.updateLinks(serviceContext.getUserId(),
                      assetEntry.getEntryId(), serviceContext.getAssetLinkEntryIds(),
                      AssetLinkConstants.TYPE_RELATED);
\end{verbatim}

  Here, \texttt{assetEntryLocalService.updateEntry} updates an existing
  asset entry and \texttt{assetLinkLocalService.updateLinks} adds or
  updates that entry's asset links (related assets).
\item
  Next, add the asset calls to the \texttt{deleteGuestbook} method,
  directly after the resource calls:

\begin{verbatim}
  AssetEntry assetEntry = assetEntryLocalService.fetchEntry(
                      Guestbook.class.getName(), guestbookId);

  assetLinkLocalService.deleteLinks(assetEntry.getEntryId());

  assetEntryLocalService.deleteEntry(assetEntry);
\end{verbatim}

  Here, you use the guestbook's class name and ID to retrieve the
  corresponding asset entry. Then you delete that asset entry's asset
  links and the asset entry itself.
\item
  Finally, organize your imports, save the file, and run Service Builder
  to apply the changes.
\end{enumerate}

Next, you'll do the same thing for guestbook entries.

\section{Handling Assets at the Entry Service
Layer}\label{handling-assets-at-the-entry-service-layer}

\begin{verbatim}
<p>Enabling Assets at the Service Layer<br>Step 3 of 3</p>
\end{verbatim}

Now you must update the guestbook entry entity's service methods. In
these methods, the calls you'll make to \texttt{assetEntryLocalService}
and \texttt{assetLinkLocalService} are identical to the ones you made in
the guestbook entity's service methods. Follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open \texttt{EntryLocalServiceImpl} and add the asset calls to the
  \texttt{addEntry} method after the resource calls:

\begin{verbatim}
  AssetEntry assetEntry = assetEntryLocalService.updateEntry(userId,
                      groupId, entry.getCreateDate(), entry.getModifiedDate(),
                      Entry.class.getName(), entryId, entry.getUuid(), 0,
                      serviceContext.getAssetCategoryIds(),
                      serviceContext.getAssetTagNames(), true, true, null, null, null, null,
                      ContentTypes.TEXT_HTML, entry.getMessage(), null, null, null,
                      null, 0, 0, null);

  assetLinkLocalService.updateLinks(userId, assetEntry.getEntryId(),
                      serviceContext.getAssetLinkEntryIds(),
                      AssetLinkConstants.TYPE_RELATED);
\end{verbatim}
\item
  Next, add the asset calls to the \texttt{updateEntry} method after the
  resource calls:

\begin{verbatim}
      AssetEntry assetEntry = assetEntryLocalService.updateEntry(userId,
                      serviceContext.getScopeGroupId(),
                      entry.getCreateDate(), entry.getModifiedDate(),
                      Entry.class.getName(), entryId, entry.getUuid(),
                      0, serviceContext.getAssetCategoryIds(),
                      serviceContext.getAssetTagNames(), true, true,
                      entry.getCreateDate(), null, null, null,
                      ContentTypes.TEXT_HTML, entry.getMessage(), null,
                      null, null, null, 0, 0,
                      serviceContext.getAssetPriority());

      assetLinkLocalService.updateLinks(userId, assetEntry.getEntryId(),
                      serviceContext.getAssetLinkEntryIds(),
                      AssetLinkConstants.TYPE_RELATED);
\end{verbatim}
\item
  Add the asset calls to the \texttt{deleteEntry} method after the
  resource calls:

\begin{verbatim}
AssetEntry assetEntry = assetEntryLocalService.fetchEntry(
                      Entry.class.getName(), entryId);

assetLinkLocalService.deleteLinks(assetEntry.getEntryId());

assetEntryLocalService.deleteEntry(assetEntry);
\end{verbatim}
\item
  Organize your imports, save the file, and run Service Builder.
\item
  Finally, add these language keys to the
  \texttt{guestbook-web/src/main/resource/content/Language.properties}
  file:

\begin{verbatim}
model.resource.com.liferay.docs.guestbook.model.Guestbook=Guestbook
model.resource.com.liferay.docs.guestbook.model.Entry=Guestbook Entry
\end{verbatim}
\end{enumerate}

Excellent! You've asset-enabled your guestbook and guestbook entry
entities at the service layer. Your next step is to implement asset
renderers for these entities so they can be fully integrated into
Liferay DXP's asset framework. Every asset needs an asset renderer class
so the Asset Publisher portlet can display it.

\chapter{Implementing Asset
Renderers}\label{implementing-asset-renderers}

Assets are generic versions of entities, so they contain fields like
\texttt{title}, \texttt{description}, and \texttt{summary}. Liferay DXP
uses these fields to display assets. Asset Renderers translate an entity
into an asset via these fields. For Liferay DXP to display your entities
as assets, you must therefore create and register Asset Renderer classes
for your guestbook and guestbook entry entities. Without these classes,
Liferay DXP can't display your entities in Asset Publisher,
Notifications, Activities, or anywhere else that displays assets.

Your next task is to create these Asset Renderers. Ready to begin?

Let's Go!{}

\section{Implementing a Guestbook Asset
Renderer}\label{implementing-a-guestbook-asset-renderer}

\begin{verbatim}
<p>Implementing Asset Renderers<br>Step 1 of 2</p>
\end{verbatim}

Liferay DXP's asset renderers follow the factory pattern, so you must
create a \texttt{GuestbookAssetRendererFactory} that instantiates the
\texttt{GuestbookAssetRenderer}'s private guestbook object. Here, you'll
create both classes.

Get started by creating the Asset Renderer class first.

\subsection{Creating the AssetRenderer
Class}\label{creating-the-assetrenderer-class}

Follow these steps to create the \texttt{GuestbookAssetRenderer} class:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a new package called \texttt{com.liferay.docs.guestbook.asset}
  in the \texttt{guestbook-service} module's \texttt{src/main/java}
  folder. In this package, create a \texttt{GuestbookAssetRenderer}
  class that extends Liferay DXP's \texttt{BaseJSPAssetRenderer} class.
  Extending this class gives you a head-start on implementing the
  \texttt{AssetRenderer} interface. Start with this code:

\begin{verbatim}
package com.liferay.docs.guestbook.asset;

import com.liferay.asset.kernel.model.BaseJSPAssetRenderer;
import com.liferay.portal.kernel.exception.PortalException;
import com.liferay.portal.kernel.exception.SystemException;
import com.liferay.portal.kernel.model.LayoutConstants;
import com.liferay.portal.kernel.portlet.LiferayPortletRequest;
import com.liferay.portal.kernel.portlet.LiferayPortletResponse;
import com.liferay.portal.kernel.portlet.PortletURLFactoryUtil;
import com.liferay.portal.kernel.security.permission.ActionKeys;
import com.liferay.portal.kernel.security.permission.PermissionChecker;
import com.liferay.portal.kernel.util.HtmlUtil;
import com.liferay.portal.kernel.util.PortalUtil;
import com.liferay.portal.kernel.util.StringUtil;
import com.liferay.docs.guestbook.portlet.constants.GuestbookPortletKeys;
import com.liferay.docs.guestbook.model.Guestbook;
import com.liferay.docs.guestbook.service.permission.GuestbookPermission;
import java.util.Locale;
import javax.portlet.PortletRequest;
import javax.portlet.PortletResponse;
import javax.portlet.PortletURL;
import javax.portlet.WindowState;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class GuestbookAssetRenderer extends BaseJSPAssetRenderer<Guestbook> {

}
\end{verbatim}
\item
  Add the constructor and the guestbook class variable next. Most of the
  methods in this class are simply getters that return fields from this
  private guestbook object:

\begin{verbatim}
public GuestbookAssetRenderer(Guestbook guestbook) {

            _guestbook = guestbook;
}

private Guestbook _guestbook;
\end{verbatim}
\item
  The \texttt{BaseJSPAssetRenderer} abstract class that you're extending
  contains dummy implementations of the \texttt{hasEditPermission} and
  \texttt{hasViewPermission} methods that you must override. Override
  these dummy implementations with actual permission checks using the
  \texttt{GuestbookPermission} class that you created earlier:

\begin{verbatim}
@Override
public boolean hasEditPermission(PermissionChecker permissionChecker) 
throws PortalException {

  long guestbookId = _guestbook.getGuestbookId();
  return GuestbookPermission.contains(permissionChecker, guestbookId, 
  ActionKeys.UPDATE);
}

@Override
public boolean hasViewPermission(PermissionChecker permissionChecker) 
throws PortalException {

  long guestbookId = _guestbook.getGuestbookId();
  return GuestbookPermission.contains(permissionChecker, guestbookId, 
  ActionKeys.VIEW);
}
\end{verbatim}
\item
  Add the following getter methods to retrieve information about the
  guestbook asset:

\begin{verbatim}
@Override
public Guestbook getAssetObject() {
  return _guestbook;
}

@Override
public long getGroupId() {
  return _guestbook.getGroupId();
}

@Override
public long getUserId() {

  return _guestbook.getUserId();
}

@Override
public String getUserName() {
  return _guestbook.getUserName();
}

@Override
public String getUuid() {
  return _guestbook.getUuid();
}

@Override
public String getClassName() {
  return Guestbook.class.getName();
}

@Override
public long getClassPK() {
  return _guestbook.getGuestbookId();
}

@Override
public String getSummary(PortletRequest portletRequest, PortletResponse 
  portletResponse) {
    return "Name: " + _guestbook.getName();
}

@Override
public String getTitle(Locale locale) {
  return _guestbook.getName();
}

@Override
public boolean include(HttpServletRequest request, HttpServletResponse 
  response, String template) throws Exception {
    request.setAttribute("GUESTBOOK", _guestbook);
    request.setAttribute("HtmlUtil", HtmlUtil.getHtml());
    request.setAttribute("StringUtil", new StringUtil());
    return super.include(request, response, template);
}
\end{verbatim}

  The final method makes several utilities, as well as the
  \texttt{Guestbook} entity, available to Liferay DXP in the
  \texttt{HttpServletRequest} object.
\item
  Override the \texttt{getJspPath} method. This method returns a string
  that represents the path to the JSP that renders the guestbook asset.
  When the Asset Publisher displays an asset's full content, it invokes
  the asset renderer class's \texttt{getJspPath} method and passes a
  \texttt{template} string parameter that equals
  \texttt{"full\_content"}. This returns
  \texttt{/asset/guestbook/full\_content.jsp} when the
  \texttt{full\_content} template string is passed as a parameter.
  You'll create this JSP later when updating your application's user
  interface:

\begin{verbatim}
  @Override
  public String getJspPath(HttpServletRequest request, String template) {

    if (template.equals(TEMPLATE_FULL_CONTENT)) {
      request.setAttribute("gb_guestbook", _guestbook);

      return "/asset/guestbook/" + template + ".jsp";
    } else {
      return null;
    }
  }
\end{verbatim}
\item
  Override the \texttt{getURLEdit} method. This method returns a URL for
  editing the asset:

\begin{verbatim}
  @Override
  public PortletURL getURLEdit(LiferayPortletRequest liferayPortletRequest,
      LiferayPortletResponse liferayPortletResponse) throws Exception {
    PortletURL portletURL = liferayPortletResponse.createLiferayPortletURL(
        getControlPanelPlid(liferayPortletRequest), GuestbookPortletKeys.GUESTBOOK,
        PortletRequest.RENDER_PHASE);
    portletURL.setParameter("mvcRenderCommandName", "/guestbookwebportlet/edit_guestbook");
    portletURL.setParameter("guestbookId", String.valueOf(_guestbook.getGuestbookId()));
    portletURL.setParameter("showback", Boolean.FALSE.toString());

    return portletURL;
  }
\end{verbatim}
\item
  Override the \texttt{getURLViewInContext} method. This method returns
  a URL to view the asset in its native application:

\begin{verbatim}
  @Override
  public String getURLViewInContext(LiferayPortletRequest liferayPortletRequest,
      LiferayPortletResponse liferayPortletResponse, String noSuchEntryRedirect) throws Exception {
    try {
      long plid = PortalUtil.getPlidFromPortletId(_guestbook.getGroupId(),
          GuestbookPortletKeys.GUESTBOOK);

      PortletURL portletURL;
      if (plid == LayoutConstants.DEFAULT_PLID) {
        portletURL = liferayPortletResponse.createLiferayPortletURL(getControlPanelPlid(liferayPortletRequest),
            GuestbookPortletKeys.GUESTBOOK, PortletRequest.RENDER_PHASE);
      } else {
        portletURL = PortletURLFactoryUtil.create(liferayPortletRequest,
            GuestbookPortletKeys.GUESTBOOK, plid, PortletRequest.RENDER_PHASE);
      }

      portletURL.setParameter("mvcRenderCommandName", "/guestbookwebportlet/view");
      portletURL.setParameter("guestbookId", String.valueOf(_guestbook.getGuestbookId()));

      String currentUrl = PortalUtil.getCurrentURL(liferayPortletRequest);

      portletURL.setParameter("redirect", currentUrl);

      return portletURL.toString();

    } catch (PortalException e) {

    } catch (SystemException e) {
    }

    return noSuchEntryRedirect;
  }
\end{verbatim}
\item
  Override the \texttt{getURLView} method. This method returns a URL to
  view the asset from within the Asset Publisher:

\begin{verbatim}
  @Override
  public String getURLView(LiferayPortletResponse liferayPortletResponse, 
  WindowState windowState) throws Exception {

    return super.getURLView(liferayPortletResponse, windowState);
  }
\end{verbatim}
\item
  Save the class.
\item
  You have an error in your class, because the
  \texttt{guestbook-service} project doesn't have access to the
  \texttt{GuestbookPortletKeys} object that's in the
  \texttt{guestbook-web} project.

  It is logical to think this could be corrected by including the
  project as a dependency in \texttt{guestbook-service}'s
  \texttt{build.gradle} file, but that creates a circular dependency.
  \texttt{guestbook-web} already depends on \texttt{guestbook-service},
  so you can't make \texttt{guestbook-service} depend circularly on
  \texttt{guestbook-web}.

  So now what do you do?

  Make sure you've opened both \texttt{guestbook-api} and
  \texttt{guestbook-web} projects. Drag the
  \texttt{com.liferay.docs.guestbook.portlet.constants} package from the
  \texttt{guestbook-web} project and drop it on the
  \texttt{guestbook-api} project's \texttt{src/main/java} folder. Blamo!
  You fixed the problem. \texttt{guestbook-service} depends on
  \texttt{guestbook-api} and implements its interfaces.
  \texttt{guestbook-web} depends on both. Now you have only linear
  dependencies.
\end{enumerate}

Next you can create the \texttt{AssetRendererFactory} class.

\subsection{Creating the GuestbookAssetRendererFactory
Class}\label{creating-the-guestbookassetrendererfactory-class}

Follow these steps to create the \texttt{GuestbookAssetRendererFactory}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In the \texttt{com.liferay.docs.guestbook.asset} package, create a
  class called \texttt{GuestbookAssetRendererFactory} that extends
  Liferay DXP's \texttt{BaseAssetRendererFactory} class. Replace its
  code with this starter code:

\begin{verbatim}
package com.liferay.docs.guestbook.asset;

import com.liferay.asset.kernel.model.AssetRenderer;
import com.liferay.asset.kernel.model.AssetRendererFactory;
import com.liferay.asset.kernel.model.BaseAssetRendererFactory;
import com.liferay.docs.guestbook.model.Guestbook;
import com.liferay.docs.guestbook.service.EntryLocalService;
import com.liferay.docs.guestbook.service.GuestbookLocalService;
import com.liferay.docs.guestbook.service.permission.GuestbookPermission;
import com.liferay.docs.guestbook.constants.GuestbookPortletKeys;
import com.liferay.portal.kernel.util.WebKeys;
import com.liferay.portal.kernel.exception.PortalException;
import com.liferay.portal.kernel.portlet.LiferayPortletRequest;
import com.liferay.portal.kernel.portlet.LiferayPortletResponse;
import com.liferay.portal.kernel.security.permission.PermissionChecker;
import com.liferay.portal.kernel.theme.ThemeDisplay;

import javax.portlet.PortletRequest;
import javax.portlet.PortletURL;
import javax.servlet.ServletContext;

import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Reference;


@Component(immediate = true, 
  property = {"javax.portlet.name=" + GuestbookPortletKeys.GUESTBOOK}, 
  service = AssetRendererFactory.class
  )
public class GuestbookAssetRendererFactory extends 
  BaseAssetRendererFactory<Guestbook> {

  public GuestbookAssetRendererFactory() {
    setClassName(CLASS_NAME);
    setLinkable(_LINKABLE);
    setPortletId(GuestbookPortletKeys.GUESTBOOK);
    setSearchable(true);
    setSelectable(true);
  }
\end{verbatim}

  This code contains the class declaration and the constructor. It sets
  the class name it creates an \texttt{AssetRenderer} for, a portlet ID,
  and a boolean (\texttt{\_LINKABLE}) set to \texttt{true}. The boolean
  denotes the methods that provide URLs in the generated
  \texttt{AssetRenderer} are implemented.
\item
  Implement the \texttt{getAssetRenderer} method, which constructs new
  \texttt{GuestbookAssetRenderer} instances for specific guestbooks. It
  uses the \texttt{classPK} (primary key) parameter to retrieve the
  guestbook from the database. It then calls the
  \texttt{GuestbookAssetRenderer}'s constructor, passing the retrieved
  guestbook as an argument:

\begin{verbatim}
@Override
public AssetRenderer<Guestbook> getAssetRenderer(long classPK, int type) 
throws PortalException {

  Guestbook guestbook = _guestbookLocalService.getGuestbook(classPK);

  GuestbookAssetRenderer guestbookAssetRenderer = 
  new GuestbookAssetRenderer(guestbook);

  guestbookAssetRenderer.setAssetRendererType(type);
  guestbookAssetRenderer.setServletContext(_servletContext);

  return guestbookAssetRenderer;
}
\end{verbatim}
\item
  You're extending \texttt{BaseAssetRendererFactory}, an abstract class
  that implements the \texttt{AssetRendererFactory} interface. To ensure
  that your custom asset is associated with the correct entity, each
  asset renderer factory must implement the \texttt{getClassName} and
  \texttt{getType} methods (among others):

\begin{verbatim}
  @Override
  public String getClassName() {
    return CLASS_NAME;
  }

  @Override
  public String getType() {
    return TYPE;
  }
\end{verbatim}
\item
  Implement the \texttt{hasPermission} method via the
  \texttt{GuestbookPermission} class:

\begin{verbatim}
@Override
public boolean hasPermission(PermissionChecker permissionChecker, 
long classPK, String actionId) throws Exception {

  Guestbook guestbook = _guestbookLocalService.getGuestbook(classPK);
  return GuestbookPermission.contains(permissionChecker, guestbook, 
  actionId);
}
\end{verbatim}
\item
  Add the remaining code to create the portlet URL for the asset and
  specify whether it's linkable:

\begin{verbatim}
      @Override
      public PortletURL getURLAdd(LiferayPortletRequest liferayPortletRequest,
          LiferayPortletResponse liferayPortletResponse, long classTypeId) {
        PortletURL portletURL = null;

        try {
          ThemeDisplay themeDisplay = (ThemeDisplay) 
          liferayPortletRequest.getAttribute(WebKeys.THEME_DISPLAY);

          portletURL = liferayPortletResponse.createLiferayPortletURL(getControlPanelPlid(themeDisplay),
              GuestbookPortletKeys.GUESTBOOK, PortletRequest.RENDER_PHASE);
          portletURL.setParameter("mvcRenderCommandName", "/guestbookwebportlet/edit_guestbook");
          portletURL.setParameter("showback", Boolean.FALSE.toString());
        } catch (PortalException e) {
        }

        return portletURL;
      }

      @Override
      public boolean isLinkable() {
        return _LINKABLE;
      }

      @Override
      public String getIconCssClass() {
          return "bookmarks";
      }

    @Reference(target = "(osgi.web.symbolicname=com.liferay.docs.guestbook.portlet)",
            unbind = "-")
    public void setServletContext(ServletContext servletContext) {
            _servletContext = servletContext;
        }
        private ServletContext _servletContext;

    @Reference(unbind = "-")
        protected void setGuestbookLocalService(GuestbookLocalService guestbookLocalService) {
            _guestbookLocalService = guestbookLocalService; 
    }

    private GuestbookLocalService _guestbookLocalService;
    private static final boolean _LINKABLE = true;
    public static final String CLASS_NAME = Guestbook.class.getName();
    public static final String TYPE = "guestbook";
}
\end{verbatim}
\item
  Organize imports (Ctrl-Shift-O) and save the file.
\end{enumerate}

Great! The guestbook asset renderer is complete. Next, you'll create the
entry asset renderer.

\section{Implementing an Entry Asset
Renderer}\label{implementing-an-entry-asset-renderer}

\begin{verbatim}
<p>Implementing Asset Renderers<br>Step 2 of 2</p>
\end{verbatim}

The classes you'll create here are nearly identical to the
\texttt{GuestbookAssetRenderer} and
\texttt{GuestbookAssetRendererFactory} classes you created for
guestbooks in the previous step. This step provides the code needed for
guestbook entries. Please review the previous sections for more
information on this code.

\subsection{Creating the EntryAssetRenderer
Class}\label{creating-the-entryassetrenderer-class}

In the \texttt{com.liferay.docs.guestbook.asset} package, create an
\texttt{EntryAssetRenderer} class that extends Liferay DXP's
\texttt{BaseJSPAssetRenderer} class. Replace the contents of your
\texttt{EntryAssetRenderer} class with the following code:

\begin{verbatim}
package com.liferay.docs.guestbook.asset;

import com.liferay.asset.kernel.model.BaseJSPAssetRenderer;
import com.liferay.portal.kernel.exception.PortalException;
import com.liferay.portal.kernel.exception.SystemException;
import com.liferay.portal.kernel.model.LayoutConstants;
import com.liferay.portal.kernel.portlet.LiferayPortletRequest;
import com.liferay.portal.kernel.portlet.LiferayPortletResponse;
import com.liferay.portal.kernel.portlet.PortletURLFactoryUtil;
import com.liferay.portal.kernel.security.permission.ActionKeys;
import com.liferay.portal.kernel.security.permission.PermissionChecker;
import com.liferay.portal.kernel.util.HtmlUtil;
import com.liferay.portal.kernel.util.PortalUtil;
import com.liferay.portal.kernel.util.StringUtil;
import com.liferay.docs.guestbook.portlet.constants.GuestbookPortletKeys;
import com.liferay.docs.guestbook.model.Entry;
import com.liferay.docs.guestbook.service.permission.EntryPermission;
import java.util.Locale;
import javax.portlet.PortletRequest;
import javax.portlet.PortletResponse;
import javax.portlet.PortletURL;
import javax.portlet.WindowState;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class EntryAssetRenderer extends BaseJSPAssetRenderer<Entry> {

  public EntryAssetRenderer(Entry entry) {

    _entry = entry;
  }

  @Override
  public boolean hasViewPermission(PermissionChecker permissionChecker) 
  throws PortalException {

    long entryId = _entry.getEntryId();
    return EntryPermission.contains(permissionChecker, entryId, 
    ActionKeys.VIEW);
  }

  @Override
  public Entry getAssetObject() {
    return _entry;
  }

  @Override
  public long getGroupId() {
    return _entry.getGroupId();
  }

  @Override
  public long getUserId() {

    return _entry.getUserId();
  }

  @Override
  public String getUserName() {
    return _entry.getUserName();
  }

  @Override
  public String getUuid() {
    return _entry.getUuid();
  }

  @Override
  public String getClassName() {
    return Entry.class.getName();
  }

  @Override
  public long getClassPK() {
    return _entry.getEntryId();
  }

  @Override
  public String getSummary(PortletRequest portletRequest, 
  PortletResponse portletResponse) {
    return "Name: " + _entry.getName() + ". Message: " + _entry.getMessage();
  }

  @Override
  public String getTitle(Locale locale) {
    return _entry.getMessage();
  }

  @Override
  public boolean include(HttpServletRequest request, 
  HttpServletResponse response, String template) throws Exception {
    request.setAttribute("ENTRY", _entry);
    request.setAttribute("HtmlUtil", HtmlUtil.getHtml());
    request.setAttribute("StringUtil", new StringUtil());
    return super.include(request, response, template);
  }

  @Override
  public String getJspPath(HttpServletRequest request, String template) {
    
    if (template.equals(TEMPLATE_FULL_CONTENT)) {
      request.setAttribute("gb_entry", _entry);

      return "/asset/entry/" + template + ".jsp";
    } else {
      return null;
    }
  }

  @Override
  public PortletURL getURLEdit(LiferayPortletRequest liferayPortletRequest,
      LiferayPortletResponse liferayPortletResponse) throws Exception {
    PortletURL portletURL = liferayPortletResponse.createLiferayPortletURL(
        getControlPanelPlid(liferayPortletRequest), GuestbookPortletKeys.GUESTBOOK,
        PortletRequest.RENDER_PHASE);
    portletURL.setParameter("mvcRenderCommandName", "/guestbookwebportlet/edit_entry");
    portletURL.setParameter("entryId", String.valueOf(_entry.getEntryId()));
    portletURL.setParameter("showback", Boolean.FALSE.toString());

    return portletURL;
  }

  @Override
  public String getURLViewInContext(LiferayPortletRequest liferayPortletRequest,
      LiferayPortletResponse liferayPortletResponse, String noSuchEntryRedirect) 
      throws Exception {
    try {
      long plid = PortalUtil.getPlidFromPortletId(_entry.getGroupId(),
          GuestbookPortletKeys.GUESTBOOK);

      PortletURL portletURL;
      if (plid == LayoutConstants.DEFAULT_PLID) {
        portletURL = liferayPortletResponse.createLiferayPortletURL(getControlPanelPlid(liferayPortletRequest),
            GuestbookPortletKeys.GUESTBOOK, PortletRequest.RENDER_PHASE);
      } else {
        portletURL = PortletURLFactoryUtil.create(liferayPortletRequest,
            GuestbookPortletKeys.GUESTBOOK, plid, PortletRequest.RENDER_PHASE);
      }

      portletURL.setParameter("mvcRenderCommandName", "/guestbookwebportlet/view");
      portletURL.setParameter("entryId", String.valueOf(_entry.getEntryId()));

      String currentUrl = PortalUtil.getCurrentURL(liferayPortletRequest);

      portletURL.setParameter("redirect", currentUrl);

      return portletURL.toString();

    } catch (PortalException e) {

    } catch (SystemException e) {
    }

    return noSuchEntryRedirect;
  }

  @Override
  public String getURLView(LiferayPortletResponse liferayPortletResponse, 
  WindowState windowState) throws Exception {

    return super.getURLView(liferayPortletResponse, windowState);
  }

  @Override
  public boolean isPrintable() {
        return true;
  }

  private Entry _entry;
}
\end{verbatim}

This class is similar to the \texttt{GuestbookAssetRenderer} class. For
the \texttt{EntryAssetRenderer.getSummary} method, you return a summary
that displays the entry name (the name of the user who created the
entry) and the entry message.

\texttt{GuestbookAssetRenderer.getSummary} returns a summary that
displays the guestbook name. \texttt{EntryAssetRenderer.getTitle}
returns the entry message. \texttt{GuestbookAssetRenderer.getTitle}
returns the guestbook name. The rest of the methods of
\texttt{EntryAssetRenderer} are nearly identical to those of
\texttt{GuestbookAssetRenderer}.

\subsection{Creating the EntryAssetRendererFactory
Class}\label{creating-the-entryassetrendererfactory-class}

Next, you must create the guestbook entry asset renderer's factory
class. In the \texttt{com.liferay.docs.guestbook.asset} package, create
a class called \texttt{EntryAssetRendererFactory} that extends Liferay
DXP's \texttt{BaseAssetRendererFactory} class. Replace its contents with
the following code:

\begin{verbatim}
package com.liferay.docs.guestbook.asset;

import com.liferay.asset.kernel.model.AssetRenderer;
import com.liferay.asset.kernel.model.AssetRendererFactory;
import com.liferay.asset.kernel.model.BaseAssetRendererFactory;
import com.liferay.docs.guestbook.model.Entry;
import com.liferay.docs.guestbook.service.EntryLocalService;
import com.liferay.docs.guestbook.service.permission.EntryPermission;
import com.liferay.docs.guestbook.portlet.constants.GuestbookPortletKeys;
import com.liferay.portal.kernel.util.WebKeys;
import com.liferay.portal.kernel.exception.PortalException;
import com.liferay.portal.kernel.portlet.LiferayPortletRequest;
import com.liferay.portal.kernel.portlet.LiferayPortletResponse;
import com.liferay.portal.kernel.portlet.LiferayPortletURL;
import com.liferay.portal.kernel.security.permission.PermissionChecker;
import com.liferay.portal.kernel.theme.ThemeDisplay;

import javax.portlet.PortletRequest;
import javax.portlet.PortletURL;
import javax.portlet.WindowState;
import javax.portlet.WindowStateException;
import javax.servlet.ServletContext;

import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Reference;

@Component(
    immediate = true,
    property = {"javax.portlet.name=" + GuestbookPortletKeys.GUESTBOOK},
    service = AssetRendererFactory.class
)
public class EntryAssetRendererFactory extends BaseAssetRendererFactory<Entry> {

    public EntryAssetRendererFactory() {
        setClassName(CLASS_NAME);
        setLinkable(_LINKABLE);
        setPortletId(GuestbookPortletKeys.GUESTBOOK);
        setSearchable(true);
        setSelectable(true);
    }

    @Override
    public AssetRenderer<Entry> getAssetRenderer(long classPK, int type)
        throws PortalException {

        Entry entry = _entryLocalService.getEntry(classPK);

        EntryAssetRenderer entryAssetRenderer = new EntryAssetRenderer(entry);

        entryAssetRenderer.setAssetRendererType(type);
        entryAssetRenderer.setServletContext(_servletContext);

        return entryAssetRenderer;
    }

    @Override
    public String getClassName() {
        return CLASS_NAME;
    }

    @Override
    public String getType() {
        return TYPE;
    }

    @Override
    public boolean hasPermission(PermissionChecker permissionChecker,
        long classPK, String actionId) throws Exception {

        Entry entry = _entryLocalService.getEntry(classPK);
        return EntryPermission.contains(permissionChecker, entry, actionId);
    }

    @Override
    public PortletURL getURLAdd(LiferayPortletRequest liferayPortletRequest,
        LiferayPortletResponse liferayPortletResponse, long classTypeId) {

        PortletURL portletURL = null;

        try {
            ThemeDisplay themeDisplay = (ThemeDisplay) liferayPortletRequest.getAttribute(WebKeys.THEME_DISPLAY);

            portletURL = liferayPortletResponse.createLiferayPortletURL(getControlPanelPlid(themeDisplay),
                GuestbookPortletKeys.GUESTBOOK, PortletRequest.RENDER_PHASE);
            portletURL.setParameter("mvcRenderCommandName", "/guestbookwebportlet/edit_entry");
            portletURL.setParameter("showback", Boolean.FALSE.toString());
        } catch (PortalException e) {
        }

        return portletURL;
    }

    @Override
    public PortletURL getURLView(LiferayPortletResponse liferayPortletResponse, WindowState windowState) {

        LiferayPortletURL liferayPortletURL
            = liferayPortletResponse.createLiferayPortletURL(
                GuestbookPortletKeys.GUESTBOOK, PortletRequest.RENDER_PHASE);

        try {
            liferayPortletURL.setWindowState(windowState);
        } catch (WindowStateException wse) {

        }
        return liferayPortletURL;
    }

    @Override
    public boolean isLinkable() {
        return _LINKABLE;
    }

    @Override
    public String getIconCssClass() {
        return "pencil";
    }

    @Reference(target = "(osgi.web.symbolicname=com.liferay.docs.guestbook.portlet)",
        unbind = "-")
    public void setServletContext (ServletContext servletContext) {
        _servletContext = servletContext;
    }

    @Reference(unbind = "-")
    protected void setEntryLocalService(EntryLocalService entryLocalService) {
        _entryLocalService = entryLocalService;
    }

    private EntryLocalService _entryLocalService;
    private ServletContext _servletContext;
    private static final boolean _LINKABLE = true;
    public static final String CLASS_NAME = Entry.class.getName();
    public static final String TYPE = "entry";

}
\end{verbatim}

\subsection{Exporting the Asset
Package}\label{exporting-the-asset-package}

The container needs to make the asset renderers and their factories
available to Liferay DXP when it needs them. To do this, you must export
the package.

Open the \texttt{guestbook-service} module's \texttt{bnd.bnd} file and
add the asset package to the \texttt{Export-Package} declaration. When
you're finished, it should look like this:

\begin{verbatim}
Export-Package: com.liferay.docs.guestbook.asset,\
                com.liferay.docs.guestbook.service.permission,\
                com.liferay.docs.guestbook.search
\end{verbatim}

Now your guestbook project's entities are fully asset-enabled. To test
the functionality, add the Asset Publisher portlet to a page and add a
few guestbooks and guestbook entries. Edit a few of them, too. Then,
check the Asset Publisher portlet. The Asset Publisher, by default,
dynamically displays assets of any kind from the current site.

\begin{figure}
\centering
\includegraphics{./images/custom-entities-asset-publisher.png}
\caption{After you've implemented and registered your asset renderers
for your custom entities, the Asset Publisher can display your
entities.}
\end{figure}

Confirm that the Asset Publisher displays the guestbooks and guestbook
entries that you added.

Great! In the next section, you'll update your portlets' user interfaces
to use several features of Liferay DXP's asset framework: comments,
ratings, tags, categories, and related assets.

\chapter{Adding Asset Features to Your User
Interface}\label{adding-asset-features-to-your-user-interface}

\begin{verbatim}
<p>Adding Asset Features to Your UI<br>Step 1 of 5</p>
\end{verbatim}

Now that your guestbook and guestbook entry entities are asset-enabled,
you're ready to use Liferay DXP's asset functionality in your
application. You'll start by implementing comments, ratings, tags,
categories, and related assets for guestbooks. Then you'll do the same
for guestbook entries. All the back-end support for these features is
provided by Liferay DXP. Your only task is to update your applications'
user interfaces to use these features.

In this section, you'll create several new JSPs that need new imports.
Add the following imports to the \texttt{guestbook-web} module project's
\texttt{init.jsp} file:

\begin{verbatim}
<%@ page import="java.util.Map" %>
<%@ page import="java.util.HashMap" %>

<%@ page import="com.liferay.asset.kernel.service.AssetEntryLocalServiceUtil" %>
<%@ page import="com.liferay.asset.kernel.service.AssetTagLocalServiceUtil" %>

<%@ page import="com.liferay.asset.kernel.model.AssetEntry" %>
<%@ page import="com.liferay.asset.kernel.model.AssetTag" %>

<%@ page import="com.liferay.portal.kernel.util.ListUtil" %>
\end{verbatim}

It's simpler to add these imports now so you don't run into errors as
you're working through this section.

\section{Creating JSPs for Displaying Custom Assets in the Asset
Publisher}\label{creating-jsps-for-displaying-custom-assets-in-the-asset-publisher}

\begin{verbatim}
<p>Adding Asset Features to Your UI<br>Step 2 of 5</p>
\end{verbatim}

Before proceeding, you must tie up a loose end from the previous step.
Remember that you implemented \texttt{getJspPath} methods in your
\texttt{GuestbookAssetRenderer} and \texttt{EntryAssetRenderer} classes.
These methods return paths to the JSPs the Asset Publisher uses to
display the assets' full content. The \texttt{getJspPath} method of
\texttt{GuestbookAssetRenderer} returns
\texttt{"/asset/guestbook/full\_content.jsp"}, and the
\texttt{getJspPath} method of \texttt{EntryAssetRenderer} returns
\texttt{"/asset/entry/full\_content.jsp"}. It's time to create these
JSPs.

Follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In the \texttt{guestbook-web} module project, create a new folder
  called \texttt{asset} under the \texttt{resources/META-INF/resources}
  folder. Add two folders to this new folder: \texttt{entry} and
  \texttt{guestbook}.
\item
  Create a new file called \texttt{full\_content.jsp} in the
  \texttt{/asset/guestbook} folder. This JSP displays a guestbook
  asset's full content. Add the following code to this file:

\begin{verbatim}
<%@include file="../../init.jsp"%>

<%
Guestbook guestbook = (Guestbook)request.getAttribute("gb_guestbook");

guestbook = guestbook.toEscapedModel();
%>

<dl>
        <dt>Name</dt>
        <dd><%= guestbook.getName() %></dd>
</dl>
\end{verbatim}

  This JSP grabs the guestbook object from the request and displays the
  guestbook's name. In \texttt{GuestbookAssetRenderer}, the
  \texttt{getJspPath} method used the following to add the
  \texttt{gb\_guestbook} request attribute:

\begin{verbatim}
request.setAttribute("gb_guestbook", _guestbook);
\end{verbatim}

  The guestbook's \texttt{toEscapedModel} method belongs to the
  \texttt{GuestbookModelImpl} class, which was generated by Service
  Builder. This method returns a \emph{safe} guestbook object (a
  guestbook in which each field is HTML-escaped). Calling
  \texttt{guestbook\ =\ guestbook.toEscapedModel()} before displaying
  the guestbook name ensures that your JSP won't display malicious code
  that's masquerading as a guestbook name.
\item
  Next, in the \texttt{/asset/entry} folder, create a
  \texttt{full\_content.jsp} for displaying a guestbook entry asset's
  full content. Add the following code to this file:

\begin{verbatim}
<%@include file="../../init.jsp"%>

<%
Entry entry = (Entry)request.getAttribute("gb_entry");

entry = entry.toEscapedModel();
%>

<dl>
        <dt>Guestbook</dt>
        <dd><%= GuestbookLocalServiceUtil.getGuestbook(entry.getGuestbookId()).getName() %></dd>
        <dt>Name</dt>
        <dd><%= entry.getName() %></dd>
        <dt>Message</dt>
        <dd><%= entry.getMessage() %></dd>
</dl>
\end{verbatim}
\end{enumerate}

This JSP is almost as simple as the one for guestbooks. The only
difference is that you're displaying three fields of the guestbook entry
entity as opposed to one field of the guestbook entity.

Test your new JSPs by clicking a guestbook's or guestbook entry's title
in the Asset Publisher. The Asset Publisher renders
\texttt{full\_content.jsp}:

\begin{figure}
\centering
\includegraphics{./images/asset-publisher-full-content.png}
\caption{When you click the title for a guestbook or guestbook entry in
the Asset Publisher, your \texttt{full\_content.jsp} should be
displayed.}
\end{figure}

By default, when displaying an asset's full view, the Asset Publisher
displays additional links for Twitter, Facebook, and Google Plus. These
links publicize your asset on social media. The \emph{Back} icon and the
\emph{View in Context} link return you to the Asset Publisher's default
view.

\section{Enabling Tags, Categories, and Related Assets for
Guestbooks}\label{enabling-tags-categories-and-related-assets-for-guestbooks}

\begin{verbatim}
<p>Adding Asset Features to Your UI<br>Step 3 of 5</p>
\end{verbatim}

Since you already asset-enabled guestbooks at the service layer,
guestbook entities can now use Liferay DXP's back-end support for tags
and categories. All that's left is to enable tags and categories in the
UI. In this step, you'll update the Guestbook Admin portlet's
\texttt{edit\_guestbook.jsp} so admins can add, edit, or remove tags and
categories when adding or updating a guestbook.

\subsection{Enabling Asset Features}\label{enabling-asset-features}

Follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In the \texttt{guestbook-web} module's
  \texttt{/guestbookadminportlet/edit\_guestbook.jsp}, add the tags
  \texttt{\textless{}liferay-ui:asset-categories-error\ /\textgreater{}}
  and \texttt{\textless{}liferay-ui:asset-tags-error/\textgreater{}} to
  the \texttt{aui:form} below the closing
  \texttt{\textless{}/aui:fieldset\textgreater{}} tag:

\begin{verbatim}
<liferay-ui:asset-categories-error />
<liferay-ui:asset-tags-error />
\end{verbatim}

  These tags display error messages if an error occurs with the tags or
  categories submitted in the form.
\item
  Below the error tags, add a
  \texttt{\textless{}liferay-ui:panel\textgreater{}} tag with the
  following attributes:

\begin{verbatim}
<liferay-ui:panel defaultState="closed" extended="<%= false %>"
  id="guestbookCategorizationPanel" persistState="<%= true %>"
  title="categorization">

</liferay-ui:panel>
\end{verbatim}

  The \texttt{\textless{}liferay-ui:panel\textgreater{}} tag generates a
  collapsible section.
\item
  Add input fields for tags and categories inside the panel section you
  just created. Specify the \texttt{assetCategories} and
  \texttt{assetTags} types for the
  \texttt{\textless{}aui:input\ /\textgreater{}} tags to tell Liferay
  DXP that these input tags represent asset categories and asset tags.
  You can group related input fields together with an
  \texttt{\textless{}aui:fieldset\textgreater{}} tag. Liferay DXP shows
  the appropriate selectors for tags and categories and displays the
  tags and categories that have already been added to the guestbook:

\begin{verbatim}
<aui:fieldset>
  <aui:input name="categories" type="assetCategories" />

  <aui:input name="tags" type="assetTags" />
</aui:fieldset>
\end{verbatim}
\item
  Add a second \texttt{\textless{}liferay-ui:panel\textgreater{}} tag
  under the existing one. In this new tag, add an
  \texttt{\textless{}aui:fieldset\textgreater{}} tag containing a
  \texttt{\textless{}liferay-ui:asset-links\textgreater{}} tag. To
  display the correct asset links (the selected guestbook's related
  assets), set the \texttt{className} and \texttt{classPK} attributes:

\begin{verbatim}
<liferay-ui:panel defaultState="closed" extended="<%= false %>"
  id="guestbookAssetLinksPanel" persistState="<%= true %>"
  title="related-assets">
  <aui:fieldset>
    <liferay-ui:input-asset-links
      className="<%= Guestbook.class.getName() %>"
      classPK="<%= guestbookId %>" />
  </aui:fieldset>
</liferay-ui:panel>
\end{verbatim}
\end{enumerate}

Test the updated \texttt{edit\_guestbook.jsp} page by navigating to the
Guestbook Admin portlet in the Control Panel and clicking \emph{Add
Guestbook}. You'll see a field for adding tags and a selector for
selecting related assets.

\begin{figure}
\centering
\includegraphics{./images/guestbook-tags-related-assets.png}
\caption{Once you've updated your Guestbook Admin portlet's
\texttt{edit\_guestbook.jsp} page, you'll see forms for adding tags and
selecting related assets.}
\end{figure}

Don't do anything with these fields yet, because you're not done
implementing assets. Next, you'll enable tags and categories for
guestbook entries.

\section{Enabling Tags, Categories, and Related Assets for Guestbook
Entries}\label{enabling-tags-categories-and-related-assets-for-guestbook-entries}

\begin{verbatim}
<p>Adding Asset Features to Your UI<br>Step 4 of 5</p>
\end{verbatim}

Enabling tags, categories, and related assets for guestbook entries is
similar to enabling them for guestbooks. It's so similar, you can refer
back to the previous step for a detailed explanation.

Open your \texttt{guestbook-web} module's
\texttt{guestbookwebportlet/edit\_entry.jsp} file. Replace its content
with the following code:

\begin{verbatim}
<%@ include file="../init.jsp" %>

<%
long entryId = ParamUtil.getLong(renderRequest, "entryId");

Entry entry = null;

if (entryId > 0) {
    entry = EntryLocalServiceUtil.getEntry(entryId);
}

long guestbookId = ParamUtil.getLong(renderRequest, "guestbookId");
%>

<portlet:renderURL var="viewURL">
    <portlet:param 
        name="mvcPath" 
        value="/guestbookwebportlet/view.jsp" 
    />
</portlet:renderURL>

<liferay-ui:header
    backURL="<%= viewURL.toString() %>"
    title="<%= entry == null ? "Add Entry" : entry.getName() %>"
/>

<portlet:actionURL name="addEntry" var="addEntryURL" />

<aui:form action="<%= addEntryURL %>" name="fm">
    <aui:model-context bean="<%= entry %>" model="<%= Entry.class %>" />

        <aui:fieldset>
            <aui:input name="name" />

            <aui:input name="email" />

            <aui:input name="message" />

            <aui:input name="entryId" type="hidden" />

            <aui:input name="guestbookId" type="hidden" 
            value=
            "<%= entry == null ? guestbookId : entry.getGuestbookId() %>" />
        </aui:fieldset>

<liferay-ui:asset-categories-error />
                    <liferay-ui:asset-tags-error />
                    <liferay-ui:panel defaultState="closed" 
                    extended="<%= false %>" id="entryCategorizationPanel" 
                    persistState="<%= true %>" title="categorization">
                            <aui:fieldset>
                                    <aui:input name="categories" 
                                    type="assetCategories" />

                                    <aui:input name="tags" type="assetTags" />
                            </aui:fieldset>
                    </liferay-ui:panel>

                    <liferay-ui:panel defaultState="closed" 
                    extended="<%= false %>" id="entryAssetLinksPanel" 
                    persistState="<%= true %>" title="related-assets">
                            <aui:fieldset>
                                    <liferay-ui:input-asset-links
                                            className=
                                            "<%= Entry.class.getName() %>"
                                            classPK="<%= entryId %>"
                                    />
                            </aui:fieldset>
                    </liferay-ui:panel>

    <aui:button-row>
        <aui:button type="submit" />

        <aui:button onClick="<%= viewURL.toString() %>" type="cancel" />
    </aui:button-row>
</aui:form>
\end{verbatim}

Test your JSP by using the Guestbook portlet to add and update Guestbook
entries. Try adding and removing tags, categories, and related assets.
All these operations should work.

Well done! Next, you'll enable comments and ratings for guestbook
entries.

\section{Enabling Comments and Ratings for Guestbook
Entries}\label{enabling-comments-and-ratings-for-guestbook-entries}

\begin{verbatim}
<p>Adding Asset Features to Your UI<br>Step 5 of 5</p>
\end{verbatim}

Liferay DXP's asset framework lets users comment on and rate assets. As
with tags, categories, and related assets, you must update the user
interface to expose these features. It's best to separate the page where
users comment on and rate assets from the page where users edit assets.
You shouldn't have to edit an entry to comment on it; that not only
makes no sense, it's a security problem. Comments and ratings should be
added in a view mode only.

Follow these steps to enable comments and ratings on guestbook entries:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a new file called \texttt{view\_entry.jsp} in your
  \texttt{guestbook-web} module project's \texttt{/guestbookwebportlet}
  folder.
\item
  Add a Java scriptlet to the file you just created. In this scriptlet,
  use an \texttt{entryId} request attribute to get an entry object. For
  security reasons, convert this object to an escaped model as discussed
  in the earlier step
  \href{/docs/7.0/tutorials/-/knowledge_base/t/creating-jsps-for-displaying-custom-assets-in-the-asset-publisher}{Creating
  JSPs for Displaying Customs Assets in the Asset Publisher}:

\begin{verbatim}
<%@ include file="../init.jsp"%>

<%
  long entryId = ParamUtil.getLong(renderRequest, "entryId");

  long guestbookId = ParamUtil.getLong(renderRequest, "guestbookId");

  Entry entry = null;

  if (entryId > 0) {
    entry = EntryLocalServiceUtil.getEntry(entryId);

    entryId = entry.getEntryId();
  }

  entry = EntryLocalServiceUtil.getEntry(entryId);
  entry = entry.toEscapedModel();

  AssetEntry assetEntry = 
  AssetEntryLocalServiceUtil.getEntry(Entry.class.getName(), 
  entry.getEntryId());
\end{verbatim}
\item
  Next, update the breadcrumb entry with the the current entry's name:

\begin{verbatim}
String currentURL = PortalUtil.getCurrentURL(request);
PortalUtil.addPortletBreadcrumbEntry(request, entry.getMessage(),
currentURL);
\end{verbatim}
\item
  At the end of the scriptlet, add the names of the current entry's
  existing asset tags as keywords to the portal page. These tag names
  appear in a
  \texttt{\textless{}meta\ content="{[}tag\ names\ here{]}"\ lang="en-US"\ name="keywords"\ /\textgreater{}}
  element in your portal page's \texttt{\textless{}head\textgreater{}}
  section. These keywords can help search engines find and index your
  page:

\begin{verbatim}
  PortalUtil.setPageSubtitle(entry.getMessage(), request);
  PortalUtil.setPageDescription(entry.getMessage(), request);

  List<AssetTag> assetTags = 
  AssetTagLocalServiceUtil.getTags(Entry.class.getName(), 
  entry.getEntryId());
  PortalUtil.setPageKeywords(ListUtil.toString(assetTags, "name"), 
  request);
%>
\end{verbatim}
\item
  After the scriptlet, specify the URLs for the page and back link:

\begin{verbatim}
<liferay-portlet:renderURL varImpl="viewEntryURL">
  <portlet:param name="mvcPath"
    value="/guestbookwebportlet/view_entry.jsp" />
  <portlet:param name="entryId" value="<%=String.valueOf(entryId)%>" />
</liferay-portlet:renderURL>

<liferay-portlet:renderURL varImpl="viewURL">
  <portlet:param name="mvcPath"
    value="/guestbookwebportlet/view.jsp" />
</liferay-portlet:renderURL>

<liferay-ui:header backURL="<%=viewURL.toString()%>"
  title="<%=entry.getName()%>" 
/>
\end{verbatim}
\item
  Next, define the page's main content. Display the guestbook's name,
  and the entry's name and message with the
  \texttt{\textless{}dl\textgreater{}},
  \texttt{\textless{}dt\textgreater{}}, and
  \texttt{\textless{}dd\textgreater{}} tags:

\begin{verbatim}
<dl>
  <dt>Guestbook</dt>
  <dd><%=GuestbookLocalServiceUtil.getGuestbook(entry.getGuestbookId()).getName()%></dd>
  <dt>Name</dt>
  <dd><%=entry.getName()%></dd>
  <dt>Message</dt>
  <dd><%=entry.getMessage()%></dd>
</dl>
\end{verbatim}

  This is the same way you defined the page's main content in
  \texttt{/guestbookwebportlet/full\_content.jsp}.
\item
  Next, use a
  \texttt{\textless{}liferay-ui:panel-container\textgreater{}} tag to
  create a panel container. Inside this tag, use a
  \texttt{\textless{}liferay-ui:panel\textgreater{}} tag to create a
  panel to display the comments and ratings components:

\begin{verbatim}
<liferay-ui:panel-container extended="<%=false%>"
  id="guestbookCollaborationPanelContainer" persistState="<%=true%>">
  <liferay-ui:panel collapsible="<%=true%>" extended="<%=true%>"
    id="guestbookCollaborationPanel" persistState="<%=true%>"
    title="Collaboration">
\end{verbatim}
\item
  Add the ratings and comments components via the
  \texttt{\textless{}liferay-ui:ratings\textgreater{}} and
  \texttt{\textless{}liferay-ui:discussion\textgreater{}} tags,
  respectively. The latter tag needs an action URL (in this case,
  \texttt{invokeTaglibDiscussion}) for its \texttt{formAction}
  attribute. The action URL adds the comment after the user enters a
  comment and clicks \emph{Reply}:

\begin{verbatim}
    <liferay-ui:ratings className="<%=Entry.class.getName()%>"
      classPK="<%=entry.getEntryId()%>" type="stars" />

    <br />

    <portlet:actionURL name="invokeTaglibDiscussion" 
    var="discussionURL" />

    <liferay-ui:discussion className="<%=Entry.class.getName()%>"
      classPK="<%=entry.getEntryId()%>"
      formAction="<%=discussionURL%>" formName="fm2"
      ratingsEnabled="<%=true%>" redirect="<%=currentURL%>"
      userId="<%=entry.getUserId()%>" />

  </liferay-ui:panel>
</liferay-ui:panel-container>
\end{verbatim}
\item
  To restrict comments and ratings access to logged-in users, wrap the
  whole panel container in a \texttt{\textless{}c:if\textgreater{}} tag
  that tests the expression \texttt{themeDisplay.isSignedIn()}:

\begin{verbatim}
<c:if test="<%= themeDisplay.isSignedIn() %>">
    ... your panel container ...
</c:if>
\end{verbatim}

  Make sure you add the closing \texttt{\textless{}/c:if\textgreater{}}
  tag after the closing
  \texttt{\textless{}/liferay-ui:panel-container\textgreater{}} tag.
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** Discussions (comments) are implemented as message board messages
 in Liferay DXP. In the `MBMessage` table, there's a `classPK` column. This
 `classPK` represents the `entryId` of the guestbook entry the comment
 belongs to. Ratings are stored in the `RatingsEntry` table. Similarly, the
 `RatingsEntry` table contains a `classPK` column. This `classPK` represents
 the `entryId` of the guestbook entry the rating belongs to. Using a
 `classPK` foreign key in one table to represent the primary key of another
 table is a common pattern that's used throughout Liferay DXP.
\end{verbatim}

\noindent\hrulefill

Next, you'll update the guestbook actions to use the new view.

\subsection{Updating the Entry Actions
JSP}\label{updating-the-entry-actions-jsp}

Nothing links to your \texttt{view\_entry.jsp} page--it's currently
orphaned. Fix this by adding the \emph{View} option to the Actions Menu.
Open the \texttt{/guestbookwebportlet/entry\_actions.jsp} and find the
following line:

\begin{verbatim}
<liferay-ui:icon-menu>
\end{verbatim}

Add the following lines below it:

\begin{verbatim}
<portlet:renderURL var="viewEntryURL">
  <portlet:param name="entryId"
    value="<%= String.valueOf(entry.getEntryId()) %>" />
  <portlet:param name="mvcPath"
    value="/guestbookwebportlet/view_entry.jsp" />
</portlet:renderURL>

<liferay-ui:icon message="View" url="<%= viewEntryURL.toString() %>" />
\end{verbatim}

Here, you create a URL that points to \texttt{view\_entry.jsp}. Test
this link by selecting the \emph{View} option in a guestbook entry's
Actions Menu. Then test that comments and ratings work as expected.

Excellent! You've asset-enabled the guestbook and guestbook entry
entities, and enabled tags, categories, and related assets for both
entities. You've also enabled comments and ratings for guestbook entry
entities! Great job!

Your next task is to generate web services. This makes it possible to
write other clients (such as mobile applications) for the Guestbook
application.

\chapter{Generating Web Services}\label{generating-web-services}

Assets opened the door to support many features of Liferay DXP's
development framework. There's more to cover, but the Guestbook app's
back-end is now mature enough to widen its appeal.

Right now, the Guestbook app's back-end services can only be accessed by
modules in the same OSGi container. If you want to read or post
Guestbook entries, you have to write and deploy native code on the
server. This is fine for some, but others want more: web clients on a
different platform; standalone applications using Electron or some other
framework; or mobile apps for Android or iOS. Web services power all of
these.

You now have an application with back-end services and a front-end web
client running in the same container. Web services make it possible to
have multiple front-end clients on multiple platforms that access the
same back-end. This makes it possible to build \emph{headless}
applications on Liferay DXP, with multiple front-ends elsewhere.

\begin{figure}
\centering
\includegraphics{./images/multi-client-application.png}
\caption{Liferay DXP makes it easy to write multi-client applications.}
\end{figure}

Next, you'll use Service Builder to create the Guestbook app's web
services. When you finish, authorized clients can then consume these web
services.

Ready to start?

Let's Go!{}

\section{Creating Remote Services with Service
Builder}\label{creating-remote-services-with-service-builder}

\begin{verbatim}
<p>Creating Remote Services<br>Step 1 of 1</p>
\end{verbatim}

Earlier, you used Service Builder to generate the Guestbook's model,
persistence, and service layers. Services generated by Service Builder
can come in two flavors: local and remote. The local services you
already used can only be invoked locally from the same OSGi container.
Remote services can be invoked by any application with permission to
access your server via the web. Remote services are published as JSON or
SOAP.

For more information,
\href{/docs/7-0/tutorials/-/knowledge_base/t/service-builder-web-services}{click
here} to see the Service Builder Web Services section of tutorials.

Creating web services for the Guestbook application takes two steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Generate the web services with Service Builder.
\item
  Expose the services you want and wrap them in permission checks.
\end{enumerate}

There's a level of security in the assumption that local services can
only be called by other services in the container. For example, the web
app does permission and validation checks before calling services. To
access these services, developers must be able to deploy their modules
on the server. You don't have these assurances when you expose services
to the web, so you must check for permission before calling a service.

But first you must tell Service Builder to generate web services. Follow
these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open \texttt{service.xml} from the \texttt{guestbook-service} module.
  Find the tags for the \texttt{Guestbook} and \texttt{Entry} entities:

\begin{verbatim}
<entity name="Guestbook" local-service="true" uuid="true">

<entity name="Entry" local-service="true" uuid="true">
\end{verbatim}
\item
  As described in the \texttt{service.xml}
  \href{https://docs.liferay.com/ce/portal/7.0-ga4/definitions/liferay-service-builder_7_0_0.dtd.html}{DTD},
  \texttt{local-service} defaults to \texttt{false} and
  \texttt{remote-service} defaults to \texttt{true}. It helps other
  developers who read your code to specify what services are generated.
  Therefore, add \texttt{remote-service="true"} to the entity tags of
  the \texttt{Guestbook} and \texttt{Entry} entities:

\begin{verbatim}
<entity name="Guestbook" local-service="true" remote-service="true" uuid="true">

<entity name="Entry" local-service="true" remote-service="true" uuid="true">
\end{verbatim}
\item
  In the \emph{Gradle Tasks} window on the right-hand side of Liferay
  @ide@, expand the service module's build folder. Run Service Builder
  by double-clicking \emph{buildService}. When Service Builder finishes,
  refresh the \texttt{guestbook-api} and \texttt{guestbook-service}
  modules in the Project Explorer.
\end{enumerate}

You may be interested to know that Service Builder did absolutely
nothing. Since remote services are generated by default, you've always
had their stubs in your project. All you did was make it explicit in the
code.

By implementing local services, you separated concerns. Local services
can assume things like permission checks have already been done before
they're called. This separates the business logic from the permissions
logic. If instead you implemented everything in the remote services,
this separation wouldn't exist.

You may see code from other developers, however, who didn't implement
the local service, and instead elected to place all their business and
permission logic in the remote service. This works, but makes the code
less readable. With the concerns separated, a business logic bug is
contained in the local service, and a permissions bug is contained in
the remote service.

To expose remote services, you'll implement methods in the
\texttt{-ServiceImpl} classes instead of the \texttt{-LocalServiceImpl}
classes. Since the primary concern is permissions, however, first create
a helper class to hold the permissions:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In the \texttt{src/main/java} folder, create the new package
  \texttt{com.liferay.docs.guestbook.util}. In this new package, create
  this \texttt{ActionKeys} class:

\begin{verbatim}
package com.liferay.docs.guestbook.util;

public class ActionKeys extends
                com.liferay.portal.kernel.security.permission.ActionKeys {

        public static final String ADD_ENTRY = "ADD_ENTRY";
        public static final String ADD_GUESTBOOK = "ADD_GUESTBOOK";
}
\end{verbatim}

  The \texttt{ADD\_ENTRY} and \texttt{ADD\_GUESTBOOK} strings reference
  the permissions defined in the \texttt{guestbook-service} module's
  \texttt{docroot/WEB-INF/src/resource-actions/default.xml} file earlier
  in this Learning Path. It's a best practice to create strings to refer
  to permissions in a class called \texttt{ActionKeys} that extends
  \texttt{com.liferay.portal.kernel.security.permission.ActionKeys}. The
  parent \texttt{ActionKeys} contains strings that are used to refer to
  portal permissions. These include strings for common permissions such
  as \texttt{VIEW}, \texttt{UPDATE}, \texttt{DELETE}, and so on.
\item
  Add the following methods to the \texttt{GuestbookServiceImpl} class;
  then organize the imports by selecting \emph{Source} → \emph{Organize
  Imports}:

\begin{verbatim}
public Guestbook addGuestbook(long userId, String name,
    ServiceContext serviceContext) throws SystemException,
    PortalException {

    return guestbookLocalService.addGuestbook(userId, name, serviceContext);
}

public Guestbook deleteGuestbook(long guestbookId,
    ServiceContext serviceContext) throws PortalException,
    SystemException {

    return guestbookLocalService.deleteGuestbook(guestbookId, serviceContext);
}

public List<Guestbook> getGuestbooks(long groupId) throws SystemException {
        return guestbookLocalService.getGuestbooks(groupId);
}

public List<Guestbook> getGuestbooks(long groupId, int start, int end)
                throws SystemException {
        return guestbookLocalService.getGuestbooks(groupId, start, end);
}

public int getGuestbooksCount(long groupId) throws SystemException {
        return guestbookLocalService.getGuestbooksCount();
}

public Guestbook updateGuestbook(long userId, long guestbookId,
    String name, ServiceContext serviceContext) throws PortalException,
    SystemException {

    return guestbookLocalService.updateGuestbook(userId, guestbookId,
        name, serviceContext);
}
\end{verbatim}

  These are stub remote service methods that expose each guestbook local
  service method. For now, the remote service method implementations
  call the local service implementations. Later, you'll add permission
  checks to these methods, to wrap them in the same permissions you
  created in the UI. Service calls have no UI, so you must check for
  permission to access them. For now, you're exposing the services to
  confirm they work and are accessible.
\item
  Add the following methods to the \texttt{EntryServiceImpl} class, then
  organize the imports as you did in step 2:

\begin{verbatim}
public Entry addEntry(long userId, long guestbookId, String name,
        String email, String message, ServiceContext serviceContext)
        throws PortalException, SystemException {

    return entryLocalService.addEntry(userId, guestbookId, name, email,
                 message, serviceContext);
}

public Entry deleteEntry(long entryId, ServiceContext serviceContext)
                throws PortalException, SystemException {

    return entryLocalService.deleteEntry(entryId, serviceContext);
}

public List<Entry> getEntries(long groupId, long guestbookId)
                throws SystemException {

    return entryLocalService.getEntries(groupId, guestbookId);
}

public List<Entry> getEntries(long groupId, long guestbookId, int start,
                int end) throws SystemException {

    return entryLocalService.getEntries(groupId, guestbookId, start, end);
}

public int getEntriesCount(long groupId, long guestbookId)
                throws SystemException {

    return entryLocalService.getEntriesCount(groupId, guestbookId);
}

public Entry updateEntry(long userId, long guestbookId, long entryId,
                String name, String email, String message,
                ServiceContext serviceContext) throws PortalException,
                SystemException {

    return entryLocalService.updateEntry(userId, guestbookId, entryId,
                        name, email, message, serviceContext);
}
\end{verbatim}

  Like you did for guestbooks, you've now created method stubs for
  guestbook entries. Each method implemented here exposes a service to
  the web. You'll add permission checks in the next section.
\item
  Run Service Builder and refresh the API and service modules. Then
  redeploy the \texttt{guestbook-*} modules.
\end{enumerate}

First, make sure you're logged in as a user that can read guestbooks.
Navigate to Liferay DXP's JSONWS page
(\texttt{http://{[}host\ name{]}:{[}port\ number{]}/api/jsonws}) and
click the \emph{Context Name} selector. The Guestbook app's context,
\texttt{gb}, appears as an option. Select it and confirm that your
remote service methods appear in the list.

\begin{figure}
\centering
\includegraphics{./images/jsonws-guestbook.png}
\caption{After you've added remote service methods to your project's
\texttt{*ServiceImpl} classes, run Service Builder and redeploy your
modules. Then check that your remote services are accessible.}
\end{figure}

To test that your remote services work, choose a method to invoke. Pick
a simple method that doesn't require a Service Context parameter, like
\texttt{getGuestbooksCount(long\ groupId)}. To find the appropriate
\texttt{groupId} (the ID of the site containing the Guestbook app),
navigate to that site in your browser and select \emph{Configuration} →
\emph{Site Settings} from the Site Menu on the left. The site ID is
listed at the top of the Site Settings page. Now return to the JSONWS
page and enter the site ID into the group ID field and click
\emph{Invoke}. Confirm that the correct number of guestbooks is
returned. Great! Your remote services work.

Next, you'll build a WSDD (Web Service Deployment Descriptor) document
for your remote services to make them available via SOAP (Simple Object
Access Protocol).

Follow these steps to do so:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In your Liferay workspace's \texttt{settings.gradle} file, add imports
  for \texttt{ServiceBuilderPlugin} and \texttt{WSDDBuilderPlugin}
  before the buildscript block. Then add the
  \texttt{gradle.beforeProject} closure at the bottom of the file:

\begin{verbatim}
import com.liferay.gradle.plugins.service.builder.ServiceBuilderPlugin
import com.liferay.gradle.plugins.wsdd.builder.WSDDBuilderPlugin

...

gradle.beforeProject {
    project ->

    project.plugins.withType(ServiceBuilderPlugin) {
        project.apply plugin: WSDDBuilderPlugin
    }
}
\end{verbatim}

  Refresh your workspace's Gradle files: right click
  \texttt{settings.gradle} in the Project Explorer and select
  \emph{Gradle} → \emph{Refresh Gradle Project}.
\item
  In the \emph{Gradle Tasks} window on the right-hand side of Liferay
  @ide@, expand the service module's \emph{build} folder. Build the WSDD
  by double-clicking \emph{buildWSDD}. If \texttt{buildWSDD} is missing,
  shut down your server and then restart Liferay @ide@. The
  \texttt{buildWSDD} command appears as described.

  The WSDD builder generates a WSDD JAR file in the
  \texttt{guestbook-service} module's \texttt{build/libs} folder.
  Because this folder isn't visible in @ide@, you must access it from
  the file system. The project's modules are in the Eclipse workspace on
  the file system. Here's the full file path to the WSDD JAR in your
  Eclipse workspace:

\begin{verbatim}
com-liferay-docs-guestbook/modules/guestbook/guestbook-service/build/libs/com.liferay.docs.guestbook.service-wsdd-1.0.0.jar
\end{verbatim}

  If this file is missing, run \texttt{buildWSDD} again to generate it.
\item
  Deploy the WSDD JAR file to Liferay DXP, which is in the Liferay
  Workspace's \texttt{bundles} folder. To do this, copy and paste the
  WSDD JAR file into this folder in your Eclipse workspace on your file
  system:

\begin{verbatim}
com-liferay-docs-guestbook/bundles/deploy
\end{verbatim}

  Return to Liferay @ide@ and check the console to make sure deployment
  completes successfully.
\item
  Go to
  \texttt{http://{[}host\ name{]}:{[}port\ number{]}/o/com.liferay.docs.guestbook.service/api/axis}
  in your browser to view the Guestbook app's SOAP web services. If
  you're running Liferay DXP locally on port 8080, this is
  \url{http://localhost:8080/o/com.liferay.docs.guestbook.service/api/axis}.

  This page contains links to the WSDL (Web Services Description
  Language) documents for the Guestbook and Entry remote service
  methods. WSDL files describe details about the remote service methods,
  including the type of data these methods require.
\end{enumerate}

If you want to make your app's services available for remote invocation
via SOAP, generating WSDD and WSDL files is required. For example,
\href{https://web.liferay.com/community/liferay-projects/liferay-mobile-sdk/overview}{the
Liferay Mobile SDK} relies on the WSDD and WSDL to discover your Liferay
DXP app's remote services. For the Liferay Mobile SDK to create a mobile
client that can access your Liferay DXP app's web services, you must
therefore generate a WSDD and WSDL for your app.

Next, you'll learn how to secure your web services. Unless you secure
your web services by implementing permission checks, any user can add,
update, or delete guestbooks or guestbook entries, and you certainly
don't want that.

\chapter{Implementing Permission
Checks}\label{implementing-permission-checks}

Now that your guestbook and guestbook entry web services exist, you must
implement permission checks for them. Implementing permission checks for
a web service ensures that only users with the correct permissions can
invoke the web service. To implement permission checks in your remote
services, you'll use the \texttt{GuestbookModelPermission},
\texttt{GuestbookPermission}, and \texttt{EntryPermission} helper
classes that you created earlier. These classes provide helper methods
for checking permissions. The helper methods in
\texttt{GuestbookModelPermission} check top-level model permissions. For
example, you can use \texttt{GuestbookModelPermission}'s helper methods
to check if a user can add a new guestbook or guestbook entry. If, on
the other hand, you must check if a user can update or delete an
existing guestbook or guestbook entry, you'll use
\texttt{GuestbookPermission} or \texttt{EntryPermission}.

Once you've secured your remote services with permission checks, you'll
update your portlet classes to call remote services instead of local
services. This prevents attackers from trying to bypass your app's UI by
playing with URL parameters to access sensitive portions of your app.

Let's Go!{}

\section{Implementing Permission Checks at the Service
Layer}\label{implementing-permission-checks-at-the-service-layer}

\begin{verbatim}
<p>Implementing Permission Checks<br>Step 1 of 2</p>
\end{verbatim}

First, you'll add permission checks to \texttt{GuestbookServiceImpl}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In \texttt{GuestbookServiceImpl}, replace the \texttt{addGuestbook},
  \texttt{deleteGuestbook}, and \texttt{updateGuestbook} methods with
  these versions that contain the permission checks:

\begin{verbatim}
public Guestbook addGuestbook(long userId, String name,
                ServiceContext serviceContext) throws SystemException,
                PortalException {

        GuestbookModelPermission.check(getPermissionChecker(),
                        serviceContext.getScopeGroupId(), ActionKeys.ADD_GUESTBOOK);

        return guestbookLocalService.addGuestbook(userId, name, serviceContext);
}

public Guestbook deleteGuestbook(long guestbookId,
                ServiceContext serviceContext) throws PortalException,
                SystemException {

        GuestbookPermission.check(getPermissionChecker(), guestbookId,
                        ActionKeys.DELETE);

        return guestbookLocalService.deleteGuestbook(guestbookId, serviceContext);
}

public Guestbook updateGuestbook(long userId, long guestbookId,
                String name, ServiceContext serviceContext) throws PortalException,
                SystemException {

        GuestbookPermission.check(getPermissionChecker(), guestbookId,
                        ActionKeys.UPDATE);

        return guestbookLocalService.updateGuestbook(userId, guestbookId, name, 
                        serviceContext);
}
\end{verbatim}

  Organize imports to add the imports for the \texttt{*Permissions} and
  \texttt{ActionKeys} classes.

  These methods add permission checks to the remote service methods by
  calling the \texttt{check} helper methods in
  \texttt{GuestbookModelPermission} and \texttt{GuestbookPermission}.
  Remember that these methods throw exceptions, so if the user doesn't
  have permission, processing stops at the permission check. The
  \texttt{GuestbookModelPermission.check} method takes three parameters:

  \begin{itemize}
  \tightlist
  \item
    a \texttt{PermissionChecker} object
  \item
    a \texttt{groupId}
  \item
    an \texttt{actionId} string
  \end{itemize}

  The \texttt{GuestbookModelPermission.check} and
  \texttt{EntryModelPermission.check} methods take three parameters:

  \begin{itemize}
  \tightlist
  \item
    a \texttt{PermissionChecker} object
  \item
    an entity ID (either \texttt{guestbookId} or \texttt{entryId})
  \item
    an \texttt{actionId} string
  \end{itemize}

  \texttt{BaseServiceImpl} contains a \texttt{getPermissionChecker}
  method that returns a \texttt{PermissionChecker} object. This is
  accessible since \texttt{GuestbookServiceImpl} extends
  \texttt{GuestbookServiceBaseImpl}, which extends
  \texttt{BaseServiceImpl}. The \texttt{serviceContext} method
  \texttt{getScopeGroupId} returns a \texttt{groupId}. The
  \texttt{actionId} string comes from your \texttt{ActionKeys} class.
  Using an \texttt{ActionKeys} field is less error prone than than
  manually typing the string's name every time you want to check a
  permission. Using an \texttt{ActionKeys} string also avoids creating a
  duplicate string.
\item
  Open \texttt{EntryServiceImpl} and replace the \texttt{addEntry},
  \texttt{deleteEntry}, and \texttt{updateEntry} methods with ones that
  contain permission checks:

\begin{verbatim}
public Entry addEntry(long userId, long guestbookId, String name,
                String email, String message, ServiceContext serviceContext)
                throws PortalException, SystemException {

        GuestbookModelPermission.check(getPermissionChecker(),
                        serviceContext.getScopeGroupId(), ActionKeys.ADD_ENTRY);

        return entryLocalService.addEntry(userId, guestbookId, name, email,
                        message, serviceContext);
}

public Entry deleteEntry(long entryId, ServiceContext serviceContext)
                throws PortalException, SystemException {

        EntryPermission.check(getPermissionChecker(), entryId, ActionKeys.DELETE);

        return entryLocalService.deleteEntry(entryId, serviceContext);
}

public Entry updateEntry(long userId, long guestbookId, long entryId,
                String name, String email, String message,
                ServiceContext serviceContext) throws PortalException,
                SystemException {

        EntryPermission.check(getPermissionChecker(), entryId, ActionKeys.UPDATE);

        return entryLocalService.updateEntry(userId, guestbookId, entryId,
                        name, email, message, serviceContext);
}
\end{verbatim}

  As in step 1, organize imports to add the imports for the
  \texttt{*Permissions} and \texttt{ActionKeys} classes.

  The permission checks in these methods work the same as those in
  \texttt{GuestbookServiceImpl}. For \texttt{addEntry}, you use
  \texttt{GuestbookModelPermission.check} for the permission check,
  since adding a guestbook entry is a top level model action. For
  \texttt{deleteEntry} and \texttt{updateEntry}, you use
  \texttt{EntryPermission.check} since these operations each require a
  specific permission on a specific entity.
\item
  Open \texttt{GuestbookServiceImpl} and replace both
  \texttt{getGuestbooks} methods (this method is overloaded) and the
  \texttt{getGuestbookCount} method with these:

\begin{verbatim}
public List<Guestbook> getGuestbooks(long groupId) throws SystemException {
        return guestbookPersistence.filterFindByGroupId(groupId);
}

public List<Guestbook> getGuestbooks(long groupId, int start, int end)
                throws SystemException {

        return guestbookPersistence.filterFindByGroupId(groupId, start, end);
}

public int getGuestbooksCount(long groupId) throws SystemException {
        return guestbookPersistence.filterCountByGroupId(groupId);
}
\end{verbatim}
\item
  Open \texttt{EntryServiceImpl} and replace the \texttt{getEntries}
  methods (this method is overloaded) and the \texttt{getGuestbookCount}
  method with these:

\begin{verbatim}
public List<Entry> getEntries(long groupId, long guestbookId)
                throws SystemException {

        return entryPersistence.filterFindByG_G(groupId, guestbookId);
}

public List<Entry> getEntries(long groupId, long guestbookId, int start,
                int end) throws SystemException {

        return entryPersistence.filterFindByG_G(groupId, guestbookId, start,
                        end);
}

public int getEntriesCount(long groupId, long guestbookId)
                throws SystemException {

        return entryPersistence.filterCountByG_G(groupId, guestbookId);
}
\end{verbatim}
\item
  Run Service Builder and refresh the API and service modules.
\end{enumerate}

All remote service methods should include permission checks. In steps 1
and 2, you directly invoked permission checks for the remote service
methods \texttt{addGuestbook}, \texttt{deleteGuestbook},
\texttt{updateGuestbook}, \texttt{addEntry}, \texttt{deleteEntry}, and
\texttt{updateEntry} by using the \texttt{check} methods of the
permissions utility classes: \texttt{GuestbookModelPermission},
\texttt{GuestbookPermission}, and \texttt{EntryPermission}. In steps 3
and 4, you indirectly invoked permission checks for the remote service
methods \texttt{getGuestbooks}, \texttt{getGuestbooksCount},
\texttt{getEntries}, and \texttt{getEntriesCount} by calling the
\texttt{filterFindBy*} and \texttt{*filterCountBy*} methods of
\texttt{GuestbookPersistenceImpl} and \texttt{EntryPersistenceImpl}. The
\texttt{filterFindBy*} and \texttt{*filterCountBy*} methods are
generated by Service Builder if the following conditions are met:

\begin{itemize}
\tightlist
\item
  The entity has a simple primitive primary key
\item
  The entity has permission checks registered in an XML file in your
  project's \texttt{docroot/WEB-INF/src/resource-actions} directory
\item
  The entity has \texttt{userId} and \texttt{groupId} fields
\item
  The finder method has a \texttt{groupId} argument in its method
  signature
\end{itemize}

Since it would be a very expensive operation to retrieve a large list of
guestbook or guestbook entry entities and run permission checks on each
one, Service Builder generates the \texttt{filterFindBy*} and
\texttt{filterCountBy*} helper methods in the persistence layer to
handle permission checks. The permission checking of these helper
methods is done in the database, resulting in a less expensive
operation. The \texttt{filterFindBy*} and \texttt{filterCountBy*}
methods work just like the ordinary \texttt{findBy*} and
\texttt{countBy*} methods in the \texttt{*PersistenceImpl} classes,
except that the \texttt{filterFindBy*} and \texttt{filterCountBy*}
methods include permission checks. Instances of the
\texttt{*PersistenceImpl} classes are made available as Spring beans in
the \texttt{*ServiceImpl} classes. These beans are named
\texttt{guestbookPersistence} and \texttt{entryPersistence} in
\texttt{GuestbookServiceImpl} and \texttt{EntryServiceImpl},
respectively.

Awesome! You're almost done. The only thing left is to secure the
service calls you make in the web client.

\section{Securing Service Calls at the Portlet
Layer}\label{securing-service-calls-at-the-portlet-layer}

\begin{verbatim}
<p>Implementing Permission Checks<br>Step 2 of 2</p>
\end{verbatim}

Your remote services are now secure for direct use. Your web
application, however, is another story--it's still calling local
services. In a perfect world, that would be fine, but this isn't a
perfect world.

Previously, you implemented portlet action methods such as
\texttt{addGuestbook}, \texttt{addEntry}, \texttt{deleteEntry}, and so
on in \texttt{GuestbookPortlet} and \texttt{GuestbookAdminPortlet}
classes. These methods call local services. For example, in the
\texttt{addEntry} method of \texttt{GuestbookPortlet}, you used the
following call to add a new guestbook entry:

\begin{verbatim}
_entryLocalService.addEntry(serviceContext.getUserId(), guestbookId, userName, 
    email, message, serviceContext);
\end{verbatim}

Calling local services from an app's portlet layer isn't recommended
because they don't contain permission checks. Nefarious individuals
messing with URL parameters might be able to access protected areas of
your app. To secure your app, only call \emph{remote} services from the
portlet layer, because that's the layer that has permission checking.
Thus, to secure service calls at the portlet layer, all you have to do
is replace the local service calls with remote service calls.

\noindent\hrulefill

\textbf{Note:} An alternative approach to securing service calls at the
portlet layer is to check permissions at the portlet layer manually. To
do this, get a \texttt{ThemeDisplay} from the \texttt{ActionRequest}
(\texttt{ThemeDisplay\ themeDisplay\ =\ \ (ThemeDisplay)\ request.getAttribute(WebKeys.THEME\_DISPLAY);})
and get a \texttt{PermissionChecker} from the \texttt{ThemeDisplay}
(\texttt{PermissionChecker\ \ permissionChecker\ =\ themeDisplay.getPermissionChecker();}).
If the user passes the permission check, then call the local service
method. However, it's best to avoid rewriting permission checks whenever
possible. For this reason, if you must wrap a service call in a
permission check, implement that service method as a remote service and
add the permission check to the remote service. This is the pattern
Liferay DXP uses and that you have followed in this Learning Path.

\noindent\hrulefill

Use the following steps to secure the service calls in the
\texttt{GuestbookPortlet} class:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Replace the \texttt{\_guestbookLocalService} and
  \texttt{\_entryLocalService} variable declarations with these:

\begin{verbatim}
private GuestbookService _guestbookService;
private EntryService _entryService;
\end{verbatim}
\item
  Replace the \texttt{GuestbookLocalService} and
  \texttt{EntryLocalService} imports with the these:

\begin{verbatim}
import com.liferay.docs.guestbook.service.GuestbookService;
import com.liferay.docs.guestbook.service.EntryService;
\end{verbatim}
\item
  Replace all instances of \texttt{\_guestbookLocalService} and
  \texttt{\_entryLocalService} with \texttt{\_guestbookService} and
  \texttt{\_entryService}, respectively. Also make sure to replace any
  \texttt{GuestbookLocalService} and \texttt{EntryLocalService} method
  arguments with \texttt{GuestbookService} and \texttt{EntryService},
  respectively.
\end{enumerate}

Now follow the same steps to change guestbook services in
\texttt{GuestbookAdminPortlet}. Note that service calls and variables
for guestbook entries aren't necessary in
\texttt{GuestbookAdminPortlet}.

To check that you haven't made a mistake in your
\texttt{GuestbookPortlet} class, refer to the following complete class:

\begin{verbatim}
package com.liferay.docs.guestbook.portlet;

import java.io.IOException;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;

import javax.portlet.ActionRequest;
import javax.portlet.ActionResponse;
import javax.portlet.Portlet;
import javax.portlet.PortletException;
import javax.portlet.RenderRequest;
import javax.portlet.RenderResponse;

import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Reference;

import com.liferay.docs.guestbook.model.Entry;
import com.liferay.docs.guestbook.model.Guestbook;
import com.liferay.docs.guestbook.portlet.constants.GuestbookPortletKeys;
import com.liferay.docs.guestbook.service.GuestbookService;
import com.liferay.docs.guestbook.service.EntryService;

import com.liferay.portal.kernel.exception.PortalException;
import com.liferay.portal.kernel.portlet.bridges.mvc.MVCPortlet;
import com.liferay.portal.kernel.service.ServiceContext;
import com.liferay.portal.kernel.service.ServiceContextFactory;
import com.liferay.portal.kernel.servlet.SessionErrors;
import com.liferay.portal.kernel.servlet.SessionMessages;
import com.liferay.portal.kernel.util.ParamUtil;
import com.liferay.portal.kernel.util.PortalUtil;

/**
 * @author sezovr
 */
@Component(
    immediate = true,
    property = {
        "com.liferay.portlet.display-category=category.social",
        "com.liferay.portlet.instanceable=false",
        "com.liferay.portlet.scopeable=true",
        "javax.portlet.display-name=Guestbook",
        "javax.portlet.expiration-cache=0",
        "javax.portlet.init-param.template-path=/",
        "javax.portlet.init-param.view-template=/guestbookwebportlet/view.jsp",
        "javax.portlet.resource-bundle=content.Language",
        "javax.portlet.security-role-ref=power-user,user",
        "javax.portlet.name=" + GuestbookPortletKeys.GUESTBOOK,
        "javax.portlet.supports.mime-type=text/html"
    },
    service = Portlet.class
)
public class GuestbookPortlet extends MVCPortlet {

    public void addEntry(ActionRequest request, ActionResponse response)
                    throws PortalException {

                ServiceContext serviceContext = ServiceContextFactory.getInstance(
                    Entry.class.getName(), request);

                String userName = ParamUtil.getString(request, "name");
                String email = ParamUtil.getString(request, "email");
                String message = ParamUtil.getString(request, "message");
                long guestbookId = ParamUtil.getLong(request, "guestbookId");
                long entryId = ParamUtil.getLong(request, "entryId");

            if (entryId > 0) {

                try {

                    _entryService.updateEntry(
                        serviceContext.getUserId(), guestbookId, entryId, userName,
                        email, message, serviceContext);

                    SessionMessages.add(request, "entryAdded");

                    response.setRenderParameter(
                        "guestbookId", Long.toString(guestbookId));

                }
                catch (Exception e) {
                    System.out.println(e);

                    SessionErrors.add(request, e.getClass().getName());

                    PortalUtil.copyRequestParameters(request, response);

                    response.setRenderParameter(
                        "mvcPath", "/guestbookwebportlet/edit_entry.jsp");
                }

            }
            else {

                try {
                    _entryService.addEntry(
                        serviceContext.getUserId(), guestbookId, userName, email,
                        message, serviceContext);

                    SessionMessages.add(request, "entryAdded");

                    response.setRenderParameter(
                        "guestbookId", Long.toString(guestbookId));

                }
                catch (Exception e) {
                    SessionErrors.add(request, e.getClass().getName());

                    PortalUtil.copyRequestParameters(request, response);

                    response.setRenderParameter(
                        "mvcPath", "/guestbookwebportlet/edit_entry.jsp");
                }
            }
        }

    public void deleteEntry(ActionRequest request, ActionResponse response) throws PortalException {
        long entryId = ParamUtil.getLong(request, "entryId");
        long guestbookId = ParamUtil.getLong(request, "guestbookId");

        ServiceContext serviceContext = ServiceContextFactory.getInstance(
            Entry.class.getName(), request);

        try {

            response.setRenderParameter(
                "guestbookId", Long.toString(guestbookId));

            _entryService.deleteEntry(entryId, serviceContext);
            SessionMessages.add(request, "entryDeleted");

        }

        catch (Exception e) {
            Logger.getLogger(GuestbookPortlet.class.getName()).log(
                Level.SEVERE, null, e);
            SessionErrors.add(request, e.getClass().getName());


        }
    }


    @Override
    public void render(
            RenderRequest renderRequest, RenderResponse renderResponse)
        throws IOException, PortletException {

        try {
            ServiceContext serviceContext = ServiceContextFactory.getInstance(
                Guestbook.class.getName(), renderRequest);

            long groupId = serviceContext.getScopeGroupId();

            long guestbookId = ParamUtil.getLong(renderRequest, "guestbookId");

            List<Guestbook> guestbooks = _guestbookService.getGuestbooks(
                groupId);

            if (guestbooks.isEmpty()) {
                Guestbook guestbook = _guestbookService.addGuestbook(
                    serviceContext.getUserId(), "Main", serviceContext);

                guestbookId = guestbook.getGuestbookId();
            }

            if (guestbookId == 0) {
                guestbookId = guestbooks.get(0).getGuestbookId();
            }

            renderRequest.setAttribute("guestbookId", guestbookId);
        }
        catch (Exception e) {
            throw new PortletException(e);
        }

        super.render(renderRequest, renderResponse);
    }


    @Reference(unbind = "-")
    protected void setEntryService(EntryService entryService) {
        _entryService = entryService;
    }

    @Reference(unbind = "-")
    protected void setGuestbookService(GuestbookService guestbookService) {
        _guestbookService = guestbookService;
    }

    private GuestbookService _guestbookService;
    private EntryService _entryService;


}
\end{verbatim}

To check that you haven't made a mistake in your
\texttt{GuestbookAdminPortlet} class, refer to the following complete
class:

\begin{verbatim}
package com.liferay.docs.guestbook.portlet;

import java.util.logging.Level;
import java.util.logging.Logger;

import javax.portlet.ActionRequest;
import javax.portlet.ActionResponse;
import javax.portlet.Portlet;

import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Reference;

import com.liferay.docs.guestbook.model.Guestbook;
import com.liferay.docs.guestbook.portlet.constants.GuestbookPortletKeys;
import com.liferay.docs.guestbook.service.GuestbookService;
import com.liferay.portal.kernel.exception.PortalException;
import com.liferay.portal.kernel.portlet.bridges.mvc.MVCPortlet;
import com.liferay.portal.kernel.service.ServiceContext;
import com.liferay.portal.kernel.service.ServiceContextFactory;
import com.liferay.portal.kernel.servlet.SessionErrors;
import com.liferay.portal.kernel.servlet.SessionMessages;
import com.liferay.portal.kernel.util.ParamUtil;

@Component(
    immediate = true,
    property = {
            "com.liferay.portlet.display-category=category.hidden",
            "com.liferay.portlet.scopeable=true",
            "javax.portlet.display-name=Guestbooks",
            "javax.portlet.expiration-cache=0",
            "javax.portlet.init-param.portlet-title-based-navigation=true",
            "javax.portlet.init-param.template-path=/",
            "javax.portlet.init-param.view-template=/guestbookadminportlet/view.jsp",
            "javax.portlet.name=" + GuestbookPortletKeys.GUESTBOOK_ADMIN,
            "javax.portlet.resource-bundle=content.Language",
            "javax.portlet.security-role-ref=administrator",
            "javax.portlet.supports.mime-type=text/html",
            "com.liferay.portlet.add-default-resource=true"
    },
    service = Portlet.class
)
public class GuestbookAdminPortlet extends MVCPortlet {

    public void addGuestbook(ActionRequest request, ActionResponse response)
            throws PortalException {

            ServiceContext serviceContext = ServiceContextFactory.getInstance(
              Guestbook.class.getName(), request);

            String name = ParamUtil.getString(request, "name");

            try {
              _guestbookService.addGuestbook(
                serviceContext.getUserId(), name, serviceContext);
              SessionMessages.add(request, "guestbookAdded");

            }
            catch (PortalException e) {

            Logger.getLogger(GuestbookAdminPortlet.class.getName()).log(
              Level.SEVERE, null, e);
            SessionErrors.add(request, e.getClass().getName());


              response.setRenderParameter(
                "mvcPath", "/guestbookadminportlet/edit_guestbook.jsp");
            }
          }

    public void updateGuestbook(ActionRequest request, ActionResponse response)
            throws PortalException {

            ServiceContext serviceContext = ServiceContextFactory.getInstance(
              Guestbook.class.getName(), request);

            String name = ParamUtil.getString(request, "name");
            long guestbookId = ParamUtil.getLong(request, "guestbookId");

            try {
              _guestbookService.updateGuestbook(
                serviceContext.getUserId(), guestbookId, name, serviceContext);
              SessionMessages.add(request, "guestbookUpdated");


            } catch (PortalException e) {

              Logger.getLogger(GuestbookAdminPortlet.class.getName()).log(
              Level.SEVERE, null, e);
              SessionErrors.add(request, e.getClass().getName());


              response.setRenderParameter(
                "mvcPath", "/guestbookadminportlet/edit_guestbook.jsp");
            }
          }

    public void deleteGuestbook(ActionRequest request, ActionResponse response)
            throws PortalException {

            ServiceContext serviceContext = ServiceContextFactory.getInstance(
              Guestbook.class.getName(), request);

            long guestbookId = ParamUtil.getLong(request, "guestbookId");

            try {
              _guestbookService.deleteGuestbook(guestbookId, serviceContext);
              SessionMessages.add(request, "guestbookDeleted");


            }
            catch (PortalException e) {

              Logger.getLogger(GuestbookAdminPortlet.class.getName()).log(
                  Level.SEVERE, null, e);
              SessionErrors.add(request, e.getClass().getName());


            }
          }


          private GuestbookService _guestbookService;

          @Reference(unbind = "-")
          protected void setGuestbookService(GuestbookService guestbookService) {
          _guestbookService = guestbookService;

          }


}
\end{verbatim}

Now that you've implemented permission checks at the portlet layer,
users without the proper permissions can't add, update, or delete a
guestbook or guestbook entry entity. Even if a user manually entered a
URL pointing to one of your portlet action methods, the portlet action
now calls a remote service. The permission check in the remote service
aborts the unauthorized user's request. Excellent work on securing your
application's services!

From here, you can diverge. The later steps of this Learning Path (some
still in progress) introduce you to other parts of Liferay DXP's
development framework: workflow, the Recycle Bin, Lexicon, Friendly
URLs, Staging and import/export, the Message Bus, and distributing your
application on Marketplace. If you're interested in these topics,
continue. But there's also another option.

Now that you've implemented web services, you can create a mobile
Guestbook app with Liferay Screens. That Learning Path is available from
the navigation on the left.

\chapter{Using Workflow}\label{using-workflow}

The Guestbook application accepts submissions from any logged in user,
so there's no telling what people could post. Illegal data,
objectionable content, the entire contents of Don Quixote: all of these
and more are possibilities. You can make sure user posts don't run afoul
of the law or policy by enabling \emph{workflow} in your application.

Workflow is a review process that ensures a submitted entity isn't
published before it's reviewed. To prevent posting objectionable
content, an initially submitted Guestbook entry should be marked as a
\emph{draft} and sent through the workflow framework. It comes back to
the application code ready to have any relevant fields updated in the
database based on its status. The view layer must filter entities by
status to display only reviewed entities.

\noindent\hrulefill

\textbf{Note:} The exact review process is defined separately from the
code that enables workflow. An XML file provides the definition of a
workflow in Liferay DXP. If you're a Liferay Digital Enterprise
subscriber, you have access to the Kaleo Workflow Designer, which offers
a convenient drag-and-drop user interface for designing workflow
definition files. You can read more about this in Liferay DXP's
\href{https://help.liferay.com/hc/en-us/articles/360017876972-Kaleo-Designer}{documentation}.
Liferay DXP comes with a workflow definition called the \emph{Single
Approver} definition, but you can write your own workflow definitions
according to your organization's requirements.

A few additional definitions are included in Liferay DXP's source code,
which you can use to see how workflow definitions are defined. To
discover how to access these files, see
\href{/docs/7-0/user/-/knowledge_base/u/enabling-workflow}{here}.

\noindent\hrulefill

This section instructs the reader in workflow-enabling the Guestbook
App's \texttt{Guestbook} and \texttt{Entry} entities to ensure that only
approved content is published after review.

\begin{figure}
\centering
\includegraphics{./images/workflow-config.png}
\caption{Enable workflow in your assets, just like Liferay DXP's own
assets.}
\end{figure}

There are five steps to enabling workflow:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Update the service layer to set each entity's status fields.
\item
  Send the entity to Liferay DXP's workflow framework.
\item
  Add \emph{getter} methods that account for an entity's workflow
  status.
\item
  Handle the entity as it returns from the workflow framework.
\item
  Update the user interface to account for workflow status.
\end{enumerate}

The first three steps happen in the service layer, so that's a good
place to start.

Let's Go!{}

\chapter{Supporting Workflow at the Service
Layer}\label{supporting-workflow-at-the-service-layer}

When you
\href{/docs/7-0/tutorials/-/knowledge_base/t/assets-integrating-with-liferays-framework}{asset
enabled the Guestbook Application}, you added four database columns in
the Guestbook entities (e.g., \texttt{GB\_Entry}) that keep track of
workflow status (they're already added; celebrate!). The necessary
fields are \texttt{status}, \texttt{statusByUserName},
\texttt{statusByUserId}, and \texttt{statusDate}. The columns are
defined in the \texttt{guestbook-service} module's \texttt{service.xml}
file.

\begin{verbatim}
<column name="status" type="int" />
<column name="statusByUserId" type="long" />
<column name="statusByUserName" type="String" />
<column name="statusDate" type="Date" />
\end{verbatim}

The \texttt{status} field tells you the current status of the entity (it
defaults to \texttt{0}, which evaluates to \emph{approved}). The other
status fields store the date of the last change (\texttt{statusDate})
along with the ID and name of the user (\texttt{statusByUserId} and
\texttt{statusByUserName}) who made the update.

Although the status columns are in the Guestbook application's entity
tables, you must update the local service implementation's \texttt{add}
methods to set them, and while you're there, send the entity to the
workflow framework. You'll also write a method to update the status
fields when the entity returns from the workflow framework, along with
getters that take workflow status as a parameter. That sounds like a lot
of work, but thanks to Service Builder, you must change only three
files: \texttt{service.xml}, \texttt{GuestbookLocalServiceImpl}, and
\texttt{EntryLocalServiceImpl}.

Let's Go!{}

\section{Setting the Guestbook
Status}\label{setting-the-guestbook-status}

\begin{verbatim}
<p>Supporting Workflow at the Service Layer<br>Step 1 of 3</p>
\end{verbatim}

Before now, you set the status of all added guestbooks to approved in
the service layer. Now you'll set it to draft and pass it to the
workflow framework.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  From \texttt{guestbook-service}, open
  \texttt{GuestbookLocalServiceImpl} and add the status fields below the
  existing setter methods in the \texttt{addGuestbook} method:

\begin{verbatim}
guestbook.setStatus(WorkflowConstants.STATUS_DRAFT);
guestbook.setStatusByUserId(userId);
guestbook.setStatusByUserName(user.getFullName());
guestbook.setStatusDate(serviceContext.getModifiedDate(null));
\end{verbatim}

  This manually populates the status fields and sets the workflow status
  as a draft in the \texttt{GB\_Entry} database table. At this point
  they're identical to the similarly named non-status counterparts (like
  \texttt{setUserId} and \texttt{setStatusByUserId}), but they'll be
  updated independently in the \texttt{updateStatus} method you write
  later.
\item
  Still in the \texttt{addGuestbook} method, place the following code
  right before the \texttt{return} statement:

\begin{verbatim}
WorkflowHandlerRegistryUtil.startWorkflowInstance(guestbook.getCompanyId(), 
            guestbook.getGroupId(), guestbook.getUserId(), Guestbook.class.getName(), 
            guestbook.getPrimaryKey(), guestbook, serviceContext);
\end{verbatim}

  The call to \texttt{startWorkflowInstance} detects whether workflow is
  installed and enabled. If it isn't, the added entity is automatically
  marked as approved. The \texttt{startWorkflowInstance} call also calls
  your \texttt{GuestbookWorkflowHandler} class, which you'll create
  later.
\item
  Organize imports (\emph{{[}CTRL{]}+{[}SHIFT{]}+O}), and save your
  work.
\end{enumerate}

The \texttt{startWorkflowInstance} method is where your entity enters
the workflow framework, but you're not finished yet. Just like you
wouldn't drop your child off at college and then change your number and
move to a new address, you're not going to abandon your
\texttt{Guestbook} entity (yet).

Exert control over how the status fields are updated in the database.
Create an \texttt{updateStatus} method in
\texttt{GuestbookLocalServiceImpl}, immediately following the
\texttt{deleteGuestbook} method. Here's the first half of it:

\begin{verbatim}
 public Guestbook updateStatus(long userId, long guestbookId, int status,
        ServiceContext serviceContext) throws PortalException,
        SystemException {

    User user = userLocalService.getUser(userId);
    Guestbook guestbook = getGuestbook(guestbookId);

    guestbook.setStatus(status);
    guestbook.setStatusByUserId(userId);
    guestbook.setStatusByUserName(user.getFullName());
    guestbook.setStatusDate(new Date());

    guestbookPersistence.update(guestbook);
\end{verbatim}

If this method is called, it's because your entity is returning from the
workflow framework, and it's time to update the status values in the
database. Set the status fields, then persist the updated entity to the
database. Before saving, finish the method:

\begin{verbatim}
    if (status == WorkflowConstants.STATUS_APPROVED) {

        assetEntryLocalService.updateVisible(Guestbook.class.getName(),
                guestbookId, true);

    } else {

        assetEntryLocalService.updateVisible(Guestbook.class.getName(),
                guestbookId, false);
    }

    return guestbook;
}
\end{verbatim}

This \texttt{if} statement determines the visibility of the asset based
on its workflow status. If it's approved, the
\texttt{assetEntryLocalService.updateVisible} method sets the guestbook
in question to \texttt{true} so it can be displayed in the Asset
Publisher and in the search results. Otherwise (\texttt{else}) it sets
the visibility to \texttt{false} to ensure that unapproved guestbooks
aren't displayed to users in the Asset Publisher or the Search portlet.

Organize imports (\emph{{[}CTRL{]}+{[}SHIFT{]}+O}) and save your work.
Then run the \texttt{buildService} Gradle task.

There's one more update to make in the \texttt{deleteGuestbook} method.
When deleting, you must clean up the workflow system's database tables
to avoid leaving orphaned entries when the backing entity is deleted.
Before making the method call, open \texttt{service.xml} and add the
following tag below the existing
\texttt{\textless{}reference\textgreater{}} tags:

\begin{verbatim}
<reference entity="WorkflowInstanceLink" package-path="com.liferay.portal" />
\end{verbatim}

Save and run Service Builder. It injects the
\texttt{WorkflowInstanceLinkLocalService} service into a protected
variable in \texttt{GuesbookLocalServiceBaseImpl}. Since
\texttt{GuestbookLocalServiceImpl} extends the base class, you can use
it directly. Back in \texttt{GuesbookLocalServiceImpl}, find the
\texttt{deleteGuestbook} method and put this method call right before
the \texttt{return} statement:

\begin{verbatim}
workflowInstanceLinkLocalService.deleteWorkflowInstanceLinks(
    guestbook.getCompanyId(), guestbook.getGroupId(),
    Guestbook.class.getName(), guestbook.getGuestbookId());
\end{verbatim}

Save the file and run \emph{Refresh Gradle Project}. Now the guestbook
entity's service layer populates the status fields in the database,
sends the entity into the workflow framework, and cleans up when it's
deleted. You'll do the same thing for guestbook entries next.

\section{Setting the Entry Workflow
Status}\label{setting-the-entry-workflow-status}

\begin{verbatim}
<p>Supporting Workflow at the Service Layer<br>Step 2 of 3</p>
\end{verbatim}

Now you'll set the status fields, introduce entries to the workflow
framework, and add the \texttt{updateStatus} method to
\texttt{EntryLocalServiceImpl}. It works the same as it did for
guestbooks.

Add the following lines in the \texttt{addEntry} method, immediately
after the current setter methods (e.g.,
\texttt{entry.setMessage(message)}):

\begin{verbatim}
entry.setStatus(WorkflowConstants.STATUS_DRAFT);
entry.setStatusByUserId(userId);
entry.setStatusByUserName(user.getFullName());
entry.setStatusDate(serviceContext.getModifiedDate(null));
\end{verbatim}

Still in the \texttt{addEntry} method, place the following code right
before the \texttt{return} statement:

\begin{verbatim}
WorkflowHandlerRegistryUtil.startWorkflowInstance(entry.getCompanyId(), 
            entry.getGroupId(), entry.getUserId(), Entry.class.getName(), 
            entry.getPrimaryKey(), entry, serviceContext);
\end{verbatim}

The \texttt{startWorkflowInstance} call eventually directs the workflow
processing to your \texttt{EntryWorkflowHandler} class, which you'll
create later. That class is responsible for making sure the entity is
updated in the database (via an \texttt{updateStatus} method), but it's
best practice to make persistence calls in the service layer. Thus
you'll need a corresponding \texttt{updateStatus} method here in
\texttt{EntryLocalServiceImpl}. Add this method to the bottom of the
class:

\begin{verbatim}
 public Entry updateStatus(long userId, long guestbookId, long entryId, int status,
        ServiceContext serviceContext) throws PortalException,
        SystemException {

    User user = userLocalService.getUser(userId);
    Entry entry = getEntry(entryId);

    entry.setStatus(status);
    entry.setStatusByUserId(userId);
    entry.setStatusByUserName(user.getFullName());
    entry.setStatusDate(new Date());

    entryPersistence.update(entry);

    if (status == WorkflowConstants.STATUS_APPROVED) {

        assetEntryLocalService.updateVisible(Entry.class.getName(),
                entryId, true);

    } else {

        assetEntryLocalService.updateVisible(Entry.class.getName(),
                entryId, false);
    }

    return entry;
}
\end{verbatim}

Organize imports (\emph{{[}CTRL{]}+{[}SHIFT{]}+O}), save your work, and
run Service Builder.

As with Guestbooks, you must add a call to
\texttt{deleteWorkflowInstanceLinks} in the entry's delete method to
avoid leaving orphaned database entries in the
\texttt{workflowinstancelinks} table. First add the following
\texttt{\textless{}reference\textgreater{}} tag to \texttt{service.xml},
this time in the \texttt{entry} entity section, below the existing
reference tags:

\begin{verbatim}
<reference entity="WorkflowInstanceLink" package-path="com.liferay.portal" />
\end{verbatim}

Save, run Service Builder, and then add the following method call to the
\texttt{deleteEntry} method in \texttt{EntryLocalServiceImpl}, right
before the \texttt{return} statement:

\begin{verbatim}
workflowInstanceLinkLocalService.deleteWorkflowInstanceLinks(
    entry.getCompanyId(), entry.getGroupId(),
    Entry.class.getName(), entry.getEntryId());
\end{verbatim}

Now both entities support the status of the entity and can handle it as
it enters the workflow framework and as it returns from the workflow
framework. There's one more update to make in the local service
implementation classes: adding getter methods that take the status as a
parameter. Later you'll use these methods in the view layer so you can
display only approved guestbooks and entries.

\section{Retrieving Guestbooks and Entries by
Status}\label{retrieving-guestbooks-and-entries-by-status}

\begin{verbatim}
<p>Supporting Workflow at the Service Layer<br>Step 3 of 3</p>
\end{verbatim}

The service implementation for both entities now supports adding the
status fields to the database tables. There's one more update to make in
the service layer, but to understand why, you must think about the view
layer. When the Guestbook portlet displays entries, you must make sure
it doesn't show entries that haven't been approved. Currently, the
entry's view layer shows all guestbooks:

\begin{verbatim}
    List<Guestbook> guestbooks = GuestbookLocalServiceUtil
                .getGuestbooks(scopeGroupId);
\end{verbatim}

There's a problem: the getter only takes the \texttt{scopeGroupId} as a
parameter, so there's no way to get guestbooks by their status.

Likewise, unapproved entries must not be displayed, but the view layer
currently gets all entries:

\begin{verbatim}
    <liferay-ui:search-container total="<%=EntryLocalServiceUtil.getEntriesCount()%>">
    <liferay-ui:search-container-results
        results="<%=EntryLocalServiceUtil.getEntries(scopeGroupId.longValue(),
                        guestbookId, searchContainer.getStart(),
                        searchContainer.getEnd())%>" />
\end{verbatim}

The solution is to implement for guestbooks and entries a getter that
takes the \texttt{status} field as a parameter. Thankfully, Service
Builder makes it easy.

Open the \texttt{guestbook-service} module's \texttt{service.xml} file.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  For the entry entity, remove the following finder:

\begin{verbatim}
 <finder name="G_S" return-type="Collection">
   <finder-column name="groupId" />
   <finder-column name="status" />
 </finder>
\end{verbatim}
\item
  Add this finder in its place:

\begin{verbatim}
 <finder name="G_G_S" return-type="Collection">
   <finder-column name="groupId" />
   <finder-column name="guestbookId" />
   <finder-column name="status" />
 </finder>
\end{verbatim}
\end{enumerate}

Run service builder (double-click
\texttt{guestbook-service/build/buildService} in the Gradle Tasks pane
of IDE). Service Builder generates finder methods in the persistence
layer that take the specified fields (for example, \texttt{status}) as
parameters.

Don't call the persistence layer directly in the application code.
Instead expose the new persistence methods in the service layer.

Open \texttt{GuesbookLocalServiceImpl} and add this getter:

\begin{verbatim}
public List<Guestbook> getGuestbooks(long groupId, int status)
    throws SystemException {
    
    return guestbookPersistence.findByG_S(
        groupId, WorkflowConstants.STATUS_APPROVED);
}
\end{verbatim}

This getter gets only approved guestbooks. That's why you hard code the
workflow constant \texttt{STATUS\_APPROVED} into the status parameter
when calling the persistence method. Now open
\texttt{EntryLocalServiceImpl} and add these two getters:

\begin{verbatim}
public List<Entry> getEntries(
    long groupId, long guestbookId, int status, int start, int end)
    throws SystemException {

    return entryPersistence.findByG_G_S(
        groupId, guestbookId, WorkflowConstants.STATUS_APPROVED);
}

public int getEntriesCount(
    long groupId, long guestbookId, int status)
    throws SystemException {

    return entryPersistence.countByG_G_S(
        groupId, guestbookId, WorkflowConstants.STATUS_APPROVED);
}
\end{verbatim}

You'll replace the existing methods with these \texttt{getEntries} and
\texttt{getEntriesCount} methods in the view layer, ensuring that only
approved entries are displayed.

The work here relates to the UI updates you'll make later. Next,
implement workflow handlers so that you can call the
\texttt{updateStatus} service method when the entity returns from the
workflow framework.

\chapter{Handling Workflow}\label{handling-workflow}

The guestbook project's service layer is now updated to handle workflow.
It now properly sets the status fields for guestbooks and guestbook
entries, gets entities by their statuses, and sends entities to Liferay
DXP's workflow framework whenever the \texttt{addGuestbook} or
\texttt{addEntry} methods are called. Recall that you still have an
uncalled service method, \texttt{updateStatus}, for both entities. In
this section you'll implement workflow handlers, classes that interact
with Liferay DXP's workflow framework and your service layer (by calling
\texttt{updateStatus} on the appropriate entity).

There's a handy abstract class you can extend to make the job easier,
called \texttt{BaseWorkflowHandler}. You'll do this next for both
entities of the guestbook project, starting with guestbooks.

Let's Go!{}

\section{Creating a Workflow Handler for
Guestbooks}\label{creating-a-workflow-handler-for-guestbooks}

\begin{verbatim}
<p>Handling Workflow<br>Step 1 of 2</p>
\end{verbatim}

Each workflow enabled entity needs a \texttt{WorkflowHandler}. Create a
new package in the \texttt{guestboook-service} module called
\texttt{com.liferay.docs.guestbook.workflow}, then create the
\texttt{GuestbokWorkflowHandler} class in it. Extend
\texttt{BaseWorkflowHandler} and pass in \texttt{Guestbook} as the type
parameter:

\begin{verbatim}
public class GuestbookWorkflowHandler extends BaseWorkflowHandler<Guestbook> {
\end{verbatim}

Make it a Component class:

\begin{verbatim}
@Component(immediate = true, service = WorkflowHandler.class)
\end{verbatim}

There are three abstract methods to implement: \texttt{getClassName},
\texttt{getType}, and \texttt{updateStatus}.

\begin{verbatim}
    @Override
    public String getClassName() {
        return Guestbook.class.getName();
    }
\end{verbatim}

\texttt{getClassName} returns the guestbook entity's fully qualified
class name (\texttt{com.liferay.docs.guestbook.model.Guestbook}).

\begin{verbatim}
    @Override
    public String getType(Locale locale) {
        return _resourceActions.getModelResource(locale, getClassName());
    }
\end{verbatim}

\texttt{getType} returns the model resource name
(\texttt{model.resource.com.liferay.docs.guestbook.model.Guestbook}).
The meat of the workflow handler is in the \texttt{updateStatus} method:

\begin{verbatim}
    @Override
    public Guestbook updateStatus(
            int status, Map<String, Serializable> workflowContext)
        throws PortalException {

        long userId = GetterUtil.getLong(
            (String)workflowContext.get(WorkflowConstants.CONTEXT_USER_ID));
        long resourcePrimKey = GetterUtil.getLong(
            (String)workflowContext.get(
                WorkflowConstants.CONTEXT_ENTRY_CLASS_PK));

        ServiceContext serviceContext = (ServiceContext)workflowContext.get(
            "serviceContext");

        return _guestbookLocalService.updateStatus(
            userId, resourcePrimKey, status, serviceContext);
    }
\end{verbatim}

When you crafted the service layer's \texttt{updateStatus} method (see
the last section for more details), you specified parameters that must
be passed to the method. Here you're making sure that those parameters
are available to pass to the service call. Get the \texttt{userId} and
\texttt{resourcePrimKey} from \texttt{GetterUtil}. Its \texttt{getLong}
method takes a \texttt{String}, which you can get from the
\texttt{workflowContext} \texttt{Map} using \texttt{WorkflowConstants}
for the context user ID and the context entry class PK.

Make sure you inject the \texttt{ResourceActions} service into a private
variable at the end of the class, using the \texttt{@Reference}
annotation:

\begin{verbatim}
    @Reference(unbind = "-")
    protected void setResourceActions(ResourceActions resourceActions) {

        _resourceActions = resourceActions;
    }

    private ResourceActions _resourceActions;
\end{verbatim}

Inject a \texttt{GuestbookLocalService} into a private variable using
the \texttt{@Reference} annotation.

\begin{verbatim}
    @Reference(unbind = "-")
    protected void setGuestbookLocalService(
        GuestbookLocalService guestbookLocalService) {

        _guestbookLocalService = guestbookLocalService;
    }

    private GuestbookLocalService _guestbookLocalService;

}
\end{verbatim}

Organize imports (\emph{{[}CTRL{]}+{[}SHIFT{]}+O}) and save your work.

Now the Guestbook Application updates the database with the necessary
status information, interacting with Liferay's workflow classes to make
sure each entity is properly handled by Liferay DXP. At this point you
can enable workflow for the Guestbook inside Liferay DXP and see how it
works. Navigate to \emph{Control Panel → Workflow Configuration}. The
Guestbook entity appears among Liferay DXP's native entities. Enable the
Single Approver Workflow for Guestbooks; then go to the Guestbook Admin
portlet and add a new Guestbook. A notification appears next to your
user name in the product menu. You receive a notification from the
workflow that a task is ready for review. Click it, and you're taken to
the My Workflow Tasks portlet, where you can complete the review task.

\begin{figure}
\centering
\includegraphics{./images/workflow-notification.png}
\caption{Click the workflow notification in the Notifications portlet to
review the guestbook submitted to the workflow.}
\end{figure}

To complete the review, click the actions button
(\includegraphics{./images/icon-actions.png}) from My Workflow
Tasks and select \emph{Assign to Me}. Click the actions button again and
select \emph{Approve}.

\begin{figure}
\centering
\includegraphics{./images/workflow-assign-to-me.png}
\caption{Click the workflow notification in the Notifications portlet to
review the guestbook submitted to the workflow.}
\end{figure}

Right now the workflow process for guestbooks is functional, but the UI
isn't adapted for it. You'll write the workflow handler for guestbook
entries next, and then update the UI to account for each entity's
workflow status.

\section{Creating a Workflow Handler for Guestbook
Entries}\label{creating-a-workflow-handler-for-guestbook-entries}

\begin{verbatim}
<p>Handling Workflow<br>Step 2 of 2</p>
\end{verbatim}

The entry's workflow handler is almost identical to the guestbook's.
Create a new class in the \texttt{com.liferay.docs.guestbook.workflow}
package of the \texttt{guestbook-service} module. Name it
\texttt{EntryWorkflowHandler} and extend \texttt{BaseWorkflowHandler}.
Decorate it with a Component annotation and implement the same three
methods you implemented in the \texttt{GuestbookWorkflowHandler}. Paste
this in as the class body:

\begin{verbatim}
@Component(immediate = true, service = WorkflowHandler.class)
public class EntryWorkflowHandler extends BaseWorkflowHandler<Entry> {

    @Override
    public String getClassName() {

        return Entry.class.getName();

    }

    @Override
    public String getType(Locale locale) {

        return _resourceActions.getModelResource(locale, getClassName());

    }

    @Override
    public Entry updateStatus(
        int status, Map<String, Serializable> workflowContext)
        throws PortalException {

        long userId = GetterUtil.getLong(
            (String) workflowContext.get(WorkflowConstants.CONTEXT_USER_ID));
        long resourcePrimKey = GetterUtil.getLong(
            (String) workflowContext.get(
                WorkflowConstants.CONTEXT_ENTRY_CLASS_PK));

        ServiceContext serviceContext =
            (ServiceContext) workflowContext.get("serviceContext");

        long guestbookId =
            _entryLocalService.getEntry(resourcePrimKey).getGuestbookId();
        
        return _entryLocalService.updateStatus(
            userId, guestbookId, resourcePrimKey, status, serviceContext);
    }

    @Reference(unbind = "-")
    protected void setEntryLocalService(EntryLocalService entryLocalService) {

        _entryLocalService = entryLocalService;
    }

    @Reference(unbind = "-")
    protected void setResourceActions(ResourceActions resourceActions) {

        _resourceActions = resourceActions;
    }

    private EntryLocalService _entryLocalService;
    private ResourceActions _resourceActions;
}
\end{verbatim}

There is nothing unique about this code as compared with the guestbook's
workflow handler, except that we need the \texttt{gustbookId} for the
entry. That's easily obtained by getting the \texttt{Entry} object with
\texttt{entryLocalService}, then getting its \texttt{guestbookId}. See
the last article for the rest of the handler's implementation details.

Organize imports with \emph{CTRL+SHIFT+O} and save the file.

The back-end of the guestbook project is fully workflow enabled. All
that's left is to update the Guestbook Application's UI to handle
workflow status.

\chapter{Displaying Approved Workflow
Items}\label{displaying-approved-workflow-items}

There's not much left to do. Both entities in the guestbook project's
back-end are workflow enabled, so it's time to update the UI. The
Guestbook Admin portlet and the Guestbook portlet each requires its own
display strategy.

The Guestbook Admin application is accessed by administrators, so it can
display all guestbooks that have been submitted, even if they're not
marked as approved. However, adding a \emph{Status} field to the search
container makes sense. That way admins can see which guestbooks are
already approved, which are drafts, which are pending, etc.

The Guestbook application is meant to be viewed by site members and even
guests (unauthenticated users of your site). Here it's smart to display
only approved guestbooks and approved entries.

Start by updating the Guestbook Admin UI.

Let's Go!{}

\section{Displaying Guestbook Status}\label{displaying-guestbook-status}

\begin{verbatim}
<p>Displaying Approved Workflow Items<br>Step 1 of 2</p>
\end{verbatim}

The Guestbook Admin application's main view currently has a search
container with two columns: the guestbook name and the guestbook actions
button.

\begin{figure}
\centering
\includegraphics{./images/lp-workflow-admin-nostatus.png}
\caption{The Guestbook Admin's main view currently shows the name of the
guestbook and its actions button.}
\end{figure}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add a third column between the two existing ones: call it
  \emph{Status}. Open

\begin{verbatim}
guestbook-web/src/main/reosurces/META-INF/resources/guestbookadminportlet/view.jsp
\end{verbatim}
\item
  Find the existing \texttt{search-container-column} definitions:

\begin{verbatim}
<liferay-ui:search-container-column-text property="name" />

<liferay-ui:search-container-column-jsp align="right"
    path="/guestbookadminportlet/guestbook_actions.jsp" />
\end{verbatim}
\item
  Put the following new column between the existing columns:

\begin{verbatim}
<liferay-ui:search-container-column-status property="status" />
\end{verbatim}
\end{enumerate}

Save the file and wait for the \texttt{web} module to redeploy. With the
addition of one line in the JSP, the Guestbook Admin application now
displays the guestbook's workflow status.

\begin{figure}
\centering
\includegraphics{./images/lp-workflow-admin-status.png}
\caption{The Guestbook Admin's main view, displaying the status of each
guestbook.}
\end{figure}

Now move on to the Guestbook application's view layer.

\section{Displaying Approved Entries}\label{displaying-approved-entries}

\begin{verbatim}
<p>Displaying Approved Workflow Items<br>Step 2 of 2</p>
\end{verbatim}

The Guestbook application needs to be updated so that only guestbooks
and entries with a status of \emph{approved} appear in the UI.

Change the getters used to retrieve both entities in the view layer.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  You need a new import, so first open

\begin{verbatim}
guestbook-web/src/main/resources/META-INF/resources/init.jsp
\end{verbatim}

  and add this line:

\begin{verbatim}
<%@ page import="com.liferay.portal.kernel.workflow.WorkflowConstants"%>
\end{verbatim}
\item
  Now open

\begin{verbatim}
guestbook-web/src/main/resources/META-INF/resources/guestbookwebportlet/view.jsp
\end{verbatim}

  Find the scriptlet that retrieves guestbooks:

\begin{verbatim}
<%
    List<Guestbook> guestbooks = GuestbookLocalServiceUtil
                .getGuestbooks(scopeGroupId);
        for (int i = 0; i < guestbooks.size(); i++) {
            Guestbook curGuestbook = (Guestbook) guestbooks.get(i);
            String cssClass = StringPool.BLANK;
            if (curGuestbook.getGuestbookId() == guestbookId) {
                cssClass = "active";
            }
            if (GuestbookPermission.contains(
                permissionChecker, curGuestbook.getGuestbookId(), "VIEW")) {

%>
\end{verbatim}

  Change it so it calls the getter you added that takes workflow status
  into account. All you need to do is change this method call

\begin{verbatim}
List<Guestbook> guestbooks = GuestbookLocalServiceUtil
            .getGuestbooks(scopeGroupId);
\end{verbatim}

  to

\begin{verbatim}
List<Guestbook> guestbooks = GuestbookLocalServiceUtil
            .getGuestbooks(scopeGroupId, WorkflowConstants.STATUS_APPROVED);
\end{verbatim}

  Save the file, and now only approved guestbooks are displayed in the
  Guestbook application.
\item
  Next, update the entry's UI in the same \texttt{view.jsp}. Find the
  tags that set the search container's total and its results:

\begin{verbatim}
<liferay-ui:search-container total="<%=EntryLocalServiceUtil.
                getEntriesCount()%>">
<liferay-ui:search-container-results results=
                "<%=EntryLocalServiceUtil.getEntries
                (scopeGroupId.longValue(),
                guestbookId, searchContainer.getStart(),
                searchContainer.getEnd())%>" />
\end{verbatim}
\end{enumerate}

Replace the getters to use the ones that take workflow status as a
parameter, and pass \texttt{WorkflowConstants.STATUS\_APPROVED} as the
status. Here's what it looks like when you're finished:

\begin{verbatim}
<liferay-ui:search-container total="<%=EntryLocalServiceUtil.
                getEntriesCount(scopeGroupId.longValue(), 
                guestbookId, WorkflowConstants.STATUS_APPROVED)%>">
<liferay-ui:search-container-results results=
                "<%=EntryLocalServiceUtil.getEntries(
                scopeGroupId.longValue(), guestbookId, 
                WorkflowConstants.STATUS_APPROVED, 
                searchContainer.getStart(), searchContainer.getEnd())%>" />
\end{verbatim}

Now only approved entries are displayed, and the search container's
counter only counts the approved entries. If you update the
\texttt{getEntries} call but not the \texttt{getEntriesCount} call, the
count that's displayed includes approved entries and entries with any
other workflow status, and it won't match the total that's displayed at
the bottom of the search container.

\begin{figure}
\centering
\includegraphics{./images/lp-workflow-entries-count.png}
\caption{If you don't update the counter method to account for workflow
status, it displays an incorrect count in the search container.}
\end{figure}

Now Guestbooks and Entries are now fully workflow enabled, to the great
relief of the Lunar Resort's site administrators. You've saved them a
lot of headaches dealing with inappropriate content, primarily submitted
by visitors from Mars. Those Martians really need some lessons in
netiquette.

\chapter{Enabling Staging and
Export/Import}\label{enabling-staging-and-exportimport}

Your Guestbook application creates guestbooks and entries that are
immediately published when they're saved. Sites constantly change,
however, so it's crucial to have an area where updates can be planned
and tested before publishing to your audience. Staging enables changing
your Site behind the scenes without affecting the live Site. When you're
done, you can publish all the changes at once.

Next, you'll implement Staging support in your Guestbook app so its
entries can be tracked during the Staging phase of your publishing
process.

\begin{figure}
\centering
\includegraphics{./images/guestbook-staging.png}
\caption{Once Staging is implemented in your Guestbook app, you can have
its data tracked by the Staging framework.}
\end{figure}

\begin{figure}
\centering
\includegraphics{./images/guestbook-staging-page.png}
\caption{A Staging-enabled Guestbook app can be modified on the staged
site first without any users seeing it on the live Site.}
\end{figure}

Export/Import facilitates extracting data so it can be imported into
another Liferay DXP installation. Behind the scenes, Export/Import is
used during the Staging process. When publishing your staged content to
the live Site, you're essentially importing content from the staged Site
and exporting it to the live Site. Since the Export/Import framework is
programmatically similar to Staging, you can implement it with Staging.

Ready to support Staging in your Guestbook app?

Let's Go!{}

\section{Creating Staged Models}\label{creating-staged-models}

\begin{verbatim}
<p>Enabling Staging and Export/Import<br>Step 1 of 7</p>
\end{verbatim}

To implement the Staging framework, you must first specify the entities
you want to track. For the Guestbook application, there are two:
\texttt{Guestbook}s and \texttt{Entry}s. You can register these entities
so they're recognizable to the Staging framework by implementing the
\href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/model/StagedModel.html}{\texttt{StagedModel}}
interface in your Guestbook's model classes.

Service Builder generates an app's models as staged models when
\href{/docs/7-1/tutorials/-/knowledge_base/t/understanding-staged-models\#important-attributes-in-staging}{certain
attributes} are specified in the app's \texttt{service.xml} file. The
Guestbook app already defines many of the necessary attributes in its
\texttt{service.xml} file, so both your \texttt{GuestbookModel} and
\texttt{EntryModel} interfaces already extend the \texttt{StagedModel}
interface! For example, your Guestbook app's \texttt{EntryModel}
interface's declaration looks like this:

\begin{verbatim}
public interface EntryModel extends BaseModel<Entry>, GroupedModel, ShardedModel,
    StagedAuditedModel, WorkflowedModel {
\end{verbatim}

The \texttt{StagedModel} interface is implemented by the extension of
the
\href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/model/StagedAuditedModel.html}{\texttt{StagedAuditedModel}}
interface. Service Builder chose the \texttt{StagedAuditedModel}
interface based on the columns you declared. You'll update this later.

The following Staging-specific attributes/columns are currently defined
in the Guestbook app's \texttt{service.xml} file:

\begin{itemize}
\tightlist
\item
  \texttt{uuid} (required)
\item
  \texttt{groupId}
\item
  \texttt{companyId} (required)
\item
  \texttt{userId}
\item
  \texttt{userName}
\item
  \texttt{createDate} (required)
\item
  \texttt{modifiedDate} (required)
\end{itemize}

One of the most important attributes used by the Staging framework is
the UUID (Universally Unique Identifier). This attribute must be set to
\texttt{true} in \texttt{service.xml} for Service Builder to recognize
your model as an eligible staged model. The UUID can differentiate
entities between environments, because it's unique across multiple
systems.

The \texttt{companyId}, \texttt{createDate}, and \texttt{modifiedDate}
columns track the current entity's instance and creation/modification
dates.

The others leverage features of the Staging framework like automatic
group mapping or entity level Last Publish Date handling. See the
\href{/docs/7-0/tutorials/-/knowledge_base/t/understanding-staged-models}{Understanding
Staged Models} tutorial for more information.

Before adding Staging features to your Guestbook app, you must declare
some necessary dependencies.

\subsection{Declaring Staging
Dependencies}\label{declaring-staging-dependencies}

There are two Staging-specific dependencies used by the Guestbook's
Staging functionality.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open the \texttt{guestbook-service} module's \texttt{build.gradle}
  file.
\item
  Add the following dependencies within the \texttt{dependencies} block:

\begin{verbatim}
compileOnly group: "com.liferay", name: "com.liferay.exportimport.api", version: "2.1.0"
compileOnly group: "com.liferay", name: "com.liferay.xstream.configurator.api", version: "2.0.0"
\end{verbatim}
\item
  Save the file, right-click the Guestbook project, and run
  \emph{Gradle} → \emph{Refresh Gradle Project}.
\end{enumerate}

Now you're ready to begin implementing staging in your app.

\subsection{Updating the Extended Staged Model
Interface}\label{updating-the-extended-staged-model-interface}

Staged models that extend the \texttt{StagedAuditedModel} interface
function independently from the group concept (sometimes referred to as
company models). This means that, for example, your guestbook and
entry's scope would not be tracked by the Staging framework. You must
add one more column to your \texttt{service.xml} file to convert your
models to \texttt{StagedGroupedModel}s, so your entities' scope is
tracked correctly.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open your \texttt{guestbook-service} module's \texttt{service.xml}
  file and add the \texttt{lastPublishDate} column for both Guestbook
  and Entry entities:

\begin{verbatim}
<column name="lastPublishDate" type="Date" />
\end{verbatim}
\item
  Run Service Builder. Do this by navigating to the Gradle Tasks pane on
  the right side of IDE and selecting your project's \emph{build} →
  \emph{buildService} task.
\item
  Run \emph{Gradle} → \emph{Refresh Gradle Project} to resolve any
  remaining errors.
\end{enumerate}

Service Builder has updated your models to extend the
\texttt{StagedGroupedModel}. For example, your \texttt{EntryModel}
interface's declaration now looks like this:

\begin{verbatim}
public interface EntryModel extends BaseModel<Entry>, ShardedModel,
    StagedGroupedModel, WorkflowedModel {
\end{verbatim}

For more information on the available staged model interfaces, see this
\href{/docs/7-0/tutorials/-/knowledge_base/t/understanding-staged-models\#staged-model-interfaces}{tutorial}.

Excellent! Now it's time to create your staged model data handlers.

\section{Creating the Entry Staged Model Data
Handler}\label{creating-the-entry-staged-model-data-handler}

\begin{verbatim}
<p>Enabling Staging and Export/Import<br>Step 2 of 7</p>
\end{verbatim}

A Staged Model Data Handler supplies information about a staged model
(entity) to the Staging and Export/Import framework. Data handlers
replace the need to access the database directly and run queries to
export/import data.

You must create a staged model data handler for every entity you want
Staging to track. This means you must create a data handler for both
your guestbook and entry entities.

First, you'll create a staged model data handler for guestbook entries.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In your \texttt{guestbook-service} module, create a package named
  \texttt{com.liferay.docs.guestbook.exportimport.data.handler}.
\item
  In that package, create the \texttt{EntryStagedModelDataHandler} class
  and have it extend the
  \href{@platform-ref@/javadocs/portal-kernel/com/liferay/exportimport/kernel/lar/BaseStagedModelDataHandler.html}{\texttt{BaseStagedModelDataHandler\textless{}STAGED\_MODEL\textgreater{}}}
  class:

\begin{verbatim}
public class EntryStagedModelDataHandler
    extends BaseStagedModelDataHandler<Entry> {
\end{verbatim}
\item
  Add an \texttt{@Component} annotation above the class declaration to
  declare that the \texttt{EntryStagedModelDataHandler} class provides
  an implementation of the
  \href{@platform-ref@/javadocs/portal-kernel/com/liferay/exportimport/kernel/lar/StagedModelDataHandler.html}{\texttt{StagedModelDataHandler}}
  service:

\begin{verbatim}
@Component(
    immediate = true, 
    service = StagedModelDataHandler.class
)
\end{verbatim}
\item
  Set the staged model's local services you need in your data handler:

\begin{verbatim}
@Reference(unbind = "-")
protected void setEntryLocalService(EntryLocalService entryLocalService) {

    _entryLocalService = entryLocalService;
}

@Reference(unbind = "-")
protected void setGuestbookLocalService(
    GuestbookLocalService guestbookLocalService) {

    _guestbookLocalService = guestbookLocalService;
}

private EntryLocalService _entryLocalService;
private GuestbookLocalService _guestbookLocalService;
\end{verbatim}

  This injects the entry and guestbook's local services.
\item
  You must provide the class names of the models the data handler
  tracks. You can do this by overriding the
  \texttt{StagedModelDataHandler}'s \texttt{getClassNames()} method:

\begin{verbatim}
public static final String[] CLASS_NAMES = {Entry.class.getName()};

@Override
public String[] getClassNames() {
        return CLASS_NAMES;
}
\end{verbatim}

  As a best practice, you should have one staged model data handler per
  staged model. It's possible to use multiple class types, but this is
  not recommended.
\item
  Add a method that retrieves the staged model's display name:

\begin{verbatim}
@Override
public String getDisplayName(Entry entry) {
    return entry.getName();
}
\end{verbatim}

  The display name is presented with the progress bar during the
  export/import and publication processes.

  \begin{figure}
  \centering
  \includegraphics{./images/guestbook-staging-display-name.png}
  \caption{Your staged model data handler provides the display name in
  the Publish to Live UI.}
  \end{figure}
\item
  A staged model data handler should ensure everything required for its
  operation is also imported/exported. For example, an entry requires a
  guestbook. Therefore, the guestbook should be exported first followed
  by the entry.

  Add methods that import and export your staged model and its
  references.

\begin{verbatim}
@Override
protected void doExportStagedModel(
        PortletDataContext portletDataContext, Entry entry)
    throws Exception {

    Guestbook guestbook =
        _guestbookLocalService.getGuestbook(entry.getGuestbookId());

    StagedModelDataHandlerUtil.exportReferenceStagedModel(
        portletDataContext, entry, guestbook,
        PortletDataContext.REFERENCE_TYPE_PARENT);

    Element entryElement = portletDataContext.getExportDataElement(entry);

    portletDataContext.addClassedModel(
        entryElement, ExportImportPathUtil.getModelPath(entry), entry);
}

@Override
protected void doImportStagedModel(
        PortletDataContext portletDataContext, Entry entry)
    throws Exception {

    long userId = portletDataContext.getUserId(entry.getUserUuid());

    Map<Long, Long> guestbookIds =
        (Map<Long, Long>) portletDataContext.getNewPrimaryKeysMap(
            Guestbook.class);

    long guestbookId = MapUtil.getLong(
        guestbookIds, entry.getGuestbookId(), entry.getGuestbookId());

    Entry importedEntry = null;

    ServiceContext serviceContext =
        portletDataContext.createServiceContext(entry);

    if (portletDataContext.isDataStrategyMirror()) {
        Entry existingEntry = fetchStagedModelByUuidAndGroupId(
            entry.getUuid(), portletDataContext.getScopeGroupId());

        if (existingEntry == null) {
            serviceContext.setUuid(entry.getUuid());

            importedEntry = _entryLocalService.addEntry(
                userId, guestbookId, entry.getName(), entry.getEmail(),
                entry.getMessage(), serviceContext);
        }
        else {
            importedEntry = _entryLocalService.updateEntry(
                userId, guestbookId, existingEntry.getEntryId(),
                entry.getName(), entry.getEmail(), entry.getMessage(),
                serviceContext);
        }
    }
    else {
        importedEntry = _entryLocalService.addEntry(
            userId, guestbookId, entry.getName(), entry.getEmail(),
            entry.getMessage(), serviceContext);
    }

    portletDataContext.importClassedModel(entry, importedEntry);
}
\end{verbatim}

  The \texttt{doExportStagedModel} method retrieves the entry's data
  element from the \texttt{PortletDataContext} and then adds the class
  model characterized by that data element to the
  \texttt{PortletDataContext}. The \texttt{PortletDataContext} populates
  the
  \href{/docs/7-0/tutorials/-/knowledge_base/t/understanding-data-handlers\#liferay-archive-lar-file}{LAR
  file} with your application's data during the export process. Note
  that once an entity has been exported, subsequent calls to the export
  method don't repeat the export process multiple times, ensuring
  optimal performance.

  An important feature of the import process is that all exported
  reference elements are automatically imported when needed. The
  \texttt{doImportStagedModel} method does not need to import the
  reference elements manually; it must only find the new assigned ID for
  the guestbook before importing the entry.

  The \texttt{PortletDataContext} keeps this information and a slew of
  other data up-to-date during the import process. The code snippet
  shows how to access the old ID and new ID mapping, by using the
  \texttt{portletDataContext.getNewPrimaryKeysMap()} method. The method
  proceeds with checking the import mode (e.g., Copy As New or Mirror)
  and depending on the process configuration and existing environment,
  the entry is either added or updated.
\item
  When importing a LAR (i.e., publishing to the live Site), the import
  process expects all of an entity's references to be available and
  validates their existence.

  For example, if you republish an updated guestbook to the live Site
  and did not include some of its existing entries in the publication,
  these entries are considered missing references. A more practical
  example of this would be an image included in a web content article.
  If the image included in the web content lives on a different Site
  (i.e., the image is contained in a different group) or was not
  included in the publication process, it's considered a missing
  reference of the web content article.

  Since you're dealing with references on two separate Sites that have
  differing IDs, the system can't easily match them during publication.
  Consider this scenario for the Guestbook app; suppose you export a
  guestbook entry as a missing reference with a primary key (ID) of
  \texttt{1}. When importing that information, the LAR only provides the
  ID but not the entry itself. Therefore, during the import process, the
  Data Handler framework searches for the entry to replace by its UUID,
  but the entry to replace has a different ID (primary key) of
  \texttt{2}. You must provide a way to handle these missing references.

  To do this, you must add a method that maps the missing reference's
  primary key from the export to the existing primary key during import.
  Since the reference's UUID is constant across systems, it's used to
  complete the mapping of differing primary keys. Note that a reference
  can only be missing on the live Site if it has already been published
  previously. Therefore, when publishing a guestbook for the first time,
  the system doesn't check for missing references.

  Add this method to your class:

\begin{verbatim}
@Override
protected void doImportMissingReference(
    PortletDataContext portletDataContext, String uuid, long groupId,
    long entryId)
throws Exception {

    Entry existingEntry = fetchMissingReference(uuid, groupId);

    if (existingEntry == null) {
        return;
    }

    Map<Long, Long> entryIds =
        (Map<Long, Long>) portletDataContext.getNewPrimaryKeysMap(
        Entry.class);

    entryIds.put(entryId, existingEntry.getEntryId());
}
\end{verbatim}

  This method maps the existing staged model to the old ID in the
  reference element. When a reference is exported as missing, the Data
  Handler framework calls this method during the import process and
  updates the new primary key map in the portlet data context.
\item
  Provide a way for the staged model data handler to fetch your staged
  models:

\begin{verbatim}
@Override
public Entry fetchStagedModelByUuidAndGroupId(String uuid, long groupId) {

    return _entryLocalService.fetchEntryByUuidAndGroupId(uuid, groupId);
}

@Override
public List<Entry> fetchStagedModelsByUuidAndCompanyId(
    String uuid, long companyId) {

    return _entryLocalService.getEntriesByUuidAndCompanyId(
        uuid, companyId, QueryUtil.ALL_POS, QueryUtil.ALL_POS,
        new StagedModelModifiedDateComparator<Entry>());
}
\end{verbatim}

  These methods use the entry's local service to get the entries by UUID
  and company ID (i.e., portal instance's primary key) or group ID
  (i.e., Site, Organization, or User Group's primary key).
\item
  Override the \texttt{BaseStagedModelDataHandler}'s delete methods to
  leverage your newly created fetch method and custom local service:

\begin{verbatim}
@Override
public void deleteStagedModel(
        String uuid, long groupId, String className, String extraData)
    throws PortalException {

    Entry entry = fetchStagedModelByUuidAndGroupId(uuid, groupId);

    if (entry != null) {
        deleteStagedModel(entry);
    }

}

@Override
public void deleteStagedModel(Entry entry)
    throws PortalException {

    _entryLocalService.deleteEntry(entry);
}
\end{verbatim}

  These methods are necessary for the Staging framework to properly
  delete your entry staged models.
\item
  Organize your imports (\emph{{[}CTRL{]}+{[}SHIFT{]}+O}), and save the
  file.
\end{enumerate}

The entry's staged model data handler is complete! Next you can create
the guestbook's staged model data handler.

\section{Creating the Guestbook Staged Model Data
Handler}\label{creating-the-guestbook-staged-model-data-handler}

\begin{verbatim}
<p>Enabling Staging and Export/Import<br>Step 3 of 7</p>
\end{verbatim}

The guestbook's staged model data handler is similar to the entry's data
handler. Refer to the previous article for how this works.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In the \texttt{guestbook-service} module's
  \texttt{com.liferay.docs.guestbook.exportimport.data.handler} package,
  create the \texttt{GuestbookStagedModelDataHandler} class.
\item
  Declare
  \texttt{BaseStagedModelDataHandler\textless{}STAGED\_MODEL\textgreater{}}
  as your extension class and add the \texttt{@Component} declaration to
  declare \texttt{StagedModelDataHandler} as your implemented service:

\begin{verbatim}
@Component(
    immediate = true, 
    service = StagedModelDataHandler.class
)
public class GuestbookStagedModelDataHandler
    extends BaseStagedModelDataHandler<Guestbook> {
\end{verbatim}
\item
  Set the staged model's local service you want to leverage in your data
  handler:

\begin{verbatim}
@Reference(unbind = "-")
protected void setGuestbookLocalService(
    GuestbookLocalService guestbookLocalService) {

    _guestbookLocalService = guestbookLocalService;
}

private GuestbookLocalService _guestbookLocalService;
\end{verbatim}
\item
  Add the methods to retrieve the guestbook staged model's classes to
  track and display names:

\begin{verbatim}
public static final String[] CLASS_NAMES = {
    Guestbook.class.getName()
};

@Override
public String[] getClassNames() {

    return CLASS_NAMES;
}

@Override
public String getDisplayName(Guestbook guestbook) {

    return guestbook.getName();
}
\end{verbatim}
\item
  Add methods to ensure all import/export information is provided to the
  Staging framework for your guestbook entity:

\begin{verbatim}
@Override
protected void doExportStagedModel(
        PortletDataContext portletDataContext, Guestbook guestbook)
    throws Exception {

    Element guestbookElement =
        portletDataContext.getExportDataElement(guestbook);

    portletDataContext.addClassedModel(
        guestbookElement, ExportImportPathUtil.getModelPath(guestbook),
        guestbook);
}

@Override
protected void doImportStagedModel(
        PortletDataContext portletDataContext, Guestbook guestbook)
    throws Exception {

    long userId = portletDataContext.getUserId(guestbook.getUserUuid());

    Map<Long, Long> guestbookIds =
        (Map<Long, Long>) portletDataContext.getNewPrimaryKeysMap(
        Guestbook.class);

    long guestbookId = MapUtil.getLong(
        guestbookIds, guestbook.getGuestbookId(),
        guestbook.getGuestbookId());

    Guestbook importedGuestbook = null;

    ServiceContext serviceContext =
        portletDataContext.createServiceContext(guestbook);

    if (portletDataContext.isDataStrategyMirror()) {

        Guestbook existingGuestbook = fetchStagedModelByUuidAndGroupId(
            guestbook.getUuid(), portletDataContext.getScopeGroupId());

        if (existingGuestbook == null) {
            serviceContext.setUuid(guestbook.getUuid());

            importedGuestbook = _guestbookLocalService.addGuestbook(
                userId, guestbook.getName(), serviceContext);
        }
        else {
            importedGuestbook = _guestbookLocalService.updateGuestbook(
                userId, existingGuestbook.getGuestbookId(), guestbook.getName(), serviceContext);

        }
    }
    else {
        importedGuestbook = _guestbookLocalService.addGuestbook(
            userId, guestbook.getName(), serviceContext);
    }

    portletDataContext.importClassedModel(guestbook, importedGuestbook);
}
\end{verbatim}

  Similar to the guestbook entry, these methods add export/import
  information to the \texttt{PortletDataContext}.
\item
  Add a method that maps the missing reference ID from the export to the
  existing ID during import:

\begin{verbatim}
@Override
protected void doImportMissingReference(
        PortletDataContext portletDataContext, String uuid, long groupId,
        long guestbookId)
    throws Exception {

    Guestbook existingGuestbook = fetchMissingReference(uuid, groupId);

    if (existingGuestbook == null) {
        return;
    }

    Map<Long, Long> guestbookIds =
        (Map<Long, Long>) portletDataContext.getNewPrimaryKeysMap(
        Guestbook.class);

    guestbookIds.put(guestbookId, existingGuestbook.getGuestbookId());
}
\end{verbatim}

  Remember, this is not called for new entities being published/imported
  since all of an entity's references are new to the live Site.
\item
  Provide a way for the staged model data handler to fetch your staged
  models:

\begin{verbatim}
@Override
public Guestbook fetchStagedModelByUuidAndGroupId(
    String uuid, long groupId) {

    return _guestbookLocalService.fetchGuestbookByUuidAndGroupId(
        uuid, groupId);
}

@Override
public List<Guestbook> fetchStagedModelsByUuidAndCompanyId(
    String uuid, long companyId) {

    return _guestbookLocalService.getGuestbooksByUuidAndCompanyId(
        uuid, companyId, QueryUtil.ALL_POS, QueryUtil.ALL_POS,
        new StagedModelModifiedDateComparator<Guestbook>());
}
\end{verbatim}
\item
  Override the \texttt{BaseStagedModelDataHandler}'s delete methods to
  leverage your newly created fetch method and custom local service:

\begin{verbatim}
@Override
public void deleteStagedModel(
        String uuid, long groupId, String className, String extraData)
    throws PortalException {

    Guestbook guestbook = fetchStagedModelByUuidAndGroupId(uuid, groupId);

    if (guestbook != null) {
        deleteStagedModel(guestbook);
    }
}

@Override
public void deleteStagedModel(Guestbook guestbook)
    throws PortalException {

    _guestbookLocalService.deleteGuestbook(guestbook);
}
\end{verbatim}
\item
  Organize your imports (\emph{{[}CTRL{]}+{[}SHIFT{]}+O}), and save the
  file.
\end{enumerate}

Your guestbook staged model data handler is ready to go! Next, you'll
begin updating your guestbook's permissions to account for Staging.

\section{Updating Permissions to Support
Staging}\label{updating-permissions-to-support-staging}

\begin{verbatim}
<p>Enabling Staging and Export/Import<br>Step 4 of 7</p>
\end{verbatim}

The guestbook's current permission handlers do not account for Staging.
For example, the current configuration would display the \emph{Add
Guestbook} and \emph{Add Entry} buttons on the live Site while Staging
was enabled. These options should only be available on the staged Site
when Staging is enabled.

First, edit the Guestbook app's permissions helper classes to provide
permission checks to leverage when Staging is enabled.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open the \texttt{GuestbookModelPermission} class residing in the
  \texttt{guestbook-service}'s
  \texttt{com.liferay.docs.guestbook.service.permission} package.
  Replace the \texttt{contains(...)} methods with those below:

\begin{verbatim}
public static boolean contains(
    PermissionChecker permissionChecker, long groupId, String actionId) {

    return contains(
        permissionChecker, RESOURCE_NAME, GuestbookPortletKeys.GUESTBOOK,
        groupId, actionId);
}

public static boolean contains(
    PermissionChecker permissionChecker, String name, long classPK,
    String actionId) {

    Group group = GroupLocalServiceUtil.fetchGroup(classPK);

    if ((group != null) && group.isStagingGroup()) {
        classPK = group.getLiveGroupId();
    }

    return permissionChecker.hasPermission(
        classPK, name, classPK, actionId);
}

public static boolean contains(
    PermissionChecker permissionChecker, String name, String portletId,
    long classPK, String actionId) {

    Boolean hasPermission = StagingPermissionUtil.hasPermission(
        permissionChecker, classPK, name, classPK, portletId, actionId);

    if (hasPermission != null) {
        return hasPermission.booleanValue();
    }

    return contains(permissionChecker, name, classPK, actionId);
}
\end{verbatim}

  This adds two additional \texttt{contains} methods. The original
  \texttt{contains} method now redirects to a new method that
  instantiates a \texttt{hasPermission} field using the staging
  permission checker. If it returns as a non-null value (i.e., the app
  is rendered on the staged Site), the appropriate boolean value is
  returned based on the user's permissions. If the
  \texttt{hasPermission} field is null (i.e., the app is rendered on the
  live Site), the third \texttt{contains} method is invoked, which calls
  the permission checker with group info from the live Site.

  Now you'll edit the permissions helper classes for your two entities.
  These are for the model/resource permissions, so you supply the
  primary key of the entity you're checking permissions for (e.g.,
  \texttt{guestbookId}).
\item
  Open the \texttt{EntryPermission} class residing in the
  \texttt{guestbook-service}'s
  \texttt{com.liferay.docs.guestbook.service.permission} package. In the
  \texttt{contains(PermissionChecker,\ Entry,\ String)} method, add this
  logic:

\begin{verbatim}
Boolean hasPermission = StagingPermissionUtil.hasPermission(
    permissionChecker, entry.getGroupId(), Entry.class.getName(),
    entry.getEntryId(), GuestbookPortletKeys.GUESTBOOK, actionId);

    if (hasPermission != null) {
        return hasPermission.booleanValue();
    }
\end{verbatim}

  If the new \texttt{hasPermission} field is returned as a non-null
  value (i.e., the app is rendered on the staged Site), the appropriate
  boolean value is returned based on the staging context.
\item
  Open the \texttt{GuestbookPermission} class and add the following code
  in the \texttt{contains(PermissionChecker,\ Guestbook,\ String)}
  method:

\begin{verbatim}
Boolean hasPermission = StagingPermissionUtil.hasPermission(
    permissionChecker, guestbook.getGroupId(),
    Guestbook.class.getName(), guestbook.getGuestbookId(),
    GuestbookPortletKeys.GUESTBOOK, actionId);

if (hasPermission != null) {
    return hasPermission.booleanValue();
}
\end{verbatim}

  This is similar to the logic added for the entry's permissions.
\item
  Organize your imports (\emph{{[}CTRL{]}+{[}SHIFT{]}+O}) for all three
  classes, and then save them.
\end{enumerate}

Your Guestbook app can now display the proper functionality depending on
its staging context (i.e., staged Site or live Site).

The Guestbook's admin portlet requires additional modifications in its
JSPs to display options correctly based on staging context.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In your \texttt{guestbook-web} module, open the
  \texttt{src/main/resources/META-INF/resources/guestbookadminportlet/guestbook\_actions.jsp}
  file. Directly after the opening
  \texttt{\textless{}liferay-ui:icon-menu\textgreater{}} tag, add the
  following \texttt{if} statement:

\begin{verbatim}
<c:if test='<%= GuestbookPermission.contains(permissionChecker, guestbook.getGuestbookId(), ActionKeys.UPDATE) %>'>
\end{verbatim}

  Close the \texttt{if} statement directly after the
  \texttt{\textless{}liferay-ui:icon\ /\textgreater{}} tag. When
  completed, the \texttt{if} statement should look like this:

\begin{verbatim}
<c:if test='<%= GuestbookPermission.contains(permissionChecker, guestbook.getGuestbookId(), ActionKeys.UPDATE) %>'>
    <portlet:renderURL var="editURL">
        <portlet:param name="guestbookId"
            value="<%=String.valueOf(guestbook.getGuestbookId())%>" />
        <portlet:param name="mvcPath"
            value="/guestbookadminportlet/edit_guestbook.jsp" />
    </portlet:renderURL>

    <liferay-ui:icon image="edit" message="Edit"
        url="<%=editURL.toString()%>" />
</c:if>
\end{verbatim}

  The new \texttt{if} statement hides the Guestbook's editing
  functionality if the user does not have the permissions to edit a
  guestbook. Since you added new staging permissions, those are verified
  too.
\item
  Below the \texttt{\textless{}/c:if\textgreater{}} statement, add
  another \texttt{if} statement:

\begin{verbatim}
<c:if test='<%= GuestbookPermission.contains(permissionChecker, guestbook.getGuestbookId(), ActionKeys.DELETE) %>'>
\end{verbatim}

  Close the \texttt{if} statement directly after the
  \texttt{\textless{}liferay-ui:icon-delete\ /\textgreater{}} tag. When
  completed, the \texttt{if} statement should look like this:

\begin{verbatim}
<c:if test='<%= GuestbookPermission.contains(permissionChecker, guestbook.getGuestbookId(), ActionKeys.DELETE) %>'>
    <portlet:actionURL name="deleteGuestbook" var="deleteURL">
        <portlet:param name="guestbookId"
            value="<%=String.valueOf(guestbook.getGuestbookId())%>" />
    </portlet:actionURL>

    <liferay-ui:icon-delete url="<%=deleteURL.toString()%>" />
</c:if>
\end{verbatim}

  Similar to the previous \texttt{if} statement, this one hides the
  Guestbook's delete functionality if the user does not have the
  permissions to delete a guestbook.
\item
  Open the
  \texttt{src/main/resources/META-INF/resources/guestbookadminportlet/view.jsp}
  file and wrap the \texttt{\textless{}aui:button-row\ /\textgreater{}}
  tag with the following \texttt{if} statement:

\begin{verbatim}
<c:if test='<%= GuestbookModelPermission.contains(permissionChecker, scopeGroupId, "ADD_GUESTBOOK") %>'>
    ...
</c:if>
\end{verbatim}

  When finished, it should look like this:

\begin{verbatim}
<c:if test='<%= GuestbookModelPermission.contains(permissionChecker, scopeGroupId, "ADD_GUESTBOOK") %>'>
    <aui:button-row cssClass="guestbook-admin-buttons">
        <portlet:renderURL var="addGuestbookURL">
            <portlet:param name="mvcPath"
                value="/guestbookadminportlet/edit_guestbook.jsp" />
            <portlet:param name="redirect" value="<%="currentURL"%>" />
        </portlet:renderURL>

        <aui:button onClick="<%= addGuestbookURL.toString() %>"
            value="Add Guestbook" />
    </aui:button-row>
</c:if>
\end{verbatim}

  This \texttt{if} statement hides the Guestbook's \emph{Add Guestbook}
  button if the user does not have the permissions to create a new
  guestbook.
\end{enumerate}

Great! You've updated your Guestbook app's permissions to support
Staging!

\section{Configuring XStream}\label{configuring-xstream}

\begin{verbatim}
<p>Enabling Staging and Export/Import<br>Step 5 of 7</p>
\end{verbatim}

Configuring \href{http://x-stream.github.io/index.html}{XStream} for
your Guestbook app provides an easy way to customize how entities are
serialized to XML and back again. You can use it to enhance the
Guestbook's Staging implementation; however, it's not required. There
are three ways to leverage Liferay's offering of XStream via the
\href{@app-ref@/foundation/latest/javadocs/com/liferay/xstream/configurator/XStreamConfigurator.html}{XStreamConfigurator}:

\begin{itemize}
\tightlist
\item
  \emph{Allowed Types:} whitelists entities so everything is forbidden
  except a certain set of items. All staged models are allowed by
  default; this would be in addition to the default functionality.
  Liferay DXP defines a default list of allowed types, which are
  available in the portlet data context.
\item
  \emph{Aliases:} helps with the readability and char length of
  \href{/docs/7-0/tutorials/-/knowledge_base/t/understanding-data-handlers\#liferay-archive-lar-file}{LAR
  files} by creating an alias for an otherwise long winded entity name.
\item
  \emph{Converters:} converts configured objects to and from XML. This
  is primarily used to protect sensitive data; when serialized this way,
  sensitive data cannot be extracted from the generated LAR.
\end{itemize}

Since Allowed Types don't make sense in this context (there are no
additional entities to allow), you don't need them for Guestbook.
Converters let you re-write the serialization process from scratch---for
example, to add encryption. This is a tutorial on Staging, not
serialization, so the default serialization implementation is fine. That
leaves aliases.

In the Guestbook, you'll leverage XStream by creating an alias that
modifies the XML in the LAR file produced by your app during the staging
and export processes.

For example, by default your generated data has this structure:

\begin{verbatim}
<com.liferay.docs.guestbook.model.impl.GuestBookImpl>
    <field1>...</field1>
    ...
</com.liferay.docs.guestbook.model.impl.GuestBookImpl>
\end{verbatim}

With an XStream alias configured in your app, that same LAR content has
this structure:

\begin{verbatim}
<GuestBook>
    <field1>...</field1>
    ...
</GuestBook>
\end{verbatim}

Follow the instructions below to create an XStream alias:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In the \texttt{guestbook-service} module, create a package named
  \texttt{com.liferay.docs.guestbook.xstream.configurator}. In that
  package, create a class named \texttt{GuestbookXStreamConfigurator}.
\item
  Modify the class to implement the
  \href{@app-ref@/foundation/latest/javadocs/com/liferay/xstream/configurator/XStreamConfigurator.html}{\texttt{XStreamConfigurator}}
  interface and create an \texttt{@Component} annotation declaring that
  same class as the implementation service:

\begin{verbatim}
@Component(
    immediate = true, 
    service = XStreamConfigurator.class
)
public class GuestbookXStreamConfigurator implements XStreamConfigurator {
\end{verbatim}
\item
  Since the Guestbook won't leverage the \emph{Allowed Types} and
  \emph{Converters} XStream options, override their associated methods
  and have them return \texttt{null}:

\begin{verbatim}
@Override
public List<XStreamType> getAllowedXStreamTypes() {

    return null;
}

@Override
public List<XStreamConverter> getXStreamConverters() {

    return null;
}
\end{verbatim}
\item
  Override the \texttt{getXStreamAliases()} method to return a list of
  aliases you want to define. Also, define the list field.

\begin{verbatim}
@Override
public List<XStreamAlias> getXStreamAliases() {
    return ListUtil.toList(_xStreamAliases);
}

private XStreamAlias[] _xStreamAliases;
\end{verbatim}

  Next, you'll define the list.
\item
  Create an \texttt{activate()} method that defines the aliases to use
  for Guestbook's generated LAR file. You'll define an alias for the
  \texttt{GuestbookImpl} and \texttt{EntryImpl} classes to convert them
  from their full package names to simple entity names:

\begin{verbatim}
@Activate
protected void activate() {

    _xStreamAliases = new XStreamAlias[] {
        new XStreamAlias(GuestbookImpl.class, "Guestbook"),
        new XStreamAlias(EntryImpl.class, "Entry"),
    };
}
\end{verbatim}
\item
  Organize your imports (\emph{{[}CTRL{]}+{[}SHIFT{]}+O}), and save the
  file.
\end{enumerate}

Awesome! You implemented an XStream Configurator for the Guestbook and
created an alias for your guestbook and entry entity declarations.

\section{Defining System Events for
Deletions}\label{defining-system-events-for-deletions}

\begin{verbatim}
<p>Enabling Staging and Export/Import<br>Step 6 of 7</p>
\end{verbatim}

The Staging framework tracks entity modifications in a few different
ways. Actions like \emph{adding} a guestbook or \emph{editing} an entry
are tracked automatically by the framework with the configuration of
staged models and their data handlers. Entity deletions are handled
slightly differently using system events.

For the Guestbook app, you must define system events for entity
deletions so they're appropriately tracked by the Staging framework. If
Staging can't track your entity deletions, they can't be managed on the
staged Site, which means you can only delete entities from the live
Site.

You must define your system events in your local services.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open the \texttt{guestbook-service} module's
  \texttt{com.liferay.docs.guestbook.service.impl.GuestbookLocalServiceImpl}
  class and add the following \texttt{deleteGuestbook} methods. These
  override the default Service Builder generated methods the application
  has been using:

\begin{verbatim}
@Indexable(type = IndexableType.DELETE)
@Override
public Guestbook deleteGuestbook(long guestbookId)
    throws PortalException {

    Guestbook guestbook =
        guestbookPersistence.findByPrimaryKey(guestbookId);

    return guestbookLocalService.deleteGuestbook(guestbook);
}

@Indexable(type = IndexableType.DELETE)
@Override
@SystemEvent(type = SystemEventConstants.TYPE_DELETE)
public Guestbook deleteGuestbook(Guestbook guestbook) {

    return guestbookPersistence.remove(guestbook);
}
\end{verbatim}

  These methods override the \texttt{GuestbookLocalServiceBaseImpl}'s
  \texttt{deleteGuestbook} methods. The major addition is the
  \texttt{@SystemEvent} annotation added to the
  \texttt{deleteGuestbook(Guestbook)} method. This notifies the Staging
  framework that a deletion system event occurs when the method is
  called.

  The \texttt{deleteGuestbook(long)} method is rerouted to call the
  \texttt{SystemEvent} tracked method, so all deletions are accounted
  for.
\item
  Ensure that the remaining \texttt{deleteGuestbook} method triggers the
  system event. Within the
  \texttt{deleteGuestbook(long,\ ServiceContext)} method, change

\begin{verbatim}
guestbook = deleteGuestbook(guestbook);
\end{verbatim}

  to this

\begin{verbatim}
guestbook = guestbookLocalService.deleteGuestbook(guestbook);
\end{verbatim}

  Now all guestbook deletions are tracked via \texttt{SystemEvent}.
\item
  Add the import packages for the new \texttt{SystemEvent} annotation
  (\emph{{[}CTRL{]}+{[}SHIFT{]}+O}) and then save the file.
\item
  You must apply the deletion system event to both entities. Open the
  \texttt{com.liferay.docs.guestbook.service.impl.EntryLocalServiceImpl}
  class and add similar delete methods:

\begin{verbatim}
@Indexable(type = IndexableType.DELETE)
@Override
public Entry deleteEntry(long entryId)
    throws PortalException {

    Entry entry = entryPersistence.findByPrimaryKey(entryId);

    return entryLocalService.deleteEntry(entry);
}

@Indexable(type = IndexableType.DELETE)
@Override
@SystemEvent(type = SystemEventConstants.TYPE_DELETE)
public Entry deleteEntry(Entry entry) {

    return entryPersistence.remove(entry);
}
\end{verbatim}

  This is the same logic as before, except the delete system event is
  now applied for the entry.
\item
  Make sure the remaining \texttt{deleteEntry} method triggers the
  system event. Within the \texttt{deleteEntry(long,\ ServiceContext)}
  method, change

\begin{verbatim}
entry = deleteEntry(entryId);
\end{verbatim}

  to this

\begin{verbatim}
entry = entryLocalService.deleteEntry(entry);
\end{verbatim}

  Now all entry deletions are tracked via \texttt{SystemEvent}.
\item
  Add the import packages for the new \texttt{SystemEvent} annotation
  (\emph{{[}CTRL{]}+{[}SHIFT{]}+O}) and then save the file.
\item
  Run Service Builder by navigating to the Gradle Tasks pane on the
  right side of @ide@ and selecting your project's \emph{build} →
  \emph{buildService} task.
\end{enumerate}

Your Guestbook app's deletions are now properly tracked by the Staging
framework.

\section{Creating the Portlet Data
Handler}\label{creating-the-portlet-data-handler}

\begin{verbatim}
<p>Enabling Staging and Export/Import<br>Step 7 of 7</p>
\end{verbatim}

A Portlet Data Handler imports/exports portlet-specific data to a LAR
file. Its primary role is to query and coordinate between staged model
data handlers. It also configures the Export/Import UI options for the
application. For example, the Guestbook application's portlet data
handler should

\begin{itemize}
\tightlist
\item
  import/export portlet-specific data pertaining to the Guestbook app
\item
  track actions dealing with guestbook and entry entities (staged
  models)
\item
  configure export/import UI options for the Guestbook app
\end{itemize}

\begin{figure}
\centering
\includegraphics{./images/guestbook-pdh-diagram.png}
\caption{The Guestbook's portlet data handler must manage the portlet
data, staged model data handlers, and UI configuration.}
\end{figure}

Follow the instructions below to create the Guestbook's portlet data
handler.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In your \texttt{guestbook-service} module's
  \texttt{com.liferay.docs.guestbook.exportimport.data.handler} package,
  create the \texttt{GuestbookPortletDataHandler} class.
\item
  Extend the
  \href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/exportimport/kernel/lar/BasePortletDataHandler.html}{\texttt{BasePortletDataHandler}}
  class and add the \texttt{@Component} annotation to the class
  declaration with several configured properties like this:

\begin{verbatim}
@Component(
    immediate = true,
    property = {
        "javax.portlet.name=" + GuestbookPortletKeys.GUESTBOOK,
        "javax.portlet.name=" + GuestbookPortletKeys.GUESTBOOK_ADMIN
    }, 
    service = PortletDataHandler.class
)
public class GuestbookPortletDataHandler extends BasePortletDataHandler {
\end{verbatim}

  The three set annotation attributes are described below:

  \begin{itemize}
  \tightlist
  \item
    The \texttt{immediate} element tells the container to activate the
    component immediately once its provided module has started.
  \item
    The \texttt{property} element sets various properties for the
    component service. You must associate the portlets you wish to
    handle with this service so they function properly in the
    export/import environment. For example, since the Guestbook data
    handler is used for two portlets, they're both configured using the
    \texttt{javax.portlet.name} property.
  \item
    The \texttt{service} element should point to the
    \href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/exportimport/kernel/lar/PortletDataHandler.html}{\texttt{PortletDataHandler.class}}
    interface.
  \end{itemize}
\item
  Set what the portlet data handler controls and the portlet's
  Export/Import UI by adding an activate method:

\begin{verbatim}
@Activate
protected void activate() {

    setDeletionSystemEventStagedModelTypes(
        new StagedModelType(Entry.class),
        new StagedModelType(Guestbook.class));

    setExportControls(
        new PortletDataHandlerBoolean(
            NAMESPACE, "entries", true, false, null,
            Entry.class.getName()));

    setImportControls(getExportControls());
}
\end{verbatim}

  This method is called during initialization of the component by using
  the
  \href{https://osgi.org/javadoc/r6/residential/org/osgi/service/component/annotations/Activate.html}{\texttt{@Activate}}
  annotation. It's invoked after dependencies are set and before
  services are registered.

  The three \texttt{set} methods called in the
  \texttt{GuestbookPortletDataHandler}'s \texttt{activate} method are
  described below:

  \begin{itemize}
  \tightlist
  \item
    \texttt{setDeletionSystemEventStagedModelTypes}: sets the staged
    model deletions that the portlet data handler should track. For the
    Guestbook application, guestbooks and entries are tracked.
  \item
    \texttt{setExportControls}: adds fine grained controls over export
    behavior that are rendered in the Export UI. For the Guestbook
    application, a checkbox is added to select Guestbook content
    (entries) to export.
  \item
    \texttt{setImportControls}: adds fine grained controls over import
    behavior that are rendered in the Import UI. For the Guestbook
    application, a checkbox is added to select Guestbook content
    (entries) to import.
  \end{itemize}

  \begin{figure}
  \centering
  \includegraphics{./images/pdh-entries-ui.png}
  \caption{You can select the content types you'd like to export/import
  in the UI.}
  \end{figure}
\item
  Set the entity local services you want to leverage in your portlet
  data handler:

\begin{verbatim}
@Reference(unbind = "-")
protected void setGuestbookLocalService(
    GuestbookLocalService guestbookLocalService) {

    _guestbookLocalService = guestbookLocalService;
}

@Reference(unbind = "-")
protected void setEntryLocalService(EntryLocalService entryLocalService) {

    _entryLocalService = entryLocalService;
}

private GuestbookLocalService _guestbookLocalService;
private EntryLocalService _entryLocalService;
\end{verbatim}

  This provides access to the entry and guestbook's local services.
\item
  Create a namespace for your entities so the Export/Import framework
  can tell your application's entities from other entities in Liferay
  DXP.

\begin{verbatim}
public static final String NAMESPACE = "guestbook";
\end{verbatim}
\item
  Your portlet data handler should retrieve the data related to its
  staged model entities so it can properly export/import them. Add this
  functionality by inserting the following methods:

\begin{verbatim}
@Override
protected String doExportData(
        final PortletDataContext portletDataContext, String portletId,
        PortletPreferences portletPreferences)
    throws Exception {

    Element rootElement = addExportDataRootElement(portletDataContext);

    if (!portletDataContext.getBooleanParameter(NAMESPACE, "entries")) {
        return getExportDataRootElementString(rootElement);
    }

    portletDataContext.addPortletPermissions(
        GuestbookModelPermission.RESOURCE_NAME);

    rootElement.addAttribute(
        "group-id", String.valueOf(portletDataContext.getScopeGroupId()));

    ActionableDynamicQuery guestbookActionableDynamicQuery =
        _guestbookLocalService.getExportActionableDynamicQuery(
            portletDataContext);
    guestbookActionableDynamicQuery.performActions();

    ActionableDynamicQuery entryActionableDynamicQuery =
        _entryLocalService.getExportActionableDynamicQuery(
            portletDataContext);
        entryActionableDynamicQuery.performActions();

    return getExportDataRootElementString(rootElement);
}

@Override
protected PortletPreferences doImportData(
        PortletDataContext portletDataContext, String portletId,
        PortletPreferences portletPreferences, String data)
    throws Exception {

    if (!portletDataContext.getBooleanParameter(NAMESPACE, "entries")) {
        return null;
    }

    portletDataContext.importPortletPermissions(
        GuestbookModelPermission.RESOURCE_NAME);

    Element guestbooksElement =
        portletDataContext.getImportDataGroupElement(Guestbook.class);

    List<Element> guestbookElements = guestbooksElement.elements();

    for (Element guestbookElement : guestbookElements) {
        StagedModelDataHandlerUtil.importStagedModel(
            portletDataContext, guestbookElement);
    }

    Element entriesElement =
        portletDataContext.getImportDataGroupElement(Entry.class);

    List<Element> entryElements = entriesElement.elements();

    for (Element entryElement : entryElements) {
        StagedModelDataHandlerUtil.importStagedModel(
            portletDataContext, entryElement);
    }

    return null;
}
\end{verbatim}

  The \texttt{doExportData} method first checks if anything should be
  exported. The \texttt{portletDataContext.getBooleanParameter(...)}
  method checks if the user selected Guestbook entries for export.
  Later, the \texttt{ActionableDynamicQuery} framework runs a query
  against guestbooks and entries to find ones which should be exported
  to the LAR file.

  The \texttt{-ActionableDynamicQuery} classes are automatically
  generated by Service Builder and are available in your application's
  local service. It queries the database searching for certain
  Staging-specific parameters (e.g., \texttt{createDate} and
  \texttt{modifiedDate}), and based on those parameters, finds a list of
  exportable records from the staged model data handler.

  The \texttt{doImportData} method queries for guestbook and entry data
  in the imported LAR file that should be added to the database. This is
  done by extracting XML elements from the LAR file by using utility
  methods from the
  \href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/exportimport/kernel/lar/StagedModelDataHandlerUtil.html}{\texttt{StagedModelDataHandlerUtil}}
  class. The extracted elements tell Liferay DXP what data to import
  from the LAR file.
\item
  Add a method that counts the number of affected entities based on the
  current export or staging process:

\begin{verbatim}
@Override
protected void doPrepareManifestSummary(
        PortletDataContext portletDataContext,
        PortletPreferences portletPreferences)
    throws Exception {

    ActionableDynamicQuery entryExportActionableDynamicQuery =
        _entryLocalService.getExportActionableDynamicQuery(
            portletDataContext);
    entryExportActionableDynamicQuery.performCount();

    ActionableDynamicQuery guestbookExportActionableDynamicQuery =
        _guestbookLocalService.getExportActionableDynamicQuery(
            portletDataContext);
    guestbookExportActionableDynamicQuery.performCount();
}
\end{verbatim}

  This number is displayed in the Export and Staging UI. Note that since
  the Staging framework traverses the entity graph during export, the
  built-in components provide an approximate value in some cases.

  \begin{figure}
  \centering
  \includegraphics{./images/guestbook-staging-entity-counter.png}
  \caption{The number of modified Guestbook entities are displayed in
  the Export UI.}
  \end{figure}
\item
  Organize your imports (\emph{{[}CTRL{]}+{[}SHIFT{]}+O}), and save the
  file. \textbf{Hint:} Be sure to choose the
  \texttt{javax.portlet.PortletPreferences} import package.
\end{enumerate}

Excellent! You've set up your Guestbook's portlet data handler and can
now handle your portlet's data and control its staged model data
handlers.

Your Guestbook app is now leveraging the Staging and Export/Import
frameworks! To verify this, when you go to
\href{/docs/7-0/user/-/knowledge_base/u/enabling-staging}{enable
Staging}, you can now enable it for your Guestbook app.

\begin{figure}
\centering
\includegraphics{./images/guestbook-staging-enable.png}
\caption{Enable the Guestbook Staging functionality.}
\end{figure}

You can also navigate to the Guestbook Admin portlet and manage Staging
from the Options menu. This menu also offers a way to export and import
Guestbook LAR files manually.

\begin{figure}
\centering
\includegraphics{./images/guestbook-export-import.png}
\caption{You can manually export and import Guestbook LAR files from the
Guestbook Admin portlet.}
\end{figure}

The Guestbook is ready for the staging process!

\chapter{Writing an Android App for Liferay
DXP}\label{writing-an-android-app-for-liferay-dxp}

Users expect to access Liferay DXP content from their mobile devices. As
an intrepid developer, you naturally want to turn these expectations
into reality. Thankfully, Liferay provides a way for your mobile apps to
access Liferay DXP content and applications with
\href{https://www.liferay.com/supporting-products/liferay-screens}{Liferay
Screens}! Screens contains native components called \emph{Screenlets}
that can call Liferay DXP's remote services and display the results in
your app. Each Screenlet comes complete with its own fully pluggable UI
that you can customize to your liking. Although the Screenlets included
with Screens only work with Liferay DXP's built-in remote services, you
can write your own Screenlets that work with your custom portlets'
remote services.

If you're an experienced Android developer but need a start-to-finish
guide on how to integrate Android apps with Liferay DXP, you're in the
right place. This Learning Path walks you through the creation of an
Android app that interacts with the Guestbook portlet developed in the
\href{/docs/7-0/tutorials/-/knowledge_base/t/developing-a-web-application}{Developing
a Web Application} Learning Path. Since this is a custom portlet, you'll
write your own Screenlets that let your app retrieve and display
guestbooks and their entries.

You should note that although this Learning Path provides complete code
snippets of the app, not every aspect of Android development is
explained in detail. Focus is instead placed on the code that leverages
Liferay Screens. Therefore, you \textbf{must} have significant Android
development experience before attempting this Learning Path. Otherwise,
you'll likely be confused. Google provides extensive documentation of
the Android APIs as well as some basic tutorials on
\href{http://developer.android.com/index.html}{developer.android.com}.

Experience in Android development is all you need to start working. You
needn't have completed the Liferay MVC Learning Path to obtain a working
Guestbook portlet. The complete Guestbook portlet's modules are provided
for installation into your local Liferay DXP instance.

Now that you know what you'll be doing here, it's time to move on to the
first series of articles: Beginning Android Development for Liferay DXP.
These articles walk you through the steps required to get started
developing an Android app that interacts with Liferay DXP.

\chapter{Beginning Android Development for Your Liferay DXP
Instance}\label{beginning-android-development-for-your-liferay-dxp-instance}

Getting started with Liferay Screens for Android is a straightforward
process. This series of Learning Path articles walks you through
creating an Android app and preparing it to work with the Guestbook
portlet developed in the
\href{/docs/7-0/tutorials/-/knowledge_base/t/developing-a-web-application}{Developing
a Web Application} Learning Path.

Since Liferay Screens uses the Liferay Mobile SDK to make remote service
calls, you'll build a Mobile SDK capable of calling the Guestbook
portlet's remote services (the Guestbook Mobile SDK). You'll then
install this Mobile SDK and Screens into your Android project. You'll
also learn about the Android app's design and implement authentication
with
\href{/docs/7-0/reference/-/knowledge_base/r/loginscreenlet-for-android}{Login
Screenlet}.

This section of the Learning Path covers these topics:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Setting up the Guestbook portlet
\item
  Building the Guestbook Mobile SDK
\item
  Creating the Android project
\item
  Installing the Guestbook Mobile SDK and Liferay Screens in the Android
  project
\item
  Designing Your App
\item
  Using Login Screenlet for Authentication
\end{enumerate}

When you finish, you'll be ready to start developing your first
Screenlet.

\section{Setting up the Guestbook
Portlet}\label{setting-up-the-guestbook-portlet}

Before you begin developing the Guestbook app for Android, you must set
up the Guestbook portlet in a Liferay DXP instance. To do this, follow
these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/setting-up-the-guestbook-portlet\#installing-the-jdk}{Install
  JDK 8}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/setting-up-the-guestbook-portlet\#installing-and-configuring-a-local-liferay-bundle}{Install
  and Configure a Local Liferay DXP bundle}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/setting-up-the-guestbook-portlet\#deploying-the-guestbook-portlet}{Deploy
  the Guestbook Portlet to the Local Liferay DXP Instance}
\end{enumerate}

\subsection{Installing the JDK}\label{installing-the-jdk}

To get started, you must have JDK 8 installed. You can download and
install the Java SE JDK from the
\href{http://www.oracle.com/technetwork/java/javase/downloads/index.html}{Java
downloads page}. This page also has links to the JDK installation
instructions.

\subsection{Installing and Configuring a Local Liferay DXP
Bundle}\label{installing-and-configuring-a-local-liferay-dxp-bundle}

First, download a Liferay DXP Tomcat bundle from
\href{https://www.liferay.com/}{liferay.com}. Then
\href{/docs/7-0/deploy/-/knowledge_base/d/installing-product}{click
here} and follow the instructions to install the bundle. To follow
Liferay DXP best practices, you should create a \texttt{bundles} folder
and unzip it there. The bundle's root folder is referred to as
\emph{Liferay Home} and is named according to the version, edition, and
specific Liferay DXP release. For example, if you downloaded Liferay
Portal 7.0 CE GA4 and unzipped it to a \texttt{bundles} folder on your
machine, that bundle's Liferay Home folder path is:

\begin{verbatim}
bundles/liferay-ce-portal-7.0-ga4
\end{verbatim}

Now you're ready to start Liferay DXP! Start the bundle as described in
the link above. If you're on Mac or Linux you should also run
\texttt{tail\ -f\ ../logs/catalina.out} immediately after the
\texttt{./startup.sh} command executes. This ensures that the server log
prints to the terminal. This step isn't necessary on Windows because the
server log automatically opens in another window.

After a minute or two, Liferay DXP starts up and automatically takes you
to its initial setup page at \url{http://localhost:8080}. On this page,
you need to provide some basic information about how to set up your
Liferay DXP instance. Enter a name for your instance, select the default
language, and then uncheck the \emph{Add Sample Data} box. Then enter
the first name, last name, and email address of the default
administrative user. For the purposes of this Learning Path, these don't
have to be real. If you want to connect Liferay DXP to a separate
database such as MySQL or PostgreSQL, you can configure that connection
here. Note that although the default embedded database is fine for
development on your local machine, it isn't optimized for production.
Click \emph{Finish Configuration} when you're done. Then accept the
terms of use and set a password and a password reminder query for your
administrative user. Your Liferay DXP instance then takes you to its
default site.

Great! Next, you'll deploy the Guestbook portlet to your Liferay DXP
instance.

\subsection{Deploying the Guestbook
Portlet}\label{deploying-the-guestbook-portlet}

Now that your Liferay DXP instance is set up, you can deploy the
Guestbook portlet to it. First,
\href{https://portal.liferay.dev/documents/113763090/114000186/guestbook-services.zip}{click
here} to download the Guestbook portlet's modules:

\begin{itemize}
\tightlist
\item
  \texttt{com.liferay.docs.guestbook.api-1.0.0.jar}
\item
  \texttt{com.liferay.docs.guestbook.portlet-1.0.0.jar}
\item
  \texttt{com.liferay.docs.guestbook.service-1.0.0.jar}
\item
  \texttt{com.liferay.docs.guestbook.service-wsdd-1.0.0.jar}
\end{itemize}

Place these modules in your Liferay DXP instance's
\texttt{{[}Liferay\ Home{]}/deploy} folder. You should then see console
messages indicating that the modules have successfully deployed and
started. On your Liferay DXP instance's default site, click the
\emph{Add} button
(\includegraphics{./images/icon-control-menu-add.png}) on the
upper-right corner of the screen. Then click the \emph{Applications} →
\emph{Sample} category and drag \emph{Guestbook} onto the page. The
Guestbook portlet should now appear with the default guestbook (Main).
In the portlet, add a new guestbook and an entry or two each from the
\emph{Add} menu (\includegraphics{./images/icon-app-add.png})
that appears in the top right of the portlet's border when you mouse
over the portlet. When you create the Guestbook Android app, this
ensures there's some content to display in it. The Guestbook portlet on
your site should now look like this:

\begin{figure}
\centering
\includegraphics{./images/guestbook-portlet-01.png}
\caption{The Guestbook portlet, with a new guestbook and some entries.}
\end{figure}

Stupendous! You've successfully set up a Liferay DXP instance and added
the Guestbook portlet to it. Now you're ready to get started with the
Liferay Mobile SDK.

\section{Building the Guestbook Mobile
SDK}\label{building-the-guestbook-mobile-sdk}

Once you've deployed the Guestbook portlet, you're ready to build the
Guestbook Mobile SDK. You might be asking yourself, ``Why do I have to
build a separate Mobile SDK? Can't I just use the pre-built Mobile SDK
that Liferay already provides?'' Fantastic question! The reason is that
Liferay's pre-built Mobile SDK doesn't have the classes it needs to call
the Guestbook portlet's remote services. The pre-built Mobile SDK
includes only the framework necessary to make server calls to the remote
services of Liferay DXP's \emph{core} apps. Core apps (also referred to
as \emph{out-of-the-box} apps) are those included with every Liferay DXP
instance. Since you're calling services of an app the default Mobile SDK
doesn't know about (the Guestbook portlet), you must build a Mobile SDK
that can call its services. Now put on your hard hat, because it's time
to get building!

\subsection{Building the Mobile SDK}\label{building-the-mobile-sdk}

In the Mobile SDK source code, Liferay provides a Mobile SDK Builder
that you can use to build your own Mobile SDKs. For the builder to
generate the classes that can call a non-core app's remote services,
those services must be available and accompanied by a Web Service
Deployment Descriptor (WSDD). To learn how the Guestbook portlet's
remote services and WSDD were generated, see the section
\href{/docs/7-0/tutorials/-/knowledge_base/t/generating-web-services}{Generating
Web Services} in the web application Learning Path. Since the Guestbook
portlet's web services already exist, you don't need to generate them.
Just remember that you must generate web services when developing your
own portlets.

To build the Guestbook Mobile SDK, first download the Mobile SDK's
source code
\href{https://github.com/liferay/liferay-mobile-sdk/archive/android-7.0.6.zip}{by
clicking here}. Unzip the file to a location on your machine where you
want the Mobile SDK to reside. This location is purely personal
preference; the builder works the same no matter where you put the
Mobile SDK's source code. Once unzipped, the Mobile SDK's source code is
in the \texttt{liferay-mobile-sdk-android-7.0.6} folder.

Now you're ready to build the Guestbook Mobile SDK. The builder contains
a convenient command line wizard to assist you in building Mobile SDKs.
To start it, navigate to the \texttt{liferay-mobile-sdk-android-7.0.6}
folder and run the following command:

\begin{verbatim}
./gradlew createModule
\end{verbatim}

The wizard launches and asks you to enter your project's properties. You
must first provide the \texttt{Context} property. This is the context
path of the remote services the builder will generate classes and
methods for. To view your Liferay DXP instance's remote service context
paths, go to \url{http://localhost:8080/api/jsonws}. On the page's upper
left, there's a menu for selecting the context path. Select \emph{gb},
which is the Guestbook portlet's context path. The UI updates to show
only the remote services available in the selected context path. Return
to the terminal and enter \texttt{gb} for the \texttt{Context} property.

\begin{figure}
\centering
\includegraphics{./images/remote-services-context.png}
\caption{The Guestbook Portlet's context path (gb) on the server.}
\end{figure}

Next, the wizard needs the \texttt{Package\ Name} property. This is the
package path for the classes the builder generates. Accept the default
value of \texttt{com.liferay.mobile.android}. The wizard then asks for
the \texttt{POM\ Description} property. Technically, you only need this
if you want to publish your Mobile SDK to Maven. Since the builder
requires it, however, enter \texttt{Guestbook\ SDK}. The following
screenshot shows these properties entered in the wizard:

\begin{figure}
\centering
\includegraphics{./images/mobile-sdk-build-wizard.png}
\caption{To build your Mobile SDK, you must enter values for the
\texttt{Context}, \texttt{Package\ Name}, and \texttt{POM\ Description}
properties. The blue values in square brackets are defaults.}
\end{figure}

Once you enter the final property, the builder runs and generates a
\texttt{BUILD\ SUCCESSFUL} message. Now that the builder contains a
\texttt{gb} module, you must generate that module's remote services. To
do this, first navigate to the following folder:

\begin{verbatim}
liferay-mobile-sdk-android-7.0.6/modules/gb
\end{verbatim}

Then run the following command:

\begin{verbatim}
../../gradlew generate
\end{verbatim}

As before, the builder runs and generates a \texttt{BUILD\ SUCCESSFUL}
message. Great! You're probably wondering what just happened, though.
The builder generated the source classes you'll use in your Android app
to interact with the Guestbook portlet. You can find these source
classes in the following folder of the Mobile SDK's source code:

\begin{verbatim}
modules/gb/android/src/gen/java
\end{verbatim}

Also note that the source classes are in the package path you specified
when generating the module, with an additional folder that denotes the
Liferay DXP version they work with. The full path to the generated
source classes is therefore:

\begin{verbatim}
modules/gb/android/src/gen/java/com/liferay/mobile/android/v7
\end{verbatim}

This folder has two subfolders that correspond to each entity in the
Guestbook portlet: \texttt{guestbook} and \texttt{entry}. Each subfolder
contains that entity's source class, \texttt{GuestbookService} and
\texttt{EntryService}, respectively.

There's one last thing to do before you can use these classes in your
Android app: put them in a JAR file. To do this, make sure you're still
in the \texttt{modules/gb} folder on the command line and run
\texttt{../../gradlew\ jar}. This command does two things:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Generates a JAR file in \texttt{modules/gb/build/libs} that contains
  the Guestbook portlet's service classes. This JAR file is the
  Guestbook Mobile SDK.
\item
  Generates a custom-built version of Liferay's pre-built Mobile SDK in
  \texttt{liferay-mobile-sdk-android-7.0.6/android/build/libs}.
\end{enumerate}

Congratulations! You just built the Guestbook Mobile SDK. Now that's an
accomplishment worth writing in a guestbook. All you need now is an
Android app in which to install this Mobile SDK. The next article shows
you how to create this.

\section{Creating the Android
Project}\label{creating-the-android-project}

Now that you've built the Guestbook Mobile SDK, you're ready to create
the Guestbook Android app. This article walks you through the steps
required to create the app's project in Android Studio. After this,
you'll be ready to install the Guestbook Mobile SDK and Liferay Screens.
First though, you should make sure you've installed Android's
development tools.

\subsection{Installing Android Studio}\label{installing-android-studio}

This Learning Path uses Android Studio--Android's official IDE--to
develop the Guestbook app. As an Android developer, you're likely very
familiar with Android Studio. If you need help setting up and using
Android Studio, see the following topics in Android Studio's
documentation:

\begin{itemize}
\tightlist
\item
  \href{https://developer.android.com/studio/install.html?pkg=studio}{Android
  Studio Installation Instructions}
\item
  \href{https://developer.android.com/studio/intro/index.html}{Meet
  Android Studio}
\end{itemize}

Once Android Studio is up and running, you're ready to create the
Guestbook app!

\subsection{Creating the Guestbook
App}\label{creating-the-guestbook-app}

When you start Android Studio, it presents a welcome screen containing a
Quick Start menu. Click \emph{Start a new Android Studio project} in
this menu. This launches the \emph{Create New Project} wizard, which
asks you to enter the app name, company domain, and project location.
Enter \emph{Liferay Guestbook} as the app name and
\emph{docs.liferay.com} as the company domain. Android Studio uses these
values to autofill your app's package name and project location. Accept
the package name \texttt{com.liferay.docs.liferayguestbook}, and choose
a project location that's convenient. Click \emph{Next}.

\begin{figure}
\centering
\includegraphics{./images/android-studio-new-project-01.png}
\caption{The first screen of Android Studio's Create New Project wizard
asks you to enter your app's name and company domain.}
\end{figure}

The next screen asks you to specify your app's supported form factors
and minimum Android SDK. Make sure that only the \emph{Phone and Tablet}
checkbox is selected. In the \emph{Minimum SDK} menu, select \emph{API
15: Android 4.0.3 (IceCreamSandwich)}. Android Studio gives you an
estimate of the percentage of devices active on the Google Play store
that can run the selected API level. You can view a graphical
representation of these estimates by clicking the \emph{Help me choose}
link in the text below the Minimum SDK menu. Click \emph{Next} when
you're finished.

\begin{figure}
\centering
\includegraphics{./images/android-studio-new-project-02.png}
\caption{The second screen of Android Studio's Create New Project wizard
lets you select your app's form factors and minimum Android API level.}
\end{figure}

You must now specify your app's first activity. Although you'll use this
activity to authenticate users to your Liferay DXP instance, don't
select Login Activity. Select \emph{Empty Activity} instead. Later,
you'll insert
\href{/docs/7-0/reference/-/knowledge_base/r/loginscreenlet-for-android}{Login
Screenlet} in this activity. Login Screenlet contains everything your
users need to authenticate to a Liferay DXP instance, including the UI.
Click \emph{Next}.

\begin{figure}
\centering
\includegraphics{./images/android-studio-new-project-03.png}
\caption{The third screen of Android Studio's Create New Project wizard
lets you specify an activity for your app.}
\end{figure}

The final screen of the New Project Wizard asks you to enter the
activity's name and the name of its layout file. Accept the defaults and
click \emph{Finish}.

\begin{figure}
\centering
\includegraphics{./images/android-studio-new-project-04.png}
\caption{In the final screen of Android Studio's Create New Project
wizard, accept the default values for the activity and layout name.}
\end{figure}

A progress indicator appears that indicates your project is building.
Android Studio then opens the project with the activity's class and
layout ready to edit. The project's structure appears on the left side
of the screen.

\begin{figure}
\centering
\includegraphics{./images/android-studio-project.png}
\caption{Android Studio shows your project's structure.}
\end{figure}

Well done! You successfully created the Guestbook app's project. Now
it's time to put the Guestbook Mobile SDK and Liferay Screens to work!

\section{Installing the Guestbook Mobile SDK and Liferay Screens for
Android}\label{installing-the-guestbook-mobile-sdk-and-liferay-screens-for-android}

For your Android app to interact with the Guestbook portlet, you must
install the following libraries in your Android project:

\begin{itemize}
\item
  \textbf{Liferay's pre-built Mobile SDK:} This Mobile SDK contains the
  classes that call Liferay DXP's core remotes services. It also
  contains the framework necessary for any Mobile SDK to make server
  calls.
\item
  \textbf{The Guestbook Mobile SDK:} This Mobile SDK contains only the
  classes that call the Guestbook portlet's remote services.
\item
  \textbf{Liferay Screens:} Screens contains the Screenlet framework and
  \href{/docs/7-0/reference/-/knowledge_base/r/screenlets-in-liferay-screens-for-android}{several
  built-in Screenlets} like Login Screenlet. Because these built-in
  Screenlets interact with Liferay DXP's core apps, they make their
  server calls with Liferay's pre-built Mobile SDK. Note that all
  Screenlets, including those that make server calls with a custom-built
  Mobile SDK, must use the framework in Liferay's pre-built Mobile SDK
  to issue their calls.
\end{itemize}

Since Liferay's pre-built Mobile SDK is a dependency of Liferay Screens,
installing Screens automatically installs this Mobile SDK. You must,
however, install the Guestbook Mobile SDK manually.

This article walks you through the installation of the Guestbook Mobile
SDK and Liferay Screens. When you finish, you'll be ready to start
developing the app.

\subsection{Installing the Guestbook Mobile
SDK}\label{installing-the-guestbook-mobile-sdk}

The Mobile SDK Builder generated two separate JAR files in your
\texttt{liferay-mobile-sdk-android-7.0.6} folder:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \texttt{modules/gb/build/libs/liferay-gb-android-sdk-1.0.jar}
\item
  \texttt{android/build/libs/liferay-android-sdk-7.0.6.jar}
\end{enumerate}

The first JAR file is the Guestbook Mobile SDK. The second JAR file is a
custom built version of Liferay's pre-built Mobile SDK. Because Screens
includes the pre-built Mobile SDK, you don't need to install the second
JAR file. You must, however, install the first JAR file. To do so, copy
\texttt{liferay-gb-android-sdk-1.0.jar} into your app's
\texttt{app/libs} folder (the default location for your Android app is
\texttt{AndroidStudioProjects/LiferayGuestbook}). That's it! Next,
you'll install Liferay Screens.

\subsection{Installing Liferay
Screens}\label{installing-liferay-screens}

To install Liferay Screens, you must edit your app's
\texttt{build.gradle} file. Note that your project has two
\texttt{build.gradle} files: one for the project, and another for the
app module. You can find them under \emph{Gradle Scripts} in your
Android Studio project. This screenshot highlights the app module's
\texttt{build.gradle} file:

\begin{figure}
\centering
\includegraphics{./images/android-build-gradle-app-module.png}
\caption{The app module's \texttt{build.gradle} file.}
\end{figure}

In the app module's \texttt{build.gradle} file, add the following lines
of code inside the \texttt{dependencies} element:

\begin{verbatim}
compile 'com.liferay.mobile:liferay-screens:2.1.1'
compile 'com.liferay.mobile:liferay-material-viewset:2.1.1'
\end{verbatim}

This adds the \texttt{liferay-screens} and
\texttt{liferay-material-viewset} dependencies. Although only the
\texttt{liferay-screens} dependency is necessary to install Screens,
adding other View Sets, like the Material View Set, gives you
flexibility when designing your app's look and feel.
\href{/docs/7-0/tutorials/-/knowledge_base/t/using-views-in-android-screenlets}{Click
here} for more information on Views in Liferay Screens.

Once you edit \texttt{build.gradle}, a message appears at the top of the
file that asks you to sync your app with its Gradle files. Syncing with
the Gradle files is required to incorporate any changes you make to
them. Syncing also downloads and installs any new dependencies, like
those you just added. Sync the Gradle files now by clicking the
\emph{Sync Now} link in the message.

Note that after syncing, your \texttt{build.gradle} may show an error
similar to this:

\begin{verbatim}
All com.android.support libraries must use the exact same version specification...
\end{verbatim}

If this occurs, you must manually add the correct version of the
\texttt{com.android.support} dependencies. For example, the app in this
Learning Path currently uses version \texttt{25.3.1} of the
\texttt{com.android.support} libraries. This requires that you manually
add the following dependencies to the app's \texttt{build.gradle}:

\begin{verbatim}
compile 'com.android.support:support-v4:25.3.1'
compile 'com.android.support:recyclerview-v7:25.3.1'
compile 'com.android.support:transition:25.3.1'
compile 'com.android.support:design:25.3.1'
compile 'com.android.support:exifinterface:25.3.1'
\end{verbatim}

After adding these inside the \texttt{dependencies} element, click
\emph{Sync Now} again. The error message should be gone once the sync
completes.

\begin{figure}
\centering
\includegraphics{./images/android-build-gradle-sync.png}
\caption{After editing the app module's \texttt{build.gradle} file,
click \emph{Sync Now} to incorporate the changes in your app.}
\end{figure}

Great! Now you're ready to test your Screens and Mobile SDK
installations.

\subsection{Verifying the
Installations}\label{verifying-the-installations}

To check your Screens and Mobile SDK installations, first open your
project's \texttt{MainActivity} class in Android Studio. It's in the
\texttt{java} folder's \texttt{com.liferay.docs.liferayguestbook}
package. Then add the following imports to this file:

\begin{verbatim}
import com.liferay.mobile.android.service.Session;
import com.liferay.mobile.android.v7.entry.EntryService;
import com.liferay.mobile.android.v7.guestbook.GuestbookService;
import com.liferay.mobile.screens.auth.login.LoginScreenlet;
\end{verbatim}

If Android Studio recognizes these imports, then you're good to go!
Remove them once you've verified that they're valid. Next, there's one
final small but important task to complete: point your app at the
correct Liferay DXP instance.

\subsection{Configuring Communication with Liferay
DXP}\label{configuring-communication-with-liferay-dxp}

For Screens to work properly with your app, you must point it to your
Liferay DXP instance. You do this by adding a
\texttt{server\_context.xml} file in your project's \texttt{res/values}
directory. Create this file and add the following code to it:

\begin{verbatim}
<?xml version="1.0" encoding="utf-8"?>
<resources>

    <!-- Change these values for your portal instance -->

    <string name="liferay_server">http://10.0.2.2:8080</string>

    <integer name="liferay_company_id">20116</integer>
    <integer name="liferay_group_id">20147</integer>

    <integer name="liferay_portal_version">70</integer>

</resources>
\end{verbatim}

As the comment indicates, change the values to match those of your
Liferay DXP instance. The server address \texttt{http://10.0.2.2:8080}
is suitable for testing with Android Studio's emulator, because it
corresponds to \texttt{localhost:8080} through the emulator. The Liferay
DXP instance you set up earlier should be running on
\texttt{localhost:8080}.

The \texttt{liferay\_company\_id} value is your Liferay DXP instance's
ID. You can find it in your Liferay DXP instance at \emph{Control Panel}
→ \emph{Configuration} → \emph{Virtual Instances}. The instance's ID is
in the \emph{Instance ID} column. Copy and paste this value into the
\texttt{liferay\_company\_id} value in \texttt{server\_context.xml}.

The \texttt{liferay\_group\_id} value is the ID of the site your app
needs to communicate with. Since the app needs to communicate with the
Guestbook portlet, navigate to the site you put the Guestbook portlet
on. In the \emph{Site Administration} menu, select \emph{Configuration}
→ \emph{Site Settings}. The site ID is listed at the top of the
\emph{General} tab. Copy and paste this value from your portal to the
\texttt{liferay\_group\_id} value in \texttt{server\_context.xml}.

Awesome! Next, you'll learn the app's basic design.

\section{Designing Your App}\label{designing-your-app}

As a developer, you know that developing any kind of app without an
overall design goal and plan to implement it is a recipe for disaster.
To avoid this, you need to decide some things upfront. The Liferay
Guestbook app needs a straightforward way to do three things:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Authenticate users
\item
  Display guestbooks
\item
  Display entries
\end{enumerate}

To authenticate users, all you need to do is insert and configure
\href{/docs/7-0/reference/-/knowledge_base/r/loginscreenlet-for-android}{Login
Screenlet} in your app. Login Screenlet comes complete with its own UI.
The design for authentication, therefore, like with Liferay DXP itself,
is done for you.

You must, however, create the UI for displaying guestbooks and entries.
What sort of UI would be best for this? Although the \emph{best} UI for
any purpose is a matter of opinion, displaying guestbooks and entries in
a list is a good choice. Lists are common, compact design elements
familiar to mobile users. Since most mobile devices don't have room to
display a list of guestbooks and a list of entries at the same time, you
also need a user-friendly way to display and manage these lists. It
makes sense to show the first guestbook's entries automatically after
the user authenticates. This is similar to the Guestbook portlet's
design: it shows a list of the first guestbook's entries by default.
When the user selects a different guestbook, you can then use the same
UI to show the selected guestbook's entries instead.

\begin{figure}
\centering
\includegraphics{./images/guestbook-portlet.png}
\caption{By default, the first guestbook in the portlet is selected.}
\end{figure}

You must also decide how the users can select different guestbooks.
Showing the list of guestbooks in a navigation drawer that slides out
from the left side of the screen is a good choice. A navigation drawer
is easily hidden and is a common Android UI element.

To display these lists of guestbooks and entries, you'll create your own
Screenlets: Guestbook List Screenlet and Entry List Screenlet. Guestbook
List Screenlet needs to retrieve guestbooks from the portlet and display
them in a simple list. Once written, using this Screenlet is a simple
matter of inserting it in the navigation drawer. Entry List Screenlet
needs to retrieve and display a guestbook's entries in a similar list.
You'll display the entries by inserting Entry List Screenlet in the UI
element where you want it.

Also note that these Screenlets are \emph{list Screenlets}. You develop
list Screenlets by using the list Screenlet framework, which sits on top
of the core Screenlet framework. The list Screenlet framework makes it
easy for developers to write Screenlets that display lists of entities
from a Liferay DXP instance.

Awesome! Now you have a basic UI design and know the Screenlets you'll
create to implement it. But where in the app can you use these
Screenlets? The app only contains one empty activity,
\texttt{MainActivity}, which you'll use for authentication with Login
Screenlet. To use your custom list Screenlets, you'll need to create an
additional activity and a fragment: \texttt{GuestbooksActivity} and
\texttt{EntriesFragment}. You'll create the activity in a moment.

\begin{figure}
\centering
\includegraphics{./images/android-app-design-screenlets.png}
\caption{The Liferay Guestbook app's design uses two activities and a
fragment. In this diagram, each activity and fragment is labeled, along
with the Screenlets and the navigation drawer.}
\end{figure}

In addition to showing the app's components, this diagram shows how the
user navigates through the app. After sign in, the user transitions to
\texttt{GuestbooksActivity}. This activity uses Entry List Screenlet in
\texttt{EntriesFragment} to display the selected guestbook's entries
(the first guestbook is selected by default). Pressing the hamburger
button at the top-left of this screen opens the navigation drawer, where
Guestbook List Screenlet displays the list of guestbooks. Selecting a
guestbook closes the drawer to reveal that guestbook's entries. Note
that you only need one activity, \texttt{GuestbooksActivity}, to display
guestbooks and entries. The navigation drawer and
\texttt{EntriesFragment} are part of this activity.

Now you're ready to create \texttt{GuestbooksActivity}. Fortunately,
Android Studio has a template for creating an activity that contains a
navigation drawer. Follow these steps to create
\texttt{GuestbooksActivity} with the navigation drawer template:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Right click the package \texttt{com.liferay.docs.liferayguestbook} and
  select \emph{New} → \emph{Activity} → \emph{Navigation Drawer
  Activity} to launch the New Android Activity wizard.
\item
  Name the activity \texttt{GuestbooksActivity}, accept the defaults for
  the remaining fields, and click \emph{Finish}.
\item
  After Android Studio creates the activity, the
  \texttt{GuestbooksActivity} class and \texttt{content\_guestbooks.xml}
  layout open in the editor. Close them. You don't need to edit these
  files yet.
\end{enumerate}

Great! Now you understand the Liferay Guestbook app's design. You also
have the app structure in place. Next, you'll authenticate users by
adding Login Screenlet to \texttt{MainActivity}.

\section{Using Login Screenlet for
Authentication}\label{using-login-screenlet-for-authentication}

For the app to retrieve data from the Guestbook portlet, the user must
first authenticate to the Liferay DXP instance. You can implement
authentication using the Liferay Mobile SDK, but it takes time to write.
Using Liferay Screens to authenticate takes about ten minutes. In this
article, you'll use Login Screenlet to implement authentication in your
app.

\subsection{Adding Login Screenlet to the
App}\label{adding-login-screenlet-to-the-app}

To use any Screenlet, you must follow two steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Insert the Screenlet's XML in the layout of the activity or fragment
  where you want the Screenlet to appear.
\item
  Implement the Screenlet's listener in the activity or fragment class.
\end{enumerate}

In this app, you'll use Login Screenlet in \texttt{MainActivity}. This
means you must insert the Screenlet's XML in \texttt{MainActivity}'s
layout, \texttt{activity\_main.xml}. You'll then implement Login
Screenlet's listener, \texttt{LoginListener}, in the
\texttt{MainActivity} class.

\subsubsection{Insert the Screenlet's
XML}\label{insert-the-screenlets-xml}

Follow these steps to insert Login Screenlet's XML in
\texttt{activity\_main.xml}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open \texttt{activity\_main.xml} from the \texttt{res/layout} folder
  and delete the \texttt{TextView} generated by Android Studio when you
  created the project. Insert Login Screenlet's XML in its place:

\begin{verbatim}
<com.liferay.mobile.screens.auth.login.LoginScreenlet
    android:id="@+id/login_screenlet"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    app:basicAuthMethod="screen_name"
    app:layoutId="@layout/login_default"
    />
\end{verbatim}

  Note the two \texttt{app} attributes in the Login Screenlet's XML. The
  \texttt{app:basicAuthMethod} attribute tells the Screenlet to use
  basic authentication instead of OAuth. The \texttt{screen\_name} value
  tells the Screenlet to authenticate with the user's screen name. You
  can alternatively set this to \texttt{email} or \texttt{userId}. This
  Learning Path uses \texttt{screen\_name} only because it's much faster
  to type a screen name than a full email address in the emulator. Also,
  this value must match the authentication setting in the Liferay DXP
  instance. By default, Liferay DXP instances use email address for
  authentication. For this Learning Path, you need to set your Liferay
  DXP instance to authenticate by screen name instead.
  \href{/docs/6-2/reference/-/knowledge_base/r/loginscreenlet-for-android\#basic-authentication}{Click
  here} for instructions on changing your Liferay DXP instance's
  authentication setting.

  The second \texttt{app} attribute in Login Screenlet's XML is
  \texttt{app:layoutId}. This attribute sets the \emph{View} to display
  the Screenlet with. Views in Liferay Screens set a Screenlet's look
  and feel independent of the Screenlet's core functionality. You can
  think of them as a sort of skin or theme for a Screenlet. The value
  \texttt{@layout/login\_default} specifies Login Screenlet's Default
  View, which is part of the Default \emph{View Set}. A View Set is a
  collection of Views for several Screenlets. Using a View Set lets you
  apply a consistent look and feel across multiple Screenlets. To use a
  View that is part of a View Set, like Login Screenlet's Default View,
  the theme of the app or activity must inherit the theme that sets the
  View Set's styles. For the Default View Set, this is
  \texttt{default\_theme}.
\item
  To set the app's theme to inherit from \texttt{default\_theme}, open
  \texttt{res/values/styles.xml} and set the base app theme's parent to
  \texttt{default\_theme}. In this app, the base app theme is
  \texttt{AppTheme}. The theme declaration should now look like this:

\begin{verbatim}
<style name="AppTheme" parent="default_theme">
    ...
\end{verbatim}
\end{enumerate}

\href{/docs/6-2/tutorials/-/knowledge_base/t/using-views-in-android-screenlets}{Click
here} for more information on using Views in Liferay Screens. For more
information on Login Screenlet's available attributes,
\href{/docs/6-2/reference/-/knowledge_base/r/loginscreenlet-for-android\#attributes}{click
here}.

Next, you'll implement \texttt{LoginListener} in the
\texttt{MainActivity} class.

\subsubsection{Implement the Screenlet's
Listener}\label{implement-the-screenlets-listener}

To use a Screenlet in an activity or fragment, you must also implement
the Screenlet's listener in that activity or fragment's class. You'll do
this now to use Login Screenlet in \texttt{MainActivity}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open \texttt{MainActivity} and change its declaration to implement
  \texttt{LoginListener}. The class declaration should now look like
  this:

\begin{verbatim}
public class MainActivity extends AppCompatActivity implements LoginListener {...
\end{verbatim}

  You must also import
  \texttt{com.liferay.mobile.screens.auth.login.LoginListener}.
\item
  Implementing \texttt{LoginListener} requires you to implement the
  \texttt{onLoginSuccess} and \texttt{onLoginFailure} methods. Add them
  to the class as follows:

\begin{verbatim}
@Override
public void onLoginSuccess(User user) {
    Toast.makeText(this, "Login successful!", Toast.LENGTH_SHORT).show();
}

@Override
public void onLoginFailure(Exception e) {
    Toast.makeText(this, "Couldn't log in " + e.getMessage(), Toast.LENGTH_LONG).show();
}
\end{verbatim}

  When you add these methods, you must import
  \texttt{android.widget.Toast} and
  \texttt{com.liferay.mobile.screens.context.User}.

  These are listener methods called when login succeeds or fails,
  respectively. Using them lets your app respond the Screenlet's
  actions. For the moment, they each only do one thing: display a
  success or failure message to the user. You'll change this shortly.
  Note that each Screenlet has different listener methods; they're
  listed in the Screenlet
  \href{/docs/6-2/reference/-/knowledge_base/r/screenlets-in-liferay-screens-for-android}{reference
  documentation}.
\item
  Now you must get a reference to the Screenlet and set the
  \texttt{MainActivity} class as its listener. To do so, add the
  following code to the end of the \texttt{onCreate} method:

\begin{verbatim}
LoginScreenlet loginScreenlet = (LoginScreenlet) findViewById(R.id.login_screenlet);
loginScreenlet.setListener(this);
\end{verbatim}

  This requires you to import
  \texttt{com.liferay.mobile.screens.auth.login.LoginScreenlet}.

  The \texttt{findViewById} method uses the Screenlet's ID from the
  layout to create the reference. The \texttt{setListener} method then
  sets \texttt{MainActivity} as Login Screenlet's listener.
\end{enumerate}

Now run the app by clicking the green \emph{play} button in the toolbar,
or by selecting \emph{Run `app'} from the \emph{Run} menu. If you've
never run the emulator, you must first create and choose an Android
Virtual Device (AVD) to run your app. For more information on this and
running the emulator in general,
\href{https://developer.android.com/studio/run/emulator.html}{click
here}. Once the emulator launches, unlock it if necessary. Your app
automatically opens to Login Screenlet. Enter your credentials and click
\emph{SIGN IN}. The toast message pops up saying that the login
succeeded.

\begin{figure}
\centering
\includegraphics{./images/android-login-screenlet-success.png}
\caption{Login Screenlet successfully authenticated you with the Liferay
DXP instance.}
\end{figure}

The toast message goes away and you remain on the login screen. Nothing
else happens. Don't worry, this is supposed to happen; you haven't added
any other functionality yet. You'll fix this next.

\subsection{Navigating from Login
Screenlet}\label{navigating-from-login-screenlet}

When login succeeds, the app should open \texttt{GuestbooksActivity}.
You'll do this by using an
\href{https://developer.android.com/guide/components/intents-filters.html}{Android
intent} in \texttt{MainActivity}'s \texttt{onLoginSuccess} method:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Replace the contents of \texttt{onLoginSuccess} with this code:

\begin{verbatim}
Intent intent = new Intent(this, GuestbooksActivity.class);
startActivity(intent);
\end{verbatim}

  When login succeeds, this code creates an \texttt{Intent} and uses it
  to start \texttt{GuestbooksActivity}. If you haven't already, make
  sure to import \texttt{android.content.Intent} in
  \texttt{MainActivity}.
\item
  Now you're ready to see the intent in action! Run the app in the
  emulator and log in when prompted. When login succeeds,
  \texttt{GuestbooksActivity} opens.
\end{enumerate}

\begin{figure}
\centering
\includegraphics{./images/android-login-success-intent.png}
\caption{Upon login, the app takes you to the new activity.}
\end{figure}

Nice work! You successfully implemented Liferay DXP authentication in
your Android app. It didn't take you that long, either. So far, however,
that's all your app does; it doesn't display any content. Next, you'll
rectify this by developing Guestbook List Screenlet.

\chapter{Creating Guestbook List
Screenlet}\label{creating-guestbook-list-screenlet}

In the previous section, you created an Android app that contains the
Guestbook Mobile SDK and Liferay Screens. You also used
\href{/docs/7-0/reference/-/knowledge_base/r/loginscreenlet-for-android}{Login
Screenlet} to implement authentication to Liferay DXP. That's all your
app does though. It doesn't display any Guestbook portlet content. In
this section of the Learning Path, you'll create Guestbook List
Screenlet to retrieve and display the portlet's guestbooks in your app's
navigation drawer.

Creating your own Screenlets brings additional benefits. Since you use a
consistent, repeatable development model to create them, you can often
reuse code when creating other Screenlets. You can also package and
reuse Screenlets in other apps. What's more, Screenlet UIs are fully
pluggable. This lets you change a Screenlet's appearance quickly without
affecting its functionality. In summary, Screenlets are pretty much the
greatest thing since sliced bread. Now it's time to make a sandwich.

As background material, the following materials are helpful:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Getting started: creating the Screenlet's package, and model class.
\item
  Creating the Screenlet's UI (its View).
\item
  Creating the Screenlet's Interactor. Interactors are Screenlet
  components that make server calls.
\item
  Creating the Screenlet class. The Screenlet class governs the
  Screenlet's behavior.
\end{enumerate}

Before beginning, you should read the following tutorials:

\begin{itemize}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/architecture-of-liferay-screens-for-android}{Architecture
  of Liferay Screens for Android}: Explains the components that
  constitute a Screenlet, and how they relate to one another.
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/creating-android-screenlets}{Creating
  Android Screenlets}: Explains the general steps for creating a
  Screenlet.
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/creating-android-list-screenlets}{Creating
  Android List Screenlets}: Explains the general steps for creating a
  list Screenlet. This section of the Learning Path follows this
  tutorial.
\end{itemize}

Note that these tutorials explain Screenlet and list Screenlet concepts
that this Learning Path doesn't cover in depth. Although it's possible
to complete this Learning Path without reading these tutorials, they
explain how Screenlets work in more detail. By reading them you'll be
better able to apply the Learning Path material to your own Screenlets.

If you get confused or stuck while creating Guestbook List Screenlet,
refer to the finished app that contains the Screenlet code
\href{https://github.com/liferay/liferay-docs/tree/master/develop/tutorials/code/mobile/android/screenlets-app/LiferayGuestbook}{here
in GitHub}.

\section{Getting Started with Guestbook List
Screenlet}\label{getting-started-with-guestbook-list-screenlet}

Before creating a Screenlet, you should know how you'll use it. If you
plan to use it in only one app, then you can create it in that app's
project. If you need to use it in several apps, however, then it's best
to create it in a separate project for redistribution. For information
on creating Screenlets for redistribution, see the tutorial
\href{/docs/7-0/tutorials/-/knowledge_base/t/packaging-your-android-screenlets}{Packaging
Your Android Screenlets}. Since you'll use Guestbook List Screenlet in
only this app, you can create it in a new package inside the app's
project. Create this package now:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In Android Studio, right click the \emph{java} folder and select
  \emph{New} → \emph{Package}.
\item
  Select \emph{\ldots/app/src/main/java} as the destination directory,
  and click \emph{OK}.
\item
  Enter \texttt{com.liferay.docs.guestbooklistscreenlet} as the
  package's name and click \emph{OK}. Android Studio lists the new
  package alongside the package that contains the app's activity and
  fragment (\texttt{liferayguestbook}). If it doesn't appear at first,
  you may need to collapse and reopen the \emph{java} folder.
\end{enumerate}

\begin{figure}
\centering
\includegraphics{./images/android-guestbooks-screenlet-package.png}
\caption{Guestbook List Screenlet's new package is highlighted.}
\end{figure}

Before getting started, you should understand how pagination works in
list Screenlets.

\subsection{Pagination}\label{pagination}

To ensure that users can scroll smoothly through large lists of items,
list Screenlets support fluent pagination. Support for this is built
into the list Screenlet framework. You'll see this as you construct your
list Screenlet. For example, several methods have parameters for the
start row and end row of a page in the list.

Now you're ready to begin!

\subsection{Creating the Model Class for
Guestbooks}\label{creating-the-model-class-for-guestbooks}

Entities come back from Liferay Portal in JSON. To work with these
results efficiently in your app, you must convert them to model objects
that represent the entity in the portal. Although Screens's
\href{https://github.com/liferay/liferay-screens/blob/master/android/library/src/main/java/com/liferay/mobile/screens/base/list/interactor/BaseListInteractor.java}{\texttt{BaseListInteractor}}
transforms the JSON entities into \texttt{Map} objects for you, you
still must convert these into proper entity objects for use in your app.
You'll do this via a model class.

The model class you'll create for Guestbook List Screenlet,
\texttt{GuestbookModel}, creates \texttt{GuestbookModel} objects that
represent guestbooks retrieved from the Guestbook portlet. You'll create
this model class in a separate package outside of the
\texttt{guestbooklistscreenlet} package. In this case, it makes sense to
organize your code this way because other Screenlets may also use the
model class. For example, if a Screenlet that edits guestbooks existed,
it would also need \texttt{GuestbookModel} objects. Putting the model
class in a separate package makes it clear that this class doesn't
belong exclusively to a single Screenlet.

Follow these steps to create \texttt{GuestbookModel}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a new package called \texttt{model} inside the
  \texttt{com.liferay.docs} package.
\item
  Inside this new \texttt{model} package, create a new class called
  \texttt{GuestbookModel}.
\item
  Replace \texttt{GuestbookModel}'s contents with this code:

\begin{verbatim}
package com.liferay.docs.model;

import android.os.Parcel;
import android.os.Parcelable;

import java.util.Date;
import java.util.Map;

public class GuestbookModel implements Parcelable {

    private Map values;
    private long guestbookId;
    private long groupId;
    private long companyId;
    private long userId;
    private String userName;
    private long createDate;
    private long modifiedDate;
    private String name;

    public static final Creator<GuestbookModel> CREATOR = new Creator<GuestbookModel>() {
        @Override
        public GuestbookModel createFromParcel(Parcel in) {
            return new GuestbookModel(in);
        }

        @Override
        public GuestbookModel[] newArray(int size) {
            return new GuestbookModel[size];
        }
    };

    public GuestbookModel() {
        super();
    }

    protected GuestbookModel(Parcel in) {
        guestbookId = in.readLong();
        groupId = in.readLong();
        companyId = in.readLong();
        userId = in.readLong();
        userName = in.readString();
        createDate = in.readLong();
        modifiedDate = in.readLong();
        name = in.readString();
    }

    public GuestbookModel(Map<String, Object> stringObjectMap) {
        values = stringObjectMap;
        guestbookId = Long.parseLong((String) stringObjectMap.get("guestbookId"));
        groupId = Long.parseLong((String) stringObjectMap.get("groupId"));
        companyId = Long.parseLong((String) stringObjectMap.get("companyId"));
        userId = Long.parseLong((String) stringObjectMap.get("userId"));
        userName = (String) stringObjectMap.get("userName");
        createDate = (long) stringObjectMap.get("createDate");
        modifiedDate = (long) stringObjectMap.get("modifiedDate");
        name = (String) stringObjectMap.get("name");
    }

    @Override
    public void writeToParcel(Parcel dest, int flags) {
        dest.writeLong(guestbookId);
        dest.writeLong(groupId);
        dest.writeLong(companyId);
        dest.writeLong(userId);
        dest.writeString(userName);
        dest.writeLong(createDate);
        dest.writeLong(modifiedDate);
        dest.writeString(name);
    }

    @Override
    public int describeContents() {
        return 0;
    }

    public long getGuestbookId() {
        return guestbookId;
    }

    public long getGroupId() {
        return groupId;
    }

    public long getCompanyId() {
        return companyId;
    }

    public long getUserId() {
        return userId;
    }

    public String getUserName() {
        return userName;
    }

    public Date getCreateDate() {
        return new Date(createDate);
    }

    public Date getModifiedDate() {
        return new Date(modifiedDate);
    }

    public String getName() {
        return name;
    }

    public Map getValues() {
        return values;
    }

    public void setValues(Map values) {
        this.values = values;
    }
}
\end{verbatim}
\end{enumerate}

This class creates \texttt{GuestbookModel} objects that represent the
Guestbook portlet's \texttt{Guestbook} objects. The constructor with the
\texttt{Map\textless{}String,\ Object\textgreater{}} argument does the
heavy lifting. Following a successful Mobile SDK call, the list
Screenlet framework's
\href{https://github.com/liferay/liferay-screens/blob/2.1.0/android/library/src/main/java/com/liferay/mobile/screens/base/list/interactor/BaseListInteractor.java}{\texttt{BaseListInteractor}
class} returns this \texttt{Map}, which contains the data of a guestbook
retrieved from the portlet. To get the guestbook's data from the
\texttt{Map}, the constructor uses the \texttt{get} method with each
parameter of the portlet's \texttt{Guestbook} entity. To see how the
portlet defines these parameters,
\href{/docs/6-2/tutorials/-/knowledge_base/t/using-service-builder-to-generate-a-persistence-fr}{see
the Liferay MVC Learning Path article on Service Builder}. For now, the
only parameters you really need in \texttt{GuestbookModel} are
\texttt{guestbookId} and \texttt{name}. Because you might need the rest
later, however, it's best to add all of them now.

Besides the getters and setter, the remaining code in
\texttt{GuestbookModel} implements Android's \texttt{Parcelable}
interface. For more information on this, see
\href{https://developer.android.com/reference/android/os/Parcelable.html}{Android's
documentation on \texttt{Parcelable}}.

Great! Now you have a model class for guestbooks. Next, you'll create
the Screenlet's UI.

\section{Creating Guestbook List Screenlet's
UI}\label{creating-guestbook-list-screenlets-ui}

Recall that in Liferay Screens for Android, Screenlet UIs are called
Views, and every Screenlet must have at least one View. In this article,
you'll use the following steps to create a View for Guestbook List
Screenlet:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create the row layout. This layout defines the UI for each row
  instance in the list.
\item
  Create the adapter class. This is an
  \href{https://developer.android.com/guide/topics/ui/declaring-layout.html\#AdapterViews}{Android
  adapter} that fills a row layout instance with the data for one list
  item. This repeats for each list item until the list is full.
\item
  Create the View class. This class renders the UI, handles user
  interactions, and communicates with the Screenlet class.
\item
  Create the View's layout. This layout defines the Screenlet's UI as a
  whole. For a list Screenlet, this is a scrollable list.
\end{enumerate}

Note that these are the same steps for creating a View as those in
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-android-list-screenlets\#creating-the-screenlets-view}{the
list Screenlet tutorial}.

You'll create Guestbook List Screenlet's View in its own package inside
the \texttt{guestbooklistscreenlet} package. Create a new package named
\texttt{view} inside the \texttt{guestbooklistscreenlet} package. Now
you're ready to create the row layout.

\subsection{Creating the Row Layout}\label{creating-the-row-layout}

First, you must create the layout that defines the UI for each row
instance in the list. Since each row in Guestbook List Screenlet
displays only a single guestbook's name, the row layout only needs a
single \texttt{TextView}. Create the layout file
\texttt{res/layout/guestbook\_row.xml} and paste in this content:

\begin{verbatim}
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="vertical">

    <TextView
        android:id="@+id/guestbook_name"
        android:textSize="25sp"
        android:padding="10dp"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"/>

</LinearLayout>
\end{verbatim}

Note that the \texttt{textSize} and \texttt{padding} values result in
clean, readable text for this example. When you develop your own list
Screenlets, you can style your row layouts however you like.

\subsection{Creating the Adapter
Class}\label{creating-the-adapter-class}

\href{https://developer.android.com/guide/topics/ui/declaring-layout.html\#AdapterViews}{Android
adapters} fill a layout with content. In Guestbook List Screenlet, the
layout is \texttt{guestbook\_row.xml} (the row layout) and the content
is a guestbook's name. To make list scrolling smooth, the adapter class
should use an
\href{https://developer.android.com/training/improving-layouts/smooth-scrolling.html\#ViewHolder}{Android
view holder}. To make this easier, you can extend the list Screenlet
framework's
\href{https://github.com/liferay/liferay-screens/blob/master/android/library/src/main/java/com/liferay/mobile/screens/base/list/BaseListAdapter.java}{\texttt{BaseListAdapter}
class} with your model class and view holder as type arguments. By
extending \texttt{BaseListAdapter}, your adapter needs only two methods:

\begin{itemize}
\tightlist
\item
  \texttt{createViewHolder}: instantiates the view holder
\item
  \texttt{fillHolder}: fills in the view holder for each row
\end{itemize}

Your view holder should also contain variables for any data each row
needs to display. The view holder must assign these variables to the
corresponding row layout elements, and set the appropriate data to them.

Inside the Screenlet's \texttt{view} package, create the following
\texttt{GuestbookAdapter} class:

\begin{verbatim}
package com.liferay.docs.guestbooklistscreenlet.view;

import android.support.annotation.NonNull;
import android.view.View;
import android.widget.TextView;

import com.liferay.docs.liferayguestbook.R;
import com.liferay.docs.model.GuestbookModel;
import com.liferay.mobile.screens.base.list.BaseListAdapter;
import com.liferay.mobile.screens.base.list.BaseListAdapterListener;

public class GuestbookAdapter extends 
    BaseListAdapter<GuestbookModel, GuestbookAdapter.GuestbookViewHolder> {

    public GuestbookAdapter(int layoutId, int progressLayoutId, BaseListAdapterListener listener) {
        super(layoutId, progressLayoutId, listener);
    }

    @NonNull
    @Override
    public GuestbookViewHolder createViewHolder(View view, BaseListAdapterListener listener) {
        return new GuestbookAdapter.GuestbookViewHolder(view, listener);
    }

    @Override
    protected void fillHolder(GuestbookModel entry, GuestbookViewHolder holder) {
        holder.bind(entry);
    }

    public class GuestbookViewHolder extends BaseListAdapter.ViewHolder {

        private final TextView name;

        public GuestbookViewHolder(View view, BaseListAdapterListener listener) {
            super(view, listener);

            name = (TextView) view.findViewById(R.id.guestbook_name);
        }

        public void bind(GuestbookModel entry) {
            name.setText(entry.getName());
        }

    }
}
\end{verbatim}

This adapter class extends \texttt{BaseListAdapter} with
\texttt{GuestbookModel} and
\texttt{GuestbookAdapter.GuestbookViewHolder} as type arguments. The
view holder is an inner class that extends \texttt{BaseListAdapter}'s
view holder. Since Guestbook List Screenlet only needs to display a
guestbook's name in each row, the view holder only needs one variable:
\texttt{name}. The view holder's constructor assigns the
\texttt{TextView} from \texttt{guestbook\_row.xml} to this variable. The
\texttt{bind} method then sets the guestbook's name as the
\texttt{TextView}'s text. The other methods in \texttt{GuestbookAdapter}
leverage the view holder. The \texttt{createViewHolder} method
instantiates \texttt{GuestbookViewHolder}. The \texttt{fillHolder}
method calls the view holder's \texttt{bind} method to set the
guestbook's name as the \texttt{name} variable's text.

Next, you'll create the View class.

\subsection{Creating the View Class}\label{creating-the-view-class}

Recall that the View class controls a Screenlet's UI. It renders the UI,
handles user interactions, and communicates with the Screenlet class.
The list Screenlet framework provides most of this functionality for you
via
\href{https://github.com/liferay/liferay-screens/blob/master/android/library/src/main/java/com/liferay/mobile/screens/base/list/BaseListScreenletView.java}{the
\texttt{BaseListScreenletView} class}. Your View class must extend this
class to provide your row layout ID and an instance of your adapter.
You'll do this by overriding \texttt{BaseListScreenletView}'s
\texttt{getItemLayoutId} and \texttt{createListAdapter} methods. Also,
when you extend \texttt{BaseListScreenletView} you must do so with your
model class, view holder, and adapter as type arguments. This is
required for your View class to represent your model objects in a view
holder, inside an adapter.

Create the \texttt{GuestbookListView} class inside the \texttt{view}
package, and replace its contents with this code:

\begin{verbatim}
package com.liferay.docs.guestbooklistscreenlet.view;

import android.content.Context;
import android.util.AttributeSet;

import com.liferay.docs.liferayguestbook.R;
import com.liferay.docs.model.GuestbookModel;
import com.liferay.mobile.screens.base.list.BaseListScreenletView;

public class GuestbookListView extends BaseListScreenletView<GuestbookModel, 
    GuestbookAdapter.GuestbookViewHolder, GuestbookAdapter> {

    public GuestbookListView(Context context) {
        super(context);
    }

    public GuestbookListView(Context context, AttributeSet attributes) {
        super(context, attributes);
    }

    public GuestbookListView(Context context, AttributeSet attributes, int defaultStyle) {
        super(context, attributes, defaultStyle);
    }

    @Override
    protected GuestbookAdapter createListAdapter(int itemLayoutId, int itemProgressLayoutId) {
        return new GuestbookAdapter(itemLayoutId, itemProgressLayoutId, this);
    }

    @Override
    protected int getItemLayoutId() {
        return R.layout.guestbook_row;
    }
}
\end{verbatim}

This View class represents \texttt{GuestbookModel} instances in a
\texttt{GuestbookViewHolder} inside a \texttt{GuestbookAdapter}. This
class therefore extends \texttt{BaseListScreenletView} parameterized
with \texttt{GuestbookModel},
\texttt{GuestbookAdapter.GuestbookViewHolder}, and
\texttt{GuestbookAdapter}. Besides overriding \texttt{createListAdapter}
to return a \texttt{GuestbookAdapter} instance, the only other
functionality that this View class needs to support is to get the layout
for each row in the list. The overridden \texttt{getItemLayoutId} method
does this by returning the row layout \texttt{guestbook\_row}.

Now you're ready to create your View's main layout.

\subsection{Creating the View's Layout}\label{creating-the-views-layout}

Although you already created a layout for your list rows, you must still
create a layout to define the list as a whole. This layout must contain:

\begin{itemize}
\tightlist
\item
  The View class's fully qualified name as the layout's first element.
\item
  An
  \href{http://developer.android.com/training/material/lists-cards.html\#RecyclerView}{Android
  \texttt{RecyclerView}} to let your app efficiently scroll through a
  potentially large list of items.
\item
  An
  \href{https://developer.android.com/reference/android/widget/ProgressBar.html}{Android
  \texttt{ProgressBar}} to indicate progress when loading the list.
\end{itemize}

Apart from the View class and styling, this layout's code is the same
for all list Screenlets.

Create the layout file \texttt{res/layout/list\_guestbooks.xml} and
replace its contents with this code:

\begin{verbatim}
<com.liferay.docs.guestbooklistscreenlet.view.GuestbookListView
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:id="@+id/liferay_list_screenlet"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <ProgressBar
        android:id="@+id/liferay_progress"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="center"
        android:visibility="gone"/>

    <android.support.v7.widget.RecyclerView
        android:id="@+id/liferay_recycler_list"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:visibility="gone"/>
</com.liferay.docs.guestbooklistscreenlet.view.GuestbookListView>
\end{verbatim}

Note that the \texttt{android:id} values in this layout XML are
hardcoded into the Screens framework and changing them will cause your
app to crash.

Great! You're done with Guestbook List Screenlet's View. Next, you'll
create the Screenlet's Interactor.

\section{Creating Guestbook List Screenlet's
Interactor}\label{creating-guestbook-list-screenlets-interactor}

\emph{Interactors} are Screenlet components that make server calls and
process the results. Interactors themselves are made up of several
components:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{The event class:} creates event objects that contain the
  server call's results. Liferay Screens uses these event objects via
  the \href{https://greenrobot.github.io/EventBus/}{EventBus} library to
  communicate the results between the Screenlet's components.
\item
  \textbf{The listener interface:} defines the methods the app developer
  needs to respond to the Screenlet's behavior. For example,
  \href{/docs/7-0/reference/-/knowledge_base/r/loginscreenlet-for-android\#listener}{Login
  Screenlet's listener} defines the \texttt{onLoginSuccess} and
  \texttt{onLoginFailure} methods. Screens calls these methods when
  login succeeds or fails, respectively. By implementing these methods
  in the activity or fragment class that contains the Screenlet, the app
  developer can respond to login success and failure.
\item
  \textbf{The Interactor class:} makes the server calls, processes the
  results in the event objects, and notifies the listener of those
  results.
\end{enumerate}

Since the list Screenlet framework already contains two listener
interfaces, you only need to create the event and Interactor classes.
You'll create the event class first.

\subsection{Creating the Event Class}\label{creating-the-event-class}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  First, create a new package called \texttt{interactor} in the
  \texttt{com.liferay.docs.guestbooklistscreenlet} package. You'll
  create your Interactor's components in this new package.
\item
  A list Screenlet's event class must extend
  \href{https://github.com/liferay/liferay-screens/blob/master/android/library/src/main/java/com/liferay/mobile/screens/base/list/interactor/ListEvent.java}{the
  \texttt{ListEvent} class} with the Screenlet's model class as a type
  argument. This lets the event class contain the server call's results
  as model objects. Guestbook List Screenlet's event class,
  \texttt{GuestbookEvent}, must therefore extend \texttt{ListEvent} with
  \texttt{GuestbookModel} as a type argument. Create this class now in
  the \texttt{interactor} package. The class declaration should look
  like this:

\begin{verbatim}
public class GuestbookEvent extends ListEvent<GuestbookModel> {...
\end{verbatim}

  This requires you to import
  \texttt{com.liferay.docs.model.GuestbookModel} and
  \texttt{com.liferay.mobile.screens.base.list.interactor.ListEvent}.
\item
  The event class should also contain a private instance variable for
  the model class, a constructor that sets this variable, and a
  no-argument constructor that calls the superclass constructor. Add
  this code now:

\begin{verbatim}
private GuestbookModel guestbook;

public GuestbookEvent() {
    super();
}

public GuestbookEvent(GuestbookModel guestbook) {
    this.guestbook = guestbook;
}
\end{verbatim}
\item
  You must also implement \texttt{ListEvent}'s abstract methods in your
  event class. Note that these methods support
  \href{/docs/6-2/tutorials/-/knowledge_base/t/using-offline-mode-in-android}{offline
  mode}. Even though Guestbook List Screenlet doesn't support offline
  mode, you must still implement these methods. Add these methods to
  \texttt{GuestbookEvent} now:

  \begin{itemize}
  \item
    \texttt{getListKey}: returns the ID for the cache. This ID is
    typically the data each list row displays. For example, the
    \texttt{getListKey} method in \texttt{GuestbookEvent} returns the
    guestbook's name:

\begin{verbatim}
  @Override
  public String getListKey() {
      return guestbook.getName();
  }
\end{verbatim}
  \item
    \texttt{getModel}: unwraps the model entity to the cache by
    returning the model class instance. For example, the
    \texttt{getModel} method in \texttt{GuestbookEvent} method returns
    the guestbook:

\begin{verbatim}
  @Override
  public GuestbookModel getModel() {
      return guestbook;
  }
\end{verbatim}
  \end{itemize}
\end{enumerate}

Note that this code is almost identical to the example event class in
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-android-list-screenlets\#creating-the-screenlets-event}{the
list Screenlet tutorial}. The only difference is that
\texttt{GuestbookEvent} handles \texttt{GuestbookModel} objects.

Nice work! Your event class is done. You're almost ready to write the
Screenlet's server call. First, however, you should understand the
basics of how server calls work in Interactors.

\subsection{Understanding Screenlet Server
Calls}\label{understanding-screenlet-server-calls}

Recall that Interactor classes use the Liferay Mobile SDK to make server
calls and process the results. An Interactor class does this with the
following sequence:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Get the Mobile SDK session and use it to create the Mobile SDK service
  you want to call.
\item
  Invoke the Mobile SDK service method that makes the server call.
\item
  Create an event object from the JSON that the server call returns. If
  your Screenlet has a model class, create a model object from this
  JSON, then use the model object to create the event object.
\end{enumerate}

\begin{figure}
\centering
\includegraphics{./images/android-screenlet-server-call.png}
\caption{This diagram shows a typical server call made by a Screenlet's
Interactor. The dashed line around the model class indicates that it's
optional. Although list Screenlets require model classes, non-list
Screenlets don't.}
\end{figure}

To call the Guestbook portlet's remote services, you'll use the
Guestbook Mobile SDK you built and installed earlier. This Mobile SDK
contains the services required to call the Guestbook portlet's remote
services. Next, you'll create Guestbook List Screenlet's Interactor
class.

\subsection{Creating the Interactor
Class}\label{creating-the-interactor-class}

A Screenlet's Interactor class is the central component of the
Interactor. It makes the server calls, processes the results in the
event objects, and notifies the listener of those results. The list
Screenlet framework's
\href{https://github.com/liferay/liferay-screens/blob/master/android/library/src/main/java/com/liferay/mobile/screens/base/list/interactor/BaseListInteractor.java}{\texttt{BaseListInteractor}
class} provides most of the functionality that Interactor classes in
list Screenlets require. You must, however, extend
\texttt{BaseListInteractor} to make your service calls and handle their
results via your model and event classes.

Follow these steps to create Guestbook List Screenlet's Interactor
class, \texttt{GuestbookListInteractor}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create the \texttt{GuestbookListInteractor} class in the package
  \texttt{com.liferay.docs.guestbooklistscreenlet.interactor}. A list
  Screenlet's Interactor class must extend \texttt{BaseListInteractor}
  with
  \texttt{BaseListInteractorListener\textless{}YourModelClass\textgreater{}}
  and your event class as type arguments. You must therefore change
  \texttt{GuestbookListInteractor} to extend \texttt{BaseListInteractor}
  with
  \texttt{BaseListInteractorListener\textless{}GuestbookModel\textgreater{}}
  and \texttt{GuestbookEvent} as type arguments:

\begin{verbatim}
public class GuestbookListInteractor extends 
    BaseListInteractor<BaseListInteractorListener<GuestbookModel>, GuestbookEvent> {...
\end{verbatim}

  This requires that you add the following imports:

\begin{verbatim}
import com.liferay.docs.model.GuestbookModel;
import com.liferay.mobile.screens.base.list.interactor.BaseListInteractor;
import com.liferay.mobile.screens.base.list.interactor.BaseListInteractorListener;
\end{verbatim}
\item
  Override the \texttt{getPageRowsRequest} method to retrieve a page of
  entities. In this method, you can use the \texttt{getSession()} method
  to retrieve the session created by authentication with Login
  Screenlet. Then make the server call by creating a service instance
  from the session and calling the service method that retrieves the
  entities. Guestbook List Screenlet must retrieve a page of guestbooks,
  so you must create a \texttt{GuestbookService} instance from the
  session. Then call the service's \texttt{getGuestbooks} method with
  the \texttt{groupId}, start row, and end row. The \texttt{groupId}
  specifies the site to retrieve guestbooks from, while the start row
  and end row define the list rows that mark the start and end of the
  page of guestbooks, respectively. Add this \texttt{getPageRowsRequest}
  method to \texttt{GuestbookListInteractor}:

\begin{verbatim}
@Override
protected JSONArray getPageRowsRequest(Query query, Object... args) throws Exception {

    return new GuestbookService(getSession()).getGuestbooks(groupId, query.getStartRow(), 
        query.getEndRow());
}
\end{verbatim}

  Note that the \texttt{groupId} variable isn't set anywhere.
  Interactors that extend\\
  \texttt{BaseListInteractor}, like \texttt{GuestbookListInteractor},
  inherit this variable via the Screens framework. You'll set it when
  you create the Screenlet class.

  This \texttt{getPageRowsRequest} method requires that you add the
  following imports:

\begin{verbatim}
import com.liferay.mobile.android.v7.guestbook.GuestbookService;
import com.liferay.mobile.screens.base.list.interactor.Query;
import org.json.JSONArray;
\end{verbatim}
\item
  Override the \texttt{getPageRowCountRequest} method to retrieve the
  total number of entities. This enables pagination. In
  \texttt{GuestbookListInteractor}, you retrieve the total number of
  guestbooks from a site by creating a \texttt{GuestbookService}
  instance from the session and then calling the service's
  \texttt{getGuestbooksCount} method with the \texttt{groupId}. Add this
  \texttt{getPageRowCountRequest} method to
  \texttt{GuestbookListInteractor}:

\begin{verbatim}
@Override
protected Integer getPageRowCountRequest(Object... args) throws Exception {

    return new GuestbookService(getSession()).getGuestbooksCount(groupId);
}
\end{verbatim}
\item
  Override the \texttt{createEntity} method to create and return a new
  event object containing the server call's results. The
  \texttt{BaseListInteractor} class converts the JSON that results from
  a successful server call into a
  \texttt{Map\textless{}String,\ Object\textgreater{}}. The
  \texttt{createEntity} method's only argument is this \texttt{Map},
  which you use to create a \texttt{GuestbookModel} object. Then use the
  model object to create and return a new \texttt{GuestbookEvent}
  object. Add this \texttt{createEntity} method to
  \texttt{GuestbookListInteractor}:

\begin{verbatim}
@Override
protected GuestbookEvent createEntity(Map<String, Object> stringObjectMap) {
    GuestbookModel guestbook = new GuestbookModel(stringObjectMap);
    return new GuestbookEvent(guestbook);
}
\end{verbatim}

  This requires you to import \texttt{java.util.Map}.
\item
  Override the \texttt{getIdFromArgs} method to return the value of the
  first object argument as a string. Add this method to
  \texttt{GuestbookListInteractor}:

\begin{verbatim}
@Override
protected String getIdFromArgs(Object... args) {
    return String.valueOf(args[0]);
}
\end{verbatim}

  This is a boilerplate method that returns a cache key for
  \href{/docs/7-0/tutorials/-/knowledge_base/t/using-offline-mode-in-android}{offline
  mode}. Even though you won't add offline mode support to Guestbook
  List Screenlet, this method makes it easier if you decide to do so
  later.
\end{enumerate}

Nice work! Your Interactor class is finished. Note that this class is
very similar to the Interactor class in
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-android-list-screenlets\#creating-the-screenlets-interactor}{the
list Screenlet creation tutorial}.

Your Interactor is finished too. Next, you'll create the Screenlet
class.

\section{Creating Guestbook List Screenlet's Screenlet
Class}\label{creating-guestbook-list-screenlets-screenlet-class}

When using a Screenlet, app developers primarily interact with its
Screenlet class. The Screenlet class contains attributes for configuring
the Screenlet's behavior, a reference to the Screenlet's View, methods
for invoking Interactor operations, and more.

You'll use these steps to create the Screenlet class:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Define the Screenlet's attributes. These are the XML attributes the
  app developer can set when inserting the Screenlet's XML. These
  attributes control aspects of the Screenlet's behavior.
\item
  Create the Screenlet class. This class implements the Screenlet's
  functionality defined in the View and Interactor. It also reads the
  attribute values and configures the Screenlet accordingly.
\end{enumerate}

First, you'll define Guestbook List Screenlet's attributes.

\subsection{Defining Screenlet
Attributes}\label{defining-screenlet-attributes}

Before creating the Screenlet class, you should define its attributes.
These are the attributes the app developer can set when inserting the
Screenlet's XML in an activity or fragment layout. For example, to use
\href{/docs/7-0/reference/-/knowledge_base/r/loginscreenlet-for-android}{Login
Screenlet}, the app developer could insert the following Login Screenlet
XML in an activity or fragment layout:

\begin{verbatim}
<com.liferay.mobile.screens.auth.login.LoginScreenlet
    android:id="@+id/login_screenlet"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    app:basicAuthMethod="email"
    app:layoutId="@layout/login_default"
    />
\end{verbatim}

The app developer can set the \texttt{app} attributes
\texttt{basicAuthMethod} and \texttt{layoutId} to set Login Screenlet's
authentication method and View, respectively. The Screenlet class reads
these settings to enable the appropriate functionality.

When creating a Screenlet, you can define the attributes you want to
make available to app developers. You do this in an XML file inside your
Android project's \texttt{res/values} directory. Guestbook List
Screenlet only needs one attribute. You'll define it now. Create the
file \texttt{guestbook\_attrs.xml} in your app's \texttt{res/values}
directory. Replace the file's contents with the following code:

\begin{verbatim}
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <declare-styleable name="GuestbookListScreenlet">
        <attr name="groupId"/>
    </declare-styleable>
</resources>
\end{verbatim}

This defines the \texttt{groupId} attribute, which the app developer can
use to set the portal site to communicate with if they don't want to use
the default \texttt{groupId} setting in \texttt{server\_context.xml}.
You'll account for this attribute's functionality in the Screenlet
class.

Now that you've defined this attribute and know what it needs to do,
you're ready to write the Screenlet class.

\subsection{Extending
BaseListScreenlet}\label{extending-baselistscreenlet}

Because
\href{https://github.com/liferay/liferay-screens/blob/master/android/library/src/main/java/com/liferay/mobile/screens/base/list/BaseListScreenlet.java}{the
\texttt{BaseListScreenlet} class} provides the basic functionality for
all Screenlet classes in list Screenlets, including methods for
pagination and other default behavior, your Screenlet class must extend
\texttt{BaseListScreenlet} with your model class and Interactor as type
arguments.

Use the following steps to create the Screenlet class for Guestbook List
Screenlet, \texttt{GuestbookListScreenlet}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create the \texttt{GuestbookListScreenlet} class in the package
  \texttt{com.liferay.docs.guestbooklistscreenlet}. This class must
  extend \texttt{BaseListScreenlet} with the model and Interactor as
  type arguments:

\begin{verbatim}
public class GuestbookListScreenlet extends 
    BaseListScreenlet<GuestbookModel, GuestbookListInteractor> {...
\end{verbatim}

  This requires you to add the following imports:

\begin{verbatim}
import com.liferay.docs.guestbooklistscreenlet.interactor.GuestbookListInteractor;
import com.liferay.docs.model.GuestbookModel;
import com.liferay.mobile.screens.base.list.BaseListScreenlet;
\end{verbatim}
\item
  For constructors, leverage the superclass constructors:

\begin{verbatim}
public GuestbookListScreenlet(Context context) {
    super(context);
}

public GuestbookListScreenlet(Context context, AttributeSet attrs) {
    super(context, attrs);
}

public GuestbookListScreenlet(Context context, AttributeSet attrs, int defStyleAttr) {
    super(context, attrs, defStyleAttr);
}

public GuestbookListScreenlet(Context context, AttributeSet attrs, int defStyleAttr, 
    int defStyleRes) {
        super(context, attrs, defStyleAttr, defStyleRes);
}
\end{verbatim}

  This requires you to add the following imports:

\begin{verbatim}
import android.content.Context;
import android.util.AttributeSet;
\end{verbatim}
\item
  Implement the \texttt{error} method. This is a boilerplate method that
  uses a listener in the Screenlet framework to propagate any exception,
  and the user action that produced it, that occurs during the service
  call. This method does this by checking for a listener and then
  calling its \texttt{error} method with the \texttt{Exception} and
  \texttt{userAction}:

\begin{verbatim}
@Override
public void error(Exception e, String userAction) {
    if (getListener() != null) {
        getListener().error(e, userAction);
    }
}
\end{verbatim}
\item
  Override the \texttt{createScreenletView} method. This method reads
  the Screenlet's attribute values via an
  \href{https://developer.android.com/reference/android/content/res/TypedArray.html}{Android
  \texttt{TypedArray}}, and instantiates the View. In Guestbook List
  Screenlet, you only need to read the value of the \texttt{groupId}
  attribute and set it to the \texttt{groupId} variable. Recall that the
  Screens framework propagates this variable to your Interactor. Finish
  the \texttt{createScreenletView} method by calling the superclass's
  \texttt{createScreenletView} method. This instantiates the View for
  you:

\begin{verbatim}
@Override
protected View createScreenletView(Context context, AttributeSet attributes) {
    TypedArray typedArray = context.getTheme().obtainStyledAttributes(attributes, 
        R.styleable.GuestbookListScreenlet, 0, 0);
    groupId = typedArray.getInt(R.styleable.GuestbookListScreenlet_groupId, 
        (int) LiferayServerContext.getGroupId());
    typedArray.recycle();

    return super.createScreenletView(context, attributes);
}
\end{verbatim}

  Note that if the app developer doesn't set the \texttt{groupId}
  attribute, \texttt{LiferayServerContext.getGroupId()} is called to
  retrieve the app's default \texttt{liferay\_group\_id} setting from
  \texttt{res/values/server\_context.xml}.

  This \texttt{createScreenletView} method requires you to add the
  following imports:

\begin{verbatim}
import android.content.res.TypedArray;
import android.view.View;
import com.liferay.docs.liferayguestbook.R;
import com.liferay.mobile.screens.context.LiferayServerContext;
\end{verbatim}
\item
  Override the \texttt{loadRows} method to start your Interactor and
  thereby retrieve the list rows from the server. This method takes an
  instance of your Interactor as an argument, which you use to call the
  Interactor's \texttt{start} method. The \texttt{loadRows} method in
  \texttt{GuestbookListScreenlet} therefore starts a
  \texttt{GuestbookListInteractor} instance. Note that the Interactor
  inherits \texttt{start} from \texttt{BaseListInteractor}. Also,
  because you don't need to pass any data to
  \texttt{GuestbookListInteractor}, you can call the \texttt{start}
  method with \texttt{0} as an argument:

\begin{verbatim}
@Override
protected void loadRows(GuestbookListInteractor interactor) {
    interactor.start(0);
}
\end{verbatim}
\item
  Override the \texttt{createInteractor} method to instantiate your
  Interactor. Since that's all this method needs to do, call your
  Interactor's constructor and return the new instance:

\begin{verbatim}
@Override
protected GuestbookListInteractor createInteractor(String actionName) {
    return new GuestbookListInteractor();
}
\end{verbatim}
\end{enumerate}

Awesome! Your Screenlet class is finished. Note that this Screenlet
class is very similar to the one in
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-android-list-screenlets\#creating-the-screenlet-class}{the
list Screenlet creation tutorial}.

Your Screenlet is finished, too! Before using Guestbook List Screenlet,
however, you'll create Entry List Screenlet to show a list of each
guestbook's entries. After all, viewing guestbooks without their entries
doesn't make much sense. It isn't very exciting either. What's really
exciting is that you can create Entry List Screenlet with the same set
of steps you used to create Guestbook List Screenlet. The next series of
articles in this Learning Path walks you through this.

\chapter{Creating Entry List
Screenlet}\label{creating-entry-list-screenlet}

In the previous section, you created Guestbook List Screenlet to
retrieve and display guestbooks from the Guestbook portlet. You still
need a way to retrieve and display each guestbook's entries, though.
You'll do this by creating another list Screenlet: Entry List Screenlet.
This section walks you through the steps required to create it.

Because you use a consistent development model to create Screenlets,
similar Screenlets have similar code. As with guestbooks, it makes sense
to display entries in a list using a list Screenlet. This means you can
reuse most of Guestbook List Screenlet's code in Entry List Screenlet.
You'll therefore create Entry List Screenlet using the same sequence of
steps you used to create Guestbook List Screenlet:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Getting started: creating the Screenlet's package and model class.
\item
  Creating the Screenlet's UI (its View).
\item
  Creating the Screenlet's Interactor.
\item
  Creating the Screenlet class.
\end{enumerate}

Although this Learning Path section presents complete code snippets, it
only discusses the code unique to Entry List Screenlet. Refer back to
the previous section for detailed explanations of the code shared with
Guestbook List Screenlet. If you get confused or stuck, refer to the
finished app that contains the Screenlet code
\href{https://github.com/liferay/liferay-docs/tree/master/develop/tutorials/code/mobile/android/screenlets-app/LiferayGuestbook}{here
in GitHub}.

\section{Getting Started with Entry List
Screenlet}\label{getting-started-with-entry-list-screenlet}

Like Guestbook List Screenlet, you'll create Entry List Screenlet in a
new package inside your app's project. Get started by creating the
package \texttt{com.liferay.docs.entrylistscreenlet}. Once you have this
package, you're ready to start writing the Screenlet.

\subsection{Creating the Model Class for
Entries}\label{creating-the-model-class-for-entries}

Recall that you need a model class to represent entities retrieved from
Liferay DXP. The model class you'll create for guestbook entries,
\texttt{EntryModel}, creates \texttt{EntryModel} objects that serve as
guestbook entries retrieved from the Guestbook portlet.

Create the following \texttt{EntryModel} class alongside the
\texttt{GuestbookModel} class in the \texttt{com.liferay.docs.model}
package:

\begin{verbatim}
package com.liferay.docs.model;

import android.os.Parcel;
import android.os.Parcelable;

import java.util.Date;
import java.util.Map;

public class EntryModel implements Parcelable {

    private Map values;
    private long entryId;
    private long groupId;
    private long companyId;
    private long userId;
    private String userName;
    private long createDate;
    private long modifiedDate;
    private String name;
    private String email;
    private String message;
    private long guestbookId;

    public static final Creator<EntryModel> CREATOR = new Creator<EntryModel>() {
        @Override
        public EntryModel createFromParcel(Parcel in) {
            return new EntryModel(in);
        }

        @Override
        public EntryModel[] newArray(int size) {
            return new EntryModel[size];
        }
    };

    public EntryModel() {
        super();
    }

    protected EntryModel(Parcel in) {
        entryId = in.readLong();
        groupId = in.readLong();
        companyId = in.readLong();
        userId = in.readLong();
        userName = in.readString();
        createDate = in.readLong();
        modifiedDate = in.readLong();
        name = in.readString();
        email = in.readString();
        message = in.readString();
        guestbookId = in.readLong();
    }

    public EntryModel(Map<String, Object> stringObjectMap) {
        values = stringObjectMap;
        entryId = Long.parseLong((String) stringObjectMap.get("entryId"));
        groupId = Long.parseLong((String) stringObjectMap.get("groupId"));
        companyId = Long.parseLong((String) stringObjectMap.get("companyId"));
        userId = Long.parseLong((String) stringObjectMap.get("userId"));
        userName = (String) stringObjectMap.get("userName");
        createDate = (long) stringObjectMap.get("createDate");
        modifiedDate = (long) stringObjectMap.get("modifiedDate");
        name = (String) stringObjectMap.get("name");
        email = (String) stringObjectMap.get("email");
        message = (String) stringObjectMap.get("message");
        guestbookId = Long.parseLong((String) stringObjectMap.get("guestbookId"));
    }

    @Override
    public void writeToParcel(Parcel dest, int flags) {
        dest.writeLong(entryId);
        dest.writeLong(groupId);
        dest.writeLong(companyId);
        dest.writeLong(userId);
        dest.writeString(userName);
        dest.writeLong(createDate);
        dest.writeLong(modifiedDate);
        dest.writeString(name);
        dest.writeString(email);
        dest.writeString(message);
        dest.writeLong(guestbookId);
    }

    @Override
    public int describeContents() {
        return 0;
    }

    public Map getValues() {
        return values;
    }

    public void setValues(Map values) {
        this.values = values;
    }

    public long getEntryId() {
        return entryId;
    }

    public long getGroupId() {
        return groupId;
    }

    public long getCompanyId() {
        return companyId;
    }

    public long getUserId() {
        return userId;
    }

    public String getUserName() {
        return userName;
    }

    public Date getCreateDate() {
        return new Date(createDate);
    }

    public Date getModifiedDate() {
        return new Date(modifiedDate);
    }

    public String getName() {
        return name;
    }

    public String getEmail() {
        return email;
    }

    public String getMessage() {
        return message;
    }

    public long getGuestbookId() {
        return guestbookId;
    }

}
\end{verbatim}

Besides working with entries instead of guestbooks, this class works the
same as \texttt{GuestbookModel}. For an explanation of the code, see
\href{/docs/7-0/tutorials/-/knowledge_base/t/getting-started-with-guestbook-list-screenlet}{the
article on getting started with Guestbook List Screenlet}.

Next, you'll create the Screenlet's UI.

\section{Creating Entry List Screenlet's
UI}\label{creating-entry-list-screenlets-ui}

Once you have the model class for entries, you can create the
Screenlet's UI. Recall that in Liferay Screens for Android, you create a
Screenlet's UI by implementing a View. In this article, you'll create
Entry List Screenlet's View by using the same sequence of steps you used
to create Guestbook List Screenlet's View:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create the row layout. This layout defines the UI for each row in the
  list.
\item
  Create the adapter class. The adapter fills a row layout instance with
  the data for one list item. This repeats for each list item.
\item
  Create the View class. This class renders the UI, handles user
  interactions, and communicates with the Screenlet class.
\item
  Create the View's layout. This layout defines the Screenlet's UI as a
  whole. For a list Screenlet, this is a scrollable list.
\end{enumerate}

As you follow these steps, you'll see that Entry List Screenlet's View
shares a great deal of code with Guestbook List Screenlet's View. The
biggest difference between these Views is that one displays guestbooks
and the other displays entries. The mechanisms they use to display data,
however, are almost identical.

To get started, create a new package named \texttt{view} inside the
\texttt{entrylistscreenlet} package. You'll create the row layout first.

\subsection{Creating the Row Layout}\label{creating-the-row-layout-1}

You must create the layout that defines the Screenlet's UI for each list
row instance. Recall that in Guestbook List Screenlet,
\texttt{guestbook\_row.xml} serves this purpose with a single
\texttt{TextView} it uses to display a guestbook's name. You'll create a
similar layout here for Entry List Screenlet, but you'll use two
\texttt{TextView} elements: one for the entry and one for the name of
the person that left it. Create \texttt{entry\_row.xml} in your app's
\texttt{res/layout} directory and replace its contents with this code:

\begin{verbatim}
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="vertical">

    <TextView
        android:id="@+id/entry_message"
        android:textSize="25sp"
        android:textStyle="bold"
        android:paddingLeft="10dp"
        android:paddingRight="10dp"
        android:paddingBottom="1dp"
        android:paddingTop="10dp"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"/>

    <TextView
        android:id="@+id/entry_name"
        android:textSize="15sp"
        android:paddingLeft="10dp"
        android:paddingRight="10dp"
        android:paddingBottom="10dp"
        android:paddingTop="1dp"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"/>

</LinearLayout>
\end{verbatim}

You'll use the first \texttt{TextView} (\texttt{entry\_message}) to
display the entry, and the second \texttt{TextView}
(\texttt{entry\_name}) to display the name of the person that left it.
The \texttt{padding} settings in each \texttt{TextView} element group
the text closer together and create extra space at the top and bottom of
the row. This makes it clear that the text in each row belongs together
as a single list item. Of course, this is only one of many possible
representations. You can style each row as you wish.

Next, you'll create your Screenlet's adapter class.

\subsection{Creating the Adapter
Class}\label{creating-the-adapter-class-1}

Recall that an adapter class is required to fill each row with data.
Entry List Screenlet's adapter class is almost identical to that of
Guestbook List Screenlet. The only difference, besides working with
\texttt{EntryModel} instead of \texttt{GuestbookModel}, is that it needs
two variables: one for the entry and one for the name of the person who
left it. In contrast, Guestbook List Screenlet's adapter class needed
only one variable for the guestbook's name.

Inside the Entry List Screenlet's \texttt{view} package, create the
following \texttt{EntryAdapter} class:

\begin{verbatim}
package com.liferay.docs.entrylistscreenlet.view;

import android.support.annotation.NonNull;
import android.view.View;
import android.widget.TextView;

import com.liferay.docs.liferayguestbook.R;
import com.liferay.docs.model.EntryModel;
import com.liferay.mobile.screens.base.list.BaseListAdapter;
import com.liferay.mobile.screens.base.list.BaseListAdapterListener;


public class EntryAdapter extends BaseListAdapter<EntryModel, EntryAdapter.EntryViewHolder> {

    public EntryAdapter(int layoutId, int progressLayoutId, BaseListAdapterListener listener) {
        super(layoutId, progressLayoutId, listener);
    }

    @NonNull
    @Override
    public EntryViewHolder createViewHolder(View view, BaseListAdapterListener listener) {
        return new EntryAdapter.EntryViewHolder(view, listener);
    }

    @Override
    protected void fillHolder(EntryModel entry, EntryViewHolder holder) {
        holder.bind(entry);
    }

    public class EntryViewHolder extends BaseListAdapter.ViewHolder {

        private final TextView message;
        private final TextView name;

        public EntryViewHolder(View view, BaseListAdapterListener listener) {
            super(view, listener);

            message = (TextView) view.findViewById(R.id.entry_message);
            name = (TextView) view.findViewById(R.id.entry_name);
        }

        public void bind(EntryModel entry) {
            message.setText(entry.getMessage());
            name.setText(entry.getName());
        }

    }
}
\end{verbatim}

For an explanation of how this code works, see
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-guestbook-list-screenlets-ui\#creating-the-adapter-class}{the
section on the adapter class} in the article on Creating Guestbook List
Screenlet's UI.

Now you're ready to create the View class.

\subsection{Creating the View Class}\label{creating-the-view-class-1}

Recall that the View class controls a Screenlet's UI. Because Entry List
Screenlet is so similar to Guestbook List Screenlet, their View classes
are almost identical. The only difference is--you guessed it--one uses
entries and the other uses guestbooks. For a full explanation of the
View class, see
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-guestbook-list-screenlets-ui\#creating-the-view-class}{the
section on the View class} in the article on Creating Guestbook List
Screenlet's UI.

Create the \texttt{EntryListView} class inside Entry List Screenlet's
\texttt{view} package, and replace its contents with this code:

\begin{verbatim}
package com.liferay.docs.entrylistscreenlet.view;

import android.content.Context;
import android.util.AttributeSet;

import com.liferay.docs.liferayguestbook.R;
import com.liferay.docs.model.EntryModel;
import com.liferay.mobile.screens.base.list.BaseListScreenletView;


public class EntryListView extends BaseListScreenletView<EntryModel, 
    EntryAdapter.EntryViewHolder, EntryAdapter> {

    public EntryListView(Context context) {
        super(context);
    }

    public EntryListView(Context context, AttributeSet attributes) {
        super(context, attributes);
    }

    public EntryListView(Context context, AttributeSet attributes, int defaultStyle) {
        super(context, attributes, defaultStyle);
    }

    @Override
    protected EntryAdapter createListAdapter(int itemLayoutId, int itemProgressLayoutId) {
        return new EntryAdapter(itemLayoutId, itemProgressLayoutId, this);
    }

    @Override
    protected int getItemLayoutId() {
        return R.layout.entry_row;
    }
}
\end{verbatim}

Fabulous work! Next, you'll create your View's main layout.

\subsection{Creating the View's
Layout}\label{creating-the-views-layout-1}

In the first step, you created a layout for each list row. Recall that
you must also create a layout for the list as a whole. Although you may
be getting tired of hearing this, it's saving you a great deal of work:
Entry List Screenlet's layout is almost identical to that of Guestbook
List Screenlet. The only difference is that Entry List Screenlet's
layout uses \texttt{EntryListView} instead of
\texttt{GuestbookListView}.

Create the file \texttt{list\_entries.xml} in the \texttt{res/layout}
directory, and replace its contents with this code:

\begin{verbatim}
<com.liferay.docs.entrylistscreenlet.view.EntryListView
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:id="@+id/liferay_list_screenlet"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <ProgressBar
        android:id="@+id/liferay_progress"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="center"
        android:visibility="gone"/>

    <android.support.v7.widget.RecyclerView
        android:id="@+id/liferay_recycler_list"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:visibility="gone"/>
</com.liferay.docs.entrylistscreenlet.view.EntryListView>
\end{verbatim}

For a full explanation of this layout, see
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-guestbook-list-screenlets-ui\#creating-the-views-layout}{the
section on creating the layout} in the article on creating Guestbook
List Screenlet's UI. You must also be sure not to change the layout's
\texttt{android:id} values. They're hard-coded into the list Screenlet
framework and changing them will cause your app to crash.

Nice job! You're done creating Entry List Screenlet's View. Next, you'll
create the Screenlet's Interactor.

\section{Creating Entry List Screenlet's
Interactor}\label{creating-entry-list-screenlets-interactor}

Recall that Interactors are Screenlet components that make server calls
and process the results. Also recall that Interactors themselves are
made up of several components:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  The event class
\item
  The listener interface
\item
  The Interactor class
\end{enumerate}

Since the list Screenlet framework already contains two listeners, you
only need to create the event and Interactor classes. This article walks
you through the steps required do this. Because Entry List Screenlet's
Interactor is so similar to that of Guestbook List Screenlet, these
steps aren't explained in detail. Focus is instead placed on the few
places in the code where the Interactors diverge. For a full explanation
of the code, see the article on creating
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-guestbook-list-screenlets-interactor}{Guestbook
List Screenlet's Interactor}.

You'll create the event class first.

\subsection{Creating the Event Class}\label{creating-the-event-class-1}

Recall that you must create an event class to communicate the server
call's results via \href{http://greenrobot.org/eventbus/}{EventBus}.
First, create a new package called \texttt{interactor} in the
\texttt{com.liferay.docs.entrylistscreenlet} package. Then create the
\texttt{EntryEvent} class in the \texttt{interactor} package. Replace
this class's contents with this code:

\begin{verbatim}
package com.liferay.docs.entrylistscreenlet.interactor;

import com.liferay.docs.model.EntryModel;
import com.liferay.mobile.screens.base.list.interactor.ListEvent;

public class EntryEvent extends ListEvent<EntryModel> {

    private EntryModel entry;

    public EntryEvent() {
        super();
    }

    public EntryEvent(EntryModel entry) {
        this.entry = entry;
    }

    @Override
    public String getListKey() {
        return entry.getMessage();
    }

    @Override
    public EntryModel getModel() {
        return entry;
    }
}
\end{verbatim}

This code is almost identical to \texttt{GuestbookEvent}. The only
difference is that it works with entries instead of guestbooks.

Next, you'll create the Interactor class.

\subsection{Creating the Interactor
Class}\label{creating-the-interactor-class-1}

Recall that an Interactor class issues the server call and processes the
results via the event. In the \texttt{interactor} package, create a new
class called \texttt{EntryListInteractor}. Replace this class's content
with this code:

\begin{verbatim}
package com.liferay.docs.entrylistscreenlet.interactor;

import com.liferay.docs.model.EntryModel;
import com.liferay.mobile.android.v7.entry.EntryService;
import com.liferay.mobile.screens.base.list.interactor.BaseListInteractor;
import com.liferay.mobile.screens.base.list.interactor.BaseListInteractorListener;
import com.liferay.mobile.screens.base.list.interactor.Query;

import org.json.JSONArray;
import java.util.Map;

public class EntryListInteractor extends
    BaseListInteractor<BaseListInteractorListener<EntryModel>, EntryEvent> {

    @Override
    protected JSONArray getPageRowsRequest(Query query, Object... args) throws Exception {

        long guestbookId = (long) args[0];
        return new EntryService(getSession()).getEntries(groupId, guestbookId, 
            query.getStartRow(), query.getEndRow());
    }

    @Override
    protected Integer getPageRowCountRequest(Object... args) throws Exception {

        long guestbookId = (long) args[0];
        return new EntryService(getSession()).getEntriesCount(groupId, guestbookId);
    }

    @Override
    protected EntryEvent createEntity(Map<String, Object> stringObjectMap) {
        EntryModel entry = new EntryModel(stringObjectMap);
        return new EntryEvent(entry);
    }

    @Override
    protected String getIdFromArgs(Object... args) {
        return String.valueOf(args[0]);
    }
}
\end{verbatim}

Besides getting entries instead of guestbooks, this class is almost
identical to \texttt{GuestbookListInteractor}. The only other
differences are due to the service calls that retrieve the entries and
number of entries from a guestbook in the Guestbook portlet. These
service calls, made in \texttt{getPageRowsRequest} and
\texttt{getPageRowCountRequest}, require an \texttt{EntryService}
instance. The \texttt{getEntries} method retrieves a guestbook's
entries, and the \texttt{getEntriesCount} method retrieves the number of
entries in a guestbook. Note that these calls require a guestbook ID
(\texttt{guestbookId}) in addition to the group ID (\texttt{groupId}).
The \texttt{getPageRowsRequest} and \texttt{getPageRowCountRequest}
methods get the \texttt{guestbookId} from the \texttt{args} argument,
and then use it along with \texttt{groupId} make their service calls.
You'll see how the \texttt{guestbookId} gets into the \texttt{args}
argument when you create the Screenlet class.

Nicely done! Now that Entry List Screenlet has an Interactor, you must
create the Screenlet class. The next article shows you how to do this.

\section{Creating Entry List Screenlet's Screenlet
Class}\label{creating-entry-list-screenlets-screenlet-class}

Recall that when using a Screenlet, the app developer primarily
interacts with its Screenlet class. The Screenlet class contains
attributes for configuring the Screenlet's behavior, a reference to the
Screenlet's View, methods for invoking Interactor operations, and more.
This article shows you how to create Entry List Screenlet's Screenlet
class.

As with most of Entry List Screenlet, its Screenlet class is almost
identical to that of Guestbook List Screenlet. Besides working with
entries instead of guestbooks, the only difference is that it must know
its entries' guestbook ID. Even the Screenlets' attributes are the same.

Therefore, this article doesn't explain all the code in detail. Focus is
instead placed on the few parts that differ from Guestbook List
Screenlet. For a full explanation of the code,
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-guestbook-list-screenlets-screenlet-class}{click
here} to see the article on creating Guestbook List Screenlet's
Screenlet class.

You'll create Entry List Screenlet's class with the same steps you used
to create Guestbook List Screenlet's class:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Define the Screenlet's attributes. These are the XML attributes the
  app developer can set when inserting the Screenlet's XML. These
  attributes control aspects of the Screenlet's behavior.
\item
  Create the Screenlet class. This class implements the Screenlet's
  functionality defined in the View and Interactor. It also reads the
  attribute values and configures the Screenlet accordingly.
\end{enumerate}

First, you'll define Entry List Screenlet's attributes.

\subsection{Defining Screenlet
Attributes}\label{defining-screenlet-attributes-1}

Recall that before creating the Screenlet class, you must define the
attributes the app developer needs to control the Screenlet's behavior.
Entry List Screenlet, like Guestbook List Screenlet, only needs a
\texttt{groupId} attribute. In your app's \texttt{res/values} directory,
create \texttt{entry\_attrs.xml} and replace its contents with this
code:

\begin{verbatim}
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <declare-styleable name="EntryListScreenlet">
        <attr name="groupId"/>
    </declare-styleable>
</resources>
\end{verbatim}

Next, you'll create the Screenlet class.

\subsection{Creating the Screenlet
Class}\label{creating-the-screenlet-class}

Entry List Screenlet's class must contain an instance variable for the
ID of the guestbook the Screenlet retrieves entries from. This is
required to start the Interactor. This is the only significant
difference between the Screenlet classes of Entry List Screenlet and
Guestbook List Screenlet. The remaining differences exist only because
they handle different entities.

Create the \texttt{EntryListScreenlet} class in the
\texttt{entrylistscreenlet} package. Replace the class's content with
this code:

\begin{verbatim}
package com.liferay.docs.entrylistscreenlet;

import android.content.Context;
import android.content.res.TypedArray;
import android.util.AttributeSet;
import android.view.View;

import com.liferay.docs.entrylistscreenlet.interactor.EntryListInteractor;
import com.liferay.docs.liferayguestbook.R;
import com.liferay.docs.model.EntryModel;
import com.liferay.mobile.screens.base.list.BaseListScreenlet;
import com.liferay.mobile.screens.context.LiferayServerContext;

public class EntryListScreenlet extends BaseListScreenlet<EntryModel, EntryListInteractor> {

    private long guestbookId;

    public EntryListScreenlet(Context context) {
        super(context);
    }

    public EntryListScreenlet(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    public EntryListScreenlet(Context context, AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
    }

    public EntryListScreenlet(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) {
        super(context, attrs, defStyleAttr, defStyleRes);
    }

    @Override
    public void error(Exception e, String userAction) {
        if (getListener() != null) {
            getListener().error(e, userAction);
        }
    }

    @Override
    protected View createScreenletView(Context context, AttributeSet attributes) {
        TypedArray typedArray = context.getTheme().obtainStyledAttributes(attributes,
            R.styleable.GuestbookListScreenlet, 0, 0);
        groupId = typedArray.getInt(R.styleable.GuestbookListScreenlet_groupId,
            (int) LiferayServerContext.getGroupId());
        typedArray.recycle();

        return super.createScreenletView(context, attributes);
    }

    @Override
    protected void loadRows(EntryListInteractor interactor) {
        interactor.start(guestbookId);
    }

    @Override
    protected EntryListInteractor createInteractor(String actionName) {
        return new EntryListInteractor();
    }

    public long getGuestbookId() {
        return guestbookId;
    }

    public void setGuestbookId(long guestbookId) {
        this.guestbookId = guestbookId;
    }
}
\end{verbatim}

The instance variable for the guestbook ID is \texttt{guestbookId}. The
getter and setter methods \texttt{getGuestbookId} and
\texttt{setGuestbookId} let the app developer get and set this variable,
respectively. The \texttt{loadRows} method starts the Interactor by
calling the \texttt{start} method with \texttt{guestbookId} as an
argument. Behind the scenes, the list Screenlet framework passes
\texttt{guestbookId} to the Interactor's \texttt{getPageRowsRequest} and
\texttt{getPageRowCountRequest} methods via the \texttt{args} argument.
This is why you were able to extract \texttt{guestbookId} from the
\texttt{args} argument in these methods. For an explanation of how the
rest of this Screenlet class works,
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-guestbook-list-screenlets-screenlet-class}{click
here} to see the article on creating Guestbook List Screenlet's
Screenlet class.

That's it! Now you're ready to use Entry List Screenlet alongside
Guestbook List Screenlet. The following section of this Learning Path
concludes with both Screenlets working together in harmony.

\chapter{Using the Guestbook List and Entry List
Screenlets}\label{using-the-guestbook-list-and-entry-list-screenlets}

Now that you have the Guestbook List and Entry List Screenlets, you're
ready to put them to work. As you'll see, using these Screenlets isn't
much more difficult than using Login Screenlet. This is an advantage of
Screenlets; it typically takes only a few minutes to get them up and
running. They also integrate with the rest of your app's UI.

To add your Screenlets to the app, you'll follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Understand how \texttt{GuestbooksActivity}'s UI works. Since your
  Screenlets augment this UI instead of replacing it, you should first
  understand how it works.
\item
  Prepare \texttt{GuestbooksActivity} for Guestbook List Screenlet.
\item
  Use Guestbook List Screenlet by inserting it in
  \texttt{GuestbooksActivity}.
\item
  Create \texttt{EntriesFragment} for Entry List Screenlet. You'll also
  set \texttt{GuestbooksActivity} to display this fragment when a
  guestbook is selected in Guestbook List Screenlet.
\item
  Use Entry List Screenlet by inserting it in \texttt{EntriesFragment}.
\end{enumerate}

If you get confused or stuck at any point in this section of the
Learning Path, refer to the finished app's code
\href{https://github.com/liferay/liferay-docs/tree/master/develop/tutorials/code/mobile/android/screenlets-app/LiferayGuestbook}{here
in GitHub}.

First, you'll see how \texttt{GuestbooksActivity}'s UI works.

\section{Understanding GuestbooksActivity's
UI}\label{understanding-guestbooksactivitys-ui}

Recall that you used Android Studio's Navigation Drawer Activity
template to create \texttt{GuestbooksActivity}. Any activity this
template creates contains a navigation drawer and all the components the
activity needs. This includes layout files that display content.
Currently, these files contain simple placeholder content. You'll
replace this content shortly with content from your Guestbook portlet.
Before doing so, however, you should know where the placeholder content
exists in the project's structure and how the app displays it.

The app's UI is defined by three layout files that combine to display
the app's content:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \texttt{activity\_guestbooks.xml}: The activity's main layout file.
  This layout defines the navigation drawer and includes the
  \texttt{app\_bar\_guestbooks} layout. The latter appears when the
  navigation drawer is closed.
\item
  \texttt{app\_bar\_guestbooks.xml}: Defines the action bar (app bar)
  and includes the \texttt{content\_guestbooks} layout.
\item
  \texttt{content\_guestbooks.xml}: Defines the activity's main content,
  which appears below the action bar.
\end{enumerate}

First, you'll learn how \texttt{activity\_guestbooks.xml} works.

\subsection{Understanding the Activity's Main Layout
File}\label{understanding-the-activitys-main-layout-file}

First, open \texttt{GuestbooksActivity}'s main layout file,
\texttt{activity\_guestbooks.xml}. This file should look similar to this
one:

\begin{verbatim}
<?xml version="1.0" encoding="utf-8"?>
<android.support.v4.widget.DrawerLayout 
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools" 
    android:id="@+id/drawer_layout"
    android:layout_width="match_parent" 
    android:layout_height="match_parent"
    android:fitsSystemWindows="true" 
    tools:openDrawer="start">

    <include layout="@layout/app_bar_guestbooks" 
        android:layout_width="match_parent"
        android:layout_height="match_parent" />

    <android.support.design.widget.NavigationView 
        android:id="@+id/nav_view"
        android:layout_width="wrap_content" 
        android:layout_height="match_parent"
        android:layout_gravity="start" 
        android:fitsSystemWindows="true"
        app:headerLayout="@layout/nav_header_guestbooks" 
        app:menu="@menu/activity_guestbooks_drawer" />

</android.support.v4.widget.DrawerLayout>
\end{verbatim}

This isn't much code considering everything that's in
\texttt{GuestbooksActivity}. The \texttt{NavigationView} and its parent
\texttt{DrawerLayout} define the navigation drawer. Two attributes in
\texttt{NavigationView} define the drawer's contents:
\texttt{app:headerLayout} and \texttt{app:menu}. The
\texttt{app:headerLayout} value
\texttt{"@layout/nav\_header\_guestbooks"} specifies that the layout
\texttt{res/layout/nav\_header\_guestbooks.xml} renders the drawer's
header section. The \texttt{app:menu} value
\texttt{"@menu/activity\_guestbooks\_drawer"} specifies that the menu in
\texttt{res/menu/activity\_guestbooks\_drawer.xml} creates the drawer's
items. Above the \texttt{NavigationView}, the \texttt{include} statement
adds the layout \texttt{app\_bar\_guestbooks.xml} as the content shown
when the navigation drawer is closed. The following diagram illustrates
how \texttt{activity\_guestbooks.xml} maps to the UI.

\begin{figure}
\centering
\includegraphics{./images/android-activity-guestbooks.png}
\caption{The \texttt{activity\_guestbooks.xml} layout defines the app's
main UI components.}
\end{figure}

The activity's main content also contains a toolbar (the action bar),
some text, and a
\href{https://www.google.com/design/spec/components/buttons-floating-action-button.html}{floating
action button}. Next, you'll see how these are defined.

\subsection{Understanding the app\_bar\_guestbooks and
content\_guestbooks
Layouts}\label{understanding-the-app_bar_guestbooks-and-content_guestbooks-layouts}

Open \texttt{app\_bar\_guestbooks.xml}. It should look similar to this:

\begin{verbatim}
<?xml version="1.0" encoding="utf-8"?>
<android.support.design.widget.CoordinatorLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools" 
    android:layout_width="match_parent"
    android:layout_height="match_parent" 
    android:fitsSystemWindows="true"
    tools:context="com.liferay.docs.liferayguestbook.GuestbooksActivity">

    <android.support.design.widget.AppBarLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:theme="@style/AppTheme.AppBarOverlay">

        <android.support.v7.widget.Toolbar 
            android:id="@+id/toolbar"
            android:layout_width="match_parent" 
            android:layout_height="?attr/actionBarSize"
            android:background="?attr/colorPrimary" 
            app:popupTheme="@style/AppTheme.PopupOverlay" />

    </android.support.design.widget.AppBarLayout>

    <include layout="@layout/content_guestbooks" />

    <android.support.design.widget.FloatingActionButton 
        android:id="@+id/fab"
        android:layout_width="wrap_content" 
        android:layout_height="wrap_content"
        android:layout_gravity="bottom|end" 
        android:layout_margin="@dimen/fab_margin"
        android:src="@android:drawable/ic_dialog_email" />

</android.support.design.widget.CoordinatorLayout>
\end{verbatim}

The \texttt{AppBarLayout} and \texttt{Toolbar} elements define the
toolbar at the top of the activity. Following the toolbar definition,
the \texttt{include} statement adds the \texttt{content\_guestbooks}
layout to \texttt{app\_bar\_guestbooks}. The
\texttt{content\_guestbooks} layout defines the content displayed in the
activity's body (below the toolbar). Right now, this layout only
contains an empty \texttt{ConstraintLayout} element. Now open
\texttt{content\_guestbooks.xml}. Its contents should look similar to
this:

\begin{verbatim}
<?xml version="1.0" encoding="utf-8"?>
<android.support.constraint.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    app:layout_behavior="@string/appbar_scrolling_view_behavior"
    tools:context="com.liferay.docs.liferayguestbook.GuestbooksActivity"
    tools:showIn="@layout/app_bar_guestbooks">

</android.support.constraint.ConstraintLayout>
\end{verbatim}

Anything you define in this layout becomes the activity's main body
content. Later, you'll return to \texttt{content\_guestbooks.xml} to
display the guestbook entries retrieved from the Guestbook portlet.

Now return to \texttt{app\_bar\_guestbooks.xml}. This layout concludes
by using \texttt{FloatingActionButton} to define the floating action
button. Pressing this button in the app slides a
\href{https://www.google.com/design/spec/components/snackbars-toasts.html}{snackbar}
containing placeholder content up from the bottom of the screen.
Although you won't do anything with the floating action button in this
Learning Path, you'll leave it in place. When you finish this Learning
Path, you may want to test your Liferay mobile development chops by
adding functionality to this button.

The following figure illustrates how the \texttt{app\_bar\_guestbooks}
layout maps to the activity's UI. On the left, this figure lists each UI
component in \texttt{app\_bar\_guestbooks}. Each arrow points to the
component's rendering on the right.

\begin{figure}
\centering
\includegraphics{./images/android-app-bar-guestbooks.png}
\caption{The layout \texttt{app\_bar\_guestbooks.xml} defines the
activity's main content.}
\end{figure}

Awesome! Now you know which layout files in the project define the app's
UI. You also know the exact UI components these files define. Next,
you'll prepare \texttt{GuestbooksActivity} for Guestbook List Screenlet.

\section{Preparing GuestbooksActivity for Guestbook List
Screenlet}\label{preparing-guestbooksactivity-for-guestbook-list-screenlet}

Recall that you want \texttt{GuestbooksActivity} to display Guestbook
List Screenlet and Entry List Screenlet. Before using these Screenlets,
however, you must prepare \texttt{GuestbooksActivity} as follows:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Refactor the action bar so you can later set its title to the selected
  guestbook's name.
\item
  Refactor the navigation drawer so you can later close it when a
  guestbook is selected in Guestbook List Screenlet.
\item
  Delete the \texttt{NavigationView.OnNavigationItemSelectedListener}
  implementation. Since Guestbook List Screenlet handles guestbook
  selections, you don't need \texttt{NavigationView}.
\end{enumerate}

When you finish, you'll be ready to use Guestbook List Screenlet. Note
that you won't always have to take steps like these before using
Screenlets. You only do so here to fit this particular app's design.

First, you'll refactor the action bar.

\subsection{Refactoring the Action
Bar}\label{refactoring-the-action-bar}

By default, the action bar displays the activity's name. When you use
Guestbook List Screenlet, you want the action bar to display the
selected guestbook's name instead. You'll enable this by modifying the
code that creates the action bar. Android Studio created this code for
you in the \texttt{GuestbooksActivity} class's \texttt{onCreate} method:

\begin{verbatim}
Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);
setSupportActionBar(toolbar);
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Remove this code. Although you could edit it, you'll instead create a
  separate method that creates the action bar. Note that you don't need
  to worry about the now missing \texttt{toolbar} variable in
  \texttt{onCreate}; you'll fix it shortly.
\item
  Create \texttt{ActionBar} and \texttt{Toolbar} instance variables.
  This lets you refer to them anywhere in the activity. Add these
  variables to the \texttt{GuestbooksActivity} class:

\begin{verbatim}
Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);
setSupportActionBar(toolbar);
\end{verbatim}

  This requires that you import
  \texttt{android.support.v7.app.ActionBar}.
\item
  Add the following \texttt{initActionBar()} method to
  \texttt{GuestbooksActivity}:

\begin{verbatim}
private void initActionBar() {
    toolbar = (Toolbar) findViewById(R.id.toolbar);
    setSupportActionBar(toolbar);
    actionBar = getSupportActionBar();
    actionBar.setTitle("");
}
\end{verbatim}

  Like the code you removed from \texttt{onCreate}, this method also
  creates a \texttt{Toolbar} and sets it as the action bar. It also sets
  the action bar's title to an empty string. This prevents the
  activity's title from showing in the action bar before the app can
  retrieve guestbooks from the portlet.
\item
  Call \texttt{initActionBar()} in \texttt{onCreate}. Place the call
  immediately below the \texttt{setContentView} call. The first few
  lines of \texttt{onCreate} should now look like this:

\begin{verbatim}
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_guestbooks);

    initActionBar();

    ...
}
\end{verbatim}
\end{enumerate}

Next, you'll modify the code that controls the navigation drawer.

\subsection{Refactoring the Navigation
Drawer}\label{refactoring-the-navigation-drawer}

Before you can use Guestbook List Screenlet in the navigation drawer,
you must refactor the drawer's existing code. Do so now by following
these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Currently, the navigation drawer initialization code is in the
  \texttt{onCreate} method. Android Studio created this code for you
  when you used the Navigation Drawer Activity template to create
  \texttt{GuestbooksActivity}. Delete this code from \texttt{onCreate}:

\begin{verbatim}
DrawerLayout drawer = (DrawerLayout) findViewById(R.id.drawer_layout);
ActionBarDrawerToggle toggle = new ActionBarDrawerToggle(
    this, drawer, toolbar, R.string.navigation_drawer_open, R.string.navigation_drawer_close);
drawer.setDrawerListener(toggle);
toggle.syncState();
\end{verbatim}

  Instead, you'll initialize the navigation drawer in a separate method
  that you'll call in \texttt{onCreate}. You'll create this method
  shortly.
\item
  You'll also change the \texttt{drawer} variable to be an instance
  variable that you can refer to throughout the class. This lets you use
  this variable to close the drawer when a guestbook is selected in
  Guestbook List Screenlet. Add this variable to
  \texttt{GuestbooksActivity}:

\begin{verbatim}
private DrawerLayout drawer;
\end{verbatim}
\item
  Add the following \texttt{initDrawer} method. This method's contents
  match the drawer initialization code you deleted in \texttt{onCreate},
  except that \texttt{drawer} is now an instance variable:

\begin{verbatim}
private void initDrawer() {
    // drawer initialization
    drawer = (DrawerLayout) findViewById(R.id.drawer_layout);
    ActionBarDrawerToggle toggle = new ActionBarDrawerToggle(
        this, drawer, toolbar, R.string.navigation_drawer_open, 
        R.string.navigation_drawer_close);
    drawer.setDrawerListener(toggle);
    toggle.syncState();
}
\end{verbatim}
\item
  In the \texttt{onCreate} method, place the call to
  \texttt{initDrawer()} immediately below the \texttt{initActionBar}
  call. The first few lines of \texttt{onCreate} should now look like
  this:

\begin{verbatim}
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_guestbooks);

    initActionBar();
    initDrawer();

    ...
}
\end{verbatim}
\item
  Also, because you want to use the same \texttt{DrawerLayout} instance
  throughout the class, delete the line of code that creates a new
  \texttt{DrawerLayout} in the \texttt{onBackPressed} method. Your
  \texttt{onBackPressed} method should now look like this:

\begin{verbatim}
@Override
public void onBackPressed() {
    if (drawer.isDrawerOpen(GravityCompat.START)) {
        drawer.closeDrawer(GravityCompat.START);
    } else {
        super.onBackPressed();
    }
}
\end{verbatim}
\end{enumerate}

Now you're ready to delete the
\texttt{NavigationView.OnNavigationItemSelectedListener} implementation.
The next section walks you through this.

\subsection{Deleting the NavigationView.OnNavigationItemSelectedListener
Implementation}\label{deleting-the-navigationview.onnavigationitemselectedlistener-implementation}

Since Guestbook List Screenlet handles navigation drawer item
selections, you don't need to implement
\texttt{NavigationView.OnNavigationItemSelectedListener} in
\texttt{GuestbooksActivity}. Follow these steps to remove this
implementation:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Delete the implementation from the class declaration. The class
  declaration should now look like this:

\begin{verbatim}
public class GuestbooksActivity extends AppCompatActivity {...
\end{verbatim}
\item
  Remove the code in \texttt{GuestbooksActivity} that implements
  \texttt{NavigationView.OnNavigationItemSelectedListener}. To do this,
  first delete the following code at the end of the \texttt{onCreate}
  method:

\begin{verbatim}
NavigationView navigationView = (NavigationView) findViewById(R.id.nav_view);
navigationView.setNavigationItemSelectedListener(this);
\end{verbatim}

  Your \texttt{onCreate} method should now look like this:

\begin{verbatim}
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_guestbooks);

    initActionBar();
    initDrawer();

    FloatingActionButton fab = (FloatingActionButton) findViewById(R.id.fab);
    fab.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View view) {
            Snackbar.make(view, "Replace with your own action", Snackbar.LENGTH_LONG)
                .setAction("Action", null).show();
        }
    });
}
\end{verbatim}
\item
  Delete the \texttt{onNavigationItemSelected} method, along with its
  \texttt{@Override} and
  \texttt{@SuppressWarnings("StatementWithEmptyBody")} statements.
\item
  Finally, remove the
  \texttt{android.support.design.widget.NavigationView} import.
\end{enumerate}

Great job! Now you're ready to insert Guestbook List Screenlet in
\texttt{GuestbooksActivity}.

\section{Using Guestbook List
Screenlet}\label{using-guestbook-list-screenlet}

The steps for using Guestbook List Screenlet are the same as those for
using any Screenlet:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Insert the Screenlet's XML in the activity or fragment layout you want
  the Screenlet to appear in.
\item
  Implement the Screenlet's listener in the activity or fragment class.
\end{enumerate}

Recall that you used these steps to insert Login Screenlet in
\texttt{MainActivity}. First, you'll insert Guestbook List Screenlet's
XML in \texttt{GuestbooksActivity}'s layout.

\subsection{Inserting the Screenlet XML in the
Layout}\label{inserting-the-screenlet-xml-in-the-layout}

Recall that \texttt{activity\_guestbooks.xml} defines
\texttt{GuestbooksActivity}'s UI. Also recall that the
\texttt{NavigationView} in \texttt{activity\_guestbooks.xml} defines the
navigation drawer.

To put Guestbook List Screenlet in the drawer, you must insert the
Screenlet's XML in the \texttt{NavigationView}. You must also remove the
placeholder content from the \texttt{NavigationView}. To do these
things, replace the \texttt{NavigationView} in
\texttt{activity\_guestbooks.xml} with this code:

\begin{verbatim}
<android.support.design.widget.NavigationView
    android:id="@+id/nav_view"
    android:layout_width="wrap_content"
    android:layout_height="match_parent"
    android:layout_gravity="start"
    android:fitsSystemWindows="true"
    app:headerLayout="@layout/nav_header_guestbooks">

    <com.liferay.docs.guestbooklistscreenlet.GuestbookListScreenlet
        android:id="@+id/guestbooklist_screenlet"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:paddingTop="@dimen/nav_header_height"
        app:layoutId="@layout/list_guestbooks"/>

</android.support.design.widget.NavigationView>
\end{verbatim}

Compared to the \texttt{NavigationView} it replaced, this
\texttt{NavigationView} contains Guestbook List Screenlet's XML and
lacks the \texttt{app:menu} attribute. Recall that this attribute
pointed to the menu resource file that creates the drawer's items. Since
the Screenlet now handles the drawer's items (the guestbooks), you don't
need \texttt{app:menu} or the menu resource file. Delete the menu
resource file \texttt{res/menu/activity\_guestbooks\_drawer.xml}. You
also don't need the drawable resources that Android Studio created for
the navigation drawer's placeholder content. Delete
\texttt{res/values/drawables.xml}, and each of the
\texttt{ic\_menu\_*.xml} files in \texttt{res/drawable}.

Returning your attention to \texttt{activity\_guestbooks.xml}, note that
Guestbook List Screenlet's XML strongly resembles Login Screenlet's XML.
Both contain an \texttt{android:id} value that you can use in the
activity to get a reference to the Screenlet. Both also use a
\texttt{layoutId} attribute to specify the Screenlet's View. Guestbook
List Screenlet's XML, however, differs by using the
\texttt{android:paddingTop} attribute. This attribute's value,
\texttt{@dimen/nav\_header\_height}, pads the top of the Screenlet by
the height of the navigation drawer's header section. This prevents the
Screenlet and drawer header from overlapping.

Great! Next, you'll implement the Screenlet's listener interface in
\texttt{GuestbooksActivity}.

\subsection{Implementing the Screenlet's
Listener}\label{implementing-the-screenlets-listener}

To use a Screenlet, you must implement its listener methods in the class
of the activity or fragment where you want the Screenlet to appear. How
you implement these methods depends on how you want the Screenlet to
function in your app. For example, when you used Login Screenlet you
implemented \texttt{LoginListener} in \texttt{MainActivity}. You
implemented this listener's \texttt{onLoginSuccess} and
\texttt{onLoginFailure} methods to display a message to the user. You
then changed the \texttt{onLoginSuccess} implementation to navigate from
\texttt{MainActivity} to \texttt{GuestbooksActivity}. Since these
methods are \texttt{void}, however, you could have left them empty.
Obviously this wouldn't have made for a very useful app, but it
highlights an important point: Screenlet listener methods let the app
developer choose how to respond to the Screenlet's events. By
implementing these methods, app developers can therefore control how the
Screenlet functions with their app.

Before implementing Guestbook List Screenlet's listener, however, you
should add a method that the listener methods can use to help display a
guestbook and its entries. You might now be thinking, ``I thought you
said Screenlets contain their own UIs? Why does the activity need
special methods for displaying the Screenlets' entities?'' Although a
list Screenlet's UI displays the list of entities, the rest of the app's
UI must still account for that list. Consider the action bar, for
example. List Screenlets don't include an action bar, but you should
still change the action bar's contents to reflect what's on the screen.
When a guestbook is selected in Guestbook List Screenlet, the action bar
should display that guestbook's name. You can accomplish this by calling
a method that takes a \texttt{GuestbookModel} and sets that guestbook's
name as the action bar's title.

Follow these steps to add this method and implement the listener:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add this \texttt{showEntries} method to \texttt{GuestbooksActivity}:

\begin{verbatim}
public void showEntries(GuestbookModel guestbook) {

    actionBar.setTitle(guestbook.getName());
}
\end{verbatim}

  This requires you to import
  \texttt{com.liferay.docs.model.GuestbookModel}. This method is called
  \texttt{showEntries} because you'll also use it to display the
  guestbook's entries via Entry List Screenlet (you'll add this code
  later). You'll call this method in the listener methods you'll
  implement to process a guestbook selection.
\item
  Recall that Guestbook List Screenlet doesn't need any custom listener
  methods. It can use the listener methods defined in the list Screenlet
  framework's
  \href{https://github.com/liferay/liferay-screens/blob/2.1.0/android/library/src/main/java/com/liferay/mobile/screens/base/list/BaseListListener.java}{\texttt{BaseListListener}
  interface}. Change \texttt{GuestbooksActivity}'s class declaration to
  implement
  \texttt{BaseListListener\textless{}GuestbookModel\textgreater{}}. The
  class declaration should now look like this:

\begin{verbatim}
public class GuestbooksActivity extends AppCompatActivity implements 
    BaseListListener<GuestbookModel> {...
\end{verbatim}

  This requires you to import
  \texttt{com.liferay.mobile.screens.base.list.BaseListListener}.
\item
  To implement \texttt{BaseListListener}, you must implement the
  following methods:

  \begin{itemize}
  \item
    \texttt{onListPageFailed(int\ startRow,\ Exception\ e)}: Called when
    the server call to retrieve a page of items fails. This method's
    arguments include the \texttt{Exception} generated when the server
    call failed. Implement this method to show the user a
    \href{https://developer.android.com/guide/topics/ui/notifiers/toasts.html}{toast}
    message containing an error:

\begin{verbatim}
  @Override
  public void onListPageFailed(int startRow, Exception e) {

      Toast.makeText(this, "Page request failed", Toast.LENGTH_LONG).show();
  }
\end{verbatim}

    This requires you to import \texttt{android.widget.Toast}.
  \item
    \texttt{onListPageReceived(int\ startRow,\ int\ endRow,\ List\textless{}E\textgreater{}\ entries,\ int\ rowCount)}:
    Called when the server call to retrieve a page of items succeeds.
    Note that this method's arguments include the list of objects
    retrieved from the server (\texttt{entries}), and the page's start
    row (\texttt{startRow}), and end row (\texttt{endRow}). Recall that
    by default, you want the activity to display the first guestbook's
    entries. You'll use this method to do so because it receives the
    guestbooks from the server. Note that because \texttt{startRow} and
    \texttt{endRow} change for each page, a \texttt{startRow} of
    \texttt{0} corresponds to the first guestbook on the first page. Use
    an \texttt{if} statement to select this guestbook, and then call
    \texttt{showEntries}:

\begin{verbatim}
  @Override
  public void onListPageReceived(int startRow, int endRow, List<GuestbookModel> guestbooks, 
      int rowCount) {

      if (startRow == 0) {
          showEntries(guestbooks.get(0));
      }
  }
\end{verbatim}

    This requires you to import \texttt{java.util.List}.
  \item
    \texttt{onListItemSelected(E\ element,\ View\ view)}: Called when
    the user selects an item in the list. This method's arguments
    include the selected list item (\texttt{element}). To process the
    guestbook's selection, call \texttt{showEntries} in this method.
    Also, close the navigation drawer following the \texttt{showEntries}
    call:

\begin{verbatim}
  @Override
  public void onListItemSelected(GuestbookModel guestbook, View view) {

      showEntries(guestbook);
      drawer.closeDrawers();
  }
\end{verbatim}
  \end{itemize}
\item
  Because \texttt{BaseListListener} extends the
  \href{https://github.com/liferay/liferay-screens/blob/2.1.0/android/library/src/main/java/com/liferay/mobile/screens/base/interactor/listener/BaseCacheListener.java}{\texttt{BaseCacheListener}
  interface}, the activity must also implement
  \texttt{BaseCacheListener}'s \texttt{error} method. This method lets
  you respond to an error alongside the user action that caused it. In
  this app, you don't need to do anything in this method, so you can
  leave its contents empty:

\begin{verbatim}
@Override
public void error(Exception e, String userAction) {

}
\end{verbatim}
\item
  Now that you've implemented the listener methods, you must set
  \texttt{GuestbooksActivity} as the listener. This is where the
  \texttt{guestbooklist\_screenlet} ID that you set in the Screenlet's
  XML comes in handy. Add the following code to the end of the
  activity's \texttt{onCreate} method:

\begin{verbatim}
GuestbookListScreenlet screenlet = 
    (GuestbookListScreenlet) findViewById(R.id.guestbooklist_screenlet);
screenlet.setListener(this);
\end{verbatim}

  This requires you to import
  \texttt{com.liferay.docs.guestbooklistscreenlet.GuestbookListScreenlet}.

  This code first uses the ID \texttt{guestbooklist\_screenlet} to get a
  reference to \texttt{GuestbookListScreenlet}. It then sets this
  \texttt{GuestbooksActivity} instance as the Screenlet's listener.
\end{enumerate}

Great! That's it! Your app's \texttt{GuestbooksActivity} now contains
Guestbook List Screenlet. You're almost ready to use Entry List
Screenlet. Before you do so, however, you must create a fragment to put
it in. You'll do this next.

\section{Creating a Fragment for Entry List
Screenlet}\label{creating-a-fragment-for-entry-list-screenlet}

Using a fragment for Entry List Screenlet lets you swap out part of
\texttt{GuestbookActivity}'s contents without recreating the entire
activity from scratch each time a guestbook is selected. Your app
doesn't currently have any fragments, though. In this step, you'll
create a fragment and then add it to \texttt{GuestbooksActivity}. When
you finish, you'll be ready to use Entry List Screenlet in this
fragment.

\subsection{Creating the Fragment}\label{creating-the-fragment}

Follow these steps to create the fragment:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  To create the fragment, right click the
  \texttt{com.liferay.docs.liferayguestbook} package and select
  \emph{New} → \emph{Fragment} → \emph{Fragment (Blank)}. In the wizard,
  check only the box to create the layout XML, name the fragment
  \texttt{EntriesFragment}, and then click \emph{Finish}. The following
  screenshot illustrates this:

  \begin{figure}
  \centering
  \includegraphics{./images/android-create-fragment.png}
  \caption{Create a new blank fragment for the entries.}
  \end{figure}

  This creates the \texttt{EntriesFragment} class and its layout file
  \texttt{fragment\_entries.xml}.
\item
  Replace the class's contents with this code:

\begin{verbatim}
package com.liferay.docs.liferayguestbook;

import android.os.Bundle;
import android.support.v4.app.Fragment;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;

public class EntriesFragment extends Fragment {

    public static EntriesFragment newInstance(long guestbookId) {
        EntriesFragment entriesFragment = new EntriesFragment();
        Bundle args = new Bundle();
        args.putLong("guestbookId", guestbookId);
        entriesFragment.setArguments(args);

        return entriesFragment;
    }

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container,
                     Bundle savedInstanceState) {
        // Inflate the layout for this fragment
        View view = inflater.inflate(R.layout.fragment_entries, container, false);
        long guestbookId = getArguments().getLong("guestbookId");

        return view;
    }

}
\end{verbatim}

  If you have experience with Android fragments, then you're likely
  familiar with the static \texttt{newInstance} method. In short, using
  such a method instead of an empty constructor lets you create the
  fragment and initialize its data in one step. This makes it easier to
  create and restore the fragment.
  \href{http://www.androiddesignpatterns.com/2012/05/using-newinstance-to-instantiate.html}{Click
  here} for more information.

  Since this fragment will contain Entry List Screenlet, its data must
  include the guestbook ID the Screenlet retrieves entries from
  (\texttt{guestbookId}). Also, the \texttt{onCreateView} method uses
  the bundle arguments set in \texttt{newInstance} to retrieve the
  \texttt{guestbookId}. For now, you don't have to do anything with the
  \texttt{guestbookId} in \texttt{onCreateView}. You'll use this
  variable when you add the Screenlet to the fragment.
\end{enumerate}

Next, you'll add this fragment to \texttt{GuestbooksActivity}.

\subsection{Adding the Fragment to
GuestbooksActivity}\label{adding-the-fragment-to-guestbooksactivity}

Now that \texttt{EntriesFragment} exists, you can add it to
\texttt{GuestbooksActivity}. To do this, you must put an Android
fragment container in the layout where you want the fragment. For more
information, see
\href{http://developer.android.com/training/basics/fragments/fragment-ui.html\#AddAtRuntime}{Android's
documentation on adding fragments at runtime}. Since you want Entry List
Screenlet to appear in \texttt{GuestbooksActivity}, your first thought
might be to put the fragment container directly in
\texttt{activity\_guestbooks.xml}. Don't do this. Recall that Android
Studio's Navigation Drawer Activity template created the layout
\texttt{content\_guestbooks.xml} to hold the activity's main body
content. You'll add the fragment container to this layout, then write
the code in \texttt{GuestbooksActivity} that displays the fragment.

Follow these steps to add the fragment to \texttt{GuestbooksActivity}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open \texttt{content\_guestbooks.xml} and place the following fragment
  container inside the \texttt{ConstraintLayout}. This fragment
  container should be the only other element inside the
  \texttt{ConstraintLayout}:

\begin{verbatim}
<FrameLayout
    android:id="@+id/fragment_container"
    android:layout_width="match_parent"
    android:layout_height="match_parent" />
\end{verbatim}
\item
  Next, you must write the \texttt{GuestbooksActivity} code that
  displays the fragment when a guestbook is selected in Guestbook List
  Screenlet. You'll do this with an
  \href{http://developer.android.com/guide/components/fragments.html\#Transactions}{Android
  fragment transaction}. Recall that you created
  \texttt{GuestbooksActivity}'s \texttt{showEntries} method to process a
  list item selection in Guestbook List Screenlet. All
  \texttt{showEntries} does right now is set the action bar's title to
  the selected guestbook's name. You'll add the fragment transaction to
  \texttt{showEntries}, so a guestbook selection also shows that
  guestbook's entries. Replace the \texttt{showEntries} method in
  \texttt{GuestbooksActivity} with this code:

\begin{verbatim}
public void showEntries(GuestbookModel guestbook) {
    actionBar.setTitle(guestbook.getName());

    EntriesFragment entriesFragment = EntriesFragment.newInstance(guestbook.getGuestbookId());
    FragmentTransaction transaction = getSupportFragmentManager().beginTransaction();
    transaction.replace(R.id.fragment_container, entriesFragment);
    transaction.commit();
}
\end{verbatim}

  This requires that you import
  \texttt{android.support.v4.app.FragmentTransaction}.

  This method's \texttt{actionBar.setTitle} call is the same as before.
  Only the fragment code is new. In it, you first use
  \texttt{newInstance} to create a new \texttt{EntriesFragment} instance
  with the selected guestbook's ID. A fragment transaction then adds
  this fragment to the fragment container.
\end{enumerate}

Fantastic! Now you have a fragment to put Entry List Screenlet in, and
the code that displays this fragment in \texttt{GuestbooksActivity}.
Next, you'll put Entry List Screenlet in the fragment.

\section{Using Entry List Screenlet}\label{using-entry-list-screenlet}

You'll use Entry List Screenlet by following the same steps to use any
Screenlet: insert the Screenlet's XML in an activity or fragment layout,
and then implement the Screenlet's listener in the activity or fragment
class. You'll follow these steps here to insert Entry List Screenlet in
\texttt{EntriesFragment}.

First, you'll insert Entry List Screenlet's XML in
\texttt{EntriesFragment}'s layout, \texttt{fragment\_entries.xml}.

\subsection{Inserting the Screenlet in the
Layout}\label{inserting-the-screenlet-in-the-layout}

Inserting Entry List Screenlet's XML is very simple. Since all you want
\texttt{fragment\_entries.xml} to do is display the Screenlet, it must
only contain the Screenlet's XML. Replace the contents of
\texttt{fragment\_entries.xml} with the following markup:

\begin{verbatim}
<com.liferay.docs.entrylistscreenlet.EntryListScreenlet
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:id="@+id/entrylist_screenlet"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    app:layoutId="@layout/list_entries"/>
\end{verbatim}

As with Guestbook List Screenlet, you'll use the \texttt{android:id}
value to get a Screenlet reference. Next, you must implement the
Screenlet's listener.

\subsection{Implementing the Screenlet's
Listener}\label{implementing-the-screenlets-listener-1}

Recall that to use a Screenlet, you must implement its listener. The
listener methods let the app developer respond to the Screenlet's
behavior in the activity or fragment class that contains the Screenlet.
Also recall that because Guestbook List Screenlet didn't need extra
listener methods, you used it in \texttt{GuestbooksActivity} by
implementing the
\href{https://github.com/liferay/liferay-screens/blob/2.1.0/android/library/src/main/java/com/liferay/mobile/screens/base/list/BaseListListener.java}{\texttt{BaseListListener}
interface} with \texttt{GuestbookModel} as a type argument. Entry List
Screenlet also doesn't need extra listener methods. Like Guestbook List
Screenlet, you can use it by implementing \texttt{BaseListListener} with
its model class as a type argument.

Follow these steps to implement Entry List Screenlet's listener in
\texttt{EntriesFragment}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Change \texttt{EntriesFragment}'s class declaration to implement
  \texttt{BaseListListener\textless{}EntryModel\textgreater{}}. The
  class declaration should now look like this:

\begin{verbatim}
public class EntriesFragment extends Fragment implements BaseListListener<EntryModel> {...
\end{verbatim}

  This requires that you add the following imports:

\begin{verbatim}
import com.liferay.docs.model.EntryModel;
import com.liferay.mobile.screens.base.list.BaseListListener;
\end{verbatim}
\item
  Now you must implement the listener's methods. Recall that this
  includes the
  \href{https://github.com/liferay/liferay-screens/blob/2.1.0/android/library/src/main/java/com/liferay/mobile/screens/base/list/BaseListListener.java}{\texttt{BaseCacheListener}
  interface's}, \texttt{error} method, since \texttt{BaseListListener}
  extends \texttt{BaseCacheListener}. For a full explanation of the
  methods in both listeners, see
  \href{/docs/6-2/tutorials/-/knowledge_base/t/using-guestbook-list-screenlet}{using
  Guestbook List Screenlet}. Note that in \texttt{EntriesFragment}, you
  don't need to take any action in these methods. There are no UI
  elements or other parts of the fragment that must be updated or
  processed in response to the Screenlet's behavior. All this Screenlet
  must do is display its content, which it does regardless of anything
  you do in the listener methods. The only thing you may want to add is
  a toast message in \texttt{onListPageFailed} to notify the user if the
  server call fails, but this isn't required. Implement these methods
  now:

\begin{verbatim}
@Override
public void onListPageFailed(int startRow, Exception e) {
    Toast.makeText(getActivity(), "Page request failed", Toast.LENGTH_LONG).show();
}

@Override
public void onListPageReceived(int startRow, int endRow, List<EntryModel> entries, int rowCount) {

}

@Override
public void onListItemSelected(EntryModel entry, View view) {

}

@Override
public void error(Exception e, String userAction) {

}
\end{verbatim}

  This requires you to add the following imports:

\begin{verbatim}
import android.widget.Toast;
import java.util.List;
\end{verbatim}
\item
  Now you're ready to register \texttt{EntriesFragment} as the
  Screenlet's listener. You'll do this the same way you registered
  \texttt{GuestbooksActivity} as Guestbook List Screenlet's listener:
  get a reference to the Screenlet and call its \texttt{setListener}
  method. After doing this, you'll use the Entry List Screenlet
  reference's \texttt{setGuestbookId} method to set its guestbook ID.
  This sets the guestbook where the Screenlet gets its entries. You'll
  do these things in the \texttt{onCreateView} method. Replace the
  \texttt{onCreateView} method with this updated version:

\begin{verbatim}
@Override
public View onCreateView(LayoutInflater inflater, ViewGroup container,
                     Bundle savedInstanceState) {
    // Inflate the layout for this fragment
    View view = inflater.inflate(R.layout.fragment_entries, container, false);
    long guestbookId = getArguments().getLong("guestbookId");

    EntryListScreenlet screenlet = (EntryListScreenlet) view.findViewById(R.id.entrylist_screenlet);
    screenlet.setListener(this);
    screenlet.setGuestbookId(guestbookId);

    return view;
}
\end{verbatim}

  This requires you to import
  \texttt{com.liferay.docs.entrylistscreenlet.EntryListScreenlet}.

  As you can see, \texttt{onCreateView} now registers
  \texttt{EntriesFragment} as the Screenlet's listener and sets the
  Screenlet's guestbook ID. The rest of \texttt{onCreateView} is
  unchanged.
\end{enumerate}

Now run the app in the emulator and log in with your credentials when
prompted. The app then presents you with the first guestbook's entries.
Open the navigation drawer by pressing the hamburger button, then select
a different guestbook. The drawer then closes to show the selected
guestbook's entries. Nice work! Your app now uses Guestbook List
Screenlet and Entry List Screenlet to show the same guestbooks and
entries as the Guestbook portlet. The following screenshots show these
Screenlets in action.

\begin{figure}
\centering
\includegraphics{./images/android-guestbooks-entries-screenlets.png}
\caption{Entry List Screenlet displays guestbook entries in your app.}
\end{figure}

\begin{figure}
\centering
\includegraphics{./images/android-guestbook-screenlet-drawer-01.png}
\caption{Guestbook List Screenlet displays guestbooks in the navigation
drawer.}
\end{figure}

Although your Screenlets work, you may have noticed something odd about
the navigation drawer's header--it's hideous. The action bar is
somewhere on the purple-blue spectrum, while the drawer header is green.
You've probably seen more attractive finger paintings. Fortunately, it's
simple to change the drawer header's color. Also, the drawer header
contains the generic text \emph{Android Studio}. You should change this
to something more suitable for your app, like \emph{Liferay Guestbook}.

Follow these steps to apply these changes to the drawer header:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In \texttt{res/drawable/side\_nav\_bar.xml}, replace
  \texttt{android:centerColor}, \texttt{android:endColor}, and
  \texttt{android:startColor} with the following settings:

\begin{verbatim}
android:centerColor="@color/colorPrimary"
android:endColor="@color/colorPrimaryDark"
android:startColor="@color/colorPrimary"
\end{verbatim}

  This sets the drawer header's colors to match the colors used in the
  rest of the app.
\item
  Define the following string resource in
  \texttt{res/values/strings.xml}:

\begin{verbatim}
<string name="liferay_guestbook">Liferay Guestbook</string>
\end{verbatim}
\item
  In \texttt{nav\_header\_guestbooks.xml}, find the \texttt{TextView}
  element that contains \texttt{android:text="Android\ Studio"}, and
  replace \texttt{Android\ Studio} with
  \texttt{@string/liferay\_guestbook}. You can delete any other
  \texttt{TextView} elements in this file. Run the app again, and open
  the drawer after signing in. The drawer header now shows your
  greeting. It's a lot prettier too.
\end{enumerate}

\begin{figure}
\centering
\includegraphics{./images/android-guestbook-screenlet-drawer-02.png}
\caption{The drawer header looks a lot better after some light
customization.}
\end{figure}

Congratulations! Now you know how to use Liferay Screens and create your
own Screenlets. This opens up a world of possibilities for developing
apps that leverage Liferay DXP. Although you learned a great deal in
this Learning Path, there's still more. You can customize your
Screenlet's appearance, package it for redistribution, and even
configure it to receive push notifications. These topics, and more, are
covered in the
\href{/docs/7-0/tutorials/-/knowledge_base/t/android-apps-with-liferay-screens}{tutorials
on Android apps with Liferay Screens}.

\chapter{Writing an iOS App with Liferay
Screens}\label{writing-an-ios-app-with-liferay-screens}

Users expect to access portal content from their mobile devices. As an
intrepid developer, you naturally want to turn these expectations into
reality. Thankfully, Liferay provides a way for your mobile apps to
access portal content and applications with
\href{https://www.liferay.com/supporting-products/liferay-screens}{Liferay
Screens}! Screens contains native components called \emph{Screenlets}
that can call Liferay DXP's remote services and display the results in
your app. Each Screenlet comes complete with its own fully pluggable UI
that you can customize to your liking. Although the Screenlets included
with Screens only work with Liferay DXP's built-in remote services, you
can write your own Screenlets that work with your custom portlets'
remote services.

If you're an experienced iOS developer but need a start-to-finish guide
on how to integrate iOS apps with Liferay DXP, you're in the right
place. This Learning Path walks you through the creation of an iOS app
that interacts with the Guestbook portlet developed in the
\href{/docs/7-0/tutorials/-/knowledge_base/t/developing-a-web-application}{Developing
a Web Application} Learning Path. Since this is a custom portlet, you'll
write your own Screenlets that let your app retrieve and display
guestbooks and their entries.

You should note that although this Learning Path provides complete code
snippets of the app, not every aspect of iOS development is explained in
detail. Focus is instead placed on the code that leverages Liferay
Screens. Therefore, you \textbf{must} have significant iOS development
experience before attempting this Learning Path. Otherwise, you'll
likely be confused. Apple provides extensive documentation of the iOS
APIs as well as some basic tutorials on
\href{https://developer.apple.com/}{developer.apple.com}.

Experience in iOS development is all you need to start working. You
needn't have completed the Developing a Web Application Learning Path to
obtain a working Guestbook portlet. The complete Guestbook portlet's
modules are provided for installation into your local Liferay DXP
instance.

Now that you know what you'll be doing here, it's time to move on to the
first series of articles: Beginning iOS Development for Your Portal.
These articles walk you through the steps required to get started
developing an iOS app that interacts with Liferay DXP.

\chapter{Beginning iOS Development for Your
Portal}\label{beginning-ios-development-for-your-portal}

Getting started with Liferay Screens for iOS is straightforward. This
series of Learning Path articles walks you through creating an iOS app
and preparing it to work with the Guestbook portlet developed in the
\href{/docs/7-0/tutorials/-/knowledge_base/t/developing-a-web-application}{Developing
a Web Application} Learning Path. Since Liferay Screens uses the Liferay
Mobile SDK to make remote service calls, you'll build a Mobile SDK
capable of calling the Guestbook portlet's remote services (the
Guestbook Mobile SDK). You'll then install this Mobile SDK and Screens
into your iOS project. You'll also learn about the iOS app's design and
implement authentication with
\href{/docs/7-0/reference/-/knowledge_base/r/loginscreenlet-for-ios}{Login
Screenlet}.

This section of the Learning Path covers these topics:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Setting up the Guestbook portlet
\item
  Building the Guestbook Mobile SDK
\item
  Creating the iOS project
\item
  Installing the Guestbook Mobile SDK and Liferay Screens in the iOS
  project
\item
  Designing Your App
\item
  Using Login Screenlet for Authentication
\item
  Creating the Guestbooks Scene
\end{enumerate}

When you finish, you'll be ready to start developing your first
Screenlet.

\section{Setting up the Guestbook
Portlet}\label{setting-up-the-guestbook-portlet-1}

Before you begin developing the Guestbook app for iOS, you must set up
the Guestbook portlet in a Liferay DXP instance. To do this, follow
these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Install JDK 8
\item
  Install and Configure a Local Liferay DXP Bundle
\item
  Deploy the Guestbook Portlet to the Local Liferay DXP Instance
\end{enumerate}

\subsection{Installing the JDK}\label{installing-the-jdk-1}

To get started, you must have JDK 8 installed. You can download and
install the Java SE JDK from the
\href{http://www.oracle.com/technetwork/java/javase/downloads/index.html}{Java
downloads page}. This page also has links to the JDK installation
instructions.

\subsection{Installing and Configuring a Local Liferay DXP
Bundle}\label{installing-and-configuring-a-local-liferay-dxp-bundle-1}

Follow these instructions to install and configure a local Liferay DXP
instance:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Download a Liferay DXP Tomcat bundle from
  \href{https://www.liferay.com/}{liferay.com}.
\item
  Unzip the bundle to a new \texttt{bundles} folder. Note that the
  bundle's root folder is referred to as \emph{Liferay Home} and is
  named according to the version, edition, and specific Liferay DXP
  release. For example, if you downloaded Liferay CE Portal 7.0 GA5 and
  unzipped it to a \texttt{bundles} folder on your machine, that
  bundle's Liferay Home folder is:

\begin{verbatim}
bundles/liferay-ce-portal-7.0-ga5
\end{verbatim}
\item
  Now you're ready to start Liferay DXP! Open a terminal and navigate to
  \texttt{{[}Liferay\ Home{]}/tomcat-{[}version{]}/bin}. Then run these
  commands:

\begin{verbatim}
./startup.sh
tail -f ../logs/catalina.out
\end{verbatim}

  The \texttt{tail} command ensures that the server log prints to the
  terminal.
\item
  After a minute or two, Liferay DXP starts up and automatically takes
  you to its initial setup page at \url{http://localhost:8080}. On this
  page, provide the following information to set up your Liferay DXP
  instance:

  \begin{itemize}
  \tightlist
  \item
    Enter a name for your instance.
  \item
    Select the default language.
  \item
    Uncheck the \emph{Add Sample Data} box.
  \item
    Enter the first name, last name, and email address of the default
    administrative user. For the purposes of this Learning Path, these
    don't have to be real.
  \item
    If you want to connect Liferay DXP to a separate database such as
    MySQL or PostgreSQL, you can configure that connection here. Note
    that although the default embedded database is fine for development
    on your local machine, it isn't optimized for production.
  \end{itemize}

  Click \emph{Finish Configuration} when you're done.
\item
  Accept the terms of use.
\item
  Set a password and a password reminder query for your administrative
  user. Your Liferay DXP instance then takes you to its default site.
\end{enumerate}

Great! Next, you'll deploy the Guestbook portlet to your Liferay DXP
instance.

\subsection{Deploying the Guestbook
Portlet}\label{deploying-the-guestbook-portlet-1}

Now that your portal is set up, you can deploy the Guestbook portlet to
it. Follow these instructions to do so:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Download
  \href{https://portal.liferay.dev/documents/113763090/114000186/guestbook-services.zip}{the
  Guestbook portlet's modules}:

  \begin{itemize}
  \tightlist
  \item
    \texttt{com.liferay.docs.guestbook.api-1.0.0.jar}
  \item
    \texttt{com.liferay.docs.guestbook.portlet-1.0.0.jar}
  \item
    \texttt{com.liferay.docs.guestbook.service-1.0.0.jar}
  \item
    \texttt{com.liferay.docs.guestbook.service-wsdd-1.0.0.jar}
  \end{itemize}
\item
  Place these modules in your Liferay DXP instance's
  \texttt{{[}Liferay\ Home{]}/deploy} folder. You should then see
  console messages indicating that the modules have successfully
  deployed and started.
\item
  On your Liferay DXP instance's default site, click the \emph{Add}
  button (\includegraphics{./images/icon-control-menu-add.png})
  on the upper-right corner of the screen. Then click the
  \emph{Applications} → \emph{Sample} category and drag \emph{Guestbook}
  onto the page. The Guestbook portlet should now appear with the
  default guestbook (Main).
\item
  In the portlet, add a new guestbook and an entry or two each from the
  \emph{Add} menu (\includegraphics{./images/icon-app-add.png})
  that appears in the top right of the portlet's border when you mouse
  over the portlet. When you create the Guestbook iOS app, this ensures
  there's some content to display in it. The Guestbook portlet on your
  site should now look like this:

  \begin{figure}
  \centering
  \includegraphics{./images/guestbook-portlet-01.png}
  \caption{The Guestbook portlet, with a new guestbook and some
  entries.}
  \end{figure}
\end{enumerate}

Stupendous! You've successfully set up a Liferay DXP instance and added
the Guestbook portlet to it. Now you're ready to get started with the
Liferay Mobile SDK.

\section{Building the Guestbook Mobile
SDK}\label{building-the-guestbook-mobile-sdk-1}

Once you've deployed the Guestbook portlet, you're ready to build the
Guestbook Mobile SDK. You might be asking yourself, ``Why do I have to
build a separate Mobile SDK? Can't I just use the pre-built Mobile SDK
that Liferay already provides?'' Fantastic question! The reason is that
Liferay's pre-built Mobile SDK doesn't have the classes it needs to call
the Guestbook portlet's remote services. The pre-built Mobile SDK
includes only the framework necessary to make server calls to the remote
services of Liferay DXP's \emph{core} apps. Core apps (also referred to
as \emph{out-of-the-box} apps) are those included with every Liferay DXP
instance. Since you're calling services of an app the default Mobile SDK
doesn't know about (the Guestbook portlet), you must build a Mobile SDK
that can call its services. Now put on your hard hat, because it's time
to get building!

\subsection{Building the Mobile SDK}\label{building-the-mobile-sdk-1}

In the Mobile SDK source code, Liferay provides a Mobile SDK Builder
that you can use to build your own Mobile SDKs. For the builder to
generate the classes that can call a non-core app's remote services,
those services must be available and accompanied by a Web Service
Deployment Descriptor (WSDD). To learn how the Guestbook portlet's
remote services and WSDD were generated, see the section
\href{/docs/7-0/tutorials/-/knowledge_base/t/generating-web-services}{Generating
Web Services} in the web application Learning Path. Since the Guestbook
portlet's web services already exist, you don't need to generate them.
Just remember that you must generate web services when developing your
own portlets.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \href{https://github.com/liferay/liferay-mobile-sdk/archive/ios-7.0.13.zip}{Download
  the Mobile SDK's source code} and unzip the file to a location on your
  machine where you want the Mobile SDK to reside. This location is
  purely personal preference; the builder works the same no matter where
  you put the Mobile SDK's source code. Once unzipped, the Mobile SDK's
  source code is in the folder \texttt{liferay-mobile-sdk-ios-7.0.13}.
\item
  Now you're ready to build the Guestbook Mobile SDK. The builder
  contains a convenient command line wizard to assist you in building
  Mobile SDKs. To start it, navigate to the
  \texttt{liferay-mobile-sdk-ios-7.0.13} folder and run the following
  command:

\begin{verbatim}
./gradlew createModule
\end{verbatim}

  The wizard launches and asks you to enter your project's properties.
  You'll do this next.
\item
  You must first provide the \texttt{Context} property. This is the
  context path of the remote services the builder will generate classes
  and methods for. To view your Liferay DXP instance's remote service
  context paths, go to \url{http://localhost:8080/api/jsonws}. On the
  page's upper left, there's a menu for selecting the context path.
  Select \emph{gb}, which is the Guestbook portlet's context path. The
  UI updates to show only the remote services available in the selected
  context path. Return to the terminal and enter \texttt{gb} for the
  \texttt{Context} property.

  \begin{figure}
  \centering
  \includegraphics{./images/remote-services-context.png}
  \caption{The Guestbook Portlet's context path (gb) on the server.}
  \end{figure}
\item
  Next, the wizard needs the \texttt{Package\ Name} property. Because
  the builder also builds an Android version of the Mobile SDK, this
  property defines the Java package path for the classes the builder
  generates. Accept the default value of
  \texttt{com.liferay.mobile.android}.
\item
  The wizard then asks for the \texttt{POM\ Description} property. This
  property also applies to the Android version of the Mobile SDK. Since
  the builder requires it, however, enter \texttt{Guestbook\ SDK}. The
  following screenshot shows these properties entered in the wizard:

  \begin{figure}
  \centering
  \includegraphics{./images/mobile-sdk-build-wizard.png}
  \caption{To build your Mobile SDK, you must enter values for the
  \texttt{Context}, \texttt{Package\ Name}, and
  \texttt{POM\ Description} properties. The blue values in square
  brackets are defaults.}
  \end{figure}

  Once you enter the final property, the builder runs and generates a
  \texttt{BUILD\ SUCCESSFUL} message.
\item
  Now that the builder contains a \texttt{gb} module, you must generate
  that module's remote services. To do this, first navigate to this
  folder:

\begin{verbatim}
liferay-mobile-sdk-ios-7.0.13/modules/gb
\end{verbatim}

  Then run this command:

\begin{verbatim}
../../gradlew generate
\end{verbatim}

  As before, the builder runs and generates a \texttt{BUILD\ SUCCESSFUL}
  message. Great! You're probably wondering what just happened, though.
  The builder generated the source classes you'll use in your iOS app to
  interact with the Guestbook portlet. You can find these source classes
  in the following folder of the Mobile SDK's source code:

\begin{verbatim}
modules/gb/ios/Source/Service/v7
\end{verbatim}

  The last folder in this path, \texttt{v7}, denotes the Liferay DXP
  version the classes work with. This folder has two subfolders that
  correspond to each entity in the Guestbook portlet: \texttt{guestbook}
  and \texttt{entry}. Each subfolder contains an Objective-C class
  header and implementation file for that entity's class
  (\texttt{LRGuestbookService\_v7} and \texttt{LREntryService\_v7},
  respectively).
\item
  There's one last thing to do before you can use these classes in your
  iOS app: put them in a JAR file. To do this, make sure you're still in
  the \texttt{modules/gb} folder on the command line and run this
  command:

\begin{verbatim}
../../gradlew zip
\end{verbatim}

  This command generates this ZIP file:

\begin{verbatim}
modules/gb/build/liferay-gb-ios-sdk-1.0.zip
\end{verbatim}

  This ZIP file is the Guestbook Mobile SDK. It contains the service
  classes required to call the Guestbook portlet's remote services.
\end{enumerate}

Congratulations! You just built the Guestbook Mobile SDK. Now that's an
accomplishment worth writing in a guestbook. All you need now is an iOS
app to install this Mobile SDK in. The next article shows you how to
create it.

\section{Creating the iOS Project}\label{creating-the-ios-project}

Now that you've built the Guestbook Mobile SDK, you're ready to create
the Guestbook iOS app. This article walks you through the steps required
to create the app's project in Xcode. After this, you'll be ready to
install the Guestbook Mobile SDK and Liferay Screens.

\noindent\hrulefill

\textbf{Note:} This learning path presumes that you've installed and
know how to use Xcode. If you need assistance with Xcode, see
\href{https://developer.apple.com/xcode/}{Apple's developer site}.

\noindent\hrulefill

Follow these steps to create the Liferay Guestbook iOS project:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open Xcode and click \emph{Create a new Xcode project} on the welcome
  screen. Alternatively, you can select \emph{File} → \emph{New} →
  \emph{Project}.
\item
  In the \emph{Application} section of the \emph{iOS} tab, select
  \emph{Single View Application} and click \emph{Next}.

  \begin{figure}
  \centering
  \includegraphics{./images/ios-lp-create-app-01.png}
  \caption{Use the Single View Application project template.}
  \end{figure}
\item
  Enter the following fields as listed here:

  \begin{itemize}
  \tightlist
  \item
    \textbf{Product Name:} Liferay Guestbook
  \item
    \textbf{Organization Name:} Your name
  \item
    \textbf{Organization Identifier:} com.liferay.docs
  \item
    \textbf{Language:} Swift
  \end{itemize}

  Make sure the checkboxes below these fields are unchecked, and click
  \emph{Next}.

  \begin{figure}
  \centering
  \includegraphics{./images/ios-lp-create-app-02.png}
  \caption{Fill out this form as shown.}
  \end{figure}
\item
  Select a location for your project and click \emph{Create}. Xcode
  creates and opens your new project.
\end{enumerate}

Nice! You now have the iOS project in which you'll develop the Liferay
Guestbook app. Before doing any development, however, you must install
Liferay Screens and the Guestbook Mobile SDK. You'll do this next.

\section{Installing Liferay Screens and the Guestbook Mobile
SDK}\label{installing-liferay-screens-and-the-guestbook-mobile-sdk}

For your iOS app to work with the Guestbook portlet, you must install
the following in your iOS project:

\begin{itemize}
\item
  \textbf{Liferay's pre-built Mobile SDK:} This Mobile SDK contains the
  classes that call Liferay DXP's core remote services. It also contains
  the framework necessary for any Mobile SDK to make server calls.
\item
  \textbf{The Guestbook Mobile SDK:} This Mobile SDK contains only the
  classes that call the Guestbook portlet's remote services.
\item
  \textbf{Liferay Screens:} Screens contains the Screenlet framework and
  \href{/docs/7-0/reference/-/knowledge_base/r/screenlets-in-liferay-screens-for-ios}{several
  built-in Screenlets} like Login Screenlet. Because these built-in
  Screenlets work with Liferay DXP's core apps, they make their server
  calls with Liferay's pre-built Mobile SDK. Note that all Screenlets,
  including those that make server calls with a custom-built Mobile SDK,
  must use the framework in Liferay's pre-built Mobile SDK to issue
  their calls.
\end{itemize}

Since Liferay's pre-built Mobile SDK is a dependency of Liferay Screens,
installing Screens automatically installs this Mobile SDK. You must,
however, install the Guestbook Mobile SDK manually.

This article walks you through the installation of the Guestbook Mobile
SDK and Liferay Screens. When you finish, you'll be ready to start
developing the app.

\subsection{Anatomy of the Liferay Guestbook iOS
Project}\label{anatomy-of-the-liferay-guestbook-ios-project}

Before getting started, you should learn a couple of terms this Learning
Path uses when referring to the project's structure. Knowing these terms
ensures that you know where to add folders and files in the project. In
Xcode's Project navigator, there are two \emph{Liferay Guestbook} items:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{The root project:} This is the first item in the Project
  navigator. It contains all other items in the project, and is labeled
  with a blue application document icon. The root project corresponds
  with a folder in your file system that this Learning Path refers to as
  the \emph{root project folder}. For example, the root project folder
  for the Liferay Guestbook project is \texttt{Liferay\ Guestbook}.
\item
  \textbf{The Liferay Guestbook folder:} This is immediately under the
  root project. It contains the app's files, and is labeled with a
  manila folder icon. Even though this folder shares a name with the
  root project folder on your file system, it \textbf{is not} the same
  thing. The root project folder contains this
  \texttt{Liferay\ Guestbook} folder.
\end{enumerate}

\begin{figure}
\centering
\includegraphics{./images/ios-lp-project-structure.png}
\caption{The root project and Liferay Guestbook folder are labeled in
this screenshot.}
\end{figure}

\begin{figure}
\centering
\includegraphics{./images/ios-lp-project-file-system.png}
\caption{On your file system, the \texttt{Liferay\ Guestbook} root
project folder contains the app's \texttt{Liferay\ Guestbook} folder.
The latter is selected in this screenshot.}
\end{figure}

It's important not to confuse these two items. If you're ever confused
about where things should go,
\href{https://github.com/liferay/liferay-docs/tree/7.0.x/develop/tutorials/code/mobile/ios/screenlets-app/Liferay\%20Guestbook}{click
here} to see the finished app in GitHub.

Now you're ready to install Liferay Screens!

\subsection{Installing Liferay
Screens}\label{installing-liferay-screens-1}

You'll use \href{https://cocoapods.org/}{CocoaPods} to install Liferay
Screens.
\href{https://guides.cocoapods.org/using/getting-started.html}{Click
here} for instructions on installing CocoaPods. After installing it, use
these steps to install Screens:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In your root project's folder, create a file named \texttt{Podfile}
  that contains the following:

\begin{verbatim}
source 'https://github.com/CocoaPods/Specs.git'

platform :ios, '9.0'
use_frameworks!

target "Liferay Guestbook" do
    pod 'LiferayScreens', '3.0.2'
end

post_install do |installer|
  incompatiblePods = [
    'Cosmos',
    'CryptoSwift',
    'KeychainAccess',
    'Liferay-iOS-SDK',
    'Liferay-OAuth',
    'LiferayScreens',
    'Kingfisher'
  ]

  installer.pods_project.targets.each do |target|
    if incompatiblePods.include? target.name
      target.build_configurations.each do |config|
        config.build_settings['SWIFT_VERSION'] = '3.2'
      end
    end
    target.build_configurations.each do |config|
        config.build_settings['CONFIGURATION_BUILD_DIR'] = '$PODS_CONFIGURATION_BUILD_DIR'
    end
  end
end
\end{verbatim}

  This adds Liferay Screens 3.0.2 (the most recent version at the time
  this Learning Path was published) as a dependency. Since Screens 3.0.2
  is incompatible with Swift 4, this \texttt{Podfile} also specifies
  that Screens and several of its dependencies
  (\texttt{incompatiblePods}) should be compiled by Swift 3.2. This lets
  you develop the app in Swift 4, while Screens itself is compiled in
  Swift 3.2.

  Also note the setting for \texttt{CONFIGURATION\_BUILD\_DIR}. This is
  a workaround for a benign bug that causes Screenlet previews to fail
  in Interface Builder.
\item
  On the terminal, navigate to your root project's folder and run this
  command:

\begin{verbatim}
pod repo update
\end{verbatim}

  This ensures you have the latest version of the CocoaPods repository
  on your machine. Note that this command can take a while to run.
\item
  Still in your root project's folder in the terminal, run this command:

\begin{verbatim}
pod install
\end{verbatim}

  This installs the Liferay Screens as specified in your
  \texttt{Podfile}. Once this completes, quit Xcode and reopen your
  project by using the \texttt{LiferayGuestbook.xcworkspace} file in
  your root project's folder. From now on, you must use this file to
  open your project.
\end{enumerate}

Great! You just installed Liferay Screens and the Liferay Mobile SDK!
Next, you'll install the Guestbook Mobile SDK.

\subsection{Installing the Guestbook Mobile
SDK}\label{installing-the-guestbook-mobile-sdk-1}

To install the Guestbook Mobile SDK, you must add its service classes to
your project. Recall that these service classes are Objective-C.
\href{https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html}{To
use them from your project's Swift code}, you must also add and
configure an Objective-C bridging header. You'll do these things now:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Recall that you created the following ZIP file containing the
  Guestbook Mobile SDK:

\begin{verbatim}
modules/gb/build/liferay-gb-ios-sdk-1.0.zip
\end{verbatim}

  Unzip this file to a location of your choosing on your machine. This
  creates the following directory hierarchy:

  \begin{figure}
  \centering
  \includegraphics{./images/ios-lp-sdk-structure.png}
  \caption{The Guestbook Mobile SDK's Objective-C classes unzip to this
  folder structure.}
  \end{figure}

  This should look familiar. It's the same \texttt{Service} folder,
  contents and all, from the Guestbook Mobile SDK you built earlier.
\item
  To install the service classes in your project, drag the \texttt{v7}
  folder from your Finder into your Xcode project, directly under the
  root project. In the dialog that appears, make sure you select the
  following items, and then click \emph{Finish}:

  \begin{figure}
  \centering
  \includegraphics{./images/ios-lp-add-sdk.png}
  \caption{When adding the Guestbook Mobile SDK to your project, select
  these options and then click \emph{Finish}.}
  \end{figure}

  \begin{figure}
  \centering
  \includegraphics{./images/ios-lp-post-sdk-install.png}
  \caption{Your project structure should look like this after adding the
  Guestbook SDK.}
  \end{figure}
\item
  The \texttt{v7} folder and its contents are now inside your Xcode
  project. Now you must change each Objective-C class header file in the
  Guestbook Mobile SDK to always import the Liferay Mobile SDK
  framework. This is necessary because you used
  \texttt{use\_frameworks!} in your \texttt{Podfile}.

  In \texttt{LREntryService\_v7.h} and
  \texttt{LRGuestbookService\_v7.h}, replace the
  \texttt{\#if\ ...\ \#endif} statement with
  \texttt{@import\ LRMobileSDK;}. Don't worry if Xcode doesn't recognize
  this import--you'll fix this shortly by adding and configuring an
  Objective-C bridging header in your project.
\item
  In Xcode, for each \texttt{*.m} file in the Guestbook Mobile SDK
  (\texttt{LREntryService\_v7.m} and \texttt{LRGuestbookService\_v7.m}),
  make sure the checkbox for the \emph{Liferay Guestbook} target is
  selected in the File inspector's \emph{Target Membership} section.

  \begin{figure}
  \centering
  \includegraphics{./images/ios-lp-target-membership.png}
  \caption{Each \texttt{*.m} file in the Guestbook Mobile SDK must be
  part of the \emph{Liferay Guestbook} target.}
  \end{figure}
\end{enumerate}

To use the Guestbook Mobile SDK's Objective-C classes from Swift, you
must add and configure an Objective-C bridging header in your project.
Follow these instructions to do so:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In Xcode's project navigator, right-click the root project and select
  \emph{New File}. In the window that appears, select \emph{Header File}
  from the \emph{Source} section of the \emph{iOS} tab, and click
  \emph{Next}.

  \begin{figure}
  \centering
  \includegraphics{./images/ios-lp-header-file-01.png}
  \caption{Create a new iOS header file.}
  \end{figure}
\item
  Name the file \texttt{Liferay\ Guestbook-Bridging-Header.h} and make
  sure that \emph{Liferay Guestbook} with the blue icon is selected in
  the \emph{Group} menu. To finish creating the file, uncheck any items
  in \emph{Targets} and click \emph{Create}.

  \begin{figure}
  \centering
  \includegraphics{./images/ios-lp-header-file-02.png}
  \caption{Use these options to create the header file.}
  \end{figure}
\item
  Upon creating the header file, Xcode opens it in the editor. In this
  file, you must import the Guestbook Mobile SDK's header files. Add
  these imports immediately below the comments at the top of the file:

\begin{verbatim}
#import "LRGuestbookService_v7.h"
#import "LREntryService_v7.h"
\end{verbatim}

  Your bridging header file should now look like this:

\begin{verbatim}
#import "LRGuestbookService_v7.h"
#import "LREntryService_v7.h"

#ifndef Liferay_Guestbook_Bridging_Header_h
#define Liferay_Guestbook_Bridging_Header_h


#endif 
\end{verbatim}
\item
  Now you must configure your project to use this file. Select the root
  project on the left and then click \emph{Build Settings}. Enter for
  \emph{Objective-C Bridging Header} in the search box. The matching
  build setting appears under the section \emph{Swift Compiler -
  General}. In the two \emph{Liferay Guestbook} fields for this build
  setting, enter the bridging header's file name.

  \begin{figure}
  \centering
  \includegraphics{./images/ios-lp-build-settings-header.png}
  \caption{The red boxes highlight the two Liferay Guestbook fields
  configured to use the bridging header file.}
  \end{figure}
\item
  Build the project.
\end{enumerate}

Awesome! You've successfully installed the Guestbook Mobile SDK. Next,
you'll configure your app to communicate with your Liferay DXP
installation.

\subsection{Configuring Communication with Liferay
Portal}\label{configuring-communication-with-liferay-portal}

For Liferay Screens to work with your app, you must configure it to
communicate with your Liferay DXP installation. You'll do this by
setting attributes in a \texttt{plist} file:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In Xcode's project navigator, right-click the \emph{Liferay Guestbook}
  folder (\textbf{not} the root project) and select \emph{New File}. In
  the dialog that appears, select the \emph{iOS} tab then scroll down to
  the \emph{Resource} section and select \emph{Property List}. Click
  \emph{Next}.

  \begin{figure}
  \centering
  \includegraphics{./images/ios-lp-plist-01.png}
  \caption{: Use the Property List template to create a new
  \texttt{plist} file.}
  \end{figure}
\item
  Name the file \texttt{liferay-server-context.plist} and make sure
  you're creating it in the \emph{Liferay Guestbook} folder, which
  should be selected in the \emph{Group} menu. Also make sure that
  \emph{Liferay Guestbook} is selected in the \emph{Targets} menu. Then
  click \emph{Create}.

  \begin{figure}
  \centering
  \includegraphics{./images/ios-lp-plist-02.png}
  \caption{: Create the \texttt{plist} file as shown here.}
  \end{figure}
\item
  The \texttt{plist} file now opens in the editor. Right-click the file
  in the Project navigator and select \emph{Open As} → \emph{Source
  Code}. Replace the file's contents with this code:

\begin{verbatim}
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>server</key>
    <string>http://localhost:8080</string>
    <key>version</key>
    <integer>70</integer>
    <key>companyId</key>
    <integer>20116</integer>
    <key>groupId</key>
    <integer>20143</integer>
</dict>
</plist>
\end{verbatim}

  This \texttt{plist} file sets the server address
  (\texttt{http://localhost:8080}), Liferay DXP version (\texttt{70}
  specifies Liferay CE Portal 7.0 and Liferay DXP 7.0),
  \texttt{companyId} (Liferay DXP instance ID), and \texttt{groupId}
  (site ID) the app retrieves data from.
\item
  Change the \texttt{companyId} and \texttt{groupId} in the
  \texttt{plist} file to match those of your Liferay DXP instance. You
  can find your company ID in your portal at \emph{Control Panel} →
  \emph{Configuration} → \emph{Virtual Instances}. The instance's ID is
  in the \emph{Instance ID} column. You can find your site ID from the
  site you put the Guestbook portlet on. Navigate to this site, and in
  the \emph{Site Administration} menu select \emph{Configuration} →
  \emph{Site Settings}. The site ID is listed at the top of the
  \emph{General} tab.
\end{enumerate}

Next, you'll configure iOS App Transport Security.

\subsection{Disabling App Transport
Security}\label{disabling-app-transport-security}

App Transport Security is an iOS security feature that restricts all
network activity to HTTPS. It isn't necessary for use in development and
testing. Since your local Liferay DXP instance uses HTTP by default, App
Transport Security prevents your app from communicating with the portal.
You must therefore disable it:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Select your project in Xcode's Project navigator. With the
  \emph{Liferay Guestbook} target selected in the outline, click the
  \emph{Info} tab.

  \begin{figure}
  \centering
  \includegraphics{./images/ios-lp-ats-01.png}
  \caption{: You'll disable App Transport Security in the Info tab.}
  \end{figure}
\item
  In \emph{Custom iOS Target Properties}, right-click \emph{Bundle OS
  Type Code} and select \emph{Add Row}. In the new row's text field,
  enter \emph{App Transport Security Settings}.
\item
  Even though it doesn't yet contain any items, ensure that the App
  Transport Security Settings category is open (click the triangle icon
  to its left to open/close it). Now click the \emph{+} icon next to App
  Transport Security Settings and select \emph{Allow Arbitrary Loads}.
  Then select \emph{YES} for this field's value.

  \begin{figure}
  \centering
  \includegraphics{./images/ios-lp-ats-02.png}
  \caption{: Your App Transport Security settings should look like
  this.}
  \end{figure}

  The Allow Arbitrary Loads setting should look like this when viewing
  your app's \texttt{Info.plist} file as code:

\begin{verbatim}
...
<key>NSAppTransportSecurity</key>
<dict>
    <key>NSAllowsArbitraryLoads</key>
    <true/>
</dict>
...
\end{verbatim}
\end{enumerate}

Stupendous! You've successfully installed Liferay Screens and the
Guestbook Mobile SDK, and configured your app to communicate with your
Liferay DXP instance. Before starting work on the app, however, you
should learn the app's design. The next article walks you through this.

\section{Designing Your App}\label{designing-your-app-1}

As a developer, you know that developing any kind of app without an
overall design goal and plan to implement it is a recipe for disaster.
To avoid this, you need to decide some things upfront. The Liferay
Guestbook app needs a straightforward way to do three things:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Authenticate users
\item
  Display guestbooks
\item
  Display entries
\end{enumerate}

To authenticate users, all you need to do is insert and configure
\href{/docs/7-0/reference/-/knowledge_base/r/loginscreenlet-for-ios}{Login
Screenlet} in your app. Login Screenlet comes complete with its own UI.
The design for authentication, therefore, like with Liferay DXP itself,
is done for you.

You must, however, create the UI for displaying guestbooks and entries.
What sort of UI would be best for this? Although the \emph{best} UI for
any purpose is a matter of opinion, displaying guestbooks and entries in
lists is a good choice. Lists are common, compact design elements
familiar to mobile users. Since most mobile devices don't have room to
display a list of guestbooks and a list of entries at the same time, you
also need a user-friendly way to display and manage these lists. It
makes sense to show a list of guestbooks automatically after the user
authenticates. The user can then select a guestbook to view a list of
its entries. Users are familiar with this drill-down navigation style,
as it's common throughout iOS.

To display these lists, you'll create your own Screenlets: Guestbook
List Screenlet and Entry List Screenlet. Guestbook List Screenlet needs
to retrieve guestbooks from the portlet and display them in a simple
list. Once written, using this Screenlet is a simple matter of inserting
it in a scene. Entry List Screenlet needs to retrieve and display a
guestbook's entries in a similar list. You'll display the entries by
inserting Entry List Screenlet in another scene.

Also note that these Screenlets are \emph{list Screenlets}. You develop
list Screenlets by using the list Screenlet framework, which sits on top
of the core Screenlet framework. The list Screenlet framework makes it
easy for developers to write Screenlets that display lists of entities
from a Liferay DXP instance.

\begin{figure}
\centering
\includegraphics{./images/ios-app-design.png}
\caption{After login, the user transitions to the guestbooks scene where
Guestbook List Screenlet displays a list of guestbooks. Upon selecting a
guestbook, the entries scene displays a list of that guestbook's entries
with Entry List Screenlet. Because the guestbooks and entries scenes are
embedded in a navigation controller, the user can navigate back to the
guestbooks scene via a back button in the navigation bar.}
\end{figure}

Awesome! Now you have a basic UI design and know the Screenlets you'll
create to implement it. But the app currently contains only one empty
scene, which you'll use for authentication with Login Screenlet. To use
your custom list Screenlets, you'll need to create two additional
scenes. You'll do this as you develop the app.

Great! Now you understand the Liferay Guestbook app's design. Next,
you'll use Login Screenlet to implement authentication.

\section{Using Login Screenlet for
Authentication}\label{using-login-screenlet-for-authentication-1}

For the app to retrieve data from the Guestbook portlet, the user must
first authenticate to the Liferay DXP instance. You can implement
authentication using the Liferay Mobile SDK, but it takes time to write.
Using Liferay Screens to authenticate takes about ten minutes. In this
article, you'll use Login Screenlet to implement authentication in your
app.

\subsection{Adding Login Screenlet to the
App}\label{adding-login-screenlet-to-the-app-1}

To use any Screenlet, you must follow two steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Insert the Screenlet in the storyboard scene where you want it to
  appear. You do this by adding an empty view to the scene, and then
  setting the Screenlet class as the view's custom class.
\item
  Conform the scene's view controller's class to the Screenlet's
  delegate protocol. This lets the view controller respond to the
  Screenlet's events.
\end{enumerate}

In this app, you'll use Login Screenlet in the app's first (and at this
time, only) scene. After adding the Screenlet to this scene, you'll
conform \texttt{ViewController} (the scene's view controller class) to
the \texttt{LoginScreenletDelegate} protocol.

\subsection{Adding Login Screenlet to the
Scene}\label{adding-login-screenlet-to-the-scene}

Follow these steps to add Login Screenlet to the scene:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In \texttt{Main.storyboard}, first select the scene's view controller.
  Then drag and drop a plain view (\texttt{UIView}) from the Object
  Library onto the view controller. In the outline view, this new view
  should be nested under the view controller's existing view.

  \begin{figure}
  \centering
  \includegraphics{./images/ios-lp-new-view-outline.png}
  \caption{The new view is nested under the view controller's existing
  view.}
  \end{figure}
\item
  With the new view selected, open the Identity inspector and set the
  view's Custom Class as \texttt{LoginScreenlet}. Xcode now builds the
  project and renders Login Screenlet's preview in the view. Also note
  that the view now appears as Login Screenlet in the outline view.

  \begin{figure}
  \centering
  \includegraphics{./images/ios-lp-custom-class.png}
  \caption{You must set the view's Custom Class to
  \texttt{LoginScreenlet}.}
  \end{figure}
\item
  Now you'll set the constraints to center Login Screenlet in the scene.
  Although this isn't required (you can technically position Login
  Screenlet anywhere you want), centering an authentication UI is common
  in mobile apps. Center Login Screenlet in the scene, and click the
  \emph{Align} menu at the bottom-right of the canvas. In this menu,
  check the checkboxes for \emph{Horizontally in Container} and
  \emph{Vertically in Container}, and click the \emph{Add 2 Constraints}
  button (don't worry about the Auto Layout errors that appear--you'll
  resolve these in the next step).

  \begin{figure}
  \centering
  \includegraphics{./images/ios-lp-alignment-constraints.png}
  \caption{These alignment constraints center Login Screenlet in the
  scene.}
  \end{figure}
\item
  By default, Login Screenlet stretches or compresses to fill the view.
  It's compressed at the moment because of the alignment constraints. To
  avoid any ill-effects caused by automatic resizing, you'll set the
  Screenlet to a fixed size. With the view selected, open the \emph{Add
  New Constraints} menu at the bottom-right of the canvas. In this menu,
  set the \emph{Width} to 270 and the \emph{Height} to 185, and click
  the \emph{Add 2 Constraints} button. The Screenlet looks better now
  and the Auto Layout errors are gone. Note that you don't have to use
  these exact width and height values when using Login Screenlet. You
  can size the Screenlet however you wish.

  \begin{figure}
  \centering
  \includegraphics{./images/ios-lp-size-constraints.png}
  \caption{Setting these size constraints ensures that Login Screenlet
  isn't too stretched out or compressed.}
  \end{figure}

  \begin{figure}
  \centering
  \includegraphics{./images/ios-lp-login-scene.png}
  \caption{With the alignment and size constraints set, Login Screenlet
  appears in the center of the scene and its UI components aren't too
  compressed or stretched out.}
  \end{figure}
\end{enumerate}

Nicely done! The scene now contains Login Screenlet. Next, you'll
conform \texttt{ViewController} (the scene's view controller class) to
the \texttt{LoginScreenletDelegate} protocol.

\subsection{Conforming to the Screenlet's Delegate
Protocol}\label{conforming-to-the-screenlets-delegate-protocol}

A view controller can respond to a Screenlet's events by conforming to
the Screenlet's delegate protocol. This lets the app developer choose
how their app behaves with the Screenlet. To respond to Login
Screenlet's events, \texttt{ViewController} must conform to the
\texttt{LoginScreenletDelegate} protocol. The Login Screenlet events
that need a response are login success and failure. The delegate defines
methods for both.

Follow these steps to conform \texttt{ViewController} to the
\texttt{LoginScreenletDelegate} protocol:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Import \texttt{LiferayScreens} and set \texttt{ViewController} to
  adopt the \texttt{LoginScreenletDelegate} protocol. The first few
  lines of the class should look like this:

\begin{verbatim}
import UIKit
import LiferayScreens

class ViewController: UIViewController, LoginScreenletDelegate {...
\end{verbatim}
\item
  Implement the \texttt{LoginScreenletDelegate} method
  \texttt{screenlet(\_:onLoginResponseUserAttributes:)}. This method is
  called when authentication with Login Screenlet succeeds. Right now,
  you don't need to do anything in this method besides indicate that
  login succeeded:

\begin{verbatim}
func screenlet(_ screenlet: BaseScreenlet, 
    onLoginResponseUserAttributes attributes: [String:AnyObject]) {
        print("Login Successful!")
}
\end{verbatim}
\item
  Implement the \texttt{LoginScreenletDelegate} method
  \texttt{screenlet(\_:onLoginError:)}. This method is called when
  authentication with Login Screenlet fails. All you need to do in this
  method is print a message indicating that login failed:

\begin{verbatim}
func screenlet(_ screenlet: BaseScreenlet, onLoginError error: NSError) {
    print("Login Failed!")
}
\end{verbatim}
\item
  Now you must get a Login Screenlet reference in
  \texttt{ViewController}. You'll do this by creating an outlet to the
  Screenlet. Return to your storyboard and enter the Assistant editor to
  display \texttt{ViewController}'s code and the storyboard side by
  side. With Login Screenlet selected in the storyboard, Control-drag
  from the Screenlet to the \texttt{ViewController} class to create the
  outlet. In the dialog that appears upon releasing your mouse button,
  enter the following information and click \emph{Connect}:

  \begin{itemize}
  \tightlist
  \item
    \textbf{Connection:} Outlet
  \item
    \textbf{Name:} loginScreenlet
  \item
    \textbf{Type:} LoginScreenlet
  \item
    \textbf{Storage:} Weak
  \end{itemize}

  Xcode then adds the following code inside the \texttt{ViewController}
  class:

\begin{verbatim}
@IBOutlet weak var loginScreenlet: LoginScreenlet!
\end{verbatim}

  \begin{figure}
  \centering
  \includegraphics{./images/ios-lp-login-screenlet-outlet.png}
  \caption{Create an outlet from Login Screenlet to the
  \texttt{ViewController} class.}
  \end{figure}
\item
  In the \texttt{ViewController} class, use the new
  \texttt{loginScreenlet} variable to set the view controller as the
  Screenlet's delegate. Do this in the \texttt{viewDidLoad()} method by
  deleting the placeholder comment and inserting this code below the
  call to \texttt{super.viewDidLoad()}:

\begin{verbatim}
self.loginScreenlet?.delegate = self
\end{verbatim}
\end{enumerate}

Great, you're finished! Before running the app, make sure that your
\texttt{ViewController} class looks like this:

\begin{verbatim}
import UIKit
import LiferayScreens

class ViewController: UIViewController, LoginScreenletDelegate {

    @IBOutlet weak var loginScreenlet: LoginScreenlet!

    override func viewDidLoad() {
        super.viewDidLoad()
        self.loginScreenlet?.delegate = self
    }

    override func didReceiveMemoryWarning() {
        super.didReceiveMemoryWarning()
    }

    func screenlet(_ screenlet: BaseScreenlet, onLoginResponseUserAttributes attributes: [String:AnyObject]) {
        print("Login Successful!")
    }

    func screenlet(_ screenlet: BaseScreenlet, onLoginError error: NSError) {
        print("Login Failed!")
    }

}
\end{verbatim}

Now you're ready to test your work. With your Liferay DXP instance
running, launch the app using the iPhone simulator (any iPhone version
supported by Xcode will work). Enter your credentials when Login
Screenlet appears and click \emph{SIGN IN}. In Xcode, the
\texttt{Login\ Successful!} message appears in the console.

\begin{figure}
\centering
\includegraphics{./images/ios-lp-login-successful.png}
\caption{It worked!}
\end{figure}

Nice job! Nothing else happens, though. Your app still displays Login
Screenlet. This is expected. There aren't any other scenes for your app
to navigate to. In the next article, you'll create the scene for
displaying guestbooks: the guestbooks scene.

\section{Creating the Guestbooks
Scene}\label{creating-the-guestbooks-scene}

In the previous article, you used Login Screenlet to implement
authentication in the login scene. Now you must create the scene you
want the user to see following login: the guestbooks scene. Later in
this Learning Path, you'll display guestbooks in this scene via
Guestbook List Screenlet. For now, though, all you need to do is create
the scene and take the user to it after login. This article shows you
how to do this with the following steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add a view controller to your storyboard. You'll then embed the view
  controller in a navigation controller. The navigation controller gives
  the scene a navigation bar and automatically implements
  back-navigation in the entries scene you'll create later.
\item
  Create the guestbook scene's view controller class. This class
  controls the view controller's behavior.
\item
  Create a segue from the login scene to the guestbooks scene. Upon
  login, this segue takes the user to the guestbooks scene.
\end{enumerate}

First, you'll add a view controller to the storyboard.

\subsection{Adding a View Controller to the
Storyboard}\label{adding-a-view-controller-to-the-storyboard}

Follow these steps to add a view controller to the storyboard:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open your storyboard and drag and drop a \emph{View Controller} from
  the Object Library to the right of the login scene.

  \begin{figure}
  \centering
  \includegraphics{./images/ios-lp-add-gb-vc.png}
  \caption{The arrow shows where to drag and drop the View Controller to
  create the new guestbooks scene.}
  \end{figure}
\item
  Now you must embed this view controller in a
  \href{https://developer.apple.com/library/content/documentation/WindowsViews/Conceptual/ViewControllerCatalog/Chapters/NavigationControllers.html}{navigation
  controller}. Navigation controllers in iOS implement a
  \emph{navigation stack}. You can loosely think of a navigation stack
  as a deck of cards where each card is a view controller with a
  navigation bar. The navigation bar contains a back button that lets
  you navigate to the previous view controller in the stack. You can
  also change the navigation bar's title to reflect the scene's content.

  With the new view controller selected in the storyboard, select
  \emph{Editor} → \emph{Embed In} → \emph{Navigation Controller}. Your
  storyboard now shows the navigation controller with a segue to the
  guestbooks scene. Also, the guestbooks scene now contains an empty
  navigation bar.
\item
  Select the Navigation Item in the guestbooks scene's navigation bar.
  In the Attributes inspector, enter \emph{Guestbooks} in the
  \emph{Title} field, then enter a single space in the \emph{Back
  Button} field and press return. This labels the scene via the
  navigation bar, and ensures that the back button in the Navigation
  controller has no label. The back button's default left chevron
  indicates the button's purpose without the need for additional text.

  \begin{figure}
  \centering
  \includegraphics{./images/ios-lp-back-button-label.png}
  \caption{Label the scene in the navigation bar, and set the back
  button's label to an empty space.}
  \end{figure}
\item
  With the guestbooks scene's view controller selected in the
  storyboard, open the Attributes inspector and uncheck \emph{Adjust
  Scroll View Insets}. This ensures that the scene's contents are flush
  with the navigation bar.

  \begin{figure}
  \centering
  \includegraphics{./images/ios-lp-adj-scroll-view-ins.png}
  \caption{Make sure the view controller's \emph{Adjust Scroll View
  Insets} option is unchecked in the Attributes inspector.}
  \end{figure}
\end{enumerate}

Great! You now have the guestbooks scene, embedded in a navigation
controller. For this scene's view controller to work, it must have a
class that controls its behavior. You'll create this class next.

\subsection{Creating the Guestbooks Scene's View Controller
Class}\label{creating-the-guestbooks-scenes-view-controller-class}

Each view controller must have a class that controls its behavior. In
this section, you'll create this class for the guestbooks scene's view
controller. In the storyboard, you'll then set this class as the view
controller's custom class.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Right-click the \emph{Liferay Guestbook} folder in Xcode's project
  navigator and select \emph{New File}. In the \emph{iOS} →
  \emph{Source} section of the dialog that appears, select \emph{Cocoa
  Touch Class} and click \emph{Next}.
\item
  The next screen in the dialog lets you set the class's name, subclass,
  and language. You can also choose whether to create an XIB file for
  the class. Enter the following information and click \emph{Next}:

  \begin{itemize}
  \tightlist
  \item
    \textbf{Class:} \texttt{GuestbooksViewController}
  \item
    \textbf{Subclass of:} \texttt{UIViewController}
  \item
    \textbf{Also create XIB file:} Unchecked
  \item
    \textbf{Language:} Swift
  \end{itemize}

  \begin{figure}
  \centering
  \includegraphics{./images/ios-lp-gb-vc-class.png}
  \caption{Set these options when creating the view controller's class.}
  \end{figure}
\item
  The final screen in the dialog lets you set the class's location,
  group, and targets. Make sure \emph{Liferay Guestbook} is selected for
  both the \emph{Group} and \emph{Targets} menus, and click
  \emph{Create}.
\item
  In the storyboard, select the guestbooks scene's view controller. In
  the Identity inspector, set \texttt{GuestbooksViewController} as the
  Custom Class.

  \begin{figure}
  \centering
  \includegraphics{./images/ios-lp-gb-vc-cc.png}
  \caption{Set \texttt{GuestbooksViewController} as the custom class of
  the guestbooks scene's view controller.}
  \end{figure}
\end{enumerate}

Nice! The guestbooks scene's view controller now has a class that
governs its behavior. You may have noticed a big problem, though.
There's no way for the user to get from the login scene to the
guestbooks scene. This is because there's no segue from the login scene
to the navigation controller the guestbooks scene is embedded in. You'll
fix this next.

\subsection{Creating the Segue}\label{creating-the-segue}

Follow these steps to create and trigger the segue:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Control-drag from the login scene's view controller to the navigation
  controller. In the dialog that appears when you release your mouse
  button, select \emph{show} for the segue type. The segue now connects
  the login scene's view controller and the navigation controller.

  \begin{figure}
  \centering
  \includegraphics{./images/ios-lp-login-segue.png}
  \caption{A segue now exists from the login scene to the navigation
  controller.}
  \end{figure}
\item
  Now you must tell the login scene's view controller when to perform
  this segue. You'll do this programmatically in the
  \texttt{ViewController} class. To perform a segue programmatically,
  you must first give it an identifier in your storyboard. You'll then
  use this identifier in \texttt{ViewController} to perform the segue
  when a user logs in.

  In your storyboard, select the segue and then enter the Attributes
  inspector. Enter \emph{loginsegue} in the \emph{Identifier} field, and
  press \emph{return}.

  \begin{figure}
  \centering
  \includegraphics{./images/ios-lp-login-segue-id.png}
  \caption{Set the segue's ID in the Attributes inspector.}
  \end{figure}
\item
  Recall that the \texttt{ViewController} class's
  \texttt{screenlet(\_:onLoginResponseUserAttributes:)} method is called
  upon successful login. You'll therefore trigger the segue in this
  method. Currently, this method only prints a success message. Below
  the line that prints this message, add the following code:

\begin{verbatim}
performSegue(withIdentifier: "loginsegue", sender: nil)
\end{verbatim}

  The \texttt{performSegue(withIdentifier:sender:)} method performs the
  segue with the specified identifier and includes any additional sender
  code. You send \texttt{nil} here since you don't need to send any
  information with the segue. Your
  \texttt{screenlet(\_:onLoginResponseUserAttributes:)} method should
  now look like this:

\begin{verbatim}
func screenlet(_ screenlet: BaseScreenlet, 
    onLoginResponseUserAttributes attributes: [String:AnyObject]) {
        print("Login Successful!")
        performSegue(withIdentifier: "loginsegue", sender: nil)
}
\end{verbatim}
\end{enumerate}

Great! Your app can now navigate to the guestbooks scene after login. To
verify this, run the app and log in.

\begin{figure}
\centering
\includegraphics{./images/ios-lp-gb-scene-empty.png}
\caption{Following successful login, the app now navigates to the empty
guestbooks scene.}
\end{figure}

Awesome! You've successfully added a scene for displaying guestbooks,
and set the app to take the user there after login. Now you're ready to
develop Guestbook List Screenlet. The next section in this Learning Path
walks you through this.

\chapter{Creating Guestbook List
Screenlet}\label{creating-guestbook-list-screenlet-1}

In the previous section, you created an iOS app that contains the
Guestbook Mobile SDK and Liferay Screens. You also used
\href{/docs/7-0/reference/-/knowledge_base/r/loginscreenlet-for-ios}{Login
Screenlet} to implement authentication to Liferay DXP. That's all your
app does though. It doesn't display any Guestbook portlet content. In
this section of the Learning Path, you'll create Guestbook List
Screenlet to retrieve and display the portlet's guestbooks in your app's
guestbooks scene.

Creating your own Screenlets brings additional benefits. Since you use a
consistent, repeatable development model to create them, you can often
reuse code when creating other Screenlets. You can also package and
reuse Screenlets in other apps. What's more, Screenlet UIs are fully
pluggable. This lets you change a Screenlet's appearance quickly without
affecting its functionality. In summary, Screenlets are pretty much the
greatest thing since sliced bread. Now it's time to make a sandwich.

You'll use these steps to create Guestbook List Screenlet:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Getting started: Create the Screenlet's folder, and the model class.
  The model class creates objects that represent guestbooks retrieved
  from the portlet, making it easier to work with guestbooks in your
  app.
\item
  Create the Screenlet's UI (its Theme).
\item
  Create the Connector. Connectors are Screenlet components that make
  server calls.
\item
  Create the Interactor. In list Screenlets, Interactors are Screenlet
  components that instantiate Connectors and receive their results.
\item
  Create the delegate. Delegates let other classes respond to the
  Screenlet's events.
\item
  Create the Screenlet class. The Screenlet class governs the
  Screenlet's behavior.
\end{enumerate}

As background material, the following materials are helpful:

\begin{itemize}
\tightlist
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/architecture-of-liferay-screens-for-ios}{Architecture
  of Liferay Screens for iOS}: Explains the components that constitute a
  Screenlet, and how they relate to one another.
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/creating-ios-screenlets}{Creating
  iOS Screenlets}: Explains the general steps for creating a Screenlet.
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/creating-ios-list-screenlets}{Creating
  iOS List Screenlets}: Explains the general steps for creating a list
  Screenlet. This section of the Learning Path follows this tutorial.
\end{itemize}

Note that these tutorials explain Screenlet and list Screenlet concepts
that this Learning Path doesn't cover in depth. Although it's possible
to complete this Learning Path without reading these tutorials, they
explain how Screenlets work in more detail. By reading them you'll be
better able to apply the Learning Path material to your own Screenlets.

If you get confused or stuck while creating Guestbook List Screenlet,
refer to the finished app that contains the Screenlet code
\href{https://github.com/liferay/liferay-docs/tree/7.0.x/develop/tutorials/code/mobile/ios/screenlets-app/Liferay\%20Guestbook}{here
in GitHub}.

\section{Getting Started with Guestbook List
Screenlet}\label{getting-started-with-guestbook-list-screenlet-1}

Before creating a Screenlet, you should know how you'll use it. If you
plan to use it in only one app, then you can create it in that app's
project. If you need to use it in several apps, however, then it's best
to create it in a separate project for redistribution. For information
on creating Screenlets for redistribution, see the tutorial
\href{/docs/7-0/tutorials/-/knowledge_base/t/packaging-ios-themes}{Packaging
iOS Themes}. Even though that tutorial is for packaging Themes, you can
use the same steps to package Screenlets.

Since you'll use Guestbook List Screenlet in only this app, you can
create it in a new folder inside the app's project. Create this folder
now:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In the Finder, create the \texttt{GuestbookListScreenlet} folder
  inside the root project folder.

  \begin{figure}
  \centering
  \includegraphics{./images/ios-lp-guestbook-screenlet-finder.png}
  \caption{The new \texttt{GuestbookListScreenlet} folder should be
  inside your root project folder.}
  \end{figure}
\item
  Drag and drop the \texttt{GuestbookListScreenlet} folder from the
  Finder into your Xcode project, under the root project. In the dialog
  that appears, select \emph{Copy items if needed}, \emph{Create
  groups}, and the \emph{Liferay Guestbook} target. Then click
  \emph{Finish}. The \texttt{GuestbookListScreenlet} folder now appears
  in your project.

  \begin{figure}
  \centering
  \includegraphics{./images/ios-lp-gb-screenlet-proj-nav.png}
  \caption{After adding the \texttt{GuestbookListScreenlet} folder, your
  project should look something like this.}
  \end{figure}
\end{enumerate}

Great! Now you have a folder to create Guestbook List Screenlet in.
Before getting started, you should understand how pagination works in in
list Screenlets.

\subsection{Pagination}\label{pagination-1}

To ensure that users can scroll smoothly through large lists of items,
list Screenlets support
\href{http://www.iosnomad.com/blog/2014/4/21/fluent-pagination}{fluent
pagination}. Support for this is built into the list Screenlet
framework. You'll see this as you construct your list Screenlet. For
example, several methods have parameters for the start row and end row
of a page in the list.

Now you're ready to begin creating the Screenlet!

\subsection{Creating the Model Class}\label{creating-the-model-class}

Liferay Screens typically receives entities from a Liferay DXP instance
as a \texttt{{[}String:AnyObject{]}} dictionary, where \texttt{String}
is the entity's attribute and \texttt{AnyObject} is the attribute's
value. Although your Screenlet can use these dictionary objects, it's
often easier to create a \emph{model class} that converts each into an
object that represents the corresponding entity in the portal. Model
classes are especially convenient for complex entities composed of many
attribute-value pairs, like guestbooks in the Guestbook portlet.

Your model class must contain all the code necessary to transform each
\texttt{{[}String:AnyObject{]}} dictionary that comes back from the
server into a model object that represents a guestbook. This includes a
public constant for holding each \texttt{{[}String:AnyObject{]}}
dictionary, a public initializer that sets this constant, and a public
property for each attribute value.

The model class you'll create for Guestbook List Screenlet,
\texttt{GuestbookModel}, creates \texttt{GuestbookModel} objects that
represent guestbooks retrieved from the Guestbook portlet. You'll create
this model class in a separate folder outside of the
\texttt{GuestbookListScreenlet} folder. In this case, it makes sense to
organize your code this way because other Screenlets may also use the
model class. For example, if a Screenlet that edits guestbooks existed,
it would also need \texttt{GuestbookModel} objects. Putting the model
class in a separate folder makes it clear that this class doesn't belong
exclusively to a single Screenlet.

Follow these steps to create Guestbook List Screenlet's model class:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In the Finder, create the \texttt{model} folder inside your root
  project folder.

  \begin{figure}
  \centering
  \includegraphics{./images/ios-lp-model-finder.png}
  \caption{The new \texttt{model} folder should be inside your root
  project folder.}
  \end{figure}
\item
  Drag and drop the \texttt{model} folder from the Finder into your
  Xcode project, under the root project. In the dialog that appears,
  select \emph{Copy items if needed}, \emph{Create groups}, and the
  \emph{Liferay Guestbook} target. Then click \emph{Finish}. The
  \texttt{model} folder now appears in your project.

  \begin{figure}
  \centering
  \includegraphics{./images/ios-lp-model-project-nav.png}
  \caption{After adding the \texttt{model} folder, your project should
  look something like this.}
  \end{figure}
\item
  In the Project navigator, right-click the \texttt{model} folder and
  select \emph{New File}. In the dialog that appears, fill out each
  screen as follows:

  \begin{itemize}
  \tightlist
  \item
    Select \emph{iOS} → \emph{Source} → \emph{Cocoa Touch Class}, and
    click \emph{Next}.
  \item
    Name the class \texttt{GuestbookModel}, set it to extend
    \texttt{NSObject}, select \emph{Swift} for the language, and click
    \emph{Next}.
  \item
    Make sure the \texttt{model} folder and group is selected, as well
    as the \emph{Liferay Guestbook} target (these should be selected by
    default). Click \emph{Create}.
  \end{itemize}

  The new class now opens in the editor.
\item
  Replace the class file's contents with this code:

\begin{verbatim}
import UIKit

@objc public class GuestbookModel: NSObject {

    public let attributes: [String:AnyObject]

    public var guestbookId: Int64 {
        return attributes["guestbookId"]?.int64Value ?? 0
    }

    public var groupId: Int64 {
        return attributes["groupId"]?.int64Value ?? 0
    }

    public var companyId: Int64 {
        return attributes["companyId"]?.int64Value ?? 0
    }

    public var userId: Int64 {
        return attributes["userId"]?.int64Value ?? 0
    }

    public var userName: String {
        return attributes["userName"] as? String ?? ""
    }

    public var createDate: Int64 {
        return attributes["createDate"]?.int64Value ?? 0
    }

    public var modifiedDate: Int64 {
        return attributes["modifiedDate"]?.int64Value ?? 0
    }

    public var name: String {
        return attributes["name"] as? String ?? ""
    }

    //MARK: Initializer

    public init(attributes: [String:AnyObject]) {
        self.attributes = attributes
    }

}
\end{verbatim}
\end{enumerate}

This class creates \texttt{GuestbookModel} objects that represent
guestbooks from the Guestbook portlet. The
\texttt{{[}String:AnyObject{]}} dictionary contains the data of a
guestbook retrieved from the portlet. The initializer sets this
dictionary to the \texttt{attributes} property. Each computed property
returns the value of a guestbook parameter in \texttt{attributes}. For
example, the \texttt{guestbookId} property returns the value of the
\texttt{guestbookId} parameter, the \texttt{groupId} property returns
the value of the \texttt{groupId} parameter, and so on. To see how the
Guestbook portlet defines these parameters, see the
\href{/docs/7-0/tutorials/-/knowledge_base/t/generating-the-back-end}{section
on generating the portlet's back end} in the Liferay Web Application
Learning Path.

Also note that each computed property defaults to an empty string or
\texttt{0}, depending on the property's type, if the parameter contains
a value that can't be represented as that type. This prevents the app
from crashing if the parameter doesn't have an appropriate value. For
example, if the \texttt{guestbookId} parameter contains \texttt{nil},
then the \texttt{guestbookId} property returns \texttt{0}.

Great! Now you have a model class for guestbooks. Next, you'll create
the Screenlet's UI.

\section{Creating Guestbook List Screenlet's
UI}\label{creating-guestbook-list-screenlets-ui-1}

In Liferay Screens for iOS, Screenlet UIs are called \emph{Themes}.
Every Screenlet must have at least one Theme. You'll use the following
steps to create a Theme for Guestbook List Screenlet:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Create your Theme's folder and add it to your Xcode project.
\item
  Create an XIB file and use it to construct the UI.
\item
  Create your Theme's View class and set it as the XIB file's custom
  class.
\end{enumerate}

\subsection{Creating Your Theme's
Folder}\label{creating-your-themes-folder}

Even if you only plan on creating one Theme, it's best practice to
create it in its own folder inside a parent \texttt{Themes} folder. The
parent \texttt{Themes} folder gives you a place to put any additional
Themes you create. You'll create a single Theme for Guestbook List
Screenlet: the Default Theme. You'll therefore create the
\texttt{Themes/Default} folder path inside the
\texttt{GuestbookListScreenlet} folder.

Follow these steps to create your Theme's folder:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In the Finder, create the \texttt{Themes} folder inside your project's
  \texttt{GuestbookListScreenlet} folder. Then create the
  \texttt{Default} folder inside the new \texttt{Themes} folder.

  \begin{figure}
  \centering
  \includegraphics{./images/ios-lp-theme-folders-finder.png}
  \caption{The new \texttt{Themes/Default} folder structure should be
  inside the Screenlet's folder.}
  \end{figure}
\item
  Drag and drop the \texttt{Themes} folder from the Finder into your
  Xcode project, under the \texttt{GuestbookListScreenlet} folder. In
  the dialog that appears, select \emph{Copy items if needed},
  \emph{Create groups}, and the \emph{Liferay Guestbook} target. Then
  click \emph{Finish}. The \texttt{Themes/Default} folder structure now
  appears in your project.

  \begin{figure}
  \centering
  \includegraphics{./images/ios-lp-themes-proj-nav.png}
  \caption{After adding the \texttt{Themes} folder to your project, the
  \texttt{Themes/Default} folder structure should appear in the Project
  navigator.}
  \end{figure}
\end{enumerate}

Now you're ready to start creating your Theme. First, you'll create its
XIB file.

\subsection{Creating the XIB File}\label{creating-the-xib-file}

A Theme requires an XIB file to define the UI's components and layout.
Use these steps to create your Theme's XIB file:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In the Project navigator, right-click the \texttt{Default} folder and
  select \emph{New File}. In the dialog that appears, select \emph{iOS}
  → \emph{User Interface} → \emph{Empty}, and click \emph{Next}. Name
  the file \texttt{GuestbookListView\_default.xib}, and ensure that
  \emph{Default} is selected for the save location and group. The
  \emph{Liferay Guestbook} target should also be selected. Click
  \emph{Create}. The file should then open in Interface Builder.
\item
  In Interface Builder, drag and drop a View from the Object Library to
  the canvas. Then add a Table View to the View. Set the Table View to
  take up the entire View.
\item
  With the Table View selected, open the \emph{Add New Constraints} menu
  at the bottom-right of the canvas. In this menu, set \emph{Spacing to
  nearest neighbor} to 0 on all sides, select \emph{Constrain to
  margins}, and then click the \emph{Add 4 Constraints} button.

  \begin{figure}
  \centering
  \includegraphics{./images/ios-lp-xib-constraints.png}
  \caption{Add these constraints to the Table View in the XIB.}
  \end{figure}
\end{enumerate}

Your Theme's XIB is now finished. Next, you'll create your View class.

\subsection{Creating the Theme's View
Class}\label{creating-the-themes-view-class}

Every Theme needs a View class that controls its behavior. Since the XIB
file uses a \texttt{UITableView} to show a list of guestbooks, your View
class must extend
\href{https://github.com/liferay/liferay-screens/blob/master/ios/Framework/Core/Base/BaseListScreenlet/TableView/BaseListTableView.swift}{the
\texttt{BaseListTableView} class}. Liferay Screens provides this class
to serve as the base class for list Screenlets' View classes. Since
\texttt{BaseListTableView} provides most of the required functionality,
extending it lets you focus on the parts of your View class that are
unique to your Screenlet.

Follow these steps to create your Screenlet's View class:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In the Project navigator, right-click the \texttt{Default} folder and
  select \emph{New File}. In the dialog that appears, fill out each
  screen as follows:

  \begin{itemize}
  \tightlist
  \item
    Select \emph{iOS} → \emph{Source} → \emph{Cocoa Touch Class}, and
    click \emph{Next}.
  \item
    Name the class \texttt{GuestbookListView\_default}, set it to extend
    \texttt{BaseListTableView}, select \emph{Swift} for the language,
    and click \emph{Next}.
  \item
    Make sure the \texttt{Default} folder and group is selected, as well
    as the \emph{Liferay Guestbook} target (these should be selected by
    default). Click \emph{Create}.
  \end{itemize}
\item
  In \texttt{GuestbookListView\_default}, add an import for
  \texttt{LiferayScreens} and delete any placeholder comments in the
  class body.
\item
  Now you must override the View class methods that fill the table
  cells' contents. There are two methods for this, depending on the cell
  type:

  \begin{itemize}
  \item
    \textbf{Normal cells:} the cells that show the entities. These cells
    typically use \texttt{UILabel}, \texttt{UIImage}, or another UI
    component to show the entity. Override the \texttt{doFillLoadedCell}
    method to fill these cells. Guestbook List Screenlet's View class
    must override \texttt{doFillLoadedCell} to set each cell's
    \texttt{textLabel} to a guestbook's name:

\begin{verbatim}
  override public func doFillLoadedCell(row: Int, cell: UITableViewCell, 
      object: AnyObject) {

          let guestbook = object as! GuestbookModel
          cell.textLabel?.text = guestbook.name
  }
\end{verbatim}
  \item
    \textbf{Progress cell:} the cell at the bottom of the list that
    indicates the list is loading the next page of items. Override the
    \texttt{doFillInProgressCell} method to fill this cell. Guestbook
    List Screenlet's View class must override this method to set the
    cell's \texttt{textLabel} to the string \texttt{"Loading..."}:

\begin{verbatim}
  override public func doFillInProgressCell(row: Int, cell: UITableViewCell) {
      cell.textLabel?.text = "Loading..."
  }
\end{verbatim}
  \end{itemize}

  Your complete View class should look like this:

\begin{verbatim}
import UIKit
import LiferayScreens

class GuestbookListView_default: BaseListTableView {

    override public func doFillLoadedCell(row: Int, cell: UITableViewCell, 
        object: AnyObject) {

            let guestbook = object as! GuestbookModel
            cell.textLabel?.text = guestbook.name
    }

    override public func doFillInProgressCell(row: Int, cell: UITableViewCell) {
        cell.textLabel?.text = "Loading..."
    }

}
\end{verbatim}
\item
  Return to the Theme's XIB in Interface Builder, and set
  \texttt{GuestbookListView\_default} as the the parent View's custom
  class. To do this, select the Table View's parent View, click the
  Identity inspector, and enter \texttt{GuestbookListView\_default} as
  the Custom Class.

  \begin{figure}
  \centering
  \includegraphics{./images/ios-lp-gb-theme-custom-class.png}
  \caption{In the XIB file, set the Custom Class of the Table View's
  parent View to \texttt{GuestbookListView\_default}.}
  \end{figure}
\item
  With the Theme's XIB still open in Interface Builder, set the parent
  View's \texttt{tableView} outlet to the Table View. To do this, select
  the parent View and click the Connections inspector. In the Outlets
  section, drag and drop from the \texttt{tableView}'s circle icon (it
  turns into a plus icon on mouseover) to the Table View in the XIB. The
  new outlet then appears in the Connections inspector.

  \begin{figure}
  \centering
  \includegraphics{./images/ios-lp-table-view-outlet-01.png}
  \caption{In the XIB, drag and drop from the \texttt{tableView} outlet
  to the Table View.}
  \end{figure}

  \begin{figure}
  \centering
  \includegraphics{./images/ios-lp-table-view-outlet-02.png}
  \caption{After creating the connection, it appears in the Connections
  inspector.}
  \end{figure}
\end{enumerate}

Great! Your Theme is finished. Next, you'll create Guestbook List
Screenlet's Connector.

\section{Creating Guestbook List Screenlet's
Connector}\label{creating-guestbook-list-screenlets-connector}

Connectors are Screenlet components that make server calls. Non-list
Screenlets don't require Connectors--they can make server calls in
Interactors instead. Connectors, however, provide a layer of abstraction
by making the server call outside the Interactor. This leaves the
Interactor to instantiate the Connector and receive the server call's
results. List Screenlets exploit this architectural advantage by
requiring Connectors.

First, you'll create a folder for the Connector.

\subsection{Creating Your Connector's
Folder}\label{creating-your-connectors-folder}

Follow these steps to create your Connector's folder:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In the Finder, create the \texttt{Connector} folder inside your
  project's \texttt{GuestbookListScreenlet} folder.
\item
  Drag and drop the \texttt{Connector} folder from the Finder into your
  Xcode project, under the \texttt{GuestbookListScreenlet} folder. In
  the dialog that appears, select \emph{Copy items if needed},
  \emph{Create groups}, and the \emph{Liferay Guestbook} target. Then
  click \emph{Finish}. The \texttt{Connector} folder now appears in your
  project.

  \begin{figure}
  \centering
  \includegraphics{./images/ios-lp-connector-folder.png}
  \caption{The new \texttt{Connector} folder should be inside the
  Screenlet's folder.}
  \end{figure}
\end{enumerate}

Now you're ready to create the Connector.

\subsection{Creating the Connector}\label{creating-the-connector}

List Screenlet Connectors must extend
\href{https://github.com/liferay/liferay-screens/blob/master/ios/Framework/Core/Base/BaseListScreenlet/PaginationLiferayConnector.swift}{the
\texttt{PaginationLiferayConnector} class}, which Liferay Screens
provides to enable most of the functionality required by list Screenlet
Connectors. Extending this class lets you focus on the functionality
unique to your Connector. Your list Screenlet's Connector class must
contain any properties it needs to make the server call, and an
initializer that sets them. To support pagination, the initializer must
also contain the following arguments, which you'll pass to the
superclass initializer:

\begin{itemize}
\tightlist
\item
  \texttt{startRow}: The number representing the page's first row.
\item
  \texttt{endRow}: The number representing the page's last row.
\item
  \texttt{computeRowCount}: Whether to call the Connector's
  \texttt{doAddRowCountServiceCall} method (you'll learn about this
  method shortly).
\end{itemize}

Follow these steps to create Guestbook List Screenlet's Connector:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In the Project navigator, right-click the \texttt{Connector} folder
  and select \emph{New File}. In the dialog that appears, fill out each
  screen as follows:

  \begin{itemize}
  \tightlist
  \item
    Select \emph{iOS} → \emph{Source} → \emph{Cocoa Touch Class}, and
    click \emph{Next}.
  \item
    Name the class \texttt{GuestbookListPageLiferayConnector}, set it to
    extend \texttt{PaginationLiferayConnector}, select \emph{Swift} for
    the language, and click \emph{Next}.
  \item
    Make sure the \texttt{Connector} folder and group is selected, as
    well as the \emph{Liferay Guestbook} target (these should be
    selected by default). Click \emph{Create}.
  \end{itemize}
\item
  In the new class, import \texttt{LiferayScreens} and add a public
  \texttt{Int64} constant called \texttt{groupId}. This constant holds
  the ID of the site the Connector retrieves guestbooks from. Your
  Connector should now look like this:

\begin{verbatim}
import UIKit
import LiferayScreens

class GuestbookListPageLiferayConnector: PaginationLiferayConnector {

    public let groupId: Int64

}
\end{verbatim}
\item
  Create an initializer that takes the arguments \texttt{startRow},
  \texttt{endRow}, \texttt{computeRowCount}, and \texttt{groupId}. In
  this initializer, set the \texttt{groupId} constant to the
  corresponding argument, then call the superclass initializer with the
  remaining arguments. Add the initializer as follows:

\begin{verbatim}
public init(startRow: Int, endRow: Int, computeRowCount: Bool, groupId: Int64) {
    self.groupId = groupId

    super.init(startRow: startRow, endRow: endRow, computeRowCount: computeRowCount)
}
\end{verbatim}
\item
  Override the \texttt{doAddPageRowsServiceCall} method to make the
  server call that retrieves guestbooks from the portlet. This method
  must call the Guestbook SDK service method
  \texttt{getGuestbooksWithGroupId}, which retrieves guestbooks. To do
  this, you must first create a \texttt{LRGuestbookService\_v7} instance
  from the session. Then call the service's
  \texttt{getGuestbooksWithGroupId} method with \texttt{groupId},
  \texttt{startRow}, and \texttt{endRow}:

\begin{verbatim}
public override func doAddPageRowsServiceCall(session: LRBatchSession, startRow: Int, endRow: Int, 
    obc: LRJSONObjectWrapper?) {
        let service = LRGuestbookService_v7(session: session)

        do {
            try service!.getGuestbooksWithGroupId(groupId, start: Int32(startRow), end: Int32(endRow))
        }
        catch {
            // ignore error: the service method returns nil because 
            // the request is sent later, in batch
        }

}
\end{verbatim}

  Note that you don't need to do anything in the \texttt{catch}
  statement because the request is sent later, in batch. The
  \texttt{session} type \texttt{LRBatchSession} handles this for you.
  You'll receive the request's results elsewhere, once the request
  completes.
\item
  Override the \texttt{doAddRowCountServiceCall} method to make the
  server call that retrieves the total number of guestbooks from the
  portlet. This enables pagination. This method must call the Guestbook
  SDK service method \texttt{getGuestbooksCount}, which retrieves the
  total number of guestbooks. To do this, you must first create a
  \texttt{LRGuestbookService\_v7} service instance from the session.
  Then call the service's \texttt{getGuestbooksCount} method with
  \texttt{groupId}:

\begin{verbatim}
override public func doAddRowCountServiceCall(session: LRBatchSession) {
    let service = LRGuestbookService_v7(session: session)

    do {
        try service!.getGuestbooksCount(withGroupId: groupId)
    }
    catch {
        // ignore error: the service method returns nil because 
        // the request is sent later, in batch
    }
}
\end{verbatim}

  As in the previous step, you don't need to do anything in the
  \texttt{catch} statement.
\end{enumerate}

Awesome! Your Connector is finished. Now you're ready to create the
Interactor.

\section{Creating Guestbook List Screenlet's
Interactor}\label{creating-guestbook-list-screenlets-interactor-1}

Interactors implement your Screenlet's actions. In non-list Screenlets,
this can include making the server call. List Screenlets, however, make
server calls via Connectors. Also, loading entities is usually the only
action a user can take in a list Screenlet. Therefore, list Screenlet
Interactors typically only need to instantiate the Connector and receive
the server call's results. This is the case for Guestbook List
Screenlet's Interactor. You'll create this Interactor now.

\subsection{Creating Your Interactor's
Folder}\label{creating-your-interactors-folder}

Follow these steps to create your Interactor's folder:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In the Finder, create the \texttt{Interactor} folder inside your
  project's \texttt{GuestbookListScreenlet} folder.
\item
  Drag and drop the \texttt{Interactor} folder from the Finder into your
  Xcode project, under the \texttt{GuestbookListScreenlet} folder. In
  the dialog that appears, select \emph{Copy items if needed},
  \emph{Create groups}, and the \emph{Liferay Guestbook} target. Then
  click \emph{Finish}. The \texttt{Interactor} folder now appears in
  your project.

  \begin{figure}
  \centering
  \includegraphics{./images/ios-lp-interactor-folder.png}
  \caption{The new \texttt{Interactor} folder should be inside the
  Screenlet's folder.}
  \end{figure}
\end{enumerate}

Now you're ready to create the Interactor.

\subsection{Creating the Interactor}\label{creating-the-interactor}

The Interactor class of a list Screenlet that implements fluent
pagination must extend
\href{https://github.com/liferay/liferay-screens/blob/master/ios/Framework/Core/Base/BaseListScreenlet/BaseListPageLoadInteractor.swift}{Liferay
Screens's \texttt{BaseListPageLoadInteractor} class}. This class
provides most of the functionality required by list Screenlet
Interactors. Your Interactor class must also contain any properties your
Screenlet needs and an initializer that sets them. This initializer
needs arguments for the following properties, which it passes to the
superclass initializer:

\begin{itemize}
\tightlist
\item
  \texttt{screenlet}: A \texttt{BaseListScreenlet} reference. This
  ensures the Interactor always has a Screenlet reference.
\item
  \texttt{page}: The page number to retrieve.
\item
  \texttt{computeRowCount}: Whether to call the Connector's
  \texttt{doAddRowCountServiceCall} method.
\end{itemize}

Follow these steps to create Guestbook List Screenlet's Interactor:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In the Project navigator, right-click the \texttt{Interactor} folder
  and select \emph{New File}. In the dialog that appears, fill out each
  screen as follows:

  \begin{itemize}
  \tightlist
  \item
    Select \emph{iOS} → \emph{Source} → \emph{Cocoa Touch Class}, and
    click \emph{Next}.
  \item
    Name the class \texttt{GuestbookListPageLoadInteractor}, set it to
    extend \texttt{BaseListPageLoadInteractor}, select \emph{Swift} for
    the language, and click \emph{Next}.
  \item
    Make sure the \texttt{Interactor} folder and group is selected, as
    well as the \emph{Liferay Guestbook} target (these should be
    selected by default). Click \emph{Create}.
  \end{itemize}
\item
  In the new class, import \texttt{LiferayScreens} and add a private
  \texttt{Int64} constant called \texttt{groupId}. This constant holds
  the ID of the site guestbooks are retrieved from. Your Interactor
  should now look like this:

\begin{verbatim}
import UIKit
import LiferayScreens

class GuestbookListPageLoadInteractor: BaseListPageLoadInteractor {

    private let groupId: Int64

}
\end{verbatim}
\item
  Create an initializer that takes the arguments \texttt{screenlet},
  \texttt{page}, \texttt{computeRowCount}, and \texttt{groupId}. In this
  initializer, set the \texttt{groupId} constant to the corresponding
  argument, then call the superclass initializer with the remaining
  arguments. Note that if the the \texttt{groupId} is \texttt{0}, the
  \texttt{groupId} setting in \texttt{liferay-server-context.plist} is
  used instead. Add the initializer as follows:

\begin{verbatim}
init(screenlet: BaseListScreenlet,
    page: Int,
    computeRowCount: Bool,
    groupId: Int64) {

    self.groupId = (groupId != 0) ? groupId : LiferayServerContext.groupId

    super.init(screenlet: screenlet, page: page, computeRowCount: computeRowCount)
}
\end{verbatim}
\item
  Override the \texttt{createListPageConnector} method to create and
  return an instance of your Connector,
  \texttt{GuestbookListPageLiferayConnector}. This method must first get
  a reference to the Screenlet via the \texttt{screenlet} property. When
  calling the Connector's initializer, use
  \texttt{screenlet.firstRowForPage} to convert the page number
  (\texttt{page}) to the page's start and end indices. You must also
  pass the initializer any other properties it needs, like
  \texttt{groupId}. Add this \texttt{createListPageConnector} method to
  your Interactor class:

\begin{verbatim}
public override func createListPageConnector() -> PaginationLiferayConnector {
    let screenlet = self.screenlet as! BaseListScreenlet

    return GuestbookListPageLiferayConnector(
        startRow: screenlet.firstRowForPage(self.page),
        endRow: screenlet.firstRowForPage(self.page + 1),
        computeRowCount: self.computeRowCount,
        groupId: groupId)
}
\end{verbatim}
\item
  Override the \texttt{convertResult} method to convert each
  \texttt{{[}String:AnyObject{]}} result into a \texttt{GuestbookModel}
  object. The Screenlet calls this method once for each guestbook
  retrieved from the server. Add this method as follows:

\begin{verbatim}
override public func convertResult(_ serverResult: [String:AnyObject]) -> AnyObject {

    return GuestbookModel(attributes: serverResult)
}
\end{verbatim}
\item
  Override the \texttt{cacheKey} method to return a key that can be used
  with
  \href{/docs/7-0/tutorials/-/knowledge_base/t/architecture-of-offline-mode-in-liferay-screens}{offline
  mode}. Although Guestbook List Screenlet won't initially support
  offline mode, this method is still required. For this Screenlet, the
  \texttt{groupId} serves as a sufficient key. Add this method as
  follows:

\begin{verbatim}
override public func cacheKey(_ op: PaginationLiferayConnector) -> String {
    return "\(groupId)"
}
\end{verbatim}
\end{enumerate}

Great! Your Interactor is finished. Next, you'll create the delegate.

\section{Creating Guestbook List Screenlet's
Delegate}\label{creating-guestbook-list-screenlets-delegate}

A delegate is a Screenlet component that lets other classes to respond
to a Screenlet's actions. For example,
\href{/docs/7-0/reference/-/knowledge_base/r/loginscreenlet-for-ios\#delegate}{Login
Screenlet's delegate} lets the app developer implement methods that
respond to login success or failure. Note that the
\href{/docs/7-0/reference/-/knowledge_base/r/screenlets-in-liferay-screens-for-ios}{reference
documentation} for each Screenlet that comes with Liferay Screens lists
the Screenlet's delegate methods.

You can also create a delegate for your own Screenlet. Guestbook List
Screenlet should have a delegate protocol that defines the following
methods:

\begin{itemize}
\tightlist
\item
  \texttt{screenlet(\_:onGuestbookListResponse:)}: Receives the
  \texttt{GuestbookModel} results when the server call succeeds. This
  lets app developers respond to a successful server call.
\item
  \texttt{screenlet(\_:onGuestbookListError:)}: Receives the
  \texttt{NSError} object when the server call fails. This lets app
  developers respond to a failed server call.
\item
  \texttt{screenlet(\_:onGuestbookSelected:)}: Receives the
  \texttt{GuestbookModel} when a user selects it in the list. This lets
  app developers respond to a guestbook selection by the user.
\end{itemize}

You'll create this delegate in the same file as the Screenlet class.
Later, you'll finish creating the Screenlet class itself.

Follow these steps to create Guestbook List Screenlet's delegate:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In the Project navigator, right-click the
  \texttt{GuestbookListScreenlet} folder and select \emph{New File}. In
  the dialog that appears, fill out each screen as follows:

  \begin{itemize}
  \tightlist
  \item
    Select \emph{iOS} → \emph{Source} → \emph{Cocoa Touch Class}, and
    click \emph{Next}.
  \item
    Name the class \texttt{GuestbookListScreenlet}, set it to extend
    \texttt{BaseListScreenlet}, select \emph{Swift} for the language,
    and click \emph{Next}.
  \item
    Make sure the \texttt{GuestbookListScreenlet} folder and group is
    selected, as well as the \emph{Liferay Guestbook} target (these
    should be selected by default). Click \emph{Create}.
  \end{itemize}
\item
  In the new \texttt{GuestbookListScreenlet} class, import
  \texttt{LiferayScreens}, make the class \texttt{public}, and delete
  any placeholder comments in the class body.
\item
  In between the \texttt{import} statements and the class declaration,
  add the following code:

\begin{verbatim}
@objc public protocol GuestbookListScreenletDelegate : BaseScreenletDelegate {

    @objc optional func screenlet(screenlet: GuestbookListScreenlet,
                            onGuestbookListResponse guestbooks: [GuestbookModel])

    @objc optional func screenlet(screenlet: GuestbookListScreenlet,
                            onGuestbookListError error: NSError)

    @objc optional func screenlet(screenlet: GuestbookListScreenlet,
                            onGuestbookSelected guestbook: GuestbookModel)

}
\end{verbatim}

  This defines the \texttt{GuestbookListScreenletDelegate} protocol,
  which extends
  \href{https://github.com/liferay/liferay-screens/blob/master/ios/Framework/Core/Base/BaseScreenlet.swift}{the
  \texttt{BaseScreenletDelegate} protocol}. Delegates for custom
  Screenlets, like Guestbook List Screenlet, must extend
  \texttt{BaseScreenletDelegate}. The rest of
  \texttt{GuestbookListScreenletDelegate} defines the delegate methods
  you'll use later to respond to the Screenlet's events.
\end{enumerate}

The contents of \texttt{GuestbookListScreenlet.swift} should now look
like this:

\begin{verbatim}
import UIKit
import LiferayScreens

@objc public protocol GuestbookListScreenletDelegate : BaseScreenletDelegate {

    @objc optional func screenlet(screenlet: GuestbookListScreenlet,
                              onGuestbookListResponse guestbooks: [GuestbookModel])

    @objc optional func screenlet(screenlet: GuestbookListScreenlet,
                              onGuestbookListError error: NSError)

    @objc optional func screenlet(screenlet: GuestbookListScreenlet,
                              onGuestbookSelected guestbook: GuestbookModel)

}

public class GuestbookListScreenlet: BaseListScreenlet {

}
\end{verbatim}

Nice work! Now you're ready to complete the Screenlet class.

\section{Creating the Screenlet
Class}\label{creating-the-screenlet-class-1}

The Screenlet class is the main component that governs the Screenlet's
behavior. When using a Screenlet, app developers primarily interact with
its Screenlet class. A list Screenlet's Screenlet class must extend
\href{https://github.com/liferay/liferay-screens/blob/master/ios/Framework/Core/Base/BaseListScreenlet/BaseListScreenlet.swift}{the
\texttt{BaseListScreenlet} class}. Since \texttt{BaseListScreenlet}
provides most of the functionality needed by Screenlet classes,
extending it lets you focus on the functionality unique to your
Screenlet. The Screenlet class must also define the configurable
\texttt{IBInspectable} properties the Screenlet needs, create and return
an instance of your Interactor, and respond to the Screenlet's events
via the delegate.

The Screenlet class you created while creating the delegate is currently
empty. You'll complete it now.

Follow these steps to complete the \texttt{GuestbookListScreenlet} class
in \texttt{GuestbookListScreenlet.swift}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Define a public, \texttt{IBInspectable}, \texttt{Int64} property for
  the \texttt{groupId}. Although the app developer can set this value
  via \texttt{liferay-server-context.plist}, it's also a good idea to
  let them set it in Interface Builder when using the Screenlet. Give
  this property an initial value of \texttt{0}. Your Screenlet class
  should now look like this:

\begin{verbatim}
public class GuestbookListScreenlet: BaseListScreenlet {

    @IBInspectable public var groupId: Int64 = 0

}
\end{verbatim}
\item
  Override the \texttt{createPageLoadInteractor} method to create and
  return an instance of your Interactor,
  \texttt{GuestbookListPageLoadInteractor}. This method includes
  \texttt{page} and \texttt{computeRowCount} arguments, which you can
  pass to the Interactor's constructor along with \texttt{groupId}:

\begin{verbatim}
override public func createPageLoadInteractor(
    page: Int,
    computeRowCount: Bool) -> BaseListPageLoadInteractor {

    return GuestbookListPageLoadInteractor(screenlet: self,
                                                 page: page,
                                                 computeRowCount: computeRowCount,
                                                 groupId: self.groupId)
}
\end{verbatim}
\item
  Create a computed property to get a reference to your delegate,
  \texttt{GuestbookListScreenletDelegate}:

\begin{verbatim}
public var guestbookListDelegate: GuestbookListScreenletDelegate? {
    return delegate as? GuestbookListScreenletDelegate
}
\end{verbatim}

  You'll use this property to handle the Screenlet's events via the
  delegate's methods.
\item
  Override the \texttt{BaseListScreenlet} methods that handle the
  Screenlet's events. Because these methods correspond to your delegate
  methods, you'll call your delegate methods in them:

  \begin{itemize}
  \item
    \texttt{onLoadPageResult}: Called when the Screenlet loads a page
    successfully. Override this method to call the superclass's
    \texttt{onLoadPageResult} method, then call your delegate's
    \texttt{screenlet(\_:onGuestbookListResponse:)} method:

\begin{verbatim}
  override public func onLoadPageResult(page: Int, rows: [AnyObject], rowCount: Int) {
      super.onLoadPageResult(page: page, rows: rows, rowCount: rowCount)

      guestbookListDelegate?.screenlet?(screenlet: self, 
          onGuestbookListResponse: rows as! [GuestbookModel])
  }
\end{verbatim}
  \item
    \texttt{onLoadPageError}: Called when the Screenlet fails to load a
    page. Override this method to call the superclass's
    \texttt{onLoadPageError} method, then call your delegate's
    \texttt{screenlet(\_:onGuestbookListError:)} method:

\begin{verbatim}
  override public func onLoadPageError(page: Int, error: NSError) {
      super.onLoadPageError(page: page, error: error)

      guestbookListDelegate?.screenlet?(screenlet: self, 
          onGuestbookListError: error)
  }
\end{verbatim}
  \item
    \texttt{onSelectedRow}: Called when an item is selected in the list.
    Override this method to call your delegate's
    \texttt{screenlet(\_:onGuestbookSelected:)} method:

\begin{verbatim}
  override public func onSelectedRow(_ row: AnyObject) {
      guestbookListDelegate?.screenlet?(screenlet: self, 
          onGuestbookSelected: row as! GuestbookModel)
  }
\end{verbatim}
  \end{itemize}
\end{enumerate}

Awesome! Your Screenlet class is finished. You're also done with
Guestbook List Screenlet! The next section in this Learning Path shows
you how to create Entry List Screenlet to display a guestbook's entries.

\chapter{Creating Entry List
Screenlet}\label{creating-entry-list-screenlet-1}

In the previous section, you created Guestbook List Screenlet to
retrieve and display guestbooks from the Guestbook portlet. You still
need a way to retrieve and display each guestbook's entries, though.
You'll do this by creating another list Screenlet: Entry List Screenlet.
This section walks you through the steps required to create it.

Because you use a consistent development model to create Screenlets,
similar Screenlets have similar code. As with guestbooks, it makes sense
to display entries in a list using a list Screenlet. This means you can
reuse most of Guestbook List Screenlet's code in Entry List Screenlet.
You'll therefore create Entry List Screenlet using the same sequence of
steps you used to create Guestbook List Screenlet:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Getting started: create the Screenlet's folder, and the model class.
  This model class creates objects that represent entries retrieved from
  the portlet, making it easier to work with entries in the app.
\item
  Create the Screenlet's UI (its Theme).
\item
  Create the Connector. Connectors are Screenlet components that make
  server calls.
\item
  Create the Interactor. In list Screenlets, Interactors are Screenlet
  components that instantiate Connectors and receive their results.
\item
  Create the delegate. Delegates let other classes respond to the
  Screenlet's events.
\item
  Create the Screenlet class. The Screenlet class governs the
  Screenlet's behavior.
\end{enumerate}

Although this Learning Path section presents complete code snippets, it
only discusses the code unique to Entry List Screenlet. Refer back to
the previous section for detailed explanations of the code shared with
Guestbook List Screenlet.

If you get confused or stuck while creating Guestbook List Screenlet,
refer to the finished app that contains the Screenlet code
\href{https://github.com/liferay/liferay-docs/tree/7.0.x/develop/tutorials/code/mobile/ios/screenlets-app/Liferay\%20Guestbook}{here
in GitHub}.

\section{Getting Started with Entry List
Screenlet}\label{getting-started-with-entry-list-screenlet-1}

Like Guestbook List Screenlet, you'll create Entry List Screenlet in its
own folder inside your app's project. Create this folder now:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In the Finder, create the \texttt{EntryListScreenlet} folder inside
  your root project folder (on the same level as the
  \texttt{GuestbookListScreenlet} folder).
\item
  Drag and drop the \texttt{EntryListScreenlet} folder from the Finder
  into your Xcode project, under the root project (on the same level as
  the \texttt{GuestbookListScreenlet} folder). In the dialog that
  appears, select \emph{Copy items if needed}, \emph{Create groups}, and
  the \emph{Liferay Guestbook} target. Then click \emph{Finish}. The
  \texttt{EntryListScreenlet} folder now appears in your project.

  \begin{figure}
  \centering
  \includegraphics{./images/ios-lp-entry-proj-nav.png}
  \caption{After adding the \texttt{EntryListScreenlet} folder, your
  project should look something like this.}
  \end{figure}
\end{enumerate}

Now you're ready to begin!

\subsection{Creating the Model Class}\label{creating-the-model-class-1}

Recall that you need a model class to represent entities retrieved from
Liferay DXP. The model class you'll create for guestbook entries,
\texttt{EntryModel}, creates \texttt{EntryModel} objects that represent
guestbook entries retrieved from the Guestbook portlet.

Create the following \texttt{EntryModel} class alongside the
\texttt{GuestbookModel} class in the \texttt{model} folder:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In the Project navigator, right-click the \texttt{model} folder and
  select \emph{New File}. In the dialog that appears, fill out each
  screen as follows:

  \begin{itemize}
  \tightlist
  \item
    Select \emph{iOS} → \emph{Source} → \emph{Cocoa Touch Class}, and
    click \emph{Next}.
  \item
    Name the class \texttt{EntryModel}, set it to extend
    \texttt{NSObject}, select \emph{Swift} for the language, and click
    \emph{Next}.
  \item
    Make sure the \texttt{model} folder and group is selected, as well
    as the \emph{Liferay Guestbook} target (these should be selected by
    default). Click \emph{Create}.
  \end{itemize}

  The new class now opens in the editor.
\item
  Replace the class file's contents with this code:

\begin{verbatim}
import UIKit

@objc public class EntryModel: NSObject {

    public let attributes: [String:AnyObject]

    public var entryId: Int64 {
        return attributes["entryId"]?.int64Value ?? 0
    }

    public var groupId: Int64 {
        return attributes["groupId"]?.int64Value ?? 0
    }

    public var companyId: Int64 {
        return attributes["companyId"]?.int64Value ?? 0
    }

    public var userId: Int64 {
        return attributes["userId"]?.int64Value ?? 0
    }

    public var userName: String {
        return attributes["userName"] as? String ?? ""
    }

    public var createDate: Int64 {
        return attributes["createDate"]?.int64Value ?? 0
    }

    public var modifiedDate: Int64 {
        return attributes["modifiedDate"]?.int64Value ?? 0
    }

    public var name: String {
        return attributes["name"] as? String ?? ""
    }

    public var email: String {
        return attributes["email"] as? String ?? ""
    }

    public var message: String {
        return attributes["message"] as? String ?? ""
    }

    public var guestbookId: Int64 {
        return attributes["guestbookId"]?.int64Value ?? 0
    }

    //MARK: Initializer

    public init(attributes: [String:AnyObject]) {
        self.attributes = attributes
    }

}
\end{verbatim}
\end{enumerate}

Besides working with entries instead of guestbooks, this class is almost
identical to \texttt{GuestbookModel}. For an explanation of the code,
see
\href{/docs/7-0/tutorials/-/knowledge_base/t/getting-started-with-guestbook-list-screenlet-ios}{the
article on getting started with Guestbook List Screenlet}.

Next, you'll create the Screenlet's UI.

\section{Creating Entry List Screenlet's
UI}\label{creating-entry-list-screenlets-ui-1}

Recall that in Liferay Screens for iOS, Screenlet UIs are called
\emph{Themes}, and every Screenlet must have at least one Theme. You'll
create Entry List Screenlet's Theme with the same steps you used to
create Guestbook List Screenlet's Theme:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Create your Theme's folder and add it to your Xcode project.
\item
  Create an XIB file and use it to construct the UI.
\item
  Create your Theme's View class and set it as the XIB file's custom
  class.
\end{enumerate}

\subsection{Creating Your Theme's
Folder}\label{creating-your-themes-folder-1}

Like Guestbook List Screenlet's Theme, you'll create Entry List
Screenlet's Theme in a \texttt{Themes/Default} folder. Follow these
steps to create this folder structure in Entry List Screenlet's folder:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In the Finder, create the \texttt{Themes} folder inside your project's
  \texttt{EntryListScreenlet} folder. Then create the \texttt{Default}
  folder inside the new \texttt{Themes} folder.
\item
  Drag and drop the \texttt{Themes} folder from the Finder into your
  Xcode project, under the \texttt{EntryListScreenlet} folder. In the
  dialog that appears, select \emph{Copy items if needed}, \emph{Create
  groups}, and the \emph{Liferay Guestbook} target (these should be
  selected by default). Then click \emph{Finish}. The
  \texttt{Themes/Default} folder structure now appears in your project.

  \begin{figure}
  \centering
  \includegraphics{./images/ios-lp-themes-proj-nav-02.png}
  \caption{After adding the \texttt{Themes} folder to Entry List
  Screenlet, the \texttt{Themes/Default} folder structure should look
  like this in the Project navigator.}
  \end{figure}
\end{enumerate}

Now you're ready to start creating your Theme. First, you'll create its
XIB file.

\subsection{Creating the XIB File}\label{creating-the-xib-file-1}

A Theme requires an XIB file to define the UI's components and layout.
Use these steps to create your Theme's XIB file:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In the Project navigator, right-click the \texttt{Default} folder you
  added above and select \emph{New File}. In the dialog that appears,
  select \emph{iOS} → \emph{User Interface} → \emph{Empty}, and click
  \emph{Next}. Name the file \texttt{EntryListView\_default.xib}, and
  ensure that \emph{Default} is selected for the save location and
  group. The \emph{Liferay Guestbook} target should also be selected.
  Click \emph{Create}. The file then opens in Interface Builder.
\item
  In Interface Builder, drag and drop a View from the Object Library
  onto the canvas. Then add a Table View to the View. Set the Table View
  to take up the entire View.
\item
  With the Table View selected, open the \emph{Add New Constraints} menu
  at the bottom-right of the canvas. In this menu, set \emph{Spacing to
  nearest neighbor} to 0 on all sides, select \emph{Constrain to
  margins}, and then click the \emph{Add 4 Constraints} button.

  \begin{figure}
  \centering
  \includegraphics{./images/ios-lp-xib-constraints.png}
  \caption{Add these constraints to the Table View in the XIB.}
  \end{figure}
\end{enumerate}

Your Theme's XIB is now finished. Next, you'll create your View class.

\subsection{Creating the Theme's View
Class}\label{creating-the-themes-view-class-1}

Every Theme needs a View class that controls its behavior. Recall that a
list Screenlet's View class gets most of its functionality by extending
\href{https://github.com/liferay/liferay-screens/blob/master/ios/Framework/Core/Base/BaseListScreenlet/TableView/BaseListTableView.swift}{the
\texttt{BaseListTableView} class}. This lets you focus on the parts of
your View class that are unique to your Screenlet.

Follow these steps to create your Screenlet's View class:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In the Project navigator, right-click Entry List Screenlet's
  \texttt{Default} folder and select \emph{New File}. In the dialog that
  appears, fill out each screen as follows:

  \begin{itemize}
  \tightlist
  \item
    Select \emph{iOS} → \emph{Source} → \emph{Cocoa Touch Class}, and
    click \emph{Next}.
  \item
    Name the class \texttt{EntryListView\_default}, set it to extend
    \texttt{BaseListTableView}, select \emph{Swift} for the language,
    and click \emph{Next}.
  \item
    Make sure the \texttt{Default} folder and group is selected, as well
    as the \emph{Liferay Guestbook} target (these should be selected by
    default). Click \emph{Create}.
  \end{itemize}
\item
  Replace the class file's contents with this code:

\begin{verbatim}
import UIKit
import LiferayScreens

class EntryListView_default: BaseListTableView {

    override public func doFillLoadedCell(row: Int, cell: UITableViewCell, object: AnyObject) {
        let entry = object as! EntryModel

        cell.textLabel?.text = entry.message
        cell.detailTextLabel?.text = entry.name
    }

    override open func doCreateCell(_ cellId: String) -> UITableViewCell {
        return UITableViewCell(style: .subtitle, reuseIdentifier: cellId)
    }

    override public func doFillInProgressCell(row: Int, cell: UITableViewCell) {
        cell.textLabel?.text = "Loading..."
    }

}
\end{verbatim}

  Note that this class is almost identical to Guestbook List Screenlet's
  View class, \texttt{GuestbookListView\_default}. The only difference
  is that \texttt{EntryListView\_default} handles entries
  (\texttt{EntryModel}) instead of guestbooks (\texttt{GuestbookModel}).
  The \texttt{doFillLoadedCell} method sets the cell's main text label
  to the entry's message, and sets the cell's secondary text label to
  the name of the person who left the message. This way, a single cell
  displays both pieces of information. For a description of the code
  shared with \texttt{GuestbookListView\_default}, see
  \href{/docs/7-0/tutorials/-/knowledge_base/t/creating-guestbook-list-screenlets-ui-ios}{the
  article on creating Guestbook List Screenlet's Theme}.
\item
  Return to the Theme's XIB in Interface Builder and set
  \texttt{EntryListView\_default} as the the parent View's custom class.
  To do this, select the Table View's parent View, click the Identity
  inspector, and enter \texttt{EntryListView\_default} as the custom
  class.

  \begin{figure}
  \centering
  \includegraphics{./images/ios-lp-entry-theme-custom-class.png}
  \caption{In the XIB file, set the custom class of the Table View's
  parent View to \texttt{EntryListView\_default}.}
  \end{figure}
\item
  With the Theme's XIB still open in Interface Builder, set the parent
  View's \texttt{tableView} outlet to the Table View. To do this, select
  the parent View and click the Connections inspector. In the
  \emph{Outlets} section, drag and drop from the \texttt{tableView}'s
  circle icon (on mouseover, it turns into a plus icon) to the Table
  View in the XIB. The new outlet then appears in the Connections
  inspector.

  \begin{figure}
  \centering
  \includegraphics{./images/ios-lp-table-view-outlet-01.png}
  \caption{Drag and drop from the \texttt{tableView} outlet to the Table
  View in the XIB.}
  \end{figure}

  \begin{figure}
  \centering
  \includegraphics{./images/ios-lp-table-view-outlet-02.png}
  \caption{After creating the connection, the outlet looks like this in
  the Connections inspector.}
  \end{figure}
\end{enumerate}

Great! Your Theme is finished. Next, you'll create Entry List
Screenlet's Connector.

\section{Creating Entry List Screenlet's
Connector}\label{creating-entry-list-screenlets-connector}

Recall that Connectors are Screenlet components that make server calls.
Also recall that by making your server calls in Connectors instead of
Interactors, you gain an additional layer of abstraction.

In this article, you'll create Entry List Screenlet's Connector. Because
this Connector is so similar to that of Guestbook List Screenlet, the
steps to create it aren't explained in detail. Focus is instead placed
on the few places in the code where the Connectors diverge. For a full
explanation of the code, see
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-guestbook-list-screenlets-connector}{the
article on creating Guestbook List Screenlet's Connector}.

\subsection{Creating Your Connector's
Folder}\label{creating-your-connectors-folder-1}

Follow these steps to create your Connector's folder:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In the Finder, create the \texttt{Connector} folder inside your
  project's \texttt{EntryListScreenlet} folder.
\item
  Drag and drop the \texttt{Connector} folder from the Finder into your
  Xcode project, under the \texttt{EntryListScreenlet} folder. In the
  dialog that appears, select \emph{Copy items if needed}, \emph{Create
  groups}, and the \emph{Liferay Guestbook} target. Then click
  \emph{Finish}. The \texttt{Connector} folder now appears in your
  project.
\end{enumerate}

Now you're ready to create the Connector.

\subsection{Creating the Connector}\label{creating-the-connector-1}

Recall that list Screenlet Connectors must extend
\href{https://github.com/liferay/liferay-screens/blob/master/ios/Framework/Core/Base/BaseListScreenlet/PaginationLiferayConnector.swift}{the
\texttt{PaginationLiferayConnector} class}. Your list Screenlet's
Connector class must also contain any properties it needs to make the
server call, and an initializer that sets them. To support pagination,
the initializer must also contain the following arguments, which you'll
pass to the superclass initializer:

\begin{itemize}
\tightlist
\item
  \texttt{startRow}: The number representing the page's first row.
\item
  \texttt{endRow}: The number representing the page's last row.
\item
  \texttt{computeRowCount}: Whether to call the Connector's
  \texttt{doAddRowCountServiceCall} method.
\end{itemize}

Follow these steps to create Guestbook List Screenlet's Connector:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In the Project navigator, right-click the \texttt{Connector} folder
  you added above and select \emph{New File}. In the dialog that
  appears, fill out each screen as follows:

  \begin{itemize}
  \tightlist
  \item
    Select \emph{iOS} → \emph{Source} → \emph{Cocoa Touch Class}, and
    click \emph{Next}.
  \item
    Name the class \texttt{EntryListPageLiferayConnector}, set it to
    extend \texttt{PaginationLiferayConnector}, select \emph{Swift} for
    the language, and click \emph{Next}.
  \item
    Make sure the \texttt{Connector} folder and group is selected, as
    well as the \emph{Liferay Guestbook} target (these should be
    selected by default). Click \emph{Create}.
  \end{itemize}
\item
  Replace the class file's contents with this code:

\begin{verbatim}
import UIKit
import LiferayScreens

class EntryListPageLiferayConnector: PaginationLiferayConnector {

    public let groupId: Int64
    public let guestbookId: Int64

    //MARK: Initializer

    public init(startRow: Int, endRow: Int, computeRowCount: Bool, groupId: Int64, 
        guestbookId: Int64) {

            self.groupId = groupId
            self.guestbookId = guestbookId

            super.init(startRow: startRow, endRow: endRow, computeRowCount: computeRowCount)
    }

    //MARK: PaginationLiferayConnector

    public override func doAddPageRowsServiceCall(session: LRBatchSession, startRow: Int, endRow: Int, 
        obc: LRJSONObjectWrapper?) {

        let service = LREntryService_v7(session: session)

        do {
            try service!.getEntriesWithGroupId(groupId, guestbookId: guestbookId, 
                    start: Int32(startRow), end: Int32(endRow))
        }
        catch {
            // the service method returns nil because the request is sent later, in batch
        }

    }

    override public func doAddRowCountServiceCall(session: LRBatchSession) {
        let service = LREntryService_v7(session: session)

        do {
            try service!.getEntriesCount(withGroupId: groupId, guestbookId: guestbookId)
        }
        catch {
            // the service method returns nil because the request is sent later, in batch
        }
    }

}
\end{verbatim}

  This class is almost identical to Guestbook List Screenlet's Connector
  class, \texttt{GuestbookListPageLiferayConnector}. The only
  differences are due to the service calls. To define the guestbook to
  retrieve entries from, \texttt{EntryListPageLiferayConnector} needs a
  \texttt{guestbookId} property. It then uses this property with the
  service methods \texttt{getEntriesWithGroupId} and
  \texttt{getEntriesCount} to retrieve the entries and number of
  entries, respectively. Also note that the service is an
  \texttt{LREntryService\_v7} instance.
\end{enumerate}

Nicely done! Now that Entry List Screenlet has a Connector, you must
create its Interactor. The next article shows you how to do this.

\section{Creating Entry List Screenlet's
Interactor}\label{creating-entry-list-screenlets-interactor-1}

Recall that list Screenlets require an Interactor to instantiate the
Connector and receive the server call's results. In this article, you'll
create Entry List Screenlet's Interactor.

Because this Interactor is so similar to that of Guestbook List
Screenlet, the steps to create it aren't explained in detail. Focus is
instead placed on the few places in the code where the Interactors
diverge. For a full explanation of the code, see
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-guestbook-list-screenlets-interactor-ios}{the
article on creating Guestbook List Screenlet's Interactor}.

\subsection{Creating Your Interactor's
Folder}\label{creating-your-interactors-folder-1}

Follow these steps to create your Interactor's folder:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In the Finder, create the \texttt{Interactor} folder inside your
  project's \texttt{EntryListScreenlet} folder.
\item
  Drag and drop the \texttt{Interactor} folder from the Finder into your
  Xcode project, under the \texttt{EntryListScreenlet} folder. In the
  dialog that appears, select \emph{Copy items if needed}, \emph{Create
  groups}, and the \emph{Liferay Guestbook} target. Then click
  \emph{Finish}. The \texttt{Interactor} folder now appears in your
  project.
\end{enumerate}

Now you're ready to create the Interactor.

\subsection{Creating the Interactor}\label{creating-the-interactor-1}

Recall that the Interactor class of a list Screenlet that implements
fluent pagination must extend
\href{https://github.com/liferay/liferay-screens/blob/master/ios/Framework/Core/Base/BaseListScreenlet/BaseListPageLoadInteractor.swift}{the
\texttt{BaseListPageLoadInteractor} class}. Your Interactor class must
also contain any properties the Screenlet needs, and an initializer that
sets them. This initializer also needs arguments for the following
properties, which it passes to the superclass initializer:

\begin{itemize}
\tightlist
\item
  \texttt{screenlet}: A \texttt{BaseListScreenlet} reference. This
  ensures the Interactor always has a Screenlet reference.
\item
  \texttt{page}: The page number to retrieve.
\item
  \texttt{computeRowCount}: Whether to call the Connector's
  \texttt{doAddRowCountServiceCall} method.
\end{itemize}

Follow these steps to create Entry List Screenlet's Interactor:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In the Project navigator, right-click the \texttt{Interactor} folder
  you added above and select \emph{New File}. In the dialog that
  appears, fill out each screen as follows:

  \begin{itemize}
  \tightlist
  \item
    Select \emph{iOS} → \emph{Source} → \emph{Cocoa Touch Class}, and
    click \emph{Next}.
  \item
    Name the class \texttt{EntryListPageLoadInteractor}, set it to
    extend \texttt{BaseListPageLoadInteractor}, select \emph{Swift} for
    the language, and click \emph{Next}.
  \item
    Make sure the \texttt{Interactor} folder and group is selected, as
    well as the \emph{Liferay Guestbook} target (these should be
    selected by default). Click \emph{Create}.
  \end{itemize}
\item
  Replace the class file's contents with this code:

\begin{verbatim}
import UIKit
import LiferayScreens

class EntryListPageLoadInteractor: BaseListPageLoadInteractor {

    private let groupId: Int64
    private let guestbookId: Int64

    init(screenlet: BaseListScreenlet,
         page: Int,
         computeRowCount: Bool,
         groupId: Int64,
         guestbookId: Int64) {

        self.groupId = (groupId != 0) ? groupId : LiferayServerContext.groupId
        self.guestbookId = guestbookId

        super.init(screenlet: screenlet, page: page, computeRowCount: computeRowCount)
    }

    public override func createListPageConnector() -> PaginationLiferayConnector {
        let screenlet = self.screenlet as! BaseListScreenlet

        return EntryListPageLiferayConnector(
            startRow: screenlet.firstRowForPage(self.page),
            endRow: screenlet.firstRowForPage(self.page + 1),
            computeRowCount: self.computeRowCount,
            groupId: groupId,
            guestbookId: guestbookId)
    }

    override public func convertResult(_ serverResult: [String:AnyObject]) -> AnyObject {

        return EntryModel(attributes: serverResult)
    }

    override public func cacheKey(_ op: PaginationLiferayConnector) -> String {
        return "\(groupId)-\(guestbookId)"
    }

}
\end{verbatim}

  This class is almost identical to Guestbook List Screenlet's
  Interactor, \texttt{GuestbookListPageLoadInteractor}. The only real
  difference is that \texttt{EntryListPageLoadInteractor} handles
  entries. It therefore needs a \texttt{guestbookId} variable to define
  the guestbook to retrieve entries from. This variable is set in the
  initializer and then used in the \texttt{createListPageConnector}
  method to create a \texttt{EntryListPageLiferayConnector} instance.
  The \texttt{convertResult} method receives each
  \texttt{{[}String:AnyObject{]}} entry from the server and transforms
  it into an \texttt{EntryModel} object. Also recall that the
  \texttt{cacheKey} method must return a key that can be used with
  online mode. For entries, a combination of the \texttt{groupId} and
  \texttt{guestbookId} is a sufficient key.
\end{enumerate}

Great! Your Interactor is finished. Next, you'll create the delegate.

\section{Creating Entry List Screenlet's
Delegate}\label{creating-entry-list-screenlets-delegate}

Recall that a delegate lets other classes respond to your Screenlet's
actions. Like you did for Guestbook List Screenlet, you'll create a
delegate for Entry List Screenlet that can respond to a successful
server call, a failed server call, and an item selection in the list.
This delegate must therefore define these methods:

\begin{itemize}
\tightlist
\item
  \texttt{screenlet(\_:onEntryListResponse:)}: Receives the
  \texttt{EntryModel} results when the server call succeeds. This lets
  app developers respond to a successful server call.
\item
  \texttt{screenlet(\_:onEntryListError:)}: Receives the
  \texttt{NSError} object when the server call fails. This lets app
  developers respond to a failed server call.
\item
  \texttt{screenlet(\_:onEntrySelected:)}: Receives the
  \texttt{EntryModel} when a user selects it in the list. This lets app
  developers respond to an entry selection by the user.
\end{itemize}

You'll create this delegate in the same file as the Screenlet class.
Later, you'll finish creating the Screenlet class itself.

Follow these steps to create Entry List Screenlet's delegate:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In the Project navigator, right-click the \texttt{EntryListScreenlet}
  folder and select \emph{New File}. In the dialog that appears, fill
  out each screen as follows:

  \begin{itemize}
  \tightlist
  \item
    Select \emph{iOS} → \emph{Source} → \emph{Cocoa Touch Class}, and
    click \emph{Next}.
  \item
    Name the class \texttt{EntryListScreenlet}, set it to extend
    \texttt{BaseListScreenlet}, select \emph{Swift} for the language,
    and click \emph{Next}.
  \item
    Make sure the \texttt{EntryListScreenlet} folder and group is
    selected, as well as the \emph{Liferay Guestbook} target (these
    should be selected by default). Click \emph{Create}.
  \end{itemize}
\item
  In the new \texttt{EntryListScreenlet} class, import
  \texttt{LiferayScreens}, make the class \texttt{public}, and delete
  any placeholder comments in the class body.
\item
  In between the \texttt{import} statements and the class declaration,
  add the following code:

\begin{verbatim}
@objc public protocol EntryListScreenletDelegate : BaseScreenletDelegate {

    @objc optional func screenlet(screenlet: EntryListScreenlet,
                          onEntryListResponse entries: [EntryModel])

    @objc optional func screenlet(screenlet: EntryListScreenlet,
                          onEntryListError error: NSError)

    @objc optional func screenlet(screenlet: EntryListScreenlet,
                          onEntrySelected entry: EntryModel)

}
\end{verbatim}

  This delegate is almost identical to that of Guestbook List Screenlet,
  \texttt{GuestbookListScreenletDelegate}. The only difference is that
  \texttt{EntryListScreenletDelegate} works with entries instead of
  guestbooks.
\end{enumerate}

The contents of \texttt{EntryListScreenlet.swift} should now look like
this:

\begin{verbatim}
import UIKit
import LiferayScreens

@objc public protocol EntryListScreenletDelegate : BaseScreenletDelegate {

    @objc optional func screenlet(screenlet: EntryListScreenlet,
                              onEntryListResponse entries: [EntryModel])

    @objc optional func screenlet(screenlet: EntryListScreenlet,
                              onEntryListError error: NSError)

    @objc optional func screenlet(screenlet: EntryListScreenlet,
                              onEntrySelected entry: EntryModel)

}

public class EntryListScreenlet: BaseListScreenlet {

}
\end{verbatim}

Nice work! Now you're ready to complete the Screenlet class.

\section{Creating the Screenlet
Class}\label{creating-the-screenlet-class-2}

Recall that the Screenlet class is the main component that governs the
Screenlet's behavior. Also recall that a list Screenlet's class must do
the following:

\begin{itemize}
\tightlist
\item
  Extend \texttt{BaseListScreenlet}. Since \texttt{BaseListScreenlet}
  provides most of the functionality needed by Screenlet classes,
  extending it lets you focus on the functionality unique to your
  Screenlet.
\item
  Define the configurable \texttt{IBInspectable} properties the
  Screenlet needs.
\item
  Create and return an instance of your Interactor.
\item
  Respond to the Screenlet's events via the delegate.
\end{itemize}

The Screenlet class you created when you created the delegate is
currently empty. You'll complete it now.

Follow these steps to complete the \texttt{EntryListScreenlet} class in
\texttt{EntryListScreenlet.swift}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Define public, \texttt{IBInspectable}, \texttt{Int64} properties for
  the \texttt{groupId} and \texttt{guestbookId}. Although the app
  developer can set \texttt{groupId} via
  \texttt{liferay-server-context.plist}, and the \texttt{guestbookId} is
  set dynamically, it's also a good idea to let the developer set their
  values in Interface Builder. Give both properties an initial value of
  \texttt{0}. Your Screenlet class should now look like this:

\begin{verbatim}
public class EntryListScreenlet: BaseListScreenlet {

    @IBInspectable public var groupId: Int64 = 0
    @IBInspectable public var guestbookId: Int64 = 0
}
\end{verbatim}
\item
  Override the \texttt{createPageLoadInteractor} method to create and
  return an instance of \texttt{EntryListPageLoadInteractor}. This
  method includes \texttt{page} and \texttt{computeRowCount} arguments,
  which you pass to the Interactor's constructor along with
  \texttt{groupId} and \texttt{guestbookId}:

\begin{verbatim}
override public func createPageLoadInteractor(
    page: Int,
    computeRowCount: Bool) -> BaseListPageLoadInteractor {

    return EntryListPageLoadInteractor(screenlet: self,
                                             page: page,
                                             computeRowCount: computeRowCount,
                                             groupId: self.groupId,
                                             guestbookId: self.guestbookId)
}
\end{verbatim}
\item
  Create a computed property to get a reference to
  \texttt{EntryListScreenletDelegate}:

\begin{verbatim}
public var entryListDelegate: EntryListScreenletDelegate? {
    return delegate as? EntryListScreenletDelegate
}
\end{verbatim}

  You'll use this property to handle the Screenlet's events via the
  delegate's methods.
\item
  Override the \texttt{BaseListScreenlet} methods that handle the
  Screenlet's events. Because these events correspond to those handled
  by your delegate, you'll call the corresponding delegate methods in
  these \texttt{BaseListScreenlet} methods:

  \begin{itemize}
  \item
    \texttt{onLoadPageResult}: Called when the Screenlet loads a page
    successfully. Override this method to call the superclass's
    \texttt{onLoadPageResult} method, then call your delegate's
    \texttt{screenlet(\_:onEntryListResponse:)} method:

\begin{verbatim}
  override public func onLoadPageResult(page: Int, rows: [AnyObject], rowCount: Int) {
      super.onLoadPageResult(page: page, rows: rows, rowCount: rowCount)

      entryListDelegate?.screenlet?(screenlet: self, onEntryListResponse: rows as! [EntryModel])
  }
\end{verbatim}
  \item
    \texttt{onLoadPageError}: Called when the Screenlet fails to load a
    page. Override this method to call the superclass's
    \texttt{onLoadPageError} method, then call your delegate's
    \texttt{screenlet(\_:onEntryListError:)} method:

\begin{verbatim}
  override public func onLoadPageError(page: Int, error: NSError) {
      super.onLoadPageError(page: page, error: error)

      entryListDelegate?.screenlet?(screenlet: self, onEntryListError: error)
  }
\end{verbatim}
  \item
    \texttt{onSelectedRow}: Called when an item is selected in the list.
    Override this method to call your delegate's
    \texttt{screenlet(\_:onEntrySelected:)} method:

\begin{verbatim}
  override public func onSelectedRow(_ row: AnyObject) {
      entryListDelegate?.screenlet?(screenlet: self, onEntrySelected: row as! EntryModel)
  }
\end{verbatim}
  \end{itemize}
\end{enumerate}

Awesome! Your Screenlet class is finished. You're also done with Entry
List Screenlet! Now you're ready to use Entry List Screenlet alongside
Guestbook List Screenlet. The following section of this Learning Path
concludes with both Screenlets working together in harmony.

\chapter{Using Your Screenlets}\label{using-your-screenlets}

Now that you have the Guestbook List and Entry List Screenlets, you're
ready to put them to work. As you'll see, using these Screenlets isn't
much more difficult than using Login Screenlet. This is an advantage of
Screenlets; it typically takes only a few minutes to get them up and
running.

To add your Screenlets to the app, you'll follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Create the entries scene.
\item
  Add Guestbook List Screenlet to the guestbooks scene.
\item
  Add Entry List Screenlet to the entries scene.
\end{enumerate}

If you get confused or stuck at any point in this section of the
Learning Path, refer to the finished app that contains the Screenlet
code
\href{https://github.com/liferay/liferay-docs/tree/7.0.x/develop/tutorials/code/mobile/ios/screenlets-app/Liferay\%20Guestbook}{here
in GitHub}.

First, you'll create the entries scene.

\section{Creating the Entries Scene}\label{creating-the-entries-scene}

Currently, the login and guestbooks scenes are the only two scenes in
your app. The login scene contains Login Screenlet, and you'll put
Guestbook List Screenlet in the guestbooks scene. Before you can use
Entry List Screenlet, you must create a scene to put it in: the entries
scene.

In this article, you'll use these steps to create the entries scene:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Add a new view controller to your storyboard, and create a segue to it
  from the guestbooks scene.
\item
  Create the entries scene's view controller class.
\end{enumerate}

\subsection{Adding a View Controller to the
Storyboard}\label{adding-a-view-controller-to-the-storyboard-1}

Follow these steps to create a view controller for the entries scene:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open your storyboard and drag and drop a \emph{View Controller} from
  the Object Library to the right of the guestbooks scene.
\item
  With the new view controller selected in the storyboard, open the
  Attributes inspector and uncheck \emph{Adjust Scroll View Insets}.
  This ensures that the scene's contents are flush with the navigation
  bar.
\item
  Create a segue from the guestbooks scene's view controller to the new
  view controller. To do this, control-drag from the guestbooks scene's
  view controller to the new view controller. In the dialog that appears
  upon releasing your mouse button, select \emph{show} for the segue
  type. The segue now connects the two view controllers.
\item
  Click the new segue, and then enter the Attributes inspector. Enter
  \emph{entriessegue} in the \emph{Identifier} field, and press
  \emph{return}. Later, you'll use this identifier to perform the segue
  programmatically when a user selects a guestbook in Guestbook List
  Screenlet.
\end{enumerate}

\begin{figure}
\centering
\includegraphics{./images/ios-lp-entries-scene-01.png}
\caption{The entries scene now exists to the right of the guestbooks
scene, with a segue connecting the two scenes.}
\end{figure}

Great! The entries scene now exists, and there's a segue going to it
from the guestbooks scene. Next, you'll create the entries scene's view
controller class.

\subsection{Creating the Entries Scene's View Controller
Class}\label{creating-the-entries-scenes-view-controller-class}

Each view controller must have a class that controls its behavior. In
this section, you'll create this class for the entries scene's view
controller. In the storyboard, you'll then set this class as the view
controller's custom class.

Follow these steps to create the entries scene's view controller class:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Right-click the \texttt{Liferay\ Guestbook} folder in Xcode's project
  navigator and select \emph{New File}. In the \emph{iOS} →
  \emph{Source} section of the dialog that appears, select \emph{Cocoa
  Touch Class} and click \emph{Next}.
\item
  The next screen in the dialog lets you set the class's name, subclass,
  and language. You can also choose whether to create an XIB file for
  the class. Enter the following information and click \emph{Next}:

  \begin{itemize}
  \tightlist
  \item
    \textbf{Class:} \texttt{EntriesViewController}
  \item
    \textbf{Subclass of:} \texttt{UIViewController}
  \item
    \textbf{Also create XIB file:} Unchecked
  \item
    \textbf{Language:} Swift
  \end{itemize}
\item
  The final screen in the dialog lets you set the class's location,
  group, and targets. Make sure \emph{Liferay Guestbook} is selected for
  both the \emph{Group} and \emph{Targets} menus (it should be by
  default), and click \emph{Create}.
\item
  \texttt{EntriesViewController} needs a \texttt{GuestbookModel}
  variable to hold the guestbook it shows entries from. Add this
  variable to the top of the class:

\begin{verbatim}
var selectedGuestbook: GuestbookModel?
\end{verbatim}

  As its name implies, this variable holds the guestbook the user
  selects in Guestbook List Screenlet.
\item
  In the storyboard, select the entries scene's view controller. In the
  Identity inspector, set \texttt{EntriesViewController} as the custom
  class.
\end{enumerate}

Nice work! The entries scene's view controller now has a class that
governs its behavior. Now you're ready to put your Screenlets to use.

\section{Using Guestbook List
Screenlet}\label{using-guestbook-list-screenlet-1}

The steps for using Guestbook List Screenlet are the same as those for
using any Screenlet:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Insert the Screenlet in the storyboard scene where you want it to
  appear. You do this by adding an empty view to the scene, and then
  setting the Screenlet class as the view's custom class.
\item
  Conform the scene's view controller class to the Screenlet's delegate
  protocol. This lets the view controller respond to the Screenlet's
  events.
\end{enumerate}

You'll follow these steps to use Guestbook List Screenlet in the
guestbooks scene. You'll also take an extra step to trigger the segue to
the entries scene when a user selects a guestbook.

\subsection{Adding Guestbook List Screenlet to the Guestbooks
Scene}\label{adding-guestbook-list-screenlet-to-the-guestbooks-scene}

Follow these steps to add Guestbook List Screenlet to the guestbooks
scene:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In your storyboard, first select the guestbooks scene's view
  controller. Then drag and drop a plain view (\texttt{UIView}) from the
  Object Library to the view controller. In the outline view, this new
  view should be nested under the view controller's existing view.

  \begin{figure}
  \centering
  \includegraphics{./images/ios-lp-gb-view-outline.png}
  \caption{The new view is nested under the view controller's existing
  view.}
  \end{figure}
\item
  Resize the new view to take up all the space below the navigation bar.
  With the new view selected, open the \emph{Add New Constraints} menu
  at the bottom-right of the canvas. In this menu, set \emph{Spacing to
  nearest neighbor} to 0 on all sides, and click the \emph{Add 4
  Constraints} button.

  \begin{figure}
  \centering
  \includegraphics{./images/ios-lp-gb-constraints.png}
  \caption{Set the new view's \emph{Spacing to nearest neighbor}
  constraints to 0 on all sides.}
  \end{figure}
\item
  With the new view still selected, open the Identity inspector and set
  the view's custom class to \texttt{GuestbookListScreenlet}. The view
  now appears as Guestbook List Screenlet in the outline view.
\end{enumerate}

Fantastic! The guestbooks scene now contains Guestbook List Screenlet.
Next, you'll conform the scene's view controller class to the
Screenlet's delegate.

\subsection{Conforming to the Screenlet's Delegate
Protocol}\label{conforming-to-the-screenlets-delegate-protocol-1}

Recall that a view controller can respond to a Screenlet's events by
conforming to the Screenlet's delegate protocol. To respond to Guestbook
List Screenlet's events, \texttt{GuestbooksViewController} (the
guestbooks scene's view controller class) must conform to the
\texttt{GuestbookListScreenletDelegate} protocol. You created this
delegate when creating the Screenlet. This delegate defines methods for
responding to the success or failure to retrieve guestbooks, and the
selection of a guestbook in the list.

Follow these steps to conform \texttt{GuestbooksViewController} to the
\texttt{GuestbookListScreenletDelegate} protocol:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Import \texttt{LiferayScreens}, and in the class declaration set
  \texttt{GuestbooksViewController} to adopt the
  \texttt{GuestbookListScreenletDelegate} protocol. The first few lines
  of the class should look like this:

\begin{verbatim}
import UIKit
import LiferayScreens

class GuestbooksViewController: UIViewController, GuestbookListScreenletDelegate {...
\end{verbatim}
\item
  Implement the \texttt{GuestbookListScreenletDelegate} method
  \texttt{screenlet(\_:onGuestbookListResponse:)}. Recall that this
  method lets you respond to a successful server call. Its arguments
  include the \texttt{GuestbookModel} objects that result from such a
  call. Since the Screenlet already displays these objects, you don't
  need to do anything in this method:

\begin{verbatim}
func screenlet(screenlet: GuestbookListScreenlet, 
    onGuestbookListResponse guestbooks: [GuestbookModel]) {

}
\end{verbatim}
\item
  Implement the \texttt{GuestbookListScreenletDelegate} method
  \texttt{screenlet(\_:onGuestbookListError:)}. Recall that this method
  lets you respond to a failed server call. Its arguments include the
  \texttt{NSError} object that results from such a call. You don't have
  to do anything in this method, but it's a good idea to print the
  error:

\begin{verbatim}
func screenlet(screenlet: GuestbookListScreenlet, onGuestbookListError error: NSError) {
    print("Failed to retrieve guestbooks: \(error.localizedDescription)")
}
\end{verbatim}
\item
  Implement the \texttt{GuestbookListScreenletDelegate} method
  \texttt{screenlet(\_:onGuestbookSelected:)}. Recall that this method
  lets you respond when a user selects a guestbook in the list. It does
  so by including the selected \texttt{GuestbookModel} object in its
  arguments. When a user selects a guestbook, the app should transition
  to the entries scene and display that guestbook's entries with Entry
  List Screenlet. To do this, you must trigger the segue to the entries
  scene by using the method
  \texttt{performSegue(withIdentifier:sender:)} with the segue's ID and
  the selected \texttt{GuestbookModel}. Recall that you assigned the
  segue's ID, \texttt{entriessegue}, when you created the segue.
  Including the selected \texttt{GuestbookModel} lets Entry List
  Screenlet know which guestbook to display entries from:

\begin{verbatim}
func screenlet(screenlet: GuestbookListScreenlet, 
    onGuestbookSelected guestbook: GuestbookModel) {

    performSegue(withIdentifier: "entriessegue", sender: guestbook)
}
\end{verbatim}
\item
  Next, you must set the segue's destination view controller to an
  \texttt{EntriesViewController} instance, and set that instance's
  \texttt{selectedGuestbook} variable to the selected guestbook. This
  ensures that Entry List Screenlet receives the guestbook you sent in
  \texttt{performSegue(withIdentifier:sender:)}.

  You do this by overriding the \texttt{prepare(for:sender:)} method.
  This method is called by \texttt{performSegue(withIdentifier:sender:)}
  before the segue occurs. The \texttt{prepare(for:sender:)} method's
  \texttt{sender} parameter receives the guestbook sent by
  \texttt{performSegue(withIdentifier:sender:)}. Currently,
  \texttt{prepare(for:sender:)} is commented out at the bottom of
  \texttt{GuestbooksViewController}. Xcode created this method for you
  when you used the Cocoa Touch Class template to create a view
  controller class. Uncomment the method, and replace it with this:

\begin{verbatim}
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    guard segue.identifier ==  "entriessegue",
        let entriesViewController = segue.destination as? EntriesViewController,
        let selectedGuestbook = sender as? GuestbookModel
        else {return}

    entriesViewController.selectedGuestbook = selectedGuestbook
}
\end{verbatim}

  The \texttt{guard} statement ensures that the code only runs when the
  segue ID is \texttt{entriessegue}, the destination view controller is
  \texttt{EntriesViewController}, and the \texttt{sender} is a
  \texttt{GuestbookModel}. In other words, the code only runs in
  preparation for the segue to the entries scene. The code that runs
  when that condition is met is only one line long:

\begin{verbatim}
entriesViewController.selectedGuestbook = selectedGuestbook
\end{verbatim}

  This sets the guestbook received by \texttt{prepare(for:sender:)} to
  the guestbook in \texttt{EntriesViewController}. As the variable names
  indicate, this is the guestbook the user selects in Guestbook List
  Screenlet.
\item
  Now you must get a Guestbook List Screenlet reference. You'll do this
  by creating an outlet to the Screenlet. Return to your storyboard and
  enter the Assistant editor to display
  \texttt{GuestbooksViewController}'s code and the storyboard side by
  side. With Guestbook List Screenlet selected in the storyboard,
  Control-drag from the Screenlet to the
  \texttt{GuestbooksViewController} class, just below the class
  declaration. Release your mouse button, enter the following
  information in the dialog that appears, and click \emph{Connect}:

  \begin{itemize}
  \tightlist
  \item
    \textbf{Connection:} Outlet
  \item
    \textbf{Name:} screenlet
  \item
    \textbf{Type:} GuestbookListScreenlet
  \item
    \textbf{Storage:} Weak
  \end{itemize}

  Xcode then adds the following code inside the
  \texttt{GuestbooksViewController} class:

\begin{verbatim}
@IBOutlet weak var screenlet: GuestbookListScreenlet!
\end{verbatim}
\item
  Use this new \texttt{screenlet} variable to set the view controller as
  the Screenlet's delegate. Do this in the \texttt{viewDidLoad()} method
  by deleting the placeholder comment and inserting this code below the
  call to \texttt{super.viewDidLoad()}:

\begin{verbatim}
self.screenlet.delegate = self
\end{verbatim}
\end{enumerate}

Great! The guestbooks scene now contains Guestbook List Screenlet. Next,
you'll use Entry List Screenlet in the entries scene.

\section{Using Entry List Screenlet}\label{using-entry-list-screenlet-1}

You'll use Entry List Screenlet the same way you use any Screenlet:
insert it in a storyboard scene, then conform the scene's view
controller class to the Screenlet's delegate protocol. You'll follow
these steps now to use Entry List Screenlet in the entries scene.

\subsection{Adding Entry List Screenlet to the Entries
Scene}\label{adding-entry-list-screenlet-to-the-entries-scene}

Follow these steps to add Entry List Screenlet to the entries scene:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In your storyboard, select the entries scene's view controller. Then
  drag and drop a plain view (\texttt{UIView}) from the Object Library
  to the view controller. In the outline view, this new view should be
  nested under the view controller's existing view.

  \begin{figure}
  \centering
  \includegraphics{./images/ios-lp-entries-view-outline.png}
  \caption{The new view is nested under the view controller's existing
  view.}
  \end{figure}
\item
  Resize the new view to take up all the space below the navigation bar.
  Then open the \emph{Add New Constraints} menu at the bottom-right of
  the canvas. In this menu, set \emph{Spacing to nearest neighbor} to 0
  on all sides, and click the \emph{Add 4 Constraints} button.

  \begin{figure}
  \centering
  \includegraphics{./images/ios-lp-gb-constraints.png}
  \caption{Set the new view's \emph{Spacing to nearest neighbor}
  constraints to 0 on all sides.}
  \end{figure}
\item
  With the new view still selected, open the Identity inspector and set
  the view's custom class to \texttt{EntryListScreenlet}. The view now
  appears as Entry List Screenlet in the outline view.
\end{enumerate}

Great! The entries scene now contains Entry List Screenlet. Next, you'll
conform the scene's view controller class to the Screenlet's delegate.

\subsection{Conforming to the Screenlet's Delegate
Protocol}\label{conforming-to-the-screenlets-delegate-protocol-2}

To respond to Entry List Screenlet's events,
\texttt{EntriesViewController} must conform to the
\texttt{EntryListScreenletDelegate} protocol. You created this delegate
when creating the Screenlet. This delegate defines methods for
responding to the success or failure to retrieve entries, and the
selection of an entry in the list.

Follow these steps to conform \texttt{EntriesViewController} to the
\texttt{EntryListScreenletDelegate} protocol:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Import \texttt{LiferayScreens}, and in the class declaration set
  \texttt{EntriesViewController} to adopt the
  \texttt{EntryListScreenletDelegate} protocol. The first few lines of
  the class should look like this:

\begin{verbatim}
import UIKit
import LiferayScreens

class EntriesViewController: UIViewController, EntryListScreenletDelegate {...
\end{verbatim}
\item
  Implement the \texttt{EntryListScreenletDelegate} method
  \texttt{screenlet(\_:onEntryListResponse:)}. Recall that this method
  lets you respond to a successful server call. Its arguments include
  the \texttt{EntryModel} objects that result from such a call. Since
  the Screenlet already displays these objects, you don't need to do
  anything in this method:

\begin{verbatim}
func screenlet(screenlet: EntryListScreenlet, onEntryListResponse entries: [EntryModel]) {

}
\end{verbatim}
\item
  Implement the \texttt{EntryListScreenletDelegate} method
  \texttt{screenlet(\_:onEntryListError:)}. Recall that this method lets
  you respond to a failed server call. Its arguments include the
  resulting \texttt{NSError} object. You don't have to do anything in
  this method, but it's a good idea to print the error:

\begin{verbatim}
func screenlet(screenlet: EntryListScreenlet, onEntryListError error: NSError) {
    print("Failed to retrieve guestbook entries: \(error.localizedDescription)")
}
\end{verbatim}
\item
  Implement the \texttt{EntryListScreenletDelegate} method
  \texttt{screenlet(\_:onEntrySelected:)}. Recall that this method lets
  you respond when a user selects an entry in the list. It does so by
  including the selected \texttt{EntryModel} object in its arguments.
  Since there's currently not a scene or other action that handles
  detailed information about an entry, you don't need to do anything in
  this method:

\begin{verbatim}
func screenlet(screenlet: EntryListScreenlet, onEntrySelected entry: EntryModel) {

}
\end{verbatim}
\item
  Now you must get an Entry List Screenlet reference. You'll do this by
  creating an outlet to the Screenlet. Return to your storyboard and
  enter the Assistant editor to display \texttt{EntriesViewController}'s
  code and the storyboard side by side. With Entry List Screenlet
  selected in the storyboard, Control-drag from the Screenlet to the
  \texttt{EntriesViewController} class, just below the class
  declaration. Release your mouse button, enter the following
  information in the dialog that appears, and click \emph{Connect}:

  \begin{itemize}
  \tightlist
  \item
    \textbf{Connection:} Outlet
  \item
    \textbf{Name:} screenlet
  \item
    \textbf{Type:} EntryListScreenlet
  \item
    \textbf{Storage:} Weak
  \end{itemize}

  Xcode then adds the following code inside the
  \texttt{EntriesViewController} class:

\begin{verbatim}
@IBOutlet weak var screenlet: EntryListScreenlet!
\end{verbatim}
\item
  Use this new \texttt{screenlet} variable to set the view controller as
  the Screenlet's delegate. Do this in the \texttt{viewDidLoad()} method
  by deleting the placeholder comment and inserting this code below the
  call to \texttt{super.viewDidLoad()}:

\begin{verbatim}
self.screenlet.delegate = self
\end{verbatim}
\item
  Next, you must set the guestbook the Screenlet retrieves entries from.
  To do this, set the Screenlet's \texttt{guestbookId} property to the
  selected guestbook's ID, immediately below the Screenlet's delegate
  assignment in the \texttt{viewDidLoad()} method:

\begin{verbatim}
self.screenlet.guestbookId = selectedGuestbook!.guestbookId
\end{verbatim}
\item
  Lastly, you must set the selected guestbook's name to the navigation
  bar's title. This lets the scene reflect the guestbook selection in
  the UI. To do this, add the following line of code at the end of the
  \texttt{viewDidLoad()} method:

\begin{verbatim}
self.navigationItem.title = selectedGuestbook!.name
\end{verbatim}

  Your \texttt{viewDidLoad()} method should now look like this:

\begin{verbatim}
override func viewDidLoad() {
    super.viewDidLoad()

    self.screenlet.delegate = self
    self.screenlet.guestbookId = selectedGuestbook!.guestbookId
    self.navigationItem.title = selectedGuestbook!.name
}
\end{verbatim}
\end{enumerate}

Now you're ready to test your handiwork. Make sure your portal
containing the Guestbook portlet is running, and that the portlet
contains a couple guestbooks that have entries. Then run the app and log
in with your credentials. You should see the list of guestbooks
displayed by Guestbook List Screenlet. Selecting a guestbook in the list
takes you to the entries scene, which uses Entry List Screenlet to
display a list of that guestbook's entries. Pressing the back button
returns you to the guestbooks scene, where you can select a different
guestbook.

\begin{figure}
\centering
\includegraphics{./images/ios-lp-gb-screenlet.png}
\caption{After login, Guestbook List Screenlet displays the list of
guestbooks from the portlet.}
\end{figure}

\begin{figure}
\centering
\includegraphics{./images/ios-lp-entries-screenlet.png}
\caption{Selecting a guestbook displays a list of that guestbook's
entries via Entry List Screenlet.}
\end{figure}

Congratulations! Now you know how to use Liferay Screens and create your
own Screenlets. This opens up a world of possibilities for developing
apps that leverage Liferay DXP. Although you learned a great deal in
this Learning Path, there's still more. You can customize your
Screenlet's appearance, package Screenlets and Themes for
redistribution, and even add multiple actions to a Screenlet. These
topics, and more, are covered in
\href{/docs/7-0/tutorials/-/knowledge_base/t/ios-apps-with-liferay-screens}{the
tutorials on iOS apps with Liferay Screens}.

\chapter{Tooling}\label{tooling}

Liferay is very flexible when it comes to supporting different
development tooling. Instead of being pigeonholed into using a specific
tool, Liferay works with whatever tools you like to use. This set of
tutorials describes some of the more popular tools that are used to
develop for Liferay. If you're a newbie looking for the best development
tool for Liferay, or even a seasoned veteran looking for a tool you may
like more than your current setup, this section will answer your tooling
questions.

\chapter{Liferay @ide@}\label{liferay-ide}

Liferay @ide@ provides an all-in-one, integrated development environment
based on Eclipse that supports development for Liferay DXP. @ide@
includes Liferay IDE plugins and additional enterprise-only features
like

\begin{itemize}
\tightlist
\item
  Kaleo Designer for Java
\item
  WebSphere support
\item
  Pre-installed Liferay Digital Enterprise server
\end{itemize}

@ide@ is also designed to work with build tools such as Gradle and
Maven, and configuration tools like BndTools.

Liferay @ide@ makes Liferay development easier. There are editors for
Service Builder files, workflow definitions, layout templates, and more.
You'll find wizards for creating every kind of Liferay project there is,
snippet for tag libraries, and auto-deploy of changes to plugins.

In this section of tutorials, you'll learn how to install Liferay @ide@
and develop/manage Liferay modules using Liferay Workspace and other
technologies.

\section{Installing Liferay @ide@}\label{installing-liferay-ide}

Liferay @ide@ is a plugin for Eclipse that provides many
Liferay-specific features and additional enterprise only features. You
can install it into your existing Eclipse environment, or Liferay
provides a bundled version. In this tutorial, you'll learn the different
methods available for installing Liferay @ide@. Before beginning the
installation process, view @ide@'s
\href{https://web.liferay.com/group/customer/dxp/support/compatibility-matrix/developer-tools}{Compatibility
Matrix} to get acquainted with its supported Liferay versions and
application servers.

\textbf{Important:} If you're upgrading your Liferay @ide@ instance to
version 3.1, you must install a new @ide@ bundle. You cannot install an
update for this upgrade. Your Liferay Workspace instance and its
contents are backwards compatible and can be copied to the new 3.1
version.

\subsection{Install the Liferay @ide@
Bundle}\label{install-the-liferay-ide-bundle}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Download and install \href{http://java.oracle.com}{Java}. Liferay DXP
  runs on Java, so you'll need it to run everything else. Because you'll
  be developing apps for Liferay DXP in Liferay @ide@, the Java
  Development Kit (JDK) is required. It is an enhanced version of the
  Java Environment used for developing new Java technology. You can
  download the Java SE JDK from the Java
  \href{http://www.oracle.com/technetwork/java/javase/downloads/index.html}{Downloads}
  page.
\item
  Download the
  \href{https://web.liferay.com/group/customer/dxp/downloads/developer-tools}{Liferay
  @ide@ installer}. Be sure to choose the installer appropriate for your
  operating system (e.g., Windows, MacOS, Linux).

  You may be prompted for your liferay.com username and password before
  downloading the Liferay DXP installer. Since @ide@ includes access to
  Liferay DXP, you must verify that you have rights to use it.

  Your credentials are not saved locally; they're saved as a token in
  the \texttt{\textasciitilde{}/.liferay} folder. The token is used by
  your @ide@'s
  \href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-workspace}{Liferay
  Workspace} if you ever decide to redownload a Liferay DXP bundle.
  Furthermore, the Liferay DXP bundle that was downloaded in your
  workspace is also copied to your
  \texttt{\textasciitilde{}/.liferay/bundles} folder, so if you decide
  to initialize another Liferay DXP instance of the same version, the
  bundle is not re-downloaded. See the
  \href{/docs/7-0/tutorials/-/knowledge_base/t/configuring-a-liferay-workspace\#adding-a-liferay-bundle-to-a-workspace}{Adding
  a Liferay Bundle to a Workspace} for more information on this topic.

  \textbf{Important:} The token generator sometimes has issues
  generating a token for workspaces built behind a proxy. If you're
  unable to automatically generate a workspace token, you can
  \hyperref[generating-a-workspace-token-manually]{generate one
  manually}.
\item
  Run the installer. You may need to allow permission for the installer
  to run, depending on your operating system and where you want to
  install it.
\item
  Click \emph{Next} to begin the installation process. Select the
  installation folder for your Liferay @ide@ instance. Then click
  \emph{Next}.

  \begin{figure}
  \centering
  \includegraphics{./images-dxp/dev-studio-install.png}
  \caption{Choose the folder your @ide@ instance should reside.}
  \end{figure}
\item
  Liferay @ide@ provides
  \href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-workspace}{Liferay
  Workspace} by default, which is a developer environment used to build
  and manage Liferay DXP projects. The installer automatically installs
  Liferay Workspace and its dedicated command line tool
  (\href{/docs/7-0/tutorials/-/knowledge_base/t/blade-cli}{Blade CLI}).

  You'll need to choose the Liferay bundle you plan to use in your
  Liferay Workspace: \emph{Liferay DXP Bundle} or \emph{Community
  Edition Bundle}. Then choose \emph{Next}.

  \begin{figure}
  \centering
  \includegraphics{./images-dxp/dev-studio-bundle-selection.png}
  \caption{Choose the Liferay bundle you plan to use.}
  \end{figure}

  If you selected \emph{Liferay DXP Bundle}, you're also required to
  provide your liferay.com email and password.
\item
  Click \emph{Next} to finish the installation process for your @ide@
  instance.
\end{enumerate}

Congratulations! You've installed Liferay @ide@! It's now available in
the folder you specified. To run @ide@, execute the
\texttt{DeveloperStudio} executable. A Liferay Workspace has also been
initialized in that same folder. For more information on the Liferay
Workspace installation related to this installation process, see the
\href{/docs/7-0/tutorials/-/knowledge_base/t/installing-liferay-workspace}{Installing
Liferay Workspace} section.

\subsection{Install Liferay @ide@ into Eclipse
Environment}\label{install-liferay-ide-into-eclipse-environment}

To install @ide@ using an update URL, follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In Eclipse, go to \emph{Help} → \emph{Install New Software\ldots{}}.
\item
  In the \emph{Work with} field, copy in the URL
  http://releases.liferay.com/tools/ide/latest/stable/.
\item
  You'll see the @ide@ components in the list below. Check them off and
  click \emph{Next}.
\item
  Accept the terms of the agreements. Click \emph{Next}, and @ide@ is
  installed. Like other Eclipse plugins, you must restart Eclipse to use
  them.
\end{enumerate}

Liferay @ide@ is now installed in your existing Eclipse environment.

\subsection{Install Liferay @ide@ into Eclipse from a ZIP
File}\label{install-liferay-ide-into-eclipse-from-a-zip-file}

To install @ide@ using a Zip file, follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Go to the
  \href{https://web.liferay.com/group/customer/dxp/downloads/developer-tools}{Liferay
  @ide@} downloads page. From the drop-down menu, select \emph{Developer
  Studio Update Site Zip} and click \emph{Download}.
\item
  In Eclipse, go to \emph{Help} → \emph{Install New Software\ldots{}}.
\item
  In the \emph{Add} dialog, click the \emph{Archive} button and browse
  to the location of the downloaded Liferay @ide@ Update Site
  \texttt{.zip} file. Then press \emph{OK}.
\item
  You'll see the @ide@ components in the list below. Check them off and
  click \emph{Next}.

  \begin{figure}
  \centering
  \includegraphics{./images-dxp/dev-studio-zip-install.png}
  \caption{Make sure to check all the @ide@ components you wish to
  install.}
  \end{figure}
\item
  Accept the terms of the agreements and click \emph{Next}, and
  Developer Studio is installed. Like other Eclipse plugins, you must
  restart Eclipse to use them.
\end{enumerate}

Awesome! You've installed Liferay @ide@ in your existing Eclipse
environment.

\subsection{Generating a Workspace Token
Manually}\label{generating-a-workspace-token-manually}

If you run into any issues with generating your token automatically, you
can follow the steps below to manually create one.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Navigate to \href{https://www.liferay.com/}{www.liferay.com} and log
  in to your account.
\item
  Click the Options button
  (\includegraphics{./images-dxp/icon-liferay-options.png}) and
  select \emph{Account Home}.
\item
  Select \emph{Account Settings} from the left menu.
\item
  Click \emph{Authorization Tokens} from the right menu under the
  Miscellaneous heading.

  \begin{figure}
  \centering
  \includegraphics{./images-dxp/authorization-tokens-option.png}
  \caption{You can manually create your workspace token in the
  Authorization Tokens menu.}
  \end{figure}
\item
  Select \emph{Add Token}, give it a device name, and click
  \emph{Generate}. The device name can be set to any string; it's for
  bookkeeping purposes only.
\item
  Create a file named \texttt{\textasciitilde{}/.liferay/token} and copy
  the generated token into that file.

  \begin{figure}
  \centering
  \includegraphics{./images-dxp/generated-token.png}
  \caption{The generated token is available to copy.}
  \end{figure}

  Make sure there are no new lines or white space in the file. It should
  only be one line.
\end{enumerate}

You've successfully generated your token manually and it's now available
for your installer to access. If you haven't run the installer, you can
do so now. If you've already run the installer, you can set the DXP
bundle to download in the \texttt{gradle.properties} file of your
workspace. See the
\href{/docs/7-0/tutorials/-/knowledge_base/t/configuring-a-liferay-workspace\#adding-a-liferay-bundle-to-a-workspace}{Adding
a Liferay Bundle to a Workspace} tutorial for details.

\section{Creating a Liferay Workspace with Liferay
@ide@}\label{creating-a-liferay-workspace-with-liferay-ide}

In this tutorial, you'll learn how to generate a Liferay Workspace using
Liferay @ide@, which runs on the
\href{/docs/7-0/tutorials/-/knowledge_base/t/blade-cli}{Blade CLI}
behind the scenes. Liferay @ide@ gives you a graphical interface instead
of the command prompt, which can streamline your workflow. To learn more
about Liferay Workspaces, visit its dedicated
\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-workspace}{tutorial
section}.

!P\href{https://portal.liferay.dev/documents/113763090/113920063/vid-ide-thumbnail.png}{Video
Thumbnail}

Before creating your Liferay Workspace, you should understand the
available Liferay DXP perspectives specifically designed for Liferay DXP
development. You'll notice in the Perspectives view the \emph{Liferay
Workspace} and \emph{Liferay} perspectives. If you plan on using a
Liferay Workspace for your Liferay DXP development, you should select
the \emph{Liferay Workspace} perspective. This offers Gradle related
development tools that are helpful when using a Liferay workspace. The
\emph{Liferay} perspective is geared towards developers who are using
Ant-based development tools such as the Plugins SDK.

To create a Liferay Workspace in @ide@, select \emph{File} → \emph{New}
→ \emph{Liferay Workspace Project}.

\noindent\hrulefill

\textbf{Note:} Creating or importing a Liferay Workspace in IDE
leverages Gradle scripts provided by the
\href{https://projects.eclipse.org/projects/tools.buildship}{Buildship}
plugin. When using @ide@ 3.1.x, you should be using Buildship 2.1.x. If
you leverage higher versions of Buildship (e.g., 2.2.x), @ide@ cannot
successfully create or import a workspace.

\noindent\hrulefill

\begin{figure}
\centering
\includegraphics{./images/selecting-liferay-workspace.png}
\caption{By selecting \emph{Liferay Workspace}, you begin the process of
creating a new workspace for your Liferay projects.}
\end{figure}

A New Liferay Workspace dialog appears, presenting several configuration
options. Follow the instructions below to create your workspace.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Give your workspace a name.
\item
  Choose the location where you'd like your workspace to reside.
  Checking the \emph{Use default location} checkbox places your Liferay
  Workspace in the Eclipse workspace you're working in.
\item
  Check the \emph{Download Liferay bundle} checkbox if you'd like to
  auto-generate a Liferay instance in your workspace. You'll be prompted
  to name the server, if selected. This Liferay bundle is generated the
  same way as described in the previous section.
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** If you'd like to configure a pre-existing Liferay bundle to your
 workspace, you can create a directory for the bundle in your workspace and
 configure it in the workspace's `gradle.properties` file by setting the
 `liferay.workspace.home.dir` property.
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{3}
\item
  Check the \emph{Add project to working set} checkbox if you'd like the
  workspace to be a part of a larger working set you've already created
  in @ide@. For more information on working sets, visit
  \href{http://help.eclipse.org/mars/index.jsp?topic=\%2Forg.eclipse.platform.doc.user\%2Fconcepts\%2Fcworkset.htm}{Eclipse
  Help}.
\item
  Click \emph{Finish} to create your Liferay Workspace.
\end{enumerate}

\begin{figure}
\centering
\includegraphics{./images/new-workspace-menu.png}
\caption{Liferay @ide@ provides an easy-to-follow menu to create your
Liferay Workspace.}
\end{figure}

A dialog appears prompting you to open the Liferay Workspace
perspective. Click \emph{Yes}, and your perspective will switch to
Liferay Workspace.

\noindent\hrulefill

\textbf{Note:} You can also create a Liferay Workspace during the
initial start-up of a Liferay Developer Studio instance.

\noindent\hrulefill

Awesome! You've successfully created a Liferay Workspace in Liferay
@ide@! If you're using Liferay Developer Studio, you can also create a
workspace during initial start-up.

\subsection{Liferay Workspace Settings in
@ide@}\label{liferay-workspace-settings-in-ide}

The Liferay Workspace perspective is intended for Gradle development for
7.0 modules. Since Liferay Workspaces are used for Gradle based
development and the Liferay Plugins perspective is intended for the
Plugins SDK and Ant based development, the two perspectives are
independent of each other.

\begin{figure}
\centering
\includegraphics{./images/liferay-workspace-perspective.png}
\caption{The Liferay Workspace perspective is preferred for 7.0 and OSGi
module development.}
\end{figure}

You'll find your new workspace in the Project Explorer and your Liferay
server (if you created it) in the Servers menu. It's important to note
that an Eclipse workspace can only have one Liferay Workspace project.

\begin{figure}
\centering
\includegraphics{./images/liferay-workspace-duplicate.png}
\caption{An @ide@ workspace only supports one Liferay Workspace project.
If you create another, you'll be given an error message.}
\end{figure}

You can configure your workspace's module presentation by switching
between the default \emph{Hierarchical} or \emph{Flat} views. To do
this, navigate to the Project Explorer's \emph{View Menu}
(\includegraphics{./images/icon-ide-view-menu.png}), select
\emph{Projects Presentation} and then select the presentation mode you'd
like to display. The Hierarchical view displays subfolders and
subprojects under the workspace project, whereas the Flat view displays
the workspace's modules separately from the workspace.

\begin{figure}
\centering
\includegraphics{./images/workspace-presentation.png}
\caption{The Hierarchical project presentation mode is set, by default.}
\end{figure}

If you've already created a Liferay Workspace and you'd like to import
it into your existing @ide@, you can do so by navigating to \emph{File}
→ \emph{Import} → \emph{Liferay} → \emph{Liferay Workspace Project}.
Then click \emph{Next} and browse for your workspace project. Once
you've selected you workspace, click \emph{Finish}.

\begin{figure}
\centering
\includegraphics{./images/liferay-workspace-import.png}
\caption{You can import an existing Liferay Workspace into your current
@ide@ session.}
\end{figure}

Congratulations! You've learned how to create and configure a Liferay
Workspace using Liferay @ide@. Now that your workspace is created, you
can begin creating Liferay plugins.

!V\href{https://portal.liferay.dev/documents/113763090/113920063/getting-started-with-liferay-ide.mp4\%7Chttps://portal.liferay.dev/documents/113763090/113920063/getting-started-with-liferay-ide.webm}{Video
Tutorial}

\section{Setting Proxy Requirements for Liferay
@ide@}\label{setting-proxy-requirements-for-liferay-ide}

If you have proxy server requirements and want to configure your http(s)
proxy\\
to work with Liferay @ide@, follow the instructions below.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Navigate to Eclipse's \emph{Window} → \emph{Preferences} →
  \emph{General} → \emph{Network Connections} menu.
\item
  Set the \emph{Active Provider} drop-down selector to \emph{Manual}.
\item
  Under \emph{Proxy entries}, configure both proxy HTTP and HTTPS by
  clicking the field and selecting the \emph{Edit} button.

  \begin{figure}
  \centering
  \includegraphics{./images/ide-network-connections.png}
  \caption{You can configure your proxy settings in @ide@'s Network
  Connections menu.}
  \end{figure}
\item
  For each schema (HTTP and HTTPS), enter your proxy server's host,
  port, and authentication settings (if necessary).

  \textbf{Note:} Do not leave whitespace at the end of your proxy host
  or port settings.
\item
  Once you've configured your proxy entry, click \emph{OK} → \emph{OK}.
\end{enumerate}

If you're working with a Liferay Workspace in @ide@, you'll need to
configure your proxy settings for that environment too. See the
\href{/docs/7-0/tutorials/-/knowledge_base/t/setting-proxy-requirements-for-liferay-workspace}{Setting
Proxy Requirements for Liferay Workspace} for more details.

Awesome! You've successfully configured Liferay @ide@'s proxy settings!

\subsection{Additional Proxy Settings}\label{additional-proxy-settings}

Some Eclipse plugins do not properly check the \texttt{core.net} proxy
infrastructure when setting proxy settings via \emph{Window} →
\emph{Preferences} → \emph{General} → \emph{Network Connections}.
Therefore, you may need to configure additional proxy settings.

To do so, open the \texttt{eclipse.ini} file associated with your
Eclipse installation and add the following entries:

\begin{verbatim}
    -vmargs
    -Dhttp.proxyHost=www.somehost.com
    -Dhttp.proxyPort=1080
    -Dhttp.proxyUser=userId
    -Dhttp.proxyPassword=somePassword
    -Dhttps.proxyHost=www.somehost.com
    -Dhttps.proxyPort=1080
    -Dhttps.proxyUser=userId
    -Dhttps.proxyPassword=somePassword
\end{verbatim}

After saving the file, restart Eclipse. Now your additional proxy
settings are applied!

\section{Updating Liferay @ide@}\label{updating-liferay-ide}

If you're already using Liferay @ide@ but need to update your
environment, follow the steps below:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In Liferay @ide@, go to \emph{Help} → \emph{Install New
  Software\ldots{}}.
\item
  In the \emph{Work with} field, copy in the URL
  http://releases.liferay.com/tools/ide/latest/stable/.
\item
  You'll see the @ide@ components in the list below. Check them off and
  click \emph{Next}.

  \begin{figure}
  \centering
  \includegraphics{./images/ide-zip-install.png}
  \caption{Make sure to check all the @ide@ components you wish to
  install.}
  \end{figure}
\item
  Accept the terms of the agreements. Click \emph{Next}, and @ide@ is
  updated. You must restart @ide@ for the updates to take effect.
\end{enumerate}

You're now on the latest version of Liferay @ide@!

\section{Creating Modules with Liferay
@ide@}\label{creating-modules-with-liferay-ide}

@ide@ provides a Module Project Wizard for users to create a variety of
different module projects. You can create a new Liferay module project
by navigating to \emph{File} → \emph{New} → \emph{Liferay Module
Project}.

\begin{figure}
\centering
\includegraphics{./images/new-module-project.png}
\caption{When selecting \emph{New} → \emph{Liferay Module Project}, a
Module Project Wizard appears.}
\end{figure}

You're given options for project name, location, build type, and
template type. You can build your project using Gradle or Maven. If
you're unsure for which template type to choose, see the
\href{/docs/7-0/reference/-/knowledge_base/r/project-templates}{Project
Templates} reference section. Click \emph{Next} and you're given
additional configuration options for a component class.

\begin{figure}
\centering
\includegraphics{./images/component-class-wizard.png}
\caption{Specify your component class's details in the Portlet Component
Class Wizard.}
\end{figure}

You can specify your component class's name, package name, and its
properties. The properties you assign are the ones found in the
\texttt{@Component} annotation's \texttt{property\ =\ \{...\}}
assignment.

Once you've configured your module project's component class, click
\emph{Finish} to create your project.

\subsection{Creating Component
Classes}\label{creating-component-classes}

You can also create a new component class for a pre-existing module
project. Navigate to \emph{File} → \emph{New} → \emph{Liferay Component
Class}. This is a similar wizard to the previous component class wizard,
except you can select a component class template. There are many
templates in the \texttt{Component\ Class\ Template} list:

\begin{itemize}
\tightlist
\item
  \emph{Auth Failure}: processes a verify login failure
\item
  \emph{Auth Max Failure}: processes maximum number of login failures
\item
  \emph{Authenticator}: authenticates processing
\item
  \emph{Friendly URL Mapper}: processes Friendly URLs
\item
  \emph{GOGO Command}: creates a custom Gogo command
\item
  \emph{Indexer Post Processor}: creates a new Indexer Post Processor
\item
  \emph{Login Pre Action}: creates a login pre action
\item
  \emph{Model Listener}: sets a model listener
\item
  \emph{Poller Processor}: creates a new poller processor
\item
  \emph{Portlet}: creates a new portlet class file
\item
  \emph{Portlet Action Command}: creates a new portlet action command
\item
  \emph{Portlet Filter}: creates a new portlet filter
\item
  \emph{Rest}: calls and wraps inner service in the way of Rest
\item
  \emph{Service Wrapper}: creates a new service wrapper
\item
  \emph{Struts in Action}: creates a new struts action
\item
  \emph{Struts Portlet Action}: creates a new struts portlet action
\end{itemize}

\subsection{Possible Dependency
Issues}\label{possible-dependency-issues}

When selecting the \texttt{Authenticator},
\texttt{Portlet\ Action\ Command}, \texttt{Rest}, or
\texttt{Service\ Wrapper} templates, you may run into some dependency
issues that could cause errors in your project. There is a set of steps
outlined below that you should follow, with sub-steps for each of the
four templates that could cause problems.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open the module project's \texttt{build.gradle} file.
\item
  Check whether the appropriate dependencies exist. These are outlined
  below.
\item
  Right-click your project and select \emph{Gradle} → \emph{Refresh
  Gradle Project}.
\item
  If you're using the \emph{Portlet Action Command} template, you'll
  also need to change the component class declaration from implementing
  the \texttt{FreeMarkerPortlet} class to extending it. For instance,
  your \texttt{*Portlet} component class should have the following
  declared:

  YourPortletClass extends FreeMarkerPortlet
\end{enumerate}

The dependencies to check for when using each template are outlined
below:

\textbf{Authenticator}

\begin{itemize}
\tightlist
\item
  \texttt{compile\ com.liferay.portal:com.liferay.portal.kernel:VERSION}
\item
  \texttt{compile\ org.osgi:org.osgi.service.component.annotations:VERSION}
\end{itemize}

\textbf{Portlet Action Command}

\begin{itemize}
\tightlist
\item
  \texttt{compile\ javax.portlet:portlet-api:VERSION}
\item
  \texttt{compile\ javax.servlet:javax.servlet-api:VERSION}
\item
  \texttt{compile\ org.osgi:org.osgi.service.component.annotations:VERSION}
\item
  \texttt{compile\ com.liferay.portal:com.liferay.portal.kernel:VERSION}
\item
  \texttt{compile\ com.liferay.portal:com.liferay.util.bridges:VERSION}
\item
  \texttt{compile\ com.liferay.portal:com.liferay.util.taglib:VERSION}
\end{itemize}

\textbf{Rest}

\begin{itemize}
\tightlist
\item
  \texttt{compile\ javax.ws.rs:javax.ws.rs-api:VERSION}
\end{itemize}

\textbf{Service Wrapper}

\begin{itemize}
\item
  The service wrapper class being used. For example, if you're using the
  \texttt{BookmarksEntryLocalServiceWrapper}, the following dependency
  would be required:

\begin{verbatim}
  compile com.liferay:com.liferay.bookmarks.api:VERSION
\end{verbatim}
\end{itemize}

Make sure the replace the \texttt{VERSION} text with the appropriate
version for each specified dependency.

Once you've created your module project, you can configure your
project's presentation in the @ide@'s Project Explorer. To change the
project's presentation, select the default \emph{Hierarchical} or
\emph{Flat} views. To do this, navigate to the Project Explorer's
\emph{View Menu}
(\includegraphics{./images/icon-ide-view-menu.png}), select
\emph{Projects Presentation} and then select the presentation mode you'd
like to display. The Hierarchical view displays subfolders and
subprojects under the project, whereas the Flat view displays the
modules separately from their project.

\begin{figure}
\centering
\includegraphics{./images/workspace-presentation.png}
\caption{The Hierarchical project presentation mode is set, by default.}
\end{figure}

@ide@ also provides a method to import existing module projects. You can
import a module project by navigating to \emph{File} → \emph{Import} →
\emph{Liferay} → \emph{Liferay Module Project(s)}. Then point to the
project location and click \emph{Finish}.

\begin{figure}
\centering
\includegraphics{./images/import-wizard.png}
\caption{Select the \emph{Liferay Module Project(s)} to import a module
project.}
\end{figure}

You now have the knowledge to create a Liferay module project from
Liferay @ide@. Now go out there and get stuff done!

\section{Creating Themes with Liferay
@ide@}\label{creating-themes-with-liferay-ide}

Liferay @ide@ lets you create and configure Liferay theme projects. You
can create a standalone theme or in a
\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-workspace}{Liferay
Workspace}. You can even create a Gradle or Maven based theme! Read on
to learn more about creating themes in @ide@.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In @ide@, navigate to \emph{File} → \emph{New} → \emph{Liferay Module
  Project}.
\item
  In the New Liferay Module Project wizard, give your project a name and
  select the \emph{theme} project template. Also choose your theme's
  build type by selecting either \emph{gradle-module} or
  \emph{maven-module}.

  \begin{figure}
  \centering
  \includegraphics{./images/theme-in-ide.png}
  \caption{Use the theme project template to create a Liferay theme in
  @ide@.}
  \end{figure}
\item
  Select \emph{Finish}.
\end{enumerate}

That's it! You've created a theme project in @ide@!

If you've
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-a-liferay-workspace-with-liferay-ide}{configured
a Liferay Workspace in your @ide@ instance}, your theme is available in
the workspace's \texttt{wars} folder by default. If you don't have a
workspace configured in @ide@, it's available in the root of @ide@'s
Project Explorer.

Note that themes created in @ide@ follow a WAR-style layout. This is the
default layout of themes in 7.0. Although the wizard can be misleading
by calling the theme a new module project, it is a WAR.

To modify a theme created in @ide@, mirror the folder structure of the
files you wish to change and copy them into your theme's \texttt{webapp}
folder.

Under the hood, @ide@ is using the
\href{/docs/7-0/reference/-/knowledge_base/r/theme-template}{theme
project template}. If you're interested in creating Liferay themes using
the Liferay Theme Generator, see its dedicated
\href{/docs/7-0/tutorials/-/knowledge_base/t/themes-generator}{tutorial}.
For more general information on Liferay themes, visit their dedicated
tutorial section
\href{/docs/7-0/tutorials/-/knowledge_base/t/themes-and-layout-templates}{Themes
and Layout Templates}.

\section{Deploying Modules with Liferay
@ide@}\label{deploying-modules-with-liferay-ide}

Deploying modules in Liferay @ide@ is a cinch. Before deploying your
module, make sure you have a Liferay server configured in @ide@. To see
how to do this, see the
\href{/docs/7-0/tutorials/-/knowledge_base/t/installing-a-server-in-liferay-ide}{Installing
a Server in Liferay @ide@}

There are two ways to deploy a module to your Liferay server. You should
start your Liferay server before attempting to deploy to it.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Select the module from the Package Explorer window and drag it to your
  Liferay server in the Servers window.

  \begin{figure}
  \centering
  \includegraphics{./images/starting-module-dev-drag-module.png}
  \caption{You can use the drag-and-drop method to deploy your module to
  Liferay DXP.}
  \end{figure}
\item
  Right-click the server from the Servers window and select \emph{Add
  and Remove\ldots{}}. Add the module(s) you'd like to deploy from the
  Available window to the Configured window. Then click \emph{Finish}.

  \begin{figure}
  \centering
  \includegraphics{./images/add-and-remove-ide.png}
  \caption{Using the this deployment method is convenient when deploying
  multiple module projects.}
  \end{figure}
\end{enumerate}

\noindent\hrulefill

\textbf{Note:} For a legacy Maven application, you were able to deploy
it by right-clicking it in the Package Explorer and selecting
\emph{Liferay} → \emph{Maven} → \emph{liferay:deploy}. This is no longer
possible because Liferay's Maven archetypes no longer rely on the legacy
\texttt{liferay-maven-plugin}. To deploy Maven projects in @ide@, make
sure to follow the methods described above.

\noindent\hrulefill

That's it! Once your module is deployed to the Liferay server, you can
verify its installation in @ide@'s Console window.

\section{Managing Module Projects with Liferay
@ide@}\label{managing-module-projects-with-liferay-ide}

Liferay @ide@ provides the ability to manage Liferay module projects
from a GUI. Before you begin learning about managing your modules from
Liferay @ide@, you should make sure a Liferay server is configured in
your Eclipse workspace so you can deploy and run your projects. You can
learn how to create a Liferay bundle and link it to your Liferay
workspace in the
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-a-liferay-workspace-with-liferay-ide}{Creating
a Liferay Workspace with Liferay @ide@} tutorial.

Once you've created modules, you can deploy them using Liferay @ide@.
First, make sure your Liferay server is started by clicking the
\emph{Start Server} button
(\includegraphics{./images/icon-start-server.png}). Then navigate
to your module project from the Project Explorer and drag-and-drop the
project onto the configured Liferay bundle in the \emph{Servers} menu.
If at any time you'd like to stop your Liferay server, click the
\emph{Stop Server} button
(\includegraphics{./images/icon-stop-server.png}). Awesome!
You've deployed a module to your running Liferay instance!

For the deployed module project, you can check if it has been deployed
successfully by using
\href{/docs/7-0/reference/-/knowledge_base/r/using-the-felix-gogo-shell}{Gogo
Shell}. Right-click the started portal in server view and select
\emph{Open Gogo Shell}.

\begin{figure}
\centering
\includegraphics{./images/open-gogo-shell.png}
\caption{Select \emph{Open Gogo Shell} to open a terminal window in
@ide@ using Gogo shell.}
\end{figure}

A Gogo shell terminal appears, allowing you to enter Gogo commands to
inspect your Liferay instance and the modules deployed to it. Enter the
\texttt{lb} command to view a list of deployed modules. If the project
status is active, then it deployed successfully.

\begin{figure}
\centering
\includegraphics{./images/gogo-deploy-successful.png}
\caption{You can check to see if your module deployed successfully to
Liferay using the Gogo shell.}
\end{figure}

Since the Liferay Workspace perspective in @ide@ is Gradle-based, you
have some additional Gradle features you can take advantage of. The
Gradle Tasks toolbar presents Gradle commands for your workspace that
you can execute with a click of the mouse.

\begin{figure}
\centering
\includegraphics{./images/gradle-task-toolbar.png}
\caption{The Gradle Task toolbar offers Gradle tasks and their
descriptions, which can be executed by double-clicking them.}
\end{figure}

You can also access various Gradle build operations intended for Liferay
module projects. Right-click your module project and select
\emph{Liferay} → \emph{Gradle} and then the build command you want to
execute.

\begin{figure}
\centering
\includegraphics{./images/gradle-build-operations.png}
\caption{You can execute build operations by right-clicking the Gradle
project in the Project Explorer.}
\end{figure}

To learn more about Gradle development in Liferay @ide@, see the
\href{/docs/7-0/tutorials/-/knowledge_base/t/using-gradle-in-liferay-ide}{Using
Gradle in Liferay @ide@} tutorial.

Excellent! You've learned how to manage your Gradle-based Liferay
Workspace using Liferay @ide@.

\section{Installing a Server in Liferay
@ide@}\label{installing-a-server-in-liferay-ide}

Installing a server in Liferay @ide@ is easy. In just a few steps you'll
have your server up and running. Follow these steps to install your
server:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In the Servers view, click the \emph{No Servers are available} link.
  If you already have a server installed, you can install a new server
  by right-clicking in the Servers view and selecting \emph{New} →
  \emph{Server}. This brings up a wizard that walks you through the
  process of defining a new server.
\item
  Select the type of server you would like to create from the list of
  available options. For a standard server, open the \emph{Liferay,
  Inc.} folder and select the \emph{Liferay 7.x} option. You can change
  the server name to something more unique too; this is the name
  displayed in the Servers view. Then click \emph{Next}. If you're
  creating a server for the first time, continue to the next step.

  \begin{figure}
  \centering
  \includegraphics{./images/define-new-server.png}
  \caption{Choose the type of server you want to create.}
  \end{figure}

  \textbf{Note:} If you've already configured previous Liferay servers,
  you'll be provided the \emph{Server runtime environment} field, which
  lets you choose previously configured runtime environments. If you
  want to re-add an existing server, select one from the dropdown menu.
  You can also add a new server by selecting \emph{Add}, or you can edit
  existing servers by selecting \emph{Configure runtime environments}.
  Once you've configured the server runtime environment, select
  \emph{Finish}. If you selected an existing server, your server
  installation is finished; you can skip steps 3-5.
\item
  Enter a name for your server. This is the name for the Liferay DXP
  runtime configuration used by @ide@. This is not the display name used
  in the Servers tab.
\item
  Browse to the installation folder of the Liferay DXP bundle. For
  example,
  \texttt{C:\textbackslash{}liferay-ce-portal-7.0-ga4\textbackslash{}tomcat-8.0.32}.

  \begin{figure}
  \centering
  \includegraphics{./images/specify-directory.png}
  \caption{Specify the installation folder of the bundle.}
  \end{figure}
\item
  Select a runtime JRE and click \emph{Finish}. Your new server appears
  under the Servers view.

  \begin{figure}
  \centering
  \includegraphics{./images/new-server-added.png}
  \caption{Your new server appears under the \emph{Servers} view.}
  \end{figure}
\end{enumerate}

Your server is now available in Liferay @ide@!

For reference, here's how the Liferay DXP server buttons work with your
Liferay DXP instance:

\begin{itemize}
\tightlist
\item
  \emph{Start}
  (\includegraphics{./images/icon-start-server.png}): Starts the
  server.
\item
  \emph{Stop} (\includegraphics{./images/icon-stop-server.png}):
  Stops the the server.
\item
  \emph{Debug}
  (\includegraphics{./images/icon-debug-server.png}): Starts the
  server in debug mode. For more information on debugging in Eclipse,
  see the
  \href{https://eclipse.org/community/eclipse_newsletter/2017/june/article1.php}{Eclipse
  Debugging} article.
\end{itemize}

Now you're ready to use your server in Liferay @ide@!

\section{Searching Liferay DXP Source in Liferay
@ide@}\label{searching-liferay-dxp-source-in-liferay-ide}

In Liferay Liferay DXP, you can search through Liferay DXP's source code
to aid in the development of your project. Liferay provides great
resources to help with development (e.g., official documentation,
\href{https://docs.liferay.com/}{docs.liferay.com},
\href{/docs/7-0/reference/-/knowledge_base/r/sample-modules}{sample
projects}, etc.), but sometimes, searching through Liferay's codebase
(i.e., platform and official apps) for patterns is just as useful. For
example, if you're creating a custom app that extends a class provided
in Liferay's \texttt{portal-kernel} JAR, you can inspect that class and
research how it's used in other areas of Liferay DXP's codebase.

To do this, you must be developing in a
\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-workspace}{Liferay
Workspace}. Liferay Workspace is able to provide this functionality by
targeting a specific Liferay DXP version, which indexes the configured
Liferay DXP source code to provide advanced search. See the
\href{/docs/7-0/tutorials/-/knowledge_base/t/managing-the-target-platform-for-liferay-workspace}{Managing
the Target Platform in Liferay Workspace} tutorial for more information
on how this works.

Workspace does not perform portal source indexing by default. You must
enable this functionality by adding the following property to your
workspace's \texttt{gradle.properties} file:

\begin{verbatim}
target.platform.index.sources=true
\end{verbatim}

\noindent\hrulefill

\textbf{Note:} Portal source indexing is disabled in Gradle workspace
version 2.0.3+ (Target Platform plugin version 2.0.0+).

\noindent\hrulefill

In this tutorial, you'll explore three use cases where advanced search
would be useful.

\begin{itemize}
\tightlist
\item
  \hyperref[search-class-hierarchy]{Search class hierarchy}
\item
  \hyperref[search-method-declarations]{Search declarations}
\item
  \hyperref[search-annotation-references]{Search references}
\end{itemize}

These examples are just a small subset of what you can search in Liferay
@ide@. See Eclipse's documentation on
\href{http://help.eclipse.org/oxygen/index.jsp?topic=\%2Forg.eclipse.jdt.doc.user\%2Fconcepts\%2Fconcept-java-search.htm&resultof=\%22\%6a\%61\%76\%61\%22\%20}{Java
Search} for a comprehensive guide.

\subsection{Search Class Hierarchy}\label{search-class-hierarchy}

Inspecting classes that extend a similar superclass can help you find
useful patterns and examples for how you can develop your own app. For
example, suppose your app extends the
\href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/bridges/mvc/MVCPortlet.html}{MVCPortlet}
class. You an search classes that extend that same class in @ide@ by
right-clicking the \texttt{MVCPortlet} declaration and selecting
\emph{Open Type Hierarchy}. This opens a window that lets you inspect
all classes residing in the target platform that extend
\texttt{MVCPortlet}.

\begin{figure}
\centering
\includegraphics{./images/open-type-hierarchy.png}
\caption{Browse the Type Hierarchy window and open the provided classes
for examples on how to extend a class.}
\end{figure}

Great! Now you can search for all extensions and implementations of a
class/interface to aid in your quest for developing the perfect app.

\subsection{Search Method
Declarations}\label{search-method-declarations}

Sometimes you want a search to be more granular, exploring the
declarations of a specific method provided by a class/interface. Liferay
@ide@'s advanced search has no limits; Liferay Workspace's target
platform indexing provides method exploration too!

Suppose in the
\href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/bridges/mvc/MVCPortlet.html}{MVCPortlet}
class you're extending, you'd like to search for declarations of its
\texttt{doView} method you're overriding. You can do this by
right-clicking the \texttt{doView} method declaration in your custom
app's class and selecting \emph{Declarations} → \emph{Workspace}.

\begin{figure}
\centering
\includegraphics{./images/inspect-declared-method.png}
\caption{All declarations of the method are returned in the Search
window.}
\end{figure}

The rendered Search window displays the other occurrences in the target
platform where that method was overridden.

\subsection{Search Annotation
References}\label{search-annotation-references}

Annotations used in Liferay DXP's source code can sometimes be cryptic.
With the ability to search where these types of annotations reside in
Liferay's target platform, you can find how they could be used in your
own app.

For example, you may find some official documentation on using the
\texttt{@Reference} annotation in an OSGi module and implement it in
your custom app. It could be useful to reference real world examples in
Liferay DXP's apps to check how it was used elsewhere. You could search
for this by right-clicking the annotation in a class and selecting
\emph{References} → \emph{Workspace}.

\begin{figure}
\centering
\includegraphics{./images/inspect-references-ide.png}
\caption{All matching annotations are displayed in the Search window.}
\end{figure}

The rendered Search window displays the other occurrences in the target
platform where that annotation was used.

Excellent! You now have the tools to search the configured target
platform specified in your Liferay Workspace!

\section{Debugging Liferay DXP Source in Liferay
@ide@}\label{debugging-liferay-dxp-source-in-liferay-ide}

You can use Liferay Liferay DXP to debug Liferay DXP source code to help
resolve errors. Debugging Liferay DXP code follows most of the same
techniques associated with debugging in Eclipse. If you need some help
with general debugging, you can visit Eclipse's documentation. Here's
some helpful Eclipse links to visit:

\begin{itemize}
\tightlist
\item
  \href{http://help.eclipse.org/oxygen/index.jsp?topic=\%2Forg.eclipse.jdt.doc.user\%2Fconcepts\%2Fcdebugger.htm&cp=1_2_9}{Debugger}
\item
  \href{http://help.eclipse.org/oxygen/index.jsp?topic=\%2Forg.eclipse.jdt.doc.user\%2Fconcepts\%2Fclocdbug.htm&cp=1_2_11}{Local
  Debugging}
\item
  \href{http://help.eclipse.org/oxygen/index.jsp?topic=\%2Forg.eclipse.jdt.doc.user\%2Fconcepts\%2Fcremdbug.htm&cp=1_2_12}{Remote
  Debugging}
\end{itemize}

There are a couple Liferay-specific configurations to know before
debugging Liferay DXP code:

\begin{itemize}
\tightlist
\item
  \hyperref[configure-your-target-platform]{Configure your target
  platform.}
\item
  \hyperref[configure-a-liferay-server-and-start-it-in-debug-mode]{Configure
  a Liferay server and start it in debug mode.}
\end{itemize}

Let's explore these Liferay-specific debugging configurations.

\subsection{Configure Your Target
Platform}\label{configure-your-target-platform}

To configure your target platform, you must be developing in a
\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-workspace}{Liferay
Workspace}. Liferay Workspace is able to provide debugging capabilities
by targeting a specific Liferay DXP version, which indexes the
configured Liferay DXP source code. You must enable this functionality by
adding the following property to your workspace's
\texttt{gradle.properties} file:

\begin{verbatim}
target.platform.index.sources=true
\end{verbatim}

\noindent\hrulefill

\textbf{Note:} Portal source indexing is disabled in Gradle workspace
version 2.0.3+ (Target Platform plugin version 2.0.0+).

\noindent\hrulefill

Without specifying a target platform, Liferay DXP's source code cannot
be accessed by @ide@. See the
\href{/docs/7-0/tutorials/-/knowledge_base/t/managing-the-target-platform-for-liferay-workspace}{Managing
the Target Platform for Liferay Workspace} tutorial for more information
on how this works.

\textbf{Important:} The target platform should match the Liferay server
version you configure in the next section.

Once the target platform is configured in your workspace, Eclipse has
access to all of Liferay DXP's source code. Next, you'll configure a
Liferay server and learn how to start it in Debug mode.

\subsection{Configure a Liferay Server and Start It in Debug
Mode}\label{configure-a-liferay-server-and-start-it-in-debug-mode}

Configuring your target platform gives Eclipse Liferay DXP's source code
to reference. Now you must configure a Liferay server matching the
target platform version so you can deploy the custom code you wish to
debug.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Set up your Liferay DXP server to run in @ide@. See the
  \href{/docs/7-0/tutorials/-/knowledge_base/t/installing-a-server-in-liferay-ide}{Installing
  a Server in Liferay @ide@} for more details.
\item
  Start the server in debug mode. To do this, click the debug button in
  the Servers pane of Liferay @ide@.

  \begin{figure}
  \centering
  \includegraphics{./images/ide-debug.png}
  \caption{The red box in this screenshot highlights the debug button.
  Click this button to start the server in debug mode.}
  \end{figure}
\end{enumerate}

Awesome! You're now equipped to begin debugging in Liferay @ide@!

\section{Enabling Code Assist Features in Your
Project}\label{enabling-code-assist-features-in-your-project}

Liferay @ide@'s integration of \href{http://ternjs.net/}{Tern} provides
many valuable front-end and back-end development tools for code
inference and completion. This tutorial covers how to enable Tern
features for your projects.

Before beginning this tutorial, make sure your @ide@ instance has the
necessary development tooling and Tern integration installed. To to
this, go to \emph{Help} → \emph{Installation Details} and search for
\emph{Liferay IDE AlloyUI} under \emph{Installed Software}. If you have
it installed, you can continue to the \emph{Setting Up Tern Features}
section; if you do not, you'll need to install it by following the
instructions below.

Navigate to \emph{Help} → \emph{Install New Software\ldots{}} and paste
the following link into the \emph{Work with} field:

\begin{verbatim}
http://releases.liferay.com/tools/ide/latest/stable/
\end{verbatim}

Make sure the \emph{Liferay IDE AlloyUI} option is checked and finish
the installation process.

\begin{figure}
\centering
\includegraphics{./images/alloyui-ide-feature.png}
\caption{The \emph{Liferay IDE AlloyUI} option is actually a sub-option
listed within the \emph{Liferay IDE} option.}
\end{figure}

Now that the necessary features are installed, follow the steps below to
learn how to enable Tern's code assist features in your project.

\subsection{Setting Up Tern Features}\label{setting-up-tern-features}

Tern features are enabled on a project-by-project basis. By default,
Tern is already enabled for Liferay portlet plugins. For all other
project types, you'll need to follow the steps below:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Right-click on your project and select \emph{Configure} →
  \emph{Convert to Tern Project}.

  Your project is now configured to use Tern. Now that you have your
  project configured, you need to enable the modules you want to use for
  your project.
\item
  Right-click your project and select \emph{Properties}.
\item
  Select \emph{Tern} → \emph{Modules}.

  Here you'll find a list of all the available Tern modules you
  currently have installed. To use AlloyUI features, you'll need the
  \emph{AlloyUI}, \emph{Browser}, \emph{JSCS}, \emph{Liferay}, and
  \emph{YUI Library} modules enabled. The figure below shows the Tern
  Modules menu.

  \begin{figure}
  \centering
  \includegraphics{./images/tern-modules.png}
  \caption{By selecting these Tern modules, you can use AlloyUI code
  assist features in your project.}
  \end{figure}
\item
  Check any additional modules you wish to use in your project and click
  \emph{OK}.
\end{enumerate}

Your project is now set up to use @ide@'s Tern features.

\subsection{Related Topics}\label{related-topics-21}

\href{/docs/7-0/tutorials/-/knowledge_base/t/using-front-end-code-assist-features-in-ide}{Using
Front-End Code Assist Features in @ide@}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-modules-with-liferay-ide}{Creating
Modules with Liferay @ide@}

\href{/docs/7-0/tutorials/-/knowledge_base/t/blade-cli}{Blade CLI}

\section{Using Gradle in Liferay
@ide@}\label{using-gradle-in-liferay-ide}

\href{http://gradle.org/}{Gradle} is a popular open source build
automation system. You can take full advantage of Gradle in Liferay
@ide@ by utilizing
\href{https://projects.eclipse.org/releases/oxygen}{Buildship}, which is
a collection of Eclipse plugin-ins that provide support for building
software using Gradle with Liferay @ide@. Buildship is bundled with
Liferay @ide@ versions 3.0 and higher.

\begin{figure}
\centering
\includegraphics{./images/buildship-in-liferayide.png}
\caption{Navigate to \emph{Help} → \emph{Installation Details} to view
plugins included in Liferay @ide@.}
\end{figure}

The first thing you'll learn about in this tutorial is creating Gradle
projects in @ide@.

\subsection{Creating and Importing Gradle
Projects}\label{creating-and-importing-gradle-projects}

You can create a Gradle project by using the Gradle Project wizard.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Navigate to \emph{File} → \emph{New} → \emph{Project\ldots{}} and
  select \emph{Gradle} → \emph{Gradle Project}. Finally, click
  \emph{Next} → \emph{Next}.
\item
  Enter a valid project name. You can also specify your project location
  and working sets.
\item
  Optionally, you can navigate to the next page and specify your Gradle
  distribution and other advanced options. Once you're finished, select
  \emph{Finish}.
\end{enumerate}

\begin{figure}
\centering
\includegraphics{./images/new-gradle-project.png}
\caption{You can specify your Gradle distribution and advanced options
such as home directories, JVM options, and program arguments.}
\end{figure}

You can also import existing Gradle projects in Liferay @ide@.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Go to \emph{File} → \emph{Import\ldots{}} → \emph{Gradle} →
  \emph{Gradle Project} → \emph{Next} → \emph{Next}.

  \begin{figure}
  \centering
  \includegraphics{./images/import-gradle-project.png}
  \caption{You can specify what Gradle project to import from the
  \emph{Import Gradle Project} wizard.}
  \end{figure}
\item
  Click the \emph{Browse\ldots{}} button to choose a Gradle project.
\item
  Optionally, you can navigate to the next page and specify your Gradle
  distribution and other advanced options. Once you're finished, click
  \emph{Next} again to review the import configuration. Select
  \emph{Finish} once you've confirmed your Gradle project import.

  \begin{figure}
  \centering
  \includegraphics{./images/import-configuration-overview.png}
  \caption{You can preview your Gradle project's import information.}
  \end{figure}
\end{enumerate}

Next you'll learn about Gradle tasks and executions, and learn how to
run and display them in Liferay @ide@.

\subsection{Gradle Tasks and
Executions}\label{gradle-tasks-and-executions}

Liferay @ide@ provides two views to enhance your developing experience
using Gradle: Gradle Tasks and Gradle Executions. You can open these
views by following the instructions below.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Go to \emph{Window} → \emph{Show View} → \emph{Other\ldots{}}.
\item
  Navigate to the \emph{Gradle} folder and open \emph{Gradle Tasks} and
  \emph{Gradle Executions}.
\end{enumerate}

Gradle tasks and executions views open automatically once you create or
import a Gradle project.

The Gradle Tasks view allows you to display the Gradle tasks available
for you to use in your Gradle project. Users can execute a task listed
under the Gradle project by double-clicking it.

\begin{figure}
\centering
\includegraphics{./images/gradle-tasks.png}
\caption{Navigate into your preferred Gradle project to view its
available Gradle tasks.}
\end{figure}

Once you've executed a Gradle task, you can open the Gradle Executions
view to inspect its output.

\begin{figure}
\centering
\includegraphics{./images/gradle-executions.png}
\caption{The Gradle Executions view helps you visualize the Gradle build
process.}
\end{figure}

Keep in mind that if you change the Gradle build scripts inside your
Gradle projects (e.g., \texttt{build.gradle} or
\texttt{settings.gradle}), you must refresh the project so Liferay @ide@
can account for the change and display it properly in your views. To
refresh a Gradle project, right-click on the project and select
\emph{Gradle} → \emph{Refresh Gradle Project}.

\begin{figure}
\centering
\includegraphics{./images/refresh-gradle-project.png}
\caption{Make sure to always refresh your Gradle project in Liferay
@ide@ after build script edits.}
\end{figure}

If you prefer Eclipse refresh your Gradle projects automatically,
navigate to \emph{Window} → \emph{Preferences} → \emph{Gradle} and
enable the \emph{Automatic Project Synchronization} checkbox. If you'd
like to enable Gradle's automatic synchronization for just one Gradle
project, you can right-click a Gradle project and select
\emph{Properties} → \emph{Gradle} and enable auto sync that way. This
feature is available in Buildship version 2.2+, so make sure you have
the required version.

Excellent! You're now equipped with the knowledge to add, import, and
build your Gradle projects in Liferay @ide@!

\section{Using Maven in Liferay @ide@}\label{using-maven-in-liferay-ide}

You can take full advantage of Maven in Liferay @ide@ with its built-in
Maven support. In this tutorial, you'll learn about the following
topics:

\begin{itemize}
\tightlist
\item
  \hyperref[installing-maven-plugins-for-liferay-ide]{Installing Maven
  Plugins for Liferay @ide@}
\item
  \hyperref[creating-maven-projects]{Creating Maven Projects}
\item
  \hyperref[importing-maven-projects]{Importing Maven Projects}
\item
  \hyperref[using-the-pom-graphic-editor]{Using the POM Graphic Editor}
\end{itemize}

First you'll install the necessary Maven plugins for Liferay @ide@.

\subsection{Installing Maven Plugins for Liferay
@ide@}\label{installing-maven-plugins-for-liferay-ide}

In order to support Maven projects in @ide@ properly, you first need a
mechanism to recognize Maven projects as Liferay @ide@ projects. @ide@
projects are recognized in Eclipse as faceted web projects that include
the appropriate Liferay plugin facet. Therefore, all @ide@ projects are
also Eclipse web projects (faceted projects with the web facet
installed). In order for @ide@ to recognize the Maven project and for it
to be able to leverage Java EE tooling features (e.g., the Servers view)
with the project, the project must be a flexible web project. Liferay
@ide@ relies on the following Eclipse plugins to provide this
capability:

\begin{itemize}
\tightlist
\item
  \texttt{m2e-core} (Maven integration for Eclipse)
\item
  \texttt{m2e-wtp} (Maven integration for WTP)
\end{itemize}

All you have to do is install them so you can begin developing Maven
projects for Liferay DXP.

When first installing Liferay @ide@, the installation startup screen
lets you select whether you'd like to install the Maven plugins
automatically. Don't worry if you missed this during setup. You'll learn
how to install the required Maven plugins for @ide@ manually below.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Navigate to \emph{Help} → \emph{Install New Software}. In the
  \emph{Work with} field, insert the following value:

\begin{verbatim}
Liferay IDE repository - http://releases.liferay.com/tools/ide/latest/milestone/
\end{verbatim}
\item
  Check the \emph{Liferay IDE Maven Support} option. This bundles all
  the required Maven plugins you need to begin developing Maven projects
  for Liferay DXP.

  \begin{figure}
  \centering
  \includegraphics{./images/maven-install-ide-plugins.png}
  \caption{You can install all the necessary Maven plugins for @ide@ by
  installing the \emph{Liferay IDE Maven Support} option.}
  \end{figure}

  If the \emph{Liferay IDE Maven Support} option does not appear, then
  it's already installed. To verify that it's installed, uncheck the
  \emph{Hide items that are already installed} checkbox and look for
  \emph{Liferay IDE Maven Support} in the list of installed plugins.
  Also, if you'd like to view everything that is bundled with the
  \emph{Liferay IDE Maven Support} option, uncheck the \emph{Group items
  by category} checkbox.
\item
  Click \emph{Next}, review the install details, accept the term and
  license agreements, and select \emph{Finish}.
\end{enumerate}

Awesome! Your Liferay DXP is ready to develop Maven projects for
Liferay DXP!

You'll learn about creating Maven projects in @ide@ next.

\subsection{Creating Maven Projects}\label{creating-maven-projects}

You can create a Maven project based on Liferay's provided Maven
archetypes.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Navigate to \emph{File} → \emph{New} → \emph{Liferay Module Project}.
\item
  Give your project a name, select the \texttt{maven-module} build type,
  and choose the project template (archetype) you'd like to use.

  \begin{figure}
  \centering
  \includegraphics{./images/create-maven-ide-project.png}
  \caption{The New Liferay Module Project wizard lets you generate a
  Maven module project.}
  \end{figure}
\item
  (Optional) Click \emph{Next} and name your component class name and
  package. You can also specify your component class's properties in the
  Properties menu.
\item
  Click \emph{Finish}.
\end{enumerate}

That's it! You've created a Liferay module project using Maven!

If you created your Maven project outside of @ide@ with another tool,
you can still manage that project in @ide@, but you must first import
it. You'll learn how to do this next.

\subsection{Importing Maven Projects}\label{importing-maven-projects}

To import a pre-existing Maven project into Liferay @ide@, follow the
steps outlined below:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Navigate to \emph{File} → \emph{Import} → \emph{Maven} →
  \emph{Existing Maven Projects} and click \emph{Next}.

  \begin{figure}
  \centering
  \includegraphics{./images/import-maven-project.png}
  \caption{@ide@ offers the Maven folder in the Import wizard.}
  \end{figure}
\item
  Click \emph{Browse\ldots{}} and select the root folder for your Maven
  project. Once you've selected it, the \texttt{pom.xml} for that
  project should be visible in the Projects menu.

  \begin{figure}
  \centering
  \includegraphics{./images/select-maven-import.png}
  \caption{Use the Import Maven Projects wizard to import your
  pre-existing project.}
  \end{figure}
\item
  Click \emph{Finish}.
\end{enumerate}

Now your Maven project is available from the Package Explorer. Next
you'll learn about Liferay @ide@'s POM graphical editor.

\subsubsection{Using the POM Graphic
Editor}\label{using-the-pom-graphic-editor}

You're provided a nifty POM graphic editor when opening your Maven
project's \texttt{pom.xml} in Liferay @ide@. This gives you several
different ways to leverage the power of Maven in your project:

\begin{itemize}
\item
  \textbf{Overview:} provides a graphical interface where you can add to
  and edit the \texttt{pom.xml} file.
\item
  \textbf{Dependencies:} provides a graphical interface for adding and
  editing dependencies in your project, as well as modifying the
  \texttt{dependencyManagement} section of the \texttt{pom.xml} file.
\item
  \textbf{Effective POM:} provides a read-only version of your project
  POM merged with its parent POM(s), \texttt{settings.xml}, and the
  settings in Eclipse for Maven.
\item
  \textbf{Dependency Hierarchy:} provides a hierarchical view of project
  dependencies and an interactive listing of resolved dependencies.
\item
  \textbf{pom.xml:} provides an editor for your POM's source XML.
\end{itemize}

The figure below shows the \texttt{pom.xml} file editor and its modes.

\begin{figure}
\centering
\includegraphics{./images/pom-editor-features.png}
\caption{Liferay @ide@ provides five interactive modes to help you edit
and organize your POM..}
\end{figure}

By taking advantage of these interactive modes, Liferay @ide@ makes
modifying and organizing your POM and its dependencies a snap!

\section{Using Front-End Code Assist Features in
@ide@}\label{using-front-end-code-assist-features-in-ide}

Liferay @ide@ provides extended front-end development tools to assist in
Liferay development. You now have access to code inferencing and code
completion features for AlloyUI, JavaScript, CSS, and jQuery.

This tutorial covers how to use the code assist features for AlloyUI,
JavaScript, CSS, and jQuery in @ide@. Each language is covered in its
own section, so you can navigate to the language you're most interested
in. Continue reading to find out how to use @ide@'s code assist features
in your project.

\subsection{Using Code Assist
Features}\label{using-code-assist-features}

@ide@'s integration of \href{http://ternjs.net/}{Tern} gives you access
to code assist in JavaScript, AlloyUI, and CSS. To access these
features, you must be working in a JavaScript, JSP, HTML, or CSS file.

You must have Tern features enabled in your project in order to use
them. By default, Liferay portlet plugins already have Tern features
enabled. Visit the
\href{/docs/7-0/tutorials/-/knowledge_base/t/enabling-code-assist-features-in-your-project}{Enabling
Code Assist Features in your Project} tutorial to learn how to enable
Tern features for non-Liferay specific projects.

\noindent\hrulefill

\textbf{Note:} For those developing with the Plugins SDK, the taglib
descriptions that @ide@ makes available to users are dependent upon the
Plugins SDK version. @ide@ uses taglib descriptions from the current
SDK's \texttt{util-taglib.jar} file, so a more up-to-date Plugins SDK
means more up-to-date taglib descriptions.

\noindent\hrulefill

You'll begin testing the AlloyUI code assist features next.

\subsubsection{AlloyUI Code Assist
Features}\label{alloyui-code-assist-features}

There are several helpful code assist features that can improve your
productivity when writing code for AlloyUI. The example below shows how
to access the AlloyUI code assist features in the \texttt{main.js} of
your project:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open your project's \texttt{main.js} file and type the following code:

\begin{verbatim}
 AUI().
\end{verbatim}
\item
  Press \emph{Ctrl+Space} with your cursor to the right of
  \texttt{AUI().}. This brings up the code inference for the
  \texttt{AUI()} global object. Notice the AlloyUI framework's own API
  documentation is also displayed. Press \emph{Enter} to use code
  completion.
\end{enumerate}

\begin{figure}
\centering
\includegraphics{./images/code-inference.png}
\caption{This figure demonstrates code inference in a JS file.}
\end{figure}

\noindent\hrulefill

\textbf{Note:} Code assist not only works for methods of an object, but
also works for AUI-specific Tern completions for objects. For instance,
you could type \texttt{AU} and press \emph{Ctrl+Space} to see a list of
objects to choose from.

\noindent\hrulefill

By default, code inference is triggered by a keystroke combination;
however, you can enable auto activation in @ide@'s Preferences menu.
Follow the steps below to enable auto activation:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Navigate to \emph{Window} → \emph{Preferences} → \emph{JavaScript} →
  \emph{Editor} → \emph{Content Assist}.
\item
  Check the \emph{Enable auto activation} box and click \emph{Apply}.
  Then click \emph{OK}.
\end{enumerate}

The figure below shows how to enable auto activation:

\begin{figure}
\centering
\includegraphics{./images/enable-auto-activation.png}
\caption{The \emph{Enable auto activation} checkbox is listed below the
\emph{Auto-Activation} heading.}
\end{figure}

Now, if you follow the previous example, code inference activates as
soon as you press the trigger key, which in this case is the \emph{.}
(period) key.

In addition to general code inference for AlloyUI, you have access to
code templates. AUI JavaScript templates are available in Eclipse's
JavaScript editor as well as in the HTML/JSP editor when working with
\texttt{\textless{}script\textgreater{}} and
\texttt{\textless{}aui-script\textgreater{}} tags. Follow the steps
below to use AUI code templates:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Type the following code in your \texttt{main.js}:

\begin{verbatim}
AUI
\end{verbatim}
\item
  Press \emph{Ctrl+Space} to bring up the code inference for
  \texttt{AUI}, and you'll see a list of all the available AlloyUI code
  templates, along with documentation.

  \begin{figure}
  \centering
  \includegraphics{./images/code-template.png}
  \caption{@ide@ gives you access to AUI code templates in the JS and
  JSP editors.}
  \end{figure}
\item
  Select your template and hit \emph{Enter} to paste its contents into
  your \texttt{main.js}.
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** You can view all the AlloyUI code templates you have
 installed by going to @ide@'s Preferences menu and selecting *JavaScript*
 &rarr; *Editor* &rarr; *Templates*.
\end{verbatim}

\noindent\hrulefill

In addition to code inference in your JS files, you can also use code
inference in your JSP/HTML files using
\texttt{\textless{}aui:script\textgreater{}} tags.

Open one of your project's JSPs and add the AUI taglib directive if it
is not already in your JSP:

\begin{verbatim}
<%@ taglib uri="http://liferay.com/tld/aui" prefix="aui" %>
\end{verbatim}

You can also add the import from the Snippets menu under \emph{Taglib
imports} → \emph{Liferay AUI Taglib Import v6.1}.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add an \texttt{\textless{}aui:script\textgreater{}} tag inside your
  JSP and configure it to look like the following code:

\begin{verbatim}
 <aui:script>
     aui
 </aui:script>
\end{verbatim}
\item
  Press \emph{Ctrl+Space} with your cursor placed to the right of
  \texttt{aui} to bring up code inference.
\end{enumerate}

There you go! Whether in a JavaScript file or inside a JSP, you now have
access to code assist features that improve your workflow.

Next, you'll examine the JavaScript code assist features for @ide@.

\subsubsection{JavaScript Code Assist
Features}\label{javascript-code-assist-features}

In addition to AlloyUI code assist features, you also have access to
code inference and completion using raw JavaScript. This code assist
feature is available in your project because the Tern module
\texttt{Liferay} is enabled. This plugin provides code completions for
the static JavaScript object APIs available to portlets when running in
Liferay Portal. To learn more about enabling Tern modules in Eclipse,
refer to the
\href{/docs/7-0/tutorials/-/knowledge_base/t/enabling-code-assist-features-in-your-project}{Enabling
Code Assist Features in Your Project} tutorial.

The example below shows how you can use code assist features to easily
access functions in your portlet project.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open the \texttt{main.js} of your portlet and add the following
  function:

\begin{verbatim}
function say(text){
    alert(text);
}
\end{verbatim}
\item
  Add the following button to the \texttt{view.jsp} of your portlet:

\begin{verbatim}
<aui:button onClick=""/>
\end{verbatim}
\item
  Place your cursor within the quotation marks of the \texttt{onClick}
  attribute and press \emph{Ctrl+Space}. The code inference dialog pops
  up with a list of possible JavaScript functions available for you to
  use.
\item
  Type \emph{say} and you'll notice the list is narrowed down to your
  new \texttt{say(text)} function.

  \begin{figure}
  \centering
  \includegraphics{./images/js-code-inference.png}
  \caption{JavaScript code assist features give easy access to your
  functions.}
  \end{figure}
\item
  Select the \texttt{say(text)} function, and you'll notice that it's
  accompanied by documentation that provides the parameter for the
  function, as well as the file path where the function is located.
\item
  Press \emph{Enter} to use code completion and add the function to your
  button.
\end{enumerate}

As you can see, JavaScript development is a breeze using @ide@'s code
assist features. Now that you know how to use the AlloyUI and JavaScript
code assist features, you can learn how to use the CSS code assist
features next.

\subsubsection{CSS Code Assist Features}\label{css-code-assist-features}

@ide@ offers code inference and completion tools for CSS. In order to
use these tools, you'll need to install an additional plugin.

\noindent\hrulefill

\textbf{Note:} The plugin described below is planned to be bundled with
Liferay @ide@ in the near future. Initial tests of the plugin revealed
performance issues in some cases, which is why it is not yet a part of
Liferay @ide@. Problems were not consistent, so you may have no issues
installing the plugin, but we wanted to give full disclosure about it.

\noindent\hrulefill

Follow the steps below to install the plugin in @ide@:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Go to \emph{Help} → \emph{Install New Software\ldots{}}.
\item
  Paste the following link into the \texttt{Work\ with:} input field:

\begin{verbatim}
 http://oss.opensagres.fr/eclipse-wtp-webresources/1.1.0/
\end{verbatim}
\item
  Click \emph{Add\ldots{}} and check the box next to \emph{WTP HTML -
  Web Resources}.
\item
  Click \emph{Next} and follow the installation instructions.
\end{enumerate}

Now that your plugin is installed, you'll need to enable the CSS
features in your project. Right-click your project and go to
\emph{Properties} → \emph{Web Resources} → \emph{CSS}. Check both boxes
to enable CSS features in your project.

You have successfully installed and enabled the new CSS features in your
project!

Now that you have the CSS features enabled, you'll find out how to use
them next. Follow the steps below to use the CSS code assist features to
locate a CSS class. Note that the process below can also be used to
locate an ID.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open your \texttt{main.css} file and add the following class to it:

\begin{verbatim}
.sample-class {
    background-color:green;
}
\end{verbatim}
\item
  Inside your \texttt{view.jsp} add an
  \texttt{\textless{}aui:button/\textgreater{}} tag and configure it to
  match the following code:

\begin{verbatim}
<aui:button name="test" value="test" cssClass=""/>
\end{verbatim}
\item
  Within the quotations of the \texttt{cssClass}�attribute, press
  \emph{Ctrl+Space} to bring up the code inference for CSS. Begin typing
  \emph{sample-class} to narrow down the classes to the one you're
  looking for.

  \begin{figure}
  \centering
  \includegraphics{./images/css-code-inference.png}
  \caption{CSS code inference improves your workflow when developing in
  CSS.}
  \end{figure}

  Notice, along with code inference, you can also view the styling you
  have for the class, as well as the file in which it is located.
\item
  Press \emph{Enter} to use code completion and add the CSS class to the
  JSP.
\end{enumerate}

If you look at the code inference dialog for CSS classes, you'll also
notice that in addition to your own CSS classes, you also have access to
Bootstrap CSS classes found in Liferay Portal.

\noindent\hrulefill

\textbf{Note:} You can go to the file that the class, ID, or function is
located in by hovering over top of it in your JSP and holding down the
\texttt{Ctrl} (Windows) or \texttt{command} (Mac) key, and clicking the
hyperlink that appears.

\noindent\hrulefill

Lastly, you'll learn about the code assist features for jQuery.

\subsubsection{jQuery Code Assist
Features}\label{jquery-code-assist-features}

You can also use code assist with jQuery. To do this, you must enable
the \texttt{jQuery} Tern module. Follow the instructions in the
\href{/docs/7-0/tutorials/-/knowledge_base/t/enabling-code-assist-features-in-your-project}{Enabling
Code Assist Features in Your Project} tutorial to learn how to enable
Tern modules in your project.

The jQuery Tern plugin gives type information for the jQuery framework.
In the example below, you'll test the jQuery code assist feature.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open your project's \texttt{jquery.js} file.
\item
  In the file, type the following sample variable:

\begin{verbatim}
var form = 
\end{verbatim}
\item
  Press \emph{Ctrl+Space} to bring up the code inference for the
  variable you're declaring, and you'll see a list of everything that is
  available. Also notice jQuery documentation is available for each
  method. Take a look at the figure below for an example of using code
  assit in jQuery.

  \begin{figure}
  \centering
  \includegraphics{./images/jquery-js-1.png}
  \caption{Using the jQuery code assist features gives you the
  convenience of showing you what's available, and the documentation
  behind each option.}
  \end{figure}
\end{enumerate}

Furthermore, for jQuery callback handlers, the type information for
parameters is also made available.

\begin{figure}
\centering
\includegraphics{./images/jquery-js-2.png}
\caption{jQuery code assist also displays type information for
parameters.}
\end{figure}

Excellent! You now know how to use @ide@'s front-end development code
assist features to improve your workflow.

\subsection{Related Topics}\label{related-topics-22}

\href{/docs/7-0/tutorials/-/knowledge_base/t/enabling-code-assist-features-in-your-project}{Enabling
Code Assist Features in your Project}

\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-workspace}{Liferay
Workspace}

\href{/docs/7-0/tutorials/-/knowledge_base/t/from-liferay-6-to-liferay-7}{From
Liferay 6 to 7.0}

\chapter{Blade CLI}\label{blade-cli}

The \href{https://github.com/liferay/liferay-blade-cli/}{Blade CLI} is
the easiest way for Liferay developers to create new Liferay modules.
Although the Plugins SDK is also supported, Blade CLI lets you create
projects that can be used with any IDE or development environment. Blade
CLI is a command line tool bootstrapped on to a Gradle based environment
that is used to build Liferay 7.0 modules. This tool set provides a host
of sub-commands that help Liferay developers create and deploy modules
to a Liferay instance. The following sub-commands are callable in the
Blade CLI environment:

\begin{itemize}
\tightlist
\item
  \emph{convert}: Converts a Plugins SDK plugin project to a Gradle
  Workspace project.
\item
  \emph{create}: Creates a new Liferay module project from available
  templates.
\item
  \emph{deploy}: Builds and deploys bundles to the Liferay module
  framework.
\item
  \emph{gw}: Executes Gradle command using the Gradle Wrapper, if
  detected.
\item
  \emph{help}: Gives help on a specific command.
\item
  \emph{init}: Initializes a new Liferay Workspace.
\item
  \emph{install}: Installs a bundle into Liferay's module framework.
\item
  \emph{open}: Opens or imports a file or project in Liferay @ide@.
\item
  \emph{samples}: Generates a sample project.
\item
  \emph{server}: Starts or stops server defined by your Liferay project.
\item
  \emph{sh}: Connects to Liferay and executes Gogo command and returns
  output.
\item
  \emph{update}: Updates Blade CLI to latest version.
\item
  \emph{upgradeProps:} Analyzes your old \texttt{portal-ext.properties}
  and your newly installed 7.x server to show you properties moved to
  OSGi configuration files or removed from the product.
\item
  \emph{version}: Displays version information about Blade CLI.
\end{itemize}

In this set of tutorials, you'll learn how to use these commands to
create and test Liferay modules.

\section{Installing Blade CLI}\label{installing-blade-cli}

You can install Blade CLI using the Liferay Project SDK installer. This
installs JPM and Blade CLI into your user home folder and optionally
initializes a
\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-workspace}{Liferay
Workspace} folder.

\noindent\hrulefill

\textbf{Note:} In the past, if you've installed Blade CLI globally
(e.g., using \texttt{sudo}), you should not run the installer to
\emph{update} your Blade CLI version. Since the installer only installs
Blade CLI to your user home folder, your previous global installation
would always override the installer's installation. Therefore, always
follow the
\href{/docs/7-0/tutorials/-/knowledge_base/t/updating-blade-cli}{Updating
Blade CLI} tutorial to update your Blade CLI instance.

\noindent\hrulefill

If you need to configure proxy settings for Blade CLI, follow the
\href{/docs/7-0/tutorials/-/knowledge_base/t/setting-blade-cli-proxy-requirments}{Installing
Blade CLI with Proxy Requirements}

Follow the steps below to download and install Blade CLI:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Download the latest
  \href{https://sourceforge.net/projects/lportal/files/Liferay\%20IDE/}{Liferay
  Project SDK installer} that corresponds with your operating system
  (e.g., Windows, MacOS, or Linux). The Project SDK installer is listed
  under \emph{Liferay IDE}, so the folder versions are based on IDE
  releases. You can select an installer that does not include @ide@, if
  you don't intend to use it. The Project SDK installer is available for
  versions 3.2.0+. Do \textbf{not} select the large green download
  button; this downloads Liferay Portal instead.
\item
  Run the installer. Click \emph{Next} to step through the installer's
  introduction.
\item
  If you'd like to initialize a Liferay Workspace, you can set the
  directory where it should go.

  \begin{figure}
  \centering
  \includegraphics{./images/blade-installer-workspace-init.png}
  \caption{Determine where your Liferay Workspace should reside, if you
  want one.}
  \end{figure}

  Select the \emph{Don't initialize Liferay Workspace directory} option
  if you only want to install Blade CLI. Then click \emph{Next}.
\item
  If you decided to initialize a Liferay Workspace folder in the
  previous step, you'll have an additional option to select the Liferay
  product type you'll use with your workspace. Choose the product type
  and click \emph{Next}.

  \begin{figure}
  \centering
  \includegraphics{./images/installer-workspace-type.png}
  \caption{Select the product version you'll use with your Liferay
  Workspace.}
  \end{figure}
\item
  Click \emph{Next} to begin installing Blade CLI/Liferay Workspace on
  your computer.
\end{enumerate}

That's it! Blade CLI is installed on your machine! If you specified a
location to initialize a Liferay Workspace folder, that is also
available.

Blade CLI offers many
\href{/docs/7-0/reference/-/knowledge_base/r/project-templates}{\texttt{create}
templates} to help build 7.0 applications. It also offers various ways
to deploy those apps and interact with your Liferay server. Be sure to
explore more Blade CLI tutorials to learn how.

\subsection{Installer Issues on macOS}\label{installer-issues-on-macos}

If you're using macOS or Linux, you could experience an issue where the
\texttt{blade} command is not available via command line. This is caused
by the installer being unable to add JPM's \texttt{bin} folder to your
user path. JPM is a Java package manager used in Blade CLI.

To add the required \texttt{bin} folder, execute the appropriate command
based on your operating system.

macOS:

\begin{verbatim}
echo 'export PATH="$PATH:$HOME/Library/PackageManager/bin"' >> ~/.bash_profile
\end{verbatim}

Linux:

\begin{verbatim}
echo 'export PATH="$PATH:$HOME/jpm/bin"' >> ~/.bash_profile
\end{verbatim}

Once you restart the command line, the \texttt{blade} command should be
available.

\section{Installing Blade CLI with Proxy
Requirements}\label{installing-blade-cli-with-proxy-requirements}

If you have proxy server requirements and want to use Blade CLI, you
must configure your http(s) proxy for it using JPM. Before beginning,
make sure you've installed JPM and Blade CLI using a Liferay Workspace
installer. Read the
\href{/docs/7-0/tutorials/-/knowledge_base/t/installing-blade-cli}{Installing
Blade CLI} tutorial for more details.

Once Blade CLI and JPM are installed, execute the following command to
configure your proxy requirements for Blade CLI:

\begin{verbatim}
jpm command --jvmargs "-Dhttp(s).proxyHost=[your proxy host] -Dhttp(s).proxyPort=[your proxy port]" jpm
\end{verbatim}

Excellent! You've configured Blade CLI with your proxy settings using
JPM.

\noindent\hrulefill

\textbf{Note:} When executing \texttt{blade\ update}, your Blade CLI's
proxy settings are sometimes reset. Be sure to verify your proxy
settings after every Blade CLI update.

\section{Creating a Liferay Workspace with Blade
CLI}\label{creating-a-liferay-workspace-with-blade-cli}

In this tutorial, you'll learn how to generate a Liferay Workspace using
Blade CLI. The Blade CLI tool you installed in the
\href{/docs/7-0/tutorials/-/knowledge_base/t/installing-blade-cli}{Installing
Blade CLI} section provides many different commands to help build and
customize Liferay projects. The first thing you should do before
building and customizing projects is create a Liferay Workspace. The
workspace generated by Blade CLI is Gradle based; if you'd like to
generate a Liferay Workspace built with Maven, see the
\href{/docs/7-0/tutorials/-/knowledge_base/t/maven-workspace}{Maven
Workspace} tutorial.

Your workspace is the home for all your custom Liferay projects.
Navigate to the folder where you want your workspace and run the
following command:

\begin{verbatim}
blade init -v 7.0 [WORKSPACE_NAME]
\end{verbatim}

\noindent\hrulefill

\textbf{Note:} Workspace automatically sets the default Liferay DXP
version to develop against when it's first initialized. The default
version is set to \texttt{7.2}. When adding the \texttt{-v\ 7.0} param
to Blade's init command, the version is set for \texttt{7.0} Liferay DXP
development. This is applied to create projects using appropriately
versioned project templates.

You can update the default version after it has been set by opening your
workspace's \texttt{.blade.properties} file and setting the
\texttt{liferay.version.default} property.

\noindent\hrulefill

Initializing a workspace requires no downloading or access to the
internet.

If you still plan on using a Plugins SDK and wish to use it in
conjunction with a workspace, navigate to your Plugins SDK root folder
and run the following command:

\begin{verbatim}
blade init -u
\end{verbatim}

This command builds a workspace and automatically adds and configures
your current Plugins SDK environment for use inside the workspace. See
the
\href{/docs/7-0/tutorials/-/knowledge_base/t/configuring-a-liferay-workspace\#using-a-plugins-sdk-from-your-workspace}{Using
a Plugins SDK From Your Workspace} section for more information on how
to use a Plugins SDK from within a workspace.

Once your workspace is generated, look at its folder structure. Several
folders and build/properties files were autogenerated:

\begin{itemize}
\tightlist
\item
  \texttt{configs}
\item
  \texttt{gradle}
\item
  \texttt{modules}
\item
  \texttt{themes}
\item
  \texttt{build.gradle}
\item
  \texttt{gradle-local.properties}
\item
  \texttt{gradle.properties}
\item
  \texttt{gradlew}
\item
  \texttt{settings.gradle}
\end{itemize}

The build/properties files included in your workspace's root directory
sets your workspace's Gradle properties and facilitates the build
processes of your modules. You can learn more about these generated
files/folders in the
\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-workspace}{Liferay
Workspace} tutorial. You'll learn about how to use these folders and
properties files throughout the next few tutorials.

Next you'll learn about generating and using a Liferay DXP instance from
within your workspace.

\subsection{Running a Liferay Instance from Your
Workspace}\label{running-a-liferay-instance-from-your-workspace}

As discussed in the
\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-workspace}{Liferay
Workspace} tutorial, Liferay Workspaces can generate and hold a Liferay
Server. This lets you build/test your plugins against a running Liferay
instance. Once you've properly generated and installed a Liferay server
in your workspace, you can begin using it with the Blade CLI. To start
your Liferay instance, run

\begin{verbatim}
blade server start -b
\end{verbatim}

This command starts your Liferay server in a separate window. You also
have the option to run your server in debug mode (\texttt{-d}).

Awesome! You have a built-in Liferay server in your workspace and can
start the server using Blade CLI. Next you'll learn how to use a legacy
Plugins SDK from your workspace.

\subsection{Configuring a Plugins SDK in Your
Workspace}\label{configuring-a-plugins-sdk-in-your-workspace}

Because Liferay DXP 7.0 uses a module-based framework, the current
structure of a Liferay Workspace is centered around module development.
There are still, however, many situations where you must create
WAR-style plugins using the Plugins SDK. Because of this, your workspace
can also work with the Plugins SDK. When configuring your SDK in a
workspace, you can take advantage of all the new functionality
workspaces provide and also use the SDK environment that you're used to.

Running the \texttt{blade\ init\ -u} command converted the Plugins SDK
to a workspace that includes the Plugins SDK. If you created your
workspace from scratch instead with \texttt{blade\ init}, you'll need to
configure your Liferay workspace's Gradle properties.

If you revisit your workspace's \texttt{gradle.properties} file, you'll
notice the Plugins SDK folder is set to \texttt{plugins-sdk}. This
folder was not generated by default, so you must create it yourself. In
your workspace's root folder, create the \texttt{plugins-sdk} folder.
Then copy your legacy Plugins SDK files into the \texttt{plugins-sdk}
folder. Lastly, generate its requirements by running
\texttt{gradlew\ tasks}. Once this command successfully downloads all
your Plugins SDK dependencies, it's ready to use in your workspace. For
more information on manually configuring a Plugins SDK, see the
\href{/docs/7-0/tutorials/-/knowledge_base/t/configuring-a-liferay-workspace\#using-a-plugins-sdk-from-your-workspace}{Using
a Plugins SDK from Your Workspace} section.

\section{Creating Projects with Blade
CLI}\label{creating-projects-with-blade-cli}

When you use Blade CLI to create a project, your project's folder
structure, build script (e.g., \texttt{build.gradle}), Java classes, and
other resources (such as JSPs) are created based on the chosen template.
In this tutorial, you'll learn how to use Blade CLI to create modules
based on pre-existing templates and samples.

Using Blade CLI gives you the flexibility to choose how you want to
create your application. You can do so in your own standalone
environment, or within a
\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-workspace}{Liferay
Workspace}. You can also create a project using either the Gradle or
Maven build tool. Creating Liferay modules in a workspace using Blade
CLI is very similar to creating them in a standalone environment.

When creating projects in a workspace, you should navigate to the
appropriate folder corresponding to that type of project (e.g., the
\texttt{/modules} folder for a module project). You can also provide
further directory nesting into that folder, if preferred. For example,
the Gradle workspace, by default, sets the directory where your modules
should be stored by setting the following property in the workspace's
\texttt{gradle.properties} file:

\begin{verbatim}
liferay.workspace.modules.dir=modules
\end{verbatim}

Change this property if you'd like to store your modules in a different
directory.

\noindent\hrulefill

\textbf{Note:} Your projects should define a repository where external
dependencies can be downloaded. Unlike Maven, Gradle does not define any
repositories by default. For convenience, Gradle projects created with
Blade CLI define Liferay's public Nexus repository as its default
repository. This is defined, however, in different files depending on
where the project was created.

If you used Blade CLI to create a Gradle project outside of a workspace,
your repository is defined in the module's \texttt{build.gradle} file.
Likewise, if you created your module inside a workspace, your repository
is defined in the \texttt{settings.gradle} file located in the
workspace's ROOT folder. This ensures that all modules residing in the
workspace share the same repository URL.

\noindent\hrulefill

First, you'll learn how to create a module using a template.

\subsection{Project Templates}\label{project-templates}

To create a new Liferay project, you can run the Blade \texttt{create}
command, which offers many available templates. There are, however, many
other options you can specify to help mold your project just the way you
want it. To learn how to use the Blade \texttt{create} command and the
many options it provides, enter \texttt{blade\ help\ create} into a
terminal. A list of the \texttt{create} options are listed below:

\begin{itemize}
\tightlist
\item
  \texttt{-b,\ -\/-build\ \textless{}string\textgreater{}}: The build
  type of the project. Available options are \texttt{gradle} (default)
  and \texttt{maven}.
\item
  \texttt{-c,\ -\/-classname\ \textless{}string\textgreater{}}: If a
  class is generated in the project, provide the name of the class to be
  generated. If not provided, the class name defaults to the project
  name.
\item
  \texttt{C,\ -\/-contributorType\ \textless{}string\textgreater{}}:
  Identifies your module as a theme contributor. This is also used to
  add the \texttt{Liferay-Theme-Contributor-Type} and
  \texttt{Web-ContextPath} bundle headers to the BND file.
\item
  \texttt{-d,\ -\/-dir\ \textless{}file\textgreater{}}: The directory to
  create the new project.
\item
  \texttt{-h,\ -\/-hostbundlebsn\ \textless{}string\textgreater{}}: If a
  new JSP hook fragment needs to be created, provide the name of the
  host bundle symbolic name.
\item
  \texttt{-H,\ -\/-hostbundleversion\ \textless{}string\textgreater{}}:
  If a new JSP hook fragment needs to be created, provide the name of
  the host bundle version.
\item
  \texttt{-l,\ -\/-listtemplates}: Prints a list of available project
  templates.
\item
  \texttt{-p,\ -\/-packagename\ \textless{}string\textgreater{}}: The
  package name to use when creating the project.
\item
  \texttt{-s,\ -\/-service\ \textless{}string\textgreater{}}: If a new
  Declarative Services (DS) component needs to be created, provide the
  name of the service to be implemented. Note that in this context, the
  term \emph{service} refers to an OSGi service, not to a Liferay API.
\item
  \texttt{-t,\ -\/-template\ \textless{}string\textgreater{}}: The
  project template to use when creating the project. Run
  \texttt{blade\ create\ -l} for a listing of available Blade CLI
  templates.
\item
  \texttt{-v,\ -\/-liferay-version}: The Liferay DXP version to target
  when creating a project (e.g., \texttt{7.0}).
\end{itemize}

To create a module project, use the following syntax:

\begin{verbatim}
blade create [OPTIONS] <NAME>
\end{verbatim}

For example, if you wanted to create an MVC portlet project with Gradle,
you could execute the following:

\begin{verbatim}
blade create -t mvc-portlet -p com.liferay.docs.guestbook -c GuestbookPortlet my-guestbook-project
\end{verbatim}

This command creates an MVC portlet project based on the template
\texttt{mvc-portlet}. It uses the package name
\texttt{com.liferay.docs.guestbook} and creates the portlet class
\texttt{GuestbookPortlet}. The project name is
\texttt{my-guestbook-project}. Since the directory was not specified, it
is created in the folder you executed the command. When generating a
project using Blade CLI, there is no downloading, which means internet
access is not required.

Blade CLI can also create the same project with Maven by specifying the
\texttt{-b\ maven} parameter. Using Blade CLI's Maven option isn't the
only way leverage Liferay's Maven project templates; you can also
generate them using Maven archetypes. See Liferay's
\href{/docs/7-0/reference/-/knowledge_base/r/project-templates}{Project
Templates} articles to see how.

When using Blade CLI, you'll have to manually edit your project's
component class. Blade CLI gives you the ability to specify the class's
name, but all other contents of the class can only be edited after the
class is created. See the
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-modules-with-liferay-ide}{Creating
Modules with Liferay @ide@} tutorial for further details and important
dependency information on component classes.

Now that you know the basics on creating Liferay projects using
\texttt{blade\ create}, you can visit the
\href{/docs/7-0/reference/-/knowledge_base/r/project-templates}{Project
Templates} reference section to view specific \texttt{create} templates
and how they work.

Next, you'll explore Liferay's provided project samples and how to
generate them using Blade CLI.

\subsection{Project Samples}\label{project-samples}

Liferay provides many sample projects that are useful for those
interested in learning best practices on structuring their projects to
accomplish specific tasks in Liferay DXP. These samples can be found in
the
\href{https://github.com/liferay/liferay-blade-samples}{liferay-blade-samples}
Github repository. You can also learn more about these samples by
visiting the
\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-sample-modules}{Liferay
Sample Projects} article.

You can generate these samples using Blade CLI for convenience, instead
of cloning the repository and manually copy/pasting them to your
environment. To do this, use the following syntax:

\begin{verbatim}
blade samples <NAME>
\end{verbatim}

For example, if you wanted to generate the
\href{https://github.com/liferay/liferay-blade-samples/tree/7.0/gradle/apps/ds-portlet}{portlet-ds}
sample, you could execute

\begin{verbatim}
blade samples ds-portlet
\end{verbatim}

For a full listing of all the available Blade samples, run

\begin{verbatim}
blade samples
\end{verbatim}

Awesome! Now you know the basics on creating Liferay projects with Blade
CLI.

\section{Deploying Modules with Blade
CLI}\label{deploying-modules-with-blade-cli}

Deploying modules to a Liferay server using Blade CLI is easy. To use
the Blade \texttt{deploy} command, you must first have built a module to
deploy. See the
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-modules-with-blade-cli}{Creating
Projects with Blade CLI} tutorials for more information about creating
Liferay projects. Once you've built a module, navigate to it with your
CLI and execute the following command to deploy it:

\begin{verbatim}
blade deploy
\end{verbatim}

This can be used for WAR-style projects and modules (JARs). You can also
deploy all projects in a folder by running the \texttt{deploy} command
from the parent folder (e.g., \texttt{{[}WORKSPACE\_ROOT{]}/modules}).

If you're using Liferay Workspace, the \texttt{deploy} command deploys
your project based on the build tool's deployment configuration. For
example, leveraging Blade CLI in a default Gradle Liferay Workspace uses
the underlying Gradle deployment configuration. The build tool's
deployment configuration is found by reading the Liferay Home folder set
in your workspace's \texttt{gradle.properties} or \texttt{pom.xml} file.
The \texttt{deploy} command works similarly if you're working outside of
workspace; the Liferay Home folder, in contrast, is set by loading the
Liferay extension object (Gradle) or the effective POM (Maven) and
searching for the Liferay Home property stored there. If it's not
stored, Blade prompts you to set it so it's available.

\noindent\hrulefill

\textbf{Note:} If you prefer using pure Gradle or Maven to deploy your
project, you can do this by applying the appropriate plugin and
configuring your Liferay Home property. Here's how you can do this for
Gradle and Maven:

\textbf{Gradle:}

First ensure the Liferay Gradle plugin is applied in your
\texttt{build.gradle} file:

\begin{verbatim}
 apply plugin: "com.liferay.plugin"
\end{verbatim}

Then extend the Liferay extension object to set your Liferay Home and
\texttt{deploy} folder:

\begin{verbatim}
 liferay {
     liferayHome = "../../../../liferay-ce-portal-7.0.1-ga2"
     deployDir = file("${liferayHome}/deploy")
 }
\end{verbatim}

\textbf{Maven:}

Ensure the Bundle Support plugin is applied and configure Liferay Home
in your \texttt{pom.xml}. See the
\href{/docs/7-0/tutorials/-/knowledge_base/t/deploying-a-module-built-with-maven-to-product}{Deploying
a Module Built with Maven to Liferay Portal} for details.

\noindent\hrulefill

If you prefer not to use your underlying build tool's (Gradle or Maven)
module deployment configuration, and instead, you want to deploy
straight to Liferay DXP's OSGi container, run this command instead:

\begin{verbatim}
blade deploy -l
\end{verbatim}

Blade CLI also offers a way to \emph{watch} a deployed project, which
compiles and redeploys a project when changes are detected. There are
two ways to do this:

\begin{itemize}
\tightlist
\item
  \texttt{blade\ watch}
\item
  \texttt{blade\ deploy\ -w}
\end{itemize}

The \texttt{blade\ watch} command is the fastest way to develop and test
module changes, because the \texttt{watch} command does not rebuild your
project every time a change is detected. When running
\texttt{blade\ watch}, your project is not copied to Portal, but rather,
is installed into the runtime as a reference. This means that the Portal
does not make a cached copy of the project. This allows the Portal to
see changes that are made to your project's files immediately. When you
cancel the \texttt{watch} task, your module is uninstalled
automatically.

\noindent\hrulefill

\textbf{Note:} The \texttt{blade\ watch} command is available for
Liferay Workspace versions 1.10.9+ (i.e., the
\texttt{com.liferay.gradle.plugins.workspace} dependency). Maven
projects cannot leverage the \texttt{watch} feature at this time.

\noindent\hrulefill

The \texttt{blade\ deploy\ -w} command works similarly to
\texttt{blade\ watch}, except it manually recompiles and deploys your
project every time a change is detected. This causes slower update
times, but does preserve your deployed project in Portal when it's shut
down.

Cool! You've successfully deployed your module project using Blade CLI.

\section{Managing Your Liferay Server with Blade
CLI}\label{managing-your-liferay-server-with-blade-cli}

In this tutorial, you'll learn how to manage a Liferay server using
Blade CLI. For example, Blade CLI lets you install, start, stop,
inspect, and modify a Liferay server.

Make sure you're in a Liferay Workspace and have a bundle installed and
configured in the workspace before testing the Blade CLI commands on
your own. To learn more about installing a Liferay server in a Liferay
Workspace, see the
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-a-liferay-workspace-with-liferay-ide}{Creating
a Liferay Workspace with Liferay @ide@} section. The following Blade CLI
commands are covered in this sub-section:

\begin{itemize}
\tightlist
\item
  \texttt{server}
\item
  \texttt{sh}
\end{itemize}

The first thing that comes to mind when interacting with a server is
simply turning it on/off. You can use the \texttt{server} sub-command to
accomplish this. To turn on a Liferay server (Tomcat or Wildfly/JBoss),
you can run

\begin{verbatim}
blade server start -b
\end{verbatim}

Likewise, to turn off a server, run

\begin{verbatim}
blade server stop
\end{verbatim}

Once you've started your bundle, you can examine your server's OSGi
container by using the \texttt{sh} command, which provides access to
your server using the Felix Gogo shell. For example, to check if you
successfully deployed your application from the previous section, you
could run:

\begin{verbatim}
blade sh lb
\end{verbatim}

Your output lists a long list of modules that are active/installed in
your server's OSGi container.

\begin{figure}
\centering
\includegraphics{./images/blade-sh.png}
\caption{Blade CLI accesses the Gogo shell script to run the \texttt{lb}
command.}
\end{figure}

You can run any Gogo command using \texttt{blade\ sh}. See the
\href{/docs/7-0/reference/-/knowledge_base/r/using-the-felix-gogo-shell}{Using
the Felix Gogo Shell} section for more information on this tool.

Awesome! You learned how to conveniently interact with Liferay DXP using
Blade CLI.

\section{Updating Blade CLI}\label{updating-blade-cli}

If your Blade CLI version is outdated, you can run the following command
to automatically download and install the latest version of Blade CLI:

\begin{verbatim}
blade update
\end{verbatim}

For Windows users, the \texttt{blade\ update} command does not work
because Windows cannot update a file that is currently in use. To bypass
this issue, you can use JPM to update your version of Blade CLI:

\begin{verbatim}
jpm install -f https://releases.liferay.com/tools/blade-cli/latest/blade.jar
\end{verbatim}

Blade CLI is updated frequently, so it's recommended to update your
Blade CLI environment for new features. You can check the released
versions of Blade CLI at
\url{https://releases.liferay.com/tools/blade-cli/}. You can check your
current installed version by running \texttt{blade\ version}.

\noindent\hrulefill

\textbf{Note:} If you run \texttt{blade\ version} after updating, but
don't see the expected version installed, you may have two separate
Blade CLI installations on your machine. This is typically caused by
users who installed an earlier version of Blade CLI, and then used the
\href{/docs/7-0/tutorials/-/knowledge_base/t/installing-blade-cli}{Liferay
Workspace installer} (at any time prior) to update the older Blade CLI
instance. This is not recommended. Doing this installs Blade CLI in the
global and user home folder of your machine. The latest Blade CLI update
process installs to your user home folder, so you must delete the legacy
Blade files in your global folder, if present. To do this, navigate to
your \texttt{GLOBAL\_FOLDER/JPM4J} folder and delete

\begin{itemize}
\tightlist
\item
  \texttt{/bin/blade}
\item
  \texttt{/commands/blade}
\end{itemize}

The newest Blade CLI installation in your user home folder is now
recognized and available.

\noindent\hrulefill

Although Blade CLI is frequently released, if you want bleeding edge
features not yet available, you can install the latest snapshot version:

\begin{verbatim}
blade update -s
\end{verbatim}

This pulls the latest snapshot version of Blade CLI and installs it to
your local machine. Running \texttt{blade\ version} after installing a
snapshot displays output similar to this:

\begin{verbatim}
blade version 3.3.1.SNAPSHOT201811301746
\end{verbatim}

Be careful; snapshot versions are unstable and should only be used for
experimental purposes.

Awesome! You've successfully learned how to update Blade CLI.

\section{Converting Plugins SDK Projects with Blade
CLI}\label{converting-plugins-sdk-projects-with-blade-cli}

Blade CLI can automatically migrate a Plugins SDK project to a Liferay
Workspace. During the process, the Ant-based Plugins SDK project is
copied to the applicable workspace folder based on its project type
(e.g., \texttt{wars}) and is converted to a Gradle-based Liferay
Workspace project. This drastically speeds up the migration process when
upgrading to a Liferay Workspace from a legacy Plugins SDK.

\noindent\hrulefill

\textbf{Note:} There is no Maven command for the migration process yet,
so you must complete it manually for Maven-based workspaces.

\noindent\hrulefill

To copy your Plugins SDK project and convert it to Gradle, use the Blade
\texttt{convert} command:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Navigate to the root folder of your workspace in a command line tool.
\item
  Execute the following command:

\begin{verbatim}
blade convert -s [PLUGINS_SDK_PATH] [PLUGINS_SDK_PROJECT_NAME]
\end{verbatim}

  You must provide the path of the Plugins SDK your project resides in
  and the project name you want to convert. If you prefer converting all
  the Plugins SDK projects at once, replace the project name variable
  with \texttt{-a} (i.e., specifying all plugins).
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** If the `convert` task doesn't work as described above, you may
 need to update your Blade CLI version. See the
 [Updating Blade CLI](/docs/7-0/tutorials/-/knowledge_base/t/updating-blade-cli)
 article for more information.
\end{verbatim}

\noindent\hrulefill

\begin{verbatim}
This Gradle conversion process also works for themes; they're converted to
automatically leverage NodeJS. If you're converting a Java-based theme, add
the `-t` option to your command too. This will incorporate the
[Theme Builder](/docs/reference/7-0/-/knowledge_base/r/theme-builder-gradle-plugin)
Gradle plugin for the theme instead. For more information on upgrading
6.2 themes, see the
[Upgrade a 6.2 Theme to 7.0](/docs/7-0/tutorials/-/knowledge_base/t/upgrading-themes)
article.
\end{verbatim}

\noindent\hrulefill

\textbf{Note:} When converting a Service Builder project, the
\texttt{convert} task automatically extracts the project's service
interfaces and implementations into OSGi modules (i.e., \emph{-impl and
}-api) and places them in the workspace's \texttt{modules} folder. Your
portlet and controller logic remain a WAR and reside in the
\texttt{wars} folder.

\noindent\hrulefill

Your project is successfully converted to a Gradle-based workspace
project! Great job!

\chapter{Liferay Workspace}\label{liferay-workspace}

A \emph{Liferay Workspace} is a generated environment that is built to
hold and manage your Liferay projects. This workspace is intended to aid
in the management of Liferay projects by providing various Gradle build
scripts and configured properties. This is the official way to create
7.0 modules using Gradle. For those developers that still want to
develop WAR-style plugins using the Plugins SDK, this way is also
supported using a Liferay Workspace. Do you prefer Maven over Gradle?
See the
\href{/docs/7-0/tutorials/-/knowledge_base/t/maven-workspace}{Maven
Workspace} tutorial to learn about using Liferay Workspace with Maven.

Liferay Workspaces can be used in many different development
environments, which makes it flexible and applicable to many different
developers. You can download the
\href{https://sourceforge.net/projects/lportal/files/Liferay\%20Workspace}{Liferay
Workspace installer} and run it to install
\href{/docs/7-0/tutorials/-/knowledge_base/t/blade-cli}{Blade CLI}
(default CLI for workspace) and initialize a new Liferay Workspace.

You can also use it with other developer IDEs. For example, a Liferay
Workspace easily integrates with Liferay @ide@, providing a seamless
development experience. To learn more about Liferay @ide@ and using
workspace with it, see the
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-a-liferay-workspace-with-liferay-ide}{Creating
a Liferay Workspace with Liferay @ide@} tutorial.

Your workspace also offers Gradle properties that you can modify to help
manage the generated folders. There are also some folders that aren't
generated by default, but can be manually created and set. This provides
you the power to customize your workspace's folder structure any way
you'd like. To learn more info on a workspace's folder structure and how
you can configure a workspace, see the
\href{/docs/7-0/tutorials/-/knowledge_base/t/configuring-a-liferay-workspace}{Configuring
a Liferay Workspace} tutorial.

Liferay Workspaces offer a full development lifecycle for your modules
to make your Liferay development easier than ever. The development
lifecycle includes creating, building, deploying, testing, and releasing
modules. To learn more about the development lifecycle of a Liferay
Workspace, see the
\href{/docs/7-0/tutorials/-/knowledge_base/t/development-lifecycle-for-a-liferay-workspace}{Development
Lifecycle for a Liferay Workspace} tutorial.

\section{Installing Liferay
Workspace}\label{installing-liferay-workspace}

You can install Liferay Workspace using the Liferay Project SDK
installer. This installs JPM and
\href{/docs/7-0/tutorials/-/knowledge_base/t/blade-cli}{Blade CLI} into
your user home folder and optionally initializes a Liferay Workspace
folder. This is the same installer used to install Blade CLI, which is
covered in the
\href{/docs/7-0/tutorials/-/knowledge_base/t/installing-blade-cli}{Installing
Blade CLI} tutorial.

Follow the steps below to download and install Liferay Workspace:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Download the latest
  \href{https://sourceforge.net/projects/lportal/files/Liferay\%20IDE/}{Liferay
  Project SDK installer} that corresponds with your operating system
  (e.g., Windows, MacOS, or Linux). The Project SDK installer is listed
  under \emph{Liferay IDE}, so the folder versions are based on IDE
  releases. You can select an installer that does not include @ide@, if
  you don't intend to use it. The Project SDK installer is available for
  versions 3.2.0+. Do \textbf{not} select the large green download
  button; this downloads Liferay Portal instead.
\item
  Run the installer. Click \emph{Next} to step through the installer's
  introduction.
\item
  Set the directory where your Liferay Workspace should be initialized.

  \begin{figure}
  \centering
  \includegraphics{./images/blade-installer-workspace-init.png}
  \caption{Determine where your Liferay Workspace should reside.}
  \end{figure}

  Then click \emph{Next}.
\item
  Choose the Liferay product type you intend to use with the workspace.
  Then click \emph{Next}.

  \begin{figure}
  \centering
  \includegraphics{./images/installer-workspace-type.png}
  \caption{Select the product version you'll use with your Liferay
  Workspace.}
  \end{figure}
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** You'll be prompted for your liferay.com username and password
 before downloading the Liferay DXP bundle. Your credentials are not saved
 locally; they're saved as a token in the `~/.liferay` folder. The token is
 used by your workspace if you ever decide to redownload a DXP bundle.
 Furthermore, the bundle that is downloaded in your workspace is also copied
 to your `~/.liferay/bundles` folder, so if you decide to initialize another
 Liferay DXP instance of the same version, the bundle is not re-downloaded. See
 the
 [Adding a Liferay Bundle to a Workspace](/docs/7-0/tutorials/-/knowledge_base/t/configuring-a-liferay-workspace#adding-a-liferay-bundle-to-a-workspace)
 for more information on this topic.
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{4}
\tightlist
\item
  Click \emph{Next} to begin installing Liferay Workspace on your
  machine.
\end{enumerate}

That's it! Liferay Workspace is now installed on your machine!

\section{Configuring a Liferay
Workspace}\label{configuring-a-liferay-workspace}

A Liferay Workspace offers a development environment that can be
configured to fit your development needs. You'll learn about the
files/folders a workspace provides by default, and then you'll dive into
configuring your workspace.

The top-level files/folder of a Liferay workspace are outlined below:

\begin{itemize}
\tightlist
\item
  \texttt{bundles} (generated): the default folder for Liferay DXP
  bundles.
\item
  \texttt{configs}: holds the configuration files for different
  environments. These files serve as your global configuration files for
  all Liferay servers and projects residing in your workspace. To learn
  more about using the \texttt{configs} folder, see the
  \href{/docs/7-0/tutorials/-/knowledge_base/t/development-lifecycle-for-a-liferay-workspace\#testing-modules}{Testing
  Modules} section.
\item
  \texttt{gradle}: holds the Gradle Wrapper used by your workspace.
\item
  \texttt{modules}: holds your custom modules.
\item
  \texttt{plugins-sdk} (generated): holds plugins to migrate from
  previous releases.
\item
  \texttt{themes}: holds your custom themes which are built using the
  Theme Generator.
\item
  \texttt{wars} (generated): holds traditional WAR-style web application
  projects.
\item
  \texttt{build.gradle}: the common Gradle build file.
\item
  \texttt{gradle-local.properties}: sets user-specific properties for
  your workspace. This lets multiple users use a single workspace,
  letting them configure specific properties for the workspace on their
  own machine.
\item
  \texttt{gradle.properties}: specifies the workspace's project
  locations and Liferay DXP server configuration globally.
\item
  \texttt{gradlew}: executes the Gradle command wrapper
\item
  \texttt{settings.gradle}: applies plugins to the workspace and
  configures its dependencies.
\end{itemize}

The build/properties files included in your workspace's root folder sets
your workspace's Gradle properties and facilitates the build processes
of your modules.

Before you begin using your workspace, you should set your workspace
Gradle properties in the \texttt{gradle.properties} file. There are
several commented out properties in this file. These are the default
properties set in your workspace. If you'd like to change a variable,
uncomment the variable and set it to a custom value. For instance, if
you want to store your modules in a folder other than
\texttt{{[}ROOT{]}/modules}, uncomment the
\texttt{liferay.workspace.modules.dir} variable and set it to a
different value.

If you'd like to keep the global Gradle properties the same, but want to
change them for yourself only (perhaps for local testing), you can
override the \texttt{gradle.properties} file with your own
\texttt{gradle-local.properties} file.

\noindent\hrulefill

\textbf{Note:} Liferay Workspace provides many subprojects for you
behind the scenes, which hides some complexities of Gradle. You can
learn more about this in the
\href{/docs/7-0/tutorials/-/knowledge_base/t/development-lifecycle-for-a-liferay-workspace\#building-modules}{Building
Modules} section.

\noindent\hrulefill

Now that you know about a workspace's default folder structure and how
to modify its Gradle properties, you'll learn how to add a Liferay
bundle to your workspace.

\subsection{Adding a Liferay Bundle to a
Workspace}\label{adding-a-liferay-bundle-to-a-workspace}

Liferay Workspaces can generate and hold a Liferay Server. This lets you
build/test your plugins against a running Liferay instance. Before
generating a Liferay instance, open the \texttt{gradle.properties} file
located in your workspace's root folder. There are several configurable
properties for your workspace's Liferay instance. You can set the
version of the Liferay bundle you'd like to generate and install by
setting the download URL for the \texttt{liferay.workspace.bundle.url}
property (e.g.,
\texttt{https://releases-cdn.liferay.com/portal/7.0.6-ga7/liferay-ce-portal-tomcat-7.0-ga7-20180507111753223.zip}).
You can also set the folder where your Liferay bundle is generated with
the \texttt{liferay.workspace.home.dir} property. It's set to
\texttt{bundles} by default.

You can download a Liferay DXP bundle for your workspace if you're a DXP
subscriber. Do this by setting the \texttt{liferay.workspace.bundle.url}
property to a ZIP hosted on \emph{api.liferay.com}. For example,

\texttt{liferay.workspace.bundle.url=https://api.liferay.com/downloads/portal/7.0.10.8/liferay-dxp-digital-enterprise-tomcat-7.0-sp8-20180717152749345.zip}

It can be tricky to find the fully qualified ZIP name/number for the DXP
bundle you want. You cannot access Liferay's API site directly to find
it, so you must start to download DXP manually, take note of the file
name, and append it to
\texttt{https://api.liferay.com/downloads/portal/}.

You must also set the \texttt{liferay.workspace.bundle.token.download}
property to \texttt{true} to allow your workspace to access Liferay's
API site.

Once you've finalized your Gradle properties, navigate to your
workspace's root folder and run

\begin{verbatim}
blade server init
\end{verbatim}

This uses workspace's pre-bundled
\href{/docs/7-0/tutorials/-/knowledge_base/t/blade-cli}{Blade CLI} tool
to download the version of Liferay DXP you specified in your Gradle
properties and installs your Liferay instance in the \texttt{bundles}
folder.

If you want to skip the downloading process, you can create the
\texttt{bundles} folder manually in your workspace's ROOT folder and
unzip your Liferay DXP bundle to that folder.

You can also produce a distributable Liferay bundle (Zip or Tar) from
within a workspace. To do this, navigate to your workspace's root folder
and run the following command:

\begin{verbatim}
./gradlew distBundle[Zip|Tar]
\end{verbatim}

Your distribution file is available from the workspace's \texttt{/build}
folder.

\noindent\hrulefill

\textbf{Note:} You can define different environments for your Liferay
bundle for easy testing. You can learn more about this in the
\href{/docs/7-0/tutorials/-/knowledge_base/t/development-lifecycle-for-a-liferay-workspace\#testing-modules}{Testing
Modules} section.

\noindent\hrulefill

The Liferay Workspace is a great development environment for Liferay
module development; however, what if you'd like to also stick with
developing WAR-style applications? Liferay Workspace can handle that
request too!

\subsection{Using a Plugins SDK from Your
Workspace}\label{using-a-plugins-sdk-from-your-workspace}

Because 7.0 uses a module-based framework, the current structure of a
Liferay Workspace is centered around module development. There are
still, however, many situations where you must create WAR-style plugins
using the Plugins SDK. Because of this, your workspace can also work
with the Plugins SDK. When configuring your SDK in a workspace, you can
take advantage of all the new functionality workspaces provide and also
use the SDK environment that you're used to. To learn more about
upgrading legacy applications to 7.0 and what you should consider before
converting them to modules, visit the tutorial
\href{/docs/7-0/tutorials/-/knowledge_base/t/migrating-existing-code-to-liferay-7}{Planning
Plugin Upgrades and Optimizations}.

The Blade CLI offers a command that adds and configures your current
Plugins SDK environment automatically for use inside a newly generated
workspace (e.g., \texttt{blade\ init\ -u}). You can learn more about
this in the
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-a-liferay-workspace-with-blade-cli}{Creating
a Liferay Workspace with Blade CLI} tutorial. If you created your
workspace from scratch and want to use a Plugins SDK, however, you can
add one to your workspace by completing one of the two options:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Copy your existing Plugins SDK's files into the workspace.
\item
  Generate a new Plugins SDK to use in the workspace.
\end{enumerate}

Follow the appropriate section based on the option you want to follow.

\subsubsection{Copying an Existing Plugins SDK into
Workspace}\label{copying-an-existing-plugins-sdk-into-workspace}

If you open your workspace's \texttt{gradle.properties} file, you'll
notice the \texttt{liferay.workspace.plugins.sdk.dir} property sets the
Plugins SDK folder to \texttt{plugins-sdk}. This is where the workspace
expects any Plugins SDK files to reside. This folder was not generated
by default, so you must create it yourself. In your workspace's root
folder, create the \texttt{plugins-sdk} folder. Then copy your legacy
Plugins SDK files into the \texttt{plugins-sdk} folder.

The copied Plugins SDK requires many build-related artifacts. To start
the artifact download process, execute the following command in your
workspace's root folder:

\begin{verbatim}
./gradlew upgradePluginsSDK
\end{verbatim}

The Plugins SDK's artifacts are downloaded. The Plugins SDK is now ready
for use!

\subsubsection{Generating a New Plugins SDK in
Workspace}\label{generating-a-new-plugins-sdk-in-workspace}

You can easily generate a new Plugins SDK for your workspace by
executing a single Gradle command in your workspace's root folder:

\begin{verbatim}
./gradlew upgradePluginsSDK
\end{verbatim}

This generates a new 7.0 Plugins SDK into the folder set by the
\texttt{liferay.workspace.plugins.sdk.dir} property, which is configured
to \texttt{plugins-sdk} by default in the workspace's
\texttt{gradle.properties} file. You can change the folder name by
updating the property. The downloaded Plugins SDK version is the latest
release at the time of execution. You can reference the latest Plugins
SDK releases
\href{https://repository.liferay.com/nexus/content/groups/public/com/liferay/portal/com.liferay.portal.plugins.sdk/}{here}.

Once the downloading is complete, your Plugins SDK is ready to use in
your workspace!

\section{Setting Proxy Requirements for Liferay
Workspace}\label{setting-proxy-requirements-for-liferay-workspace}

If you're working behind a corporate firewall that requires using a
proxy server to access external repositories, you need to add some extra
configuration to make Liferay Workspace work within your environment.
You'll learn how to set proxy requirements for both Gradle and Maven
environments.

\subsection{Using Gradle}\label{using-gradle}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open your \texttt{\textasciitilde{}/.gradle/gradle.properties} file.
  Create this file if it does not exist.
\item
  Add the following properties to the file:

\begin{verbatim}
systemProp.http.proxyHost=www.somehost.com
systemProp.http.proxyPort=1080
systemProp.https.proxyHost=www.somehost.com
systemProp.https.proxyPort=1080
\end{verbatim}

  Make sure to replace the proxy host and port values with your own.
\item
  If the proxy server requires authentication, also add the following
  properties:

\begin{verbatim}
systemProp.http.proxyUser=userId
systemProp.http.proxyPassword=yourPassword
systemProp.https.proxyUser=userId
systemProp.https.proxyPassword=yourPassword
\end{verbatim}
\end{enumerate}

Excellent! Your proxy settings are set in your Liferay Workspace's
Gradle environment.

\subsection{Using Maven}\label{using-maven}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open your \texttt{\textasciitilde{}/.m2/settings.xml} file. Create
  this file if it does not exist.
\item
  Add the following XML snippet to the file:

\begin{verbatim}
<?xml version="1.0" encoding="UTF-8"?>
    <settings xmlns="http://maven.apache.org/SETTINGS/1.0.0"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd">
        <proxies>
            <proxy>
                <id>httpProxy</id>
                <active>true</active>
                <protocol>http</protocol>
                <host>www.somehost.com</host>
                <port>1080</port>
            </proxy>
            <proxy>
                <id>httpsProxy</id>
                <active>true</active>
                <protocol>https</protocol>
                <host>www.somehost.com</host>
                <port>1080</port>
            </proxy>
        </proxies>
    </settings>
\end{verbatim}

  Make sure to replace the proxy host and port values with your own.
\item
  If the proxy server requires authentication, also add the
  \texttt{username} and \texttt{password} proxy properties. For example,
  the HTTP proxy authentication configuration would look like this:

\begin{verbatim}
<proxy>
  <id>httpProxy</id>
  <active>true</active>
  <protocol>http</protocol>
  <host>www.somehost.com</host>
  <port>1080</port>
  <username>userID</username>
  <password>somePassword</password>
</proxy>
\end{verbatim}
\end{enumerate}

Excellent! Your Maven proxy settings are now set.

\section{Development Lifecycle for a Liferay
Workspace}\label{development-lifecycle-for-a-liferay-workspace}

Liferay Workspaces provide an environment that supports all phases of a
Liferay module's development lifecycle:

\begin{itemize}
\tightlist
\item
  \hyperref[creating-modules]{Creating modules}
\item
  \hyperref[building-modules]{Building modules}
\item
  \hyperref[deploying-modules]{Deploying modules}
\item
  \hyperref[testing-modules]{Testing modules}
\item
  \hyperref[releasing-modules]{Releasing modules}
\end{itemize}

In this tutorial, you'll explore the development lifecycle phases
Liferay Workspace provides for you. Then you'll be directed to other
tutorials that go into further detail for leveraging the workspace's
particular lifecycle phase for a specific tool (e.g., Blade CLI or
Liferay @ide@). Let's get started!

\subsection{Creating Modules}\label{creating-modules}

The first step of Liferay Workspace's development phase is the module
creation process. Workspace provides a slew of templates that you can
use to create many different types of Liferay modules.

You can configure where your workspace creates modules by editing the
\texttt{liferay.workspace.modules.dir} property in the workspace's
\texttt{gradle.properties} file. By default, modules are created in the
\texttt{{[}ROOT{]}/modules} folder.

You can also control where themes are generated by specifying the
\texttt{liferay.workspace.themes.dir} property in the
\texttt{gradle.properties} file. Themes are typically migrated to the
\texttt{themes} folder after being created using the
\href{/docs/7-0/tutorials/-/knowledge_base/t/themes-generator}{Liferay
Theme Generator}.

To learn more about creating modules in a workspace using Blade CLI or
Liferay @ide@, visit the
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-modules-with-blade-cli}{Creating
Modules with Blade CLI} and
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-modules-with-liferay-ide}{Creating
Modules with Liferay @ide@} tutorials, respectively.

\subsection{Building Modules}\label{building-modules}

Liferay Workspace abstracts many build requirements away so you can
focus on developing modules instead of worrying about how to build them.
Liferay Workspace is built using Gradle, so your modules leverage the
Gradle build lifecycle.

Workspace includes a Gradle wrapper in its ROOT folder (e.g.,
\texttt{gradlew}), which you can leverage to execute Gradle commands.
This means that you can run familiar Gradle build commands (e.g.,
\texttt{build}, \texttt{clean}, \texttt{compile}, etc.) from a Liferay
Workspace without having Gradle installed on your machine.

\noindent\hrulefill

\textbf{Note:} You can also use the workspace's Gradle wrapper by
executing \texttt{blade\ \ gw} followed by the Gradle command. This is
an easier way to run the workspace's Gradle wrapper without specifying
its path. Since the workspace's Gradle wrapper resides in its root
folder, it can sometimes be a hassle running it for a deeply nested
module (e.g., \texttt{../../../../gradlew\ compileJava}). Running the
Gradle wrapper from Blade CLI automatically detects the Gradle wrapper
and can run it anywhere.

\noindent\hrulefill

When using Liferay Workspace, the workspace plugin is automatically
applied which adds a multitude of subprojects for you, hiding some
complexities of Gradle. For example, a typical project's
\texttt{settings.gradle} file could contain many included subprojects
like this:

\begin{verbatim}
...
include images:base:oracle-jdk:oracle-jdk-6
include images:base:oracle-jdk:oracle-jdk-7
include images:base:oracle-jdk:oracle-jdk-8
include images:base:liferay-portal:liferay-portal-ce-tomcat-7.0-ga1
include images:source-bundles:glassfish
include images:source-bundles:jboss-eap
include images:source-bundles:tomcat
include images:source-bundles:websphere
include images:source-bundles:wildfly
include compose:jboss-eap-mysql
include compose:tomcat-mariadb
include compose:tomcat-mysql
include compose:tomcat-mysql-elastic
include compose:tomcat-postgres
include file-server
...
\end{verbatim}

You don't have to worry about applying these subprojects because the
workspace plugin does it for you. Likewise, if a folder in the
\texttt{/themes} folder includes a \texttt{liferay-theme.json} file, the
\texttt{gulp} plugin is applied to it; if a folder in the
\texttt{/modules} folder includes a \texttt{bnd.bnd} file, the
\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-sample-modules}{liferay-gradle}
plugin is applied to it. See the
\href{/docs/7-0/reference/-/knowledge_base/r/gradle}{Gradle} reference
article for a list of Liferay Gradle plugins automatically provided for
all Workspace apps. As you can see, Liferay Workspace provides many
plugins and build configurations behind the scenes to make your
development process convenient.

A good example of the Gradle build lifecycle abstraction is the module
deployment process in a workspace. You can build/deploy your modules
from workspace without ever running a Gradle command. You'll learn how
to do this next.

\subsection{Deploying Modules}\label{deploying-modules}

Liferay Workspace provides easy-to-use deployment mechanisms that let
you deploy your module to a Liferay server without any custom
configuration. To learn more about deploying modules from a workspace
using Blade CLI or Liferay @ide@, visit the
\href{/docs/7-0/tutorials/-/knowledge_base/t/deploying-modules-with-blade-cli}{Deploying
Modules with Blade CLI} and
\href{/docs/7-0/tutorials/-/knowledge_base/t/deploying-modules-with-liferay-ide}{Deploying
Modules with Liferay @ide@} tutorials, respectively.

\subsection{Testing Modules}\label{testing-modules}

Liferay provides many configuration settings for 7.0. Configuring
several different Liferay DXP installations to simulate/test certain
behaviors can become cumbersome and time consuming. With Liferay
Workspace, you can easily organize environment settings and generate an
environment installation with those settings.

Liferay Workspace provides the \texttt{configs} folder, which lets you
configure different environments in the same workspace. For example, you
could configure separate Liferay DXP environment settings for
development, testing, and production in a single Liferay Workspace. So
how does it work?

The \texttt{configs} folder offers five subfolders:

\begin{itemize}
\tightlist
\item
  \texttt{common}: holds a common configuration that you want applied to
  all environments.
\item
  \texttt{dev}: holds the development configuration.
\item
  \texttt{local}: holds the configuration intended for testing locally.
\item
  \texttt{prod}: holds the configuration for a production site.
\item
  \texttt{uat}: holds the configuration for a UAT site.
\end{itemize}

You're not limited to just these environments. You can create any
subfolder in the \texttt{configs} folder (e.g., \texttt{aws},
\texttt{docker}, etc.) to simulate any environment. Each environment
folder can supply its own database, \texttt{portal-ext.properties},
Elasticsearch, etc. The files in each folder overlay your Liferay DXP
installation, which you generate from within workspace.

\begin{figure}
\centering
\includegraphics{./images/workspace-configs.png}
\caption{The \texttt{configs/common} and
\texttt{configs/{[}environment{]}} overlay you Liferay DXP bundle when
it's generated.}
\end{figure}

When workspace generates a Liferay DXP bundle, these things happen:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Configuration files found in the \texttt{configs/common} folder are
  applied to the Liferay DXP bundle.
\item
  The configured workspace environment (\texttt{dev}, \texttt{local},
  \texttt{prod}, \texttt{uat}, etc.) is applied on top of any existing
  configurations from the \texttt{common} folder.
\end{enumerate}

To generate a Liferay DXP bundle with a specific environment
configuration to the workspace's \texttt{/bundles} folder, run

\begin{verbatim}
./gradlew initBundle -Pliferay.workspace.environment=[ENVIRONMENT]

<!-- `blade server init` is not able to pass the environment param in
currently. This new feature is requested in BLADE-343. -Cody -->
\end{verbatim}

To generate a distributable Liferay DXP installation to the workspace's
\texttt{/build} folder, run

\begin{verbatim}
./gradlew distBundle[Zip|Tar] -Pliferay.workspace.environment=[ENVIRONMENT]
\end{verbatim}

The \texttt{ENVIRONMENT} variable should match the configuration folder
(\texttt{dev}, \texttt{local}, \texttt{prod}, \texttt{uat}, etc.) you
intend to apply.

\noindent\hrulefill

\textbf{Note:} You may prefer to set your workspace environment in the
\texttt{gradle.properties} file instead of passing it via Gradle
command. If so, it's recommended to set the workspace envrionment
variable inside the \texttt{{[}USER\_HOME{]}/.gradle/gradle.properties}
file.

\begin{verbatim}
 liferay.workspace.environment=local
\end{verbatim}

The variable is set to \texttt{local} by default.

\noindent\hrulefill

To simulate using the \texttt{configs} folder, let's explore a typical
scenario. Suppose you want a local Liferay DXP installation for testing
and a UAT installation for simulating a production site. Assume you want
the following configuration for the two environments:

\textbf{Local Environment}

\begin{itemize}
\tightlist
\item
  Use MySQL database pointing to localhost
\item
  Skip setup wizard
\end{itemize}

\textbf{UAT Environment}

\begin{itemize}
\tightlist
\item
  Use MySQL database pointing to a live server
\item
  Skip setup wizard
\end{itemize}

To configure these two environments in your workspace, follow the steps
below:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open the \texttt{configs/common} folder and add the
  \texttt{portal-setup-wizard.properties} file with the
  \texttt{setup.wizard.enabled=false} property.
\item
  Open the \texttt{configs/local} folder and configure the MySQL
  database settings for localhost in a \texttt{portal-ext.properties}
  file.
\item
  Open the \texttt{configs/uat} folder and configure the MySQL database
  settings for the live server in a \texttt{portal-ext.properties} file.
\item
  Now that your two environments are configured, generate one of them:

\begin{verbatim}
./gradlew distBundle[Zip|Tar] -Pliferay.workspace.environment=uat
\end{verbatim}

  You've successfully configured two environments and generated one of
  them.
\end{enumerate}

Awesome! You can now test various Liferay DXP bundle environments using
Liferay Workspace.

\subsection{Releasing Modules}\label{releasing-modules}

Liferay Workspace does not provide a built-in release mechanism, but
there are easy ways to use external release tools with workspace. The
most popular choice is uploading your modules to a Maven Nexus
repository. You could also use other release tools like
\href{https://www.jfrog.com/artifactory/}{Artifactory}.

Uploading modules to a remote repository is useful if you need to share
them with other non-workspace projects. Also, if you're ready for your
modules to be in the spotlight, uploading them to a public remote
repository gives other developers the chance to use them.

For more instructions on how to set up a Maven Nexus repository for your
workspace's modules, see the
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-a-maven-repository}{Creating
a Maven Repository} and
\href{/docs/7-0/tutorials/-/knowledge_base/t/deploying-liferay-maven-artifacts-to-a-repository}{Deploying
Liferay Maven Artifacts to a Repository} tutorials.

\section{Managing the Target Platform for Liferay
Workspace}\label{managing-the-target-platform-for-liferay-workspace}

Liferay Workspace helps you target a specific release of Liferay DXP, so
dependencies get resolved properly. This makes upgrades easy: specify
your target platform, and Workspace points to the new version. All your
dependencies are updated to the latest ones provided in the targeted
release.

\noindent\hrulefill

\textbf{Note:} There are times when configuring dependencies based on a
version range is better than tracking exact versions. See the
\href{/docs/7-0/tutorials/-/knowledge_base/t/semantic-versioning}{Semantic
Versioning} tutorial for more details.

\noindent\hrulefill

\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-ide}{Liferay @ide@
3.2+} helps you streamline targeting a specific version even more. @ide@
can index the configured Liferay DXP source code to

\begin{itemize}
\tightlist
\item
  provide advanced Java search (Open Type and Reference Searching)
  (\href{/docs/7-0/tutorials/-/knowledge_base/t/searching-product-source-in-liferay-ide}{tutorial})
\item
  debug Liferay DXP sources
  (\href{/docs/7-0/tutorials/-/knowledge_base/t/debugging-product-source-in-liferay-ide}{tutorial})
\end{itemize}

To enable this functionality, set the following property in your
workspace's \texttt{gradle.properties} file:

\begin{verbatim}
target.platform.index.sources=true
\end{verbatim}

\noindent\hrulefill

\textbf{Note:} Portal source indexing is disabled in Gradle workspace
version 2.0.3+ (Target Platform plugin version 2.0.0+).

\noindent\hrulefill

These options in @ide@ are only available when developing in a Liferay
Workspace, or if you have the
\href{/docs/7-0/reference/-/knowledge_base/r/target-platform-gradle-plugin}{Target
Platform} Gradle plugin applied to your multi-module Gradle project with
specific configurations. See the
\hyperref[targeting-a-platform-outside-of-workspace]{Targeting a
Platform Outside of Workspace} section for more info on applying the
Target Platform Gradle plugin.

Next, you'll discover how all of this is possible.

\subsection{Dependency Management with
BOMs}\label{dependency-management-with-boms}

You can target a version by importing a predefined bill of materials
(BOM). This only requires that you specify a property in your
workspace's \texttt{gradle.properties} file. You'll see how to do this
later.

Each Liferay DXP version has a predefined BOM that you can specify for
your workspace to reference. Each BOM defines the artifacts and their
versions used in the specific release. BOMs list all dependencies in a
management fashion, so it doesn't \textbf{add} dependencies to your
project; it only \textbf{provides} your build tool (e.g., Gradle or
Maven) the versions needed for the project's defined artifacts. This
means you don't need to specify your dependency versions; the BOM
automatically defines the appropriate artifact versions based on the
BOM.

You can override a BOM's defined artifact version by specifying a
different version in your project's \texttt{build.gradle}. Artifact
versions defined in your project's build files override those specified
in the predefined BOM. Note that overriding the BOM can be dangerous;
make sure the new version is compatible in the targeted platform.

For more information on BOMs, see the
\href{https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism\#Importing_Dependencies}{Importing
Dependencies} section in Maven's official documentation.

Pretty cool, right? Next, you'll step through an example configuration.

\subsection{Setting the Target
Platform}\label{setting-the-target-platform}

Setting the version to develop for takes two steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open the workspace's \texttt{gradle.properties} file and set the
  \texttt{liferay.workspace.target.platform.version} property to the
  version you want to target. For example,

\begin{verbatim}
liferay.workspace.target.platform.version=7.0.6
\end{verbatim}

  If you're using Liferay DXP, the versions are specified based on
  service packs. For example, you could set your target platform
  workspace Gradle property to

\begin{verbatim}
liferay.workspace.target.platform.version=7.0.10.7
\end{verbatim}

  \textbf{Important:} You can leverage the target platform features in
  Liferay Portal GA6+ and Liferay DXP 7.0 SP7+. Previous versions do not
  provide these features.

  The versions following the SP7 release of DXP follow fix pack versions
  (e.g., \texttt{7.0.10.fp69}, \texttt{7.0.10.fp70}, etc.).
\item
  Once the target platform is configured, check to make sure no
  dependencies in your Gradle build files specify a version. The
  versions are now imported from the configured target platform's BOM.
  For example, a simple MVC portlet's \texttt{build.gradle} may look
  something like this:

\begin{verbatim}
dependencies {
    compileOnly group: "com.liferay.portal", name: "com.liferay.portal.kernel"
    compileOnly group: "com.liferay.portal", name: "com.liferay.util.taglib"
    compileOnly group: "javax.portlet", name: "portlet-api"
    compileOnly group: "javax.servlet", name: "javax.servlet-api"
    compileOnly group: "jstl", name: "jstl"
    compileOnly group: "org.osgi", name: "osgi.cmpn"
}
\end{verbatim}
\end{enumerate}

\noindent\hrulefill

\textbf{Note}: The \texttt{liferay.workspace.target.platform.version}
property also sets the distro JAR, which can be used in to validate your
projects during the build process. See the
\href{/docs/7-0/tutorials/-/knowledge_base/t/validating-modules-against-the-target-platform}{Validating
Modules Against the Target Platform} tutorials for more info.

\noindent\hrulefill

The target platform functionality is available in Liferay Workspace
version 1.9.0+. If you have an older version, you must update it to
leverage platform targeting. See the
\href{/docs/7-0/tutorials/-/knowledge_base/t/updating-liferay-workspace}{Updating
Liferay Workspace} tutorial to do this.

You now know how to configure a target platform in workspace and how
dependencies without versions appear in your Gradle build files. You're
all set!

\subsection{Targeting a Platform Outside of
Workspace}\label{targeting-a-platform-outside-of-workspace}

If you prefer to not use Liferay Workspace, but still want to target a
platform, you must apply the
\href{/docs/7-0/reference/-/knowledge_base/r/target-platform-gradle-plugin}{Target
Platform} Gradle plugin to the root \texttt{build.gradle} file of your
custom multi-module Gradle build.

To do this, your \texttt{build.gradle} file should look similar to this:

\begin{verbatim}
buildscript {
    dependencies {
        classpath group: "com.liferay", name: "com.liferay.gradle.plugins.target.platform", version: "1.1.6"
    }
    repositories {
        maven {
            url "https://repository-cdn.liferay.com/nexus/content/groups/public"
        }
    }
}

apply plugin: "com.liferay.target.platform"

dependencies {
    targetPlatformBoms group: "com.liferay.portal", name: "release.portal.bom", version: "7.0.6"
    targetPlatformBoms group: "com.liferay.portal", name: "release.portal.bom.compile.only", version: "7.0.6"
}
\end{verbatim}

Liferay DXP users must replace the artifact names and versions:

\begin{itemize}
\tightlist
\item
  \texttt{release.portal.bom} → \texttt{release.dxp.bom}
\item
  \texttt{release.portal.bom.compile.only} →
  \texttt{release.dxp.bom.compile.only}
\item
  \texttt{7.0.6} → \texttt{7.0.10.7}
\end{itemize}

This Gradle code

\begin{itemize}
\tightlist
\item
  applies Liferay's Target Platform Gradle plugin
\item
  configures the repository that provides the necessary artifacts for
  your project build
\item
  sets the Target Platform plugin's dependencies:

  \begin{itemize}
  \tightlist
  \item
    \texttt{release.portal.bom}: provides all the artifacts included in
    Liferay DXP.
  \item
    \texttt{release.portal.bom.compile.only}: provides artifacts that
    are not included in Liferay DXP, but are necessary to reference
    during the build (e.g., \texttt{org.osgi.core}).
  \end{itemize}
\end{itemize}

If you're interested in
\href{/docs/7-0/tutorials/-/knowledge_base/t/searching-product-source-in-liferay-ide}{advanced
search} and/or
\href{/docs/7-0/tutorials/-/knowledge_base/t/debugging-product-source-in-liferay-ide}{debugging}
Liferay DXP's source using
\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-ide}{Liferay
@ide@}, you must also apply the following configuration:

\begin{verbatim}
targetPlatformIDE {
    includeGroups "com.liferay", "com.liferay.portal"
}
\end{verbatim}

This indexes the target platform's source code and makes it available to
@ide@.

Now you can define your target platform!

\chapter{Validating Modules Against the Target
Platform}\label{validating-modules-against-the-target-platform}

\noindent\hrulefill

\textbf{Important:} Validating modules with the \texttt{resolve} task is
deprecated. It only functions as it's documented here in versions prior
to Liferay Workspace (Gradle only) version 2.0.3. It is being redesigned
for workspace versions 2.0.3+ and is still in development at this time.

\noindent\hrulefill

After you write a module in Liferay Workspace, you can validate it
before deployment to make sure of several things:

\begin{itemize}
\tightlist
\item
  Will my app deploy successfully?
\item
  Will there be some sort of missing requirement?
\item
  If there's an issue, how do I diagnose it?
\end{itemize}

These are all common worries that can be frustrating.

Instead of deploying your app and checking for errors in the log, you
can validate your app before deployment. This is done by calling Liferay
Workspace's \texttt{resolve} task, which validates your modules against
a targeted platform. Continue on to learn how this works.

\section{Resolving Your Modules}\label{resolving-your-modules}

Deploying your modules only to be met with console errors or mysterious
problems can be frustrating. You can avoid this painful process by
resolving your modules before deployment. This can be done by calling
the \texttt{resolve} Gradle task provided by Liferay Workspace.

\begin{verbatim}
../gradlew resolve
\end{verbatim}

This task gathers all the capabilities provided by

\begin{itemize}
\tightlist
\item
  the specified version of Liferay DXP (i.e.,
  \href{/docs/7-0/tutorials/-/knowledge_base/t/managing-the-target-platform-for-liferay-workspace}{targeted
  platform})
\item
  the current workspace's modules
\end{itemize}

Some capabilities/information gathered by the \texttt{resolve} task that
are validated include

\begin{itemize}
\tightlist
\item
  declared required capabilities
\item
  module versions
\item
  package imports/use constraints
\item
  service references
\end{itemize}

It also computes a list of run requirements for your project. Then it
compares the current project's requirements against the gathered
capabilities. If your project requires something not available in the
gathered list of capabilities, the task fails.

The task can only validate OSGi modules. It does not work with WAR-style
projects, themes, or npm portlets.

\noindent\hrulefill

\textbf{Note:} The \texttt{resolve} task can be executed from a specific
project folder or from the workspace's root folder. Running the task
from the root folder validates all the modules in your workspace.

\noindent\hrulefill

The \texttt{resolve} task can automatically gather the available
capabilities from your workspace, but you must specify this for your
targeted Liferay DXP version. To do this, open your workspace's
\texttt{gradle.properties} file and set the
\texttt{liferay.workspace.target.platform.version} property to the
version you want to target. For example,

\begin{verbatim}
liferay.workspace.target.platform.version=7.0.6
\end{verbatim}

If you're using Liferay DXP, the versions are specified based on service
packs. For example, you could set your target platform workspace Gradle
property to

\begin{verbatim}
liferay.workspace.target.platform.version=7.0.10.7
\end{verbatim}

\textbf{Important:} You can leverage the target platform features in
Liferay Portal GA6+ and Liferay DXP 7.0 SP7+. Previous versions do not
provide these features.

The versions following the SP7 release of DXP follow service pack
versions (e.g., \texttt{7.0.10.8} (SP8), \texttt{7.0.10.9} (SP9), etc.).

This provides a static \emph{distro} JAR for the specified version of
Liferay DXP, which contains all the metadata (i.e., capabilities,
packages, versions, etc.) running in that version. The distro JAR is a
complete snapshot of everything provided in the OSGi runtime; this
serves as the target platform's list of capabilities that your modules
are validated against.

You can now validate your module projects before deploying them!
Sometimes, you must modify the \texttt{resolve} task's default behavior
to successfully validate your app. See the
\href{/docs/7-1/tutorials/-/knowledge_base/t/modifying-the-target-platforms-capabilities}{Modifying
the Target Platform's Capabilities} tutorial for more information. For
help resolving common output errors printed by the \texttt{resolve}
task, see the
\href{/docs/7-1/reference/-/knowledge_base/r/resolving-common-output-errors-reported-by-the-resolve-task}{Resolving
Common Output Errors Reported by the resolve Task} article.

\section{Modifying the Target Platform's
Capabilities}\label{modifying-the-target-platforms-capabilities}

In a perfect world, everything the \texttt{resolve} task gathers and
checks against would work during your development process.
Unfortunately, there are exceptions that may force you to modify the
default functionality of the \texttt{resolve} task. If you're unfamiliar
with workspace's \texttt{resolve} task, see the
\href{/docs/7-0/tutorials/-/knowledge_base/t/resolving-your-modules}{Resolving
Your Modules} tutorial for more information.

There are two scenarios you may run into during development that require
a modification for your project to pass the resolver check.

\begin{itemize}
\tightlist
\item
  You're depending on a third party library that is not available in the
  targeted Liferay DXP instance or the current workspace.
\item
  You're depending on a customized distribution of Liferay DXP.
\end{itemize}

You'll explore these use cases next.

\subsection{Depending on Third Party Libraries Not Included in Liferay
DXP}\label{depending-on-third-party-libraries-not-included-in-liferay-dxp}

The \texttt{resolve} task, by default, gathers all of Liferay DXP's
capabilities and the capabilities of your workspace's modules. What if,
however, your module depends on a third party project that is not
included in either space (e.g.,
\href{https://opensource.google.com/projects/guava}{Google Guava})?. The
\texttt{resolve} task fails by default if your project depends on this
project type. You probably plan to have this project deployed and
available at runtime, so it's not a concern, but the resolver doesn't
know that; you must customize the resolver to bypass this.

There are three ways you can do this:

\begin{itemize}
\tightlist
\item
  \hyperref[embed-the-third-party-library-in-your-module]{Embed the
  third party library in your module}
\item
  \hyperref[add-the-third-party-librarys-capabilities-to-the-current-static-set-of-resolver-capabilities]{Add
  the third party library's capabilities to the current static set of
  resolver capabilities}
\item
  \hyperref[skip-the-resolving-process-for-your-module]{Skip the
  resolving process for your module}
\end{itemize}

For help resolving third party dependency errors, see the
\href{/docs/7-0/tutorials/-/knowledge_base/t/adding-third-party-libraries-to-a-module}{Resolving
Third Party Library Package Dependencies} tutorial.

\subsubsection{Embed the Third Party Library in Your
Module}\label{embed-the-third-party-library-in-your-module}

If you only have one module that depends on the third party project, you
can bypass the resolver failure by embedding the JAR in your module.
This is not a best practice if more than one project in the OSGi
container depends on that module. See the
\href{/docs/7-0/tutorials/-/knowledge_base/t/adding-third-party-libraries-to-a-module\#embedding-libraries-in-a-module}{Embedding
Libraries in a Module}

section for more details.

\subsubsection{Add the Third Party Library's Capabilities to the Current
Static Set of Resolver
Capabilities}\label{add-the-third-party-librarys-capabilities-to-the-current-static-set-of-resolver-capabilities}

You can add your third party dependencies to the target platform's
default list of capabilities by listing them as provided modules. Do
this by adding the following Gradle code into your workspace's root
\texttt{build.gradle} file:

\begin{verbatim}
dependencies {
    providedModules group: "GROUP_ID", name: "NAME", version: "VERSION"
}
\end{verbatim}

For example, if you wanted to add
\href{https://opensource.google.com/projects/guava}{Google Guava} as a
provided module, it would look like this:

\begin{verbatim}
dependencies {
    providedModules group: "com.google.guava", name: "guava", version: "23.0"
}
\end{verbatim}

This both provides the third party dependency to the resolver, and it
downloads and includes it in your Liferay DXP bundle's
\texttt{osgi/modules} folder when you initialize it (e.g.,
\texttt{blade\ server\ init}).

\subsubsection{Skip the Resolving Process for Your
Module}\label{skip-the-resolving-process-for-your-module}

It may be easiest to skip validating a particular module during the
resolve process. To do this, open your workspace's root
\texttt{build.gradle} file and insert the following Gradle code at the
bottom of the file:

\begin{verbatim}
targetPlatform {
    resolveOnlyIf { project ->
        project.name != 'PROJECT_NAME'
    }
}
\end{verbatim}

Be sure to replace the \texttt{PROJECT\_NAME} filler with your module's
name (e.g., \texttt{test-api}).

If you prefer to disable the Target Platform plugin altogether, you can
add a slightly different directive to your \texttt{build.gradle} file:

\begin{verbatim}
targetPlatform {
    onlyIf { project ->
        project.name != 'PROJECT_NAME'
    }
}
\end{verbatim}

This both skips the \texttt{resolve} task execution and disables BOM
dependency management.

Now the \texttt{resolve} task skips your module project.

\subsection{Depending on a Customized Distribution of Liferay
DXP}\label{depending-on-a-customized-distribution-of-liferay-dxp}

There are times when manually specifying your project's list of
dependent JARs does not suffice. If your app requires a customized
Liferay DXP instance to run, you must regenerate the target platform's
default list of capabilities with an updated list. Two examples of a
customized Liferay DXP instance are described below:

\textbf{Example 1: Leveraging an External Feature}

There are many external features/frameworks available that are not
included in the downloadable bundle by default. After deploying a
feature/framework, it's available for your module projects to leverage.
When validating your app, however, the \texttt{resolve} task does not
have access to external capabilities not included by default. For
example, Audience Targeting is an example of this type of external
framework. If you're creating a Liferay Audience Targeting rule that
depends on the Audience Targeting framework, you can't easily provide a
slew of JARs for your module. In this case, you should install the
platform your code depends on and regenerate an updated list of
capabilities that your Liferay DXP instance provides.

\textbf{Example 2: Leveraging a Customized Core Feature}

You can extend Liferay DXP's core features to provide a customized
experience for your intended audience. Once deployed, you can assume
these customizations are present and build other things on top of them.
The new capabilities resulting from your customizations are not
available, however, in the target platform's default list of
capabilities. Therefore, when your application relies on non-default
capabilities, it fails during the \texttt{resolve} task. To get around
this, you must regenerate a new list of capabilities that your
customized Liferay DXP instance provides.

To regenerate the target platform's capabilities (distro JAR) based on
the current workspace's Liferay DXP instance, follow the steps below:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Start the Liferay DXP instance stored in your workspace. Make sure the
  platform you want to depend on is installed.
\item
  Download the
  \href{https://search.maven.org/\#search\%7Cga\%7C1\%7Cbiz.aqute.remote.agent}{BND
  Remote Agent JAR file} and copy it into the \texttt{osgi/modules}
  folder.
\item
  From the root folder of your workspace, run the following command:

\begin{verbatim}
bnd remote distro -o custom_distro.jar release.portal.distro 7.0.6
\end{verbatim}

  Liferay DXP users must replace the \texttt{release.portal.distro}
  artifact name with \texttt{release.dxp.distro} and use the
  \texttt{7.0.10.7} version syntax.

  This connects to the newly deployed BND agent running in Liferay DXP
  and generates a new distro JAR named \texttt{custom\_distro.jar}. All
  other capabilities inherit their functionality based on your Liferay
  DXP instance, so verify the workspace bundle is the version you plan
  to release in production.
\item
  Navigate to your workspace's root \texttt{build.gradle} file and add
  the following dependency:

\begin{verbatim}
dependencies {
    targetPlatformDistro files('custom_distro.jar')
}
\end{verbatim}
\end{enumerate}

Now your workspace is pointing to a custom distro JAR file instead of
the default one provided. Run the \texttt{resolve} task to validate your
modules against the new set of capabilities.

\section{Including the Resolver in Your Gradle
Build}\label{including-the-resolver-in-your-gradle-build}

By default, Liferay Workspace provides the \texttt{resolve} task as an
independent executable. It's provided by the
\href{/docs/7-0/reference/-/knowledge_base/r/target-platform-gradle-plugin}{Target
Platform} Gradle plugin and is not integrated in any other Gradle
processes. This gives you control over your Gradle build without
imposing strategies you may not want included in your default build
process.

With that said, the \texttt{resolve} task can be useful to include in
your build process if you want to check for errors in your module
projects before deployment. Instead of resolving your projects
separately from your standard build, you can build and resolve them all
in one shot.

In Liferay Workspace, the recommended path for doing this is adding it
to the default \texttt{check} Gradle task. The \texttt{check} task is
provided by default in a workspace by the
\href{https://docs.gradle.org/current/userguide/java_plugin.html\#_lifecycle_tasks}{Java}
plugin. Adding the \texttt{resolve} task to the \texttt{check} lifecycle
task also promotes the \texttt{resolve} task to run for CI and other
test tools that typically run the \texttt{check} task for verification.
Of course, Gradle's \texttt{build} task also depends on the
\texttt{check} task, so you can run \texttt{gradlew\ build} and run the
resolver too.

To call the \texttt{resolve} task during the \texttt{check} task
automatically, open your workspace's root \texttt{build.gradle} file and
add the following directive:

\begin{verbatim}
check.dependsOn resolve
\end{verbatim}

You can also configure this for specific projects in a workspace if you
don't want all modules to be included in the global \texttt{check}.

If the \texttt{resolve} task runs during every Gradle build, you may
want to prevent the build from failing if there are errors reported by
the resolver. To do this, open your workspace's root
\texttt{build.gradle} file and add the following code:

\begin{verbatim}
targetPlatform {
    ignoreResolveFailures = true
}
\end{verbatim}

This reports the failures without failing the build. Note, this can only
be configured in the workspace's root \texttt{build.gradle} file.

Awesome! You can now run the \texttt{resolve} task in your current
Gradle lifecycle.

\section{Validating Modules Outside of
Workspace}\label{validating-modules-outside-of-workspace}

If you prefer to not use Liferay Workspace, but still want to validate
modules against a target platform, you must apply the
\href{/docs/7-0/reference/-/knowledge_base/r/target-platform-gradle-plugin}{Target
Platform} Gradle plugin to the root \texttt{build.gradle} file of your
multi-module Gradle build. Follow the
\href{/docs/7-0/tutorials/-/knowledge_base/t/managing-the-target-platform-for-liferay-workspace\#targeting-a-platform-outside-of-workspace}{Targeting
a Platform Outside of Workspace} section to do this.

Once you have the Target Platform plugin and its BOM dependencies
configured, you must configure the \texttt{targetPlatformDistro}
dependency. Open your project's root \texttt{build.gradle} file and add
it to the list of dependencies. It should look like this:

\begin{verbatim}
dependencies {
    targetPlatformBoms group: "com.liferay.portal", name: "release.portal.bom", version: "7.0.6"
    targetPlatformBoms group: "com.liferay.portal", name: "release.portal.bom.compile.only", version: "7.0.6"
    targetPlatformDistro group: "com.liferay.portal", name "release.portal.distro", version: "7.0.6"
}

Liferay DXP users must replace the artifact names and versions:
             
- `release.portal.bom` &rarr; `release.dxp.bom`
- `release.portal.bom.compile.only` &rarr; `release.dxp.bom.compile.only`
- `release.portal.distro` &rarr; `release.dxp.distro`
- `7.0.6` &rarr; `7.0.10.7`
\end{verbatim}

Now you can validate your modules against a target platform!

\section{Updating Liferay Workspace}\label{updating-liferay-workspace}

Liferay Workspace is continuously being updated with new features. If
you created your Workspace a while ago, you may be missing out on some
of the latest features that could improve your Liferay development
experience. Updating your Liferay Workspace is easy; you'll learn how to
do it next.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Find the latest Liferay Workspace version. To do this, open the
  \href{https://github.com/liferay/liferay-portal/blob/master/modules/sdk/gradle-plugins-workspace/CHANGELOG.markdown}{Liferay
  Gradle Plugins Workspace Change Log} and copy the version to which you
  want to upgrade. You can find the updates and new features associated
  with each version by browsing the change log too.
\item
  Open your Liferay Workspace's \texttt{settings.gradle} file. This file
  resides in your Workspace's root folder.
\item
  In the \texttt{dependencies} block, you'll find code similar to below:

\begin{verbatim}
dependencies {
    classpath group: "com.liferay", name: "com.liferay.gradle.plugins.workspace", version: "[WORKSPACE_VERSION]"
}
\end{verbatim}

  Update the \texttt{com.liferay.gradle.plugins.workspace} dependency's
  \texttt{version} to the version number you copied from the change log
  in step 1.
\item
  Execute any Gradle command to initiate the update process for your
  Workspace (e.g., \texttt{blade\ gw\ tasks}).
\end{enumerate}

Awesome! You learned where to check for Liferay Workspace's latest
version, how to update your Workspace to that version, and how to
initiate the update process.

\chapter{Maven}\label{maven-1}

\href{https://maven.apache.org/}{Maven} is a viable option for managing
Liferay projects if you don't want to use Liferay's default Gradle
management system. Liferay provides several Maven plugins to let you
generate and manage your project. Liferay also provides Maven artifacts
that are easy to obtain and are required for Liferay Maven module
development. In the Maven tutorials, you'll learn how to

\begin{itemize}
\tightlist
\item
  Install Liferay Maven artifacts.
\item
  Generate Liferay projects using Maven archetypes.
\item
  Create a Module JAR using Maven.
\item
  Deploy a module built with Maven to Liferay DXP.
\item
  Create a remote repository for Maven projects.
\item
  Deploy a Maven project to a remote repository.
\item
  Use Service Builder in a Maven project.
\item
  Compile Sass files in a Maven project.
\item
  Build a Liferay theme in a Maven project.
\item
  Leverage the Maven Workspace.
\end{itemize}

Because Liferay DXP is tool agnostic, Maven is fully supported for
Liferay DXP development. Read on to learn more!

\section{Installing Liferay Maven
Artifacts}\label{installing-liferay-maven-artifacts}

To create Liferay modules using Maven, you'll need the archives required
by Liferay (e.g., JAR and WAR files). This isn't a problem--Liferay
provides them as Maven artifacts. You can retrieve them from a remote
repository.

There are two repositories that contain Liferay artifacts: Central
Repository and Liferay Repository. The Central Repository is the default
repository used to download artifacts if you don't have a remote
repository configured. The Central Repository \emph{usually} offers the
latest Liferay Maven artifacts, but using the the Liferay Repository
\emph{guarantees} the latest artifacts released by Liferay. Other than a
slight delay between artifact releases between the two repositories,
they're identical. You'll learn how to reference both of them next.

Using the Central Repository to install Liferay Maven artifacts only
requires that you specify your module's dependencies in its
\texttt{pom.xml} file. For example, the snippet below sets a dependency
on Liferay's \texttt{com.liferay.portal.kernel} artifact:

\begin{verbatim}
<dependencies>
    <dependency>
        <groupId>com.liferay.portal</groupId>
        <artifactId>com.liferay.portal.kernel</artifactId>
        <version>2.0.0</version>
        <scope>provided</scope>
    </dependency>
    ...
</dependencies>
\end{verbatim}

When packaging your module, the automatic Maven artifact installation
process only downloads the artifacts necessary for that module from the
Central Repository.

You can view the published Liferay Maven artifacts on the Central
Repository by searching for \emph{liferay maven} in the repo's Search
bar. For convenience, you can reference the available artifacts at
\href{http://search.maven.org/\#search\%7Cga\%7C1\%7Cliferay\%20maven}{http://search.maven.org/\#search\textbar ga\textbar1\textbar liferay
maven}. Use the Latest Version column as a guide to see what's available
for the intended version of Liferay DXP for which you're developing.

If you'd like to access Liferay's latest Maven artifacts, you can
configure Maven to use \href{https://repository.liferay.com}{Liferay's
Nexus repository} instead by inserting the following snippet in your
project's parent \texttt{pom.xml}:

\begin{verbatim}
<repositories>
    <repository>
        <id>liferay-public-releases</id>
        <name>Liferay Public Releases</name>
        <url>https://repository.liferay.com/nexus/content/repositories/liferay-public-releases</url>
    </repository>
</repositories>
  
<pluginRepositories>
    <pluginRepository>
        <id>liferay-public-releases</id>
        <url>https://repository.liferay.com/nexus/content/repositories/liferay-public-releases/</url>
    </pluginRepository>
</pluginRepositories>
\end{verbatim}

The above configuration retrieves artifacts from Liferay's release
repository.

\noindent\hrulefill

\textbf{Note:} Liferay also provides a
\href{https://repository.liferay.com/nexus/content/repositories/liferay-public-snapshots/}{snapshot
repository} that you can access by modifying the
\texttt{\textless{}id\textgreater{}},
\texttt{\textless{}name\textgreater{}}, and
\texttt{\textless{}url\textgreater{}} tags to point to that repo. This
repository should only be used in special cases. You'll also need to
enable accessing the snapshot artifacts:

\begin{verbatim}
 <snapshots>
     <enabled>true</enabled>
 </snapshots>
\end{verbatim}

\noindent\hrulefill

If you've configured the Liferay Nexus repository to access Liferay
Maven artifacts and you've already been syncing from the Central
Repository, you may need to clear out parts of your local repository to
force Maven to re-download the newer artifacts. Also, do not leave the
Liferay repository configured when publishing artifacts to Maven
Central. You must comment out the Liferay Repository credentials when
publishing your artifacts.

The Liferay Maven repository offers a good alternative for those who
want the most up-to-date Maven artifacts produced by Liferay.

Congratulations! You've downloaded the Liferay artifacts and installed
them to your chosen repository.

\section{Generating New Projects Using
Archetypes}\label{generating-new-projects-using-archetypes}

Creating Maven projects from scratch can be a lot of work. What
dependencies does my Liferay portlet project need? What does a Liferay
Maven Service Builder project look like? How do I create a Liferay
Maven-based context contributor? These questions can be answered with
three words: Liferay Maven Archetypes.

Liferay provides a slew of Maven archetypes for easy Liferay module
projects. In this tutorial, you'll learn how to use Liferay's Maven
archetypes to generate your module project.

At the time of this writing, Liferay provides just under 40 Maven
archetypes for you to use; expect this number to continue growing! These
archetypes are generated from the Central Repository, unless you've
configured for them to be generated from another remote repository
(e.g., \href{https://repository.liferay.com}{Liferay Repository}. You
can view the Liferay-provided Maven archetypes by running the following
command:

\begin{verbatim}
mvn archetype:generate -Dfilter=liferay
\end{verbatim}

The generated archetypes are not all intended for the latest Liferay DXP
release. Some are intended for earlier versions of Liferay Portal (e.g.,
6.2, 6.1, etc.). An easy way to tell if the archetype is compatible with
7.0 is by inspecting the archetype's package name. Archetypes with the
\texttt{com.liferay.maven.archetypes} prefix are legacy archetypes.
Those prefixed with \texttt{com.liferay.project.templates.{[}TYPE{]}} or
\texttt{com.liferay.faces.archetype:{[}TYPE{]}} are compatible with 7.0.

Here's a brief list of some popular Maven archetypes provided by
Liferay:

\begin{itemize}
\tightlist
\item
  Activator
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/context-contributors}{Context
  Contributor}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/jsf-portlets-with-liferay-faces}{Liferay
  Faces} portlets

  \begin{itemize}
  \tightlist
  \item
    \href{https://web.liferay.com/community/liferay-projects/liferay-faces/alloy}{Alloy}
  \item
    \href{http://www.icesoft.org/java/projects/ICEfaces/overview.jsf}{ICEfaces}
  \item
    \href{https://web.liferay.com/community/liferay-projects/liferay-faces/overview}{JSF}
  \item
    \href{http://primefaces.org/}{PrimeFaces}
  \item
    \href{http://richfaces.jboss.org/}{RichFaces}
  \end{itemize}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-mvc-portlet}{MVC
  Portlet}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/customizing-the-product-menu\#adding-custom-panel-apps}{Panel
  App}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/providing-portlets-to-manage-requests}{Portlet
  Provider}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/what-is-service-builder}{Service
  Builder}
\item
  Service Wrapper
\item
  Vaadin Liferay portlet
\end{itemize}

For documentation on the archetypes (project templates) compatible with
7.0, see the
\href{/docs/7-0/reference/-/knowledge_base/r/project-templates}{Project
Templates} reference section. Visit Maven's
\href{http://maven.apache.org/archetype/maven-archetype-plugin/generate-mojo.html}{Archetype
Generation} documentation for further details on how to modify the Maven
archetype generation process.

\noindent\hrulefill

\textbf{Note:} If you're creating a JSF portlet using Liferay Faces, you
can find example archetype declarations for JSF component suites at
\href{http://www.liferayfaces.org/}{http://www.liferayfaces.org}.

\noindent\hrulefill

Here's an example that creates a Liferay MVC portlet using its Liferay
Maven archetype.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  On the command line, navigate to where you want your Maven project.
  Run the Maven archetype generation command filtered for Liferay
  archetypes only:

\begin{verbatim}
mvn archetype:generate -Dfilter=liferay
\end{verbatim}
\item
  Select the \texttt{com.liferay.project.templates.mvc.portlet}
  archetype by choosing its corresponding number (e.g., \texttt{8}).

  In most cases, you should choose the latest archetype version. The
  archetype versions provided are compatible with all 7.x versions of
  Liferay DXP.
\item
  Depending on the Maven archetype you selected, you're given a set of
  archetype options to fill out for your Maven project. For the MVC
  portlet archetype, you could use these properties:

  \begin{itemize}
  \tightlist
  \item
    \texttt{groupId}: \texttt{com.liferay}
  \item
    \texttt{artifactId}:
    \texttt{com.liferay.project.templates.mvc.portlet}
  \item
    \texttt{version}: \texttt{1.0.0}
  \item
    \texttt{package}: \texttt{com.liferay.docs}
  \item
    \texttt{className}: \texttt{SampleMVC}
  \end{itemize}

  Once you've filled out the required property values, you're given a
  summary of the properties configuration you defined. Enter \texttt{Y}
  to confirm your project's configuration.
\end{enumerate}

Your Maven project is generated and available from the folder for which
you ran the archetype generation command. If you have an existing parent
\texttt{pom.xml} file in that folder, your module project is
automatically accounted for there:

\begin{verbatim}
<modules>
    ...
    <module>com.liferay.project.templates.mvc.portlet</module>
</modules>
\end{verbatim}

The Liferay Maven archetypes generate deployable Liferay module
projects, but they're bare bones and likely require further
customizations.

If you want to generate a quick foundation for a Liferay module built
with Maven, using Liferay Maven archetypes is your best option.

\section{Creating a Module JAR Using
Maven}\label{creating-a-module-jar-using-maven}

If you have an existing Liferay module built with Maven that you created
from scratch, or you're upgrading your Maven project from a previous
version of Liferay, your project probably can't generate an executable
OSGi JAR. Don't fret! You can do this by making a few minor
configurations in your module's POMs.

\noindent\hrulefill

\textbf{Note:} If you used Liferay's Maven archetypes to generate your
module project, the project already has the Maven plugins required to
generate an OSGi JAR.

\noindent\hrulefill

Continue on to see how this is done.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In your project's \texttt{pom.xml} file, add the
  \href{http://njbartlett.name/2015/03/27/announcing-bnd-maven-plugin.html}{BND
  Maven Plugin} declaration:

\begin{verbatim}
<plugin>
    <groupId>biz.aQute.bnd</groupId>
    <artifactId>bnd-maven-plugin</artifactId>
    <version>3.3.0</version>
    <executions>
        <execution>
            <goals>
                <goal>bnd-process</goal>
            </goals>
        </execution>
    </executions>
</plugin>
\end{verbatim}

  The BND Maven plugin prepares all your Maven module's resources (e.g.,
  \texttt{MANIFEST.MF}) and inserts them into the generated
  \texttt{{[}Maven\ Project{]}/target/classes} folder. This plugin
  prepares your module to be packaged as an OSGi JAR deployable to
  Liferay DXP.
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** Although WABs can be generated using the `bnd-maven-plugin`, this
 is not supported by Liferay. WABs should be created as a standard WAR
 project and deployed to the
 [Liferay WAB Generator](/docs/7-0/tutorials/-/knowledge_base/t/using-the-wab-generator),
 which generates a WAB for you.
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\item
  In your project's \texttt{pom.xml} file, add the
  \href{http://maven.apache.org/plugins/maven-jar-plugin/}{Maven JAR
  Plugin} declaration:

\begin{verbatim}
<build>
    <plugins>
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-jar-plugin</artifactId>
            <version>2.6</version>
            <configuration>
                <archive>
                    <manifestFile>${project.build.outputDirectory}/META-INF/MANIFEST.MF</manifestFile>
                </archive>
            </configuration>
        </plugin>
    </plugins>
</build>
\end{verbatim}

  The Maven JAR plugin builds your Maven project as a JAR file,
  including the resources generated by the BND Maven plugin. The above
  configuration also sets the default project \texttt{MANIFEST.MF} file
  path for your project, which is essential when packaging your module
  using the BND Maven plugin. By default, the Maven JAR Plugin ignores
  the \texttt{target/classes/META-INF/MANIFEST.MF} generated by the BND
  Maven plugin, so you must explicitly set it as the manifest file so
  it's included properly in the generated JAR file.
\item
  Make sure you've added a
  \href{http://bnd.bndtools.org/}{\texttt{bnd.bnd} file} to your Liferay
  Maven project, residing in the same folder as your project's
  \texttt{pom.xml} file.
\item
  Build your Maven OSGi JAR by running

\begin{verbatim}
mvn package
\end{verbatim}

  Your Maven JAR is generated in your project's \texttt{/target} folder.
  You can deploy it manually into Liferay DXP's \texttt{/deploy} folder,
  or you can configure your project to deploy automatically to Liferay
  DXP by following the
  \href{/docs/7-0/tutorials/-/knowledge_base/t/deploying-a-module-built-with-maven-to-product}{Deploying
  a Module Built with Maven to Liferay DXP} tutorial.
\end{enumerate}

Fantastic! You've configured your Liferay Maven project to package
itself into a deployable OSGi module.

\section{Deploying a Module Built with Maven to Liferay
DXP}\label{deploying-a-module-built-with-maven-to-liferay-dxp}

There are two ways to deploy a Maven-built Liferay module:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Copy your generated Maven module JAR to your Liferay DXP instance's
  \texttt{/deploy} folder.
\item
  Configure your Maven project to deploy to the Liferay DXP instance
  automatically by running a Maven command via the command prompt.
\end{enumerate}

Although manually copying your module JAR for deployment is a viable
option, this is an inefficient way to deploy your projects. With a small
configuration in your Maven POMs, you can deploy a module to Liferay DXP
with one command execution.

In previous versions of Liferay Portal, you were able to execute the
\texttt{liferay:deploy} command to deploy your configured Maven project
to a Liferay server. This is no longer possible since the
\texttt{liferay-maven-plugin} is not applied to Maven projects built
from Liferay archetypes.

A prerequisite for this tutorial is to have your project configured to
generate an OSGi module JAR; if you haven't done this, visit the
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-a-module-jar-using-maven}{Creating
a Module JAR Using Maven} tutorial for more information.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add the following plugin configuration to your Liferay Maven project's
  parent \texttt{pom.xml} file.

\begin{verbatim}
<build>
    <plugins>
        <plugin>
            <groupId>com.liferay</groupId>
            <artifactId>com.liferay.portal.tools.bundle.support</artifactId>
            <version>2.0.1</version>
            <executions>
                <execution>
                    <id>default-deploy</id>
                    <goals>
                        <goal>deploy</goal>
                    </goals>
                    <phase>pre-integration-test</phase>
                </execution>
            </executions>
        </plugin>
    </plugins>
</build>
\end{verbatim}

  This POM configuration applies Liferay's
  \href{https://repository.liferay.com/nexus/content/groups/public/com/liferay/com.liferay.portal.tools.bundle.support/}{Bundle
  Support plugin} by defining its \texttt{groupId}, \texttt{artifactId},
  and \texttt{version}. You can learn more about this plugin in the
  \href{/docs/7-0/tutorials/-/knowledge_base/t/maven-workspace}{Maven
  Workspace} tutorial. The logic also defines the
  \href{https://maven.apache.org/guides/mini/guide-configuring-plugins.html\#Using_the_executions_Tag}{\texttt{executions}
  tag}, which configures the Bundle Support plugin to run during the
  \texttt{pre-integration-test} phase of your Maven project's build
  lifecycle. The \texttt{deploy}
  \href{http://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html\#A_Build_Phase_is_Made_Up_of_Plugin_Goals}{goal}
  is defined for that lifecycle phase.
\item
  By default, the Bundle Support plugin deploys to the Liferay
  installation in the \texttt{bundles} folder, located in your plugin's
  parent folder. If you do not have your project set up this way, you
  must define your Liferay home folder in your POM. You can do this by
  adding the following logic within the \texttt{plugin} tags, but
  outside of the \texttt{execution} tags:

\begin{verbatim}
<configuration>
    <liferayHome>LIFERAY_HOME_PATH</liferayHome>
</configuration>
\end{verbatim}

  An example configuration would look like this:

\begin{verbatim}
<configuration>
    <liferayHome>C:/liferay/liferay-ce-portal-7.0-ga7</liferayHome>
</configuration>
\end{verbatim}
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** Maven applications built for previous Liferay Portal versions
 required the `<liferay.maven.plugin.version>` tag to do various tasks (e.g.,
 deploying to a Liferay server). This tag is not needed since the old
 `liferay-maven-plugin` is no longer used.
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\item
  Run this command to deploy your project:

\begin{verbatim}
mvn verify
\end{verbatim}
\end{enumerate}

That's it! Your Liferay Maven project is built and deployed
automatically to your Liferay DXP instance.

\section{Creating a Maven Repository}\label{creating-a-maven-repository}

You'll frequently want to share Liferay artifacts and modules with
teammates or manage your repositories using a GUI. Sonatype Nexus is a
valuable tool for managing your repositories. It's a Maven repository
management server that facilitates creating and managing release
servers, snapshot servers, and proxy servers. There are several other
Maven repository management servers you can use (for example,
\href{https://www.jfrog.com/artifactory/}{Artifactory}), but this
tutorial focuses on Nexus.

To create a Maven repository using Nexus, download
\href{http://www.sonatype.org/nexus/}{Nexus} and follow the instructions
at \url{http://books.sonatype.com/nexus-book/reference/install.html} to
install and start it.

To create your own repository using Nexus, follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open your web browser; navigate to your Nexus repository server (e.g.,
  \url{http://localhost:8081/nexus}) and log in. The default user name
  is \texttt{admin} with password \texttt{admin123}.
\item
  Click on \emph{Repositories} and navigate to \emph{Add\ldots{}} →
  \emph{Hosted Repository}.

  \begin{figure}
  \centering
  \includegraphics{./images/maven-nexus-create-repo.png}
  \caption{Adding a repository to hold your Liferay artifacts is easy
  with Nexus.}
  \end{figure}

  To learn more about each type of Nexus repository, read Sonatype's
  \href{http://books.sonatype.com/nexus-book/reference/confignx-sect-manage-repo.html}{Managing
  Repositories} guide.
\item
  Enter repository properties appropriate for the type of artifacts it
  will hold. If you're installing release version artifacts into the
  repository, specify \emph{Release} as the repository policy. Below are
  example repository property values:

  \begin{itemize}
  \tightlist
  \item
    \textbf{Repository ID:} \emph{liferay-releases}
  \item
    \textbf{Repository Name:} \emph{Liferay Release Repository}
  \item
    \textbf{Provider:} \emph{Maven2}
  \item
    \textbf{Repository Policy:} \emph{Release}
  \end{itemize}
\item
  Click \emph{Save}.
\end{enumerate}

You just created a Liferay Maven repository accessible from your Nexus
repository server! Congratulations!

It's also useful to create a Maven repository to hold snapshots of each
Liferay module you create. Creating a snapshot repository is almost
identical to creating a release repository. The only difference is that
you specify \emph{Snapshot} as its repository policy. For example,
examine an example snapshot repository's property values:

\begin{itemize}
\tightlist
\item
  \textbf{Repository ID:} \emph{liferay-snapshots}
\item
  \textbf{Repository Name:} \emph{Liferay Snapshot Repository}
\item
  \textbf{Provider:} \emph{Maven2}
\item
  \textbf{Repository Policy:} \emph{Snapshot}
\end{itemize}

Voila! You've created a repository for your Liferay releases (i.e.,
\texttt{liferay-releases}) and Liferay snapshots (i.e.,
\texttt{liferay-snapshots}). To learn how to deploy your Liferay Maven
artifacts to a Nexus repository, see the
\href{/docs/7-0/tutorials/-/knowledge_base/t/deploying-liferay-maven-artifacts-to-a-repository}{Deploying
Liferay Maven Artifacts to a Repository} tutorial.

Next, you'll configure your new repository servers in your Maven
settings to install artifacts to them.

\subsection{Configuring Local Maven
Settings}\label{configuring-local-maven-settings}

Before using your repository servers, you must specify them in your
Maven environment settings. Your repository settings let Maven find the
repository and retrieve and install artifacts. You can configure your
local Maven settings in the \texttt{{[}USER\_HOME{]}/.m2/settings.xml}
file.

You only need to configure a repository server if you're sharing
artifacts (e.g., Liferay artifacts and/or your modules) with others. If
you're automatically installing Liferay artifacts from the
Central/Liferay Repository and aren't interested in sharing artifacts,
you don't need a repository server specified in your Maven settings. You
can find out more about installing artifacts from the Central Repository
or Liferay's own Nexus repository in the
\href{/docs/7-0/tutorials/-/knowledge_base/t/installing-liferay-maven-artifacts}{Installing
Liferay Maven Artifacts} tutorial.

To configure your Maven environment to access your
\texttt{liferay-releases} and \texttt{liferay-snapshots} repository
servers, do the following:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Navigate to your \texttt{{[}USER\_HOME{]}/.m2/settings.xml} file.
  Create it if it doesn't yet exist.
\item
  Provide settings for your repository servers. Here are contents from a
  \texttt{settings.xml} file that has \texttt{liferay-releases} and
  \texttt{liferay-snapshots} repository servers configured:

\begin{verbatim}
<?xml version="1.0"?>
<settings>
    <servers>
        <server>
            <id>liferay-releases</id>
            <username>admin</username>
            <password>admin123</password>
        </server>
        <server>
            <id>liferay-snapshots</id>
            <username>admin</username>
            <password>admin123</password>
        </server>
    </servers>
</settings>
\end{verbatim}
\end{enumerate}

The user name \texttt{admin} and password \texttt{admin123} are the
credentials of the default Nexus administrator account. If you changed
these credentials for your Nexus server, make sure to update
\texttt{settings.xml} with these changes.

Now that your repositories are configured, they're ready to receive all
the Liferay Maven artifacts you'll download and the Liferay module
artifacts you'll create!

\section{Deploying Liferay Maven Artifacts to a
Repository}\label{deploying-liferay-maven-artifacts-to-a-repository}

Deploying artifacts to a remote repository is important if you intend to
share your Maven projects with others. First, you must have a remote
repository that can hold deployed Maven artifacts. If you do not
currently have a remote repository, see the
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-a-maven-repository}{Creating
a Maven Repository} tutorial to learn how you can set up a Nexus
repository. Also make sure your
\texttt{{[}USER\_HOME{]}/.m2/settings.xml} file specifies your remote
repository's ID, user name, and password.

To deploy to a remote repository, your Liferay module should be packaged
using Maven. Maven provides a packaging command that creates an artifact
(JAR) that can be easily deployed to your remote repository. You'll
learn how to do this with a Liferay portlet module.

Once you've created a deployable artifact, you'll configure your module
project to communicate with your remote repository and use Maven's
deploy command to send it on its way. Once your module project resides
on the remote repository, other developers can configure your remote
repository in their projects and set dependencies in their project POMs
to reference it.

To follow this tutorial, you'll need a Liferay module built with Maven.
For demonstration purposes, this tutorial uses the \texttt{portlet.ds}
sample module project. To follow along with this module, download the
\href{https://portal.liferay.dev/documents/113763090/114000186/portlet.ds.zip}{portlet.ds}
ZIP.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a folder anywhere on your machine to serve as the parent folder
  for your Liferay modules. Unzip the \texttt{portlet.ds} module project
  into that folder.
\item
  Create a \texttt{pom.xml} file inside this folder. Copy the following
  logic into the parent POM:

\begin{verbatim}
<?xml version="1.0" encoding="UTF-8"?>
<project
    xmlns="http://maven.apache.org/POM/4.0.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"
>

    <modelVersion>4.0.0</modelVersion>
    <groupId>liferay.sample</groupId>
    <artifactId>liferay.sample.maven</artifactId>
    <version>1.0.0</version>
    <name>Liferay Maven Module Projects</name>
    <packaging>pom</packaging>

    <distributionManagement>
        <repository>
            <id>liferay-releases</id>
            <url>http://localhost:8081/nexus/content/repositories/liferay-releases</url>
        </repository>
    </distributionManagement>

    <modules>
        <module>portlet.ds</module>
    </modules>
</project>
\end{verbatim}

  The tags \texttt{\textless{}modelVersion\textgreater{}} through
  \texttt{\textless{}packaging\textgreater{}} are POM tags that are used
  frequently in parent POMs. Visit Maven's
  \href{https://maven.apache.org/pom.html}{POM Reference} documentation
  for more information.

  The \texttt{\textless{}distributionManagement\textgreater{}} tag
  specifies the deployment repository for all module projects residing
  in the parent folder. You should include the repository's ID and URL.
  The above \texttt{distributionManagement} declaration is configured
  for the Liferay Nexus repository created in the
  \href{/docs/7-0/tutorials/-/knowledge_base/t/creating-a-maven-repository}{Creating
  a Maven Repository} tutorial. That tutorial also created the
  \texttt{{[}USER\_HOME{]}/.m2/settings.xml}, which specified the remote
  repository's ID, user name, and password. Both the parent POM and
  \texttt{settings.xml} file's repository declarations are required to
  deploy your modules to that remote repository.

  Finally, you must list the modules residing in the parent folder that
  you want deployed using the \texttt{\textless{}modules\textgreater{}}
  tag. The \texttt{portlet.ds} module is specified within that tag.
\item
  Open the \texttt{portlet.ds} module's \texttt{pom.xml} file. If you
  did not download the \texttt{portlet.ds} module project Zip, you can
  reference its POM below.

\begin{verbatim}
<project
    xmlns="http://maven.apache.org/POM/4.0.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"
>

    <modelVersion>4.0.0</modelVersion>
    <artifactId>portlet.ds</artifactId>
    <version>1.0.0</version>
    <packaging>jar</packaging>

    <parent>
        <groupId>liferay.sample</groupId>
        <artifactId>liferay.sample.maven</artifactId>
        <version>1.0.0</version>
        <relativePath>../pom.xml</relativePath>
    </parent>

    <dependencies>
        <dependency>
            <groupId>javax.portlet</groupId>
            <artifactId>portlet-api</artifactId>
            <version>2.0</version>
            <scope>provided</scope>
        </dependency>
        <dependency>
            <groupId>org.osgi</groupId>
            <artifactId>org.osgi.service.component.annotations</artifactId>
            <version>1.3.0</version>
            <scope>provided</scope>
        </dependency>
    </dependencies>
</project>
\end{verbatim}

  The \texttt{portlet.ds} module's POM specifies its own attributes
  first, followed by the parent POM's attributes. Declaring the
  \texttt{\textless{}parent\textgreater{}} tag like above links the
  \texttt{portlet.ds} module to its parent POM, which is necessary to
  deploy to the remote repository. Then the module's dependencies are
  listed. These dependencies are downloaded from the Central Repository
  and installed to your local \texttt{.m2} repository when you package
  the \texttt{portlet.ds} module.
\item
  Now that you've configured your parent POM and module POM, package
  your Maven project. Navigate to your module project (e.g.,
  \texttt{project.ds}) in your command prompt and run the Maven package
  command:

\begin{verbatim}
mvn package
\end{verbatim}

  This downloads and installs all your module's dependencies and
  packages the project into a JAR file. Navigate to your module
  project's generated build folder (e.g., \texttt{/target}). You'll
  notice there is a newly generated JAR file. This is the artifact
  you'll deploy to your Nexus repository.
\item
  Run Maven's deploy command to deploy your module project's artifact to
  your configured remote repository.

\begin{verbatim}
mvn deploy
\end{verbatim}

  Your console shows output from the artifact being deployed into your
  repository server.
\end{enumerate}

To verify that your artifact is deployed, navigate to the Repositories
page of your Nexus server and select your repository. A window appears
below showing the Liferay artifact now deployed to your repository.

\begin{figure}
\centering
\includegraphics{./images/maven-verify-deployment.png}
\caption{Your repository server now provides access to your Liferay
Maven artifacts.}
\end{figure}

Awesome! You can now share your Liferay module projects with anyone by
deploying them as artifacts to a remote repository!

\section{Using Service Builder in a Maven
Project}\label{using-service-builder-in-a-maven-project}

Liferay's
\href{/docs/7-0/tutorials/-/knowledge_base/t/what-is-service-builder}{Service
Builder} is a model-driven service generation tool that is frequently
used by many Liferay module projects. If you have a Liferay Maven
project, you may be wondering if Service Builder works with your Maven
modules; the answer is a resounding yes!

The easiest way to add Service Builder to your Maven project is to
create a new Maven project using Liferay's provided Service Builder
archetype. You can learn how to generate a Service Builder Maven project
by visiting the
\href{/docs/7-0/reference/-/knowledge_base/r/using-the-service-builder-template}{Service
Builder Template} tutorial. In some cases, this may not be possible due
to a number of reasons:

\begin{itemize}
\tightlist
\item
  You're updating a legacy Maven project to follow OSGi modular
  architecture.
\item
  You have a pre-existing modular Maven project and don't want to start
  over.
\end{itemize}

Time to get started!

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Apply the Service Builder plugin in your Maven project's
  \texttt{pom.xml} file:

\begin{verbatim}
<build>
    <plugins>
        <plugin>
            <groupId>com.liferay</groupId>
            <artifactId>com.liferay.portal.tools.service.builder</artifactId>
            <version>1.0.174</version>
            <configuration>
                <apiDirName>../blade.servicebuilder.api/src/main/java</apiDirName>
                <autoImportDefaultReferences>true</autoImportDefaultReferences>
                <autoNamespaceTables>true</autoNamespaceTables>
                <buildNumberIncrement>true</buildNumberIncrement>
                <hbmFileName>src/main/resources/META-INF/module-hbm.xml</hbmFileName>
                <implDirName>src/main/java</implDirName>
                <inputFileName>service.xml</inputFileName>
                <mergeModelHintsConfigs>src/main/resources/META-INF/portlet-model-hints.xml</mergeModelHintsConfigs>
                <modelHintsFileName>src/main/resources/META-INF/portlet-model-hints.xml</modelHintsFileName>
                <osgiModule>true</osgiModule>
                <propsUtil>com.liferay.blade.samples.servicebuilder.service.util.PropsUtil</propsUtil>
                <resourcesDirName>src/main/resources</resourcesDirName>
                <springFileName>src/main/resources/META-INF/spring/module-spring.xml</springFileName>
                <springNamespaces>beans,osgi</springNamespaces>
                <sqlDirName>src/main/resources/META-INF/sql</sqlDirName>
                <sqlFileName>tables.sql</sqlFileName>
                <testDirName>src/main/test</testDirName>
            </configuration>
        </plugin>
    </plugins>
</build>
\end{verbatim}

  Service Builder is applied by specifying its \texttt{groupId},
  \texttt{artifactId}, and \texttt{version}. The \texttt{configuration}
  tag used above is an example of what a Service Builder project's
  configuration could look like. All the configuration attributes above
  should be modified to fit your project.

  The above code configures Service Builder for a
  \texttt{blade.servicebuilder.svc} module. When running Service Builder
  with this configuration, the project's API classes are generated in
  the \texttt{blade.servicebuilder.api} module's \texttt{src/main/java}
  folder. You can also specify your hibernate module mappings,
  implementation directory name, model hints file, Spring
  configurations, SQL configurations, etc. You can reference all the
  configurable Service Builder properties in the
  \href{/docs/7-0/reference/-/knowledge_base/r/service-builder-with-maven}{Service
  Builder with Maven} reference article. Also, visit the
  \href{/docs/7-0/tutorials/-/knowledge_base/t/defining-an-object-relational-map-with-service-builder}{Defining
  an Object-Relational Map with Service Builder} tutorial for more
  information on defining a \texttt{service.xml} file to configure
  Service Builder.
\item
  Apply the WSDD Builder plugin declaration directly after the Service
  Builder plugin declaration:

\begin{verbatim}
<plugin>
    <groupId>com.liferay</groupId>
    <artifactId>com.liferay.portal.tools.wsdd.builder</artifactId>
    <version>1.0.8</version>
    <configuration>
        <inputFileName>service.xml</inputFileName>
        <outputDirName>src/main/java</outputDirName>
        <serverConfigFileName>src/main/resources/server-config.wsdd</serverConfigFileName>
    </configuration>
</plugin>
\end{verbatim}

  The WSDD Builder is necessary to generate your project's remote
  services. Visit the
  \href{/docs/7-0/tutorials/-/knowledge_base/t/creating-remote-services}{Creating
  Remote Services} tutorial for more information on WSDD (Web Service
  Deployment Descriptor). Similar to the Service Builder configuration,
  the \texttt{service.xml} file is set to define your project's remote
  services. Also, the \texttt{outputDirName} defines where the
  \texttt{*\_deploy.wsdd} and \texttt{*\_undeploy.wsdd} files are
  generated. Make sure to define your
  \href{http://axis.apache.org/axis/java/reference.html\#Global_Axis_Configuration}{\texttt{server-config.wsdd}
  file}, as well.
\end{enumerate}

Terrific! You've successfully configured your Maven project to use
Service Builder by applying the
\texttt{com.liferay.portal.tools.service.builder} and
\texttt{com.liferay.portal.tools.wsdd.builder} plugins in your project's
POM. To run Service Builder, see the
\href{/docs/7-0/tutorials/-/knowledge_base/t/running-service-builder-and-understanding-the-generated-code}{Running
Service Builder and Understanding the Generated Code} tutorial for
instructions.

\section{Compiling Sass Files in a Maven
Project}\label{compiling-sass-files-in-a-maven-project}

If your Liferay Maven project uses Sass files to style its UI, you must
configure the project to convert its Sass files into CSS files so they
are recognizable for Maven's build lifecycle. It would be a real pain to
convert your Sass files into CSS files manually before building your
Maven project!

Liferay provides the \texttt{com.liferay.css.builder} plugin. The CSS
Builder converts Sass files into CSS files so the Maven build can parse
your style sheets.

Here's how to apply Liferay's CSS builder to your Maven project.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open your project's \texttt{pom.xml} file and apply Liferay's CSS
  Builder:

\begin{verbatim}
<plugin>
    <groupId>com.liferay</groupId>
    <artifactId>com.liferay.css.builder</artifactId>
    <version>2.0.1</version>
    <executions>
        <execution>
            <id>default-build</id>
            <phase>compile</phase>
            <goals>
                <goal>build</goal>
            </goals>
        </execution>
    </executions>
    <configuration>
        <docrootDirName>${com.liferay.portal.tools.theme.builder.outputDir}</docrootDirName>
        <outputDirName>/</outputDirName>
        <portalCommonPath>target/deps/com.liferay.frontend.css.common.jar</portalCommonPath>
    </configuration>
</plugin>
\end{verbatim}

  The above configuration applies the CSS Builder by specifying its
  \texttt{groupId}, \texttt{artifactId}, and \texttt{version}. It then
  defines the CSS Builder's execution and configuration.

  \begin{itemize}
  \tightlist
  \item
    The
    \href{https://maven.apache.org/guides/mini/guide-configuring-plugins.html\#Using_the_executions_Tag}{\texttt{executions}
    tag} configures the CSS Builder to run during the \texttt{compile}
    phase of your Maven project's build lifecycle. The \texttt{build}
    \href{http://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html\#A_Build_Phase_is_Made_Up_of_Plugin_Goals}{goal}
    is defined for that lifecycle phase.
  \item
    The
    \href{https://maven.apache.org/pom.html\#Plugins}{\texttt{configuration}
    tag} defines two important properties:

    \begin{itemize}
    \tightlist
    \item
      \texttt{docrootDirName}: The base \texttt{resources} folder
      containing the Sass files to compile.
    \item
      \texttt{outputDirName}: The name of the sub-directories where the
      SCSS files are compiled to.
    \item
      \texttt{portalCommonPath}: The file path for the
      \href{https://mvnrepository.com/artifact/com.liferay/com.liferay.frontend.css.common}{Liferay
      Frontend Common CSS JAR} file.
    \end{itemize}
  \end{itemize}
\item
  If you're using \href{http://bourbon.io/}{Bourbon} in your Sass files,
  you'll need to
  \href{/docs/7-0/tutorials/-/knowledge_base/t/configuring-dependencies}{add
  an additional plugin dependency} to your project's POM. If you're not
  using Bourbon, skip this step. Add the following plugin dependency:

\begin{verbatim}
<plugin>
    <artifactId>maven-dependency-plugin</artifactId>
    <executions>
        <execution>
            <phase>generate-sources</phase>
            <goals>
                <goal>copy</goal>
            </goals>
            <configuration>
                <artifactItems>
                    <artifactItem>
                        <groupId>com.liferay</groupId>
                        <artifactId>com.liferay.frontend.css.common</artifactId>
                        <version>2.0.4</version>
                    </artifactItem>
                </artifactItems>
                <outputDirectory>${project.build.directory}/deps</outputDirectory>
                <stripVersion>true</stripVersion>
            </configuration>
        </execution>
    </executions>
</plugin>
\end{verbatim}

  The
  \href{http://maven.apache.org/plugins/maven-dependency-plugin/}{maven-dependency-plugin}
  copies the \texttt{com.liferay.frontend.css.common} dependency from
  Maven Central to your project's build folder so the CSS Builder can
  leverage it.
\item
  Use this command to compile your Maven project's Sass files:

\begin{verbatim}
mvn compile
\end{verbatim}
\end{enumerate}

\noindent\hrulefill

\textbf{Note:} Liferay's CSS Builder is supported for Oracle's JDK and
uses a native compiler for increased speed. If you're using an IBM JDK,
you may experience issues when building your SASS files (e.g., when
building a theme). It's recommended to switch to using the Oracle JDK,
but if you prefer using the IBM JDK, you must use the fallback Ruby
compiler. To do this, add the following tag to your CSS Builder
configuration in your POM:

\begin{verbatim}
 <sassCompilerClassName>ruby</sasscompilerClassName>
\end{verbatim}

Be aware that the Ruby-based compiler doesn't perform as well as the
native compiler, so expect longer compile times.

\noindent\hrulefill

Awesome! You can now compile Sass files in your Liferay Maven project.

\section{Building Themes in a Maven
Project}\label{building-themes-in-a-maven-project}

Liferay's Theme Builder is a tool used to build Liferay DXP theme files
in your project. You can incorporate the Theme Builder into your Maven
project to generate WAR-style themes deployable to Liferay DXP. To learn
more about theming in Liferay DXP, see the
\href{/docs/7-0/tutorials/-/knowledge_base/t/themes-and-layout-templates}{Themes
and Layout Templates} tutorial section.

The easiest way to create a Liferay theme with Maven is to create a new
Maven project using Liferay's provided Theme archetype. You can learn
how to generate a Maven Theme project by visiting the
\href{/docs/7-0/tutorials/-/knowledge_base/t/generating-new-projects-using-archetypes}{Generating
New Projects Using Archetypes} tutorial. In some cases, however, this
may not be convenient. For instance, if you have a legacy theme project
and don't want to start over, generating a new project is not ideal.

For cases like this, you should manually configure your Maven project to
build a theme. You'll learn how to do this next.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Configure Liferay's Theme Builder plugin in your project's
  \texttt{pom.xml} file:

\begin{verbatim}
<build>
    <plugins>
        <plugin>
            <groupId>com.liferay</groupId>
            <artifactId>com.liferay.portal.tools.theme.builder</artifactId>
            <version>${com.liferay.portal.tools.theme.builder.version}</version>
            <executions>
                <execution>
                    <phase>generate-resources</phase>
                    <goals>
                        <goal>build</goal>
                    </goals>
                    <configuration>
                        <diffsDir>${maven.war.src}</diffsDir>
                        <name>${project.artifactId}</name>
                        <outputDir>${project.build.directory}/${project.build.finalName}</outputDir>
                        <parentDir>${project.build.directory}/deps/com.liferay.frontend.theme.styled.jar</parentDir>
                        <parentName>_styled</parentName>
                        <templateExtension>ftl</templateExtension>
                        <unstyledDir>${project.build.directory}/deps/com.liferay.frontend.theme.unstyled.jar</unstyledDir>
                    </configuration>
                </execution>
            </executions>
        </plugin>
    </plugins>
</build>
\end{verbatim}

  The above configuration applies the Theme Builder by specifying its
  \texttt{groupId}, \texttt{artifactId}, and \texttt{version}. It then
  defines the Theme Builder's execution and configuration.

  \begin{itemize}
  \tightlist
  \item
    The
    \href{https://maven.apache.org/guides/mini/guide-configuring-plugins.html\#Using_the_executions_Tag}{\texttt{executions}
    tag} configures the Theme Builder to run during the
    \texttt{generate-resources} phase of your Maven project's build
    lifecycle. The \texttt{build}
    \href{http://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html\#A_Build_Phase_is_Made_Up_of_Plugin_Goals}{goal}
    is defined for that lifecycle phase.
  \item
    The
    \href{https://maven.apache.org/pom.html\#Plugins}{\texttt{configuration}
    tag} defines several important properties:

    \begin{itemize}
    \tightlist
    \item
      \texttt{diffsDir}: The folder holding the files to copy over the
      parent theme.
    \item
      \texttt{name}: The new theme's name.
    \item
      \texttt{outputDir}: The folder to build the theme.
    \item
      \texttt{parentDir}: The parent theme's folder.
    \item
      \texttt{parentName}: The parent theme's name.
    \item
      \texttt{templateExtension}: The extension of the template files
      (e.g., \texttt{ftl} or \texttt{vm}).
    \item
      \texttt{unstyledDir}: The unstyled theme's folder.
    \end{itemize}
  \end{itemize}
\item
  Apply the CSS Builder plugin, which is required to use the Theme
  Builder:

\begin{verbatim}
<plugin>
    <groupId>com.liferay</groupId>
    <artifactId>com.liferay.css.builder</artifactId>
    <version>${com.liferay.css.builder.version}</version>
    <executions>
        <execution>
            <id>default-build</id>
            <phase>compile</phase>
            <goals>
                <goal>build</goal>
            </goals>
        </execution>
    </executions>
    <configuration>
        <docrootDirName>target/${project.build.finalName}</docrootDirName>
        <outputDirName>/</outputDirName>
        <portalCommonPath>target/deps/com.liferay.frontend.css.common.jar</portalCommonPath>
    </configuration>
</plugin>
\end{verbatim}

  You can learn more about the CSS Builder's Maven configuration by
  visiting the
  \href{/docs/7-0/tutorials/-/knowledge_base/t/compiling-sass-files-in-a-maven-project}{Compiling
  Sass Files in a Maven Project} tutorial.
\item
  You can configure your project to exclude Sass files from being
  packaged in your theme. This is optional, but is a nice convenience to
  keep any unnecessary source code out of your WAR. Since the Theme
  Builder creates a WAR-style theme, you should apply the
  \href{https://maven.apache.org/plugins/maven-war-plugin/}{maven-war-plugin}
  so it instructs the WAR file packaging process to exclude Sass files:

\begin{verbatim}
<plugin>
    <artifactId>maven-war-plugin</artifactId>
    <version>3.0.0</version>
    <configuration>
        <packagingExcludes>**/*.scss</packagingExcludes>
    </configuration>
</plugin>
\end{verbatim}
\item
  Insert the \texttt{\textless{}packaging\textgreater{}} tag in your
  project's POM so your project is correctly packaged as a WAR file.
  This tag can be placed with your project's \texttt{groupId},
  \texttt{artifactId}, and \texttt{version} specifications like this:

\begin{verbatim}
<groupId>com.liferay</groupId>
<artifactId>com.liferay.project.templates.theme</artifactId>
<version>1.0.0</version>
<packaging>war</packaging>
\end{verbatim}
\item
  Building themes requires certain dependencies. You can
  \href{/docs/7-0/tutorials/-/knowledge_base/t/configuring-dependencies}{configure
  these dependenices} in your project's \texttt{pom.xml} as directories
  or JAR files. If you choose to use JARs, you must apply the
  \href{http://maven.apache.org/plugins/maven-dependency-plugin/}{maven-dependency-plugin}
  and have it copy JAR dependencies into your project from Maven
  Central:

\begin{verbatim}
<plugin>
    <artifactId>maven-dependency-plugin</artifactId>
    <executions>
        <execution>
            <phase>generate-sources</phase>
            <goals>
                <goal>copy</goal>
            </goals>
            <configuration>
                <artifactItems>
                    <artifactItem>
                        <groupId>com.liferay</groupId>
                        <artifactId>com.liferay.frontend.css.common</artifactId>
                        <version>${com.liferay.frontend.css.common.version}</version>
                    </artifactItem>
                    <artifactItem>
                        <groupId>com.liferay</groupId>
                        <artifactId>com.liferay.frontend.theme.styled</artifactId>
                        <version>${com.liferay.frontend.theme.styled.version}</version>
                    </artifactItem>
                    <artifactItem>
                        <groupId>com.liferay</groupId>
                        <artifactId>com.liferay.frontend.theme.unstyled</artifactId>
                        <version>${com.liferay.frontend.theme.unstyled.version}</version>
                    </artifactItem>
                </artifactItems>
                <outputDirectory>${project.build.directory}/deps</outputDirectory>
                <stripVersion>true</stripVersion>
            </configuration>
        </execution>
    </executions>
</plugin>
\end{verbatim}

  This configuration copies the
  \texttt{com.liferay.frontend.css.common},
  \texttt{com.liferay.frontend.theme.styled}, and
  \texttt{com.liferay.frontend.theme.unstyled} dependencies into your
  Maven project. Notice that you've set the \texttt{stripVersion} tag to
  \texttt{true} and you're setting the artifact versions within each
  \texttt{artifactItem} tag. You'll set these versions and a few other
  properties for your Maven project next.
\item
  Configure the properties for your project in its \texttt{pom.xml}
  file:

\begin{verbatim}
<properties>
    <com.liferay.css.builder.version>2.0.1</com.liferay.css.builder.version>
    <com.liferay.frontend.css.common.version>2.0.4</com.liferay.frontend.css.common.version>
    <com.liferay.frontend.theme.styled.version>2.0.28</com.liferay.frontend.theme.styled.version>
    <com.liferay.frontend.theme.unstyled.version>2.2.5</com.liferay.frontend.theme.unstyled.version>
    <com.liferay.portal.tools.theme.builder.version>1.1.4</com.liferay.portal.tools.theme.builder.version>
</properties>
\end{verbatim}

  The properties above set the versions for the CSS and Theme Builder
  plugins and their dependencies.
\end{enumerate}

You've successfully configured your Maven project to build a Liferay
theme! For info on running the Theme Builder in your Maven project, see
the \href{/docs/7-0/tutorials/-/knowledge_base/t/theme-builder}{Theme
Builder} tutorial.

\section{Maven Workspace}\label{maven-workspace}

A Liferay Maven Workspace is a generated environment that is built to
hold and manage Liferay projects built with Maven. This workspace aids
in Liferay project management by applying various Maven plugins and
configured properties. The Liferay Maven Workspace offers a full
development lifecycle for your Maven projects to make developing them
for Liferay DXP easier than ever. In this tutorial, you'll learn how to
leverage the development lifecycle of a Liferay Maven Workspace.

First, you'll learn how to install a Maven Workspace.

\subsection{Installation}\label{installation}

The Maven Workspace is installed by generating the workspace project
from an archetype. You can do this by executing the following command
with your command line tool:

\begin{verbatim}
mvn archetype:generate \
    -DarchetypeGroupId=com.liferay \
    -DarchetypeArtifactId=com.liferay.project.templates.workspace \
    -DgroupId=[GROUP_ID] \
    -DartifactId=[WORKSPACE_NAME] \
    -Dversion=[VERSION]
\end{verbatim}

A Maven Workspace is generated in the current folder. No other tools or
CLIs are required for Maven Workspace.

\subsection{Anatomy}\label{anatomy}

The default Maven Workspace contains the following folders/files:

\begin{itemize}
\tightlist
\item
  \texttt{{[}MAVEN\_WORKSPACE{]}}

  \begin{itemize}
  \tightlist
  \item
    \texttt{configs}

    \begin{itemize}
    \tightlist
    \item
      \texttt{common}
    \item
      \texttt{dev}
    \item
      \texttt{local}
    \item
      \texttt{prod}
    \item
      \texttt{uat}
    \end{itemize}
  \item
    \texttt{modules}

    \begin{itemize}
    \tightlist
    \item
      \texttt{pom.xml}
    \end{itemize}
  \item
    \texttt{themes}

    \begin{itemize}
    \tightlist
    \item
      \texttt{pom.xml}
    \end{itemize}
  \item
    \texttt{wars}

    \begin{itemize}
    \tightlist
    \item
      \texttt{pom.xml}
    \end{itemize}
  \item
    \texttt{pom.xml}
  \end{itemize}
\end{itemize}

For more information on the \texttt{configs} folder, see the
\href{/docs/7-0/tutorials/-/knowledge_base/t/development-lifecycle-for-a-liferay-workspace\#testing-modules}{Testing
Modules} section. The \texttt{modules}, \texttt{themes}, and
\texttt{wars} folders hold projects of that type. The parent
\texttt{pom.xml} configures your workspace as a Maven project and
applies the
\href{https://repository.liferay.com/nexus/content/groups/public/com/liferay/com.liferay.portal.tools.bundle.support/}{Bundle
Support plugin}, which is required for your Maven Workspace to handle
7.0 projects. You can also
\hyperref[configuring-maven-workspace-properties]{configure workspace
properties} in your POM, which you'll learn about later.

Next, you'll learn how to initialize and package Liferay DXP bundles
using workspace.

\subsection{Adding a Liferay Bundle to a Maven
Workspace}\label{adding-a-liferay-bundle-to-a-maven-workspace}

Liferay Maven Workspaces can generate and hold a Liferay Server. This
lets you build/test your plugins against a running Liferay instance.
Before generating a Liferay instance, open the \texttt{pom.xml} file
located in your workspace's root folder and set the version of the
Liferay bundle to generate and install by setting the download URL for
the \texttt{liferay.workspace.bundle.url} property. For example,

\begin{verbatim}
<properties>
    <liferay.workspace.bundle.url>
        https://releases-cdn.liferay.com/portal/7.0.6-ga7/liferay-ce-portal-tomcat-7.0-ga7-20180507111753223.zip
    </liferay.workspace.bundle.url>
    ...
</properties>
\end{verbatim}

You can also set location of your Liferay bundle with the
\texttt{liferay.workspace.home.dir} property. It's set to
\texttt{bundles} by default.

\textbf{Important:} Make sure the
\texttt{com.liferay.portal.tools.bundle.support} plugin in your POM is
configured to use version \texttt{3.2.0+}. The
\texttt{liferay.workspace.bundle.url} property does not work for
workspaces using an older version of the Bundle Support plugin. See the
\href{updating-a-maven-workspace}{Updating a Maven Workspace} section
for instructions on how to update the plugin.

Once you've finalized your workspace properties, navigate to your
workspace's root folder and run

\begin{verbatim}
blade server init
\end{verbatim}

This uses workspace's pre-bundled and installs your Liferay DXP instance
in the \texttt{bundles} folder.
\href{/docs/7-0/tutorials/-/knowledge_base/t/blade-cli}{Blade CLI} tool
to download the version of Liferay DXP you specified in your POM file
and installs your Liferay DXP instance in the \texttt{bundles} folder.
If you prefer to not use Blade CLI or do not have it installed, the pure
Maven equivalent for this command is \texttt{mvn\ bundle-support:init}.

If you want to skip the downloading process, you can create the
\texttt{bundles} folder manually in your workspace's ROOT folder and
extract your Liferay Portal bundle to that folder.

You can also produce a distributable Liferay DXP bundle (Zip) from
within a workspace. To do this, navigate to your workspace's root folder
and run the following command:

\begin{verbatim}
mvn bundle-support:dist
\end{verbatim}

Your distribution file is available from the workspace's
\texttt{/target} folder.

\subsection{Configuring Maven Workspace
Properties}\label{configuring-maven-workspace-properties}

There are many configurable workspace properties you can set in the root
\texttt{pom.xml} file:

\begin{itemize}
\tightlist
\item
  \texttt{liferay.workspace.bundle.dest}: the destination folder for
  downloaded Liferay DXP bundle ZIP files.
\item
  \texttt{liferay.workspace.bundle.url}: the URL used to download the
  Liferay DXP bundle. For more information, see
  \hyperref[adding-a-liferay-bundle-to-a-maven-workspace]{Adding a
  Liferay Bundle to a Maven Workspace}.
\item
  \texttt{liferay.workspace.default.repository.enabled}: whether Liferay
  CDN is set as the default repository in the root project.
\item
  \texttt{liferay.workspace.deploy.war.dir}: the deployment folder for
  WAR projects.
\item
  \texttt{liferay.workspace.deploy.modules.dir}: the deployment folder
  for module projects.
\item
  \texttt{liferay.workspace.environment}: the name of a \texttt{configs}
  subfolder holding the Liferay DXP server configuration to use. See
  \href{/docs/7-0/tutorials/-/knowledge_base/t/development-lifecycle-for-a-liferay-workspace\#testing-modules}{Testing
  Modules} for more information.
\item
  \texttt{liferay.workspace.home.dir}: the Liferay DXP bundle root
  folder.
\item
  \texttt{liferay.workspace.modules.default.repository.enabled}: whether
  the Liferay CDN is set as the default repository for module projects.
\item
  \texttt{liferay.workspace.modules.dir}: the module projects' root
  folder.
\item
  \texttt{liferay.workspace.plugins.sdk.dir}: the converted Plugins
  SDK's root folder. For more information, see
  \href{/docs/7-0/tutorials/-/knowledge_base/t/configuring-a-liferay-workspace\#using-a-plugins-sdk-from-your-workspace}{Using
  a Plugins SDK from Your Workspace}
\item
  \texttt{liferay.workspace.themes.dir}: the theme projects' root
  folder.
\item
  \texttt{liferay.workspace.wars.dir}: the WAR projects' root folder.
\end{itemize}

Properties can be set by adding tags with the property name. See the
property configurations below for an example on how these can be set in
your POM:

\begin{verbatim}
<properties>
    <liferay.workspace.home.dir>${liferay.workspace.basedir}/bundles</liferay.workspace.home.dir>
    <liferay.workspace.bundle.dest>${user.home}/.liferay/bundles/liferay-ce-portal-tomcat-7.0-ga7-20180507111753223.zip</liferay.workspace.bundle.dest>
    <liferay.workspace.bundle.url>https://releases-cdn.liferay.com/portal/7.0.6-ga7/liferay-ce-portal-tomcat-7.0-ga7-20180507111753223.zip</liferay.workspace.bundle.url>
    <liferay.workspace.deploy.war.dir>${liferay.workspace.home.dir}/osgi/war</liferay.workspace.deploy.war.dir>
    <liferay.workspace.deploy.modules.dir>${liferay.workspace.home.dir}/osgi/modules</liferay.workspace.deploy.modules.dir>
    <liferay.workspace.environment>local</liferay.workspace.environment>
</properties>
\end{verbatim}

Next, you'll learn how to add and deploy modules/projects in your Maven
Workspace.

\subsection{Module Management}\label{module-management}

Maven Workspace makes managing your Maven project easier than ever. To
create a project, navigate to the appropriate workspace folder for that
type of project (e.g., \texttt{modules}, \texttt{wars}, etc.). Then
generate the project archetype. You can view a full listing of the
available archetypes in the
\href{/docs/7-0/reference/-/knowledge_base/r/project-templates}{Project
Templates} reference section. Once the project is generated, it can
leverage all of Maven Workspace's functionality.

Maven Workspace also lets you deploy your projects to Liferay DXP using
Maven. See the
\href{/docs/7-0/tutorials/-/knowledge_base/t/deploying-a-module-built-with-maven-to-product}{Deploying
a Module Built with Maven to Liferay DXP} tutorial for more information.

Want to leverage Maven Workspace's testing infrastructure so you can
simulate your Maven projects in a specific environment? See the
\href{/docs/7-0/tutorials/-/knowledge_base/t/development-lifecycle-for-a-liferay-workspace\#testing-modules}{Testing
Modules} section for more information.

Once you have your Maven projects solidified and ready for the
limelight, it'd be great to release your projects to the public. Maven
Workspace doesn't provide this functionality, but there are easy ways to
use external release tools with workspace. See the
\href{/docs/7-0/tutorials/-/knowledge_base/t/development-lifecycle-for-a-liferay-workspace\#releasing-modules}{Releasing
Modules} section for more information.

Next, you'll learn how to update a Maven Workspace.

\subsection{Updating a Maven
Workspace}\label{updating-a-maven-workspace}

Liferay Workspace is updated periodically with new features, so you'll
want to update your workspace instance accordingly. To update your Maven
Workspace, you must update the Bundle Support plugin configured in your
workspace's root \texttt{pom.xml} file:

\begin{verbatim}
<plugin>
    <groupId>com.liferay</groupId>
    <artifactId>com.liferay.portal.tools.bundle.support</artifactId>
    <version>3.2.5</version>
    ...
</plugin>
\end{verbatim}

Update the version to the latest available release. You can reference
the available releases for the Bundle Support plugin
\href{https://repository.liferay.com/nexus/content/repositories/liferay-public-releases/com/liferay/com.liferay.portal.tools.bundle.support/}{here}.

\chapter{IntelliJ IDEA}\label{intellij-idea}

The
\href{https://plugins.jetbrains.com/plugin/10739-liferay-intellij-plugin}{Liferay
IntelliJ plugin} provides support for Liferay DXP development in
\href{https://www.jetbrains.com/idea/}{IntelliJ IDEA}. Liferay's
IntelliJ plugin provides the following built-in features:

\begin{itemize}
\tightlist
\item
  Creating a Liferay Workspace (Gradle and Maven based)
\item
  Creating Liferay projects (Gradle and Maven based)
\item
  Liferay DXP Tomcat server support for project deployment and debugging
\item
  Support for adding line markers for each entity in the service editor
\item
  Syntax checking, highlighting, and code completion (e.g., Bnd and XML
  files)
\end{itemize}

In these tutorials, you'll learn how to install the Liferay IntelliJ
plugin and leverage its features to improve Liferay development with
IntelliJ IDEA.

\section{Installing the Liferay IntelliJ
Plugin}\label{installing-the-liferay-intellij-plugin}

To install the Liferay IntelliJ plugin in IntelliJ IDEA, follow the
steps below:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Navigate to the
  \href{https://plugins.jetbrains.com/plugin/10739-liferay-intellij-plugin}{JetBrains'
  Liferay IntelliJ plugin} page and download it to your local machine.
\item
  In IntelliJ, navigate to \emph{File} → \emph{Settings} →
  \emph{Plugins} and select \emph{Install plugin from disk\ldots{}}.
\item
  Select the Liferay IntelliJ plugin ZIP and select \emph{OK} →
  \emph{OK} → \emph{Restart}.
\end{enumerate}

Once IntelliJ restarts, the Liferay IntelliJ plugin is installed and
ready for use. Great job! You're now ready to develop for Liferay DXP in
IntelliJ!

\section{Creating a Liferay Workspace with IntelliJ
IDEA}\label{creating-a-liferay-workspace-with-intellij-idea}

In this tutorial, you'll learn how to generate a Liferay Workspace using
IntelliJ IDEA, which runs on
\href{/docs/7-0/tutorials/-/knowledge_base/t/blade-cli}{Blade CLI}
behind the scenes. IntelliJ gives you a graphical interface instead of
the command prompt, which can streamline your workflow. You'll also
learn how to import an existing Liferay Workspace into IntelliJ. To
learn more about Liferay Workspaces, visit its dedicated
\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-workspace}{tutorial
section}.

\subsection{Creating a Liferay
Workspace}\label{creating-a-liferay-workspace-1}

Follow the steps below to create a Liferay Workspace:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open the New Project wizard by selecting \emph{File} → \emph{New} →
  \emph{Project}. If you're starting IntelliJ for the first time, you
  can do this by selecting \emph{Create New Project} in the opening
  window.
\item
  Select \emph{Liferay} from the left menu.
\item
  Choose the build type for your workspace (i.e., Gradle or Maven). Then
  click \emph{Next}.

  \begin{figure}
  \centering
  \includegraphics{./images/intellij-workspace-build.png}
  \caption{Choose \emph{Liferay Gradle Workspace} or \emph{Liferay Maven
  Workspace}, depending on the build you prefer.}
  \end{figure}
\item
  Specify your workspace's name, location, intended Liferay DXP version,
  and SDK (i.e., Java JDK). Then click \emph{Finish}.

  \begin{figure}
  \centering
  \includegraphics{./images/intellij-workspace-project.png}
  \caption{Specify your workspace's configurations.}
  \end{figure}
\item
  A window opens for additional build configurations for the build type
  you selected (i.e., Gradle or Maven). Verify the settings and click
  \emph{OK}.
\end{enumerate}

Awesome! You've successfully created a Liferay Workspace in IntelliJ
IDEA!

\subsection{Importing a Liferay
Workspace}\label{importing-a-liferay-workspace}

To import an existing workspace into IntelliJ, follow the steps below:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Select \emph{File} → \emph{New} → \emph{Project from Existing
  Sources\ldots{}}.
\item
  Select the workspace you want to import. Then click \emph{OK}.

  \begin{figure}
  \centering
  \includegraphics{./images/intellij-import-workspace.png}
  \caption{Specify your workspace's configurations.}
  \end{figure}
\item
  Click the \emph{Import project from external model} radio button and
  select the build tool your workspace uses (e.g., Gradle or Maven).
\item
  Configure the project import (if necessary) and then click
  \emph{Finish}. See the
  \href{https://www.jetbrains.com/help/idea/creating-and-managing-projects.html\#importing-project}{Import
  a Project} section of IntelliJ's official documentation for more
  information.
\item
  Step through the remaining import prompts and then open your imported
  workspace as you desire (i.e., in the current window or a new window).
\end{enumerate}

Excellent! Your existing Liferay Workspace is now imported in IntelliJ
IDEA!

\section{Creating Projects with IntelliJ
IDEA}\label{creating-projects-with-intellij-idea}

IntelliJ IDEA provides a New Liferay Modules wizard to create a variety
of different module projects. You can also use the same wizard to create
theme projects, WAR-style projects, and more. Before beginning, ensure
you've
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-a-liferay-workspace-with-intellij-idea}{created/imported
a Liferay Workspace} in your IntelliJ environment. Follow the steps
below to create a Liferay DXP module:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Navigate to \emph{File} → \emph{New} → \emph{Liferay Module}.

  \begin{figure}
  \centering
  \includegraphics{./images/intellij-new-liferay-module.png}
  \caption{Selecting \emph{Liferay Module} opens the New Liferay Modules
  wizard.}
  \end{figure}
\item
  Select the project you want to create. Although the wizard
  characterizes itself for \emph{modules}, there are many available
  projects that are not OSGi-based modules (e.g., \texttt{theme},
  \texttt{war-mvc-portlet}, etc.). See the
  \href{/docs/7-0/reference/-/knowledge_base/r/project-templates}{Project
  Templates} reference section for more information on the available
  templates.

  \begin{figure}
  \centering
  \includegraphics{./images/intellij-modules.png}
  \caption{Choose the project template to create your module.}
  \end{figure}
\item
  Configure your project's SDK (i.e., JDK), package name, class name,
  and service name, if necessary. Then click \emph{Next}.
\item
  Give your project a name. Then click \emph{Finish}.
\end{enumerate}

Awesome! Your project is available under its project type folder in your
workspace.

\section{Installing a Server in IntelliJ
IDEA}\label{installing-a-server-in-intellij-idea}

Installing a Liferay server in IntelliJ is easy. In just a few steps,
you'll have your server up and running.

\noindent\hrulefill

\textbf{Note:} Tomcat and Wildfly are the only supported Liferay app
server bundles available to install in IntelliJ.

\noindent\hrulefill

Follow these steps to install your server:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Right-click your Liferay workspace and select \emph{Liferay} →
  \emph{InitBundle}.

  This downloads the Liferay DXP bundle specified in your workspace's
  \texttt{gradle.properties} file. You can change the default bundle by
  updating the \texttt{liferay.workspace.bundle.url} property. For
  example, this is required to update the default bundle version and/or
  type (e.g., Wildfly). The downloaded bundle is stored in the
  workspace's \texttt{bundles} folder.
\item
  Navigate to the top right Configurations dropdown menu and select
  \emph{Edit Configurations}. From here, you can configure your server's
  run and debug configurations.

  \begin{figure}
  \centering
  \includegraphics{./images/intellij-server-dropdown.png}
  \caption{You have several options to choose from the server dropdown
  menu.}
  \end{figure}
\item
  Click the \emph{Add New Configuration} button
  (\includegraphics{./images/icon-intellij-add-config.png}) and
  select \emph{Liferay Server}.
\item
  Give your server a better name and modify any other configurations, if
  necessary. Then select \emph{OK} .

  \begin{figure}
  \centering
  \includegraphics{./images/intellij-run-debug-wizard.png}
  \caption{Set your Liferay server's configurations in the Run/Debug
  Configurations menu.}
  \end{figure}
\end{enumerate}

Your server is now available in IntelliJ! Make sure to select it in the
Configurations dropdown before executing the configuration buttons
(below).

For reference, here's how the IntelliJ configuration buttons work with
your Liferay DXP instance:

\begin{itemize}
\tightlist
\item
  \emph{Start}
  (\includegraphics{./images/icon-intellij-start-server.png}):
  Starts the server.
\item
  \emph{Stop}
  (\includegraphics{./images/icon-intellij-stop-server.png}):
  Stops the server.
\item
  \emph{Debug}
  (\includegraphics{./images/icon-intellij-debug-server.png}):
  Starts the server in debug mode. For more information on debugging in
  IntelliJ, see the
  \href{https://www.jetbrains.com/help/idea/debugging-code.html}{IntelliJ
  Debugging} article.
\end{itemize}

Now you're ready to use your server in IntelliJ!

\section{Deploying Projects with IntelliJ
IDEA}\label{deploying-projects-with-intellij-idea}

Once you've
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-projects-with-intellij-idea}{created
a project} and
\href{/docs/7-0/tutorials/-/knowledge_base/t/installing-a-server-in-intellij-idea}{installed
your Liferay server} in IntelliJ, you'll want to deploy your project.
Follow the steps below to do this:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Right-click your project from within the Liferay Workspace folder
  structure and select \emph{Liferay} → \emph{Deploy}.

  This automatically loads a build progress window viewable at the
  bottom of your IntelliJ instance.

  \begin{figure}
  \centering
  \includegraphics{./images/intellij-project-build.png}
  \caption{Verify that your project build successfully.}
  \end{figure}
\item
  Verify that your project builds successfully from the build progress
  window. Then navigate back to your server's window and confirm it
  starts in your configured Liferay DXP instance. You should receive a
  message like this:

\begin{verbatim}
INFO  [fileinstall-C:/liferay-workspace/bundles/osgi/modules][BundleStartStopLogger:35] STARTED com.liferay.docs_1.0.0 [652]
\end{verbatim}
\end{enumerate}

That's it! You've successfully deployed your project to Liferay DXP!

\chapter{Liferay Sample Projects}\label{liferay-sample-projects}

Liferay provides working examples of sample projects that target
different integration points in Liferay DXP. These working examples can
be copy/pasted into your own independent project so you can take
advantage of various Liferay extension points. Each sample is a
standalone project and includes its own build files. Liferay's sample
projects can be found in the
\href{https://github.com/liferay/liferay-blade-samples}{liferay-blade-samples}
repository on GitHub. You can find documentation for Liferay's sample
projects in the
\href{/docs/7-0/reference/-/knowledge_base/r/sample-modules}{Sample
Projects} reference section.

If you'd like to browse the repository locally or copy sample projects
into your own project,
\href{https://help.github.com/articles/fork-a-repo/}{fork} and
\href{https://help.github.com/articles/cloning-a-repository/}{clone} the
\texttt{liferay-blade-samples} repository.

At first glance, you'll notice that the repository is broken up into
three primary folders:

\begin{itemize}
\tightlist
\item
  \texttt{gradle}
\item
  \texttt{liferay-workspace}
\item
  \texttt{maven}
\end{itemize}

The provided sample projects are organized by their development
toolchains to cater to a variety of developers. Each folder offers the
same set of sample Liferay projects. Their only difference is that the
build files are specific to their toolchain. For example, the
\texttt{gradle} folder contains projects using standard OSS Gradle
plugins that can be added to any Gradle composite build. The same
concept also applies to the \texttt{liferay-workspace} and
\texttt{maven} projects.

The \texttt{gradle} folder also uses the Liferay Gradle plugin (e.g.,
\texttt{com.liferay.plugin}) which encompasses additional functionality
for various types of Liferay projects. The Liferay Gradle plugin is
recommended for Gradle users developing for Liferay.

Some samples also come configured with logging to help you fully
understand what the sample is accomplishing behind the scenes. For
example, OSGi module logging is implemented for several samples (e.g.,
\href{https://github.com/liferay/liferay-blade-samples/tree/7.0/gradle/apps/action-command-portlet}{action-command-portlet},
\href{/docs/7-0/reference/-/knowledge_base/r/document-action}{document-action},
\href{/docs/7-0/reference/-/knowledge_base/r/service-builder-application-using-external-database-via-jdbc}{service-builder/jdbc},
etc.), which lets OSGi modules supply their own logging configuration
defaults without external configuration. See the
\href{/docs/7-0/tutorials/-/knowledge_base/t/adjusting-module-logging}{Adjusting
Module Logging} tutorial for more information.

For a list of sample template projects available, visit the
\href{https://github.com/liferay/liferay-blade-samples\#liferay-extension-points-and-template-projects}{Liferay
extension points} sub-section in the Liferay Blade Samples repository.
This list is not comprehensive. A subset of missing extension point
samples can be found in the
\href{https://github.com/liferay/liferay-blade-samples\#liferay-extension-points-without-template-projects}{Liferay
extension points without template projects} sub-section. Visit the
repo's
\href{https://github.com/liferay/liferay-blade-samples\#contribution-guidelines}{Contribution
Guidelines} section for details on contributing to this repository.

\section{Liferay Upgrade Planner}\label{liferay-upgrade-planner}

The Liferay Upgrade Planner provides an automated way to adapt your
installation's data and legacy plugins to your desired Liferay DXP
upgrade version. We recommend leveraging this tool for any of the
following upgrades:

\begin{itemize}
\tightlist
\item
  Liferay Portal 6.2 → Liferay DXP 7.0, 7.1, or 7.2
\item
  Liferay DXP 7.0 → Liferay DXP 7.1 or 7.2
\item
  Liferay DXP 7.1 → Liferay DXP 7.2
\end{itemize}

The Upgrade Planner is provided in
\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-ide}{Liferay Dev
Studio} (versions 3.6+). Here's what the Upgrade Planner does:

\begin{itemize}
\tightlist
\item
  Updates your development environment.
\item
  Identifies code affected by the API changes.
\item
  Describes each API change related to the code.
\item
  Suggests how to adapt the code.
\item
  Provides options, in some cases, to adapt code automatically.
\item
  Transfers database and server data to your new environment.
\end{itemize}

Even if you prefer tools other than Dev Studio (which is based on
Eclipse), you should upgrade your data and legacy plugins using the
Upgrade Planner first--you can use your favorite tools afterward.

To start the Upgrade Planner in Dev Studio, do this:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Navigate to \emph{Project} → \emph{New Liferay Upgrade Plan\ldots{}}.
\item
  In the New Liferay Upgrade Plan wizard, assign your plan a name and
  choose an upgrade plan outline. The data and code upgrade processes
  are separate, so you must step through each process independently.
\item
  Choose your current Liferay version and the new version you're
  upgrading to.
\item
  If you chose to complete a code upgrade, you must also select the
  folder where your legacy plugins reside (e.g., Plugins SDK for Liferay
  6.2 projects).
\item
  Click \emph{Finish}.
\end{enumerate}

\begin{figure}
\centering
\includegraphics{./images/upgrade-plan-wizard.png}
\caption{Configure your upgrade plan before beginning the upgrade
process.}
\end{figure}

Switch to the new Liferay Upgrade Planner perspective (prompted
automatically). You're now offered several windows in the UI:

\begin{itemize}
\tightlist
\item
  \emph{Project Explorer:} displays your legacy plugin environment and
  new development environment. It also displays your
  \href{/docs/7-0/tutorials/-/knowledge_base/t/fixing-upgrade-problems}{upgrade
  problems} that are detected during the \emph{Fix Upgrade Problems}
  step.
\item
  \emph{Liferay Upgrade Plan:} outlines the upgrade plan's steps and
  step summaries.
\item
  \emph{Liferay Upgrade Plan Info:} shows official documentation that
  describes the upgrade step.
\end{itemize}

To progress through your upgrade plan, click the steps outlined in the
Liferay Upgrade Plan window. Each step can have several options:

\begin{itemize}
\tightlist
\item
  \emph{Click to preview:} previews what an automated step will perform.
\item
  \emph{Click to perform:} executes an automated process provided with
  the step. This is only offered for steps where the Upgrade Planner can
  assist.
\item
  \emph{Click when complete:} marks the step as complete. This is only
  offered when the Upgrade Planner cannot provide automated assistance
  and, instead, only offers documentation to assist in completing the
  step manually.
\item
  \emph{Restart:} marks a completed step as unfinished. The step is
  performed again if automation is involved.
\item
  \emph{Skip:} skips the step and jumps to the next step in the outline.
\end{itemize}

\begin{figure}
\centering
\includegraphics{./images/preview-upgrade-planner-changes.png}
\caption{You can preview the Upgrade Planner's automated updates before
you perform them.}
\end{figure}

Great! You now have a good understanding of the Liferay Upgrade
Planner's UI and how to get started.

\noindent\hrulefill

\textbf{Note:} The Upgrade Planner upgrades data and code to Liferay DXP
versions that include 7.0 and the latest DXP version. It links to the
latest Liferay DXP upgrade documentation. 7.0 upgrade documentation is
available here:

\begin{itemize}
\tightlist
\item
  \href{/docs/7-0/deploy/-/knowledge_base/d/upgrading-to-liferay-7}{Data
  Upgrade}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-plugins-to-liferay-7}{Code
  Upgrade}
\end{itemize}

\section{Using the Upgrade Planner with Proxy
Requirements}\label{using-the-upgrade-planner-with-proxy-requirements}

If you have proxy server requirements and want to configure your http(s)
proxy\\
to work with the Liferay Upgrade Planner, follow the instructions below.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In Dev Studio's \texttt{DeveloperStudio.ini}/\texttt{eclipse.ini}
  file, add the following parameters:

\begin{verbatim}
-Djdk.http.auth.proxying.disabledSchemes=
-Djdk.http.auth.tunneling.disabledSchemes=
\end{verbatim}
\item
  Launch Dev Studio.
\item
  Go to \emph{Window} → \emph{Preferences} → \emph{General} →
  \emph{Network Connections}.
\item
  Set the \emph{Active Provider} drop-down selector to \emph{Manual}.
\item
  Under \emph{Proxy entries}, configure both proxy HTTP and HTTPS by
  clicking the field and selecting the \emph{Edit} button.

  \begin{figure}
  \centering
  \includegraphics{./images/upgrade-planner-proxy.png}
  \caption{You can configure your proxy settings in Dev Studio's Network
  Connections menu.}
  \end{figure}
\item
  For each schema (HTTP and HTTPS), enter your proxy server's host,
  port, and authentication settings (if necessary). Do not leave
  whitespace at the end of your proxy host or port settings.
\item
  Once you've configured your proxy entry, click \emph{Apply and Close}.
\end{enumerate}

Awesome! You've successfully configured the Upgrade Planner's proxy
settings!

\chapter{Portlets}\label{portlets}

Web apps in Liferay DXP are called \emph{portlets}. Like many web apps,
portlets process requests and generate responses. In the response, the
portlet returns content (e.g.~HTML, XHTML) for display in browsers. You
might now be thinking, ``Ok, besides the funky name, how are portlets
different from other types of web apps?'' This is a fantastic question!
One key difference is that portlets run in a portion of the web page.
When you're writing a portlet application, you only need to worry about
that application: the rest of the page--the navigation, the top banner,
and any other global component of the interface--is handled by other
components. Another difference is that portlets run only in a portal
server, like the one in Liferay DXP. Portlets can therefore use the
portal's existing support for user management, authentication,
permissions, page management, and more. This frees you to focus on
developing the portlet's core functionality. In many ways, writing your
application as a portlet is easier than writing a standalone
application.

Portlets can be placed on pages by users or portal administrators, who
can place several different portlets on a single page. For example, a
page in a community site could have a calendar portlet for community
events, an announcements portlet for important announcements, and a
bookmarks portlet for links of interest to the community. And because
the portal controls page layout, you can reposition and resize one or
more portlets on a page without altering any portlet code. Doing all
this in other types of web apps would require manual re-coding.
Alternatively, a single portlet can take up an entire page if it's the
only app you need on that page. For example, a message boards or wiki
portlet is best suited on its own page. In short, portlets alleviate
many of the traditional pain points associated with developing web apps.

\begin{figure}
\centering
\includegraphics{./images/portlet-applications.png}
\caption{You can place multiple portlets on a single page.}
\end{figure}

What's more, portals and portlets are standards-based. In 2003, Java
Portlet Specification 1.0
(\href{https://jcp.org/en/jsr/detail?id=168}{JSR-168}) first defined
portal and portlet behavior. In 2008, Java Portlet Specification 2.0
(\href{https://jcp.org/en/jsr/detail?id=286}{JSR-286}) refined and built
on JSR-168, while maintaining backwards compatibility, to define
features like inter-portlet communication (IPC) and more. The recently
released Java Portlet Specification 3.0
(\href{https://jcp.org/en/jsr/detail?id=362}{JSR-362}) continues portal
and portlet evolution. Liferay leads in this space by having a member in
the Expert Group.

So what do these specifications define? We won't bore you with the gory
details; if that's what you want you can read the specifications. We
will tell you, however, how portlets differ from other types of
servlet-based web apps. Portlets handle requests in multiple phases.
This makes portlets much more flexible than servlets. Each portlet phase
executes different operations:

\begin{itemize}
\tightlist
\item
  \textbf{Render:} Generates the portlet's contents based on the
  portlet's current state. When this phase runs on one portlet, it also
  runs on all other portlets on the page. The Render phase runs when any
  portlets on the page complete the Action or Event phases.
\item
  \textbf{Action:} In response to a user action, performs some operation
  that changes the portlet's state. The Action phase can also trigger
  events that are processed by the Event phase. Following the Action
  phase and optional Event phase, the Render phase then regenerates the
  portlet's contents.
\item
  \textbf{Event:} Processes events triggered in the Action phase. Events
  are used for IPC. Once the portlet processes all events, the portal
  calls the Render phase on all portlets on the page.
\item
  \textbf{Resource-serving:} Serves a resource independent from the rest
  of the lifecycle. This lets a portlet serve dynamic content without
  running the Render phase on all portlets on a page. The
  Resource-serving phase handles AJAX requests.
\end{itemize}

Compared to servlets, portlets also have some other key differences.
Since portlets only render a portion of a page, tags like
\texttt{\textless{}html\textgreater{}},
\texttt{\textless{}head\textgreater{}}, and
\texttt{\textless{}body\textgreater{}} aren't allowed. And because you
don't know the portlet's page ahead of time, you can't create portlet
URLs directly. Instead, the portlet API gives you methods to create
portlet URLs programmatically. Also, because portlets don't have direct
access to the \texttt{javax.servlet.ServletRequest}, they can't read
query parameters directly from a URL. Portlets instead access a
\texttt{javax.portlet.PortletRequest} object. The portlet specification
only provides a mechanism for a portlet to read its own URL parameters
or those declared as public render parameters. Liferay DXP does,
however, provide utility methods that can access the
\texttt{ServletRequest} and query parameters. Portlets also have a
\emph{portlet filter} available for each phase in the portlet lifecycle.
Portlet filters are similar to servlet filters in that they allow
request and response modification on the fly.

Portlets also differ from servlets by having distinct modes and window
states. Modes distinguish the portlet's current function:

\begin{itemize}
\tightlist
\item
  \textbf{View mode:} The portlet's standard mode. Use this mode to
  access the portlet's main functionality.
\item
  \textbf{Edit mode:} The portlet's configuration mode. Use this mode to
  configure a custom view or behavior. For example, the Edit mode of a
  weather portlet could let you choose a location to retrieve weather
  data from.
\item
  \textbf{Help mode:} A mode that displays the portlet's help
  information.
\end{itemize}

Most modern applications use View Mode only.

Portlet window states control the amount of space a portlet takes up on
a page. Window states mimic window behavior in a traditional desktop
environment:

\begin{itemize}
\tightlist
\item
  \textbf{Normal:} The portlet can be on a page that contains other
  portlets. This is the default window state.
\item
  \textbf{Maximized:} The portlet takes up an entire page.
\item
  \textbf{Minimized:} Only the portlet's title bar shows.
\end{itemize}

When you develop portlets for Liferay DXP, you can leverage all the
features defined by the portlet specification. Depending on how you
develop and package your portlet, however, it may not be able to run on
other portal containers. You may now be saying, ``Hold on a minute! I
thought Liferay DXP was standards-compliant? What gives?'' Liferay DXP
is standards-compliant, but it contains some sweeteners in the form of
APIs designed to make developers' lives easier. For example, Liferay DXP
contains an
\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-mvc-portlet}{MVC
framework} that makes it simpler to implement MVC in your portlet. This
framework, however, is only available in Liferay's portal. Without
modification, a portlet that uses this framework won't run if deployed
to a non-Liferay portal container. Note, though, that we don't force you
to use Liferay DXP's MVC framework or any of its other unique APIs. For
example, you can develop your portlet with strictly standards-compliant
frameworks and APIs, package it in a WAR file, and then deploy it on any
standards-compliant portal container.

Liferay DXP also contains an OSGi runtime. This means that you don't
have to develop and deploy your portlet as a traditional WAR file; you
can do so as OSGi modules instead. We recommend the latter, so you can
take advantage of the modularity features inherent in OSGi. For a
detailed description of these features, see the tutorial
\href{/docs/7-0/tutorials/-/knowledge_base/t/osgi-and-modularity-for-liferay-6-developers}{OSGi
and Modularity}. Note, however, that Liferay DXP portlets you develop as
OSGi modules won't run on other portlet containers that lack an OSGi
runtime. Even so, the advantages of modularity are so great that we
still recommend you develop your portlets as OSGi modules.

With that said, you can use a variety of technologies to develop
portlets that run on Liferay DXP. Have you ever heard the saying,
``There's more than one way to skin a cat?'' It's gross, but it's
probably true. Liferay DXP doesn't force you to use a single tool or set
of tools to develop portlets. This section shows you how to develop
portlets using the following frameworks and techniques:

\begin{itemize}
\tightlist
\item
  Liferay's \texttt{MVCPortlet}
\item
  Soy Portlet
\item
  Spring MVC
\item
  JavaServer Faces (JSF) Portlets with Liferay Faces
\item
  Making URLs Friendlier
\item
  Preparing Your JavaScript Files for ES2015
\item
  Applying Lexicon Styles to Your App
\item
  Automatic Single Page Applications
\item
  Creating Layouts Inside Custom Portlets
\end{itemize}

\chapter{Liferay MVC Portlet}\label{liferay-mvc-portlet}

Web applications are often developed following the Model View Controller
(MVC) pattern. But Liferay has developed a groundbreaking new pattern
called the \emph{Modal Veal Contractor} (MVC) pattern. Okay, that's not
true: the framework is actually another implementation of Model View
Controller. If you're an experienced developer, this will not be the
first time you've heard about Model View Controller. In this article
you'll need to stay focused, because there will be several attempts to
show you why Liferay's implementation of Model View Controller is
different, when instead you're hearing about another MVC framework. With
that in mind, let's get back to the \emph{Medial Vein Constriction}
pattern we were discussing.

If there are so many implementations of MVC frameworks in Java, why did
Liferay create yet another one? Stay with us and you'll see that Liferay
MVC provides these benefits:

\begin{itemize}
\tightlist
\item
  It's lightweight, as opposed to many other Java MVC frameworks.
\item
  There are no special configuration files that need to be kept in sync
  with your code.
\item
  It's a simple extension of \texttt{GenericPortlet}.
\item
  You avoid writing a bunch of boilerplate code, since Liferay's MVC
  framework simply looks for some pre-defined parameters when the
  \texttt{init()} method is called.
\item
  The controller can be broken down into MVC command classes, each of
  which handles the controller code for a particular portlet phase
  (render, action, and resource serving phases).
\item
  Liferay's portlets use it. That means there are plenty of robust
  implementations to reference when you need to design or troubleshoot
  your Liferay applications.
\end{itemize}

The Liferay MVC portlet framework is light, it hides part of the
complexity of portlets, and it makes the most common operations easier.
The default \texttt{MVCPortlet} project uses separate JSPs for each
portlet mode: For example, \texttt{edit.jsp} is for \emph{edit} mode and
\texttt{help.jsp} is for \emph{help} mode.

Before diving in to the Liferay MVC swimming pool with all the other
cool kids (applications), review how each layer of the \emph{Moody Vase
Conscription} pattern helps you separate the concerns of your
application.

\section{MVC Layers and Modularity}\label{mvc-layers-and-modularity}

In MVC, there are three layers, and you can probably guess what they
are.

\textbf{Model:} The model layer holds the application data and logic for
manipulating it.

\textbf{View:} The view layer contains logic for displaying data.

\textbf{Controller:} The middle man in the MVC pattern, the Controller
contains logic for passing the data back and forth between the view and
the model layers.

The \emph{Middle Verse Completer} pattern fits well with
\href{/docs/7-0/tutorials/-/knowledge_base/t/fundamentals\#modules}{Liferay's
application modularity effort}.

Liferay's applications are divided into multiple discrete modules. With
Service Builder, the model layer is generated into a \texttt{service}
and an \texttt{api} module. That accounts for the model in the MVC
pattern. The view and the controller share a module, the \texttt{web}
module.

Generating the skeleton for a multi-module Service Builder driven MVC
application using
\href{/docs/7-0/tutorials/-/knowledge_base/t/blade-cli}{Liferay Blade
CLI} saves you lots of time and gets you started on the more important
(and interesting, if we're being honest) development work.

\section{Liferay MVC Command Classes}\label{liferay-mvc-command-classes}

In a larger application, your \texttt{-Portlet} class can become
monstrous and unwieldy if it holds all of the controller logic. Liferay
provides MVC command classes to break up your controller functionality.

\begin{itemize}
\tightlist
\item
  \textbf{\href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/bridges/mvc/MVCActionCommand.html}{\texttt{MVCActionCommand}}:}
  Use \texttt{-ActionCommand} classes to hold each of your portlet
  actions, which are invoked by action URLs.
\item
  \textbf{\href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/bridges/mvc/MVCRenderCommand.html}{\texttt{MVCRenderCommand}}:}
  Use \texttt{-RenderCommand} classes to hold a \texttt{render} method
  that dispatches to the appropriate JSP, by responding to render URLs.
\item
  \textbf{\href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/bridges/mvc/MVCResourceCommand.html}{\texttt{MVCResourceCommand}}:}
  Use \texttt{-ResourceCommand} classes to execute resource serving in
  your MVC portlet, by responding to resource URLs.
\end{itemize}

There must be some confusing configuration files to keep everything
wired together and working properly, right? Wrong: it's all easily
managed in the OSGi component in the \texttt{-Portlet} class.

\section{Liferay MVC Portlet
Component}\label{liferay-mvc-portlet-component}

Whether or not you plan to split up the controller into MVC command
classes, you use a portlet component class with a certain set of
properties. Here's a simple portlet component as an example:

\begin{verbatim}
@Component(
    immediate = true,
    property = {
        "com.liferay.portlet.css-class-wrapper=portlet-hello-world",
        "com.liferay.portlet.display-category=category.sample",
        "com.liferay.portlet.icon=/icons/hello_world.png",
        "com.liferay.portlet.preferences-owned-by-group=true",
        "com.liferay.portlet.private-request-attributes=false",
        "com.liferay.portlet.private-session-attributes=false",
        "com.liferay.portlet.remoteable=true",
        "com.liferay.portlet.render-weight=50",
        "com.liferay.portlet.use-default-template=true",
        "javax.portlet.display-name=Hello World",
        "javax.portlet.expiration-cache=0",
        "javax.portlet.init-param.always-display-default-configuration-icons=true",
        "javax.portlet.name=" + HelloWorldPortletKeys.HELLO_WORLD,
        "javax.portlet.resource-bundle=content.Language",
        "javax.portlet.security-role-ref=guest,power-user,user",
        "javax.portlet.supports.mime-type=text/html"
    },
    service = Portlet.class
)
public class HelloWorldPortlet extends MVCPortlet {
}
\end{verbatim}

When using MVC commands, the \texttt{javax.portlet.name} property is
important. This property is one of two that must be included in each MVC
command component; it links a particular portlet URL/command combination
to the correct portlet.

\noindent\hrulefill

\textbf{Important:} Make your portlet name unique, considering how
\href{/docs/7-0/reference/-/knowledge_base/r/portlet-descriptor-to-osgi-service-property-map\#six}{Liferay
DXP uses the name to create the portlet's ID}.

\noindent\hrulefill

There can be some confusion over exactly what kind of
\texttt{Portlet.class} implementation you're publishing with this
component. Liferay's service registry expects this to be
\texttt{javax.portlet.Portlet}, so make sure that's the class you
import, and not, for example,
\texttt{com.liferay.portal.kernel.model.Portlet}.

\noindent\hrulefill

\textbf{Note:} To find a list of all the Liferay-specific attributes you
can specify as properties in your portlet components, check out the
\href{@platform-ref@/7.0-latest/definitions/liferay-portlet-app_7_0_0.dtd.html}{liferay-portlet-app\_7\_0\_0.dtd}.

Consider the \texttt{\textless{}css-class-wrapper\textgreater{}} element
from the above link as an example. To specify that property in your
component, use this syntax in your property list:

\begin{verbatim}
 "com.liferay.portlet.css-class-wrapper=portlet-hello-world",
\end{verbatim}

The properties namespaced with \texttt{javax.portlet....} are elements
of the
\href{http://java.sun.com/xml/ns/portlet/portlet-app_2_0.xsd}{portlet.xml
descriptor}.

\noindent\hrulefill

\section{A Simpler MVC Portlet}\label{a-simpler-mvc-portlet}

With all for this focus on MVC commands, you might be concerned that
you'll be forced into a more complex pattern than is necessary,
especially if you're developing only a small Liferay MVC application.
Not so; just put all of your logic into the \texttt{-Portlet} class if
you don't want to split up your MVC commands.

In simpler applications, if you don't have an MVC command to rely on,
your portlet render URLs specify the path to the JSP in an
\texttt{mvcPath} parameter.

\begin{verbatim}
    <portlet:renderURL var="addEntryURL">
        <portlet:param name="mvcPath" value="/entry/edit_entry.jsp" />
        <portlet:param name="redirect" value="<%= redirect %>" />
    </portlet:renderURL>
\end{verbatim}

As you've seen, Liferay's \emph{Medical Vortex Concentrator} (MVC)
portlet framework gives you a well-structured controller layer that
takes very little time to implement. With all your free time, you could

\begin{itemize}
\tightlist
\item
  Learn a new language
\item
  Take pottery classes
\item
  Lift weights
\item
  Work on your application's business logic
\end{itemize}

It's entirely up to you.

\section{Creating an MVC Portlet}\label{creating-an-mvc-portlet}

You're convinced that Liferay's MVC Framework is right for you, and you
want to learn how to configure it.

You'll need:

\begin{itemize}
\tightlist
\item
  A module that publishes a portlet component with the necessary
  properties.
\item
  Controller code to handle the request and response.
\item
  JSPs to implement your view layer.
\end{itemize}

Along the way you'll want to know how to call services from your
controller and how to pass information from the view layer to the
controller.

Keep in mind that you can take two paths with your Liferay MVC portlet
implementation. If you have a small application that won't be heavy on
controller logic (maybe just a couple of action methods), you can put
all your controller code in the \texttt{-Portlet} class. If you have
more complex needs (lots of actions, complex render logic to implement,
or maybe even some resource serving code), consider breaking the
controller into
\href{/docs/7-0/tutorials/-/knowledge_base/t/mvc-action-command}{MVC
Action Command classes},
\href{/docs/7-0/tutorials/-/knowledge_base/t/mvc-render-command}{MVC
Render Command classes}, and
\href{/docs/7-0/tutorials/-/knowledge_base/t/mvc-resource-command}{MVC
Resource Command classes}.

In this tutorial you'll learn to implement a Liferay MVC portlet with
all the controller code in the \texttt{-Portlet} class.

\subsection{Configuring a WEB Module}\label{configuring-a-web-module}

As a naming convention, the module with your controller code and view
layer is referred to as the WEB module. A very basic WEB module might
look like this:

\begin{verbatim}
docs.liferaymvc.web/
    src/main/java/
        com/liferay/docs/liferaymvc/web/portlet/LiferayMVCPortlet.java
    src/main/resources/
        content/
            Language.properties
        META/-INF/resources/
            init.jsp
            view.jsp
    build.gradle
    bnd.bnd
\end{verbatim}

Of course you're not tied to the use of Gradle or BndTools to build your
project. However, you do need a JAR with the proper OSGi headers
defined, which is easily done if you provide a \texttt{bnd.bnd} file. To
see Liferay MVC portlets built with Maven and Gradle, you can check out
the tutorial on
\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-sample-modules}{Liferay
Sample Projects}.

\subsection{Specifying OSGi Metadata}\label{specifying-osgi-metadata}

At a minimum, you should specify the bundle symbolic name and the bundle
version for the OSGi runtime. Providing a human readable bundle name is
also recommended.

\begin{verbatim}
Bundle-Name: Example Liferay MVC Web
Bundle-SymbolicName: com.liferay.docs.liferaymvc.web
Bundle-Version: 1.0.0
\end{verbatim}

If you don't specify a \texttt{Bundle-SymbolicName}, one will be
generated from the project's directory path, which is suitable for many
cases. If you specify the bundle symbolic name yourself, it's a nice
convention to use the root package name as the bundle symbolic name.

\subsection{Creating a Portlet
Component}\label{creating-a-portlet-component}

Using the OSGi Declarative Services component model makes it easy to
publish service implementations to the OSGi runtime. In this case an
implementation of the \texttt{javax.portlet.Portlet} service must be
published. Declare this using an \texttt{@Component} annotation in the
portlet class:

\begin{verbatim}
@Component(
    immediate = true,
    service = Portlet.class
)
public class LiferayMVCPortlet extends MVCPortlet {
}
\end{verbatim}

Since Liferay's
\href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/bridges/mvc/MVCPortlet.html}{\texttt{MVCPortlet}
class} is itself an extension of \texttt{javax.portlet.Portlet}, you've
provided the right implementation. That's good in itself, but the
component needs to be fleshed out with some properties:

\begin{verbatim}
@Component(
    immediate = true,
    property = {
        "com.liferay.portlet.display-category=category.sample",
        "com.liferay.portlet.instanceable=true",
        "javax.portlet.display-name=Liferay MVC Portlet",
        "javax.portlet.init-param.template-path=/",
        "javax.portlet.init-param.view-template=/view.jsp",
        "javax.portlet.resource-bundle=content.Language",
        "javax.portlet.security-role-ref=power-user,user"
    },
    service = Portlet.class
)
public class LiferayMVCPortlet extends MVCPortlet {
}
\end{verbatim}

Some of those properties might look familiar to you if you've developed
Liferay MVC portlets before 7.0. That's because they correspond with the
XML attributes you used to specify in \texttt{liferay-portlet.xml},
\texttt{liferay-display.xml}, and \texttt{portlet.xml}. To find a list
of all the Liferay-specific attributes you can specify as properties in
your portlet components, check out the
\href{@platform-ref@/7.0-latest/definitions/liferay-portlet-app_7_0_0.dtd.html}{liferay-portlet-app\_7\_0\_0.dtd}.
This is still maintained as a DTD to keep compatibility with the JSR-168
and JSR-286 portlet specs.

Consider the \texttt{\textless{}instanceable\textgreater{}} element from
the above link as an example. To specify that property in your
component, use this syntax in your property list:

\begin{verbatim}
"com.liferay.portlet.instanceable=true",
\end{verbatim}

The properties namespaced with \texttt{javax.portlet....} are elements
of the
\href{http://java.sun.com/xml/ns/portlet/portlet-app_2_0.xsd}{portlet.xml
descriptor}.

Also note that it is possible to create nested categories using the
\texttt{com.liferay.portlet.display-category} property. The format for
creating these categories is to write out the category path starting
with the root and separating each category in descending order by the
use of \texttt{//}. Here's an example:

\begin{verbatim}
com.liferay.portlet.display-category=root//category.category1//category.category2     
\end{verbatim}

Liferay's DTD files can be found
\href{@platform-ref@/7.0-latest/definitions/}{here}.

You can publish this portlet component, but it doesn't do anything yet.
You'll implement the Controller code next.

\subsection{Writing Controller Code}\label{writing-controller-code}

In MVC, your controller receives requests from the front end, and it
receives data from the back end. It's responsible for sending that data
to the right front end view so it can be displayed to the user, and it's
responsible for taking data the user entered in the front end and
passing it to the right back end service. For this reason, it needs a
way to process requests from the front end and respond to them
appropriately, and it needs a way to determine the appropriate front end
view to pass data back to the user.

For data coming from the user to the back end, Liferay's MVC portlet
framework offers you two ways to do this. One of these is designed for
smaller applications, and the other is designed for larger applications.
First, you'll learn about processing requests in smaller applications.
After that, you'll learn about how data is rendered from the back end to
the user. For processing requests in larger applications, see the
tutorials
\href{/docs/7-0/tutorials/-/knowledge_base/t/mvc-action-command}{MVC
Action Command},
\href{/docs/7-0/tutorials/-/knowledge_base/t/mvc-render-command}{MVC
Render Command}, and
\href{/docs/7-0/tutorials/-/knowledge_base/t/mvc-resource-command}{MVC
Resource Command}. But read these after you finish this one, so you can
understand how the whole framework works.

\subsubsection{Action Methods}\label{action-methods}

If you have a small application, you can implement all your controller
code in your portlet class (the same one you annotated with
\texttt{@Component}), which acts as your controller by itself. For
processing requests, you use action methods. Here's what an action
method might look like:

\begin{verbatim}
public void addGuestbook(ActionRequest request, ActionResponse response)
        throws PortalException, SystemException {

    ServiceContext serviceContext = ServiceContextFactory.getInstance(
        Guestbook.class.getName(), request);

    String name = ParamUtil.getString(request, "name");

    try {
        _guestbookService.addGuestbook(serviceContext.getUserId(),
                name, serviceContext);

        SessionMessages.add(request, "guestbookAdded");

    } catch (Exception e) {
        SessionErrors.add(request, e.getClass().getName());

        response.setRenderParameter("mvcPath",
            "/html/guestbook/edit_guestbook.jsp");
    }

}
\end{verbatim}

In this action method, the \texttt{javax.portlet.ActionRequest} object
is used to retrieve two pieces of information that are needed to call
the \texttt{addGuestbook} service, which is the point of the method. If
successful, the
\href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/servlet/SessionMessages.html}{\texttt{SessionMessages}
object} is used to store a success message. If an exception is thrown,
it's caught, and the appropriate
\href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/servlet/SessionErrors.html}{\texttt{SessionErrors}
object} is used to store the exception message. Note the call to the
\texttt{setRenderParameter} method on the \texttt{ActionResponse}. This
is used to render the \texttt{edit\_guestbook.jsp} if a guestbook could
not be added, by setting the \texttt{mvcPath} parameter. This parameter
is a convention in Liferay's \texttt{MVCPortlet} framework that denotes
the next view that should be displayed to the user.

\subsubsection{Render Logic}\label{render-logic}

So what might a render method look like? First, note that implementing
render logic might not be necessary at all. Note the \texttt{init-param}
properties you set in your Component:

\begin{verbatim}
"javax.portlet.init-param.template-path=/",
"javax.portlet.init-param.view-template=/view.jsp",
\end{verbatim}

With these, you're directing the default rendering to your
\texttt{view.jsp}. The \texttt{template-path} property tells the MVC
framework where your JSP files live. In the above example, \texttt{/}
means that the JSP files are located in your project's root
\texttt{resources} folder. That's why it's important to follow Liferay's
standard folder structure, outlined above. Here's the path of a
hypothetical Web module's resource folder:

\begin{verbatim}
docs.liferaymvc.web/src/main/resources/META-INF/resources
\end{verbatim}

In this case, the \texttt{view.jsp} file is found at

\begin{verbatim}
docs.liferaymvc.web/src/main/resources/META-INF/resources/view.jsp
\end{verbatim}

and that's the default view of the application. When the \texttt{init}
method is called, the initialization parameters you specify are read and
used to direct rendering to the default JSP. Throughout the controller,
you can render a different view (JSP file) by setting the render
parameter \texttt{mvcPath}, like this:

\begin{verbatim}
actionResponse.setRenderParameter("mvcPath", "/error.jsp");
\end{verbatim}

In some cases, the uses of initialization parameters and render
parameters obviates the need for additional render logic. However, it's
often necessary to provide additional render logic. To do this, override
the \texttt{render} method. Here's an example:

\begin{verbatim}
@Override
public void render(RenderRequest renderRequest,
        RenderResponse renderResponse) throws PortletException, IOException {

    try {
        ServiceContext serviceContext = ServiceContextFactory.getInstance(
                Guestbook.class.getName(), renderRequest);

        long groupId = serviceContext.getScopeGroupId();

        long guestbookId = ParamUtil.getLong(renderRequest, "guestbookId");

        List<Guestbook> guestbooks = _guestbookService
                .getGuestbooks(groupId);

        if (guestbooks.size() == 0) {
            Guestbook guestbook = _guestbookService.addGuestbook(
                    serviceContext.getUserId(), "Main", serviceContext);

            guestbookId = guestbook.getGuestbookId();

        }

        if (!(guestbookId > 0)) {
            guestbookId = guestbooks.get(0).getGuestbookId();
        }

        renderRequest.setAttribute("guestbookId", guestbookId);

    } catch (Exception e) {

        throw new PortletException(e);
    }

    super.render(renderRequest, renderResponse);

}
\end{verbatim}

With render logic, you're providing the view layer with information to
display the data properly to the user. In this case, there's some
information needed at the outset, and then there's some logic in the
\texttt{if} statements that determine if there are any Guestbooks that
can be displayed. If not, a Guestbook should be created by default. If
there are Guestbooks in the database, the ID that's first in the list
retrieved via the \texttt{getGuestbooks} method should be displayed.
This is accomplished by passing the appropriate ID to the
\texttt{RenderRequest} using the \texttt{setAttirbute} method. Since
this logic should be executed before the default \texttt{render} method,
the method concludes by calling \texttt{super.render}.

\noindent\hrulefill

\textbf{Note:} Are you wondering how to call Service Builder services in
7.0? Refer to
\href{/docs/7-0/tutorials/-/knowledge_base/t/finding-and-invoking-liferay-services}{the
tutorial on Finding and Invoking Liferay Services} for a more detailed
explanation. In short, obtain a reference to the service by annotating a
setter method with the \texttt{@Reference} Declarative Services
annotation and set the service object as a private variable.

\begin{verbatim}
 private GuestbookService _guestbookService;

 @Reference(unbind = "-")
 protected void setGuestbookService(GuestbookService guestbookService) {
     _guestbookService = guestbookService;
 }
\end{verbatim}

Once done, you can call the service's methods.

\begin{verbatim}
 _guestbookService.addGuestbook(serviceContext.getUserId(), "Main",
         serviceContext);
\end{verbatim}

\noindent\hrulefill

\subsubsection{Setting and Retrieving Request Parameters and
Attributes}\label{setting-and-retrieving-request-parameters-and-attributes}

In the portlet class's render method action methods, and even in your
JSPs, you can use a handy utility class called
\href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/util/ParamUtil.html}{\texttt{ParamUtil}}
to retrieve parameters from an \texttt{ActionRequest} or a
\texttt{RenderRequest}.

\begin{verbatim}
long guestbookId = ParamUtil.getLong(renderRequest, "guestbookId");
\end{verbatim}

In the above example, the parameter was set into an action request in a
JSP:

\begin{verbatim}
<portlet:param name="guestbookId" 
        value="<%= String.valueOf(entry.getGuestbookId()) %>" />
\end{verbatim}

You can also set attributes into the request using the method

\begin{verbatim}
request.setAttribute();
\end{verbatim}

in your portlet class. To read the attribute in a JSP, use the method

\begin{verbatim}
request.getAttribute();
\end{verbatim}

To set parameters into the response in your controller code, you can use
the \texttt{setRenderParameter} method.

\begin{verbatim}
actionResponse.setRenderParameter("mvcPath", "/error.jsp");
\end{verbatim}

Passing information back and forth from your view and controller is
important, but there's more to the view layer than that.

\subsection{Configuring the View
Layer}\label{configuring-the-view-layer}

You now know how to extend Liferay's \texttt{MVCPortlet} to write
controller code and register a Component in the OSGi runtime. You also
need a view layer, of course, and for that, you'll use JSPs. Lexicon can
be used to guide your app's styling so it matches Liferay's. To learn
about Lexicon and about some of Liferay's taglibs, refer to the tutorial
\href{/docs/7-0/tutorials/-/knowledge_base/t/applying-lexicon-styles-to-your-app}{Applying
Lexicon Styles to Your App}. This section will briefly cover how to get
your view layer working, from organizing your imports in one JSP file,
to configuring URLs that direct processing to your code in the portlet
class.

It's a good practice to put all your Java imports, tag library
declarations, and variable initializations into an \texttt{init.jsp}
file. If you use Liferay @ide@ to create your Web module, these taglib
declarations and initializations are automatically added to your
\texttt{init.jsp}:

\begin{verbatim}
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %>

<%@ taglib uri="http://java.sun.com/portlet_2_0" prefix="portlet" %>

<%@ taglib uri="http://liferay.com/tld/aui" prefix="aui" %>
<%@ taglib uri="http://liferay.com/tld/portlet" prefix="liferay-portlet" %>
<%@ taglib uri="http://liferay.com/tld/theme" prefix="liferay-theme" %>
<%@ taglib uri="http://liferay.com/tld/ui" prefix="liferay-ui" %>

<liferay-theme:defineObjects />

<portlet:defineObjects />
\end{verbatim}

Make sure you include the \texttt{init.jsp} in your other JSP files:

\begin{verbatim}
<%@include file="/html/init.jsp"%>
\end{verbatim}

You can, if necessary, write Java code in your JSPs using scriptlets.
Perhaps you set an attribute into the request in your controller:

\begin{verbatim}
renderRequest.setAttribute("guestbookId", guestbookId);
\end{verbatim}

You can reference it in your JSP by calling the
\texttt{renderRequest.getAttribute} method:

\begin{verbatim}
<%
    long guestbookId = Long.valueOf((Long) renderRequest
            .getAttribute("guestbookId"));
%>
\end{verbatim}

To construct a URL that calls the \texttt{render} method of your
controller, you can use the \texttt{portlet:renderURL} tag:

\begin{verbatim}
<portlet:renderURL var="searchURL">
        <portlet:param name="mvcPath" value="/admin/view.jsp" />
</portlet:renderURL>
\end{verbatim}

You create a variable to hold the generated URL with the \texttt{var}
attribute. Then you can set any parameters you need using the
\texttt{portlet:param} tag. The \texttt{mvcPath} parameter is used to
direct to another JSP. The example above points to a JSP in

\begin{verbatim}
docs.liferaymvc.web/src/main/resources/META-INF/resources/admin/view.jsp
\end{verbatim}

You can then use the \texttt{var} value to invoke the URL in your JSP
code, perhaps in a button or navigation bar item.

Action URLs can be similarly created with the \texttt{portlet} taglib:

\begin{verbatim}
<portlet:actionURL name="doSomething" var="doSomethingURL">
    <portlet:param name="redirect" value="<%= redirect %>" />
</portlet:actionURL>
\end{verbatim}

The \texttt{name} of the action URL should match the action method name
in your portlet class; that's all Liferay's MVC framework needs in order
to know that the action method of the same name should run when this
action URL is invoked. Use the \texttt{var} attribute like you did the
\texttt{var} attribute in the render URL; to call the action URL in your
JSP code, whether it's in an icon, a button, or somewhere else.

As you can see, with Liferay MVC it's pretty easy to make your
controller talk to your view layer.

\subsection{Beyond the Basics}\label{beyond-the-basics}

This tutorial should get you up and running with a Liferay MVC Web
module, but there's more to know about creating an app in Liferay. Here
are a few useful jumping off points:

\begin{itemize}
\tightlist
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/making-urls-friendlier}{Making
  URLs Friendlier}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/applying-lexicon-styles-to-your-app}{Applying
  Lexicon Styles to your App}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/localizing-your-application}{Localizing
  your Application}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/liferays-workflow-framework}{Liferay's
  Workflow Framework}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/model-listeners}{Model
  Listeners}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/application-security}{Application
  Security}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/asset-framework}{Asset
  Framework}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/service-builder}{Service
  Builder}
\end{itemize}

\section{MVC Action Command}\label{mvc-action-command}

Liferay's MVC framework lets you split your portlet's action methods
into separate classes. This can be very helpful in portlets that have
many actions. Each action URL in your portlet's JSPs then calls the
appropriate action class when necessary.

First, use the \texttt{\textless{}portlet:actionURL\textgreater{}} tag
to create the action URL in your JSP. For example, the edit blog entry
action in Liferay's Blogs app is defined in the
\href{https://github.com/liferay/liferay-portal/blob/7.0.6-ga7/modules/apps/collaboration/blogs/blogs-web/src/main/resources/META-INF/resources/blogs/edit_entry.jsp}{\texttt{edit\_entry.jsp}
file} as follows:

\begin{verbatim}
<portlet:actionURL name="/blogs/edit_entry" var="editEntryURL" />
\end{verbatim}

When the action URL is triggered, the matching action class processes
the action. Implement the action by creating a class that implements the
\href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/bridges/mvc/MVCActionCommand.html}{\texttt{MVCActionCommand}
interface}. To avoid writing oodles of boilerplate code, your
\texttt{*MVCActionCommand} class should extend the
\href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/bridges/mvc/BaseMVCActionCommand.html}{\texttt{BaseMVCActionCommand}
class} instead of implementing \texttt{MVCActionCommand} directly. The
\texttt{BaseMVCActionCommand} class already implements
\texttt{MVCActionCommand} and provides many useful method
implementations. Naming your \texttt{*MVCActionCommand} class after the
action it performs is a good convention. For example, if your action
edits some kind of entry, you could name its class
\texttt{EditEntryMVCActionCommand}.

Your \texttt{*MVCActionCommand} class must also have a
\texttt{@Component} annotation like the following. Set the property
\texttt{javax.portlet.name} to your portlet's internal ID, and the
property \texttt{mvc.command.name} to the value of the \texttt{name}
property in your JSP's matching \texttt{actionURL}. To register the
component in the OSGi container as using the \texttt{MVCActionCommand}
class, you must set the \texttt{service} property to
\texttt{MVCActionCommand.class}:

\begin{verbatim}
@Component(
    immediate = true,
    property = {
        "javax.portlet.name=your_portlet_name_YourPortlet",
        "mvc.command.name=/your/jsp/action/url"
    },
    service = MVCActionCommand.class
)
public class YourMVCActionCommand extends BaseMVCActionCommand {
    // implement your action
}
\end{verbatim}

For example, this is the \texttt{@Component} annotation for the Blogs
app's
\href{https://github.com/liferay/liferay-portal/blob/7.0.2-ga3/modules/apps/collaboration/blogs/blogs-web/src/main/java/com/liferay/blogs/web/internal/portlet/action/EditEntryMVCActionCommand.java}{\texttt{EditEntryMVCActionCommand}
class}:

\begin{verbatim}
@Component(
    immediate = true,
    property = {
        "javax.portlet.name=" + BlogsPortletKeys.BLOGS,
        "javax.portlet.name=" + BlogsPortletKeys.BLOGS_ADMIN,
        "javax.portlet.name=" + BlogsPortletKeys.BLOGS_AGGREGATOR,
        "mvc.command.name=/blogs/edit_entry"
    },
    service = MVCActionCommand.class
)
public class EditEntryMVCActionCommand extends BaseMVCActionCommand {
    // the app's edit blog entry action implementation
}
\end{verbatim}

Note that you can use multiple \texttt{javax.portlet.name} values to
indicate the component works with multiple portlets.

In your \texttt{*MVCActionCommand} class, process the action by
overriding the \texttt{BaseMVCActionCommand} class's
\href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/bridges/mvc/BaseMVCActionCommand.html\#doProcessAction-javax.portlet.ActionRequest-javax.portlet.ActionResponse-}{\texttt{doProcessAction}
method}. This method takes \texttt{javax.portlet.ActionRequest} and
\texttt{javax.portlet.ActionResponse} parameters that you can use to
process your action. Your \texttt{*MVCActionCommand} class should also
contain any other code required to implement your action. For a
real-world example of a \texttt{*MVCActionCommand} class, see the Blogs
app's \texttt{EditEntryMVCActionCommand} class.

\subsection{Related Topics}\label{related-topics-23}

\href{/docs/7-0/tutorials/-/knowledge_base/t/mvc-render-command}{MVC
Render Command}

\href{/docs/7-0/tutorials/-/knowledge_base/t/mvc-resource-command}{MVC
Resource Command}

\href{/docs/7-0/tutorials/-/knowledge_base/t/overriding-mvc-commands}{MVC
Command Overrides}

\section{MVC Render Command}\label{mvc-render-command}

If you're here, that means you know that \texttt{MVCRenderCommand}s are
used to respond to portlet render URLs, and you want to know how to
create and use MVC render commands. If you just want to learn about
Liferay's MVC Portlet framework in general, that information is in a
\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-mvc-portlet}{separate
article}.

To use MVC render commands, you need these things:

\begin{itemize}
\tightlist
\item
  An implementation of the
  \href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/bridges/mvc/MVCRenderCommand.html}{\texttt{MVCRenderCommand}
  interface}.
\item
  A portlet render URL in your view layer.
\item
  a Component that publishes the \texttt{MVCRenderCommand} service, with
  two properties.
\end{itemize}

\subsection{Implementing
MVCRenderCommand}\label{implementing-mvcrendercommand}

What is it you want to do when a portlet render URL is invoked? Using
the \texttt{mvcRenderCommandName} parameter, direct the request to an
\texttt{MVCRenderCommand} implementation. Now override the
\texttt{render} method.

Some \texttt{MVCRenderCommand}s will simply render a particular JSP.
Here's what
\href{https://github.com/liferay/liferay-portal/blob/7.0.2-ga3/modules/apps/collaboration/blogs/blogs-web/src/main/java/com/liferay/blogs/web/internal/portlet/action/BlogsViewMVCRenderCommand.java}{\texttt{BlogsViewMVCRenderCommand}}
looks like:

\begin{verbatim}
@Override
public String render(
    RenderRequest renderRequest, RenderResponse renderResponse) {

    return "/blogs/view.jsp";
}
\end{verbatim}

Sometimes you'll want to add logic to render a certain JSP based on one
or more conditions:

\begin{verbatim}
@Override
public String render(
    RenderRequest renderRequest, RenderResponse renderResponse)
    throws PortletException {

    try {
        ActionUtil.getEntry(renderRequest);
    }
    catch (Exception e) {
        if (e instanceof NoSuchEntryException ||
            e instanceof PrincipalException) {

            SessionErrors.add(renderRequest, e.getClass());

            return "/hello/error.jsp";
        }
        else {
            throw new PortletException(e);
        }
    }

    return "/hello/edit_entry.jsp";
}
\end{verbatim}

If there's an error caught following the call to
\texttt{ActionUtil.getEntry} in the code above, the \texttt{error.jsp}
is rendered. If the call is returned without an exception being caught,
\texttt{edit\_entry.jsp} is rendered.

How does a request get directed to your MVC render command? Using a
portlet render URL.

\subsection{Creating a Portlet Render
URL}\label{creating-a-portlet-render-url}

You can generate a render URL for your portlet using the
\texttt{\textless{}portlet:renderURL\textgreater{}} taglib. To invoke
your MVC render command from the render URL, you need to specify the
parameter \texttt{mvcRenderCommandName} with the same value as your
Component property \texttt{mvc.command.name}.

For example, you can create a URL that directs the user to a page with a
form for editing an entry like this (in a JSP):

\begin{verbatim}
<portlet:renderURL var="editEntryURL">
    <portlet:param name="mvcRenderCommandName" value="/hello/edit_entry" />
    <portlet:param name="entryId" value="<%= String.valueOf(entry.getEntryId()) %>" />
</portlet:renderURL>
\end{verbatim}

Now the request will contain a parameter named
\texttt{mvcRenderCommandName}. To find the proper MVC render command,
the OSGi runtime needs to have a \texttt{mvc.command.name} property with
a matching value.

\subsection{Registering the MVC Render
Command}\label{registering-the-mvc-render-command}

In order to respond to a particular render URL, you need an
\texttt{MVCRenderCommand} Component that with two properties:

\begin{verbatim}
 "javax.portlet.name=" + HelloWorldPortletKeys.HELLO_WORLD,
 "mvc.command.name=/hello/edit_entry"
\end{verbatim}

Using the above properties as an example, any portlet render URL for the
portlet that includes a parameter called \texttt{mvcRenderCommand} with
the value \texttt{/hello/edit\_entry} will be handled by this
\texttt{MVCRenderCommand}.

The Component must also publish a \texttt{MVCRenderCommand.class}
service to the OSGi runtime. Here's a basic Component that publishes an
MVC render command.

\begin{verbatim}
@Component(
    immediate = true,
    property = {
       "javax.portlet.name=" + HelloWorldPortletKeys.HELLO_WORLD,
       "mvc.command.name=/hello/edit_entry"
    },
    service = MVCRenderCommand.class
)
public class EditEntryMVCRenderCommand implements MVCRenderCommand {
\end{verbatim}

One command can be used by one portlet, as the example above shows. If
you want, one command can be used for multiple portlets by adding more
\texttt{javax.portlet.name} entries in the property list. Likewise,
multiple commands can invoke the MVC command class by adding more
\texttt{mvc.command.name} entries. If you're really feeling wild, you
can specify multiple portlets and multiple command URLs in the same
command component, like this:

\begin{verbatim}
@Component(
    immediate = true,
    property = {
       "javax.portlet.name=" + HelloWorldPortletKeys.HELLO_MY_WORLD,
       "javax.portlet.name=" + HelloWorldPortletKeys.HELLO_WORLD,
       "mvc.command.name=/hello/edit_super_entry",
       "mvc.command.name=/hello/edit_entry"
    },
    service = MVCRenderCommand.class
)
\end{verbatim}

As you can see, MVC render commands are flexible and very easy to
implement.

\subsection{Related Topics}\label{related-topics-24}

\href{/docs/7-0/tutorials/-/knowledge_base/t/mvc-resource-command}{MVC
Resource Command}

\href{/docs/7-0/tutorials/-/knowledge_base/t/mvc-action-command}{MVC
Action Command}

\href{/docs/7-0/tutorials/-/knowledge_base/t/overriding-mvc-commands}{MVC
Command Overrides}

\section{MVC Resource Command}\label{mvc-resource-command}

When using Liferay's MVC framework, you can create resource URLs in your
JSPs to retrieve images, XML, or any other kind of resource from a
Liferay instance. The resource URL then invokes the corresponding MVC
resource command class (\texttt{*MVCResourceCommand}) that processes the
resource request and response.

First, use the \texttt{\textless{}portlet:resourceURL\textgreater{}} tag
to create the resource URL in a JSP. For example, the Login Portlet's
\texttt{/login-web/src/main/resources/META-INF/resources/navigation/create\_account.jsp}
file defines the following resource URL for retrieving a CAPTCHA image
during account creation:

\begin{verbatim}
<portlet:resourceURL id="/login/captcha" var="captchaURL" />
\end{verbatim}

When the resource URL is triggered, the matching
\texttt{*MVCResourceCommand} class processes the resource request and
response. You can create this class by implementing the
\href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/bridges/mvc/MVCResourceCommand.html}{\texttt{MVCResourceCommand}
interface}, or extending the
\href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/bridges/mvc/BaseMVCResourceCommand.html}{\texttt{BaseMVCResourceCommand}
class}. The latter may save you time, since it already implements
\texttt{MVCResourceCommand}.

Also, it's a good idea to name your \texttt{*MVCResourceCommand} class
after the resource it handles, and suffix it with
\texttt{MVCResourceCommand}. For example, the resource command class
matching the preceding CAPTCHA resource URL in the Login Portlet is
\href{https://github.com/liferay/liferay-portal/blob/7.0.2-ga3/modules/apps/foundation/login/login-web/src/main/java/com/liferay/login/web/internal/portlet/action/CaptchaMVCResourceCommand.java}{\texttt{CaptchaMVCResourceCommand}}.
In an application with several MVC command classes, this will help
differentiate them.

Your \texttt{*MVCResourceCommand} class must also have a
\texttt{@Component} annotation like the following. Set the property
\texttt{javax.portlet.name} to your portlet's internal ID, and the
property \texttt{mvc.command.name} to the value of the \texttt{id}
property in your JSP's matching \texttt{resourceURL}. To register the
component in the OSGi container as using the \texttt{MVCResourceCommand}
class, you must set the \texttt{service} property to
\texttt{MVCResourceCommand.class}:

\begin{verbatim}
@Component(
    immediate = true,
    property = {
        "javax.portlet.name=your_portlet_name_YourPortlet",
        "mvc.command.name=/your/jsp/resource/url"
    },
    service = MVCResourceCommand.class
)
public class YourMVCResourceCommand implements MVCResourceCommand {
    // your resource handling code
}
\end{verbatim}

As a real-world example, consider the Login Portlet's
\texttt{CaptchaMVCResourceCommand} class (find this class in the Liferay
source code at
\texttt{modules/apps/foundation/login/login-web/src/main/java/com/liferay/login/web/internal/portlet/action/CaptchaMVCResourceCommand.java}):

\begin{verbatim}
@Component(
    property = {
        "javax.portlet.name=" + LoginPortletKeys.FAST_LOGIN,
        "javax.portlet.name=" + LoginPortletKeys.LOGIN,
        "mvc.command.name=/login/captcha"
    },
    service = MVCResourceCommand.class
)
public class CaptchaMVCResourceCommand implements MVCResourceCommand {

    @Override
    public boolean serveResource(
        ResourceRequest resourceRequest, ResourceResponse resourceResponse) {
        
        try {
            CaptchaUtil.serveImage(resourceRequest, resourceResponse);

            return false;
        }
        catch (Exception e) {
            _log.error(e, e);
            
            return true;
        }
    }

    private static final Log _log = LogFactoryUtil.getLog(
        CaptchaMVCResourceCommand.class);
}
\end{verbatim}

In the \texttt{@Component} annotation, note that
\texttt{javax.portlet.name} has two different settings. This lets
multiple portlets use the same component. In this example, the portlet
IDs are defined as constants in the
\href{@app-ref@/foundation/7.0.8/javadocs/com/liferay/login/web/constants/LoginPortletKeys.html}{\texttt{LoginPortletKeys}
class}. Also note that the \texttt{mvc.command.name} property setting
\texttt{/login/captcha} matches the \texttt{resourceURL}'s \texttt{id}
setting shown earlier in this tutorial, and that the \texttt{service}
property is set to \texttt{MVCResourceCommand.class}.

The \texttt{CaptchaMVCResourceCommand} class implements the
\texttt{MVCResourceCommand} interface with only a single method:
\texttt{serveResource}. This method processes the resource request and
response via the \texttt{javax.portlet.ResourceRequest} and
\texttt{javax.portlet.ResourceResponse} parameters, respectively. Note
that the \texttt{try} block uses the helper class
\href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/captcha/CaptchaUtil.html}{\texttt{CaptchaUtil}}
to serve the CAPTCHA image. Though you don't have to create such a
helper class, doing so often simplifies your code.

Great! Now you know how to use \texttt{MVCResourceCommand} to process
resources in your Liferay MVC portlets.

\subsection{Related Topics}\label{related-topics-25}

\href{/docs/7-0/tutorials/-/knowledge_base/t/mvc-render-command}{MVC
Render Command}

\href{/docs/7-0/tutorials/-/knowledge_base/t/mvc-action-command}{MVC
Action Command}

\href{/docs/7-0/tutorials/-/knowledge_base/t/overriding-mvc-commands}{MVC
Command Overrides}

\chapter{Liferay Soy Portlet}\label{liferay-soy-portlet}

A Soy portlet is an extension of Liferay's MVC portlet framework. This
gives you access to all the MVC Portlet functionality you are familiar
with, plus the added bonus of using Soy templates for writing your
front-end. Soy templates use an easy templating language that also lets
you use MetalJS components. With all these benefits and more, Soy
portlets can be a good front-end tool to have in your utility belt.

You can learn about Liferay MVC portlets in the
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-an-mvc-portlet}{Creating
an MVC Portlet} tutorial.

This section covers how to implement a Soy portlet.

\section{Creating a Soy Portlet}\label{creating-a-soy-portlet}

To create a Soy portlet, you'll need these key components:

\begin{itemize}
\tightlist
\item
  A module that publishes a portlet component with the necessary
  properties
\item
  Controller code to handle the request and response
\item
  Soy templates to implement your view layer
\end{itemize}

\subsection{Configuring the Web
Module}\label{configuring-the-web-module}

First, familiarize yourself with a Soy portlet's anatomy. You may
recognize it, since a Soy portlet extends an MVC portlet:

\begin{itemize}
\tightlist
\item
  \texttt{my-soy-portlet}

  \begin{itemize}
  \tightlist
  \item
    \texttt{bnd.bnd}
  \item
    \texttt{build.gradle}
  \item
    \texttt{package.json}
  \item
    \texttt{src/main/}

    \begin{itemize}
    \tightlist
    \item
      \texttt{java/path/to/portlet/}

      \begin{itemize}
      \tightlist
      \item
        \texttt{MySoyPortlet.java}
      \item
        \texttt{action/}

        \begin{itemize}
        \tightlist
        \item
          \texttt{*MVCRenderCommand.java}
        \end{itemize}
      \end{itemize}
    \item
      \texttt{resources/META-INF/resources/}

      \begin{itemize}
      \tightlist
      \item
        \texttt{content/}

        \begin{itemize}
        \tightlist
        \item
          \texttt{Language.properties}
        \end{itemize}
      \item
        \texttt{View.es.js} (MetalJS component)
      \item
        \texttt{View.soy} (Soy template)
      \end{itemize}
    \end{itemize}
  \end{itemize}
\end{itemize}

Now that you know the basic structure of a Soy portlet module, you can
configure it. You can use the
\href{/docs/7-0/reference/-/knowledge_base/r/soy-portlet-template}{soy
portlet Blade template} to build your initial project if you wish.
Otherwise, you can follow the instructions in this section to manually
configure the module.

\subsubsection{Specifying OSGi
Metadata}\label{specifying-osgi-metadata-1}

Add the OSGi metadata to your module's \texttt{bnd.bnd} file. A sample
BND configuration is shown below:

\begin{verbatim}
Bundle-Name: Liferay Hello Soy Web
Bundle-SymbolicName: com.liferay.hello.soy.web
Bundle-Version: 1.0.3
Require-Capability:\
    soy;\
        filter:="(type=metal)"
Include-Resource: package.json
\end{verbatim}

In addition to the standard metadata, notice the
\texttt{Require-Capability} property. This specifies that this bundle
requires modules that provide the capability \texttt{soy} with a
\texttt{type} of \texttt{metal} to work. Also note the
\texttt{Include-Resource} property. \textbf{You must include your}
\texttt{package.json} \textbf{file to load the Soy Portlet's JavaScript
files.}

\subsubsection{Specifying JavaScript
Dependencies}\label{specifying-javascript-dependencies}

Specify the JavaScript module dependencies in your
\texttt{package.json}. At a minimum, you should have the following
dependencies and configuration parameters:

\begin{verbatim}
{
    "dependencies": {
        "metal-component": "^2.4.5",
        "metal-soy": "^2.4.5"
    },
    "devDependencies": {
        "liferay-module-config-generator": "^1.2.1",
        "metal-cli": "^4.0.1"
    },
    "name": "my-portlet-name",
    "version": "1.0.0"
}
\end{verbatim}

This provides everything you need to create a Metal component based on
Soy. Note that the \texttt{version} in your \texttt{package.json} should
match the \texttt{Bundle-Version} in your \texttt{bnd.bnd} file.

Next you can specify your module's build dependencies.

\subsubsection{Specifying Build
Dependencies}\label{specifying-build-dependencies}

Add the dependencies shown below to your \texttt{build.gradle} file:

\begin{verbatim}
dependencies {
    provided group: "com.liferay", name: "com.liferay.portal.portlet.bridge.soy", version: "3.1.0"
    provided group: "com.liferay.portal", name: "com.liferay.portal.kernel", version: "2.0.0"
    provided group: "com.liferay.portal", name: "com.liferay.util.java", version: "2.0.0"
    provided group: "javax.portlet", name: "portlet-api", version: "2.0"
    provided group: "javax.servlet", name: "javax.servlet-api", version: "3.0.1"
    provided group: "org.osgi", name: "org.osgi.service.component.annotations", version: "1.3.0"
}
\end{verbatim}

\noindent\hrulefill

\textbf{Note:} These are current at the time of this writing, but may
change. Please check the \href{https://repository.liferay.com}{Nexus
Repository} for the proper versions for your Liferay DXP instance.

\noindent\hrulefill

Now that your module build is configured, you can learn how to create
the Soy portlet component.

\subsection{Creating a Soy Portlet
Component}\label{creating-a-soy-portlet-component}

Create a Soy Portlet component that extends the \texttt{SoyPortlet}
class. This\\
requires an implementation of the \texttt{javax.portlet.portlet} service
to run. Declare this using an \texttt{@Component} annotation in the
portlet class:

\begin{verbatim}
@Component(
    immediate = true,
    service = Portlet.class
)
public class MySoyPortlet extends SoyPortlet {
    @Override
    public void render(RenderRequest renderRequest, RenderResponse renderResponse) {
        //do things here
    }
}
\end{verbatim}

Liferay DXP's
\href{https://github.com/liferay/com-liferay-portal-portlet-bridge/blob/7.0.x/portal-portlet-bridge-soy/src/main/java/com/liferay/portal/portlet/bridge/soy/SoyPortlet.java}{\texttt{SoyPortlet}
class} extends Liferay DXP's
\href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/bridges/mvc/MVCPortlet.html}{\texttt{MVCPortlet}
class}, which is an extension itself of \texttt{javax.portlet.Portlet},
so you've provided the right implementation.

The component requires some properties as well. A sample configuration
is shown below:

\begin{verbatim}
@Component(
        immediate = true,
        property = {
          "com.liferay.portlet.add-default-resource=true",
          "com.liferay.portlet.application-type=full-page-application",
          "com.liferay.portlet.application-type=widget",
          "com.liferay.portlet.display-category=category.sample",
          "com.liferay.portlet.layout-cacheable=true",
          "com.liferay.portlet.preferences-owned-by-group=true",
          "com.liferay.portlet.private-request-attributes=false",
          "com.liferay.portlet.private-session-attributes=false",
          "com.liferay.portlet.render-weight=50",
          "com.liferay.portlet.scopeable=true",
          "com.liferay.portlet.use-default-template=true",
          "javax.portlet.display-name=Hello Soy Portlet",
          "javax.portlet.expiration-cache=0",
          "javax.portlet.init-param.copy-request-parameters=true",
          "javax.portlet.init-param.template-path=/",
          "javax.portlet.init-param.view-template=View",
          "javax.portlet.name=hello_soy_portlet",
          "javax.portlet.resource-bundle=content.Language",
          "javax.portlet.security-role-ref=guest,power-user,user",
          "javax.portlet.supports.mime-type=text/html"
        },
        service = Portlet.class
)
\end{verbatim}

Some of these properties may seem familiar to you, as they are the same
ones used to develop an MVC portlet. You can find a list of all the
Liferay-specific attributes that are available for use as properties in
your portlet components in the
\href{@platform-ref@/7.0-latest/definitions/liferay-portlet-app_7_0_0.dtd.html}{\texttt{liferay-portlet-app\_7\_0\_0.dtd}}.

The \texttt{javax.portlet...} properties are elements of the
\href{http://java.sun.com/xml/ns/portlet/portlet-app_2_0.xsd}{portlet.xml
descriptor}

Liferay's DTD files can be found
\href{@platform-ref@/7.0-latest/definitions/}{here}

Now that you've set your Soy portlet component's foundation, you can
write the controller code.

\subsection{Writing Controller Code}\label{writing-controller-code-1}

Soy portlets extend MVC portlets, so they use the same
Model-View-Controller framework to operate. Your controller receives
requests from the front-end, and it receives data from the back-end.
It's responsible for sending that data to the right front-end view so it
can be displayed to the user, and it's responsible for taking data the
user entered in the front-end and passing it to the right back-end
service. For this reason, it needs a way to process requests from the
front-end and respond to them appropriately, and it needs a way to
determine the appropriate front-end view to pass data back to the user.

\subsubsection{Render Logic}\label{render-logic-1}

The render logic is where all the magic happens. After all, what's the
use of a portlet if you can't see it? Note the \texttt{init-param}
properties you set in your Component class:

\begin{verbatim}
"javax.portlet.init-param.template-path=/",
"javax.portlet.init-param.view-template=View",
\end{verbatim}

This directs the default rendering to View (\texttt{View.soy}). The
\texttt{template-path} property tells the framework the location of your
Soy templates. The \texttt{/} above means that the Soy files are located
in your project's root \texttt{resources} folder. That's why it's
important to follow Liferay DXP's standard folder structure, outlined
above. Here's the path of a hypothetical web module's resource folder:

\begin{verbatim}
docs.liferaysoy.web/src/main/resources/META-INF/resources
\end{verbatim}

In this case, the \texttt{View.soy} file is found at:

\begin{verbatim}
docs.liferaysoy.web/src/main/resources/META-INF/resources/View.soy
\end{verbatim}

That's the default view of the application. When the \texttt{init}
method is called, the initialization parameters you specify are read and
used to direct rendering to the default template. Throughout this
framework, you can render a different view (Soy template) by setting the
\texttt{mvcRenderCommandName} parameter of the
\texttt{javax.portlet.PortletURL} to the Soy template. The example below
uses a portlet URL called \texttt{navigationURL} to render the view
\texttt{View}:

\begin{verbatim}
navigationURL.setParameter("mvcRenderCommandName", "View");
\end{verbatim}

Each view, excluding the default template view, \textbf{must have} an
implementation of the
\href{/docs/7-0/tutorials/-/knowledge_base/t/mvc-render-command}{\texttt{MVCRenderCommand}
class}. The \texttt{*MVCRenderCommand} implementation must declare
itself as a component with the \texttt{MVCRenderCommand} service, and it
must specify the portlet's name and MVC command name using the
\texttt{javax.portlet.name} and \texttt{mvc.command.name} properties
respectively. Below is an example \texttt{MVCRenderCommand}
implementation for a \texttt{Navigation} Soy template:

\begin{verbatim}
@Component(
        immediate = true,
        property = {
                "javax.portlet.name=hello_soy_portlet",
                "mvc.command.name=Navigation"
        },
        service = MVCRenderCommand.class
)
public class HelloSoyNavigationExampleMVCRenderCommand
        implements MVCRenderCommand {

        @Override
        public String render(
                RenderRequest renderRequest, RenderResponse renderResponse) {

                Template template = (Template)renderRequest.getAttribute(
                        WebKeys.TEMPLATE);

                PortletURL navigationURL = renderResponse.createRenderURL();

                navigationURL.setParameter("mvcRenderCommandName", "View");

                template.put("navigationURL", navigationURL.toString());

                return "Navigation";
        }

}
\end{verbatim}

The render logic provides the view layer with information to display the
data properly to the user. In this case the MVC command name is set to
\texttt{Navigation} (the Soy template with namespace
\texttt{Navigation}). The MVC render command name for the
\texttt{PortletURL} \texttt{navigationURL} is set to \texttt{View} (the
Soy template with namespace \texttt{Navigation}), using the
\texttt{mvcRenderCommandName} attribute. The \texttt{navigationURL}
parameter is passed to the \texttt{Navigation} Soy template as the
variable \texttt{navigationURL}, using the \texttt{template.put()}
method. Finally, the \texttt{*MVCRenderCommand} class returns the MVC
render command name as a \texttt{String}.

Note that Soy portlet parameters are scoped to the portlet class they're
written in. For instance, you can have a \texttt{navigationURL}
parameter in two different classes, each with a different value. Below
is an example \texttt{HelloSoyPortlet} class that also defines a
\texttt{navigationURL} parameter:

\begin{verbatim}
public class HelloSoyPortlet extends SoyPortlet {

    @Override
    public void render(
            RenderRequest renderRequest, RenderResponse renderResponse)
        throws IOException, PortletException {

        PortletURL navigationURL = renderResponse.createRenderURL();

        navigationURL.setParameter("mvcRenderCommandName", "Navigation");

        template.put("navigationURL", navigationURL.toString());

        template.put("releaseInfo", ReleaseInfo.getReleaseInfo());

        super.render(renderRequest, renderResponse);
    }

}
\end{verbatim}

The \texttt{navigationURL} points to the \texttt{Navigation} Soy
template this time. The \texttt{navigationURL} and \texttt{releaseInfo}
parameters are passed to the \texttt{View} Soy template. Since this
logic should be executed before the default \texttt{render} method, the
method concludes by calling \texttt{super.render}.

Now that you understand the render logic, you can learn how the view
layer works.

\subsection{Configuring the View
Layer}\label{configuring-the-view-layer-1}

Your portlet also requires a view layer, and for that you'll use Soy
templates, which is the whole point of developing a Soy portlet, isn't
it? This section briefly covers how to get your view layer working, from
including other Soy templates, to creating a MetalJS component for
rendering your views.

Soy templates are defined in a file with the extension \texttt{.soy}.
The filename is arbitrary. The Soy template's name is specified at the
top of the template using the \texttt{namespace} declaration. For
example, this template has the namespace \texttt{View}:

\begin{verbatim}
{namespace View}
\end{verbatim}

It can be accessed in another Soy template by calling the
\texttt{render} method on the namespace as shown below:

\begin{verbatim}
{call View.render data="all"}{/call}
\end{verbatim}

Below is an example \texttt{View} Soy template that includes
\texttt{Header} and \texttt{Footer} Soy templates:

\begin{verbatim}
{namespace View}

/**
 * Prints the portlet main view.
 */
{template .render}
  <div id="{$id}">
    {call Header.render data="all"}{/call}

    <p>{msg desc=""}here-is-a-message{/msg}</p>

    {call Footer.render data="all"}{/call}
  </div>
{/template}
\end{verbatim}

Each view has a corresponding \texttt{*es.js} file (usually with the
same name) that imports the Soy templates the view requires and
registers the view as a MetalJS component. This file is also used for
any additional JavaScript logic your view may have. For example, here is
a \texttt{View.es.js} component for a \texttt{View.soy} template:

\begin{verbatim}
import Component from 'metal-component/src/Component';
import Footer from './Footer.es';
import Header from './Header.es';
import Soy from 'metal-soy/src/Soy';
import templates from './View.soy';

/**
 * View Component
 */
class View extends Component {}

// Register component
Soy.register(View, templates);

export default View;
\end{verbatim}

Now that you understand how to configure a Soy template view, you can
learn how to use portlet parameters in your Soy templates next.

\subsubsection{Using Portlet Template Parameters in the Soy
Template}\label{using-portlet-template-parameters-in-the-soy-template}

As mentioned above, the \texttt{template.put()} method exposes portlet
parameters to the Soy templates. Once a parameter is exposed, you can
access it in the Soy template by defining it at the top with the
\texttt{\{@param\ name:\ type\}} declaration. For instance, the
\texttt{hello-soy-web} portlet's \texttt{View} Soy template defines the
\texttt{navigationURL} parameter with the code below:

\begin{verbatim}
{@param navigationURL: string}
\end{verbatim}

It is then used to navigate between portlet views:

\begin{verbatim}
<a href="{$navigationURL}">{msg desc=""}
    click-here-to-navigate-to-another-view
{/msg}</a>
\end{verbatim}

Some Java theme object variables are available as well. For example, to
access the
\href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/theme/ThemeDisplay.html}{\texttt{ThemeDisplay}
object} in a Soy template, use the following syntax:

\begin{verbatim}
{$themeDisplay}
\end{verbatim}

You can also access the \texttt{Locale} object by using
\texttt{\{\$locale\}}. Here is the full \texttt{View.soy} template for
the \texttt{com.liferay.hello.soy.web} portlet, which demonstrates the
features covered in this section:

\begin{verbatim}
{namespace View}

/**
 * Prints the portlet main view.
 */
{template .render}
    {@param id: string}
    {@param layouts: list<[
        friendlyURL: string,
        nameCurrentValue: string
    ]>}
    {@param navigationURL: string}

    <div id="{$id}">
        {call Header.render data="all"}{/call}

        <p>{msg desc=""}here-you-will-find-how-easy-it-is-to-do-things-like{/msg}</p>

        <h3>{msg desc=""}listing-pages{/msg}</h3>

        <div class="list-group">
            <div class="list-group-heading">{msg desc=""}navigate-to{/msg}</div>

            {foreach $layout in $layouts}
                <a class="list-group-item" href="{$layout.friendlyURL}">{$layout.nameCurrentValue}</a>
            {/foreach}
        </div>

        <h3>{msg desc=""}navigating-between-views{/msg}</h3>

        <a href="{$navigationURL}">{msg desc=""}click-here-to-navigate-to-another-view{/msg}</a>

        {call Footer.render data="all"}{/call}
    </div>
{/template}
\end{verbatim}

Now you know how to create a Soy Portlet!

\subsection{Related Topics}\label{related-topics-26}

\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-mvc-portlet}{Liferay
MVC Portlet}

\href{/docs/7-0/tutorials/-/knowledge_base/t/jsf-portlets-with-liferay-faces}{JSF
Portlets with Liferay Faces}

\chapter{The State Object}\label{the-state-object}

MetalJS's \texttt{component} class, which your
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-a-soy-portlet\#configuring-the-view-layer}{view
component} extends, extends MetalJS's \texttt{state} class. The
\texttt{state} class provides a \texttt{STATE} object that contains
state properties, as well as watches these properties for changes. Any
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-a-soy-portlet\#using-portlet-template-parameters-in-the-soy-template}{template
parameters} defined in your portlet classes are automatically added as
properties to the portlet's \texttt{STATE} object. The
\texttt{component} class provides additional rendering logic, such as
automatically re-rendering the component when the \texttt{state} class
detects a change in a state property. This means that you can
\href{/docs/7-0/tutorials/-/knowledge_base/t/configuring-soy-portlet-template-parameters-on-the-client-side}{change
a state property on the client-side} and automatically see that change
reflected in the component's UI!

This section of tutorials covers how to configure and use your Soy
portlet's \texttt{STATE} object.

\section{Understanding The State Object's
Architecture}\label{understanding-the-state-objects-architecture}

An example \texttt{STATE} object configuration appears below:

\begin{verbatim}
View.STATE {
  myStateProperty: {
    setter: 'setterFunction',
    validator: val => val === expected value,
    value: default value,
    valueFn: val => default value,
    writeOnce: true
  }
}
\end{verbatim}

State properties have these configuration options:

\textbf{setter:} Normalizes the state key's value. The setter function
receives the new value that was set and return the value that should be
stored.

\textbf{validator:} Validates the state key's value. When it returns
\texttt{false}, the new value is ignored.

\textbf{value:} The state key's default value. Alternatively, you can
set the default value with the \texttt{valueFn} property. Setting this
to an object causes all class instances to use the same reference to the
object. To have each instance use a different reference for objects, use
the \texttt{valueFn} option instead. Note that the portlet template
parameter's value (if applicable) has priority over this value.

\textbf{valueFn:} A function that returns the state key's default value.
Alternatively, you can set the default value with the \texttt{value}
property. Note that the portlet template parameter's value (if
applicable) has priority over this value.

\textbf{writeOnce:} Whether the state key is read-only, meaning the
initial value is the final value.

Now you know the \texttt{STATE} object's architecture and how to
configure it!

\subsection{Related Topics}\label{related-topics-27}

\href{/docs/7-0/tutorials/-/knowledge_base/t/configuring-portlet-template-parameter-state-properties}{Configuring
Portlet Template Parameter State Properties}

\href{/docs/7-0/tutorials/-/knowledge_base/t/configuring-soy-portlet-template-parameters-on-the-client-side}{Configuring
Soy Portlet Template Parameters on the Client Side}

\section{Configuring Portlet Template Parameter State
Properties}\label{configuring-portlet-template-parameter-state-properties}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-a-soy-portlet\#using-portlet-template-parameters-in-the-soy-template}{Portlet
template parameters} are added automatically as state properties to the
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-a-soy-portlet\#configuring-the-view-layer}{view
component}'s
\href{/docs/7-0/tutorials/-/knowledge_base/t/understanding-the-state-object-architecture}{\texttt{STATE}
object}. Therefore, you can provide additional configuration options for
them in the \texttt{STATE} object. The example below sets the default
value for the portlet template parameter \texttt{color} in its
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-a-soy-portlet\#render-logic}{\texttt{*MVCRenderCommand}
class}:

\begin{verbatim}
Template template = (Template)renderRequest.getAttribute(
            WebKeys.TEMPLATE);
      
String color = "red";

template.put("color", color);
\end{verbatim}

The configuration above has the implicit state property configuration
shown below in the view's component file (\texttt{View.es.js} for
example):

\begin{verbatim}
   View.STATE {
     color: {
       value: 'red'
     }
   }
\end{verbatim}

You can provide additional settings by
\href{/docs/7-0/tutorials/-/knowledge_base/t/understanding-the-state-object-architecture}{configuring
the state Property} in the \texttt{View} component. The example below
defines a \texttt{setter} function that transforms the color's string to
upper case before adding it to the \texttt{STATE} object:

\begin{verbatim}
function setColor(color) {
  return color.toUpperCase();
}

View.STATE = {
  color: {
    setter: 'setColor'      
  }
}
\end{verbatim}

Now you know how to configure portlet template parameter state
properties!

\subsection{Related Topics}\label{related-topics-28}

\href{/docs/7-0/tutorials/-/knowledge_base/t/understanding-the-state-object-architecture}{Understanding
the State Object's Architecture}

\href{/docs/7-0/tutorials/-/knowledge_base/t/configuring-soy-portlet-template-parameters-on-the-client-side}{Configuring
Soy Portlet Template Parameters on the Client Side}

\section{Configuring Soy Portlet Template Parameters on the Client
Side}\label{configuring-soy-portlet-template-parameters-on-the-client-side}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-a-soy-portlet\#using-portlet-template-parameters-in-the-soy-template}{Portlet
template parameters} are set in the Soy Portlet's server-side code.
MetalJS's \texttt{state} class provides a
\href{/docs/7-0/tutorials/-/knowledge_base/t/understanding-the-state-object-architecture}{\texttt{STATE}
object} that exposes these parameters as properties so you can access
them on the client side. This tutorial covers how to configure your view
component's \texttt{STATE} object and its properties on the client side
so you can update the UI.

This tutorial references the example below.

\subsection{An Example Header State
Portlet}\label{an-example-header-state-portlet}

This tutorial references the example portlet covered in this section. It
includes one view with a header that reads \emph{Hello Soy} by default.

\begin{figure}
\centering
\includegraphics{./images/soy-example-portlet-start.png}
\caption{The example Soy portlet has a configurable header.}
\end{figure}

The text in the header following \emph{Hello} is provided by the
\texttt{header} state property defined in its \texttt{*mvcRenderCommand}
class. Deploy the provided
\href{https://github.com/liferay/liferay-docs/tree/7.0.x/develop/tutorials/code/osgi/modules/com.liferay.docs.state.soy-1.0.0.jar}{\texttt{com.liferay.docs.state.soy-1.0.0.jar}
file} to follow along with this tutorial. The example portlet's
*MVCRenderCommand class and Soy template appear below for reference:

\texttt{*MVCRenderCommand} class:

\begin{verbatim}
@Component(
    immediate = true,
    property = {
        "javax.portlet.name=MyStateSoyPortlet", "mvc.command.name=View",
        "mvc.command.name=/"
    },
    service = MVCRenderCommand.class
)
public class MyStateSoyPortletViewMVCRenderCommand
    implements MVCRenderCommand {

    @Override
    public String render(
        RenderRequest renderRequest, RenderResponse renderResponse) {

        Template template = (Template)renderRequest.getAttribute(
            WebKeys.TEMPLATE);

        String header = "Soy";

        template.put("header", header);

        return "View";
    }

}
\end{verbatim}

\texttt{View.soy}:

\begin{verbatim}
{namespace View}

/**
 * Prints the portlet main view.
 */
{template .render}
    {@param id: string}
    {@param header: string}

    <div id="{$id}">

        <h1>Hello {$header}</h1>

        <p>You can update the header with the portlet's header State properties.</p>
    </div>
{/template}
\end{verbatim}

\subsection{Configuring the State
properties}\label{configuring-the-state-properties}

Soy Portlets are registered automatically using the
\href{https://github.com/liferay/liferay-portal/blob/7.0.x/modules/apps/foundation/portal-template/portal-template-soy/src/main/resources/com/liferay/portal/template/soy/utils/dependencies/bootstrap.js.tpl}{\texttt{Liferay.component}
API}, so you can use this API to retrieve your portlet and update its
state properties. You can test this in your browser's developer console.

Follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open the console in your web browser.
\item
  Retrieve your portlet's component by passing the Soy portlet's ID in
  the method \texttt{Liferay.component()}. For example, you can access
  the example portlet's component with the code below:

\begin{verbatim}
Liferay.component('_MyStateSoyPortlet_');
\end{verbatim}

  This returns the Soy portlet's component Object containing the state
  properties along with properties inherited from the prototype.
  Alternatively, you can access the \texttt{STATE} object directly by
  calling the \texttt{getState()} method:

\begin{verbatim}
Liferay.component("_MyStateSoyPortlet_").getState();
\end{verbatim}
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** The `Liferay.component()` method only returns the `STATE` object
 information for components currently on the page. These are the state
 properties defined for the current view.
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\item
  Now that you retrieved your Soy portlet's component, you can access
  its state properties the same way you would access any object's
  properties: the dot notation or the bracket notation. For example, you
  can use the code below to retrieve the
  \texttt{com.liferay.docs.state.soy} portlet's \texttt{header} state
  property:

\begin{verbatim}
Liferay.component("_MyStateSoyPortlet_").header;
\end{verbatim}

  or

\begin{verbatim}
Liferay.component("_MyStateSoyPortlet_")["header"]
\end{verbatim}
\item
  Update the state property's value:

\begin{verbatim}
Liferay.component("portletID").stateProperty = "new value";
\end{verbatim}

  or

\begin{verbatim}
Liferay.component("portletID")["stateProperty"] = "new value";
\end{verbatim}

  or you can pass a configuration object with the \texttt{setState()}
  method:

\begin{verbatim}
Liferay.component("portletID").setState({stateProperty: new value});
\end{verbatim}

  For example, you can change the example portlet's header to read
  \emph{Hello Hamburger} instead, if you don't like soy:

\begin{verbatim}
Liferay.component('_MyStateSoyPortlet_').setState({header: 'Hamburger'});
\end{verbatim}
\end{enumerate}

\begin{figure}
\centering
\includegraphics{./images/soy-example-portlet-fin.png}
\caption{You can change the example portlet's header state property on
the client side.}
\end{figure}

Now you know how to configure Soy portlet state properties on the client
side!

\subsection{Related Topics}\label{related-topics-29}

\href{/docs/7-0/tutorials/-/knowledge_base/t/understanding-the-state-object-architecture}{Understanding
the State Object's Architecture}

\href{/docs/7-0/tutorials/-/knowledge_base/t/configuring-portlet-template-parameter-state-properties}{Configuring
Portlet Template Parameter State Properties}

\chapter{Spring MVC}\label{spring-mvc}

Liferay is an open platform in an ecosystem of open platforms. Just
because Liferay has its own
\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-mvc-portlet}{MVC
framework}, therefore, doesn't mean you have to use it. It is perfectly
valid to bring the tools and experience you have from other development
projects over to Liferay. In fact, we expect you to. Liferay's
development platform is standards-based, making it an ideal choice for
applications of almost any type.

If you're already a wizard with Spring MVC, you can use it instead of
Liferay's
\href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/bridges/mvc/MVCPortlet.html}{\texttt{MVCPortlet}
class} with no limitations whatsoever. Since Spring MVC replaces only
your application's web application layer, you can still use
\href{/docs/7-0/tutorials/-/knowledge_base/t/what-is-service-builder}{Service
Builder} for your service layer.

So what does it take to implement a Spring MVC application in Liferay?
Start by considering how to package a Spring MVC application for 7.0.

\section{Packaging a Spring MVC
Portlet}\label{packaging-a-spring-mvc-portlet}

Developers creating portlets for 7.0 can usually deploy their portlet as
Java EE-style Web Application ARchive (WAR) artifacts or as Java ARchive
(JAR) OSGi bundle artifacts. Spring MVC portlet developers don't have
that flexibility. Spring MVC portlets must be packaged as WAR artifacts
because the Spring MVC framework is designed for Java EE. Therefore, it
expects a WAR layout and requires Java EE resources such as the
\texttt{WEB-INF/web.xml} descriptor.

Because Liferay supports the OSGi WAB (Web Application Bundler) standard
for deployment, you can deploy your WAR and it runs as expected in the
OSGi runtime. Here are the high points on why that works in 7.0:

\begin{itemize}
\item
  The Liferay auto-deploy process runs, adding the
  \texttt{PortletServlet} and \texttt{PlugincontextListener}
  configurations to the \texttt{WEB-INF/web.xml} file.
\item
  The
  \href{/docs/7-0/tutorials/-/knowledge_base/t/using-the-wab-generator}{Liferay
  WAB Generator} automatically creates an OSGi-ready
  \texttt{META-INF/MANIFEST.MF} file. If you want to affect the content
  of the manifest file, you can place BND directives and OSGi headers
  directly into the \texttt{WEB-INF/liferay-plugin-package.properties}
  file.
\end{itemize}

You'll still need to provide the Liferay descriptor files
\texttt{liferay-display.xml} and \texttt{liferay-portlet.xml}, and
you'll need a \texttt{portlet.xml} descriptor.

Develop a Spring MVC portlet WAR file with the appropriate descriptor
files.

\href{/docs/7-0/tutorials/-/knowledge_base/t/importing-packages}{Import
class packages} your portlet's descriptor files reference by adding the
packages to an \texttt{Import-Package} header in your
\texttt{liferay-plugin-package.properties} file.

Here's an example \texttt{Import-Package} header:

\begin{verbatim}
Import-Package:\
    org.springframework.beans.factory.xml,\
    org.springframework.context.config,\
    org.springframework.security.config,\
    org.springframework.web.servlet.config
\end{verbatim}

The auto-deploy process and Liferay's WAB generator convert your project
to a Liferay-ready WAB. The WAB generator detects your class's
\texttt{import} statements and adds all external packages to the WAB's
\texttt{Import-Package} header. The generator merges packages from your
plugin's \texttt{liferay-plugin-package.properties} into the header
also.

If you depend on a package from Java's \texttt{rt.jar} other than a
\texttt{java.*} package, override
\href{@platform-ref@/7.0-latest/propertiesdoc/portal.properties.html\#Module\%20Framework}{portal
property \texttt{org.osgi.framework.bootdelegation}} and add it to the
property's list. Go
\href{/docs/7-0/tutorials/-/knowledge_base/t/resolving-classnotfoundexception-and-noclassdeffounderror-in-osgi-bundles\#case-4-the-missing-class-belongs-to-a-java-runtime-package}{here}
for details.

\noindent\hrulefill

\textbf{Note}: Spring MVC portlets whose embedded JARs contain
properties files (e.g., \texttt{spring.handlers},
\texttt{spring.schemas}, \texttt{spring.tooling}) might be affected by
issue \href{https://issues.liferay.com/browse/LPS-75212}{LPS-75212}. The
last JAR that has properties files is the only JAR whose properties are
added to the resulting WAB's classpath. Properties in other JARs aren't
added.

For example, suppose that a portlet has several JARs containing these
properties files:

\begin{itemize}
\tightlist
\item
  \texttt{WEB-INF/src/META-INF/spring.handlers}
\item
  \texttt{WEB-INF/src/META-INF/spring.schemas}
\item
  \texttt{WEB-INF/src/META-INF/spring.tooling}
\end{itemize}

The properties from the last JAR processed are the only ones added to
the classpath. The properties files must be on the classpath in order
for the module to use them.

To add all the properties files to the classpath, you can combine them
into one of each type (e.g., one \texttt{spring.handlers}, one
\texttt{spring.schemas}, and one \texttt{spring.tooling}) and add them
to \texttt{WEB-INF/src}.

Here's a shell script that combines these files:

\begin{verbatim}
 cat /dev/null > docroot/WEB-INF/src/META-INF/spring.handlers
 cat /dev/null > docroot/WEB-INF/src/META-INF/spring.schemas
 cat /dev/null > docroot/WEB-INF/src/META-INF/spring.tooling
 for jar in $(find docroot/WEB-INF/lib/ -name '*.jar'); do
 for file in $(unzip -l $jar | grep -F META-INF/spring. | awk '
 { print $4 }
 '); do
 if [ "META-INF/spring.tld" != "$file" ]; then
 unzip -p $jar $file >> docroot/WEB-INF/src/$file
 echo >> docroot/WEB-INF/src/$file
 fi
 done
 done
\end{verbatim}

You can modify and use the shell script to add your JAR's properties
files to the classpath.

\noindent\hrulefill

\noindent\hrulefill

\textbf{Note}: If you want to use a Spring Framework version different
from the version Liferay DXP provides, you must name your Spring
Framework JARs differently from the ones
\href{https://docs.liferay.com/ce/portal/7.0-latest/propertiesdoc/portal.properties.html\#Module\%20Framework}{portal
property \texttt{module.framework.web.generator.excluded.paths}}
excludes. If you don't rename your Spring Framework JARs, the WAB
generator assumes you're using Liferay DXP's Spring Framework JARs and
excludes yours from the generated WAB.
\href{/docs/7-0/tutorials/-/knowledge_base/t/resolving-a-plugins-dependencies\#understanding-excluded-jars}{Understanding
Excluded JARs} explains how to detect Liferay DXP's Spring Framework
version.

\noindent\hrulefill

Now get into the details of configuring a Spring MVC portlet for
Liferay.

\section{Spring MVC Portlets in
Liferay}\label{spring-mvc-portlets-in-liferay}

This isn't a comprehensive guide to configuring a Spring MVC portlet. It
covers the high points, assuming you already have familiarity with
Spring MVC. If you don't, you should consider using Liferay's MVC
framework.

What does a Liferay Spring MVC portlet look like? Almost identical to
any other Spring MVC portlet. To configure a Spring MVC portlet, start
with the \texttt{\textless{}portlet-class\textgreater{}} element in
\texttt{portlet.xml}. In it you must declare Spring's
\texttt{DispatcherPortlet}:

\begin{verbatim}
<portlet-class>org.springframework.web.portlet.DispatcherPortlet</portlet-class>
\end{verbatim}

The Spring front controller needs to know where the application context
file is, so specify it as an initialization parameter in
\texttt{portlet.xml} (update the path as needed):

\begin{verbatim}
<init-param>
    <name>contextConfigLocation</name>
    <value>/WEB-INF/spring/portlet-context.xml</value>
</init-param>
\end{verbatim}

Provide an application context file (\texttt{portlet-context.xml} in the
example above), specified as you normally would for your Spring MVC
portlet.

\begin{verbatim}
<bean id="viewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver">
    <property name="prefix" value="/WEB-INF/views/" />
    <property name="suffix" value=".jsp" />
</bean>
\end{verbatim}

If you're configuring a WAB yourself, the \texttt{web.xml} file in your
Spring MVC project needs to be fully ready for deployment. In addition
to any \texttt{web.xml} configuration for Spring MVC, you need to
include a listener for
\href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/servlet/PluginContextListener.html}{\texttt{PluginContextListener}}
and a \texttt{servlet} and \texttt{servlet-mapping} for
\href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/servlet/PortletServlet.html}{\texttt{PortletServlet}}:

\begin{verbatim}
<listener>
    <listener-class>com.liferay.portal.kernel.servlet.PluginContextListener</listener-class>
</listener>
<servlet>
    <servlet-name>Portlet Servlet</servlet-name>
    <servlet-class>com.liferay.portal.kernel.servlet.PortletServlet</servlet-class>
    <load-on-startup>1</load-on-startup>
</servlet>
<servlet-mapping>
    <servlet-name>Portlet Servlet</servlet-name>
    <url-pattern>/portlet-servlet/*</url-pattern>
</servlet-mapping>
\end{verbatim}

If you're letting Liferay generate the WAB for you (this is the
recommended approach), the above is not necessary, as it is added
automatically during auto-deployment.

Your application must be able to convert
\texttt{javax.portlet.PortletRequest}s to
\texttt{javax.servlet.ServletRequest}s and back again. Add this to
\texttt{web.xml}:

\begin{verbatim}
<servlet>
    <servlet-name>ViewRendererServlet</servlet-name>
    <servlet-class>org.springframework.web.servlet.ViewRendererServlet</servlet-class>
    <load-on-startup>1</load-on-startup>
</servlet>
<servlet-mapping>
    <servlet-name>ViewRendererServlet</servlet-name>
    <url-pattern>/WEB-INF/servlet/view</url-pattern>
</servlet-mapping>
\end{verbatim}

To configure the Spring view resolver, add a bean in your application
context file:

\begin{verbatim}
<bean id="viewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver">
    <property name="prefix" value="/WEB-INF/views/" />
    <property name="suffix" value=".jsp" />
</bean>
\end{verbatim}

Now the front controller,
\texttt{org.springframework.web.portlet.DispatcherPortlet}, can get a
request from the view layer, but there are no actual controller classes
to delegate the request handling to.

With Spring MVC, your controller is conveniently separated into classes
that handle the portlet modes (View, Edit, Help).

You'll use Spring's annotations to configure the controller and tell
\texttt{DispatcherPortlet} which mode the controller supports.

A simple controller class supporting View mode might look like this:

\begin{verbatim}
@Controller("myAppController")
@RequestMapping("VIEW")
public class MyAppController {

    @RenderMapping
    public String processRenderRequest(RenderRequest request,
            RenderResponse response) {

        return "defaultView";
    }
}
\end{verbatim}

The \texttt{return\ defaultView} statement should be understood in terms
of the view resolver bean in the application context file, which gives
the String \texttt{defaultView} a prefix of \texttt{WEB-INF/views/}, and
a suffix of \texttt{.jsp}. That maps to the path
\texttt{WEB-INF/views/defaultView.jsp}, where you would place your
default view for the application.

With Spring MVC, you can only support one portlet phase in each
controller.

An edit mode controller might contain render methods and action methods.

\begin{verbatim}
@Controller("myAppEditController")
@RequestMapping("EDIT")
public class MyAppEditController {

    @RenderMapping
    public String processRenderRequest(RenderRequest request,
            RenderResponse response) {

        return "thisView";
    }

    @ActionMapping(params="action=doSomething")
    public void doSomething(Actionrequest request, ActionResponse response){
    
        // Do something here

    }
}
\end{verbatim}

You need to define any controller classes in your application context
file by adding a \texttt{\textless{}bean\textgreater{}} tag for each
one:

\begin{verbatim}
<bean class="com.liferay.docs.springmvc.portlet.MyAppController" />
<bean class="com.liferay.docs.springmvc.portlet.MyAppEditController" />
\end{verbatim}

Develop your controllers and your views as you normally would in a
Spring MVC portlet. You'll also need to provide some necessary
descriptors for Liferay.

\subsection{Liferay Descriptors}\label{liferay-descriptors}

Liferay portlet plugins that are packaged as WAR files should include
some Liferay specific descriptors.

The descriptor \texttt{liferay-display.xml} controls the category in
which your portlet appears in Liferay DXP's \emph{Add} menu. Find the
complete DTD
\href{@platform-ref@/7.0-latest/definitions/liferay-display_7_0_0.dtd.html}{here}.

Here's a simple example that just specifies the category the application
will go under in Liferay's menu for adding applications:

\begin{verbatim}
<display>
    <category name="New Category">
        <portlet id="example-portlet" />
    </category>
</display>
\end{verbatim}

The descriptor \texttt{liferay-portlet.xml} is used for specifying
additional information about the portlet (like the location of CSS and
JavaScript files or the portlet's icon. A complete list of the
attributes you can set can be found
\href{@platform-ref@/7.0-latest/definitions/liferay-portlet-app_7_0_0.dtd.html}{here}

\begin{verbatim}
<liferay-portlet-app>
    <portlet>
        <portlet-name>example-portlet</portlet-name>
        <instanceable>true</instanceable>
        <render-weight>0</render-weight>
        <ajaxable>true</ajaxable>
        <header-portlet-css>/css/main.css</header-portlet-css>
        <footer-portlet-javascript>/js/main.js</footer-portlet-javascript>
        <footer-portlet-javascript>/js/jquery.foundation.orbit.js</footer-portlet-javascript>
    </portlet>
    <role-mapper>
        <role-name>administrator</role-name>
        <role-link>Administrator</role-link>
    </role-mapper>
    <role-mapper>
        <role-name>guest</role-name>
        <role-link>Guest</role-link>
    </role-mapper>
    <role-mapper>
        <role-name>power-user</role-name>
        <role-link>Power User</role-link>
    </role-mapper>
    <role-mapper>
        <role-name>user</role-name>
        <role-link>User</role-link>
    </role-mapper>
</liferay-portlet-app>
\end{verbatim}

\noindent\hrulefill

\textbf{Important:} Make your portlet name unique, considering how
\href{/docs/7-0/reference/-/knowledge_base/r/portlet-descriptor-to-osgi-service-property-map\#six}{Liferay
DXP uses the name to create the portlet's ID}.

\noindent\hrulefill

You'll also notice the \texttt{role-mapper} elements included above.
They're for defining the Liferay roles used in the portlet.

Then there's the \texttt{liferay-plugin-package.properties}. These
properties describe the Liferay plugin, declare its resources, and
specify its security related parameters. The DTD is found
\href{@platform-ref@/7.0-latest/definitions/liferay-plugin-package_7_0_0.dtd.html}{here}.

\begin{verbatim}
name=example-portlet
module-group-id=liferay
module-incremental-version=1
tags=
short-description=
change-log=
page-url=http://www.liferay.com
author=Liferay, Inc.
licenses=LGPL
version=1
\end{verbatim}

In the \texttt{liferay-plugin-package.properties} file, you can also add
OSGi metadata which the
\href{/docs/7-0/tutorials/-/knowledge_base/t/using-the-wab-generator}{Liferay
WAB Generator} adds to the \texttt{MANIFEST.MF} file when you deploy
your WAR file.

Find all of Liferay's DTDs
\href{@platform-ref@/7.0-latest/definitions/}{here}.

\section{Calling Services from Spring
MVC}\label{calling-services-from-spring-mvc}

To call OSGi-based Service Builder services from your Spring MVC
portlet, you need a mechanism that gives you access to the OSGi service
registry.

\noindent\hrulefill

\textbf{Note:} If you don't already have one, create a service builder
project using
\href{/docs/7-0/tutorials/-/knowledge_base/t/blade-cli}{Blade CLI}.

\begin{verbatim}
 springmvc-service-builder/
     build.gradle
     springmvc-service-builder-api/
         bnd.bnd
         build.gradle
     springmvc-service-builder-service/
         bnd.bnd
         build.gradle
         service.xml
\end{verbatim}

Design your model entity and write your service layer as normal (see the
tutorials on Service Builder
\href{/docs/7-0/tutorials/-/knowledge_base/t/what-is-service-builder}{here}).
After that, add your service's API JAR as a dependency in your Spring
MVC project.

\noindent\hrulefill

Since you're in the context of a Spring MVC portlet, you can't look up a
reference to the services published to the OSGi runtime using
Declarative Services. So how do you call Service Builder services, or
other services published in the OSGi service registry? One way is by
calling the static utility methods.

\begin{verbatim}
FooServiceUtil.getFoosByGroupId()
\end{verbatim}

While very simple, that's not a good way to call OSGi services because
of the dynamic nature of the OSGi runtime. Service implementations could
be removed and added at any time, and your plugin needs to be able to
account for that. Additionally, you need a mechanism that lets your
portlet plugin react gracefully to the possibility of the service
implementation becoming unavailable entirely. That's why you should open
a Service Tracker when you want to call a service that's in the OSGi
service registry.

\subsection{Service Trackers}\label{service-trackers}

Since you don't have the luxury of using Declarative Services to manage
your service dependencies, you have a little bit of work to do if you
want to gain some of the benefits OSGi gives you:

\begin{itemize}
\item
  Accounting for multiple service implementations, using the best
  service implementation available (taking into account the service
  ranking property)
\item
  Accounting for no service implementations
\end{itemize}

The static utility classes don't let you do that, and that's sad. But be
happy, because with a little code, you can regain those benefits. For
the details on implementing a service tracker, read the
\href{/docs/7-0/tutorials/-/knowledge_base/t/service-trackers}{Service
Trackers tutorial}.

To summarize, you'll need to do these things:

\begin{itemize}
\item
  Instantiate a new \texttt{org.osgi.util.tracker.ServiceTracker} to
  track the service of the type you need.
\item
  Open the service tracker in an \texttt{@PostConstruct} method.
\item
  Make sure the service tracker has something in it.
\item
  If there is indeed something in the service tracker, get the service.
\item
  Now you're ready to call the service. Here's what the \texttt{if}
  block might look like:

\begin{verbatim}
 if (!someServiceTracker.isEmpty()) {
     SomeService someService = someServiceTracker.getService();
     someService.doSomethingCool();
 }
\end{verbatim}
\item
  Close the service tracker in an \texttt{@PreDestroy} method.
\end{itemize}

That's probably not enough detail, so refer to the tutorial on
\href{/docs/7-0/tutorials/-/knowledge_base/t/service-trackers}{Service
Trackers} for the details. As you'll see in the tutorial, there's some
boilerplate code involved, but leveraging service trackers lets you look
up services in the OSGi runtime.

If you are not required to use a Spring MVC portlet, consider using
Liferay's MVC framework to design your portlets instead. Then you can
take advantage of the Declarative Services \texttt{@Component} and
\texttt{@Reference} annotations, which let you avoid the boilerplate
code associated with service trackers.

\section{Related Topics}\label{related-topics-30}

\href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-a-spring-mvc-portlet}{Upgrading
a Spring MVC Portlet}

\href{/docs/7-0/tutorials/-/knowledge_base/t/using-the-wab-generator}{Using
the WAB Generator}

\chapter{JSF Portlets with Liferay
Faces}\label{jsf-portlets-with-liferay-faces}

\includegraphics{./images/liferay-faces-logo.png}

Do you want to develop MVC-based portlets using the Java EE standard? Do
you want to use a portlet development framework with a UI component
model that makes it easy to develop sophisticated, rich UIs? Or have you
been writing web apps using JSF that you'd like to use in Liferay DXP?
If you answered \emph{yes} to any of these questions, you're in luck!
Liferay Faces provides all these capabilities and more.

Liferay Faces is an umbrella project that provides support for the
JavaServer™ Faces (JSF) standard in Liferay DXP. It encompasses the
following projects:

\begin{itemize}
\tightlist
\item
  \textbf{Liferay Faces Bridge} lets you deploy JSF web apps as portlets
  without writing portlet-specific Java code. It also contains
  innovative features that make it possible to leverage the power of JSF
  2.x inside a portlet application. Liferay Faces Bridge implements the
  JSR 329/378 Portlet Bridge Standard.
\item
  \textbf{Liferay Faces Alloy} lets you use AlloyUI components in a way
  that is consistent with JSF development.
\item
  \textbf{Liferay Faces Portal} lets you leverage Liferay-specific
  utilities and UI components in JSF portlets.
\end{itemize}

For a comprehensive demo for the JSF component suite, visit the
\href{http://www.liferayfaces.org}{Liferay Faces Showcase}.

If you're new to JSF, you may want to know its strengths, its
weaknesses, and how it stacks up to developing portlets with
CSS/JavaScript.

Here are some good reasons to use JSF and Liferay Faces:

\begin{itemize}
\tightlist
\item
  JSF is the Java EE standard for developing web applications that use
  the Model/View/Controller (MVC) design pattern. As a standard, the
  specification is actively maintained by the Java Community Process
  (JCP), and the Oracle reference implementation (Mojarra) has frequent
  releases. Software Architects often choose standards like JSF because
  they are supported by Java EE application server vendors and have a
  guaranteed service life according to Service Level Agreements (SLAs).
\item
  JSF was first introduced in 2003 and is a mature technology for
  developing web applications that are (arguably) easy to maintain.
\item
  JSF Portlet Bridges (like Liferay Faces Bridge) are also standardized
  by the JCP and make it possible to deploy JSF web applications as
  portlets without writing portlet-specific Java code.
\item
  Support for JSF (via Liferay Faces) is included with Liferay DXP
  support.
\item
  JSF is a unique framework in that it provides a UI component model
  that makes it easy to develop sophisticated, rich user interfaces.
\item
  JSF has built-in Ajax functionality that provides automatic updates to
  the browser by replacing elements in the DOM.
\item
  JSF is designed with many extension points that make a variety of
  integrations possible.
\item
  There are several JSF component suites available including Liferay
  Faces Alloy, Primefaces, ICEfaces, and RichFaces. Each of these
  component suites fortify JSF with a variety of UI components and
  complimentary technologies such as Ajax Push.
\item
  JSF is a good choice for server-side developers that need to build web
  user interfaces. This enables server-side developers to focus on their
  core competencies rather than being experts in HTML/CSS/JavaScript.
\item
  JSF provides the Facelets templating engine which makes it possible to
  create reusable UI components that are encapsulated as markup.
\item
  JSF provides good integration with HTML5 markup
\item
  JSF provides the Faces Flows feature which makes it easy for
  developers to create wizard-like applications that flow from
  view-to-view.
\item
  JSF has good integration with dependency injection frameworks such as
  CDI and Spring that make it easy for developers to create beans that
  are placed within a scope managed by a container:
  \texttt{@RequestScoped}, \texttt{@ViewScoped},
  \texttt{@SessionScoped}, \texttt{@FlowScoped}
\item
  Since JSF is a stateful technology, the framework encapsulates the
  complexities of managing application state so the developer doesn't
  have to write state management code. It is also possible to use JSF in
  a stateless manner, but some of the features of application state
  management become effectively disabled.
\end{itemize}

There are some reasons not to use JSF. For example, if you are a
front-end developer who makes heavy use of HTML/CSS/JavaScript, you
might find that JSF UI components render HTML in a manner that gives you
less control over the overall HTML document. Sticking with JavaScript
and leveraging AlloyUI or some other JavaScript framework may be better
for you. Or, perhaps standards aren't a major consideration for you or
you may simply prefer developing portlets using your current framework.

Whether you develop your next portlet application with JSF and Liferay
Faces or with HTML/CSS/JavaScript is entirely up to you. But you
probably want to learn more about Liferay Faces and try it out for
yourself.

\section{Generating a JSF Project from the Command
Line}\label{generating-a-jsf-project-from-the-command-line}

You can generate a Liferay Faces application without having to create
your own folder structure, descriptor files, and such manually. If you
really want to do that manually, you can examine the structure of a JSF
application and create one from scratch in the
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-a-jsf-project-manually}{Creating
a JSF Project Manually} tutorial.

!P\href{https://portal.liferay.dev/documents/113763090/113920063/jsf-vid-thumbnail.png}{Video
Thumbnail}

Before generating your JSF application, you should first visit
\href{http://liferayfaces.org/}{liferayfaces.org}, a great reference
spot for JSF application development targeted for Liferay DXP. This site
lets you choose the options for your JSF application and generates a
Maven archetype command you can execute to generate an application with
your chosen options. You can select the following archetype options:

\begin{itemize}
\tightlist
\item
  Liferay Portal Version
\item
  JSF Version
\item
  Component Suite
\end{itemize}

You can also choose a build framework (Gradle or Maven) and have a list
of dependencies generated for you and displayed on the page. The
dependencies are provided to you on the site page in a \texttt{pom.xml}
or \texttt{build.gradle}, depending on the build type you selected. This
is useful because it gives you an idea of what dependencies are required
in your JSF application before generating it.

\textbf{Note:} Gradle developers can also use the
\texttt{archetype:generate} command because it generates both a
\texttt{build.gradle} and a \texttt{pom.xml} file for you to use.

\begin{figure}
\centering
\includegraphics{./images/jsf-app-generation.png}
\caption{You can select the Liferay Portal version, JSF version, and
component suite for your archetype generation command.}
\end{figure}

Next you'll generate an example JSF application (e.g., Liferay Portal 7
+ JSF 2.2 + JSF Standard) via command line using
\href{http://liferayfaces.org/}{liferayfaces.org}.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Navigate to \href{http://liferayfaces.org/}{liferayfaces.org} and
  select the following options:

  \begin{itemize}
  \tightlist
  \item
    \textbf{Liferay Portal:} 7
  \item
    \textbf{JSF:} 2.2
  \item
    \textbf{Component Suite:} JSF Standard
  \end{itemize}
\item
  Copy the archetype generation command and execute it. Make sure you've
  navigated to the folder where you want to generate your project.
\end{enumerate}

That's it! Your JSF application is generated in the current folder!

You can also generate a Liferay JSF application using Maven's
interactive archetype UI. To do this, execute
\texttt{mvn\ archetype:generate\ -Dfilter=liferay} and select the JSF
archetype you want to use. Then you'll step through each option and
select the version, group ID, artifact ID, etc. To learn more about
this, see the
\href{/docs/7-0/tutorials/-/knowledge_base/t/generating-new-projects-using-archetypes}{Generating
New Projects Using Archetypes} tutorial.

Once you have your JSF application generated, you can
\href{/docs/7-0/tutorials/-/knowledge_base/t/using-maven-in-liferay-ide\#importing-maven-projects}{import
it into Liferay @ide@} and develop it further. To
\href{/docs/7-0/tutorials/-/knowledge_base/t/deploying-modules-with-liferay-ide}{deploy
it to your Liferay DXP instance}, drag and drop it onto the Liferay DXP
server.

You can build the project and deploy it to Liferay DXP from the command
line too! If you're using Gradle, run the following command to build
your JSF application:

\begin{verbatim}
gradle build
\end{verbatim}

For Maven, execute the following command:

\begin{verbatim}
mvn package
\end{verbatim}

Then copy the generated WAR to Liferay DXP's \texttt{deploy} folder:

\begin{verbatim}
[cp|copy] ./com.mycompany.my.jsf.portlet.war LIFERAY_HOME/deploy
\end{verbatim}

Awesome! You've generated your JSF application and deployed it using the
command line.

!V\href{https://portal.liferay.dev/documents/113763090/113920063/developing-a-new-jsf-portlet.mp4\%7Chttps://portal.liferay.dev/documents/113763090/113920063/developing-a-new-jsf-portlet.mkv}{Video
Tutorial}

\section{Generating a JSF Project Using
@ide@}\label{generating-a-jsf-project-using-ide}

You can generate a Liferay Faces application without having to create
your own folder structure and descriptor files manually using Liferay
@ide@. If you're interested in creating the structure of a JSF
application manually or if you want to examine a basic JSF application
structure, visit the
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-a-jsf-project-manually}{Creating
a JSF Project Manually} tutorial.

In this tutorial, you'll generate an example JSF project using Liferay
@ide@. Open your @ide@ instance to get started.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Navigate to \emph{File} → \emph{New} → \emph{Project\ldots{}}. This
  opens a new project wizard.
\item
  Select the \emph{Liferay} project and choose \emph{Liferay JSF
  Project} from the listed subprojects. Then click \emph{Next}.

  \begin{figure}
  \centering
  \includegraphics{./images/jsf-project-ide.png}
  \caption{Choose the \emph{Liferay JSF Project} option to begin
  creating a JSF project in @ide@.}
  \end{figure}
\item
  Assign your JSF project a name, build framework (Gradle or Maven), and
  Component Suite. You have five component suites to choose from:

  \begin{itemize}
  \tightlist
  \item
    ICEFaces
  \item
    JSF Standard
  \item
    Liferay Faces Alloy
  \item
    PrimeFaces
  \item
    RichFaces
  \end{itemize}

  \begin{figure}
  \centering
  \includegraphics{./images/new-jsf-project-ide.png}
  \caption{Choose your preferred options for your JSF project.}
  \end{figure}
\item
  Click \emph{Finish} to generate your Liferay JSF project.
\end{enumerate}

You've generated a Liferay JSF project using @ide@! The project you
generated contains a simple portlet that you can customize.

\begin{figure}
\centering
\includegraphics{./images/jsf-ide-generated-project.png}
\caption{The generated JSF portlet project displays basic build
information.}
\end{figure}

\noindent\hrulefill

\textbf{Note:} There is another option in @ide@'s \emph{File} →
\emph{New} menu named \emph{Liferay JSF Portlet}. This is intended to
add portlets to existing JSF projects. Currently, this is only
configured to create Liferay Portal 6.2 JSF portlets. Do not use this
option if you're developing for 7.0.

\noindent\hrulefill

To
\href{/docs/7-0/tutorials/-/knowledge_base/t/deploying-modules-with-liferay-ide}{deploy
the new JSF project to your Liferay DXP instance}, drag and drop it onto
the Liferay server.

Fantastic! You're now able to quickly generate your Liferay JSF project
using Liferay @ide@!

\section{Creating a JSF Project
Manually}\label{creating-a-jsf-project-manually}

Liferay DXP's modular architecture lends itself well to modular
applications created using a multitude of different technologies. JSF
applications are no different and can be developed to integrate
seamlessly into the Liferay platform.

In this tutorial, you'll step through packaging and creating a JSF
application that is deployable as an OSGi module at runtime. First,
you'll learn how to package a JSF application as a module.

\subsection{Packaging a JSF
Application}\label{packaging-a-jsf-application}

Developers creating portlets for 7.0 can package their portlets as Java
EE style Web Application ARchive (WAR) artifacts or as Java ARchive
(JAR) OSGi bundle artifacts. JSF portlet developers, however, must
package their portlets as WAR artifacts because the JSF framework
expects a WAR layout and often requires the
\texttt{WEB-INF/faces-config.xml} descriptor and other Java EE resources
such as the \texttt{WEB-INF/web.xml} descriptor.

Liferay provides a way for these WAR-styled portlets to be deployed and
treated like OSGi modules by Liferay's OSGi runtime. The WAB Generator
does this automatically by converting your WAR artifact to a WAB at
deployment time. You can learn more about WABs and the WAB Generator in
the
\href{/docs/7-0/tutorials/-/knowledge_base/t/using-the-wab-generator}{Using
the WAB Generator} tutorial.

This is how a JSF WAR artifact is structured:

\begin{itemize}
\tightlist
\item
  \texttt{jsf-portlet}

  \begin{itemize}
  \tightlist
  \item
    \texttt{src}

    \begin{itemize}
    \tightlist
    \item
      \texttt{main}

      \begin{itemize}
      \tightlist
      \item
        \texttt{java}

        \begin{itemize}
        \tightlist
        \item
          Java Classes
        \end{itemize}
      \item
        \texttt{resources}

        \begin{itemize}
        \tightlist
        \item
          Properties files
        \end{itemize}
      \item
        \texttt{webapp}

        \begin{itemize}
        \tightlist
        \item
          \texttt{WEB-INF/}

          \begin{itemize}
          \tightlist
          \item
            \texttt{classes/}

            \begin{itemize}
            \tightlist
            \item
              Class files and related properties
            \end{itemize}
          \item
            \texttt{lib/}

            \begin{itemize}
            \tightlist
            \item
              JAR dependencies
            \end{itemize}
          \item
            \texttt{resources/}

            \begin{itemize}
            \tightlist
            \item
              CSS, XHTML, PNG or other frontend files
            \end{itemize}
          \item
            \texttt{views/}

            \begin{itemize}
            \tightlist
            \item
              XHTML views
            \end{itemize}
          \item
            \texttt{faces-config.xml}
          \item
            \texttt{liferay-display.xml}
          \item
            \texttt{liferay-plugin-package.properties}
          \item
            \texttt{liferay-portlet.xml}
          \item
            \texttt{portlet.xml}
          \item
            \texttt{web.xml}
          \end{itemize}
        \end{itemize}
      \end{itemize}
    \end{itemize}
  \end{itemize}
\end{itemize}

Next, you'll begin creating a simple JSF application that is deployable
to Liferay DXP.

\subsection{Creating a JSF
Application}\label{creating-a-jsf-application}

JSF portlets are supported on Liferay Portal by using
\href{/docs/7-0/reference/-/knowledge_base/r/understanding-liferay-faces-bridge}{Liferay
Faces Bridge}. Liferay Faces Bridge makes developing JSF portlets as
similar as possible to JSF web app development.

You'll create a simple \emph{Hello User} application that asks for the
user's name and then greets him or her with the name. You'll begin by
creating the WAR-style folder structure, and then you'll configure
dependencies like Liferay Faces Bridge.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a WAR-style folder structure for your module.
  \href{https://web.liferay.com/web/neil.griffin/blog/-/blogs/new-maven-archetypes-for-jsf-portlets}{Maven
  archetypes} are available to help you get started quickly. They set
  the default configuration for you and contain boilerplate code so you
  can skip the file creation steps and get started right away. For your
  JSF application, you'll set up the folder structure manually. Follow
  the folder structure outline below:

\begin{verbatim}
- hello-user-jsf-portlet
    - src
        - main
            - java
            - resources
            - webapp
                - WEB-INF
                    - resources
                    - views
\end{verbatim}
\item
  Make sure your module specifies the dependencies necessary for a
  Liferay JSF application. For instance, you must always specify the
  Faces API, Faces Reference Implementation (Mojarra), and Liferay Faces
  Bridge as dependencies in a Liferay-compatible JSF application. Also,
  an important, but not required, dependency is the Log4j logging
  utility. This is highly recommended for development purposes because
  it logs DEBUG messages in the console. You'll configure the logging
  utility later.

  For an example build file, the \texttt{pom.xml} file used for the
  Maven based Hello User JSF application is below. All the dependencies
  described above are configured in the Hello User JSF application's
  \texttt{pom.xml} file.

\begin{verbatim}
<?xml version="1.0"?>

<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <groupId>com.liferay</groupId>
    <artifactId>com.liferay.hello.user.jsf.portlet</artifactId>
    <packaging>war</packaging>
    <name>hello-user-jsf-portlet</name>
    <version>1.0-SNAPSHOT</version>
    <properties>
        <faces.api.version>2.2</faces.api.version>
        <liferay.faces.bridge.ext.version>5.0.0</liferay.faces.bridge.ext.version>
        <liferay.faces.bridge.version>4.0.0</liferay.faces.bridge.version>
        <mojarra.version>2.2.13</mojarra.version>
    </properties>
    <build>
        <plugins>
            <plugin>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.3</version>
                <configuration>
                    <encoding>UTF-8</encoding>
                    <source>1.8</source>
                    <target>1.8</target>
                </configuration>
            </plugin>
            <plugin>
                <artifactId>maven-war-plugin</artifactId>
                <version>2.3</version>
                <configuration>
                    <filteringDeploymentDescriptors>true</filteringDeploymentDescriptors>
                </configuration>
            </plugin>
        </plugins>
    </build>
    <dependencies>
        <dependency>
            <groupId>javax.faces</groupId>
            <artifactId>javax.faces-api</artifactId>
            <version>${faces.api.version}</version>
            <scope>provided</scope>
        </dependency>
        <dependency>
            <groupId>org.glassfish</groupId>
            <artifactId>javax.faces</artifactId>
            <version>${mojarra.version}</version>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>com.liferay.faces</groupId>
            <artifactId>com.liferay.faces.bridge.ext</artifactId>
            <version>${liferay.faces.bridge.ext.version}</version>
        </dependency>
        <dependency>
            <groupId>com.liferay.faces</groupId>
            <artifactId>com.liferay.faces.bridge.impl</artifactId>
            <version>${liferay.faces.bridge.version}</version>
        </dependency>
        <dependency>
            <groupId>log4j</groupId>
            <artifactId>log4j</artifactId>
            <version>1.2.14</version>
        </dependency>
    </dependencies>
</project>
\end{verbatim}

  There are also two plugins the Hello User JSF application defined in
  its \texttt{pom.xml}:
  \href{https://maven.apache.org/plugins/maven-compiler-plugin/}{maven-compiler-plugin}
  and
  \href{https://maven.apache.org/plugins/maven-war-plugin/}{maven-war-plugin}.
  These two plugins are responsible for building and compiling the JSF
  application using Maven.

  There are several UI component suites that a JSF application can use,
  which include
  \href{/docs/7-0/reference/-/knowledge_base/r/understanding-liferay-faces-alloy}{\emph{Liferay
  Faces Alloy}}, \href{http://primefaces.org/}{\emph{PrimeFaces}},
  \href{http://www.icesoft.org/java/projects/ICEfaces/overview.jsf}{\emph{ICEfaces}},
  and \href{http://richfaces.jboss.org/}{\emph{RichFaces}}. Furthermore,
  you can take advantage of
  \href{/docs/7-0/reference/-/knowledge_base/r/understanding-liferay-faces-portal}{\emph{Liferay
  Faces Portal}} in order to use Liferay-specific utilities and UI
  components. These components can be used by specifying them as
  dependencies in your build file, as well.

  Now that your build file is configured, you must define the
  JSF-specific configurations for your application. These fall into two
  convenient categories: general descriptors and Liferay descriptors.
  You'll start with creating the necessary general descriptors.
\end{enumerate}

\subsubsection{Defining JSF Portlet
Descriptors}\label{defining-jsf-portlet-descriptors}

Since JSF portlets must follow a WAR-style folder structure, they must
also have WAR-style portlet descriptors.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a \texttt{portlet.xml} file in the \texttt{webapp/WEB-INF}
  folder. All portlet WARs require this file. In this file, make sure to
  declare the following portlet class:

\begin{verbatim}
<portlet>
    ...
    <portlet-class>javax.portlet.faces.GenericFacesPortlet</portlet-class>
    ...
</portlet>
\end{verbatim}

  The \texttt{javax.portlet.faces.GenericFacesPortlet} class handles
  invocations to your JSF portlet and makes your portlet, since it
  relies on Liferay Faces Bridge, easy to develop by acting as a turnkey
  implementation.
\item
  Define a default view file as an \texttt{init-param} in the
  \texttt{portlet.xml}. This ensures your portlet is visible when
  deployed to Liferay DXP.

\begin{verbatim}
<init-param>
    <name>javax.portlet.faces.defaultViewId.view</name>
    <value>/WEB-INF/views/view.xhtml</value>
</init-param>
\end{verbatim}

  You'll create this view later.

  The \texttt{portlet.xml} file holds other important details too, like
  portlet info and security settings. Look at the \texttt{portlet.xml}
  file for the example Hello User JSF application.

\begin{verbatim}
<?xml version="1.0"?>

<portlet-app xmlns="http://java.sun.com/xml/ns/portlet/portlet-app_2_0.xsd" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/portlet/portlet-app_2_0.xsd http://java.sun.com/xml/ns/portlet/portlet-app_2_0.xsd" version="2.0">
    <portlet>
        <portlet-name>hello-user-jsf-portlet</portlet-name>
        <display-name>Hello User JSF Portlet</display-name>
        <portlet-class>javax.portlet.faces.GenericFacesPortlet</portlet-class>
        <init-param>
            <name>javax.portlet.faces.defaultViewId.view</name>
            <value>/WEB-INF/views/view.xhtml</value>
        </init-param>
        <expiration-cache>0</expiration-cache>
        <supports>
            <mime-type>text/html</mime-type>
        </supports>
        <portlet-info>
            <title>Hello User JSF Portlet</title>
            <short-title>Hello User</short-title>
            <keywords>com.liferay.hello.user.jsf.portlet</keywords>
        </portlet-info>
        <security-role-ref>
            <role-name>administrator</role-name>
        </security-role-ref>
        <security-role-ref>
            <role-name>guest</role-name>
        </security-role-ref>
        <security-role-ref>
            <role-name>power-user</role-name>
        </security-role-ref>
        <security-role-ref>
            <role-name>user</role-name>
        </security-role-ref>
    </portlet>
</portlet-app>
\end{verbatim}

  The above configuration sets your portlet's various names, MIME type,
  expiration cache, and security roles.
\item
  Create a \texttt{web.xml} file in your JSF application's
  \texttt{webapp/WEB-INF} folder. The \texttt{web.xml} file serves as a
  deployment descriptor that provides necessary configurations for your
  JSF portlet to deploy and function in Liferay DXP. Copy the XML code
  below into your Hello User JSF application.

\begin{verbatim}
<?xml version="1.0" encoding="UTF-8"?>

<web-app xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd" version="3.0">

    <context-param>
        <param-name>javax.faces.PROJECT_STAGE</param-name>
        <param-value>${project.stage}</param-value>
    </context-param>
    <context-param>
        <param-name>javax.faces.WEBAPP_RESOURCES_DIRECTORY</param-name>
        <param-value>/WEB-INF/resources</param-value>
    </context-param>
    <servlet>
        <servlet-name>Faces Servlet</servlet-name>
        <servlet-class>javax.faces.webapp.FacesServlet</servlet-class>
        <load-on-startup>1</load-on-startup>
    </servlet>
    <security-constraint>
        <display-name>Prevent direct access to Facelet XHTML</display-name>
        <web-resource-collection>
            <web-resource-name>Facelet XHTML</web-resource-name>
            <url-pattern>*.xhtml</url-pattern>
        </web-resource-collection>
        <auth-constraint/>
    </security-constraint>
</web-app>
\end{verbatim}

  First, you set the \texttt{javax.faces.PROJECT\_STAGE} parameter to
  the \texttt{\$\{project.stage\}} variable, which is defined in your
  build file (e.g., \texttt{pom.xml}) as \texttt{Development}. When set
  to \texttt{Development}, the JSF implementation will perform the
  following steps at runtime:

  \begin{enumerate}
  \def\labelenumii{\arabic{enumii}.}
  \tightlist
  \item
    Log more verbose messages.
  \item
    Render tips and/or warnings in the view markup.
  \item
    Cause the default \texttt{ExceptionHandler} to display a
    developer-friendly error page.
  \end{enumerate}

  The \texttt{javax.faces.WEBAPP\_RESOURCES\_DIRECTORY} parameter sets
  the resources folder inside the \texttt{WEB-INF} folder. This setting
  makes the resources in that folder (e.g., CSS, JavaScript, XHTML)
  secure from non-JSF calls. You'll
  \hyperref[defining-resources-for-a-jsf-application]{create resources}
  for your app later.

  The Faces Servlet configuration is required to initialize JSF and
  should be defined in all JSF portlets deployed to Liferay DXP.

  Finally, a security restraint is set on Facelet XHTML, which prevents
  direct access to XHTML files in your JSF application.
\item
  Create a \texttt{faces-config.xml} file in your JSF application's
  \texttt{webapp/WEB-INF} folder. The \texttt{faces-config.xml}
  descriptor is a JSF portlet's application configuration file, which is
  used to register and configure objects and navigation rules. The Hello
  User portlet's \texttt{faces-config.xml} file has the following
  contents:

\begin{verbatim}
<?xml version="1.0"?>

<faces-config version="2.2"
    xmlns="http://xmlns.jcp.org/xml/ns/javaee"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-facesconfig_2_2.xsd"
>
    <lifecycle>
        <phase-listener>com.liferay.faces.util.lifecycle.DebugPhaseListener</phase-listener>
    </lifecycle>
</faces-config>
\end{verbatim}

  Many auto-generated \texttt{faces-config.xml} files have the following
  configuration:

\begin{verbatim}
<lifecycle>
    <phase-listener>com.liferay.faces.util.lifecycle.DebugPhaseListener</phase-listener>
</lifecycle>
\end{verbatim}

  This configures your JSF portlet to log the before/after phases of the
  JSF lifecycle to your console in debug mode. Remove this declaration
  before deploying to production.
\end{enumerate}

Great! You now have a good idea of how to specify and define general
descriptor files for your JSF portlet. JSF portlets also use Liferay
descriptors, which you can learn more about in the
\href{/docs/7-0/tutorials/-/knowledge_base/t/spring-mvc\#liferay-descriptors}{Liferay
Descriptors} sub-section.

Now that your portlet descriptors are defined, you should begin working
on your JSF application's resources.

\subsubsection{Defining Resources for a JSF
Application}\label{defining-resources-for-a-jsf-application}

If you look back at the Hello User portlet's structure, you'll notice
two \texttt{resources} folders defined. Why are there two of these
folders for one portlet? These two folders have distinct differences in
how they're used and what should be placed in them.

The \texttt{resources} folder in the application's \texttt{src/main}
folder is intended for resources that need to be on the classpath. Files
in this folder are usually properties files. For this portlet, you'll
create two properties files to reside in this folder.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create the \texttt{i18n.properties} file in the
  \texttt{src/main/resources} folder. Add the following property to this
  file:

\begin{verbatim}
enter-your-name=Enter your name:
\end{verbatim}

  This is a language key your JSF portlet displays in its view XHTML.
  The messages in the \texttt{i18n.properties} file can be accessed via
  the
  \href{http://docs.oracle.com/javaee/6/tutorial/doc/bnahq.html}{Expression
  Language} using the implicit \texttt{i18n} object provided by the
  Liferay Faces Util class. The \texttt{i18n} object can access messages
  both from a resource bundle defined in the portlet's
  \texttt{portlet.xml} file, and from Liferay DXP's
  \texttt{Language.properties} file.
\item
  Create the \texttt{log4j.properties} file in the
  \texttt{src/main/resources} folder. This file sets properties for the
  Log4j logging utility defined in your JSF application (i.e.,
  \texttt{faces-config.xml}). Insert the properties below into your JSF
  application's \texttt{log4j.properties} file.

\begin{verbatim}
log4j.rootLogger=INFO, CONSOLE

log4j.appender.CONSOLE=org.apache.log4j.ConsoleAppender
log4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayout
log4j.appender.CONSOLE.layout.ConversionPattern=%d{ABSOLUTE} %-5p [%c{1}:%L] %m%n

log4j.logger.com.liferay.faces.util.lifecycle.DebugPhaseListener=DEBUG
\end{verbatim}
\end{enumerate}

The second \texttt{resources} folder in your JSF application is located
in the \texttt{src/main/webapp/WEB-INF} folder. This folder holds
CSS/JS/XHTML resources that shouldn't be accessed directly by the
browser. For the Hello User JSF application, create a \texttt{css}
folder with a \texttt{main.css} file inside. In the \texttt{main.css}
file, add the following style:

\begin{verbatim}
.com.liferay.hello.user.jsf.portlet {
    font-weight: bold;
}
\end{verbatim}

This file gives your JSF portlet a bold font.

Now that your resources are defined, it's time to begin developing the
Hello User application's behavior and UI.

\subsubsection{Developing a JSF Application's Behavior and
UI}\label{developing-a-jsf-applications-behavior-and-ui}

Your current JSF application satisfies the requirements for portlet
descriptors and WAR-style structure, but it doesn't do anything yet.
You'll learn how to develop a JSF application's back-end and give it a
simple UI next.

The first thing to do is create a Java class for your module. Your JSF
portlet's behavior is defined here. In the case of the Hello User
portlet, you should provide Java methods that can get/set a name and
facilitate the submission process.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a unique package name in the module's \texttt{src/main/java}
  folder and create a new public Java class named
  \texttt{ExampleBacking.java} in that package. For example, the class's
  folder structure could be
  \texttt{src/main/java/com/liferay/example/ExampleBacking.java}. Make
  sure the class is annotated with
  \href{http://docs.oracle.com/javaee/7/api/javax/faces/bean/RequestScoped.html}{@RequestScoped}
  and
  \href{http://docs.oracle.com/javaee/7/api/javax/faces/bean/ManagedBean.html}{@ManagedBean}:

\begin{verbatim}
@RequestScoped
@ManagedBean
public class ExampleBacking {
\end{verbatim}

  Managed beans are Java beans that are managed by the JSF framework.
  Managed beans annotated with \texttt{@RequestScoped} are usually
  responsible for handling actions and listeners. JSF \emph{manages}
  these beans by creating and removing the bean object from the server.
  Visit the linked annotations above for more details.
\item
  Add the following methods and field to your
  \texttt{ExampleBacking.java} class:

\begin{verbatim}
public String getName() {
    return name;
}

public void setName(String name) {
    this.name = name;
}

public void submit(ActionEvent actionEvent) {
    FacesContextHelperUtil.addGlobalSuccessInfoMessage();
}

private String name;
\end{verbatim}

  You've provided a getter and setter method for the private
  \texttt{name} field. You've also provided a \texttt{submit(...)}
  method, which is called when the \emph{Submit} button is selected. A
  success info message is displayed once the method is invoked.

  You've defined your Hello User portlet's Java behavior; now create its
  UI!
\item
  Create a \texttt{view.xhtml} file in the \texttt{webapp/WEB-INF/views}
  folder. Add the following logic to that file:

\begin{verbatim}
<?xml version="1.0"?>

<f:view
    xmlns="http://www.w3.org/1999/xhtml"
    xmlns:f="http://java.sun.com/jsf/core"
    xmlns:h="http://java.sun.com/jsf/html"
>
    <h:head>
        <h:outputStylesheet library="css" name="main.css" />
    </h:head>
    <h:form>
        <h:messages globalOnly="true" />
        <h:outputLabel value="#{i18n['enter-your-name']}" />
        <h:inputText value="#{exampleBacking.name}" />
        <h:commandButton actionListener="#{exampleBacking.submit}" value="#{i18n['submit']}">
            <f:ajax execute="@form" render="@form" />
        </h:commandButton>
        <br />
        <h:outputText value="Hello #{exampleBacking.name}" />
    </h:form>
</f:view>
\end{verbatim}

  The first thing to notice is the \texttt{main.css} file you created is
  specified here, which makes your portlet's heading typeface bold.
  Next, your form is defined within the
  \texttt{\textless{}h:form\textgreater{}} tags. The form asks the user
  to enter his or her name, and then sets that value to the
  \texttt{name} field in your Java class. The form uses the
  \texttt{\textless{}h:commandButton\textgreater{}} tag to execute the
  Submit button and render the form after submission.

  Notice the \texttt{i18n} object call for the \texttt{enter-your-name}
  and \texttt{submit} properties. The \texttt{enter-your-name} property
  was set in the \texttt{i18n.properties} file you specified, but what
  about the \texttt{submit} property? This was not defined in your
  portlet's \texttt{i18n.properties} file, so how does your portlet know
  to use the string \emph{Submit} for your button? If you recall, the
  \texttt{i18n} object can also access messages in Liferay DXP's
  \texttt{Language.properties} file. This is where the \texttt{submit}
  language key comes from.

  Finally, the \texttt{\textless{}h:outputText\textgreater{}} tag prints
  the submitted name on the page, prefixed with \emph{Hello}.
\end{enumerate}

Awesome! Your Hello User JSF application is complete! Deploy your WAR to
Liferay DXP. Remember, when your WAR-style portlet is deployed, it's
converted to a WAB via the WAB Generator. Visit the
\href{/docs/7-0/tutorials/-/knowledge_base/t/using-the-wab-generator}{Using
the WAB Generator} tutorial for more information on this process and
your portlet's resulting folder structure.

\begin{figure}
\centering
\includegraphics{./images/hello-user-jsf-portlet.png}
\caption{After submitting the user's name, it's displayed with a
greeting.}
\end{figure}

To recap, you created your JSF application in the following steps:

\begin{itemize}
\tightlist
\item
  Construct the WAR-style folder structure.
\item
  Specify the necessary dependencies in a build file of your choice.
\item
  Create JSF portlet descriptors and Liferay descriptors.
\item
  Add resource files in the two designated \texttt{resources} folders.
\item
  Define the portlet's behavior using a Java class.
\item
  Design a view XHTML form to let the user interact with the portlet.
\end{itemize}

You can view the finished version of the Hello User JSF application by
downloading its
\href{https://portal.liferay.dev/documents/113763090/114000186/hello-user-jsf-portlet.zip}{ZIP
file}.

Now you have the knowledge to create your own JSF applications!

\subsection{Related Topics}\label{related-topics-31}

\href{/docs/7-0/tutorials/-/knowledge_base/t/fundamentals}{Fundamentals}

\href{/docs/7-0/tutorials/-/knowledge_base/t/internationalization}{Internationalization}

\href{/docs/7-0/tutorials/-/knowledge_base/t/configuration}{Configuration}

\section{Services in JSF}\label{services-in-jsf}

Creating services works the same in a JSF portlet as it would in any
other standard WAR-style MVC portlet; generate custom services as
separate API and Impl JARs and deploy them as individual modules to
Liferay DXP. You can generate custom services for your JSF portlet using
Service Builder. To learn more about how Service Builder works in
Liferay DXP, visit the
\href{/docs/7-0/tutorials/-/knowledge_base/t/service-builder}{Service
Builder} tutorials.

The JSF WAR can then rely on the API module as a \emph{provided}
dependency. The main benefit for packaging your services this way is to
allow multiple WARs to utilize the same custom service API without
packaging it inside every WAR's \texttt{WEB-INF/lib} folder. This
practice also enforces a separation of concerns, or \emph{modularity},
between the UI layer and service layer of a system.

To call OSGi-based Service Builder services from your JSF portlet, you
need a mechanism that gives you access to the OSGi service registry,
because you can't look up services published to the OSGi runtime using
Declarative Services. Instead, you should open a
\href{https://osgi.org/javadoc/r6/core/org/osgi/util/tracker/ServiceTracker.html}{ServiceTracker}
when you want to call a service that's in the OSGi service registry.

To implement a service tracker in your JSF portlet, you can add a
type-safe wrapper class that extends
\texttt{org.osgi.util.tracker.ServiceTracker}. For example, this is done
in a demo JSF portlet as follows

\begin{verbatim}
public class UserLocalServiceTracker extends ServiceTracker<UserLocalService, UserLocalService> {

    public UserLocalServiceTracker(BundleContext bundleContext) {
        super(bundleContext, UserLocalService.class, null);
    }
}
\end{verbatim}

After extending the \texttt{ServiceTracker}, just call the constructor
and the service tracker is ready to use in your managed bean.

In a managed bean, whenever you need to call a service, open the service
tracker. For example, this is done in the same demo JSF portlet to open
the service tracker, using the
\href{http://docs.oracle.com/javaee/7/api/javax/annotation/PostConstruct.html}{@PostContruct}
annotation:

\begin{verbatim}
@PostConstruct
public void postConstruct() {
    Bundle bundle = FrameworkUtil.getBundle(this.getClass());
    BundleContext bundleContext = bundle.getBundleContext();
    userLocalServiceTracker = new UserLocalServiceTracker(bundleContext);
    userLocalServiceTracker.open();
}
\end{verbatim}

Then the service can be called:

\begin{verbatim}
UserLocalService userLocalService = userLocalServiceTracker.getService();
...

userLocalService.updateUser(user);
\end{verbatim}

When it's time for the managed bean to go out of scope, you must close
the service tracker using the
\href{http://docs.oracle.com/javaee/7/api/javax/annotation/PreDestroy.html}{@PreDestroy}
annotation:

\begin{verbatim}
@PreDestroy
public void preDestroy() {
    userLocalServiceTracker.close();
}
\end{verbatim}

For more information on service trackers and how to use them in
WAR-style portlets, see the
\href{/docs/7-0/tutorials/-/knowledge_base/t/service-trackers}{Service
Trackers} tutorial.

\subsection{Related Topics}\label{related-topics-32}

\href{/docs/7-0/tutorials/-/knowledge_base/t/fundamentals}{Fundamentals}

\href{/docs/7-0/tutorials/-/knowledge_base/t/internationalization}{Internationalization}

\href{/docs/7-0/tutorials/-/knowledge_base/t/configuration}{Configuration}

\chapter{Making URLs Friendlier}\label{making-urls-friendlier}

This is a story of two URLs who couldn't be more different. One was full
of himself, and always wanted to show everyone (users and SEO services
alike) just how smart he was, by openly displaying all of the parameters
he carried. He was happiest when he met new people and could tell they
were intimidated and confused by him.

\begin{verbatim}
http://localhost:8080/group/guest/~/control_panel/manage?p_p_id=com_liferay_blogs_web_portlet_BlogsAdminPortlet&p_p_lifecycle=0&p_p_state=maximized&p_p_mode=view&_com_liferay_blogs_web_portlet_BlogsAdminPortlet_mvcRenderCommandName=%2Fblogs%2Fedit_entry&_com_liferay_blogs_web_portlet_BlogsAdminPortlet_redirect=http%3A%2F%2Flocalhost%3A8080%2Fgroup%2Fguest%2F~%2Fcontrol_panel%2Fmanage%3Fp_p_id%3Dcom_liferay_blogs_web_portlet_BlogsAdminPortlet%26p_p_lifecycle%3D0%26p_p_state%3Dmaximized%26p_p_mode%3Dview%26_com_liferay_blogs_web_portlet_BlogsAdminPortlet_mvcRenderCommandName%3D%252Fblogs%252Fview%26_com_liferay_blogs_web_portlet_BlogsAdminPortlet_orderBycol%3Dtitle%26_com_liferay_blogs_web_portlet_BlogsAdminPortlet_orderByType%3Dasc%26_com_liferay_blogs_web_portlet_BlogsAdminPortlet_entriesNavigation%3D%26_com_liferay_blogs_web_portlet_BlogsAdminPortlet_cur%3D1%26_com_liferay_blogs_web_portlet_BlogsAdminPortlet_delta%3D20&_com_liferay_blogs_web_portlet_BlogsAdminPortlet_entryId=30836
\end{verbatim}

The other was just, well, friendly. You knew only the important things
about her, because she was less concerned about looking smart, and more
concerned about those she interacted with. She didn't need to look fancy
and complicated. She aspired to be simple and kind to all the users and
SEO services she encountered.

\begin{verbatim}
http://localhost:8080/web/guest/home/-/blogs/lunar-scavenger-hunt
\end{verbatim}

If you want your application to be friendly to your users and to SEO
services, make your URLs friendlier. It only takes a couple steps, after
all.

\section{Creating Friendly URL
Routes}\label{creating-friendly-url-routes}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  First create a \texttt{routes.xml} file in your application's web
  module (if a multi-module build, in the pattern of Liferay's native
  Service Builder applications). It's recommended to put it in a
  \texttt{src/main/resources/META-INF/friendly-url-routes/} folder.
\item
  Add friendly URL routes, using as many
  \texttt{\textless{}route\textgreater{}} tags as you need friendly
  URLs, like this:

\begin{verbatim}
 <?xml version="1.0"?>
 <!DOCTYPE routes PUBLIC "-//Liferay//DTD Friendly URL Routes 7.0.0//EN" "http://www.liferay.com/dtd/liferay-friendly-url-routes_7_0_0.dtd">

 <routes>
     <route>
         <pattern></pattern>
         <implicit-parameter name="mvcRenderCommandName">/blogs/view</implicit-parameter>
         <implicit-parameter name="p_p_lifecycle">0</implicit-parameter>
         <implicit-parameter name="p_p_state">normal</implicit-parameter>
     </route>
     <route>
         <pattern>/maximized</pattern>
         <implicit-parameter name="mvcRenderCommandName">/blogs/view</implicit-parameter>
         <implicit-parameter name="p_p_lifecycle">0</implicit-parameter>
         <implicit-parameter name="p_p_state">maximized</implicit-parameter>
     </route>
     <route>
         <pattern>/{entryId:\d+}</pattern>
         <implicit-parameter name="categoryId"></implicit-parameter>
         <implicit-parameter name="mvcRenderCommandName">/blogs/view_entry</implicit-parameter>
         <implicit-parameter name="p_p_lifecycle">0</implicit-parameter>
         <implicit-parameter name="p_p_state">normal</implicit-parameter>
         <implicit-parameter name="tag"></implicit-parameter>
     </route>
     ...
 </routes>
\end{verbatim}
\end{enumerate}

Use \texttt{\textless{}pattern\textgreater{}} tags to define placeholder
values for the parameters that normally appear in the generated URL.
This is just a mask. The beastly URL still lurks beneath it.

The \texttt{pattern} value \texttt{/\{entryId:\textbackslash{}d+\}}
matches a \texttt{/} followed by an \texttt{entryId} variable that
matches the
\href{https://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html}{Java
regular expression} \texttt{\textbackslash{}d+}---one or more numeric
digits. For example, a URL \texttt{/entryId}, where the \texttt{entryId}
value is \texttt{123} results in a URL value \texttt{/123}, which
matches the pattern.

\noindent\hrulefill

\textbf{Warning:} Make sure your \texttt{pattern} values don't end in a
slash \texttt{/}. A trailing slash character prevents the request from
identifying the correct route.

\noindent\hrulefill

\textbf{Important:} If your portlet is instanceable, you must use a
variant of the \texttt{instanceId} in the \texttt{pattern} value. If the
starting value is \texttt{render-it}, for example, use one of these
patterns:

\begin{verbatim}
<pattern>/{userIdAndInstanceId}/render-it</pattern>
\end{verbatim}

or

\begin{verbatim}
<pattern>/{instanceId}/render-it</pattern>
\end{verbatim}

or

\begin{verbatim}
<pattern>/{p_p_id}/render-it</pattern>
\end{verbatim}

Use \texttt{\textless{}implicit-parameter\textgreater{}} tags to define
parameters that will always be the same for the URL. For example, if
you're dealing with a render URL, you can be certain that the
\texttt{p\_p\_lifecycle} parameter will always be \texttt{0}. There's no
need for this to be generated. You don't have to define these type of
implicit parameters, but it's a best practice. If you happen to forget
one, or decide not to define any of them, they'll just be generated as
usual.

The implicit parameters with the name \texttt{mvcRenderCommandName} are
very important. If you're
\href{/docs/7-0/tutorials/-/knowledge_base/t/mvc-render-command}{using
an \texttt{MVCPortlet} with \texttt{MVCRenderCommand} classes}, that
parameter comes from the \texttt{mvc.command.name} property in the
\texttt{@Component} of your \texttt{MVCRenderCommand} implementation.
Basically, this determines what will be rendered (for example,
\texttt{view.jsp}).

\begin{verbatim}
@Component(
    immediate = true,
    property = {
        "javax.portlet.name=" + BlogsPortletKeys.BLOGS, "mvc.command.name=/",
        "mvc.command.name=/blogs/view"
    },
    service = MVCRenderCommand.class
)
\end{verbatim}

\section{Implementing a Friendly URL
Mapper}\label{implementing-a-friendly-url-mapper}

Once you have your URLs mapped in a \texttt{routes.xml} file, you need
to provide an implementation of the
\href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/FriendlyURLMapper.html}{\texttt{FriendlyURLMapper}
service}. Just create a component that specifies a
\texttt{FriendlyURLMapper} service, with two properties:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  One that sets the path to your \texttt{routes.xml} file in the
  property \texttt{com.liferay.portlet.friendly-url-routes} property.
\item
  A \texttt{javax.portlet.name} property.

\begin{verbatim}
 @Component(
     property = {
         "com.liferay.portlet.friendly-url-routes=META-INF/friendly-url-routes/routes.xml",
         "javax.portlet.name=" + BlogsPortletKeys.BLOGS
     },
     service = FriendlyURLMapper.class
 )
\end{verbatim}
\end{enumerate}

After that, implement the \texttt{FriendlyURLMapper} service. For your
convenience, the
\href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/DefaultFriendlyURLMapper.html}{\texttt{DefaultFriendlyURLMapper}
class} provides a default implementation. If you extend
\texttt{DefaultFriendlyURLMapper} you only need to override one method,
\texttt{getMapping()}. In this method you just need to return a String
that defines the first part of your Friendly URLs. It's smart to name it
after your application. Here's what it looks like for Liferay's Blogs
application:

\begin{verbatim}
public class BlogsFriendlyURLMapper extends DefaultFriendlyURLMapper {

    @Override
    public String getMapping() {
        return _MAPPING;
    }

    private static final String _MAPPING = "blogs";

}
\end{verbatim}

All of the Blogs application's friendly URLs begin with the String set
here (\texttt{blogs}).

\section{Friendly URLs in Action}\label{friendly-urls-in-action}

Let's look at one of these Friendly URLs in action. If you add a blog
entry in Liferay, and then add the Blogs application to a page, click on
the title of the entry to see it. After that, look at the URL:

\begin{verbatim}
http://localhost:8080/web/guest/home/-/blogs/lunar-scavenger-hunt
\end{verbatim}

As specified in the friendly URL mapper class, \texttt{blogs} is the
first part of the friendly URL that comes after the Liferay part of the
URL. The next part is determined by a specific URL route in
\texttt{routes.xml}:

\begin{verbatim}
<route>
    <pattern>/{urlTitle}</pattern>
    <implicit-parameter name="categoryId"></implicit-parameter>
    <implicit-parameter name="mvcRenderCommandName">/blogs/view_entry</implicit-parameter>
    <implicit-parameter name="p_p_lifecycle">0</implicit-parameter>
    <implicit-parameter name="p_p_state">normal</implicit-parameter>
    <implicit-parameter name="tag"></implicit-parameter>
</route>
\end{verbatim}

Here, the \texttt{urlTitle} is a database field that's generated from
the title the author gives their blog post, and it's meant to be used in
a URL. Since it's already a parameter in the URL (see below), it's
available for use in the friendly URL.

\begin{verbatim}
<portlet:renderURL var="viewEntryURL">
    <portlet:param name="mvcRenderCommandName" value="/blogs/view_entry" />
    <portlet:param name="urlTitle" value="<%= entry.getUrlTitle() %>" />
</portlet:renderURL>
\end{verbatim}

When a render URL for viewing a blog entry is invoked, the String
defined in the friendly URL mapper teams up with the \texttt{pattern}
tag in your friendly URL routes file, and you get a very friendly URL
indeed, instead of some nasty, conceited, unfriendly URL that's despised
by users and SEO services alike.

\section{Automatic Single Page
Applications}\label{automatic-single-page-applications}

A good user experience is the measure of a well-designed site. A user's
time is highly valuable. The last thing you want is for someone to grow
frustrated with your site because of constant page reloads. A Single
Page Application (SPA) is the solution. Single Page Applications
drastically cut down on load times by loading only a single HTML page
that is dynamically updated as the user interacts and navigates through
the site. This provides a native-app experience by eliminating page
loads. In Liferay DXP, \textbf{SPA is enabled by default in your apps
and sites and requires no changes to your workflow or code!}

This tutorial covers these key topics:

\begin{itemize}
\tightlist
\item
  The benefits of SPAs
\item
  What is SennaJS?
\item
  How to enable SPA in Liferay DXP
\item
  How to configure SPA settings
\item
  How to listen to SPA lifecycle events
\end{itemize}

\subsection{The Benefits of SPAs}\label{the-benefits-of-spas}

Let's say you're surfing the web and you find a really rad site that
happens to be SPA enabled. Alright! Page load times are blazin' fast.
You're deep into the site, scrolling along, when you find this great
post that just speaks to you. You copy the URL from the address bar and
email it to all of your friends with the subject: `Your Life Will Change
Forever.' They must experience this awe-inspiring work!

You get a response back almost immediately. ``This is a rad site, but
what post are you talking about?'' it reads.

``What!? Do my eyes deceive me?'' you exclaim. You were in so much of a
hurry to share this life-changing content that you neglected to notice
that the URL never updated when you clicked the post. You click the back
button, hoping to get back to the post, but it takes you to the site you
were on before you ever visited this one.

What a bummer! ``Why? Why have you failed me site?'' you cry.

If only there was a way to have a Single Page Application, but also be
able to link to the content you want. Well, don't despair my friend. You
can have your cake and eat it too, thanks to SennaJS.

\subsection{What is SennaJS?}\label{what-is-sennajs}

SennaJS is Liferay DXP's SPA engine. SennaJS handles the client-side
data, and AJAX loads the page's content dynamically. While there are
other JavaScript frameworks out there that may provide some of the same
features, Senna's only focus is SPA, ensuring that your site provides
the best user experience possible.

SennaJS provides the following key enhancements to SPA:

\textbf{SEO \& Bookmarkability}: Sharing or bookmarking a link displays
the same content you are viewing. Search engines are able to index this
content.

\textbf{Hybrid rendering}: Ajax + server-side rendering lets you disable
pushState at any time, allowing progressive enhancement. You can use
your preferred method to render the server side (e.g.~HTML fragments or
template views).

\textbf{State retention}: Scrolling, reloading, or navigating through
the history of the page takes you back to where you were.

\textbf{UI feedback}: The UI indicates to the user when some content is
requested.

\textbf{Pending navigations}: UI rendering is blocked until data is
loaded, and the content is displayed all at once.

\textbf{Timeout detection}: If the request takes too long to load or the
user tries to navigate to a different link while another request is
pending, the request times out.

\textbf{History navigation}: The browser history is manipulated via the
History API, so you can use the back and forward history buttons to
navigate through the history of the page.

\textbf{Cacheable screens}: Once a surface is loaded, the content is
cached in memory and is retrieved later without any additional request,
speeding up your application.

\textbf{Page resources management}: Scripts and stylesheets are
evaluated from dynamically loaded resources. Additional content can be
appended to the DOM using XMLHttpRequest. For security reasons, some
browsers won't evaluate \texttt{\textless{}script\textgreater{}} tags
from content fragments. Therefore, SennaJS extracts scripts from the
content and parses them to ensure that they meet the browser loading
requirements.

You can read more about SennaJS as well as see examples at
\url{http://sennajs.com/}.

Now that you have a better understanding of how SennaJS benefits SPA,
you can learn how to enable and configure options for SPA within Liferay
DXP next.

\subsection{Enabling SPA}\label{enabling-spa}

Enabling SPA is easy. Deploy
\texttt{com.liferay.frontend.js.spa.web-{[}version{]}} module deployed
and enabled, and you're all set to use SPA. Since this module is
included with Liferay DXP by default, you shouldn't have to do anything.

\textbf{SPA is enabled by default in your apps and sites, and requires
no changes to your workflow or existing code!}

Next you can learn how to customize SPA settings to meet your own needs.

\subsection{Customizing SPA Settings}\label{customizing-spa-settings}

Depending on what behaviors you need to customize, you can configure SPA
options in one of two places. SPA caching and SPA timeout settings can
be configured in System Settings. If you wish to disable SPA for a
certain link, page, or portlet in your site, you can do so within the
corresponding element itself. All SPA configuration options are covered
here.

\subsubsection{Configuring SPA System
Settings}\label{configuring-spa-system-settings}

To configure system settings for SPA, follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In the Control Panel, navigate to \emph{Configuration} → \emph{System
  Settings}.
\item
  Select the \emph{Foundation} tab at the top of the page.
\item
  Click \emph{Frontend SPA Infrastructure}.
\end{enumerate}

\noindent\hrulefill

\textbf{Note:} In prior versions of Liferay, all SPA render requests
that didn't belong to a portlet (no \texttt{p\_p\_id} in the URL) were
cached indefinitely. This can confuse users, as the content they view is
cached rather than the latest fresh content. Since Liferay Portal CE 7.0
GA2 and Liferay DXP 7.0 GA1, administrators can use the \textbf{Cache
Expiration Time} property to set an expiration time for the Senna cache.

\noindent\hrulefill

The following configuration options are available:

\textbf{Cache Expiration Time}: The time, in minutes, in which the SPA
cache is cleared. A negative value means the cache should be disabled.

\textbf{Request Timeout Time}: The time, in milliseconds, in which a SPA
request times out. A zero value means the request should never timeout.

\textbf{User Notification Time}: The time, in milliseconds, in which a
notification is shown to the user stating that the request is taking
longer than expected. A zero value means no notification should be
shown.

Now that you know how to configure system settings for SPA, you can
learn how to disable SPA for elements in your site next.

\subsubsection{Disabling SPA}\label{disabling-spa}

Certain elements of your page may require a regular navigation to work
properly. For example, you may have downloadable content that you want
to share with the user. In these cases, SPA must be disabled for those
specific elements.

To disable SPA on a portal wide basis, you can add the following line to
your \texttt{portal-ext.properties}:

\begin{verbatim}
javascript.single.page.application.enabled = false
\end{verbatim}

If there is a portlet or element that you don't want to be part of the
SPA, you have some options:

\begin{itemize}
\tightlist
\item
  Blacklist the portlet to disable SPA for the entire portlet
\item
  Use the \texttt{data-senna-off} annotation to disable SPA for a
  specific form or link
\end{itemize}

To blacklist a portlet from SPA, follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open your portlet class.
\item
  Set the \texttt{com.liferay.portlet.single-page-application} property
  to false:

\begin{verbatim}
 com.liferay.portlet.single-page-application=false
\end{verbatim}

  If you prefer, you can set this property to false in your
  \texttt{liferay-portlet.xml} instead by adding the following property
  to the \texttt{\textless{}portlet\textgreater{}} section:

\begin{verbatim}
 <single-page-application>false</single-page-application>
\end{verbatim}
\item
  Alternatively, you can override the
  \href{@platform-ref@/7.0-latest/javadocs/portal-impl/com/liferay/portal/model/impl/PortletImpl.html\#isSinglePageApplication--}{\texttt{isSinglePageApplication}
  method} of the portlet to return \texttt{false}.
\end{enumerate}

To disable SPA for a form or link follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add the \texttt{data-senna-off} attribute to the element.
\item
  Set the value to \texttt{true}.
\end{enumerate}

For example
\texttt{\textless{}a\ data-senna-off="true"\ href="/pages/page2.html"\textgreater{}Page\ 2\textless{}/a\textgreater{}}

That's all you need to do to disable SPA in your app.

Now that you know how to disable SPA, you can learn how to specify how
resources are loaded during navigation.

\subsubsection{Specifying How Resources Are Loaded During
Navigation}\label{specifying-how-resources-are-loaded-during-navigation}

By default, Liferay DXP unloads CSS resources from the
\texttt{\textless{}head\textgreater{}} element on navigation. JavaScript
resources in the \texttt{\textless{}head\textgreater{}}, however, are
not removed on navigation. This functionality can be customized by
setting the resource's \texttt{data-senna-track} attribute. Follow these
steps to customize your resources:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Select the resource you want to modify the default behavior for.
\item
  Add the \texttt{data-senna-track} attribute to the resource.
\item
  Set the \texttt{data-senna-track} attribute to \texttt{permanent} to
  prevent a resource from unloading on navigation.

  Alternatively, set the \texttt{data-senna-track} attribute to
  \texttt{temporary} to unload the resource on navigation.
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** the `data-senna-track` attribute can be added to resources loaded
 outside of the `<head>` element as well to specify navigation behavior.
\end{verbatim}

\noindent\hrulefill

The example below ensures that the JS resource isn't unloaded during
navigation:

\begin{verbatim}
<script src="myscript.js" data-senna-track="permanent" />
\end{verbatim}

Next you can learn about the available SPA lifecycle events next.

\subsection{Listening to SPA Lifecycle
Events}\label{listening-to-spa-lifecycle-events}

During development, you may need to know when navigation has started or
stopped in your SPA. SennaJS makes this easy by exposing lifecycle
events that represent state changes in the application. The following
events are available:

\textbf{beforeNavigate}: Fires before navigation starts. This event
passes a JSON object with the path to the content being navigated to and
whether to update the history. Below is an example event payload:

\begin{verbatim}
{ path: '/pages/page1.html', replaceHistory: false }
\end{verbatim}

\textbf{startNavigate}: Fires when navigation begins. Below is an
example event payload:

\begin{verbatim}
{ form: '<form name="form"></form>', path: '/pages/page1.html',
replaceHistory: false }
\end{verbatim}

\textbf{endNavigate}: Fired after the content has been retrieved and
inserted onto the page. This event passes the following JSON object:

\begin{verbatim}
{ form: '<form name="form"></form>', path: '/pages/page1.html' }
\end{verbatim}

These events can be leveraged easily by listening for them on the
Liferay global object.

For example, the JavaScript below alerts the user to ``Get ready to
navigate to'' the URL that has been clicked, just before SPA navigation
begins.

\begin{verbatim}
Liferay.on('beforeNavigate', function(event) {
    alert("Get ready to navigate to " + event.path);
});
\end{verbatim}

The alert takes advantage of the payload for the \texttt{beforeNavigate}
event, retrieving the URL from the \texttt{path} attribute of the JSON
payload object.

The above code results in the behavior shown below:

\begin{figure}
\centering
\includegraphics{./images/private-messaging-before-navigate.png}
\caption{You can leverage SPA lifecycle events in your apps.}
\end{figure}

Due to the nature of SPA navigation, global listeners that you create
can become problematic over time if not handled properly. You'll learn
how to handle these listeners next.

\subsection{Detaching Global
Listeners}\label{detaching-global-listeners}

SPA provides several improvements that highly benefit your site and
users, but there is potentially some additional maintenance as a
consequence. In a traditional navigation scenario, every page refresh
resets everything, so you don't have to worry about what's left behind.
In a SPA scenario, however, global listeners such as \texttt{Liferay.on}
or \texttt{Liferay.after} or body delegates can become problematic.
Every time you execute these global listeners, you add yet another
listener to the globally persisted \texttt{Liferay} object. The result
is multiple invocations of those listeners. This can obviously cause
problems if not handled.

To prevent this, you need to listen to the navigation event in order to
detach your listeners. For example, you would use the following code to
detach the event listeners of a global \texttt{category} event:

\begin{verbatim}
var onCategory = function(event) {...};

var clearPortletHandlers = function(event) {
    if (event.portletId === '<%= portletDisplay.getRootPortletId() %>') {
        Liferay.detach('onCategoryHandler', onCategory);
        Liferay.detach('destroyPortlet', clearPortletHandlers);
    }
};


Liferay.on('category', onCategory);
Liferay.on('destroyPortlet', clearPortletHandlers);
\end{verbatim}

Now you know how to configure and use SPA in Liferay DXP!

\subsection{Related Topics}\label{related-topics-33}

\href{/docs/7-0/tutorials/-/knowledge_base/t/configuring-modules-for-products-loaders}{Configuring
Modules for Liferay Portal's Loaders}

\href{/docs/7-0/tutorials/-/knowledge_base/t/preparing-your-javascript-files-for-es2015}{Preparing
your JavaScript Files for ES2015}

\href{/docs/7-0/tutorials/-/knowledge_base/t/using-es2015-modules-in-your-portlet}{Using
ES2015 Modules in Your Portlet}

\section{Creating Layouts inside Custom
Portlets}\label{creating-layouts-inside-custom-portlets}

Page layout tags let you create layouts using Bootstrap 3 within your
portlets.

This tutorial explains the \texttt{\textless{}aui:*\textgreater{}} tags
that developers can use to create layouts.

\subsection{AUI Container}\label{aui-container}

The \texttt{\textless{}aui:container\textgreater{}} tag creates a
container \texttt{\textless{}div\textgreater{}} tag to wrap
\texttt{\textless{}aui:row\textgreater{}} components and offer
additional styling.

It supports the following attributes:

\noindent\hrulefill

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.3333}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Attribute
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Type
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Description
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
cssClass & String & A CSS class for styling the component \\
dynamicAttributes & Map\textless String, Object\textgreater{} & Map of
\texttt{data-} attributes for your container \\
fluid & boolean & Whether to enable the container to span the entire
width of the viewport. The default value is true \\
id & String & An ID for the component instance \\
\end{longtable}

\noindent\hrulefill

\subsection{AUI Row}\label{aui-row}

The \texttt{\textless{}aui:row\textgreater{}} tag creates a row to hold
\texttt{\textless{}aui:col\textgreater{}} components.

It supports the following attributes:

\noindent\hrulefill

\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Attribute & Type & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
cssClass & String & A CSS class for styling the component \\
id & String & An ID for the component instance \\
\end{longtable}

\noindent\hrulefill

\subsection{AUI Col}\label{aui-col}

The \texttt{\textless{}aui:col\textgreater{}} tag creates a column to
display content in an \texttt{\textless{}aui:row\textgreater{}}
component.

It supports the following attributes:

\noindent\hrulefill

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.3333}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Attribute
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Type
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Description
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
cssClass & String & A CSS class for styling the component. \\
id & String & An ID for the component instance. \\
lg & String & Comma separated string of numbers 1-12 to be used for
Boostrap grid \texttt{col-lg-} \\
md & String & Comma separated string of numbers 1-12 to be used for
Boostrap grid \texttt{col-md-} \\
sm & String & Comma separated string of numbers 1-12 to be used for
Boostrap grid \texttt{col-sm-} \\
xs & String & Comma separated string of numbers 1-12 to be used for
Boostrap grid \texttt{col-xs-} \\
span & int & The width of the column in the containing row as a fraction
of 12. For example, a span of 4 would result in a column width 4/12 (or
1/3) of the total width of the containing row. \\
width & int & The width of the column in the containing row as a
percentage, overriding the span attribute. The width is then converted
to a span expressed as ((width/100) x 12), rounded to the nearest whole
number. For example, a width of 33 would be converted to 3.96, which
would be rounded up to a span value of 4. \\
\end{longtable}

\noindent\hrulefill

\subsection{Example JSP}\label{example-jsp}

Below is an example layout created in a portlet:

\begin{verbatim}
<%@ taglib uri="http://liferay.com/tld/aui" prefix="aui" %>

<aui:container cssClass='super-awesome-container'>
        <aui:row>
                <aui:col md="4" sm="6">
                        <h2>Some fun content using the 'md' and 'sm' attributes</h2>
                </aui:col>

                <aui:col md="8" sm="6">
                        <p>
                                Some text here.
                        </p>
                </aui:col>
        </aui:row>

        <aui:row>
                <aui:col width="<%= 40 %>">
                        <h2>Some fun content using the 'width' attribute</h2>
                </aui:col>

                <aui:col width="<%= 60 %>">
                        <p>
                                Cool text here.
                        </p>
                </aui:col>
        </aui:row>

        <aui:row>
                <aui:col span="<%= 4 %>">
                        <h2>Some fun content using the 'span' attribute</h2>
                </aui:col>

                <aui:col span="<%= 8 %>">
                        <p>
                                Nice text here.
                        </p>
                </aui:col>
        </aui:row>
</aui:container>
\end{verbatim}

Now you know how to create layouts inside your portlets!

\subsection{Related Topics}\label{related-topics-34}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-layout-templates-with-the-themes-generator-0}{Layout
Templates with the Liferay Theme Generator}

\chapter{Using JavaScript in Your
Portlets}\label{using-javascript-in-your-portlets}

Would you like to use the latest ECMAScript features in your JavaScript
files and portlets? Do you wish you could use npm and npm packages in
your portlets?

In this section of tutorials you'll learn how to prepare your JavaScript
files to leverage these features in your portlets.

\chapter{Using ES2015 in Your
Portlets}\label{using-es2015-in-your-portlets}

You can now write JavaScript that adheres to the new ECMAScript 2015
(ES2015) syntax, leverage ES2015 advanced features in your modules, and
publish them. To do these things, you need make only minor adjustments
to your JavaScript files and projects.

\noindent\hrulefill

\textbf{Note:} The minifier fails on Liferay DXP 7.0 when JSDoc is
present in a portlet. To resolve this, use
\href{https://gruntjs.com/getting-started}{Grunt}
\href{https://www.npmjs.com/package/grunt-contrib-uglify}{uglify} to
remove the JSDoc comments. This process may take a long time, depending
on the number of files that require an update.

\noindent\hrulefill

This section of tutorials shows how to prepare modules for ES2015 and
use them in your portlets.

\section{Preparing Your JavaScript Files for
ES2015}\label{preparing-your-javascript-files-for-es2015}

To use the ES2015 syntax in a JavaScript file, add the extension
\texttt{.es} to its name. For example, you rename file
\texttt{filename.js} to \texttt{filename.es.js}. The extension indicates
it uses ES2015 syntax and must therefore be transpiled by
\href{https://babeljs.io/}{Babel} before deployment.

ES2015 advanced features, such as
\href{https://babeljs.io/docs/learn-es2015/\#generators}{generators},
are available to you if you import the \texttt{polyfillBabel} class from
the \texttt{polyfill-babel} module found in 7.0:

\begin{verbatim}
import polyfillBabel from 'polyfill-babel'
\end{verbatim}

The \href{http://babeljs.io/docs/usage/polyfill/}{Babel Polyfill}
emulates a complete ES6 environment. Use it at your own discretion, as
it loads a large amount of code. You can inspect
\url{https://github.com/zloirock/core-js\#core-js} to see what's
polyfilled.

Once you've completed writing your module, you can expose it by creating
a \texttt{package.json} file that specifies your bundle's name and
version. Make sure to create this in your module's root folder. The
\href{https://github.com/liferay/liferay-docs/tree/7.0.x/develop/tutorials/code/osgi/modules/js-logger}{js-logger}
module, for example, specifies the following values in its
\texttt{package.json} file:

\begin{verbatim}
{
    "name": "js-logger",
    "version": "1.0.0"
}
\end{verbatim}

The Module Config Generator creates the module based on this
information. There you have it! In just a few steps you can prepare your
module to leverage the latest JavaScript standard features and publish
it.

\subsection{Related Topics}\label{related-topics-35}

\href{/docs/7-0/tutorials/-/knowledge_base/t/using-es2015-modules-in-your-portlet}{Using
ES2015 Modules in Your Portlet}

\href{/docs/7-0/tutorials/-/knowledge_base/t/osgi-and-modularity-for-liferay-6-developers}{OSGi
and Modularity for Liferay Portal 6 Developers}

\section{Using ES2015 Modules in your
Portlet}\label{using-es2015-modules-in-your-portlet}

Once you've
\href{/docs/7-0/tutorials/-/knowledge_base/t/preparing-your-javascript-files-for-es2015}{exposed
your modules} via your \texttt{package.json} file, you can use them in
your portlets. The \texttt{aui:script} tag's \texttt{require} attribute
makes it easy.

This tutorial covers how to access in your portlets the modules you've
exposed. The example module \texttt{logger.es} was written inside the
\href{https://github.com/liferay/liferay-docs/tree/7.0.x/develop/tutorials/code/osgi/modules/console-logger-portlet}{Console
Logger Portlet}. Once the portlet is deployed, and added to a page,
you'll notice a printout in the console.

Follow the steps below to use your exposed modules in your portlets.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Declare the \texttt{aui} taglib in a JSP in your view:

\begin{verbatim}
 <%@ taglib uri="http://liferay.com/tld/aui" prefix="aui" %>
\end{verbatim}

  \textbf{Note:} if you created the portlet using Blade, the
  \texttt{aui} taglib is already provided for you in the
  \texttt{init.jsp}.
\item
  Add an \texttt{aui:script} tag to the JSP and set the \texttt{require}
  attribute to the relative path for your module.

  Since 7.0, the \texttt{require} attribute allows you to include your
  exposed modules in your JSP. The AMD Loader fetches the specified
  module and its dependencies. For example, the Console Logger Portlet's
  \texttt{view.jsp} includes the module \texttt{logger.es}:

\begin{verbatim}
<aui:script require="js-logger/logger.es">
    var Logger = jsLoggerLoggerEs.default;

    var loggerOne = new Logger('*** -> ');
    loggerOne.log('Hello');

    var loggerDefault = new Logger();
    loggerDefault.log('World');
</aui:script>
\end{verbatim}

  References to the module within the script tag are named after the
  \texttt{require} value, in camel-case and with all invalid characters
  removed. The \texttt{logger.es} module's reference
  \texttt{jsLoggerLoggerEs} is derived from the module's relative path
  value \texttt{js-logger/logger.es}. The value is stripped of its dash
  and slash characters and converted to camel case.
\end{enumerate}

Thanks to the \texttt{aui:script} tag and its \texttt{require}
attribute, using your modules in your portlet is a piece of cake!

\subsection{Related Topics}\label{related-topics-36}

\href{/docs/7-0/tutorials/-/knowledge_base/t/overriding-a-modules-jsps}{Overriding
a Module's JSPs}

\href{/docs/7-0/tutorials/-/knowledge_base/t/web-services}{Web Services}

\chapter{Using npm in Your Portlets}\label{using-npm-in-your-portlets}

npm is a powerful tool, and almost a necessity for Front-End
development. Since Liferay DXP 7.0 Fix Pack 30 and Liferay Portal 7.0 CE
GA5, you can use npm as your JavaScript package manager tool---including
npm and npm packages---while developing portlets in your normal,
everyday workflow.

Deployed portlets leverage
\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-amd-module-loader}{Liferay
AMD Loader} to share JavaScript modules and take advantage of semantic
versioning when resolving modules among portlets on the same page. The
liferay-npm-bundler helps prepare your npm modules for the Liferay AMD
Loader.

\noindent\hrulefill

\textbf{Note:} The minifier fails on Liferay DXP 7.0 when JSDoc is
present in a portlet. To resolve this, use
\href{https://gruntjs.com/getting-started}{Grunt}
\href{https://www.npmjs.com/package/grunt-contrib-uglify}{uglify} to
remove the JSDoc comments. This process may take a long time, depending
on the number of files that require an update.

\noindent\hrulefill

This section of tutorials covers how to set up npm-based portlet
projects and how Liferay DXP supports them.

\section{liferay-npm-bundler}\label{liferay-npm-bundler}

The liferay-npm-bundler is a bundler (like
\href{https://webpack.github.io/}{Webpack} or
\href{http://browserify.org/}{Browserify}) that targets Liferay DXP as a
platform and assumes you're using your npm packages from portlets (as
opposed to typical web applications). It is just one of the pieces of
the Liferay JS Bundle Toolkit. Liferay JS Bundle Toolkit is an abstract
umbrella term that refers to the following tools:

\begin{itemize}
\tightlist
\item
  \href{https://github.com/liferay/liferay-npm-build-tools/tree/master/packages/liferay-npm-bundler}{liferay-npm-bundler}
\item
  \href{https://github.com/liferay/liferay-npm-build-tools/tree/master/packages}{Babel
  plugins}
\item
  \href{https://github.com/liferay/liferay-npm-build-tools/tree/master/packages}{liferay-npm-bundler
  plugins}
\item
  \href{https://github.com/liferay/liferay-portal/tree/7.0.x/modules/apps/foundation/frontend-js/frontend-js-loader-modules-extender}{frontend-js-loader-modules-extender}
\item
  \href{https://github.com/liferay/liferay-amd-loader}{Javascript AMD
  loader}
\end{itemize}

\noindent\hrulefill

\textbf{Note:} The Liferay JS Bundle Toolkit is supported for Liferay
DXP 7.0 Fix Pack 39 and up.

\noindent\hrulefill

The workflow for running npm packages inside portlets is slightly
different from standard bundlers. Instead of bundling the JavaScript in
a single file, you must \emph{link} all packages together in the browser
when the full web page is assembled. This lets portlets share common
versions of modules instead of each one loading its own copy. The
liferay-npm-bundler handles this for you. You can learn how it works
next.

\subsection{How it Works Internally}\label{how-it-works-internally}

The liferay-npm-bundler takes a Liferay DXP portlet project and outputs
its files (including npm packages) to a build folder, so the standard
portlet build (Gradle) can produce an OSGi bundle. You can learn more
about the build folder's structure in
\href{/docs/7-0/tutorials/-/knowledge_base/t/the-structure-of-osgi-bundles-containing-npm-packages}{The
Structure of OSGi Bundles Containing NPM Packages} tutorial.

Here's what happens to produce the OSGi bundle:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Copy the project's \texttt{package.json} file to the output directory.
\item
  Traverse the project's dependency tree to determine its dependencies.
\item
  For each npm package dependency:

  \begin{enumerate}
  \def\labelenumii{\alph{enumii}.}
  \item
    Copy the npm package to the output folder and prefix the bundle's
    name to it. Note that the bundler stores packages in plain
    \emph{bundle-name\$package}@\emph{version} format, rather than the
    standard node\_modules tree format).
  \item
    Pre-process the npm package with any configured plugins.
  \item
    Run \href{https://babeljs.io/}{Babel} with configured plugins for
    each \texttt{.js} file inside the npm package.
  \item
    Post-process the npm package with any configured plugins.
  \end{enumerate}
\item
  For the project:

  \begin{enumerate}
  \def\labelenumii{\alph{enumii}.}
  \item
    Pre-process the project's package with any configured plugins.
  \item
    Run \href{https://babeljs.io/}{Babel} with configured plugins for
    each \texttt{.js} file inside the project.
  \item
    Post-process the project package with any configured plugins.
  \end{enumerate}
\end{enumerate}

The only difference between the pre-process and post-process steps are
when they are run (before or after Babel is run, respectively). During
this workflow, liferay-npm-bundler calls all the configured plugins so
they can perform transformations on the npm packages (for instance,
modifying their \texttt{package.json} files, or deleting or moving
files).

Now you understand how the liferay-npm-bundler works!

\subsection{Related Topics}\label{related-topics-37}

\href{/docs/7-0/tutorials/-/knowledge_base/t/the-structure-of-osgi-bundles-containing-npm-packages}{The
Structure of OSGi Bundles Containing NPM Packages}

\href{/docs/7-0/tutorials/-/knowledge_base/t/how-liferay-portal-publishes-npm-packages}{How
Liferay DXP Publishes NPM Packages}

\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-javascript-apis}{Liferay
JavaScript APIs}

\section{Adding liferay-npm-bundler to Your
Portlet}\label{adding-liferay-npm-bundler-to-your-portlet}

Adding liferay-npm-bundler to your portlet involves installing the
package via npm and adding it to your npm build process.

\subsection{Installing
liferay-npm-bundler}\label{installing-liferay-npm-bundler}

\noindent\hrulefill

\textbf{Note:} liferay-npm-bundler 1.x performs aggressive semantic
version resolution, which can potentially lead to unstable results. To
avoid issues, we recommend that you use the latest version of the
bundler (2.x at the time of this writing).

\noindent\hrulefill

Follow these steps to install liferay-npm-bundler:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Install NodeJS \textgreater=
  \href{http://nodejs.org/dist/v6.11.0/}{v6.11.0} if you don't have it
  installed.
\item
  Navigate to your portlet's
  \texttt{src/main/resources/META-INF/resources} folder.

  If you don't have a portlet already, create an empty MVC portlet. For
  convenience, you can use
  \href{/docs/7-0/tutorials/-/knowledge_base/t/installing-blade-cli}{Blade
  CLI} to create an empty portlet with the
  \href{/docs/7-0/reference/-/knowledge_base/r/using-the-mvc-portlet-template}{mvc
  portlet blade template}.
\item
  Run the following command to install the liferay-npm-bundler:

\begin{verbatim}
npm install --save-dev liferay-npm-bundler
\end{verbatim}
\end{enumerate}

\noindent\hrulefill

\textbf{Note:} Use npm from within your portlet project's root folder
(where the \texttt{package.json} file lives), as you normally do on a
typical web project.

\noindent\hrulefill

Now that you have the liferay-npm-bundler installed, you can add it to
your npm build process.

\subsection{Adding liferay-npm-bundler to Your Build
Process}\label{adding-liferay-npm-bundler-to-your-build-process}

Once your source is transpiled (if necessary) to ECMAScript and
converted to AMD format for the
\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-amd-module-loader}{Liferay
AMD Loader}, you must run liferay-npm-bundler in \texttt{package.json}
to pack the needed npm packages and transform them to AMD. This lets
Liferay AMD Loader grab the packages from the Portal.

Add \texttt{liferay-npm-bundler} to your \texttt{package.json}'s build
script:

\begin{verbatim}
"scripts": {
      "build": "[... && ] liferay-npm-bundler"
}
\end{verbatim}

The \texttt{{[}...\&\&{]}} refers to any previous steps you need to
perform (for example, transpiling your sources with Babel).

You can use any languages you like as long as they can be transpiled to
Ecmascript 5 or higher (the only requirement is that Babel can process
it and your browser can execute it). When you deploy your portlet using
Gradle, the build script is called as part of the process.

Now you know how to add the liferay-npm-bundler to your portlet!

\subsection{Related Topics}\label{related-topics-38}

\href{/docs/7-0/tutorials/-/knowledge_base/t/configuring-liferay-npm-bundler}{Configuring
liferay-npm-bundler}

\href{/docs/7-0/tutorials/-/knowledge_base/t/understanding-how-liferay-npm-bundler-formats-javascript-modules-for-amd}{Understanding
How liferay-npm-bundler Formats JavaScript Modules for AMD}

\section{Configuring
liferay-npm-bundler}\label{configuring-liferay-npm-bundler}

The liferay-npm-bundler is configured via a \texttt{.npmbundlerrc} file
placed in the portlet project's root folder. You can create a complete
configuration manually or extend a configuration preset (via Babel).

This tutorial explains the \texttt{.npmbundlerrc} file's structure and
shows how the default preset configures the liferay-npm-bundler.

\subsection{Understanding the .npmbundlerrc File's
Structure}\label{understanding-the-.npmbundlerrc-files-structure}

The \texttt{.npmbundlerrc} file has four possible phase definitions:
\emph{copy-process}, \emph{pre-process}, \emph{post-process}, and
\emph{babel}. These phase definitions are explained in more detail
below:

\textbf{Copy-Process:} Defined with the \texttt{copy-plugins} property
(only available for dependency packages). Specifies which files should
be copied or excluded from each given package.

\textbf{Pre-Process:} Defined with the \texttt{plugins} property.
Specifies plugins to run before the Babel phase is run.

\textbf{Babel:} Defined with the \texttt{.babelrc} definition. Specifies
the \texttt{.babelrc} file to use when running Babel through the
package's \texttt{.js} files.

\noindent\hrulefill

\textbf{Note:} During this phase, Babel transforms package files (for
example, to convert them to AMD format, if necessary), but doesn't
transpile them. In theory, you could also transpile them by configuring
the proper plugins. We recommend transpiling before running the bundler,
to avoid mixing both unrelated processes.

\noindent\hrulefill

\textbf{Post-Process:} Defined with the \texttt{post-plugins} property.
An alternative to using the \emph{pre-process} phase, this specifies
plugins to run after the Babel phase has completed.

Here's an example of a \texttt{.npmbundlerrc} configuration:

\begin{verbatim}
{
    "exclude": {
        "*": [
            "test/**/*"
        ],
        "some-package-name": [
            "test/**/*",
            "bin/**/*"
        ],
        "another-package-name@1.0.10": [
            "test/**/*",
            "bin/**/*",
            "lib/extras-1.0.10.js"
        ]
    },
    "include-dependencies": [
        "isobject", "isarray"
    ],
    "output": "build",
    "process-serially": false,
    "verbose": false,
    "dump-report": true,
    "config": {
        "imports": {
            "npm-angular5-provider": {
                "@angular/common": "^5.0.0",
                "@angular/core": "^5.0.0"
            }
        }
    },
    "/": {
        "plugins": ["resolve-linked-dependencies"],
        ".babelrc": {
            "presets": ["liferay-standard"]
        },
        "post-plugins": [
            "namespace-packages",
            "inject-imports-dependencies"
        ]
    },
    "*": {
        "copy-plugins": ["exclude-imports"],
        "plugins": ["replace-browser-modules"],
        ".babelrc": {
            "presets": ["liferay-standard"]
        },
        "post-plugins": [
            "namespace-packages",
            "inject-imports-dependencies",
            "inject-peer-dependencies"
        ]
    }
    "packages": {
        "a-package-name": [
        "copy-plugins": ["exclude-imports"],
            "plugins": ["replace-browser-modules"],
            ".babelrc": {
                "presets": ["liferay-standard"]
            },
            "post-plugins": [
                "namespace-packages",
                "inject-imports-dependencies",
                "inject-peer-dependencies"
            ]
        ],
        "other-package-name@1.0.10": [
          "copy-plugins": ["exclude-imports"],
            "plugins": ["replace-browser-modules"],
            ".babelrc": {
                "presets": ["liferay-standard"]
            },
            "post-plugins": [
                "namespace-packages",
                "inject-imports-dependencies",
                "inject-peer-dependencies"
            ]
        ]
    }
\end{verbatim}

\noindent\hrulefill

\textbf{Note:} Not all definition formats (\texttt{*},
\texttt{some-package-name}, and \texttt{some-package-name@version})
shown above are required. In most cases, the wildcard definition
(\texttt{*}) is enough. The non-wildcard formats
(\texttt{some-package-name} and \texttt{some-package-name@version}) are
rare exceptions for packages that require a more specific configuration
than the wildcard definition provides.

\noindent\hrulefill

Below are the configuration options for the \texttt{.npmbundlerrc} file:

\emph{exclude:} defines glob expressions of files to exclude from
bundling from all or specific packages.

\emph{include-dependencies:} defines packages to include in bundling,
even if they are not listed under the \texttt{dependencies} section of
\texttt{package.json}. These packages must be available in the
\texttt{node\_modules} folder (i.e.~installed manually, without saving
them to \texttt{package.json}, or listed in the \texttt{devDependencies}
section).

\emph{output:} by default the bundler writes packages to the standard
Gradle resources folder:
\texttt{build/resources/main/META-INF/resources}. Set this value to
override the default output folder.

\emph{process-serially:} Process packages in parallel, leveraging
Node.js asynchronous model, or one by one. The default value is
\texttt{false}, (parallel), but if you get EMFILE errors, you can
disable this.

\emph{verbose:} Sets whether to output detailed information about what
the tool is doing to the commandline.

\emph{dump-report:} Sets whether to generate a debugging report. If
\texttt{true}, an HTML file is generated in the project directory with
information such as what the liferay-npm-bundler is doing with each
package.

\emph{config}: global configuration which is passed to all bundler and
Babel plugins. Please refer to each plugin's documentation to find the
available options for each specific plugin.

\emph{``/''}: plugins' configuration for the project's package.

\emph{``"}: plugins' configuration for dependency packages.

\noindent\hrulefill

\textbf{Note:} Plugins' configuration specifies the options for
configuring plugins in all the possible phases, as well as the
\texttt{.babelrc} file to use when running Babel (see
\href{https://babeljs.io/docs/usage/babelrc/}{Babel's documentation} for
more information on that file format).

\noindent\hrulefill

\noindent\hrulefill

\textbf{Note:} Prior to version 1.4.0 of the liferay-npm-bundler,
package configurations were placed next to the tools options
(\texttt{*}, \texttt{output}, \texttt{exclude}, etc.) To prevent package
name collisions, package configurations are now namespaced and placed
under the \texttt{packages} section. To maintain backwards
compatibility, the liferay-npm-bundler falls back to the root section
outside \texttt{packages} for package configuration, if no package
configurations (\texttt{package-name@version}, \texttt{package-name}, or
\texttt{*}) are found in the \texttt{packages} section.

\noindent\hrulefill

Now that you know the structure of the \texttt{.npmbundlerrc} file, you
can learn about the default configuration preset.

\subsection{How the Default Preset Configures the
liferay-npm-bundler}\label{how-the-default-preset-configures-the-liferay-npm-bundler}

The liferay-npm-bundler comes with a default configuration preset:
\href{https://github.com/liferay/liferay-npm-build-tools/tree/master/packages/liferay-npm-bundler-preset-standard}{\texttt{liferay-npm-bundler-preset-standard}}
in your \texttt{.npmbundlerrc} file. This preset configures several
plugins for the build process and is automatically used (even if the
\texttt{.npmbundlerrc} is missing), unless you override it with one of
your own. Running the liferay-npm-bundler with this preset applies the
\href{https://github.com/liferay/liferay-npm-build-tools/blob/master/packages/liferay-npm-bundler-preset-standard/config.json}{config
file} from \texttt{liferay-npm-bundler-preset-standard}:

\begin{verbatim}
{
    "/": {
        "plugins": ["resolve-linked-dependencies"],
        ".babelrc": {
            "presets": ["liferay-standard"]
        },
        "post-plugins": ["namespace-packages", "inject-imports-dependencies"]
    },
    "*": {
        "copy-plugins": ["exclude-imports"],
        "plugins": ["replace-browser-modules"],
        ".babelrc": {
            "presets": ["liferay-standard"]
        },
        "post-plugins": [
            "namespace-packages",
            "inject-imports-dependencies",
            "inject-peer-dependencies"
        ]
    }
}
\end{verbatim}

\noindent\hrulefill

\textbf{Note:} You can override configuration preset values by adding
your own configuration to your project's \texttt{.npmbundlerrc} file.
For instance, using the configuration preset example above, you can
define your own \texttt{.babelrc} value in \texttt{.npmbundlerrc} file
to override the defined ``liferay-standard'' babelrc preset.

\noindent\hrulefill

The
\href{https://github.com/liferay/liferay-npm-build-tools/tree/master/packages/babel-preset-liferay-standard}{\texttt{liferay-standard}
preset} applies the following plugins to packages:

\begin{itemize}
\item
  \href{https://github.com/liferay/liferay-npm-build-tools/tree/master/packages/liferay-npm-bundler-plugin-exclude-imports}{exclude-imports}:
  Exclude packages declared in the \texttt{imports} section from the
  build.
\item
  \href{https://github.com/liferay/liferay-npm-build-tools/tree/master/packages/liferay-npm-bundler-plugin-inject-imports-dependencies}{inject-imports-dependencies}:
  Inject dependencies declared in the \texttt{imports} section in the
  dependencies' \texttt{package.json} files.
\item
  \href{https://github.com/liferay/liferay-npm-build-tools/tree/master/packages/liferay-npm-bundler-plugin-inject-peer-dependencies}{inject-peer-dependencies}:
  Inject declared peer dependencies (as they are resolved in the
  project's \texttt{node\_modules} folder) in the dependencies'
  \texttt{package.json} files.
\item
  \href{https://github.com/liferay/liferay-npm-build-tools/tree/master/packages/liferay-npm-bundler-plugin-namespace-packages}{namespace-packages}:
  Namespace package names based on the root project's package name to
  isolate packages per project and avoid collisions. This prepends
  \texttt{\textless{}project-package-name\textgreater{}\$} to each
  package name appearance in \texttt{package.json} files.
\item
  \href{https://github.com/liferay/liferay-npm-build-tools/tree/master/packages/liferay-npm-bundler-plugin-replace-browser-modules}{replace-browser-modules}:
  Replace modules listed under
  \texttt{browser}/\texttt{unpkg}/\texttt{jsdelivr} section of
  \texttt{package.json} files.
\item
  \href{https://github.com/liferay/liferay-npm-build-tools/tree/master/packages/liferay-npm-bundler-plugin-resolve-linked-dependencies}{resolve-linked-dependencies}:
  Replace linked dependencies versions appearing in
  \texttt{package.json} files (those obtained from local file system or
  GitHub, for example) by their real version number, as resolved in the
  project's \texttt{node\_modules} directory.
\end{itemize}

In addition, the bundler runs Babel with the
\href{https://github.com/liferay/liferay-npm-build-tools/tree/master/packages/babel-preset-liferay-standard}{babel-preset-liferay-standard}
preset, that invokes the following plugins:

\begin{itemize}
\item
  \href{https://github.com/liferay/liferay-npm-build-tools/tree/master/packages/babel-plugin-name-amd-modules}{babel-plugin-name-amd-modules}:
  Name AMD modules based on package name, version, and module path.
\item
  \href{https://github.com/liferay/liferay-npm-build-tools/tree/master/packages/babel-plugin-namespace-amd-define}{babel-plugin-namespace-amd-define}:
  Add a prefix to AMD \texttt{define()} calls (by default
  \texttt{Liferay.Loader.}).
\item
  \href{https://github.com/liferay/liferay-npm-build-tools/tree/master/packages/babel-plugin-namespace-modules}{babel-plugin-namespace-modules}:
  Namespace modules based on the root project's package name, prepending
  \texttt{\textless{}project-package-name\textgreater{}\$}. Wrap modules
  inside an AMD \texttt{define()} module for each module name appearance
  (in \texttt{define()} or \texttt{require()} calls) so that the
  packages are localized per project and don't clash.
\item
  \href{https://github.com/liferay/liferay-npm-build-tools/tree/master/packages/babel-plugin-normalize-requires}{babel-plugin-normalize-requires}:
  Normalize AMD \texttt{require()} calls.
\item
  \href{https://github.com/liferay/liferay-npm-build-tools/tree/master/packages/babel-plugin-wrap-modules-amd}{babel-plugin-wrap-modules-amd}:
  Wrap modules inside an AMD \texttt{define()} module.
\item
  \href{https://github.com/babel/minify/tree/master/packages/babel-plugin-transform-node-env-inline}{babel-plugin-transform-node-env-inline}:
  Inline the \texttt{NODE\_ENV} environment variable, and if it's part
  of a binary expression (eg.
  \texttt{process.env.NODE\_ENV\ ===\ "development"}), then statically
  evaluate and replace it.
\end{itemize}

Now you know how to configure the liferay-npm-bundler!

\subsection{Related Topics}\label{related-topics-39}

\href{/docs/7-0/tutorials/-/knowledge_base/t/adding-liferay-npm-bundler-to-your-portlet}{Adding
liferay-npm-bundler to Your Portlet}

\href{/docs/7-0/tutorials/-/knowledge_base/t/the-structure-of-osgi-bundles-containing-npm-packages}{The
Structure of OSGi Bundles Containing NPM Packages}

\section{The Structure of OSGi Bundles Containing npm
Packages}\label{the-structure-of-osgi-bundles-containing-npm-packages}

To deploy JavaScript modules, you must create an OSGi bundle with the
npm dependencies extracted from the project's \texttt{node\_modules}
folder and modify them to work with the
\href{https://github.com/liferay/liferay-amd-loader}{Liferay AMD
Loader}. The liferay-npm-bundler automates this process for you,
creating a bundle similar to the one below:

\begin{itemize}
\tightlist
\item
  \texttt{my-bundle/}

  \begin{itemize}
  \tightlist
  \item
    \texttt{META-INF/}

    \begin{itemize}
    \tightlist
    \item
      \texttt{resources/}

      \begin{itemize}
      \tightlist
      \item
        \texttt{package.json}

        \begin{itemize}
        \tightlist
        \item
          name: my-bundle-package
        \item
          version: 1.0.0
        \item
          main: lib/index
        \item
          dependencies:

          \begin{itemize}
          \tightlist
          \item
            my-bundle-package\$isarray: 2.0.0
          \item
            my-bundle-package\$isobject: 2.1.0
          \end{itemize}
        \item
          \ldots{}
        \end{itemize}
      \item
        \texttt{lib/}

        \begin{itemize}
        \tightlist
        \item
          \texttt{index.js}
        \item
          \ldots{}
        \end{itemize}
      \item
        \ldots{}
      \item
        \texttt{node\_modules/}

        \begin{itemize}
        \tightlist
        \item
          \texttt{my-bundle-package\$isobject@2.1.0/}

          \begin{itemize}
          \tightlist
          \item
            \texttt{package.json}

            \begin{itemize}
            \tightlist
            \item
              name: my-bundle-package\$isobject
            \item
              version: 2.1.0
            \item
              main: lib/index
            \item
              dependencies:

              \begin{itemize}
              \tightlist
              \item
                my-bundle-package\$isarray: 1.0.0
              \end{itemize}
            \item
              \ldots{}
            \end{itemize}
          \item
            \ldots{}
          \end{itemize}
        \item
          \texttt{my-bundle-package\$isarray@1.0.0/}

          \begin{itemize}
          \tightlist
          \item
            \texttt{package.json}

            \begin{itemize}
            \tightlist
            \item
              name: my-bundle-package\$isarray
            \item
              version: 1.0.0
            \item
              \ldots{}
            \end{itemize}
          \item
            \ldots{}
          \end{itemize}
        \item
          \texttt{my-bundle-package\$isarray@2.0.0/}

          \begin{itemize}
          \tightlist
          \item
            \texttt{package.json}

            \begin{itemize}
            \tightlist
            \item
              name: my-bundle-package\$isarray
            \item
              version: 2.0.0
            \item
              \ldots{}
            \end{itemize}
          \item
            \ldots{}
          \end{itemize}
        \end{itemize}
      \end{itemize}
    \end{itemize}
  \end{itemize}
\end{itemize}

The packages inside \texttt{node\_modules} are the same format as the
npm tool and can be copied (after a little processing for things like
converting to AMD, for example) from a standard \texttt{node\_modules}
folder. The \texttt{node\_modules} folder can hold any number of npm
packages (even different versions of the same package), or no npm
packages at all.

Now that you know the structure for OSGi bundles containing npm
packages, you can learn how the liferay-npm-bundler handles inline
JavaScript packages.

\subsection{Inline JavaScript
packages}\label{inline-javascript-packages}

The resulting OSGi bundle that the liferay-npm-bundler creates lets you
deploy one inline JavaScript package (named \texttt{my-bundle-package}
in the example) with several npm packages that are placed inside the
\texttt{node\_modules} folder, one package per folder.

The inline package is nested in the OSGi standard
\texttt{META-INF/resources} folder and is defined by a standard npm
\texttt{package.json} file.

The inline package is optional, but only one inline package is allowed
per OSGi bundle. The inline package usually provides the JavaScript code
for a portlet, when the OSGi bundle contains one. Note that the
architecture does not differentiate between inline and npm packages once
they are published. The inline package is only used for organizational
purposes.

Now you know the liferay-npm-bundler creates OSGi bundles for npm
packages!

\subsection{Related Topics}\label{related-topics-40}

\href{/docs/7-0/tutorials/-/knowledge_base/t/configuring-liferay-npm-bundler}{Configuring
liferay-npm-bundler}

\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-npm-bundler}{liferay-npm-bundler}

\href{/docs/7-0/tutorials/-/knowledge_base/t/adding-liferay-npm-bundler-to-your-portlet}{Adding
liferay-npm-bundler to Your Portlet}

\section{Understanding How liferay-npm-bundler Formats JavaScript
Modules for
AMD}\label{understanding-how-liferay-npm-bundler-formats-javascript-modules-for-amd}

Liferay AMD Loader is based on the
\href{https://github.com/amdjs/amdjs-api/wiki/AMD}{AMD specification}.
All modules inside an npm OSGi bundle must be in AMD format. This is
done for \href{http://www.commonjs.org/}{CommonJS} modules by wrapping
the module code inside a \texttt{define} call. The liferay-npm-bundler
helps automate this process by wrapping the module for you. This
tutorial references the OSGi structure below as an example. You can
learn more about this structure in
\href{/docs/7-0/tutorials/-/knowledge_base/t/the-structure-of-osgi-bundles-containing-npm-packages}{The
Structure of OSGi Bundles Containing NPM Packages} tutorial.

\begin{itemize}
\tightlist
\item
  \texttt{my-bundle/}

  \begin{itemize}
  \tightlist
  \item
    \texttt{META-INF/}

    \begin{itemize}
    \tightlist
    \item
      \texttt{resources/}

      \begin{itemize}
      \tightlist
      \item
        \texttt{package.json}

        \begin{itemize}
        \tightlist
        \item
          name: my-bundle-package
        \item
          version: 1.0.0
        \item
          main: lib/index
        \item
          dependencies:

          \begin{itemize}
          \tightlist
          \item
            my-bundle-package\$isarray: 2.0.0
          \item
            my-bundle-package\$isobject: 2.1.0
          \end{itemize}
        \item
          \ldots{}
        \end{itemize}
      \item
        \texttt{lib/}

        \begin{itemize}
        \tightlist
        \item
          \texttt{index.js}
        \item
          \ldots{}
        \end{itemize}
      \item
        \ldots{}
      \item
        \texttt{node\_modules/}

        \begin{itemize}
        \tightlist
        \item
          \texttt{my-bundle-package\$isobject@2.1.0/}

          \begin{itemize}
          \tightlist
          \item
            \texttt{package.json}

            \begin{itemize}
            \tightlist
            \item
              name: my-bundle-package\$isobject
            \item
              version: 2.1.0
            \item
              main: lib/index
            \item
              dependencies:

              \begin{itemize}
              \tightlist
              \item
                my-bundle-package\$isarray: 1.0.0
              \end{itemize}
            \item
              \ldots{}
            \end{itemize}
          \item
            \ldots{}
          \end{itemize}
        \item
          \texttt{my-bundle-package\$isarray@1.0.0/}

          \begin{itemize}
          \tightlist
          \item
            \texttt{package.json}

            \begin{itemize}
            \tightlist
            \item
              name: my-bundle-package\$isarray
            \item
              version: 1.0.0
            \item
              \ldots{}
            \end{itemize}
          \item
            \ldots{}
          \end{itemize}
        \item
          \texttt{my-bundle-package\$isarray@2.0.0/}

          \begin{itemize}
          \tightlist
          \item
            \texttt{package.json}

            \begin{itemize}
            \tightlist
            \item
              name: my-bundle-package\$isarray
            \item
              version: 2.0.0
            \item
              \ldots{}
            \end{itemize}
          \item
            \ldots{}
          \end{itemize}
        \end{itemize}
      \end{itemize}
    \end{itemize}
  \end{itemize}
\end{itemize}

For example, the \texttt{my-bundle-package\$isobject@2.1.0} package's
\texttt{index.js} file contains the following code:

\begin{verbatim}
'use strict';

var isArray = require('my-bundle-package$isarray');

module.exports = function isObject(val) {
    return val != null && typeof val === 'object' && isArray(val) === false;
};
\end{verbatim}

The updated module code configured for AMD format is shown below:

\begin{verbatim}
define(
    'my-bundle-package$isobject@2.1.0/index', 
    ['module', 'require', 'my-bundle-package$isarray'], 
    function (module, require) {
        'use strict';

        var define = undefined;

        var isArray = require('my-bundle-package$isarray');

        module.exports = function isObject(val) {
            return val != null && typeof val === 'object' 
            && isArray(val) === false;
        };
    }
);
\end{verbatim}

\noindent\hrulefill

\textbf{Note:} The module's name must be based on its package, version,
and file path (for example
\texttt{my-bundle-package\$isobject@2.1.0/index}), otherwise Liferay AMD
Loader can't find it.

\noindent\hrulefill

Note the module's dependencies:
\texttt{{[}\textquotesingle{}module\textquotesingle{},\ \textquotesingle{}require\textquotesingle{},\ \textquotesingle{}my-bundle-package\$isarray\textquotesingle{}{]}}.

\texttt{module} and \texttt{require} must be used to get a reference to
the \texttt{module.exports} object and the local \texttt{require}
function, as defined in the AMD specification.

The subsequent dependencies state the modules on which this module
depends. Note that \texttt{my-bundle-package\$isarray} in the example is
not a package but rather an alias of the
\texttt{my-bundle-package\$isarray} package's main module (thus, it is
equivalent to \texttt{my-bundle-package\$isarray/index}).

Also note that there is enough information in the \texttt{package.json}
files to know that \texttt{my-bundle-package\$isarray} refers to
\texttt{my-bundle-package\$isarray/index}, but also that it must be
resolved to version \texttt{1.0.0} of such package, i.e., that
\texttt{my-bundle-package\$isarray/index} in this case refers to
\texttt{my-bundle-package\$isarray@1.0.0/index}.

You may also have noted the \texttt{var\ define\ =\ undefined;} addition
to the top of the file. This is introduced by
\texttt{liferay-npm-bundler} to make the module think that it is inside
a CommonJS environment (instead of an AMD one). This is because some npm
packages are written in UMD format and, because we are wrapping it
inside our AMD \texttt{define()} call, we don't want them to execute
their own \texttt{define()} but prefer them to take the CommonJS path,
where the exports are done through the \texttt{module.exports} global.

You can leverage liferay-npm-bundler with the correct presets to process
your npm modules for AMD. All liferay-npm-bundler presets
(\emph{liferay-npm-bundler-preset-}) found in the
\href{https://github.com/liferay/liferay-npm-build-tools/tree/1.x/packages}{liferay-npm-build-tools}
repository include some or all of the following Babel plugins to
accomplish the AMD conversion:

\begin{itemize}
\item
  \href{https://github.com/liferay/liferay-npm-build-tools/tree/1.x/packages/babel-plugin-wrap-modules-amd}{babel-plugin-wrap-modules-amd}
\item
  \href{https://github.com/liferay/liferay-npm-build-tools/tree/1.x/packages/babel-plugin-name-amd-modules}{babel-plugin-name-amd-modules}
\item
  \href{https://github.com/liferay/liferay-npm-build-tools/tree/1.x/packages/babel-plugin-namespace-amd-define}{Babel-plugin-namespace-amd-define}
\end{itemize}

Now you have a better understanding of how liferay-npm-bundler formats
JavaScript modules for AMD!

\subsection{Related Topics}\label{related-topics-41}

\href{/docs/7-0/tutorials/-/knowledge_base/t/how-liferay-portal-publishes-npm-packages}{How
Liferay DXP Publishes NPM Packages}

\href{/docs/7-0/tutorials/-/knowledge_base/t/configuring-liferay-npm-bundler}{Configuring
liferay-npm-bundler}

\section{How Liferay DXP Publishes npm
Packages}\label{how-liferay-dxp-publishes-npm-packages}

When you deploy an OSGi bundle with the specified structure, as
explained in
\href{/docs/7-0/tutorials/-/knowledge_base/t/the-structure-of-osgi-bundles-containing-npm-packages}{The
Structure of OSGi Bundles Containing NPM Packages} tutorial, its modules
are made available for consumption through canonical URLs. To better
illustrate resolved modules, the example structure below is the standard
structure that the liferay-npm-bundler 1.x generates, and therefore
doesn't have the namespaced packages that the 2.x version generates.
Please refer to the last sections of this tutorial to know how
liferay-npm-bundler 2.0 overrides this de-duplication mechanism to
implement isolated dependencies and imports.

\begin{itemize}
\tightlist
\item
  \texttt{my-bundle/}

  \begin{itemize}
  \tightlist
  \item
    \texttt{META-INF/}

    \begin{itemize}
    \tightlist
    \item
      \texttt{resources/}

      \begin{itemize}
      \tightlist
      \item
        \texttt{package.json}

        \begin{itemize}
        \tightlist
        \item
          name: my-bundle-package
        \item
          version: 1.0.0
        \item
          main: lib/index
        \item
          dependencies:

          \begin{itemize}
          \tightlist
          \item
            isarray: 2.0.0
          \item
            isobject: 2.1.0
          \end{itemize}
        \item
          \ldots{}
        \end{itemize}
      \item
        \texttt{lib/}

        \begin{itemize}
        \tightlist
        \item
          \texttt{index.js}
        \item
          \ldots{}
        \end{itemize}
      \item
        \ldots{}
      \item
        \texttt{node\_modules/}

        \begin{itemize}
        \tightlist
        \item
          \texttt{isobject@2.1.0/}

          \begin{itemize}
          \tightlist
          \item
            \texttt{package.json}

            \begin{itemize}
            \tightlist
            \item
              name: isobject
            \item
              version: 2.1.0
            \item
              main: lib/index
            \item
              dependencies:

              \begin{itemize}
              \tightlist
              \item
                isarray: 1.0.0
              \end{itemize}
            \item
              \ldots{}
            \end{itemize}
          \item
            \ldots{}
          \end{itemize}
        \item
          \texttt{isarray@1.0.0/}

          \begin{itemize}
          \tightlist
          \item
            \texttt{package.json}

            \begin{itemize}
            \tightlist
            \item
              name: isarray
            \item
              version: 1.0.0
            \item
              \ldots{}
            \end{itemize}
          \item
            \ldots{}
          \end{itemize}
        \item
          \texttt{isarray@2.0.0/}

          \begin{itemize}
          \tightlist
          \item
            \texttt{package.json}

            \begin{itemize}
            \tightlist
            \item
              name: isarray
            \item
              version: 2.0.0
            \item
              \ldots{}
            \end{itemize}
          \item
            \ldots{}
          \end{itemize}
        \end{itemize}
      \end{itemize}
    \end{itemize}
  \end{itemize}
\end{itemize}

If you deploy the example OSGi bundle shown above, the following URLs
are made available (one for each module):

\begin{itemize}
\item
  \url{http://localhost/o/js/module/598/my-bundle-package@1.0.0/lib/index.js}
\item
  \url{http://localhost/o/js/module/598/isobject@2.1.0/index.js}
\item
  \url{http://localhost/o/js/module/598/isarray@1.0.0/index.js}
\item
  \url{http://localhost/o/js/module/598/isarray@2.0.0/index.js}
\end{itemize}

\noindent\hrulefill

\textbf{NOTE:} The OSGi bundle ID (598) may vary.

\noindent\hrulefill

You can learn about package de-duplication next.

\subsection{Package De-duplication}\label{package-de-duplication}

Since two or more OSGi modules may export multiple copies of the same
package and version, Liferay Portal must de-duplicate such collisions.
To accomplish de-duplication, a new concept called resolved module was
created.

A resolved module is the reference package exported to Liferay Portal's
front-end, when multiple copies of the same package and version exist.
It's randomly referenced from one of the several bundles exporting the
same copies of the package.

Using the example from the previous section, for each group of canonical
URLs referring to the same module inside different OSGi bundles, there's
another canonical URL for the resolved module. The example structure has
the resolved module URLs shown below:

\begin{itemize}
\item
  \url{http://localhost/o/js/resolved-module/my-bundle-package@1.0.0/lib/index.js}
\item
  {[}http://localhost/o/js/resolved-module/my-bundle-package\(isobject@2.1.0/index.js](http://localhost/o/js/resolved-module/my-bundle-package\)isobject@2.1.0/index.js)
\item
  {[}http://localhost/o/js/resolved-module/my-bundle-package\(isarray@1.0.0/index.js](http://localhost/o/js/resolved-module/my-bundle-package\)isarray@1.0.0/index.js)
\item
  {[}http://localhost/o/js/resolved-module/my-bundle-package\(isarray@2.0.0/index.js](http://localhost/o/js/resolved-module/my-bundle-package\)isarray@2.0.0/index.js)
\end{itemize}

\noindent\hrulefill

\textbf{NOTE:} The OSGi bundle ID (598 in the example) is removed and
module is replaced by \texttt{resolved-module}.

\noindent\hrulefill

Next you can learn how the bundler (since version 2.0.0) isolates
package dependencies. See
\href{/docs/7-0/reference/-/knowledge_base/r/changes-between-liferay-npm-bundler-1-and-2}{What
Changed Between liferay-npm-bundler 1.x and 2.x} for more information on
why this change was made.

\subsection{Isolated Package
Dependencies}\label{isolated-package-dependencies}

A typical OSGi bundle structure generated with liferay-npm-bundler 2.x
is shown below:

\begin{itemize}
\tightlist
\item
  \texttt{my-bundle/}

  \begin{itemize}
  \tightlist
  \item
    \texttt{META-INF/}

    \begin{itemize}
    \tightlist
    \item
      \texttt{resources/}

      \begin{itemize}
      \tightlist
      \item
        \texttt{package.json}

        \begin{itemize}
        \tightlist
        \item
          name: my-bundle-package
        \item
          version: 1.0.0
        \item
          main: lib/index
        \item
          dependencies:

          \begin{itemize}
          \tightlist
          \item
            my-bundle-package\$isarray: 2.0.0
          \item
            my-bundle-package\$isobject: 2.1.0
          \end{itemize}
        \item
          \ldots{}
        \end{itemize}
      \item
        \texttt{lib/}

        \begin{itemize}
        \tightlist
        \item
          \texttt{index.js}
        \item
          \ldots{}
        \end{itemize}
      \item
        \ldots{}
      \item
        \texttt{node\_modules/}

        \begin{itemize}
        \tightlist
        \item
          \texttt{my-bundle-package\$isobject@2.1.0/}

          \begin{itemize}
          \tightlist
          \item
            \texttt{package.json}

            \begin{itemize}
            \tightlist
            \item
              name: my-bundle-package\$isobject
            \item
              version: 2.1.0
            \item
              main: lib/index
            \item
              dependencies:

              \begin{itemize}
              \tightlist
              \item
                my-bundle-package\$isarray: 1.0.0
              \end{itemize}
            \item
              \ldots{}
            \end{itemize}
          \item
            \ldots{}
          \end{itemize}
        \item
          \texttt{my-bundle-package\$isarray@1.0.0/}

          \begin{itemize}
          \tightlist
          \item
            \texttt{package.json}

            \begin{itemize}
            \tightlist
            \item
              name: my-bundle-package\$isarray
            \item
              version: 1.0.0
            \item
              \ldots{}
            \end{itemize}
          \item
            \ldots{}
          \end{itemize}
        \item
          \texttt{my-bundle-package\$isarray@2.0.0/}

          \begin{itemize}
          \tightlist
          \item
            \texttt{package.json}

            \begin{itemize}
            \tightlist
            \item
              name: my-bundle-package\$isarray
            \item
              version: 2.0.0
            \item
              \ldots{}
            \end{itemize}
          \item
            \ldots{}
          \end{itemize}
        \end{itemize}
      \end{itemize}
    \end{itemize}
  \end{itemize}
\end{itemize}

Note that each package dependency is namespaced with the bundle's name
(\texttt{my-bundle-package\$} in the example structure). This lets each
project load its own dependencies and avoid potential collisions with
projects that export the same package. For example, consider the two
portlet projects below:

\begin{verbatim}
- `my-portlet`
    - package.json
        - dependencies:
            - a-library 1.0.0
            - a-helper 1.0.0
    - node_modules
        - a-library
            - version: 1.0.0
            - dependencies:
                - a-helper ^1.0.0
        - a-helper
            - version: 1.0.0

- `another-portlet`
    - package.json
        - dependencies:
            - a-library 1.0.0
            - a-helper 1.2.0
    - node_modules
        - a-library
            - version: 1.0.0
            - dependencies:
                - a-helper ^1.0.0
        - a-helper
            - version: 1.2.0
\end{verbatim}

In this example, \texttt{a-library} depends on \texttt{a-helper} at
version 1.0.0 or higher (note the caret \^{} expression in the
dependencies). The bundler implements isolated dependencies by prefixing
the name of the bundle to the modules, so that \texttt{my-portlet} gets
its \texttt{a-helper} at 1.0.0, while \texttt{another-portlet} gets its
\texttt{a-helper} at 1.2.0.

The dependencies isolation not only avoids collisions between bundles,
but also makes peer dependencies behave deterministically as each
portlet gets what it had in its \texttt{node\_modules} folder when it
was developed.

Now that you understand how namespacing modules isolates bundle
dependencies, avoiding collisions, you can learn about de-duplication
next.

\subsection{De-duplication through
Importing}\label{de-duplication-through-importing}

Isolated dependencies are very useful, but there are times when sharing
the same package between modules would be more beneficial. To do this,
the liferay-npm-bundler lets you import packages from an external OSGi
bundle, instead of using your own. This lets you put shared dependencies
in one project and reference them from the rest.

Imagine that you have three portlets that compose the homepage of your
site: \texttt{my-toolbar}, \texttt{my-menu}, and \texttt{my-content}.
These portlets depend on the fake, but awesome, Wonderful UI Components
(WUI) framework. This quite limited framework is composed of only three
packages:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \texttt{component-core}
\item
  \texttt{button}
\item
  \texttt{textfield}
\end{enumerate}

Since the bundler namespaces each dependency package with the portlet's
name by default, you would end up with three namespaced copies of the
WUI package on the page. This is not what you want. Since they share the
same package, instead you can create a fourth bundle that contains the
WUI package, and import the WUI package in the three portlets. This
results in the structure below:

\begin{itemize}
\tightlist
\item
  \texttt{my-toolbar/}

  \begin{itemize}
  \tightlist
  \item
    \texttt{.npmbundlerrc}

    \begin{itemize}
    \tightlist
    \item
      config:

      \begin{itemize}
      \tightlist
      \item
        imports:

        \begin{itemize}
        \tightlist
        \item
          wui-provider:

          \begin{itemize}
          \tightlist
          \item
            component-core: \^{}1.0.0
          \item
            button: \^{}1.0.0
          \item
            textfield: \^{}1.0.0
          \end{itemize}
        \end{itemize}
      \end{itemize}
    \end{itemize}
  \end{itemize}
\item
  \texttt{my-menu/}

  \begin{itemize}
  \tightlist
  \item
    \texttt{.npmbundlerrc}

    \begin{itemize}
    \tightlist
    \item
      config:

      \begin{itemize}
      \tightlist
      \item
        imports:

        \begin{itemize}
        \tightlist
        \item
          wui-provider:

          \begin{itemize}
          \tightlist
          \item
            component-core: \^{}1.0.0
          \item
            button: \^{}1.0.0
          \item
            textfield: \^{}1.0.0
          \end{itemize}
        \end{itemize}
      \end{itemize}
    \end{itemize}
  \end{itemize}
\item
  \texttt{my-content/}

  \begin{itemize}
  \tightlist
  \item
    \texttt{.npmbundlerrc}

    \begin{itemize}
    \tightlist
    \item
      config:

      \begin{itemize}
      \tightlist
      \item
        imports:

        \begin{itemize}
        \tightlist
        \item
          wui-provider:

          \begin{itemize}
          \tightlist
          \item
            component-core: \^{}1.0.0
          \item
            button: \^{}1.0.0
          \item
            textfield: \^{}1.0.0
          \end{itemize}
        \end{itemize}
      \end{itemize}
    \end{itemize}
  \end{itemize}
\item
  \texttt{wui-provider/}

  \begin{itemize}
  \tightlist
  \item
    \texttt{.package.json}

    \begin{itemize}
    \tightlist
    \item
      name: wui-provider
    \item
      dependencies:

      \begin{itemize}
      \tightlist
      \item
        component-core: 1.0.0
      \item
        button: 1.0.0
      \item
        textfield: 1.0.0
      \end{itemize}
    \end{itemize}
  \end{itemize}
\end{itemize}

The bundler switches the namespace of certain packages, thus pointing
them to an external bundle. Say that you have the following code in
\texttt{my-toolbar} portlet:

\begin{verbatim}
var Button = require('button');
\end{verbatim}

By default, the bundler 2.x transforms this into the following when not
imported from another bundle:

\begin{verbatim}
var Button = require('my-toolbar$button');
\end{verbatim}

But, because \texttt{button} is imported from \texttt{wui-provider}, it
is instead changed to the value below:

\begin{verbatim}
var Button = require('wui-provider$button');
\end{verbatim}

Also, a dependency on \texttt{wui-provider\$button} at version
\texttt{\^{}1.0.0} is included in \texttt{my-toolbar}'s
\texttt{package.json} file so that the loader finds the correct version.
That's all you need. Once \texttt{wui-provider\$button} is required at
runtime, it jumps to \texttt{wui-provider}'s context and loads the
subdependencies from there on, even if code is executed from
\texttt{my-toolbar}. This works because, as you can imagine,
\texttt{wui-provider}'s modules are namespaced too, and once you load a
module from it, it keeps requiring \texttt{wui-provider\$} prefixed
modules all the way down.

Next, you will learn possible strategies for importing.

\subsection{Strategies When Importing
Packages}\label{strategies-when-importing-packages}

De-duplication by importing is a powerful tool, but you must design a
versioning strategy suitable for you so that you don't run into errors.

First of all, you must decide if you want to declare imported
dependencies only in the \texttt{.npmbundlerrc} file or in the
\texttt{package.json} too. Listing an imported dependency in
\texttt{.npmbundlerrc} is enough, even if it isn't present in your
\texttt{node\_modules} folder because during runtime the loader will
find it. Listing an imported dependency in \texttt{.npmbundlerrc} is
enough, even if it isn't present in your \texttt{node\_modules} folder,
because during runtime the loader finds it. If you have previous
experience with dynamic linking support in standard operating systems,
think of it as a DLL or shared object.

You may need to install your dependencies in \texttt{node\_modules} too
if you use them for tests, or if they contain types needed to compile
(like in Typescript), etc. If that is the case, then you can place them
in the \texttt{dependencies} or \texttt{devDependencies} section of your
\texttt{package.json}. If you list them under the latter, they are
automatically excluded from the output bundle by the
liferay-npm-bundler. Otherwise, you need to exclude them in the
\texttt{.npmbundlerrc} file so they don't redundantly appear in the
output.

If you list dependencies both in \texttt{package.json} and
\texttt{.npmbundlerrc}, decide how to keep versions in sync. The best
advice is to use the same version constraints in both files, but you may
decide not to do so if it is necessary. For example, imagine that you
import one of your dependencies from another bundle during runtime to
run tests. Say you are using version constraint \^{}1.5.1. It would be
desirable that if you have tested your code with a version
\textgreater=1.5.1 and \textless2.0.0 (that's what \^{}1.5.1 means), you
get a compatible version during runtime. Thus, you would declare the
dependency with \^{}1.5.1 in \texttt{.npmbundlerrc} too.

However, there are times when you may want to be more lenient, and you
may need to get a lower version (1.4.0 for example) during runtime, even
if you are developing against \^{}1.5.1. In that case, you can declare
\^{}1.5.1 in your \texttt{package.json} and \^{}1.0.0 in
\texttt{.npmbundlerrc}.

In the end, it's up to you to decide how you want to handle your
dependencies:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \texttt{package.json} (While developing)
\item
  \texttt{.npmbundlerrc} (During runtime)
\end{enumerate}

we recommend that you choose a versioning strategy and stick to it, to
ensure dependencies are satisfied at runtime.

Now you know how Liferay DXP publishes npm packages!

\subsection{Related Topics}\label{related-topics-42}

\href{/docs/7-0/tutorials/-/knowledge_base/t/understanding-how-liferay-npm-bundler-formats-javascript-modules-for-amd}{Understanding
How liferay-npm-bundler Formats JavaScript Modules for AMD}

\href{/docs/7-0/tutorials/-/knowledge_base/t/how-liferay-portal-exposes-configuration-for-amd}{Understanding
How Liferay DXP Exposes Configuration for Liferay AMD Loader}

\section{Understanding How Liferay DXP Exposes Configuration For Liferay
AMD
Loader}\label{understanding-how-liferay-dxp-exposes-configuration-for-liferay-amd-loader}

\textbf{NOTE:} This tutorial is for users who know how Liferay AMD
Loader works under the hood. You can learn more about Liferay AMD Loader
in the
\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-amd-module-loader}{Liferay
AMD Module Loader} tutorial.

With
\href{/docs/7-0/tutorials/-/knowledge_base/t/how-liferay-portal-publishes-npm-packages\#package-de-duplication}{de-duplication}
in place, JavaScript modules are made available to Liferay AMD Loader
through the configuration returned by the
\texttt{/o/js\_loaded\_modules} URL.

The OSGi bundle shown below is used for reference in this tutorial:

\begin{itemize}
\tightlist
\item
  \texttt{my-bundle/}

  \begin{itemize}
  \tightlist
  \item
    \texttt{META-INF/}

    \begin{itemize}
    \tightlist
    \item
      \texttt{resources/}

      \begin{itemize}
      \tightlist
      \item
        \texttt{package.json}

        \begin{itemize}
        \tightlist
        \item
          name: my-bundle-package
        \item
          version: 1.0.0
        \item
          main: lib/index
        \item
          dependencies:

          \begin{itemize}
          \tightlist
          \item
            isarray: 2.0.0
          \item
            isobject: 2.1.0
          \end{itemize}
        \item
          \ldots{}
        \end{itemize}
      \item
        \texttt{lib/}

        \begin{itemize}
        \tightlist
        \item
          \texttt{index.js}
        \item
          \ldots{}
        \end{itemize}
      \item
        \ldots{}
      \item
        \texttt{node\_modules/}

        \begin{itemize}
        \tightlist
        \item
          \texttt{isobject@2.1.0/}

          \begin{itemize}
          \tightlist
          \item
            \texttt{package.json}

            \begin{itemize}
            \tightlist
            \item
              name: isobject
            \item
              version: 2.1.0
            \item
              main: lib/index
            \item
              dependencies:

              \begin{itemize}
              \tightlist
              \item
                isarray: 1.0.0
              \end{itemize}
            \item
              \ldots{}
            \end{itemize}
          \item
            \ldots{}
          \end{itemize}
        \item
          \texttt{isarray@1.0.0/}

          \begin{itemize}
          \tightlist
          \item
            \texttt{package.json}

            \begin{itemize}
            \tightlist
            \item
              name: isarray
            \item
              version: 1.0.0
            \item
              \ldots{}
            \end{itemize}
          \item
            \ldots{}
          \end{itemize}
        \item
          \texttt{isarray@2.0.0/}

          \begin{itemize}
          \tightlist
          \item
            \texttt{package.json}

            \begin{itemize}
            \tightlist
            \item
              name: isarray
            \item
              version: 2.0.0
            \item
              \ldots{}
            \end{itemize}
          \item
            \ldots{}
          \end{itemize}
        \end{itemize}
      \end{itemize}
    \end{itemize}
  \end{itemize}
\end{itemize}

For example, for the specified structure (shown above), as explained in
\href{/docs/7-0/tutorials/-/knowledge_base/t/the-structure-of-osgi-bundles-containing-npm-packages}{The
Structure of OSGi Bundles Containing npm Packages} tutorial, the
following configuration is published for Liferay AMD loader to consume:

\begin{verbatim}
Liferay.PATHS = {
  ...
  'my-bundle-package@1.0.0/lib/index': '/o/js/resolved-module/my-bundle-package@1.0.0/lib/index',
  'isobject@2.1.0/index': '/o/js/resolved-module/isobject@2.1.0/index',
  'isarray@1.0.0/index': '/o/js/resolved-module/isarray@1.0.0/index',
  'isarray@2.0.0/index': '/o/js/resolved-module/isarray@2.0.0/index',
  ...
}
Liferay.MODULES = {
  ...
  "my-bundle-package@1.0.0/lib/index.es": {
    "dependencies": ["exports", "isarray", "isobject"],
    "map": {
      "isarray": "isarray@2.0.0", 
      "isobject": "isobject@2.1.0"
    }
  },
  "isobject@2.1.0/index": {
    "dependencies": ["module", "require", "isarray"],
    "map": {
      "isarray": "isarray@1.0.0"
    }
  },
  "isarray@1.0.0/index": {
    "dependencies": ["module", "require"],
    "map": {}
  },
  "isarray@2.0.0/index": {
    "dependencies": ["module", "require"],
    "map": {}
  },
  ...
}
Liferay.MAPS = {
  ...
  'my-bundle-package@1.0.0': { value: 'my-bundle-package@1.0.0/lib/index', exactMatch: true}
  'isobject@2.1.0': { value: 'isobject@2.1.0/index', exactMatch: true},
  'isarray@2.0.0': { value: 'isarray@2.0.0/index', exactMatch: true},
  'isarray@1.0.0': { value: 'isarray@1.0.0/index', exactMatch: true},
  ...
}
\end{verbatim}

Note:

\begin{itemize}
\item
  The \texttt{Liferay.PATHS} property describes paths to the JavaScript
  module files.
\item
  The \texttt{Liferay.MODULES} property describes the dependency names
  and versions of each module.
\item
  The \texttt{Liferay.MAPS} property describes the aliases of the
  package's main modules.
\end{itemize}

Now you know how Liferay DXP exposes configuration for Liferay AMD
Loader!

\section{Related Topics}\label{related-topics-43}

\href{/docs/7-0/tutorials/-/knowledge_base/t/how-liferay-portal-publishes-npm-packages}{How
Liferay DXP Publishes npm Packages}

\href{/docs/7-0/tutorials/-/knowledge_base/t/understanding-how-liferay-npm-bundler-formats-javascript-modules-for-amd}{Understanding
How liferay-npm-bundler Formats JavaScript Modules for AMD}

\chapter{Using the NPMResolver API in Your
Portlets}\label{using-the-npmresolver-api-in-your-portlets}

If you're developing an npm-based portlet, your OSGi bundle's
\texttt{package.json} is a treasure-trove of information. It contains
everything that's stored in the npm registry about your bundle: default
entry point, dependencies, modules, package names, versions, and more.
Since Liferay DXP 7.0 Fix Pack 37 and Liferay Portal 7.0 CE GA6, Liferay
DXP's
\href{@app-ref@/foundation/latest/javadocs/com/liferay/frontend/js/loader/modules/extender/npm/NPMResolver.html}{\texttt{NPMResolver}
APIs} expose this information so you can access it in your portlet. If
it's defined in the OSGi bundle's \texttt{package.json}, you can
retrieve the information in your portlet with the \texttt{NPMResolver}
API. For instance, you can use this API to
\href{/docs/7-0/tutorials/-/knowledge_base/t/obtaining-dependency-npm-package-descriptors}{reference
an npm package's static resources} (such as CSS files) and even to
\href{/docs/7-0/tutorials/-/knowledge_base/t/obtaining-dependency-npm-package-descriptors}{make
your code more maintainable}.

To enable the \texttt{NPMResolver} in your portlet, use the
\texttt{@Reference} annotation to inject the \texttt{NPMResolver} OSGi
component into your portlet's Component class, as shown below:

\begin{verbatim}
import com.liferay.frontend.js.loader.modules.extender.npm.NPMResolver;

public class MyPortlet extends MVCPortlet {
  
  @Reference
  private NPMResolver `_npmResolver`;
  
}
\end{verbatim}

\noindent\hrulefill

\textbf{Note:} Because the \texttt{NPMResolver} reference is tied
directly to the OSGi bundle's \texttt{package.json} file, it can only be
used to retrieve npm module and package information from that file. You
can't use the \texttt{NPMResolver} to retrieve npm package information
for other OSGi bundles.

\noindent\hrulefill

Now that the \texttt{NPMResolver} is added to your portlet, the
tutorials in this section describe retrieving your OSGi bundle's npm
package and module information.

\section{Referencing an npm Module's Package to Improve Code
Maintenance}\label{referencing-an-npm-modules-package-to-improve-code-maintenance}

Once you've
\href{/docs/7-0/tutorials/-/knowledge_base/t/preparing-your-javascript-files-for-es2015}{exposed
your modules}, you can use them in your portlet via the
\texttt{aui:script} tag's \texttt{require} attribute. By default,
Liferay DXP automatically composes an npm module's JavaScript variable
based on its name. For example, the module \texttt{my-package@1.0.0}
translates to the variable \texttt{myPackage100} for the
\texttt{\textless{}aui:script\textgreater{}} tag's \texttt{require}
attribute. This means that each time a new version of the OSGi bundle's
npm package is released, you must update your code's variable to reflect
the new version. You can use the
\href{@app-ref@/foundation/latest/javadocs/com/liferay/frontend/js/loader/modules/extender/npm/JSPackage.html}{\texttt{JSPackage}
interface} to obtain the module's package name and create an alias to
reference it, so the variable name always reflects the latest version
number!

Follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Retrieve a reference to the OSGi bundle's npm package using the
  \href{@app-ref@/foundation/latest/javadocs/com/liferay/frontend/js/loader/modules/extender/npm/NPMResolver.html\#getJSPackage}{\texttt{getJSPackage()}
  method}:

\begin{verbatim}
JSPackage jsPackage = _npmResolver.getJSPackage();
\end{verbatim}
\item
  Grab the npm package's resolved ID (the current package version, in
  the format
  \texttt{\textless{}package\ name\textgreater{}@\textless{}version\textgreater{}},
  defined in the OSGi module's \texttt{package.json}) using the
  \href{@app-ref@/foundation/latest/javadocs/com/liferay/frontend/js/loader/modules/extender/npm/JSPackage.html\#getResolvedId}{\texttt{getResolvedId()}
  method} and alias it with the \texttt{as\ myVariableName} pattern. The
  example below retrieves the npm module's resolved ID, sets it to the
  \texttt{bootstrapRequire} variable, and assigns the entire value to
  the attribute \texttt{bootstrapRequire}. This ensures that the package
  version is always up to date:

\begin{verbatim}
renderRequest.setAttribute(
  "bootstrapRequire",
  jsPackage.getResolvedId() + " as bootstrapRequire");
\end{verbatim}
\item
  Include the reference to the
  \href{@app-ref@/foundation/latest/javadocs/com/liferay/frontend/js/loader/modules/extender/npm/NPMResolver.html}{\texttt{NPMResolver}}:

\begin{verbatim}
@Reference
private NPMResolver _npmResolver;
\end{verbatim}
\item
  Resolve the \texttt{JSPackage} and \texttt{NPMResolver} imports:

\begin{verbatim}
import com.liferay.frontend.js.loader.modules.extender.npm.JSPackage;
import com.liferay.frontend.js.loader.modules.extender.npm.NPMResolver;
\end{verbatim}
\item
  In the portlet's JSP, retrieve the aliased attribute
  (\texttt{bootstrapRequire} in the example):

\begin{verbatim}
<%
String bootstrapRequire =
    (String)renderRequest.getAttribute("bootstrapRequire");
%>
\end{verbatim}
\item
  Finally, use the attribute as the
  \texttt{\textless{}aui:script\textgreater{}} require attribute's
  value:

\begin{verbatim}
<aui:script require="<%= bootstrapRequire %>">
    bootstrapRequire.default();
</aui:script>
\end{verbatim}
\end{enumerate}

Below is the full example \texttt{*Portlet} class:

\begin{verbatim}
public class MyPortlet extends MVCPortlet {
    
    @Override
    public void doView(
            RenderRequest renderRequest, RenderResponse renderResponse)
        throws IOException, PortletException {

        JSPackage jsPackage = _npmResolver.getJSPackage();

        renderRequest.setAttribute(
            "bootstrapRequire",
            jsPackage.getResolvedId() + " as bootstrapRequire");

        super.doView(renderRequest, renderResponse);
    }
    
    @Reference
    private NPMResolver _npmResolver;
    
}
\end{verbatim}

And here is the corresponding example \texttt{view.jsp}:

\begin{verbatim}
<%
String bootstrapRequire =
  (String)renderRequest.getAttribute("bootstrapRequire");
%>

<aui:script require="<%= bootstrapRequire %>">
  bootstrapRequire.default();
</aui:script>
\end{verbatim}

Now you know how to reference an npm module's package!

\subsection{Related Topics}\label{related-topics-44}

\href{/docs/7-0/tutorials/-/knowledge_base/t/obtaining-dependency-npm-package-descriptors}{Obtaining
an OSGi bundle's Dependency npm Package Descriptors}

\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-npm-bundler}{liferay-npm-bundler}

\href{/docs/7-0/tutorials/-/knowledge_base/t/how-liferay-portal-publishes-npm-packages}{How
Liferay DXP Publishes npm Packages}

\section{Obtaining an OSGi bundle's Dependency npm Package
Descriptors}\label{obtaining-an-osgi-bundles-dependency-npm-package-descriptors}

While writing your npm portlet, you may need to reference a dependency
package or its modules. For instance, you can retrieve an npm dependency
package module's CSS file and use it in your portlet. The
\href{@app-ref@/foundation/latest/javadocs/com/liferay/frontend/js/loader/modules/extender/npm/NPMResolver.html}{\texttt{NPMResolver}
OSGi component} provides two methods for retrieving an OSGi bundle's
dependency npm package descriptors:
\href{@app-ref@/foundation/latest/javadocs/com/liferay/frontend/js/loader/modules/extender/npm/NPMResolver.html\#getDependencyJSPackage}{\texttt{getDependencyJSPackage()}}
to retrieve dependency npm packages and
\href{@app-ref@/foundation/latest/javadocs/com/liferay/frontend/js/loader/modules/extender/npm/NPMResolver.html\#resolveModuleName}{\texttt{resolveModuleName()}}
to retrieve dependency npm modules. This tutorial references the
\texttt{package.json} below to help demonstrate these methods:

\begin{verbatim}
{
    "dependencies": {
        "react": "15.6.2",
        "react-dom": "15.6.2"
    },
    .
    .
    .
}
\end{verbatim}

To obtain an OSGi bundle's npm dependency package, pass the package's
name in as the \texttt{getDependencyJSPackage()} method's argument. The
example below resolves the \texttt{react} dependency package:

\begin{verbatim}
String reactResolvedId = npmResolver.getDependencyJSPackage("react");
\end{verbatim}

\texttt{reactResolvedId}'s resulting value is \texttt{react@15.6.2}.

You can use the \texttt{resolveModuleName()} method To obtain a module
in an npm dependency package. To do this, pass the module's relative
path in as the \texttt{resolveModuleName()} method's argument. The
example below resolves a module named \texttt{react-with-addons} for the
\texttt{react} dependency package:

\begin{verbatim}
String resolvedModule = 
npmResolver.resolveModuleName("react/dist/react-with-addons");
\end{verbatim}

The \texttt{resolvedModule} variable evaluates to
\texttt{react@15.6.2/dist/react-with-addons}. You can also use this to
reference static resources inside npm packages (like CSS or image
files), as shown in the example below:

\begin{verbatim}
String cssPath = npmResolver.resolveModuleName(
      "react/lib/css/main.css"); 
\end{verbatim}

Now you know how to obtain an OSGi bundle's dependency npm packages
descriptors!

\subsection{Related Topics}\label{related-topics-45}

\href{/docs/7-0/tutorials/-/knowledge_base/t/obtaining-dependency-npm-package-descriptors}{Obtaining
an OSGi bundle's npm Package Descriptors}

\href{/docs/7-0/tutorials/-/knowledge_base/t/the-structure-of-osgi-bundles-containing-npm-packages}{The
Structure of OSGi Bundles Containing npm Packages}

\href{/docs/7-0/tutorials/-/knowledge_base/t/how-liferay-portal-publishes-npm-packages}{How
Liferay DXP Publishes npm Packages}

\chapter{Applying Lexicon Styles to your
App}\label{applying-lexicon-styles-to-your-app}

It's important to have a consistent user experience across your apps.
Liferay DXP's built-in apps achieve this through Liferay's
\href{https://v1.lexicondesign.io/}{Lexicon Experience Language} and its
web implementation, \href{https://lexiconcss.wedeploy.io/}{Lexicon}.

Lexicon provides a consistent, user-friendly UI for Liferay DXP apps,
and is included in all themes that are based on the \texttt{\_styled}
base theme, making all the components documented on the
\href{https://lexiconcss.wedeploy.io/}{Lexicon site} accessible.

This means you can use Lexicon markup and components in your Liferay DXP
apps. These tutorials explain how to apply Lexicon's design patterns to
achieve the same look and feel as Liferay DXP's built-in apps.

The tutorials in this section cover the following topics:

\begin{itemize}
\tightlist
\item
  Configuring your portlet title and back link
\item
  Applying Lexicon patterns to your forms, navigation, and more
\item
  Using the Add Button pattern
\item
  Implementing the Management Bar
\item
  Configuring your admin app's actions menu
\item
  Setting search container animations
\item
  Using Lexicon icons in your app
\end{itemize}

\section{Configuring Your Application's Title and Back
Link}\label{configuring-your-applications-title-and-back-link}

For 7.0 administration applications, the title should be moved to the
inner views of the app and the associated back link should be moved to
the portlet titles.

If you open the Blogs Admin application in the Control Panel and add a
new blog entry, you'll see this behavior in action:

\begin{figure}
\centering
\includegraphics{./images/new-blog-entry-title.png}
\caption{Adding a new blog entry displays the portlet title at the top,
along with a back link.}
\end{figure}

This tutorial uses the Blogs Admin application's
\href{https://github.com/liferay/liferay-portal/blob/b74496b5c450c134957347e7ebabd25dec1c763d/modules/apps/collaboration/blogs/blogs-web/src/main/resources/META-INF/resources/blogs/edit_entry.jsp}{\texttt{edit\_entry.jsp}}
as an example.

Follow these steps to configure your app's title and back URL:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Use \texttt{ParamUtil} to retrieve the redirect for the URL:

\begin{verbatim}
String redirect = ParamUtil.getString(request, "redirect");
\end{verbatim}
\item
  Display the back icon and set the back URL to the \texttt{redirect}:

\begin{verbatim}
portletDisplay.setShowBackIcon(true);
portletDisplay.setURLBack(redirect);
\end{verbatim}
\item
  Finally, set the title using the \texttt{renderResponse.setTitle()}
  method, as shown in the example configuration below:

\begin{verbatim}
renderResponse.setTitle((entry != null) ? entry.getTitle() : 
LanguageUtil.get(request, "new-blog-entry"));
%>
\end{verbatim}
\end{enumerate}

The example above provides a title for two scenarios:

\begin{itemize}
\tightlist
\item
  If an existing blog entry is being updated, the blog's title is
  displayed.
\item
  Otherwise it defaults to \emph{New Blog Entry} since a new blog entry
  is being created.
\end{itemize}

You should also update any back links in the view to use the
\texttt{redirect}. For example the \texttt{edit\_entry.jsp} form's
cancel button redirects the user:

\begin{verbatim}
<aui:button cssClass="btn-lg" href="<%= redirect %>" name="cancelButton" 
type="cancel" />
\end{verbatim}

Now you know how to configure your app's title and back URL!

\subsection{Related topics}\label{related-topics-46}

\href{/docs/7-0/tutorials/-/knowledge_base/t/applying-lexicon-patterns-to-forms-navigation-and-search}{Applying
Lexicon Patterns to your Forms, Navigation, and Search}

\href{/docs/7-0/tutorials/-/knowledge_base/t/setting-search-container-animations}{Setting
Search Container Animations}

\section{Applying Lexicon Patterns to Your Forms, Navigation, and
Search}\label{applying-lexicon-patterns-to-your-forms-navigation-and-search}

This tutorial covers how to leverage Lexicon patterns in your app's
forms, navigation, and search results to make them more user-friendly.

You can learn how to update your navigation next.

\subsection{Applying Lexicon to the Navigation
Bar}\label{applying-lexicon-to-the-navigation-bar}

All administration apps in 7.0 have a navigation bar. Applying Lexicon
to your existing navigation bar takes only one additional attribute.

If your app already has a navigation bar implemented with the
\href{@platform-ref@/7.0-latest/taglibs/util-taglib/aui/nav-bar.html}{\texttt{aui:nav-bar}}
tag, you can reuse it by adding the attribute
\texttt{markupView="lexicon"}.

For example,
\href{https://github.com/liferay/liferay-portal/blob/7.0.x/modules/apps/web-experience/trash/trash-web/src/main/resources/META-INF/resources/navigation.jsp}{Liferay's
Trash app} has the configuration below:

\begin{verbatim}
<aui:nav-bar cssClass="collapse-basic-search" markupView="lexicon">
\end{verbatim}

\noindent\hrulefill

\textbf{Note:} The \texttt{markupView="lexicon"} attribute ensures that
the Lexicon markup is used for the UI components, rather than the
standard markup. This attribute tells the app to use the
\texttt{lexicon} folder in the taglib to render the HTML, rather than
the default rendering. For example,
\texttt{\textless{}aui:fieldset\ markupView="lexicon"\ /\textgreater{}}
renders the HTML using
\texttt{/portal/portal-web/docroot/html/taglib/aui/fieldset/lexicon/}
instead of the \texttt{end.jsp} and \texttt{start.jsp} files in
\texttt{/portal/portal-web/docroot/html/taglib/aui/fieldset/}.

\noindent\hrulefill

Alternatively, you can use non-bordered tabs with the
\texttt{liferay-ui:tabs} taglib as the
\href{https://lexicondesign.io/docs/patterns/nav\%20tabs.html}{Lexicon
Guidelines} state.

Sweet! Now you know how to style a navigation bar with Lexicon. Next,
you'll learn how to apply Lexicon to your forms.

\subsection{Applying Lexicon Patterns to the Application
Body}\label{applying-lexicon-patterns-to-the-application-body}

To ensure that your application uses all available screen real state
from left to right, make the application body fluid in all portlet
views. This helps provide a consistent user-experience across all app
views.

To make your app's content fluid, add the \texttt{container-fluid-1280}
class in a \texttt{\textless{}div\textgreater{}} (or equivalent) element
that contains all the portlet's content (excluding the Nav Bar and
Management Bar).

If your app's view (or views) are already contained within a
\texttt{\textless{}div\textgreater{}} element, add the
\texttt{container-fluid-1280} class to it. Otherwise add an uppermost
\texttt{\textless{}div\textgreater{}} element for this purpose:

\begin{verbatim}
<div class="container-fluid-1280">
...
</div>
\end{verbatim}

Next, you can learn how to apply Lexicon to your forms.

\subsection{Improving your Forms with
Lexicon}\label{improving-your-forms-with-lexicon}

Follow these steps to apply Lexicon to your forms:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Encapsulate your \texttt{fieldset}s with the following taglib:

\begin{verbatim}
<aui:fieldset-group markupView="lexicon">

</aui:fieldset-group>
\end{verbatim}
\item
  The \texttt{fieldset} inside \texttt{fieldset-group} should be
  collapsible, so you can hide it when it's not being used. Add the
  \texttt{collapsed} and \texttt{collapsible} attributes to your
  \texttt{aui:fieldset} taglib:

\begin{verbatim}
<aui:fieldset collapsed="<%= true %>" collapsible="<%= true %>"
label="permissions">
      ...
</aui:fieldset>
\end{verbatim}
\item
  Finally, add the \texttt{btn-lg} CSS class to your form's buttons to
  increase the click area:

\begin{verbatim}
<aui:button-row>

    <aui:button cssClass="btn-lg" type="submit" />

    <aui:button cssClass="btn-lg" href="<%= redirect %>"
    type="cancel" />

</aui:button-row>
\end{verbatim}
\end{enumerate}

Your forms are now configured to use Lexicon! Next, you can learn how to
apply Lexicon to the Actions menu for your entities.

\subsection{Applying Lexicon to Your Entity's Actions
Menus}\label{applying-lexicon-to-your-entitys-actions-menus}

Your Actions menus can also benefit from Lexicon patterns. Learn how to
apply Lexicon patterns to your Admin app's actions in the
\href{/docs/7-0/tutorials/-/knowledge_base/t/configuring-your-admin-apps-actions-menu}{Configuring
Your Admin app's Actions Menu} tutorial. For regular apps, follow these
steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open your module's actions JSP (\texttt{guestbook\_actions.jsp} for
  example) and update the
  \texttt{\textless{}liferay-ui:icon-menu\textgreater{}} to use
  Lexicon's markup with the \texttt{markupView} attribute:

\begin{verbatim}
<liferay-ui:icon-menu
    direction="left-side"
    icon="<%= StringPool.BLANK %>"
    markupView="lexicon"
    message="<%= StringPool.BLANK %>"
    showWhenSingleIcon="<%= true %>"
>
\end{verbatim}
\item
  To follow the Lexicon guidelines, the Actions menu should only display
  an icon if it is one action. If the Actions menu contains multiple
  actions, remove the icon's \texttt{image} attribute and replace it
  with the \texttt{message} attribute displaying the action's title.
  Below is an example configuration:

\begin{verbatim}
<liferay-ui:icon
    message="Edit"
    url="<%= editURL.toString() %>"
/>
\end{verbatim}
\end{enumerate}

Next you can update your search iterator.

\subsection{Applying Lexicon to your Search
iterator}\label{applying-lexicon-to-your-search-iterator}

To apply Lexicon to your search iterator, add the
\texttt{markupView="lexicon"} attribute:

\begin{verbatim}
<liferay-ui:search-iterator

    displayStyle="<%= displayStyle %>"
    markupView="lexicon"
    searchContainer="<%= searchContainer %>"
/>
\end{verbatim}

The \texttt{displayStyle} attribute specifies which display style is set
for the management bar. You can learn how to configure display styles in
the
\href{/docs/7-0/tutorials/-/knowledge_base/t/implementing-the-management-bar-display-styles}{Implementing
Management Bar Display Styles} tutorial.

If the results contain different sets of entries (folders and documents,
categories and threads, etc.), you must use a class that implements
\texttt{*ResultRowSplitter} to divide the results. This is covered next.

\subsubsection{Creating a Result Row
Splitter}\label{creating-a-result-row-splitter}

Classes that implement the \texttt{*ResultRowSplitter} class divide and
categorize the results based on the different entry types. Follow these
steps to create a result row splitter:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a Java class that implements the
  \href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/dao/search/ResultRowSplitter.html}{\texttt{ResultRowSplitter}
  interface}. For example, the \texttt{com.liferay.bookmarks.web} module
  has the following \texttt{BookmarksResultRowSplitter} class to split
  its folder and bookmark results:

  public class BookmarksResultRowSplitter implements ResultRowSplitter
  \{
\item
  Override the \texttt{split()} method:

\begin{verbatim}
    @Override
    public List<ResultRowSplitterEntry> split(List<ResultRow> resultRows) {
        List<ResultRowSplitterEntry> resultRowSplitterEntries =
            new ArrayList<>();
\end{verbatim}
\item
  Create an \texttt{ArrayList} for each type of entity, as shown in the
  example below:

\begin{verbatim}
        List<ResultRow> entryResultRows = new ArrayList<>();
        List<ResultRow> folderResultRows = new ArrayList<>();
\end{verbatim}
\item
  Loop through the results and add your entities to the proper
  \texttt{ArrayList}:

\begin{verbatim}
        for (ResultRow resultRow : resultRows) {
            Object object = resultRow.getObject();

            if (object instanceof BookmarksFolder) {
                folderResultRows.add(resultRow);
            }
            else {
                entryResultRows.add(resultRow);
            }
    }
\end{verbatim}
\item
  Create a new \texttt{ResultRowSplitterEntry} for each entity, passing
  the name of the entity and the ArrayList:

\begin{verbatim}
    if (!folderResultRows.isEmpty()) {
        resultRowSplitterEntries.add(
            new ResultRowSplitterEntry("folders", folderResultRows));
    }

    if (!entryResultRows.isEmpty()) {
        resultRowSplitterEntries.add(
            new ResultRowSplitterEntry("bookmarks", entryResultRows));
    }
\end{verbatim}
\item
  Return the List of \texttt{resultRowSplitter} Entries.
\item
  Use the \texttt{resultRowSplitter} attribute in your
  \texttt{liferay-ui:search-iterator} taglib to create a new instance of
  your \texttt{*ResultRowSplitter} as shown in the example below:

\begin{verbatim}
<liferay-ui:search-iterator
    displayStyle="<%= displayStyle %>"
    markupView="lexicon"
    resultRowSplitter="<%= new BookmarksResultRowSplitter() %>"
    searchContainer="<%= bookmarksSearchContainer %>"
/>
\end{verbatim}
\end{enumerate}

Now you know how to apply Lexicon patterns to your app's forms,
navigation, and search results!

\subsection{Related topics}\label{related-topics-47}

\href{/docs/7-0/tutorials/-/knowledge_base/t/configuring-your-applications-title-and-back-link}{Configuring
Your Application's Title and Back Link}

\href{/docs/7-0/tutorials/-/knowledge_base/t/using-lexicon-icons-in-your-app}{Using
Lexicon Icons in Your App}

\section{Applying the Add Button
Pattern}\label{applying-the-add-button-pattern}

Lexicon's add button pattern is for actions that add entities (for
example a new blog entry button): it gives you a clean, minimal UI. You
can use it in any of your app's screens. The add button pattern consists
of an
\href{@platform-ref@/7.0-latest/taglibs/modules/apps/foundation/com.liferay.frontend.taglib/com.liferay.frontend.taglib/liferay-frontend/add-menu.html}{\texttt{add-menu}
tag} and at least one
\href{@platform-ref@/7.0-latest/taglibs/modules/apps/foundation/com.liferay.frontend.taglib/com.liferay.frontend.taglib/liferay-frontend/add-menu-item.html}{\texttt{add-menu-item}
tag}.

\begin{figure}
\centering
\includegraphics{./images/add-button-diagram.png}
\caption{The add button pattern consists of an \texttt{add-menu} tag and
at least one \texttt{add-menu-item} tag.}
\end{figure}

If there's only one item, the plus icon acts as a button that triggers
the item. If there's more than one item, clicking the plus icon displays
a menu containing them.

Add a \texttt{\textless{}liferay-frontend:add-menu-item\textgreater{}}
tag for every menu item you have. Here's an example of the add button
pattern with a single item:

\begin{verbatim}
<liferay-frontend:add-menu>
    <liferay-frontend:add-menu-item title='<%= LanguageUtil.get(request,
    "titleName") %>' url="<%= nameURL.toString() %>" />
</liferay-frontend:add-menu>
\end{verbatim}

You can also find the add button pattern in Liferay DXP's built-in apps.
For example, the
\href{https://github.com/liferay/liferay-portal/blob/7.0.x/modules/apps/collaboration/message-boards/message-boards-web/src/main/resources/META-INF/resources/message_boards_admin/add_button.jsp}{Message
Boards Admin application} uses the following add button pattern:

\begin{verbatim}
<liferay-frontend:add-menu>
    ...
    <liferay-frontend:add-menu-item title='<%= LanguageUtil.get(request,
    "thread") %>' url="<%= addMessageURL.toString() %>" />
    ...
    <liferay-frontend:add-menu-item title='<%= LanguageUtil.get(request,
    (categoryId == MBCategoryConstants.DEFAULT_PARENT_CATEGORY_ID) ?
    "category[message-board]" : "subcategory[message-board]") %>'
    url="<%= addCategoryURL.toString() %>" />
    ...
</liferay-frontend:add-menu>
\end{verbatim}

There you have it! Now you know how to use the add button pattern.

\subsection{Related Topics}\label{related-topics-48}

\href{/docs/7-0/tutorials/-/knowledge_base/t/setting-search-container-animations}{Setting
Search Container Animations}

\href{/docs/7-0/tutorials/-/knowledge_base/t/adding-the-management-bar}{Adding
the Management Bar}

\chapter{Adding the Management Bar}\label{adding-the-management-bar}

The Management Bar controls display options for search container
results. You can use it to display content in a list or a grid, or to
display a specific type of content. You can also customize your app's
Management Bar.

\begin{figure}
\centering
\includegraphics{./images/message-boards-management-bar.png}
\caption{The Management Bar lets the user customize how the app displays
content.}
\end{figure}

The Management Bar is divided into a few key sections. Each section is
grouped and configured using different taglibs:

The
\href{@platform-ref@/7.0-latest/taglibs/modules/apps/foundation/com.liferay.frontend.taglib/com.liferay.frontend.taglib/liferay-frontend/management-bar-buttons.html}{\texttt{\textless{}liferay-frontend:management-bar-buttons\textgreater{}}
tag} wraps the Management Bar's button elements:

\begin{figure}
\centering
\includegraphics{./images/management-bar-buttons.png}
\caption{The \texttt{management-bar-buttons} tag contains the Management
Bar's main buttons.}
\end{figure}

The
\href{@platform-ref@/7.0-latest/taglibs/modules/apps/foundation/com.liferay.frontend.taglib/com.liferay.frontend.taglib/liferay-frontend/management-bar-sidenav-toggler-button.html}{\texttt{\textless{}liferay-frontend:management-bar-sidenav-toggler-button\textgreater{}}
tag} implements slide-out navigation for the info button.

The
\href{@platform-ref@/7.0-latest/taglibs/modules/apps/foundation/com.liferay.frontend.taglib/com.liferay.frontend.taglib/liferay-frontend/management-bar-display-buttons.html}{\texttt{\textless{}liferay-frontend:management-bar-display-buttons\textgreater{}}
tag} renders the app's display style options:

\begin{figure}
\centering
\includegraphics{./images/management-bar-display-buttons.png}
\caption{The \texttt{management-bar-display-buttons} tag contains the
content's display options.}
\end{figure}

The
\href{@platform-ref@/7.0-latest/taglibs/modules/apps/foundation/com.liferay.frontend.taglib/com.liferay.frontend.taglib/liferay-frontend/management-bar-filters.html}{\texttt{\textless{}liferay-frontend:management-bar-filters\textgreater{}}
tag} wraps the app's filtering options. This filter should be included
in all control panel applications. Filtering options can include sort
criteria, sort ordering, and more:

\begin{figure}
\centering
\includegraphics{./images/management-bar-filters.png}
\caption{The \texttt{management-bar-filters} tag contains the content
filtering options.}
\end{figure}

Finally, the
\href{@platform-ref@/7.0-latest/taglibs/modules/apps/foundation/com.liferay.frontend.taglib/com.liferay.frontend.taglib/liferay-frontend/management-bar-action-buttons.html}{\texttt{\textless{}liferay-frontend:management-bar-action-buttons\textgreater{}}
tag} wraps the actions that you can execute over selected items. In 7.0,
you can select multiple items between pages. The management bar keeps
track of the number of selected items for you:

\begin{figure}
\centering
\includegraphics{./images/management-bar-action-buttons.png}
\caption{The management bar keeps track of the items selected and
displays the actions to execute on them.}
\end{figure}

For example, here's the Management Bar configuration in Liferay's Trash
app:

\begin{verbatim}
       <liferay-portlet:actionURL name="changeDisplayStyle"
       varImpl="changeDisplayStyleURL">
           <portlet:param name="redirect" value="<%= currentURL %>" />
       </liferay-portlet:actionURL>

       <liferay-frontend:management-bar-display-buttons
           displayViews='<%= new String[] {"descriptive", "icon",
           "list"} %>'
           portletURL="<%= changeDisplayStyleURL %>"
           selectedDisplayStyle="<%= trashDisplayContext.getDisplayStyle()
           %>"
       />
   </liferay-frontend:management-bar-buttons>

   <liferay-frontend:management-bar-filters>
       <liferay-frontend:management-bar-navigation
           navigationKeys='<%= new String[] {"all"} %>'
           portletURL="<%= trashDisplayContext.getPortletURL() %>"
       />

       <liferay-frontend:management-bar-sort
           orderByCol="<%= trashDisplayContext.getOrderByCol() %>"
           orderByType="<%= trashDisplayContext.getOrderByType() %>"
           orderColumns='<%= new String[] {"removed-date"} %>'
           portletURL="<%= trashDisplayContext.getPortletURL() %>"
       />
   </liferay-frontend:management-bar-filters>

   <liferay-frontend:management-bar-action-buttons>
       <liferay-frontend:management-bar-sidenav-toggler-button />

       <liferay-frontend:management-bar-button href="javascript:;"
       icon="trash" id="deleteSelectedEntries" label="delete" />
   </liferay-frontend:management-bar-action-buttons>
\end{verbatim}

In this section of tutorials, you'll learn how to add a management bar
to your application.

\section{Implementing the Management Bar Display
Styles}\label{implementing-the-management-bar-display-styles}

The Management Bar offers a few display styles for your app's search
container contents: descriptive, icon, and list. These views are
standard in Liferay DXP's control panel apps. While you are not required
to implement all these display styles in your app's management bar, they
provide some additional control over how your app's information is
displayed.

\begin{figure}
\centering
\includegraphics{./images/management-bar-display-buttons.png}
\caption{The \texttt{management-bar-display-buttons} tag contains the
content's display options.}
\end{figure}

To provide these views in your app, you must make some updates to your
search result columns. Follow the patterns covered in this tutorial to
configure your app.

\textbf{Note:} You are not required to implement all the display views
in your app. You must just at least have one display style implemented
(\texttt{list} is the default). Views that are disabled in your app will
render as greyed out buttons.

Start by configuring the Management Bar Display Buttons tag next.

\subsection{Configuring the Management Bar Display Buttons
Tag}\label{configuring-the-management-bar-display-buttons-tag}

Follow these steps to configure the management bar display button tags:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add the
  \texttt{\textless{}liferay-frontend:management-bar\textgreater{}}
  taglib to your app's main view (\texttt{view.jsp} for example). If the
  management bar has a checkbox that needs to stay selected while the
  navigation is used, you can optionally provide a search container ID
  with the \texttt{searchContainerId} attribute and set the
  \texttt{includeCheckBox} attribute to \texttt{true}.
\item
  Add the management bar buttons using the
  \texttt{\textless{}liferay-frontend:management-bar-buttons\textgreater{}}
  and
  \texttt{\textless{}liferay-frontend:management-bar-display-buttons\textgreater{}}
  tags. The
  \texttt{\textless{}liferay-frontend:management-bar-display-buttons\textgreater{}}
  tag requires three attributes: \texttt{displayViews}, the display
  style views that are available; \texttt{portletURL}, the URL to
  redirect to after an option is chosen; and
  \texttt{selectedDisplayStyle}, the view to display. Below is an
  example configuration that implements all three display views:

\begin{verbatim}
<liferay-frontend:management-bar>
    <liferay-frontend:management-bar-buttons>
      <liferay-frontend:management-bar-display-buttons
        displayViews='<%= new String[] {"icon", "descriptive", "list"} %>'
        portletURL="<%= myViewURL %>"
        selectedDisplayStyle="<%= displayStyle %>"
      />
    </liferay-frontend:management-bar-buttons>
</liferay-frontend:management-bar>
\end{verbatim}
\end{enumerate}

Your taglibs are configured for your display styles, but at the moment
they don't do anything. You'll configure the views next.

\subsection{Configuring the Display
Views}\label{configuring-the-display-views}

Note that your management bar may not contain all three views. You only
need to implement the views that you defined in your
\texttt{\textless{}liferay-frontend:management-bar-display-buttons\textgreater{}}
tag's \texttt{displayViews} attribute. Follow these steps to set the
display views for the management bar:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Define a default display style. For example, the configuration below
  sets the default display style to list:

\begin{verbatim}
<%
String displayStyle = ParamUtil.getString(request, "displayStyle", "list");
%>
\end{verbatim}
\item
  Wrap each display style configuration with the proper check:

\begin{verbatim}
<c:choose>
                <c:when test='<%= Objects.equals(displayStyle, "icon") %>'>
            <%-- icon display style configuration goes here --%>
        </c:when>
        ...
        <c:when test='<%= Objects.equals(displayStyle, "descriptive") %>'>
            <%-- descriptive display style configuration goes here --%>
        </c:when>
        ...
        <c:when test='<%= Objects.equals(displayStyle, "list") %>'>
            <%-- list display style configuration goes here --%>
        </c:when>
</c:choose>
\end{verbatim}
\end{enumerate}

Use \href{https://lexicondesign.io/docs/patterns/cards.html}{cards} to
display the information. Use a vertical card to display assets like
files or web content. Use horizontal cards to display folders or
directories. You can add the display style configurations for each view
next.

\subsubsection{Implementing the Icon
View}\label{implementing-the-icon-view}

The icon view prominently displays an icon for the content, along with
its name, status, and a condensed description.

\begin{figure}
\centering
\includegraphics{./images/lexicon-icon-view.png}
\caption{The Management Bar's icon display view gives a quick summary of
the content's description and status.}
\end{figure}

Follow the steps below to create your icon view:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  First, make your icon view responsive to different devices.

  For vertical cards use the following pattern:

\begin{verbatim}
<%
row.setCssClass("col-md-2 col-sm-4 col-xs-6");
%>
\end{verbatim}

  For horizontal cards use the following pattern:

\begin{verbatim}
<%
row.setCssClass("col-md-3 col-sm-4 col-xs-12");
%>
\end{verbatim}
\item
  Once your cards are responsive, you must add search container column
  text using the pattern below:

\begin{verbatim}
<liferay-ui:search-container-column-text>
    <%-- include your vertical card or horizontal card here --%>
</liferay-ui:search-container-column-text>
\end{verbatim}
\item
  Add the card to the
  \texttt{\textless{}liferay-ui:search-container-column-text\textgreater{}}:

  Use one of the following tags for your vertical card:

\begin{verbatim}
<liferay-frontend:vertical-card/>

<liferay-frontend:user-vertical-card/>

<liferay-frontend:icon-vertical-card/>
\end{verbatim}

  Below is an example from the \texttt{com.liferay.journal.web} module's
  \href{https://github.com/liferay/liferay-portal/blob/7.0.x/modules/apps/web-experience/journal/journal-web/src/main/resources/META-INF/resources/view_comments.jsp}{\texttt{view\_comments.jsp}}:

\begin{verbatim}
<liferay-ui:search-container-column-text>
  <liferay-frontend:vertical-card
    cssClass="entry-display-style"
    imageUrl="<%= (userDisplay != null) ? userDisplay.getPortraitURL(themeDisplay) : UserConstants.getPortraitURL(themeDisplay.getPathImage(), true, 0, null) %>"
    resultRow="<%= row %>"
  >
    <liferay-frontend:vertical-card-header>
      <liferay-ui:message arguments="<%= new String[] {LanguageUtil.getTimeDescription(locale, System.currentTimeMillis() - mbMessage.getModifiedDate().getTime(), true), HtmlUtil.escape(mbMessage.getUserName())} %>" key="x-ago-by-x" translateArguments="<%= false %>" />
    </liferay-frontend:vertical-card-header>

    <liferay-frontend:vertical-card-footer>
      <%= HtmlUtil.extractText(content) %>
    </liferay-frontend:vertical-card-footer>
  </liferay-frontend:vertical-card>
</liferay-ui:search-container-column-text>
\end{verbatim}

  For horizontal cards you can use the tag below:

\begin{verbatim}
<liferay-frontend:horizontal-card/>
\end{verbatim}
\end{enumerate}

Now that your icon view is configured, you can move onto your
descriptive view next.

\subsubsection{Implementing the Descriptive
View}\label{implementing-the-descriptive-view}

The descriptive view displays the complete description, along with a
small icon for the content, and its name.

\begin{figure}
\centering
\includegraphics{./images/lexicon-descriptive-view.png}
\caption{The Management Bar's descriptive display view gives the
content's full description.}
\end{figure}

Your descriptive view should have three columns.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  The first column usually contains an icon, image, or user portrait:

  For an icon use the following tag:

\begin{verbatim}
<liferay-ui:search-container-column-icon/>
\end{verbatim}

  For an image use the following tag:

\begin{verbatim}
<liferay-ui:search-container-column-image/>    
\end{verbatim}

  For a user portrait use the following pattern:

\begin{verbatim}
<liferay-ui:search-container-column-text>
    <liferay-ui:user-portrait/>
</liferay-ui:search-container-column-text>
\end{verbatim}
\item
  The second column should contain the descriptions. For example, the
  \href{https://github.com/liferay/liferay-portal/blob/98d332c8fa884ab229c848e7eabd5b9a8da514d6/modules/apps/web-experience/site/site-teams-web/src/main/resources/META-INF/resources/user_group_columns.jspf}{site
  teams application} is configured with the settings below:

\begin{verbatim}
<liferay-ui:search-container-column-text
    colspan="<%=2%>"
>
    <h5><%= userGroup.getName() %></h5>

    <h6 class="text-default">
        <span><%= userGroup.getDescription() %></span>
    </h6>

    <h6 class="text-default">
        <span><liferay-ui:message arguments="<%= usersCount%>" key="x-users"
        /></span>
    </h6>

</liferay-ui:search-container-column-text>
\end{verbatim}
\item
  Finally, the third column contains the actions. For example, the site
  teams application uses the configuration below:

\begin{verbatim}
<liferay-ui:search-container-column-jsp
    path="/edit_team_assignments_user_groups_action.jsp"
/>
\end{verbatim}
\end{enumerate}

Now that your descriptive view is configured you can implement your list
view next.

\subsubsection{Implementing the List
View}\label{implementing-the-list-view}

The list view is the default view that is shown for most applications.
This view lists the content's information in individual columns.

\begin{figure}
\centering
\includegraphics{./images/lexicon-list-view.png}
\caption{The Management Bar's list display view list the content's
information in individual columns.}
\end{figure}

For example, the
\href{https://github.com/liferay/liferay-portal/blob/fe808e45473fc1491ac79b396b822629df5b052c/modules/apps/foundation/mobile-device-rules/mobile-device-rules-web/src/main/resources/META-INF/resources/rule_columns.jspf}{mobile
device rules application} configures its list view using the pattern
below:

\begin{verbatim}
<liferay-ui:search-container-column-text
        cssClass="content-column name-column title-column"
        name="name"
        truncate="<%= true %>"
        value="<%= rule.getName(locale) %>"
/>

<liferay-ui:search-container-column-text
        cssClass="content-column description-column"
        name="description"
        truncate="<%= true %>"
        value="<%= rule.getDescription(locale) %>"
/>

<liferay-ui:search-container-column-date
        cssClass="create-date-column text-column"
        name="create-date"
        property="createDate"
/>

<liferay-ui:search-container-column-text
        cssClass="text-column type-column"
        name="type"
        translate="<%= true %>"
        value="<%= rule.getType() %>"
/>

<liferay-ui:search-container-column-jsp
        cssClass="entry-action-column"
        path="/rule_actions.jsp"
/>
\end{verbatim}

Finally, set the display style in your
\texttt{liferay-ui:search-iterator} tag with the \texttt{displayStyle}
attribute:

\begin{verbatim}
<liferay-ui:search-iterator

    displayStyle="<%= displayStyle %>"
    markupView="lexicon"
    searchContainer="<%= searchContainer %>"
/>
\end{verbatim}

The \texttt{displayStyle} attribute is set to the \texttt{displayStyle}
var which is set by the management bar display style buttons.

Your display views are configured!

\subsection{Related Topics}\label{related-topics-49}

\href{/docs/7-0/tutorials/-/knowledge_base/t/implementing-a-management-bar-sort-filter}{Implementing
a Management Bar Sort Filter}

\href{/docs/7-0/tutorials/-/knowledge_base/t/implementing-a-management-bar-navigation-filter}{Implementing
a Management Bar Navigation Filter}

\section{Implementing a Management Bar Navigation
Filter}\label{implementing-a-management-bar-navigation-filter}

Navigation filters are used to create navigation menus in the Management
Bar. You can add as many navigation filters to the Management Bar as
your app requires.

You can learn how to configure the navigation filter next.

\subsection{Configuring the Navigation
Filter}\label{configuring-the-navigation-filter}

Follow these steps to configure the navigation filter:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add the
  \texttt{\textless{}liferay-frontend:management-bar-filters\textgreater{}}
  tag below the
  \texttt{\textless{}liferay-frontend:management-bar-buttons\textgreater{}}
  tags, to contain your management bar filters.
\item
  Use the
  \texttt{\textless{}liferay-frontend:management-bar-navigation\textgreater{}}
  tag to add as many navigation menus as your app requires. Use the
  \texttt{navigationKeys} attribute to set the navigation menu options.
  The \texttt{navigationParam} attribute identifies the parameter to use
  for the navigation filter value. The default value is
  \texttt{navigation}. If you have more than one navigation menu, you
  can specify a unique variable with the \texttt{navigationParam} to
  identify each menu. Finally, use the \texttt{portletURL} attribute to
  set the URL for the page. Below is an example configuration with one
  navigation menu:

\begin{verbatim}
<liferay-frontend:management-bar-filters>

    <liferay-frontend:management-bar-navigation
    navigationKeys='<%= new String[] {"all", ["navigation-title"]...} %>'
    navigationParam="myCustomNavigationVariable"
    portletURL="<%= portletURL %>"
    />
</liferay-frontend:management-bar-filters>
\end{verbatim}

  If your app doesn't require any navigation filters, you can just
  provide the \emph{all} filter to display everything. If, however, you
  need to let the user navigate between pages (JSPs) of your app , you
  can add additional strings to the \texttt{navigationKeys} attribute
  for each page you need.
\item
  Set the navigation filter's default value with \texttt{paramUtil}. For
  example, the configuration below sets the default navigation filter to
  \emph{all}:

\begin{verbatim}
String navigation = ParamUtil.getString(request, "navigation", "all");
\end{verbatim}
\item
  If your app has multiple options in a navigation menu, use the
  \texttt{navigationParam} to check the current value. Below is an
  example code snippet from \texttt{com.liferay.wiki.web} module's
  \href{https://github.com/liferay/liferay-portal/blob/7.0.x/modules/apps/collaboration/wiki/wiki-web/src/main/resources/META-INF/resources/wiki/page_iterator.jsp}{\texttt{page\_iterator.jsp}}
  that checks the navigation menu's value to render the proper JSP
  content. Note that it uses the \texttt{navigationParam}'s default
  value \texttt{navigation} to check the current value:

\begin{verbatim}
if (navigation.equals("all-pages")) {
    portletURL.setParameter("mvcRenderCommandName", "/wiki/view_pages");

    PortalUtil.addPortletBreadcrumbEntry(request, LanguageUtil.get(request,
  "all-pages"), portletURL.toString());
}
else if (navigation.equals("categorized-pages")) {
    portletURL.setParameter("mvcRenderCommandName",
  "/wiki/view_categorized_pages");

    portletURL.setParameter("categoryId", String.valueOf(categoryId));
}
else if (navigation.equals("draft-pages")) {
    portletURL.setParameter("mvcRenderCommandName", "/wiki/view_draft_pages");

    PortalUtil.addPortletBreadcrumbEntry(request, LanguageUtil.get(request,
  "draft-pages"), portletURL.toString());
}
\end{verbatim}
\end{enumerate}

Now you know how to add navigation filters to a management bar!

\subsection{Related Topics}\label{related-topics-50}

\href{/docs/7-0/tutorials/-/knowledge_base/t/implementing-a-management-bar-sort-filter}{Implementing
a Management Bar Sort Filter}

\href{/docs/7-0/tutorials/-/knowledge_base/t/implementing-the-management-bar-display-styles}{Implementing
the Management Bar Display Styles}

\section{Implementing a Management Bar Sort
Filter}\label{implementing-a-management-bar-sort-filter}

The Management Bar Sort Filters let you compare entries for a search
container field, and sort them by ascending or descending. To do this,
you must create a comparator class for each field that you want to sort.

The sort filters are an implementation of the standard
\href{https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html}{\texttt{Comparator}
Interface}, with some additional methods provided by the
\href{https://github.com/liferay/liferay-portal/blob/7.0.6-ga7/portal-kernel/src/com/liferay/portal/kernel/util/OrderByComparator.java}{\texttt{OrderByComparator}
class}.

Once the class is created you can use it in your view to add the sort
filters to the UI.

Go ahead and get started by creating the Comparator class next.

\subsection{Creating the Comparator
Class}\label{creating-the-comparator-class}

The \texttt{OrderByComparator} class is a \texttt{Comparator}
implementation that you can extend to create sort filters. Follow these
steps to create the \texttt{*OrderByComparator} class:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Right-click on your API module's folder in the package explorer and
  select \emph{New}→\emph{Package} to create a new package.
\item
  Right-click the package you just created and select
  \emph{New}→\emph{Class}. Enter \emph{EntryNameComparator} for the
  class Name, check the \emph{Constructors from superclass} option, and
  click \emph{Finish}.
\item
  Update the class declaration to extend the \texttt{OrderByComparator}
  class and use a proper asset type,
  \texttt{\textless{}Entry\textgreater{}} for example\textgreater. Below
  is an example configuration for an entry name field comparator:

\begin{verbatim}
 public class EntryNameComparator extends OrderByComparator<Entry>{
   ...
 }
\end{verbatim}
\item
  Add variables for the ascending, descending, and column name field
  (name for example) sorters:

\begin{verbatim}
public static final String ORDER_BY_ASC = "[asset].[column name] ASC";

public static final String ORDER_BY_DESC = "[asset].[column name] DESC";

public static final String[] ORDER_BY_FIELDS = {"[field name]"};
\end{verbatim}

  Below is an example configuration for an Entry asset's name field:

\begin{verbatim}
public static final String ORDER_BY_ASC = "Entry.name ASC";

public static final String ORDER_BY_DESC = "Entry.name DESC";

public static final String[] ORDER_BY_FIELDS = {"name"};
\end{verbatim}
\item
  Replace the public constructor with the following constructors:

\begin{verbatim}
public *Comparator() {
    this(false);
}

public *Comparator(boolean ascending) {
    _ascending = ascending;
}
\end{verbatim}

  Below is an example configuration for an EntryNameComparator:

\begin{verbatim}
public EntryNameComparator() {
  this(false);
}

public EntryNameComparator(boolean ascending) {
  _ascending = ascending;
}
\end{verbatim}
\item
  Add the \texttt{compare()} method to compare search container asset
  entries. Below is an example configuration for entry assets:

\begin{verbatim}
@Override
public int compare(Entry entry1, Entry entry2) {
  String name1 = entry1.getName();
  String name2 = entry2.getName();

  int value = name1.compareTo(name2);

  if (_ascending) {
    return value;
  }
  else {
    return -value;
  }
}
\end{verbatim}
\item
  Add the following code to return the order fields and check whether
  the order is ascending or descending:

\begin{verbatim}
@Override
public String getOrderBy() {
    if (_ascending) {
        return ORDER_BY_ASC;
    }
    else {
        return ORDER_BY_DESC;
    }
}

@Override
public String[] getOrderByFields() {
    return ORDER_BY_FIELDS;
}

@Override
public boolean isAscending() {
    return _ascending;
}

private final boolean _ascending;
\end{verbatim}
\item
  Finally, resolve imports for the class:

\begin{verbatim}
import com.liferay.docs.guestbook.model.Entry;
import com.liferay.portal.kernel.util.OrderByComparator;
\end{verbatim}
\end{enumerate}

Now that your \texttt{*Comparator} class is written you must update the
service layer to use it.

\subsection{Updating the Service
Layer}\label{updating-the-service-layer}

Follow these steps to update services:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open your \texttt{*EntryLocalServiceImpl} class in your service module
  and import the \texttt{OrderByComparator} class:

\begin{verbatim}
import com.liferay.portal.kernel.util.OrderByComparator;
\end{verbatim}
\end{enumerate}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\item
  Update the \texttt{getEntries()} method with the start and end
  integers to include the \texttt{OrderByComparator} parameter. Below is
  an example configuraiton:

\begin{verbatim}
public List<Entry> getEntries(
    long groupId, long guestbookId, int start, int end,
    OrderByComparator<Entry> obc) {

    return entryPersistence.findByG_G(
        groupId, guestbookId, start, end, obc);
}
\end{verbatim}
\item
  Rebuild services for your App. Right-click the service module in the
  Project Explorer and select \emph{Liferay} → \emph{build-service}.
\item
  Export the comparator package in the API module's BND.
\end{enumerate}

Now that the services are updated and your exports are in order, you can
configure the view to use the comparator next.

\subsection{Configuring the View}\label{configuring-the-view}

Follow these steps to configure the view to use the Comparator:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Import the \texttt{EntryNameComparator} and \texttt{Comparator}
  classes into the web module project's \texttt{init.jsp}:

\begin{verbatim}
page import="com.liferay.docs.guestbook.util.comparator.EntryNameComparator"

page import="com.liferay.portal.kernel.util.OrderByComparator"
\end{verbatim}
\item
  Open the view and add the comparator code below the
  \texttt{displayStyle} variable in the java scriplet at the top. Below
  is an example configuration that uses the EntryNameComparator class:

\begin{verbatim}
String orderByCol = ParamUtil.getString(request, "orderByCol", "name");

boolean orderByAsc = false;

String orderByType = ParamUtil.getString(request, "orderByType", "asc");

if (orderByType.equals("asc")) {
    orderByAsc = true;
}

OrderByComparator orderByComparator = null;

if (orderByCol.equals("name")) {
    orderByComparator = new EntryNameComparator(orderByAsc);
}
\end{verbatim}

  This sets up the configuration for the comparators.
\item
  Add \texttt{orderByCol} and \texttt{orderByType} portlet parameters
  for your order comparator to the view's render URL. The
  \texttt{orderByCol} parameter specifies the column to order by and the
  \texttt{orderByType} column specifies whether the order is ascending
  or descending. Below is the configuration for the EntryNameComparator:

\begin{verbatim}
<liferay-portlet:renderURL varImpl="viewPageURL">
    <portlet:param name="mvcPath" value="/html/guestbookmvcportlet/view.jsp" />
    <portlet:param name="guestbookId" value="<%= String.valueOf(guestbookId) %>" />
    <portlet:param name="displayStyle" value="<%= displayStyle %>" />
    <portlet:param name="orderByCol" value="<%= orderByCol %>" />
    <portlet:param name="orderByType" value="<%= orderByType %>" />
</liferay-portlet:renderURL>
\end{verbatim}
\item
  Add the sort filters below the navigation filters, using the
  \texttt{\textless{}liferay-frontend:management-bar-sort\ /\textgreater{}}
  taglib. Pass the name of the column you specified in the *Comparator
  class. Below is the example configuration for the EntryNameComparator
  class:

\begin{verbatim}
<liferay-frontend:management-bar-sort
  orderByCol="<%= orderByCol %>"
  orderByType="<%= orderByType %>"
  orderColumns='<%= new String[] {"name"} %>'
  portletURL="<%= viewPageURL %>"
/>
\end{verbatim}
\item
  Finally, pass the \texttt{orderByComparator} in as an argument in the
  search container results to match the updated method signature you
  modified. Below is the configuration for the example
  EntryNameComparator:

\begin{verbatim}
<liferay-ui:search-container-results
    results="<%= EntryLocalServiceUtil.getEntries(scopeGroupId,
  guestbookId, searchContainer.getStart(), searchContainer.getEnd(),
  orderByComparator) %>"
/>
\end{verbatim}
\end{enumerate}

The Management Bar Sort Filters are finished!

\subsection{Related Topics}\label{related-topics-51}

\href{/docs/7-0/tutorials/-/knowledge_base/t/implementing-a-management-bar-navigation-filter}{Implementing
a Management Bar Navigation Filter}

\href{/docs/7-0/tutorials/-/knowledge_base/t/disabling-the-management-bar}{Disabling
the Management Bar}

\section{Disabling the Management
Bar}\label{disabling-the-management-bar}

When there's no content in the app, you should disable all the
Management Bar's buttons, except the info button.

You can disable the Management Bar by adding the \texttt{disabled}
attribute to the \texttt{liferay-frontend:management-bar} tag:

\begin{verbatim}
<liferay-frontend:management-bar
        disabled="<%= total == 0 %>"
        includeCheckBox="<%= true %>"
        searchContainerId="<%= searchContainerId %>"
>
\end{verbatim}

You can also disable individual buttons by adding the \texttt{disabled}
attribute to the corresponding tag. The example configuration below
disables the display buttons when the search container displays 0
results:

\begin{verbatim}
<liferay-frontend:management-bar-display-buttons
        disabled="<%= total == 0 %>"
        displayViews='<%= new String[] {"descriptive", "icon", "list"} %>'
        portletURL="<%= changeDisplayStyleURL %>"
        selectedDisplayStyle="<%= trashDisplayContext.getDisplayStyle() %>"
/>
\end{verbatim}

Now you know how to disable the Management Bar!

\subsection{Related Topics}\label{related-topics-52}

\href{/docs/7-0/tutorials/-/knowledge_base/t/implementing-a-management-bar-sort-filter}{Implementing
a Management Bar Sort Filter}

\href{/docs/7-0/tutorials/-/knowledge_base/t/setting-search-container-animations}{Setting
Search Container Animations}

\section{Configuring Your Admin App's Actions
Menu}\label{configuring-your-admin-apps-actions-menu}

In versions prior to 7.0, it was common to have a series of buttons or
menus with actions in the different views of the app. In 7.0 the
proposed pattern is to move all of these actions to the upper right menu
of the administrative portlet, leaving the primary action (often an
``Add'' operation) visible in the add menu,
\href{/docs/7-0/tutorials/-/knowledge_base/t/applying-the-add-button-pattern}{using
the Add Button pattern}. For example, the web content application has
the actions menu shown below:

\begin{figure}
\centering
\includegraphics{./images/actions-menu.png}
\caption{The upper right ellipsis menu contains most of the actions for
the app.}
\end{figure}

The changes covered in this tutorial do not refer to actions menus
associated with entities. For those, see
\href{/docs/7-0/tutorials/-/knowledge_base/t/applying-lexicon-patterns-to-forms-navigation-and-search}{Applying
Lexicon Patterns to Your Forms, Navigation, and Search}.

This tutorial shows how to configure the actions menu in your admin app.
The first step is to create the \texttt{PortletConfigurationIconFactory}
class.

\subsection{Creating the Icon Factory
Class}\label{creating-the-icon-factory-class}

To add an action to the upper right menu of the Admin portlet you must
first create a
\href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/configuration/icon/PortletConfigurationIcon.html}{\texttt{PortletConfigurationIcon}
Component class}. This class specifies the portlet for the action, the
screen to show it on, and the order (by specifying a weight).

In this example, the action appears on the System Settings portlet. To
make it appear in a secondary screen, you can use the \texttt{path}
property as shown below:

\begin{verbatim}
@Component(
  immediate = true,
  property = {
     "javax.portlet.name=" +
        ConfigurationAdminPortletKeys.SYSTEM_SETTINGS,
     "path=/view_factory_instances"
  },
  service = PortletConfigurationIconFactory.class
)
public class ExportFactoryInstancesIconFactory
  extends BasePortletConfigurationIconFactory {

  @Override
  public PortletConfigurationIcon create(PortletRequest portletRequest) {
     return new ExportFactoryInstancesIcon(portletRequest);
  }

  @Override
  public double getWeight() {
     return 1;
  }

}
\end{verbatim}

The value of the \texttt{path} property depends on the MVC framework
used to develop the app.

For the MVCPortlet framework, provide the path (often a JSP) from the
\texttt{mvcPath} parameter.

For MVCPortlet with MVC Commands, the path should contain the
\texttt{mvcRenderCommandName} where the actions should be displayed
(such as \texttt{/document\_library/edit\_folder} for example).

Now that your \texttt{PortletConfigurationIconFactory} class is written,
you can write the \texttt{PortletConfigurationIcon} class next.

\subsection{Writing the Configuration Icon
Class}\label{writing-the-configuration-icon-class}

The second class that you must write is a class that extends the
\href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/configuration/icon/BasePortletConfigurationIcon.html}{\texttt{BasePortletConfigurationIcon}
class}. This class specifies the action's label, whether it's invoked
with a GET or POST method, and the URL (or \texttt{onClick} JavaScript
method) to invoke when the action is clicked. It can also implement some
custom code to determine whether the action should display for the
current request. For example the class below creates a
\texttt{export-all-settings} label and specifies the \texttt{GET} method
for the action:

\begin{verbatim}
public class ExportAllConfigurationIcon extends BasePortletConfigurationIcon {

  public ExportAllConfigurationIcon(PortletRequest portletRequest) {
     super(portletRequest);
  }

  @Override
  public String getMessage() {
     return "export-all-settings";
  }

  @Override
  public String getMethod() {
     return "GET";
  }

  @Override
  public String getURL() {
     LiferayPortletURL liferayPortletURL =
        (LiferayPortletURL)PortalUtil.getControlPanelPortletURL(
           portletRequest, ConfigurationAdminPortletKeys.SYSTEM_SETTINGS,
           PortletRequest.RESOURCE_PHASE);

     liferayPortletURL.setResourceID("export");

     return liferayPortletURL.toString();
  }

  @Override
  public boolean isShow() {
     return true;
  }

}
\end{verbatim}

By default, if the portlet uses \texttt{mvcPath}, the global actions
(such as configuration, export/import, maximized, etc.) are displayed
for the JSP indicated in the initialization parameter of the portlet
\texttt{javax.portlet.init-param.view-template=/view.jsp}. The value
indicates the JSP where the global actions should be displayed.

However, if the portlet uses MVC Command, the views for the global
actions must be indicated with the initialization parameter
\texttt{javax.portlet.init-param.mvc-command-names-default-views=/wiki\_admin/view}
and the value must contain the \texttt{mvcRenderCommandName} where the
global actions should be displayed.

For portlets that can be added to a page, if the desired behavior is to
always include the configuration options, the following initialization
parameter should be added to the portlet:

\begin{verbatim}
javax.portlet.init-param.always-display-default-configuration-icons=true
\end{verbatim}

Now you know how to configure your admin app's actions!

\subsection{Related Topics}\label{related-topics-53}

\href{/docs/7-0/tutorials/-/knowledge_base/t/applying-lexicon-patterns-to-forms-navigation-and-search}{Applying
Lexicon Patterns to your Forms, Navigation, and Search}

\href{/docs/7-0/tutorials/-/knowledge_base/t/configuring-your-applications-title-and-back-link}{Configuring
Your Application's Title and Back Link}

\section{Setting Search Container
Animations}\label{setting-search-container-animations}

If you've toured 7.0's UI, you've probably noticed animations in the
search containers. These animations show the user when there is no
available content.

\begin{figure}
\centering
\includegraphics{./images/no-content-found-blog.png}
\caption{This is a still frame from the Blogs portlet's empty results
animation.}
\end{figure}

This tutorial covers the following topics:

\begin{itemize}
\tightlist
\item
  Using the default animations in your search container
\item
  Using custom animations in your search container
\end{itemize}

First, you'll learn how to use the default animations in your search
container.

\subsection{Using the Default Animations in Your Search
Container}\label{using-the-default-animations-in-your-search-container}

There are three built-in classes for the search container animation:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  The default class is \emph{taglib-empty-result-message-header}. This
  is used for most cases.

  \begin{figure}
  \centering
  \includegraphics{./images/no-content-found-blog.png}
  \caption{When no content is found, the default animation is usually
  shown.}
  \end{figure}
\item
  \emph{taglib-empty-search-result-message-header} is used when there
  are no search results.

  \begin{figure}
  \centering
  \includegraphics{./images/no-web-content-found-search.png}
  \caption{You can use the empty search result animation to show that no
  search results were found.}
  \end{figure}
\item
  \emph{taglib-empty-result-message-header-has-plus-btn} is used when
  there is no content, but you can use the add button to add an entity.
\end{enumerate}

\begin{figure}
\centering
\includegraphics{./images/no-tags-found-plus-button.png}
\caption{If you can use the add button to add entities to the app, use
the has plus button animation.}
\end{figure}

To use these animations, use the following method:

\begin{verbatim}
SearchContainer.setEmptyResultsMessageCssClass()
\end{verbatim}

For example, the Roles Admin application uses this code to set its
animation in its
\href{https://github.com/liferay/liferay-portal/blob/7.0.x/modules/apps/foundation/roles/roles-admin-web/src/main/resources/META-INF/resources/edit_role_assignments_sites.jsp\#L46-L48}{\texttt{edit\_role\_assignments\_sites.jsp}
file}:

\begin{verbatim}
if (!searchTerms.isSearch()) {
        searchContainer.setEmptyResultsMessageCssClass(
        "taglib-empty-result-message-header-has-plus-btn"
        );
}
\end{verbatim}

Alternatively you can use the \texttt{emptyResultsMessageCssClass}
attribute of the
\href{https://docs.liferay.com/portal/7.0/taglibs/util-taglib/liferay-ui/search-container.html}{\texttt{liferay-ui:search-container}}
tag to set the animation. For example,

\begin{verbatim}
<liferay-ui:search-container
  emptyResultsMessage="no-results-were-found"
  emptyResultsMessageCssClass="taglib-empty-result-message-header-has-plus-btn"
  ...
>
\end{verbatim}

If you don't want to use the default animations packaged with 7.0, you
can use custom animations instead. This is covered next.

\subsection{Using Custom Animations}\label{using-custom-animations}

As stated earlier, each animation has a matching CSS class that the
search container uses. To use a custom animation, therefore, you must
modify the existing styles.

There are two approaches you can take:

\begin{itemize}
\tightlist
\item
  Overwrite the existing styles to replace the default animations
\item
  Create new styles to make the animation available to the search
  container
\end{itemize}

Regardless of the approach you choose, you must provide the CSS styles
in a
\href{/docs/7-0/tutorials/-/knowledge_base/t/introduction-to-themes}{Theme},
\href{/docs/7-0/tutorials/-/knowledge_base/t/themelets}{Themelet}, or
\href{/docs/7-0/tutorials/-/knowledge_base/t/theme-contributors}{Theme
Contributor}. These styles point to the animation's source. You can
provide the animation however you like: as long as you have a valid URL
(relative or absolute) that points to the animation, you can use it.

The default search container animation styles are provided by the
\href{https://github.com/liferay/liferay-portal/blob/7.0.x/modules/apps/foundation/frontend-css/frontend-css-web/src/main/resources/META-INF/resources/taglib/_empty_result_message.scss}{\_empty\_result\_message.scss}
file.

\noindent\hrulefill

\textbf{Note:} Search containers can also contain static images for the
no results message if you prefer. Just use a valid image type instead.
All animations must be of type \texttt{GIF} though.

\noindent\hrulefill

You can learn how to replace the default animations next.

\subsubsection{Replacing Default Empty Results Message
Animations}\label{replacing-default-empty-results-message-animations}

Follow these steps to replace the existing animations with your own:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Make your custom animation available in your theme, themelet,
  Documents and Media repository, etc. For example, place the
  \texttt{.gif} in your theme's \texttt{images} folder.
\item
  Inside your CSS file (\texttt{\_custom.scss} for example), override
  the animation styles that you want to replace. For example, to replace
  the default animation, include the following styles for a custom
  animation located in the \texttt{images/emoticons} folder of a theme:

\begin{verbatim}
.taglib-empty-result-message {
    .taglib-empty-result-message-header {
        background-image: 
        url(@theme_image_path@/emoticons/[your_custom_animation].gif);
    }
}
\end{verbatim}
\item
  Inside your app's search container, use the
  \texttt{emptyResultsMessageCssClass} attribute, or use the
  \texttt{SearchContainer.setEmptyResultsMessageCssClass()} method.
  Below is an example configuration that uses the
  \texttt{emptyResultsMessageCssClass} attribute:

\begin{verbatim}
<liferay-ui:search-container
    emptyResultsMessage="no-results-were-found"
    emptyResultsMessageCssClass="taglib-empty-result-message-header"
    total="<%= total %>"
>
\end{verbatim}

  Here is an example configuration that uses the
  \texttt{SearchContainer.setEmptyResultsMessageCssClass()} method:

\begin{verbatim}
SearchContainer.setEmptyResultsMessageCssClass("taglib-empty-result-message-header")
\end{verbatim}
\end{enumerate}

Your custom animation now appears in the search container instead of the
default animation. If instead you want to add your custom animation to
the default ones available, follow the steps in the next section.

\subsubsection{Adding A New Empty Results Message
Animation}\label{adding-a-new-empty-results-message-animation}

Adding an animation to the empty results message involves the same steps
as replacing a default animation. The only difference is you must add a
new CSS class. Follow these steps to create a new style for your custom
search container animation:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Make your custom animation available in your theme, themelet,
  Documents and Media repository, etc. For example, place the GIF in
  your theme's \texttt{images} folder.
\item
  Inside your CSS file (\texttt{\_custom.scss} for example), add the
  styles for your new class, wrapped with
  \texttt{.taglib-empty-result-message}. For example, the styles below
  add a custom animation for a class called
  \texttt{my-custom-message-header}:

\begin{verbatim}
.taglib-empty-result-message {
    .my-custom-message-header {
        background-image: 
        url(@theme_image_path@/emoticons/[my_custom_animation].gif);
    }
}
\end{verbatim}
\item
  Use the \texttt{emptyResultsMessageCssClass} attribute in the Search
  Container, or use the
  \texttt{SearchContainer.setEmptyResultsMessageCssClass()} method to
  use the new CSS class you just added. Below is an example
  configuration that uses the \texttt{emptyResultsMessageCssClass}
  attribute:

\begin{verbatim}
<liferay-ui:search-container
    emptyResultsMessage="no-results-were-found"
    emptyResultsMessageCssClass="my-custom-message-header"
    total="<%= total %>"
>
\end{verbatim}

  Here is an example configuration that uses the
  \texttt{SearchContainer.setEmptyResultsMessageCssClass()} method:

\begin{verbatim}
SearchContainer.setEmptyResultsMessageCssClass("my-custom-message-header")
\end{verbatim}
\end{enumerate}

Now you know how to set search container animations in your app!

\subsection{Related Topics}\label{related-topics-54}

\href{/docs/7-0/tutorials/-/knowledge_base/t/using-the-liferay-ui-taglib}{Using
the Liferay UI Taglib}

\href{/docs/7-0/tutorials/-/knowledge_base/t/introduction-to-liferay-search}{Introduction
to Liferay Search}

\section{Using Lexicon Icons in Your
App}\label{using-lexicon-icons-in-your-app}

Whether you're updating your app to 7.0 or writing a new 7.0 app, follow
the process here to use Lexicon's icons. You can find the list of
available Lexicon icons on the
\href{https://liferay.github.io/lexiconcss/content/icons-lexicon/}{Lexicon
site}.

Lexicon icons are defined with the \texttt{icon} attribute. For example,
you define the icon in the management bar, inside the
\texttt{liferay-frontend:management-bar-sidenav-toggler-button} taglib:

\begin{verbatim}
<liferay-frontend:management-bar-sidenav-toggler-button
        disabled="<%= false %>"
        href="javascript:;"
        icon="info-circle"
        label="info"
        sidenavId='<%= liferayPortletResponse.getNamespace() + "infoPanelId" %>'
/>
\end{verbatim}

To use Lexicon icons outside the management bar, you have two options:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  You can use the
  \href{@platform-ref@/7.0-latest/taglibs/util-taglib/liferay-ui/icon.html}{\texttt{liferay-ui:icon}
  taglib}. For example:

\begin{verbatim}
<liferay-ui:icon

    icon="icon-name"

    markupView="lexicon"

    message="message-goes-here"

/>
\end{verbatim}
\item
  You can use the
  \href{@platform-ref@/7.0-latest/taglibs/util-taglib/aui/icon.html}{\texttt{aui:icon}
  taglib}. For example:

\begin{verbatim}
<aui:icon

     cssClass="icon-monospaced"

     image="times"

     markupView="lexicon"

/>
\end{verbatim}
\end{enumerate}

Note the addition of the \texttt{markupView="lexicon"} attribute. This
ensures that the HTML is rendered with Lexicon markup.

That's it! Now you know how to use Lexicon icons in your apps.

\subsection{Related Topics}\label{related-topics-55}

\href{/docs/7-0/tutorials/-/knowledge_base/t/setting-search-container-animations}{Setting
Search Container Animations}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-layouts-inside-custom-portlets}{Creating
Layouts inside Custom Portlets}

\chapter{Customizing}\label{customizing}

In Liferay DXP,
\href{/docs/7-0/tutorials/-/knowledge_base/t/portlets}{portlets} let you
add functionality and
\href{/docs/7-0/tutorials/-/knowledge_base/t/themes-and-layout-templates}{themes}
let you style your sites. But how do you modify and add to existing
functionality in Liferay DXP and portlets? How do you change their
content? The \emph{Customizing} tutorials answer these questions and
demonstrate how to affect your site in the following ways:

\begin{itemize}
\tightlist
\item
  Add, modify, or remove content from Liferay DXP and portlets
\item
  Modify behavior
\item
  Perform actions that respond to events
\end{itemize}

\chapter{Customizing JSPs}\label{customizing-jsps}

There are several different ways to customize JSPs in portlets and the
core. Liferay DXP's API provides the safest ways to customize them. If
you customize a JSP by other means, new versions of the JSP can render
your customization invalid and leave you with runtime errors. It's
highly recommended to use one of the API-based ways.

\section{Using Liferay's API to Override a
JSP}\label{using-liferays-api-to-override-a-jsp}

Here are API-based approaches to overriding JSPs in Liferay DXP:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.2857}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.3571}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.3571}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
\textbf{Approach}
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\textbf{Description}
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\textbf{Cons/Limitations}
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\href{/docs/7-0/tutorials/-/knowledge_base/t/jsp-overrides-using-dynamic-includes}{Dynamic
includes} & Adds content at dynamic include tags. & Limited to JSPs that
have \texttt{dynamic-include} tags (or tags whose classes inherit from
\texttt{IncludeTag}). Only inserts content in the JSPs at the dynamic
include tags. \\
\href{/docs/7-0/tutorials/-/knowledge_base/t/jsp-overrides-using-portlet-filters}{Portlet
filters} & Modifies portlet requests and/or responses to simulate a JSP
customization. & Although this approach doesn't directly customize a
JSP, it achieves the effect of a JSP customization. \\
\end{longtable}

\section{Overriding a JSP Without Using Liferay's
API}\label{overriding-a-jsp-without-using-liferays-api}

It's strongly recommended to customize JSPs using Liferay DXP's API, as
the previous section describes. As of Liferay 7.0, overriding a JSP
using an OSGi fragment or a Custom JSP Bag are both deprecated. Since
these approaches are not based on APIs there's no way to guarantee that
they'll fail gracefully. Instead, if your customization is buggy
(because of your code or because of a change in Liferay), you are most
likely to find out at runtime, where functionality breaks and nasty log
errors greet you.

If you're maintaining a JSP customization that uses one of these
approaches, you should know how they work. This section describes them
and links to their tutorials.

Here are ways to customize JSPs without using Liferay DXP's API:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.2857}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.3571}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.3571}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
\textbf{Approach}
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\textbf{Description}
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\textbf{Cons/Limitations}
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\href{/docs/7-0/tutorials/-/knowledge_base/t/overriding-a-modules-jsps}{OSGi
fragment (deprecated as of Liferay 7.0)} & Completely overrides a
module's JSP using an OSGi fragment & Changes to the original JSP or
module can cause runtime errors. \\
\href{/docs/7-0/tutorials/-/knowledge_base/t/overriding-core-jsps}{Custom
JSP bag (deprecated as of Liferay 7.0)} & Completely override a Liferay
DXP core JSP or one of its corresponding \texttt{-ext.jsp} files. & For
Liferay DXP core JSPs only. Changes to the original JSP or module can
cause runtime errors. \\
\end{longtable}

All the JSP customization approaches are available to you. It's time to
customize some JSPs!

\section{Customizing JSPs with Dynamic
Includes}\label{customizing-jsps-with-dynamic-includes}

The
\href{@platform-ref@/7.0-latest/taglibs/util-taglib/liferay-util/dynamic-include.html}{\texttt{liferay-util:dynamic-include}
tag} is an extension point for inserting content (e.g., JavaScript code,
HTML, and more). To do this, create a module that has content you want
to insert, register that content with the dynamic include tag, and
deploy your module.

\noindent\hrulefill

\textbf{Note}: If the JSP you want to customize has no
\texttt{liferay-util:dynamic-include} tags (or tags whose classes
inherit from \texttt{IncludeTag}), you must use a different
customization approach, such as
\href{/docs/7-0/tutorials/-/knowledge_base/t/jsp-overrides-using-portlet-filters}{portlet
filters}.

\noindent\hrulefill

We'll demonstrate how dynamic includes work using the Blogs entries. For
reference, you can download the
\href{https://portal.liferay.dev/documents/113763090/114000186/example-dynamic-include-blogs-master.zip}{example
module}.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Find the \texttt{liferay-util:dynamic-include} tag where you want to
  insert content and note the tag's key.

  The Blogs app's \texttt{view\_entry.jsp} has a dynamic include tag at
  the top and another at the very bottom.

\begin{verbatim}
<%@ include file="/blogs/init.jsp" %>

<liferay-util:dynamic-include key="com.liferay.blogs.web#/blogs/view_entry.jsp#pre" />

    ... JSP content is here

<liferay-util:dynamic-include key="com.liferay.blogs.web#/blogs/view_entry.jsp#post" />
\end{verbatim}

  Here are the Blogs view entry dynamic include keys:

  \begin{itemize}
  \tightlist
  \item
    \texttt{key="com.liferay.blogs.web\#/blogs/view\_entry.jsp\#pre"}
  \item
    \texttt{key="com.liferay.blogs.web\#/blogs/view\_entry.jsp\#post"}
  \end{itemize}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/starting-module-development}{Create
  a module} (e.g., \texttt{blade\ create\ my-dynamic-include}). The
  module will hold your dynamic include implementation.
\item
  Specify compile-only dependencies, like these Gradle dependencies, in
  your module build file:

\begin{verbatim}
dependencies {
    compileOnly group: "javax.portlet", name: "portlet-api", version: "2.0"
    compileOnly group: "javax.servlet", name: "javax.servlet-api", version: "3.0.1"
    compileOnly group: "com.liferay", name: "com.liferay.petra.string", version: "1.0.0"
    compileOnly group: "com.liferay.portal", name: "com.liferay.portal.kernel", version: "2.0.0"
    compileOnly group: "org.osgi", name: "osgi.cmpn", version: "6.0.0"
}
\end{verbatim}
\item
  Create an OSGi component class that implements the
  \href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/servlet/taglib/DynamicInclude.html}{\texttt{DynamicInclude}
  interface}.

  Here's an example dynamic include implementation for Blogs:

\begin{verbatim}
import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.osgi.service.component.annotations.Component;

import com.liferay.portal.kernel.servlet.taglib.DynamicInclude;

@Component(
    immediate = true,
    service = DynamicInclude.class
)
public class BlogsDynamicInclude implements DynamicInclude {

    @Override
    public void include(
            HttpServletRequest request, HttpServletResponse response,
            String key)
        throws IOException {

        PrintWriter printWriter = response.getWriter();

        printWriter.println(
            "<h2>Added by Blogs Dynamic Include!</h2><br />");
    }

    @Override
    public void register(DynamicIncludeRegistry dynamicIncludeRegistry) {
        dynamicIncludeRegistry.register(
            "com.liferay.blogs.web#/blogs/view_entry.jsp#pre");
    }

}
\end{verbatim}

  Giving the class a \texttt{@Component} annotation that has the service
  attribute \texttt{service\ =\ DynamicInclude.class} makes the class a
  \texttt{DynamicInclude} service component.

\begin{verbatim}
@Component(
    immediate = true,
    service = DynamicInclude.class
)
\end{verbatim}

  In the \texttt{include} method, add your content. The example
  \texttt{include} method writes a heading.

\begin{verbatim}
@Override
public void include(
        HttpServletRequest request, HttpServletResponse response,
        String key)
    throws IOException {

    PrintWriter printWriter = response.getWriter();

    printWriter.println(
    "<h2>Added by Blogs Dynamic Include!</h2><br />");
}
\end{verbatim}

  In the \texttt{register} method, specify the dynamic include tag you
  want to use. The example register method targets the dynamic include
  at the top of the Blogs \texttt{view\_entry.jsp}.

\begin{verbatim}
@Override
public void register(DynamicIncludeRegistry dynamicIncludeRegistry) {
    dynamicIncludeRegistry.register(
        "com.liferay.blogs.web#/blogs/view_entry.jsp#pre");
}
\end{verbatim}
\end{enumerate}

Once you've
\href{/docs/7-0/tutorials/-/knowledge_base/t/starting-module-development\#building-and-deploying-a-module}{deployed
your module}, the overridden JSP dynamically includes your content.
Congratulations on injecting dynamic content into a JSP!

\section{JSP Overrides Using Portlet
Filters}\label{jsp-overrides-using-portlet-filters}

Portlet filters let you intercept portlet requests before they're
processed and portlet responses after they're processed but before
they're sent back to the client. You can operate on the request and / or
response to modify the JSP content. Unlike dynamic includes, portlet
filters give you access to all of the content sent back to the client.

We'll demonstrate using a portlet filter to modify content in Liferay's
Blogs portlet. For reference, you can download the
\href{https://portal.liferay.dev/documents/113763090/114000186/example-portlet-filter-customize-jsp-master.zip}{example
module}.

Create a new module and make sure it specifies these compile-only
dependencies, shown here in Gradle format:

\begin{verbatim}
dependencies {
    compileOnly group: "javax.portlet", name: "portlet-api", version: "2.0"
    compileOnly group: "javax.servlet", name: "javax.servlet-api", version: "3.0.1"
    compileOnly group: "com.liferay.portal", name: "com.liferay.portal.kernel", version: "2.0.0"
    compileOnly group: "org.osgi", name: "osgi.cmpn", version: "6.0.0"
}
\end{verbatim}

Create an OSGi component class that implements the
\texttt{javax.portlet.filter.RenderFilter} interface.

Here's an example portlet filter implementation for Blogs:

\begin{verbatim}
import java.io.IOException;

import javax.portlet.PortletException;
import javax.portlet.RenderRequest;
import javax.portlet.RenderResponse;
import javax.portlet.filter.FilterChain;
import javax.portlet.filter.FilterConfig;
import javax.portlet.filter.PortletFilter;
import javax.portlet.filter.RenderFilter;
import javax.portlet.filter.RenderResponseWrapper;

import org.osgi.service.component.annotations.Component;

import com.liferay.portal.kernel.util.PortletKeys;

@Component(
    immediate = true,
    property = {
            "javax.portlet.name=" + PortletKeys.BLOGS
    },
    service = PortletFilter.class
)
public class BlogsRenderFilter implements RenderFilter {

    @Override
    public void init(FilterConfig config) throws PortletException {

    }

    @Override
    public void destroy() {

    }

    @Override
    public void doFilter(RenderRequest request, RenderResponse response, FilterChain chain)
            throws IOException, PortletException {
        
        RenderResponseWrapper renderResponseWrapper = new BufferedRenderResponseWrapper(response);

        chain.doFilter(request, renderResponseWrapper);

        String text = renderResponseWrapper.toString();
        
        if (text != null) {
            String interestingText = "<input  class=\"field form-control\"";

            int index = text.lastIndexOf(interestingText);

            if (index >= 0) {
                String newText1 = text.substring(0, index);
                String newText2 = "\n<p>Added by Blogs Render Filter!</p>\n";
                String newText3 = text.substring(index);
                
                String newText = newText1 + newText2 + newText3;
                
                response.getWriter().write(newText);
            }
        }
    }

}
\end{verbatim}

Make your class a \texttt{PortletFilter} service component by giving it
the \texttt{@Component} annotation that has the service attribute
\texttt{service\ =\ PortletFilter.class}. Target the portlet whose
content you're overriding by assigning it a javax.portlet.name property
that's the same as your portlet's key. Here's the example
\texttt{@Component} annotation:

\begin{verbatim}
@Component(
   immediate = true,
   property = {
           "javax.portlet.name=" + PortletKeys.BLOGS
   },
   service = PortletFilter.class
)
\end{verbatim}

Override the \texttt{doFilterMethod} to operate on the request or
response to produce the content you want. The example appends a
paragraph stating \texttt{Added\ by\ Blogs\ Render\ Filter!} to the
portlet content:

\begin{verbatim}
@Override
public void doFilter(RenderRequest request, RenderResponse response, FilterChain chain)
        throws IOException, PortletException {

    RenderResponseWrapper renderResponseWrapper = new BufferedRenderResponseWrapper(response);

    chain.doFilter(request, renderResponseWrapper);

    String text = renderResponseWrapper.toString();

    if (text != null) {
        String interestingText = "<input  class=\"field form-control\"";

        int index = text.lastIndexOf(interestingText);

        if (index >= 0) {
            String newText1 = text.substring(0, index);
            String newText2 = "\n<p>Added by Blogs Render Filter!</p>\n";
            String newText3 = text.substring(index);

            String newText = newText1 + newText2 + newText3;

            response.getWriter().write(newText);
        }
    }
}
\end{verbatim}

The example uses a \texttt{RenderResponseWrapper} extension class called
\texttt{BufferedRenderResponseWrapper}.
\texttt{BufferedRenderResponseWrapper} is a helper class whose
\texttt{toString} method returns the current response text and whose
\texttt{getWriter} method lets you write data to the response before
it's sent back to the client.

\begin{verbatim}
import java.io.CharArrayWriter;
import java.io.IOException;
import java.io.OutputStream;
import java.io.PrintWriter;

import javax.portlet.RenderResponse;
import javax.portlet.filter.RenderResponseWrapper;

public class BufferedRenderResponseWrapper extends RenderResponseWrapper {

    public BufferedRenderResponseWrapper(RenderResponse response) {
        super(response);

        charWriter = new CharArrayWriter();
    }

    public OutputStream getOutputStream() throws IOException {
        if (getWriterCalled) {
            throw new IllegalStateException("getWriter already called");
        }

        getOutputStreamCalled = true;

        return super.getPortletOutputStream();
    }

    public PrintWriter getWriter() throws IOException {
        if (writer != null) {
            return writer;
        }

        if (getOutputStreamCalled) {
            throw new IllegalStateException("getOutputStream already called");
        }

        getWriterCalled = true;

        writer = new PrintWriter(charWriter);

        return writer;
    }

    public String toString() {
        String s = null;

        if (writer != null) {
            s = charWriter.toString();
        }

        return s;
    }

    protected CharArrayWriter charWriter;
    protected PrintWriter writer;
    protected boolean getOutputStreamCalled;
    protected boolean getWriterCalled;

}
\end{verbatim}

Once you've
\href{/docs/7-0/tutorials/-/knowledge_base/t/starting-module-development\#building-and-deploying-a-module}{deployed
your module}, the portlet's JSP shows your custom content.

Your portlet filter operates directly on portlet response content.
Unlike dynamic includes, portlet filters allow you to work with all of a
JSP's content.

\section{JSP Overrides Using OSGi
Fragments}\label{jsp-overrides-using-osgi-fragments}

You can completely override JSPs using OSGi fragments. This approach is
powerful but can make things unstable when the host module is upgraded:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  By overriding an entire JSP, you might not account for new content or
  new widgets that are essential to new host module versions.
\item
  Fragments are tied to a specific host module version. If the host
  module is upgraded, the fragment detaches from it. In this scenario,
  the original JSPs are still available and the module is functional
  (but lacks your JSP enhancements).
\end{enumerate}

\href{/docs/7-0/tutorials/-/knowledge_base/t/overriding-jsps\#using-liferays-api-to-override-a-jsp}{Liferay's
API based approaches to overriding JSPs}, on the other hand, provide
more stability as they let you customize specific parts of the JSP that
are safe to override. Also, the API based approaches don't limit your
override to a specific host module version. In case you're maintaining
existing JSP overrides that use OSGi fragments, however, this tutorial
explains how they work.

An OSGi fragment that overrides a JSP requires these two things:

\begin{itemize}
\item
  Specifies a host module's symbolic name and version in the OSGi header
  \texttt{Fragment-Host} declaration.
\item
  includes the original JSP with any modifications you need to make.
\end{itemize}

For more information about fragment modules, you can refer to section
3.14 of the
\href{https://www.osgi.org/developer/downloads/release-6/}{OSGi
Alliance's core specification document}.

\subsection{Declaring a Fragment Host}\label{declaring-a-fragment-host}

There are two players in this game: the fragment and the host. The
fragment is a parasitic module that attaches itself to a host. That
sounds harsh, so let's compare the fragment-host relationship to the
relationship between a pilot fish and a huge, scary shark. It's
symbiotic, really. Your fragment module benefits by not doing much work
(like the pilot fish who benefits from the shark's hunting prowess). In
return, the host module gets whatever benefits you've conjured up in
your fragment's JSPs (for the shark, it gets free dental cleanings!). To
the OSGi runtime, your fragment is part of the host module.

Your fragment must declare two things to the OSGi runtime regarding the
host module:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  The Bundle Symbolic Name of the host module.

  This is the module containing the original JSP.
\item
  The exact version of the host module to which the fragment belongs.
\end{enumerate}

Both are declared using the OSGi header \texttt{Fragment-Host}.

\begin{verbatim}
Fragment-Host: com.liferay.login.web;bundle-version="[1.0.0,1.0.1)"
\end{verbatim}

Supplying a specific host module version is important. If that version
of the module isn't present, your fragment won't attach itself to a
host, and that's a good thing. A new version of the host module might
have changed its JSPs, so if your now-incompatible version of the JSP is
applied to the host module, you'll break the functionality of the host.
It's better to detach your fragment and leave it lonely in the OSGi
runtime than it is to break the functionality of an entire application.

\subsection{Provide the Overridden
JSP}\label{provide-the-overridden-jsp}

There are two possible naming conventions for targeting the host
original JSP: \texttt{portal} or \texttt{original}. For example, if the
original JSP is in the folder \texttt{/META-INF/resources/login.jsp},
then the fragment bundle should contain a JSP with the same path, using
the following pattern:

\begin{verbatim}
<liferay-util:include 
    page="/login.original.jsp" (or login.portal.jsp) 
    servletContext="<%= application %>" 
/>
\end{verbatim}

After that, make your modifications. Just make sure you mimic the host
module's folder structure when overriding its JAR. If you're overriding
Liferay's login application's \texttt{login.jsp} for example, you'd put
your own \texttt{login.jsp} in

\begin{verbatim}
my-jsp-fragment/src/main/resources/META-INF/resources/login.jsp
\end{verbatim}

If you need to post-process the output, you can update the pattern to
include Liferay DXP's buffering mechanism. Below is an example that
overrides the original \texttt{create\_account.jsp}:

\begin{verbatim}
<%@ include file="/init.jsp" %>

<liferay-util:buffer var="html">
    <liferay-util:include page="/create_account.portal.jsp" 
    servletContext="<%= application %>"/>
</liferay-util:buffer>

<liferay-util:buffer var="openIdFieldHtml"><aui:input name="openId" 
type="hidden" value="<%= ParamUtil.getString(request, "openId") %>" />
</liferay-util:buffer>

<liferay-util:buffer var="userNameFieldsHtml"><liferay-ui:user-name-fields />
</liferay-util:buffer>

<liferay-util:buffer var="errorMessageHtml">
    <liferay-ui:error 
    exception="<%= com.liferay.portal.kernel.exception.NoSuchOrganizationException.class %>" message="no-such-registration-code" />
</liferay-util:buffer>

<liferay-util:buffer var="registrationCodeFieldHtml">
            <aui:input name="registrationCode" type="text" value="">
                    <aui:validator name="required" />
            </aui:input>
</liferay-util:buffer>

<%
    html = com.liferay.portal.kernel.util.StringUtil.replace(html, 
      openIdFieldHtml, openIdFieldHtml + errorMessageHtml);
    html = com.liferay.portal.kernel.util.StringUtil.replace(html, 
      userNameFieldsHtml, userNameFieldsHtml + registrationCodeFieldHtml);
%>

<%=html %>
\end{verbatim}

\noindent\hrulefill

\textbf{Note:} An OSGi fragment can access all of the fragment host's
packages---it doesn't need to import them from another bundle. bnd adds
external packages the fragment uses (even ones in the fragment host) to
the fragment's \texttt{Import-Package:\ {[}package{]},...} OSGi manifest
header. That's fine for packages exported to the OSGi runtime. The
problem is, however, when bnd tries to import a host's internal package
(a package the host doesn't export). The OSGi runtime can't activate the
fragment because the internal package remains an
\texttt{Unresolved\ \ requirement}---a fragment shouldn't import a
fragment host's packages.

If your fragment uses an internal package from the fragment host,
continue using it but explicitly exclude the package from your bundle's
\texttt{Import-Package} OSGi manifest header. This
\texttt{Import-Package} header, for example, excludes packages that
match \texttt{com.liferay.portal.search.web.internal.*}.

\begin{verbatim}
 Import-Package: !com.liferay.portal.search.web.internal.*,*
\end{verbatim}

\noindent\hrulefill

Now you can easily modify the JSPs of any application in Liferay.

\includegraphics{./images/sharks.jpg}

To see a sample JSP-modifying fragment in action, look at the
\href{https://github.com/liferay/liferay-blade-samples/tree/7.0/liferay-workspace/overrides/module-jsp-override}{BLADE
project named \texttt{module-jsp-override}}.

\subsection{Related Topics}\label{related-topics-56}

\href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-app-jsp-hook-plugins}{Upgrading
App JSP Hooks}

\section{JSP Overrides Using Custom JSP
Bag}\label{jsp-overrides-using-custom-jsp-bag}

\href{/docs/7-0/tutorials/-/knowledge_base/t/overriding-jsps\#using-liferays-api-to-override-a-jsp}{Liferay's
API based approaches to overriding JSPs} are the best way to override
JSPs in apps and in the core. You can also use Custom JSP Bags to
override core JSPs. But the approach is not as stable as the API based
approaches. If your Custom JSP Bag's JSP is buggy (because of your code
or because of a change in Liferay), you are most likely to find out at
runtime, where functionality breaks and nasty log errors greet you. In
the case that you're maintaining existing Custom JSP Bags, however, this
tutorial explains how they work.

A Custom JSP Bag module must satisfy these criteria:

\begin{itemize}
\item
  Includes a class that implements the
  \href{@platform-ref@/7.0-latest/javadocs/portal-impl/com/liferay/portal/deploy/hot/CustomJspBag.html}{\texttt{CustomJspBag}
  interface}.
\item
  Registers the service in the OSGi runtime.
\item
  Provides the JSP you're extending.
\end{itemize}

The module provides transportation for this code into Liferay's OSGi
runtime. When configuring it to build a proper JAR, map the path of the
JSPs in the JAR to their path in your module. In a \texttt{bnd.bnd} file
you could specify

\begin{verbatim}
-includeresource: META-INF/jsps=src/META-INF/custom_jsps
\end{verbatim}

If you're using the Maven
\href{https://maven.apache.org/guides/introduction/introduction-to-the-standard-directory-layout.html}{Standard
Directory Layout} and placing your JSPs under
\texttt{src/main/resources}, you can ignore the
\texttt{-includeresource} directive.

Any core JSPs you're customizing should be put into this folder, and the
rest of their path and their name must match exactly the path and name
of the JSP that's nested underneath \texttt{portal-web/docroot/html}.
For example, if you're overriding

\begin{verbatim}
portal-web/docroot/html/common/themes/bottom-ext.jsp 
\end{verbatim}

and you used the \texttt{includeresource} directive above, put the
overridden JSP in this folder of your module:

\begin{verbatim}
my-module/src/META-INF/custom_jsps/html/common/themes/bottom-ext.jsp
\end{verbatim}

\subsection{Implement a Custom JSP
Bag}\label{implement-a-custom-jsp-bag}

Create a class that implements \texttt{CustomJspBag}. The overall goal
is to make sure that Liferay (specifically the
\href{@platform-ref@/7.0-latest/javadocs/portal-impl/com/liferay/portal/deploy/hot/CustomJspBagRegistryUtil.html}{\texttt{CustomJspBagRegistryUtil}
class}) loads the JSPs from your module upon activation.

\begin{verbatim}
public class MyCustomJspBag implements CustomJspBag {
\end{verbatim}

When the Component is activated, you need to add the URL path for all
your custom core JSPs (by directory path) to a \texttt{List}.

\begin{verbatim}
    @Activate
    protected void activate(BundleContext bundleContext) {
        bundle = bundleContext.getBundle();

        _customJsps = new ArrayList<>();

        Enumeration<URL> entries = bundle.findEntries(
            getCustomJspDir(), "*.jsp", true);

        while (entries.hasMoreElements()) {
            URL url = entries.nextElement();

            _customJsps.add(url.getPath());
        }
    }

    ...

    private List<String> _customJsps;

    private Bundle bundle;
\end{verbatim}

In the custom JSP bag you'll need to override the following methods:

\begin{itemize}
\item
  \textbf{\texttt{getCustomJspDir}:} Return the directory path in your
  module's JAR where the JSPs are placed (for example,
  \texttt{META-INF/jsps}).
\item
  \textbf{\texttt{getCustomJsps}:} Return a List of the custom JSP URL
  paths.
\item
  \textbf{\texttt{getURLContainer}:} Return a new
  \texttt{com.liferay.portal.kernel.url.URLContainer}. Instantiate the
  URL container and override its \texttt{getResources} and
  \texttt{getResource} methods. The \texttt{getResources} method is for
  looking up all of the paths to resources in the container by a given
  path. It should return a \texttt{HashSet} of \texttt{Strings} for the
  matching custom JSP paths. The \texttt{getResource} method returns one
  specific resource by its name (the path included).
\item
  \textbf{\texttt{isCustomJspGlobal}:} Return \texttt{true}.
\end{itemize}

For an example of a full class that provides a working implementation of
a custom JSP bag, refer to the
\href{https://github.com/liferay/liferay-blade-samples/blob/master/gradle/overrides/core-jsp-override/src/main/java/com/liferay/blade/samples/corejsphook/BladeCustomJspBag.java}{core-jsp-override
BLADE project}.

\subsection{Register the Custom JSP
Bag}\label{register-the-custom-jsp-bag}

Register the custom JSP bag implementation from your module in the OSGi
runtime with three properties:

\begin{itemize}
\item
  \textbf{\texttt{context.id}:} Specify your custom JSP bag class name.
  For example, \texttt{MyCustomJspBag}.
\item
  \textbf{\texttt{contex.name}:} This should be a more human readable
  name, like \texttt{My\ Custom\ \ \ \ JSP\ Bag}.
\item
  \textbf{\texttt{service.ranking:integer}:} This will determine the
  priority of your implementation. If you specify \texttt{100} here, and
  one of your coworkers develops a separate custom JSP bag
  implementation and gives theirs a ranking of \texttt{101}, you're out
  of luck. Theirs will take precedence. Logically then, you should use
  \texttt{102}.
\end{itemize}

\subsection{Extend a JSP}\label{extend-a-jsp}

If you want to add something to a core JSP, see if it has an empty
\texttt{-ext.jsp} and override that instead of the whole JSP. It'll keep
things simpler and more stable, since the full JSP might change
significantly, breaking your customization in the process. By overriding
the \texttt{-ext.jsp}, you're only relying on the original JSP including
the \texttt{-ext.jsp}. For an example, open
\texttt{portal-web/docroot/html/common/themes/bottom.jsp}, and scroll to
the end. You'll see this:

\begin{verbatim}
<liferay-util:include page="/html/common/themes/bottom-ext.jsp" />
\end{verbatim}

If you need to add something to \texttt{bottom.jsp}, override
\texttt{bottom-ext.jsp}.

As of 7.0, the content from the following JSP files formerly in
\texttt{html/common/themes} are inlined to improve performance. ~ -
\texttt{body\_bottom-ext.jsp} - \texttt{body\_top-ext.jsp} -
\texttt{bottom-ext.jsp} - \texttt{bottom-test.jsp}

They're no longer explicit files in the code base. But you can still
create them in your module to add functionality and content.

Remember, this type of customization should be seen as a last resort.
There's a risk that your override will break due to the nature of this
implementation, and core functionality in Liferay can go down with it.
If the JSP you want to override is in another module, refer to the
section on
\href{/docs/7-0/tutorials/-/knowledge_base/t/overriding-jsps\#using-liferays-api-to-override-a-jsp}{API
based approaches to overriding JSPs}.

\subsection{Site Scoped JSP
Customization}\label{site-scoped-jsp-customization}

In Liferay Portal 6.2, you could use
\href{/docs/6-2/tutorials/-/knowledge_base/t/customizing-sites-and-site-templates-with-application-adapters}{Application
Adapters} to scope your core JSP customizations to a specific site.
Since the majority of JSPs were moved into modules for 7.0, the use case
for this has shrunk considerably. If you need to scope a core JSP
customization to a site, prepare an application adapter
\href{/docs/6-2/tutorials/-/knowledge_base/t/customizing-sites-and-site-templates-with-application-adapters}{as
you would have for Liferay Portal 6.2}, and deploy it to 7.0. It will
still work. However, note that this approach is deprecated in 7.0 and
won't be supported at all in Liferay 8.0.

\subsection{Related Topics}\label{related-topics-57}

\href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-core-jsp-hooks}{Upgrading
Core JSP Hooks}

\section{Overriding Liferay DXP's Default YUI and AUI
Modules}\label{overriding-liferay-dxps-default-yui-and-aui-modules}

Liferay DXP contains several default YUI/AUI modules. You may need to
override functionality provided by these module's scripts. It's possible
to
\href{/docs/7-0/tutorials/-/knowledge_base/t/overriding-a-modules-jsps}{override
JSPs using fragments}, but you can't with JavaScript files. Instead, you
create a custom AUI module containing three things:

\begin{itemize}
\tightlist
\item
  A copy of the original module's JavaScript file containing your
  modifications
\item
  A \texttt{config.js} file that specifies the modified JavaScript
  file's path and the module it overrides
\item
  A \texttt{bnd.bnd} file that tells the OSGi container to override the
  original
\end{itemize}

Follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/starting-module-development\#creating-a-module}{Create
  an OSGi module} to override the original one. For example, you can
  create a module named \texttt{session-js-override-web} to override
  Liferay DXP's \texttt{session.js} file.
\item
  Create a \texttt{src/main/resources/META-INF/resources/js} folder in
  your module, copy the original JavaScript file into it, and rename it.
  For example, create a copy of the \texttt{session.js} module and
  rename it \texttt{session-override.js}. Make sure you also rename the
  module definition inside the \texttt{session-override.js}, e.g.~
  \texttt{AUI().add(\textquotesingle{}liferay-session-override\textquotesingle{},\ ...}.
\item
  Apply your modifications and save the file.
\item
  Next, you'll
  \href{/docs/7-0/tutorials/-/knowledge_base/t/configuring-modules-for-products-loaders\#writing-the-configuration-file}{write
  your module's configuration file} (\texttt{config.js}) to apply your
  override. Add the \texttt{config.js} file to the module's
  \texttt{src/main/resources/META-INF/resources/js} folder. The example
  \texttt{config.js} file below specifies the \texttt{condition} that
  the
  \href{/docs/7-0/tutorials/-/knowledge_base/t/configuring-modules-for-products-loaders\#writing-the-configuration-file}{YUI/AUI
  Loader} should load the custom AUI module
  (\texttt{liferay-session-override}) \texttt{instead} (indicated with
  the \texttt{when} property) of the \texttt{trigger} module
  (\texttt{liferay-session}). You can follow this same pattern to create
  your module's \texttt{config.js} file:

\begin{verbatim}
;(function() {

    var base = MODULE_PATH + '/js/';

    AUI().applyConfig(
        {
            groups: {
                mymodulesoverride: { //mymodulesoverride
                    base: base,
                    combine: Liferay.AUI.getCombine(),
                    filter: Liferay.AUI.getFilterConfig(),
                    modules: {
                        'liferay-session-override': { //my-module-override
                            path: 'session-override.js', //my-module.js
                            condition: {
                                name: 'liferay-session-override', //my-module-override
                                trigger: 'liferay-session', //original module
                                when: 'instead'
                            }
                        }
                    },
                    root: base
                }
            }
        }
    );
})();
\end{verbatim}
\item
  Finally, you must configure your \texttt{bnd.bnd} file. For the system
  to apply the changes, you must specify the \texttt{config.js}'s
  location with the \texttt{Liferay-JS-Config} BND header. The
  \texttt{liferay-session-override} module from the previous example has
  the configuration below in its \texttt{bnd.bnd} file:

\begin{verbatim}
Bundle-Name: session-js-override
Bundle-SymbolicName: session.js.override.web
Bundle-Version: 1.0.0
Liferay-JS-Config:/META-INF/resources/js/config.js
Web-ContextPath: /liferay-session-override-web
\end{verbatim}
\end{enumerate}

Now you know how to override Liferay DXP's default YUI/AUI modules!

\subsection{Related Topics}\label{related-topics-58}

\href{/docs/7-0/tutorials/-/knowledge_base/t/overriding-jsps}{Overriding
JSPs}

\href{/docs/7-0/tutorials/-/knowledge_base/t/configuring-modules-for-products-loaders}{Configuring
Modules for Liferay DXP's Module Loaders}

\section{Overriding Liferay Services (Service
Wrappers)}\label{overriding-liferay-services-service-wrappers}

Why might you need to customize Liferay services? Perhaps you've added a
custom field to Liferay's \texttt{User} object and you want its value to
be saved whenever the \texttt{addUser} or \texttt{updateUser} methods of
Liferay's API are called. Or maybe you want to add some additional
logging functionality to some of Liferay's APIs. Whatever your case may
be, Liferay's service wrappers provide easy-to-use extension points for
customizing Liferay's services.

To create a module that overrides one of Liferay's services, follow the
\href{/docs/7-0/reference/-/knowledge_base/r/using-the-service-wrapper-template}{Service
Wrapper Template} reference article to create a \texttt{servicewrapper}
project type.

As an example, here's the \texttt{UserLocalServiceOverride} class that's
generated in the Service Wrapper Template tutorial:

\begin{verbatim}
package com.liferay.docs.serviceoverride;

import com.liferay.portal.kernel.service.UserLocalServiceWrapper;
import com.liferay.portal.kernel.service.ServiceWrapper;
import org.osgi.service.component.annotations.Component;

@Component(
    immediate = true,
    property = {
    },
    service = ServiceWrapper.class
)
public class UserLocalServiceOverride extends UserLocalServiceWrapper {

    public UserLocalServiceOverride() {
        super(null);
    }

}
\end{verbatim}

Notice that you must specify the fully qualified class name of the
service wrapper class that you want to extend. The \texttt{service}
argument was used in full in this import statement:

\begin{verbatim}
import com.liferay.portal.service.UserLocalServiceWrapper
\end{verbatim}

This import statement, in turn, allowed the short form of the service
wrapper class name to be used in the class declaration of your component
class:

\begin{verbatim}
public class UserLocalServiceOverride extends UserLocalServiceWrapper
\end{verbatim}

The bottom line is that when using \texttt{blade\ create} to create a
service wrapper project, you must specify a fully qualified class name
as the \texttt{service} argument. (This is also true when using
\texttt{blade\ create} to create a service project.) For information
about creating service projects, please see the
\href{/docs/7-0/tutorials/-/knowledge_base/t/service-builder}{Service
Builder} tutorial.

The generated \texttt{UserLocalServiceOverride} class does not actually
customize any Liferay service. Before you can test that your service
wrapper module actually works, you need to override at least one service
method.

Open your \texttt{UserLocalServiceOverride} class and add the following
methods:

\begin{verbatim}
@Override
public int authenticateByEmailAddress(long companyId, String emailAddress,
        String password, Map<String, String[]> headerMap,
        Map<String, String[]> parameterMap, Map<String, Object> resultsMap)
    throws PortalException {

    System.out.println(
        "Authenticating user by email address " + emailAddress);
    return super.authenticateByEmailAddress(companyId, emailAddress, password,
        headerMap, parameterMap, resultsMap);
}

@Override
public User getUser(long userId) throws PortalException {
    System.out.println("Getting user by id " + userId);
    return super.getUser(userId);
}
\end{verbatim}

Each of these methods overrides a Liferay service method. These
implementations merely add a few print statements that are executed
before the original service implementations are invoked.

Lastly, you must add the following method to the bottom of your service
wrapper so it can find the appropriate service it's overriding on
deployment.

\begin{verbatim}
@Reference(unbind = "-")
private void serviceSetter(UserLocalService userLocalService) {
    setWrappedService(userLocalService);
}
\end{verbatim}

Now you're ready to build your project. Navigate to your project's root
folder and run \texttt{../../gradlew\ build}. The JAR file representing
your portlet module is produced in your project's \texttt{build/libs}
directory.

To deploy your project, run this command from your project's root
directory:

\begin{verbatim}
blade deploy
\end{verbatim}

Blade CLI detects your locally running Liferay instance and deploys the
specified module to Liferay's module framework. After running the
\texttt{blade\ deploy} command, you should see a message like this:

\begin{verbatim}
Installed or updated bundle 334
\end{verbatim}

Use the Gogo shell to confirm that your module was installed: Run
\texttt{blade\ sh\ lb} at the prompt. If your module was installed,
you'll see an entry like this:

\begin{verbatim}
335|Active     |    1|com.liferay.docs.serviceoverride (1.0.0.201502122109)
\end{verbatim}

Finally, log into your portal as an administrator. Navigate to the Users
section of the Control Panel. Confirm that your customizations of
Liferay's user service methods have taken effect by checking Liferay's
log for the print statements that you added. Congratulations! You've
created and deployed a 7.0 service wrapper module!

\subsection{Related Topics}\label{related-topics-59}

\href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-service-wrappers}{Upgrading
Service Wrappers}

\href{/docs/7-0/tutorials/-/knowledge_base/t/installing-blade-cli}{Installing
Blade CLI}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-modules-with-blade-cli}{Creating
Modules with Blade CLI}

\section{Overriding Language Keys}\label{overriding-language-keys}

Liferay DXP Core and portlet module \texttt{language*.properties} files
implement site internationalization. They're fully customizable, too.
This tutorial demonstrates this in the following topics:

\begin{itemize}
\tightlist
\item
  Overriding Global Language Keys
\item
  Overriding a Module's Language Keys
\end{itemize}

\subsection{Modifying Global Language
Keys}\label{modifying-global-language-keys}

Language files contain
\href{/docs/7-0/tutorials/-/knowledge_base/t/localizing-your-application}{translations
of your application's user interface messages}. But you can also
override the default language keys globally and in other applications
(including your own). Here are the steps for overriding language keys:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \hyperref[determine-the-language-keys-to-override]{Determine the
  language keys to override}
\item
  \hyperref[override-the-keys-in-a-new-language-properties-file]{Override
  the keys in a new language properties file}
\item
  \hyperref[create-a-resource-bundle-service-component]{Create a
  Resource Bundle service component}
\end{enumerate}

\noindent\hrulefill

\textbf{Note:} Many applications that were once part of Liferay Portal
6.2 are now modularized. Their language keys might have been moved out
of Liferay's language properties files and into one of the application
modules. The process for
\hyperref[overriding-a-modules-language-keys]{overriding a module's
language keys} is different from the process for overriding global
language keys.

\noindent\hrulefill

\subsection{Determine the language keys to
override}\label{determine-the-language-keys-to-override}

So how do you find global language keys? They're in the
\texttt{Language{[}xx\_XX{]}.properties} files in the source code or
your Liferay DXP bundle.

\begin{itemize}
\item
  From the source:

  \texttt{/portal-impl/src/content/Language{[}\_xx\_XX{]}.properties}
\item
  From a bundle:

  \texttt{portal-impl.jar}
\end{itemize}

All language properties files contain properties you can override, like
the language settings properties:

\begin{verbatim}
##
## Language settings
##

...
lang.user.name.field.names=prefix,first-name,middle-name,last-name,suffix
lang.user.name.prefix.values=Dr,Mr,Ms,Mrs
lang.user.name.required.field.names=last-name
lang.user.name.suffix.values=II,III,IV,Jr,Phd,Sr
...
\end{verbatim}

There are also many simple keys you can override to update default
messages and labels.

\begin{verbatim}
##
## Category titles
##

category.admin=Admin
category.alfresco=Alfresco
category.christianity=Christianity
category.cms=Content Management
...
\end{verbatim}

For example, Figure 1 shows a button that uses Liferay's
\texttt{publish} default language key.

\begin{verbatim}
publish=Publish
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/standard-publish.png}
\caption{Messages displayed in Liferay's user interface can be
customized.}
\end{figure}

Next, you'll learn how to override this key.

\subsection{Override the keys in a new language properties
file}\label{override-the-keys-in-a-new-language-properties-file}

Once you know the keys to override, create a language properties file
for the locale you want (or the default \texttt{Language.properties}
file) in your module's \texttt{src/main/resources/content} folder. In
your file, define the keys your way. For example, you could override the
\texttt{publish} key.

\begin{verbatim}
publish=Publish Override
\end{verbatim}

To enable your change, you must create a resource bundle service
component to reference your language file.

\subsubsection{Create a Resource Bundle service
component}\label{create-a-resource-bundle-service-component}

In your module, create a class that extends
\texttt{java.util.ResourceBundle} for the locale you're overriding.
Here's an example resource bundle class for the \texttt{en\_US} locale:

\begin{verbatim}
@Component(
    property = { "language.id=en_US" }, 
    service = ResourceBundle.class
)
public class MyEnUsResourceBundle extends ResourceBundle {

    @Override
    protected Object handleGetObject(String key) {
        return _resourceBundle.getObject(key);
    }

    @Override
    public Enumeration<String> getKeys() {
        return _resourceBundle.getKeys();
    }

    private final ResourceBundle _resourceBundle = ResourceBundle.getBundle(
        "content.Language_en_US", UTF8Control.INSTANCE);

}
\end{verbatim}

The class's \texttt{\_resourceBundle} field is assigned a
\texttt{ResourceBundle}. The call to \texttt{ResourceBundle.getBundle}
needs two parameters. The \texttt{content.Language\_en\_US} parameter is
the language file's qualified name with respect to the module's
\texttt{src/main/resources} folder. The second parameter is a
\texttt{control} that sets the language syntax of the resource bundle.
To use language syntax identical to Liferay's syntax, import Liferay's
\texttt{com.liferay.portal.kernel.language.UTF8Control} class and set
the second parameter to \texttt{UTF8Control.INSTANCE}.

The class's \texttt{@Component} annotation declares it an OSGi
\texttt{ResourceBundle} service component. It's \texttt{language.id}
property designates it for the \texttt{en\_US} locale.

\begin{verbatim}
@Component(
    property = { "language.id=en_US" }, 
    service = ResourceBundle.class
)
\end{verbatim}

The class overrides these methods:

\begin{itemize}
\item
  \textbf{\texttt{handleGetObject}:} Looks up the key in the module's
  resource bundle (which is based on the module's language properties
  file) and returns the key's value as an \texttt{Object}.
\item
  \textbf{\texttt{getKeys}:} Returns an \texttt{Enumeration} of the
  resource bundle's keys.
\end{itemize}

Your resource bundle service component redirects the default language
keys to your module's language key overrides.

\noindent\hrulefill

\textbf{Note}: Global language key overrides for multiple locales
require a separate module for each locale. Each module's
\texttt{ResourceBundle} extension class (like the
\texttt{MyEnUsResourceBundle} class above) must specify its locale in
the \texttt{language.id} component property definition and in the
language file qualified name parameter. For example, here is what they
look like for the Spanish locale.

Component definition:

\begin{verbatim}
 @Component(
     property = { "language.id=es_ES" },
     service = ResourceBundle.class
 )
\end{verbatim}

Resource bundle assignment:

\begin{verbatim}
 private final ResourceBundle _resourceBundle = ResourceBundle.getBundle(
     "content.Language_es_ES", UTF8Control.INSTANCE);
\end{verbatim}

\noindent\hrulefill

\textbf{Important}: If your module
\href{/docs/7-0/tutorials/-/knowledge_base/t/localizing-your-application\#using-a-language-module}{uses
language keys from another module} and
\href{/docs/7-0/tutorials/-/knowledge_base/t/localizing-your-application\#using-a-language-module-from-a-module}{overrides
any of that other module's keys}, make sure to use OSGi headers to
specify the capabilities your module requires and provides. This lets
you prioritize resource bundles from the modules.

To see your Liferay language key overrides in action,
\href{/docs/7-0/tutorials/-/knowledge_base/t/starting-module-development\#building-and-deploying-a-module}{deploy
your module} and visit the portlets and pages that use the keys.

\begin{figure}
\centering
\includegraphics{./images/localized-publish.png}
\caption{This button uses the overridden \texttt{publish} key.}
\end{figure}

That's all there is to overriding global language keys.

\subsection{Overriding a Module's Language
Keys}\label{overriding-a-modules-language-keys}

What do you do if the language keys you want to modify are in one of
Liferay's applications or another module whose source code you don't
control? Since module language keys are in the respective module, the
process for overriding a module's language keys is different from
\hyperref[modifying-global-language-keys]{the process of overriding
global language keys}.

Here is the process:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \hyperref[find-the-module-and-its-metadata-and-language-keys]{Find the
  module and its metadata and language keys}
\item
  \hyperref[write-custom-language-key-values]{Write your custom language
  key values}
\item
  \hyperref[prioritize-your-modules-resource-bundle]{Prioritize your
  module's resource bundle}
\end{enumerate}

\subsubsection{Find the module and its metadata and language
keys}\label{find-the-module-and-its-metadata-and-language-keys}

In
\href{/docs/7-0/reference/-/knowledge_base/r/using-the-felix-gogo-shell}{Gogo
shell}, list the bundles and grep for keyword(s) that match the
portlet's display name. Language keys are in the portlet's web module
(bundle). When you find the bundle, note its ID number.

To find the Blogs portlet, for example, your Gogo commands and output
might look like this:

\begin{verbatim}
g! lb | grep Blogs
  152|Active     |    1|Liferay Blogs Service (1.0.2)
  184|Active     |    1|Liferay Blogs Editor Config (2.0.1)
  202|Active     |    1|Liferay Blogs Layout Prototype (2.0.2)
  288|Active     |    1|Liferay Blogs Recent Bloggers Web (1.0.2)
  297|Active     |    1|Liferay Blogs Item Selector Web (1.0.2)
  374|Active     |    1|Liferay Blogs Item Selector API (2.0.1)
  448|Active     |    1|Liferay Blogs API (3.0.1)
  465|Active     |    1|Liferay Blogs Web (1.0.6)
true
\end{verbatim}

List the bundle's headers by passing its ID to the \texttt{headers}
command.

\begin{verbatim}
g! headers 465

Liferay Blogs Web (465)
-----------------------
Manifest-Version = 1.0
Bnd-LastModified = 1459866186018
Bundle-ManifestVersion = 2
Bundle-Name = Liferay Blogs Web
Bundle-SymbolicName = com.liferay.blogs.web
Bundle-Version: 1.0.6
... 
Web-ContextPath = /blogs-web
g! 
\end{verbatim}

Note the \texttt{Bundle-SymbolicName}, \texttt{Bundle-Version}, and
\texttt{Web-ContextPath}. The \texttt{Web-ContextPath} value, following
the \texttt{/}, is the servlet context name.

\textbf{Important}: Record the servlet context name, bundle symbolic
name and version, as you'll use them to create the resource bundle
loader later in the process.

For example, here are those values for Liferay Blogs Web module:

\begin{itemize}
\tightlist
\item
  Bundle symbolic name: \texttt{com.liferay.blogs.web}
\item
  Bundle version: \texttt{1.0.6}
\item
  Servlet context name: \texttt{blogs-web}
\end{itemize}

Next find the module's JAR file so you can examine its language keys.
Liferay follows this module JAR file naming convention:

\begin{verbatim}
[bundle symbolic name]-[version].jar
\end{verbatim}

For example, the Blogs Web version 1.0.6 module is in
\texttt{com.liferay.blogs.web-1.0.6.jar}.

Here's where to find the module JAR:

\begin{itemize}
\tightlist
\item
  Liferay's
  \href{https://repository.liferay.com/nexus/content/repositories/liferay-public-releases/com/liferay/}{Nexus
  repository}
\item
  \texttt{{[}Liferay\ Home{]}/osgi/modules}
\item
  Embedded in an application's or application suite's LPKG file in
  \texttt{{[}Liferay\ \ \ \ \ Home{]}/osgi/marketplace}.
\end{itemize}

The language property files are in the module's
\texttt{src/main/resources/content} folder. Identify the language keys
you want to override in the \texttt{Language{[}\_xx{]}.properties}
files.

Checkpoint: Make sure you have the required information for overriding
the module's language keys:

\begin{itemize}
\tightlist
\item
  Language keys
\item
  Bundle symbolic name
\item
  Servlet context name
\end{itemize}

Next you'll write new values for the language keys.

\subsubsection{Write custom language key
values}\label{write-custom-language-key-values}

Create a new module to hold a resource bundle loader and your custom
language keys.

In your module's \texttt{src/main/resources/content} folder, create
\href{/docs/7-0/tutorials/-/knowledge_base/t/localizing-your-application\#what-are-language-keys}{language
properties files} for each locale whose keys you want to override. In
each language properties file, specify your language key overrides.

Next you'll prioritize your module's language keys as a resource bundle
for the target module.

\subsection{Prioritize Your Module's Resource
Bundle}\label{prioritize-your-modules-resource-bundle}

Now that your language keys are in place, use OSGi manifest headers to
specify the language keys are for the target module. To compliment the
target module's resource bundle, you'll aggregate your resource bundle
with the target module's resource bundle. You'll list your module first
to prioritize its resource bundle over the target module resource
bundle. Here's an example of module
\texttt{com.liferay.docs.l10n.myapp.lang} prioritizing its resource
bundle over target module \texttt{com.liferay.blogs.web}'s resource
bundle:

\begin{verbatim}
Provide-Capability:\
liferay.resource.bundle;resource.bundle.base.name="content.Language",\
liferay.resource.bundle;resource.bundle.aggregate:String="(bundle.symbolic.name=com.liferay.docs.l10n.myapp.lang),(bundle.symbolic.name=com.liferay.blogs.web)";bundle.symbolic.name=com.liferay.blogs.web;resource.bundle.base.name="content.Language";service.ranking:Long="2";\
servlet.context.name=blogs-web
\end{verbatim}

Let's examine the example \texttt{Provide-Capability} header.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \texttt{liferay.resource.bundle;resource.bundle.base.name="content.Language"}
  declares that the module provides a resource bundle whose base name is
  \texttt{content.language}.
\item
  The
  \texttt{liferay.resource.bundle;resource.bundle.aggregate:String=...}
  directive specifies the list of bundles whose resource bundles are
  aggregated, the target bundle, the target bundle's resource bundle
  name, and this service's ranking:

  \begin{itemize}
  \tightlist
  \item
    \texttt{"(bundle.symbolic.name=com.liferay.docs.l10n.myapp.lang),(bundle.symbolic.name=com.liferay.blogs.web)"}:
    The service aggregates resource bundles from bundles
    \texttt{com.liferay.docs.l10n.myapp.lang} and
    \texttt{com.liferay.blogs.web}. Aggregate as many bundles as
    desired. Listed bundles are prioritized in descending order.
  \item
    \texttt{bundle.symbolic.name=com.liferay.blogs.web;resource.bundle.base.name="content.Language"}:
    Override the \texttt{com.liferay.blogs.web} bundle's resource bundle
    named \texttt{content.Language}.
  \item
    \texttt{service.ranking:Long="2"}: The resource bundle's service
    ranking is \texttt{2}. The OSGi framework applies this service if it
    outranks all other resource bundle services that target
    \texttt{com.liferay.blogs.web}'s \texttt{content.Language} resource
    bundle.
  \item
    \texttt{servlet.context.name=blogs-web}: The target resource bundle
    is in servlet context \texttt{blogs-web}.
  \end{itemize}
\end{enumerate}

\href{/docs/7-0/tutorials/-/knowledge_base/t/starting-module-development\#building-and-deploying-a-module}{Deploy
your module} to see the language keys you've overridden.

\noindent\hrulefill

\textbf{Tip:} If your override isn't showing, use
\href{/docs/7-0/reference/-/knowledge_base/r/using-the-felix-gogo-shell}{Gogo
Shell} to check for competing resource bundle services. It may be that
another service outranks yours. To check for competing resource bundle
services whose aggregates include \texttt{com.liferay.blogs.web}'s
resource bundle, for example, execute this Gogo Shell command:

\begin{verbatim}
 services "(bundle.symbolic.name=com.liferay.login.web)"
\end{verbatim}

Search the results for resource bundle aggregate services whose ranking
is higher.

\noindent\hrulefill

Now you can modify the language keys of modules in Liferay's OSGi
runtime. Remember, language keys you want to override might actually be
in Liferay's core. You can
\hyperref[modifying-global-language-keys]{override global language keys}
too.

\subsection{Related Topics}\label{related-topics-60}

\href{/docs/7-0/reference/-/knowledge_base/r/resource-bundle-override}{Resource
Bundle Override Sample Project}

\href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-core-language-key-hooks}{Upgrading
Core Language Key Hooks}

\href{internationalization}{Internationalization}

\section{Overriding Portal Properties using a
Hook}\label{overriding-portal-properties-using-a-hook}

A portal properties hook plugin lets you override a subset of
\href{@platform-ref@/7.0-latest/propertiesdoc/portal.properties.html}{portal
properties} dynamically. These properties define event actions, model
listeners, validators, generators, and content sanitizers. The
\href{@platform-ref@/7.0-latest/definitions/liferay-hook_7_0_0.dtd.html}{\texttt{liferay-hook-7.0.dtd}
file} lists this subset of properties.

\noindent\hrulefill

\textbf{Note:} To customize a property that's not in the
\href{@platform-ref@/7.0-latest/definitions/liferay-hook_7_0_0.dtd.html}{\texttt{liferay-hook-7.0.dtd}
file}, you must use an
\href{/docs/7-0/tutorials/-/knowledge_base/t/advanced-customization-with-ext-plugins}{Ext
plugin}.

\noindent\hrulefill

Some portal properties accept \emph{multiple} values. For example, the
\texttt{login.event.pre} property defines action classes to invoke
before login. Deploying multiple hooks for properties like this appends
the values to the property's current value. For example, multiple hooks
that add login event actions append their action classes to the portal
instance's \texttt{login.event.pre} property. The
\href{@platform-ref@/7.0-latest/propertiesdoc/portal.properties.html}{portal
property reference documentation} shows whether a property accepts
multiple values by stating it or showing value lists assigned to a
default or example property setting.

Some portal properties accept a \emph{single} value only. For example,
the \texttt{terms.of.use.required} property is either \texttt{true} or
\texttt{false}. Override a single value property from one hook
only--there's no telling which value is assigned if multiple hooks
override it.

Here's how to override a portal property using a Hook:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a Hook plugin using
  \href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-ide}{Liferay
  @ide@} or
  \href{/docs/7-0/tutorials/-/knowledge_base/t/generating-new-projects-using-archetypes}{Maven}.
\item
  In the plugin's \texttt{WEB-INF/src} folder, create a
  \texttt{portal.properties} file and override properties with the
  values you want.
\item
  In the plugin's \texttt{WEB-INF/liferay-hook.xml} file, add the
  following \texttt{portal-properties} element as a child of the
  \texttt{hook} element. Refer to the
  \href{@platform-ref@/7.0-latest/definitions/liferay-hook_7_0_0.dtd.html}{\texttt{liferay-hook-7.0.dtd}
  file} for details.

\begin{verbatim}
<portal-properties>portal.properties</portal-properties>
\end{verbatim}
\item
  Deploy the plugin.
\end{enumerate}

You've modified the portal property. The
\href{/docs/7-0/user/-/knowledge_base/u/server-administration\#properties}{\emph{Server
Administration} page's \emph{Properties} screen} in the Control Panel
shows your new property setting.

\subsection{Related Topics}\label{related-topics-61}

\href{@platform-ref@/7.0-latest/propertiesdoc/portal.properties.html}{Portal
Properties Reference}

\href{/docs/7-0/user/-/knowledge_base/u/server-administration\#properties}{Server
Administration}

\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-ide}{Liferay @ide@}

\href{/docs/7-0/tutorials/-/knowledge_base/t/generating-new-projects-using-archetypes}{Generating
New Projects using Maven Archetypes}.

\section{Overriding MVC Commands}\label{overriding-mvc-commands}

MVC Commands are used to break up the controller layer of a Liferay MVC
application into smaller, more digestible code chunks.

Sometimes you'll want to override an MVC command, whether it's in a
Liferay application or another Liferay MVC application whose source code
you don't own. Since MVC commands are components registered in the OSGi
runtime, you can simply publish your own component, and give it a higher
service ranking. Your MVC command will then be invoked instead of the
original one.

The logical way of breaking up the controller layer is to do it by
portlet phase. The three MVC command classes you can override are

\begin{itemize}
\tightlist
\item
  \textbf{\href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/bridges/mvc/MVCActionCommand.html}{\texttt{MVCActionCommand}}:}
  An interface that allows the portlet to process a particular action
  request.
\item
  \textbf{\href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/bridges/mvc/MVCRenderCommand.html}{\texttt{MVCRenderCommand}}:}
  An interface that handles the render phase of the portlet.
\item
  \textbf{\href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/bridges/mvc/MVCResourceCommand.html}{\texttt{MVCResourceCommand}}:}
  An interface that allows the portlet to serve a resource.
\end{itemize}

Find more information about implementing each of these MVC command
classes in the tutorials on Liferay MVC Portlets. Here we're going to
focus on overriding the logic contained in existing MVC commands.

\noindent\hrulefill

\textbf{Note:} While it's possible to copy the logic from an existing
MVC command into your override class, then customize it to your liking,
it's strongly recommended to decouple the original logic from your
override logic. Keeping the override logic separate form the original
logic will keep the code clean, maintainable, and easy to understand.

To do this, use the \texttt{@Reference} method to fetch a reference to
the original MVC command component. If there are no additional
customizations on the same command, this reference will be the original
MVC command.

\begin{verbatim}
 @Reference(
     target = "(component.name=com.liferay.blogs.web.internal.portlet.action.EditEntryMVCRenderCommand)")
 protected MVCRenderCommand mvcRenderCommand;
\end{verbatim}

Set the \texttt{component.name} target to the MVC command class name. If
you use this approach, your extension will continue to work with new
versions of the original portlet, because no coupling exists between the
original portlet logic and your customization. The command
implementation class can change. Make sure to keep your reference
updated to the name of the current implementation class.

\noindent\hrulefill

\noindent\hrulefill

\textbf{Note:} In 7.0 GA1, there's a bug that occurs when modules with
override MVC commands are removed from the OSGi runtime. Instead of
looking for an MVC command with a lower service ranking (the original
MVC command in most cases) to replace the removed one, the reference to
the command is removed entirely. This bug is documented and fixed
\href{https://issues.liferay.com/browse/LPS-65434}{here}

\noindent\hrulefill

Start by learning to override \texttt{MVCRenderCommand}. The process
will be similar for the other MVC commands.

\subsection{Overriding
MVCRenderCommand}\label{overriding-mvcrendercommand}

You can override \texttt{MVCRenderCommand} for any portlet that uses
Liferay's MVC framework and publishes an \texttt{MVCRenderCommand}
component.

For example, Liferay's Blogs application has a class called
\href{https://github.com/liferay/liferay-portal/blob/7.0.6-ga7/modules/apps/collaboration/blogs/blogs-web/src/main/java/com/liferay/blogs/web/internal/portlet/action/EditEntryMVCRenderCommand.java}{\texttt{EditEntryMVCRenderCommand}},
with this component:

\begin{verbatim}
@Component(
    immediate = true,
    property = {
        "javax.portlet.name=" + BlogsPortletKeys.BLOGS,
        "javax.portlet.name=" + BlogsPortletKeys.BLOGS_ADMIN,
        "javax.portlet.name=" + BlogsPortletKeys.BLOGS_AGGREGATOR,
        "mvc.command.name=/blogs/edit_entry"
    },
    service = MVCRenderCommand.class
)
\end{verbatim}

This MVC render command can be invoked from any of the portlets
specified by the \texttt{javax.portlet.name} parameter, by calling a
render URL that names the MVC command.

\begin{verbatim}
<portlet:renderURL var="addEntryURL">
    <portlet:param name="mvcRenderCommandName" value="/blogs/edit_entry" />
    <portlet:param name="redirect" value="<%= viewEntriesURL %>" />
</portlet:renderURL>
\end{verbatim}

What if you want to override the command, but not for all of the
portlets listed in the original component? In your override component,
just list the \texttt{javax.portlet.name} of the portlets where you want
the override to take effect. For example, if you want to override the
\texttt{/blogs/edit\_entry} MVC render command just for the Blogs Admin
portlet (the Blogs Application accessed in the site administration
section of Liferay), your component could look like this:

\begin{verbatim}
@Component(
  immediate = true,
  property = {
     "javax.portlet.name=" + BlogsPortletKeys.BLOGS_ADMIN,
     "mvc.command.name=/blogs/edit_entry",
     "service.ranking:Integer=100"
  },
  service = MVCRenderCommand.class
)
\end{verbatim}

Note the last property listed, \texttt{service.ranking}. It's used to
tell the OSGi runtime which service to use, in cases where there are
multiple components registering the same service, with the same
properties. The higher the integer you specify here, the more weight
your component carries. In this case, the override component will be
used instead of the original one, since the default value for this
property is \texttt{0}.

After that, it's up to you to do whatever you'd like. You can add logic
to the existing \texttt{render} method or redirect to an entirely new
JSP.

\subsubsection{Adding Logic to an Existing MVC Render
Command}\label{adding-logic-to-an-existing-mvc-render-command}

Don't copy the existing logic from the MVC render command into your
override command class. This unnecessary duplication of code that makes
maintenance more difficult. If you want to do something new (like set a
request attribute) and then execute the logic in the original MVC render
command, obtain a reference to the original command and call its
\texttt{render} method like this:

\begin{verbatim}
@Override
public String render(RenderRequest renderRequest, 
                    RenderResponse renderResponse) throws PortletException {

    //Do something here

    return mvcRenderCommand.render(renderRequest, renderResponse);
}

@Reference(target = 
      "(component.name=com.liferay.blogs.web.internal.portlet.action.EditEntryMVCRenderCommand)")
  protected MVCRenderCommand mvcRenderCommand;
}
\end{verbatim}

Sometimes, you might need to redirect the request to an entirely new JSP
that you'll place in your command override module.

\subsubsection{Redirecting to a New JSP}\label{redirecting-to-a-new-jsp}

If you want to render an entirely new JSP, the process is different.

The \texttt{render} method of \texttt{MVCRenderCommand} returns the path
to a JSP as a String. The JSP must live in the original module, so you
cannot simply specify a path to a custom JSP in your override module.
You need to make the method skip dispatching to the original JSP
altogether, by using the \texttt{MVC\_PATH\_VALUE\_SKIP\_DISPATCH}
constant from the
\href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/bridges/mvc/MVCRenderConstants.html}{\texttt{MVCRenderConstants}
class}. Then you need to initiate your own dispatching process,
directing the request to your JSP path. Here's how that might look in
practice:

\begin{verbatim}
public class CustomEditEntryMVCRenderCommand implements MVCRenderCommand {

    @Override
    public String render
        (RenderRequest renderRequest, RenderResponse renderResponse) throws
        PortletException {

        System.out.println("Rendering custom_edit_entry.jsp");

        RequestDispatcher requestDispatcher =
            servletContext.getRequestDispatcher("/custom_edit_entry.jsp");

        try {
            HttpServletRequest httpServletRequest = 
                PortalUtil.getHttpServletRequest(renderRequest);
            HttpServletResponse httpServletResponse = 
                PortalUtil.getHttpServletResponse(renderResponse);

            requestDispatcher.include
                (httpServletRequest, httpServletResponse);
        } catch (Exception e) {
            throw new PortletException
                ("Unable to include custom_edit_entry.jsp", e);
        }

        return MVCRenderConstants.MVC_PATH_VALUE_SKIP_DISPATCH;
    }

    @Reference(target = "(osgi.web.symbolicname=com.custom.code.web)")
    protected ServletContext servletContext;

}
\end{verbatim}

In this approach, there's no reference to the original MVC render
command because the original logic isn't reused. Instead, there's a
reference to the servlet context of your module, which is needed to use
the request dispatcher.

A servlet context is automatically created for portlets. It can be
created for other modules by including the following line in your
\texttt{bnd.bnd} file:

\begin{verbatim}
Web-ContextPath: /custom-code-web
\end{verbatim}

Once we have the servlet context we just need to dispatch to the
specific JSP in our own module.

\subsection{Overriding
MVCActionCommand}\label{overriding-mvcactioncommand}

You can override MVC action commands using a similar process to the one
presented above for MVC render commands. Again, you'll register a new
OSGi component with the same properties, but with a higher service
ranking. This time the service you're publishing is
\texttt{MVCActionCommand.class}.

For MVC action command overrides, extend the
\href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/bridges/mvc/BaseMVCActionCommand.html}{\texttt{BaseMVCActionCommand}
class}, and the only method you'll need to override is
\texttt{doProcessAction}, which must return \texttt{void}.

As with MVC render commands, you can add your logic to the original
behavior of the action method by getting a reference to the original
service, and calling it after your own logic. Here's an example of an
\texttt{MVCActionCommand} override that checks whether the
\texttt{delete} action is invoked on a blog entry, and prints a message
to the log, before continuing with the original processing:

\begin{verbatim}
@Component(
    property = { 
        "javax.portlet.name=" + BlogsPortletKeys.BLOGS_ADMIN, 
        "mvc.command.name=/blogs/edit_entry",
        "service.ranking:Integer=100" 
    }, 
    service = MVCActionCommand.class)
public class CustomBlogsMVCActionCommand extends BaseMVCActionCommand {

    @Override
    protected void doProcessAction
        (ActionRequest actionRequest, ActionResponse actionResponse) 
        throws Exception {

        String cmd = ParamUtil.getString(actionRequest, Constants.CMD);

        if (cmd.equals(Constants.DELETE)) {
            System.out.println("Deleting a Blog Entry");
        }

        mvcActionCommand.processAction(actionRequest, actionResponse);
    }

    @Reference(
        target = "(component.name=com.liferay.blogs.web.internal.portlet.action.EditEntryMVCActionCommand)")

    protected MVCActionCommand mvcActionCommand;

}
\end{verbatim}

It's straightforward to override MVC action commands while keeping your
code decoupled from the original action methods. You can also override
MVC resource commands.

\subsection{Overriding
MVCResourceCommand}\label{overriding-mvcresourcecommand}

There are fewer uses for overriding MVC resource commands, but it can
also be done.

The process is similar to the one described for
\texttt{MVCRenderCommand} and \texttt{MVCActionCommand}. There's a
couple things to keep in mind:

\begin{itemize}
\item
  The service to specify in your component is
  \texttt{MVCResourceCommand.class}
\item
  As with overriding \texttt{MVCRenderCommand}, there's no base
  implementation class to extend. You'll implement the interface
  yourself.
\item
  Keep your code decoupled from the original code by adding your logic
  to the original \texttt{MVCResourceCommand}'s logic by getting a
  reference to the original and returning a call to its
  \texttt{serveResource} method:

\begin{verbatim}
  return mvcResourceCommand.serveResource(resourceRequest, resourceResponse);
\end{verbatim}
\end{itemize}

The following example overrides the behavior of
\texttt{com.liferay.login.web.portlet.action.CaptchaMVCResourceCommand},
from the \texttt{login-web} module of the Login portlet. It simply
prints a line in the console then executes the original logic: returning
the Captcha image for the account creation screen.

\begin{verbatim}
@Component(
    property = { 
        "javax.portlet.name=" + LoginPortletKeys.LOGIN,
        "mvc.command.name=/login/captcha" }, 
    service = MVCResourceCommand.class)
public class CustomCaptchaMVCResourceCommand implements MVCResourceCommand {

    @Override
    public boolean serveResource
        (ResourceRequest resourceRequest, ResourceResponse resourceResponse) {

        System.out.println("Serving login captcha image");

        return mvcResourceCommand.serveResource(resourceRequest, resourceResponse);
    }

    @Reference(target = "(component.name=com.liferay.login.web.internal.portlet.action.CaptchaMVCResourceCommand)")
    protected MVCResourceCommand mvcResourceCommand;

}
\end{verbatim}

And that, as they say, is that. Even if you don't own the source code of
an application, you can override its MVC commands just by knowing the
component class name.

\section{Overriding lpkg files}\label{overriding-lpkg-files}

Applications are delivered through Liferay Marketplace as \emph{lpkg}
files. This is a simple compressed file format that contains .jar files
to be deployed to Liferay DXP. If you want to examine an application
from Marketplace, all you have to do is unzip it to reveal the .jar
files it contains.

After examining them, you may want to
\href{/docs/7-0/tutorials/-/knowledge_base/t/customizing}{customize} one
of these applications. Make your customization, but don't deploy it the
way you'd normally deploy an application. Instead, Liferay DXP provides
a way to update application modules without modifying the original .lpkg
file they're packaged in, by overriding the .lpkg file. This only takes
a few steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Shut down Liferay DXP.
\item
  Create a folder called \texttt{override} in the Liferay DXP instance's
  \texttt{osgi/marketplace} folder.
\item
  Name your updated .jar the same as the .jar in the original .lpkg,
  minus the version information. For example, if you're overriding the
  \texttt{com.liferay.amazon.rankings.web-1.0.5.jar} from the
  \texttt{Liferay\ CE\ Amazon\ \ \ \ \ Rankings.lpkg}, you'd name your
  .jar \texttt{com.liferay.amazon.rankings.web.jar}.
\item
  Copy this .jar into the \texttt{override} folder you created in step
  one.
\end{enumerate}

This works for applications from Marketplace, but there's also the
static .lpkg that contains core Liferay technology and third-party
utilities (such as the servlet API, Apache utilities, etc.). If you find
you need to customize or patch any of these .jar files, deploying these
customizations is a similar process:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Make your customization and package your .jar file.
\item
  Name your updated .jar the same as the original .jar, minus the
  version information. For example, a customized
  \texttt{com.liferay.portal.profile-1.0.4.jar} should be
  \texttt{com.liferay.portal.profile.jar}.
\item
  Place this .jar in the \texttt{osgi/static} folder.
\end{enumerate}

Now start @product. Note that any time you add and remove .jars this
way, Liferay DXP must be shut down and then restarted to make the
changes take effect.

If you must roll back your customizations, delete the overriding .jar
files: Liferay DXP uses the original .jar on its next startup.

\section{Creating Model Listeners}\label{creating-model-listeners}

Model Listeners implement the
\href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/model/ModelListener.html}{\texttt{ModelListener}}
interface. They are used to listen for persistence events on models and
do something in response (either before or after the event).

Model listeners were designed to perform lightweight actions in response
to a \texttt{create}, \texttt{remove}, or \texttt{update} attempt on an
entity's database table or a mapping table (for example,
\texttt{users\_roles}). Here are some supported use cases:

\begin{itemize}
\tightlist
\item
  Audit Listener: In a separate database, record information about
  updates to an entity's database table.
\item
  Cache Clearing Listener: Clear caches that you've added to improve the
  performance of custom code.
\item
  Validation Listener: Perform additional validation on a model's
  attribute values before they are persisted to the database.
\item
  Entity Update Listener: Do some additional processing when an entity
  table is updated. For example, notify users when changes are made to
  their account.
\end{itemize}

There are also use cases that are not recommended, since they're likely
to break unpredictably and give you headaches:

\begin{itemize}
\tightlist
\item
  Setting a model's attributes in an \texttt{onBeforeUpdate} call. If
  some other database table has already been updated with the values
  before your model listener is invoked, your database will get out of
  sync. To change how an entity's attributes are set, consider using a
  \href{/docs/7-0/tutorials/-/knowledge_base/t/customizing-liferay-services-service-wrappers}{service
  wrapper} instead.
\item
  Wrapping a model. Model listeners are not called when fetching records
  from the database.
\item
  Creating worker threads to do parallel processing and querying data
  you updated via your listener. Model listeners are called
  \emph{before} the database transaction is complete (even the
  \texttt{onAfter...} methods), so the queries could be executed before
  the database transaction is completed.
\end{itemize}

If there is no existing listener on the model, your model listener is
the only one that runs. However, there can be multiple listeners on a
single model, and the order in which the listeners run cannot be
controlled.

You can create a model listener in a module by doing two simple things:

\begin{itemize}
\tightlist
\item
  Implement \texttt{ModelListener}
\item
  Register the service in Liferay's OSGi runtime
\end{itemize}

\subsection{Creating a Model Listener
Class}\label{creating-a-model-listener-class}

Create a \texttt{-ModelListener} class that extends
\texttt{BaseModelListener}.

\begin{verbatim}
package ...;

import ...;

public class CustomEntityListener extends BaseModelListener<CustomEntity> {

    /* Override one or more methods from the ModelListener 
        interface.
    */
    
}
\end{verbatim}

In the body of the class override any methods from the
\texttt{ModelListener} interface. The available methods are listed and
described at the end of this article.

In your model listener class, the parameterized type (for example,
\texttt{CustomEntity} in the snippet above) is used to tell the
listener's \texttt{ServiceTrackerCustomizer} which model class the
listener should be registered against.

\subsection{Register the Model Listener
Service}\label{register-the-model-listener-service}

Register the service with Liferay's OSGi runtime. If using Declarative
Services, set \texttt{service=\ ModelListener.class} and
\texttt{immediate=true} in the Component.

\begin{verbatim}
@Component(
    immediate = true,
    service = ModelListener.class
)
\end{verbatim}

That's all there is to preparing a model listener. Now learn what model
events you can respond to.

\subsection{Listening For Persistence
Events}\label{listening-for-persistence-events}

The \texttt{ModelListener} interface provides lots of opportunity to
listen for model events:

\begin{itemize}
\tightlist
\item
  \textbf{\texttt{onAfterAddAssociation}:} If there's an association
  between two models (if they have a mapping table), use this method to
  do something after an association record is added.
\item
  \textbf{\texttt{onAfterCreate}:} Use this method to do something after
  the persistence layer's \texttt{create} method is called.
\item
  \textbf{\texttt{onAfterRemove}:} Use this method to do something after
  the persistence layer's \texttt{remove} method is called.
\item
  \textbf{\texttt{onAfterRemoveAssociation}:} If there's an association
  between two models (if they have a mapping table), do something after
  an association record is removed.
\item
  \textbf{\texttt{onAfterUpdate}:} Use this method to do something after
  the persistence layer's \texttt{update} method is called.
\item
  \textbf{\texttt{onBeforeAddAssociation}:} If there's an association
  between two models (if they have a mapping table), do something before
  an addition to the mapping table.
\item
  \textbf{\texttt{onBeforeCreate}:} Use this method to do something
  before the persistence layer's \texttt{create} method is called.
\item
  \textbf{\texttt{onBeforeRemove}:} Use this method to do something
  before the persistence layer's \texttt{remove} method is called.
\item
  \textbf{\texttt{onBeforeRemoveAssociation}:} If there's an association
  between two models (if they have a mapping table), do something before
  a removal from the mapping table.
\item
  \textbf{\texttt{onBeforeUpdate}:} Use this method to do something
  before the persistence layer's \texttt{update} method is called.
\end{itemize}

Look in Liferay's \texttt{BasePersistenceImpl}, particularly the
\texttt{remove} and \texttt{update} methods, and you'll see how model
listeners are accounted for before (for the \texttt{onBefore...} case)
and after (for the \texttt{onAfter...} case) the model persistence
event.

Now that you know how to create model listeners, keep in mind that
they're useful as standalone projects or inside of your application. If
your application needs to do something (like add a custom entity) every
time a User is added in Liferay, you can include the model listener
inside your application.

\subsection{Related Topics}\label{related-topics-62}

\href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-model-listener-hooks}{Upgrading
Model Listener Hooks}

\chapter{Application Display
Templates}\label{application-display-templates}

The application display template (ADT) framework allows portal
administrators to override the default display templates, removing
limitations to the way your site's content is displayed. With ADTs, you
can define custom display templates used to render asset-centric
applications.

Usually, when you need to modify the UI of a Liferay portlet, you can do
so using a hook (e.g., HTML-related change) or a theme (e.g.,
CSS-related change). It'd be nice, however, if you could apply
particular display changes to specific portlet instances without having
to redeploy any plugins. Ideally, you should be able to provide
authorized portal users the ability to apply custom display interfaces
to portlets.

Be of good cheer! That's precisely what
\href{/docs/7-0/user/-/knowledge_base/u/styling-apps-with-application-display-templates}{Application
Display Templates} (ADTs) provide--the ability to add custom display
templates to your portlets from the portal. This isn't actually a new
concept in Liferay; some applications already had templating
capabilities (e.g., \emph{Web Content} and \emph{Dynamic Data Lists}),
in which you can already add as many display options (or templates) as
you want. Now you can add them to your custom portlets, too.

Some portlets that already support Application Display Templates in 7.0
are \emph{Asset Catgories Navigation}, \emph{Asset Publisher},
\emph{Asset Tags Navigation}, \emph{Blogs}, \emph{Media Gallery},
\emph{RSS}, \emph{Breadcrumb}, \emph{Language}, \emph{Navigation Menu},
\emph{SiteMap}, and \emph{Wiki}.

\section{Implementing Application Display
Templates}\label{implementing-application-display-templates}

\href{/docs/7-0/user/-/knowledge_base/u/styling-apps-with-application-display-templates}{Application
Display Templates} (ADTs) provide--the ability to add custom display
templates to your portlets from the portal. The figure below shows what
the Display Template option looks like in a portlet Configuration menu.

\begin{figure}
\centering
\includegraphics{./images/adt-dropdown.png}
\caption{By using a custom display template, your portlet's display can
be customized.}
\end{figure}

In this tutorial, you'll learn how to use the Application Display
Templates API to add an ADT to a portlet.

\subsection{Using the Application Display Templates
API}\label{using-the-application-display-templates-api}

To leverage the ADT API, there are several steps you need to follow.
These steps involve registering your portlet to use ADTs, defining
permissions, and exposing the ADT functionality to users. You'll walk
through these steps now:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create and register a custom \texttt{*PortletDisplayTemplateHandler}
  component. Liferay provides the
  \href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portletdisplaytemplate/BasePortletDisplayTemplateHandler.html}{BasePortletDisplayTemplateHandler}
  as a base implementation for you to extend. You can check the
  \href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/template/TemplateHandler.html}{TemplateHandler}
  interface Javadoc to learn about each template handler method.

  The Component annotation ties your handler to a specific portlet
  setting the property \texttt{javax.portlet.name} as the portlet name
  of your portlet. The same property should be found in your portlet
  class. For example:

\begin{verbatim}
 @Component(
     immediate = true,
     property = {
         "javax.portlet.name="+ AssetCategoriesNavigationPortletKeys.ASSET_CATEGORIES_NAVIGATION
     },
     service = TemplateHandler.class
 )
\end{verbatim}

  Each of the methods in this class have a significant role in defining
  and implementing ADTs for your custom portlet. View the list below for
  a detailed explanation for each method defined specifically for ADTs:

  \begin{itemize}
  \tightlist
  \item
    \textbf{getClassName():} Defines the type of entry your portlet is
    rendering.
  \item
    \textbf{getName():} Declares the name of your ADT type (typically,
    the name of the portlet).
  \item
    \textbf{getResourceName():} Specifies which resource is using the
    ADT (e.g., a portlet) for permission checking. This method must
    return the portlet's
    \href{/participate/liferaypedia/-/wiki/Main/Fully+Qualified+Portlet+ID}{Fully
    Qualified Portlet ID} (FQPI).
  \item
    \textbf{getTemplateVariableGroups():} Defines the variables exposed
    in the template editor.
  \end{itemize}

  As an example \texttt{*PortletDisplayTemplateHandler} implementation,
  you can look at
  \href{https://github.com/liferay/liferay-portal/blob/7.0.6-ga7/modules/apps/collaboration/wiki/wiki-web/src/main/java/com/liferay/wiki/web/internal/portlet/template/WikiPortletDisplayTemplateHandler.java}{WikiPortletDisplayTemplateHandler.java}.
\item
  Since the ability to add ADTs is new to your portlet, you must
  configure permissions so that administrative users can grant
  permissions to the roles that will be allowed to create and manage
  display templates. Add the action key
  \texttt{ADD\_PORTLET\_DISPLAY\_TEMPLATE} to your portlet's
  \texttt{/src/main/resources/resource-actions/default.xml} file:

\begin{verbatim}
 <?xml version="1.0"?>
 <!DOCTYPE resource-action-mapping PUBLIC "-//Liferay//DTD Resource Action Mapping 7.0.0//EN" "http://www.liferay.com/dtd/liferay-resource-action-mapping_7_0_0.dtd">
 <resource-action-mapping>

     ...

     <portlet-resource>
         <portlet-name>yourportlet</portlet-name>
         <permissions>
             <supports>
                 <action-key>ADD_PORTLET_DISPLAY_TEMPLATE</action-key>
                 <action-key>ADD_TO_PAGE</action-key>
                 <action-key>CONFIGURATION</action-key>
                 <action-key>VIEW</action-key>
             </supports>

             ...

         </permissions>
     </portlet-resource>

     ...

 </resource-action-mapping>
\end{verbatim}
\item
  Next, you need to make sure that Liferay can find the updated
  \texttt{default.xml} with the new resource action when you deploy the
  module. Create a file named \texttt{portlet.prtoperies} in the
  \texttt{/resources} folder and add the following contents providing
  the path to your \texttt{default.xml}:

\begin{verbatim}
 include-and-override=portlet-ext.properties
 resource.actions.configs=resource-actions/default.xml
\end{verbatim}
\item
  Now that your portlet officially supports ADTs, you'll want to expose
  the ADT option to your users. Just include the
  \texttt{\textless{}liferay-ui:ddm-template-selector\textgreater{}} tag
  in the JSP file you're using to control your portlet's configuration.

  For example, it may be helpful for you to insert an
  \texttt{\textless{}aui:fieldset\textgreater{}} in your configuration
  JSP file, like the following:

\begin{verbatim}
 <aui:fieldset>
     <div class="display-template">
         <liferay-ddm:template-selector
             classNameId="<%= YourEntity.class.getName() %>"
             displayStyle="<%= displayStyle %>"
             displayStyleGroupId="<%= displayStyleGroupId %>"
             refreshURL="<%= PortalUtil.getCurrentURL(request) %>"
             showEmptyOption="<%= true %>"
         />
     </div>
 </aui:fieldset>
\end{verbatim}

  In this JSP, the
  \texttt{\textless{}liferay-ddm:template-selector\textgreater{}} tag
  specifies the Display Template drop-down menu to be used in the
  portlet's Configuration menu. The variables \texttt{displayStyle} and
  \texttt{displayStyleGroupId} are preferences that your portlet stores
  when you use this taglib and your portlet uses the
  \href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/BaseJSPSettingsConfigurationAction.html}{BaseJSPSettingsConfigurationAction}
  or
  \href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/DefaultConfigurationAction.html}{DefaultConfigurationAction}.
  Otherwise, you would need to obtain the value of those parameters and
  store them manually in your configuration class.

  As an example JSP, see the Wiki application's
  \href{https://github.com/liferay/liferay-portal/blob/7.0.6-ga7/modules/apps/collaboration/wiki/wiki-web/src/main/resources/META-INF/resources/wiki/configuration.jsp}{configuration.jsp}.
\item
  You must now extend your view code to render your portlet with the
  selected ADT. This allows you to decide which part of your view will
  be rendered by the ADT and what will be available in the template
  context.

  First, initialize the Java variables needed for the ADT:

\begin{verbatim}
 <%
 String displayStyle = GetterUtil.getString(portletPreferences.getValue("displayStyle", StringPool.BLANK));
 long displayStyleGroupId = GetterUtil.getLong(portletPreferences.getValue("displayStyleGroupId", null), scopeGroupId);
 %>
\end{verbatim}

  Next, you can test if the ADT is configured, grab the entities to be
  rendered, and render them using the ADT. The tag
  \texttt{\textless{}liferay-ddm:template-renderer\textgreater{}} aids
  with this process. It will automatically use the selected template or
  render its body if no template is selected.

  Here's some example code that demonstrates implementing this:

\begin{verbatim}
 <liferay-ddm:template-renderer
     className="<%= YourEntity.class.getName() %>"
     contextObjects="<%= contextObjects %>"
     displayStyle="<%= displayStyle %>"
     displayStyleGroupId="<%= displayStyleGroupId %>"
     entries="<%= yourEntities %>"
 >

     <%-- The code that will be rendered by default when there is no
     template available should be inserted here. --%>

 </liferay-ddm:template-renderer>
\end{verbatim}

  In this step, you initialized variables dealing with the display
  settings (\texttt{displayStyle} and \texttt{displayStyleGroupId}) and
  passed them to the tag along with other parameterers listed below:

  \begin{itemize}
  \tightlist
  \item
    \texttt{className}: your entity's class name.
  \item
    \texttt{contextObjects}: accepts a
    \texttt{Map\textless{}String,\ Object\textgreater{}} with any object
    you want to the template context.
  \item
    \texttt{entries}: accepts a list of your entities (e.g.,
    \texttt{List\textless{}YourEntity\textgreater{}}).
  \end{itemize}

  For an example that demonstrates implementing this, see
  \href{https://github.com/liferay/liferay-portal/blob/7.0.6-ga7/modules/apps/web-experience/site-navigation/site-navigation-site-map-web/src/main/resources/META-INF/resources/configuration.jsp}{configuration.jsp}.
\end{enumerate}

Now that your portlet supports ADTs, you can create your own scripts to
change the display of your portlet. You can experiment by adding your
own custom ADT.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Navigate to Site Admin* → \emph{Configuration} → \emph{Application
  Display Templates}. Then select \emph{Add}
  (\includegraphics{./images/icon-add.png}) → \emph{Your Template}.
  Give your ADT a name and insert FreeMarker (like the following code)
  or Velocity code into the template editor, and click \emph{Save}:

\begin{verbatim}
 <#if entries?has_content>
     Quick List:
     <ul>
     <#list entries as curEntry>
         <li>${curEntry.name} - ${curEntry.streetAddress}, ${curEntry.city}, ${curEntry.stateOrProvince}</li>
     </#list>
     </ul>
 </#if>
\end{verbatim}
\item
  Go back to your portlet and select \emph{Options}
  (\includegraphics{./images/icon-app-options.png}) →
  \emph{Configuration} and click the \emph{Display Template} drop-down.
  Select the ADT you created, and click \emph{Save}.
\end{enumerate}

\begin{figure}
\centering
\includegraphics{./images/wiki-social-adt.png}
\caption{The example Social template for the Wiki application provides
extended social functionalities.}
\end{figure}

Once your script is uploaded into the portal and saved, users with the
specified roles can select the template when they're configuring the
display settings of your portlet on a page. You can visit the
\href{/docs/7-0/user/-/knowledge_base/u/styling-apps-with-application-display-templates}{Styling
Apps with Application Display Templates} section for more details on
using ADTs.

Next, we'll provide some recommendations for using ADTs in Liferay
Portal.

\subsection{Recommendations for Using
ADTs}\label{recommendations-for-using-adts}

You've harnessed a lot of power by learning to leverage the ADT API. Be
careful, for with great power, comes great responsibility! To that end,
you'll learn about some practices you can use to optimize your portlet's
performance and security.

First let's talk about security. You may want to hide some classes or
packages from the template context, to limit the operations that ADTs
can perform on your portal. Liferay provides some portal system
settings, which can be accessed by navigating to \emph{Control Panel} →
\emph{Configuration} → \emph{System Settings} → \emph{Foundation} →
\emph{FreeMarker/Velocity Engine}, to define the restricted classes,
packages, and variables. In particular, you may want to add
\texttt{serviceLocator} to the list of default values assigned to the
FreeMarker and Velocity Engine Restricted variables.

Application Display Templates introduce additional processing tasks when
your portlet is rendered. To minimize negative effects on performance,
make your templates as minimal as possible by focusing on the
presentation, while using the existing API for complex operations. The
best way to make Application Display Templates efficient is to know your
template context well, and understand what you can use from it.
Fortunately, you don't need to memorize the context information, thanks
to Liferay's advanced template editor!

To navigate to the template editor for ADTs, go to the Site Admin menu
and select \emph{Configuration} → \emph{Application Display Templates}
and then click \emph{Add} and select the specific portlet on which you
decide to create an ADT.

The template editor provides fields, general variables, and util
variables customized for the portlet you chose. These variable
references can be found on the left-side panel of the template editor.
You can use them by simply placing your cursor where you'd like the
variable placed, and clicking the desired variable to place it there.
You can learn more about the template editor in the
\href{/docs/7-0/user/-/knowledge_base/u/styling-apps-with-application-display-templates}{Styling
Apps with Application Display Templates} section.

Finally, don't forget to run performance tests and tune the template
cache options by modifying the \emph{Resource modification check} field
in \emph{System Settings} → \emph{Foundation} →
\emph{FreeMarker/Velocity Engine}.

The cool thing about ADTs is the power they provide to your Liferay
portlets, providing infinite ways of editing your portlet to provide new
interfaces for your portal users. You stepped through how to configure
ADTs for a custom portlet, tried out a sample template, and ran through
important recommendations for using ADTs, which included security and
performance.

\subsection{Related Topics}\label{related-topics-63}

\href{/docs/7-0/user/-/knowledge_base/u/styling-apps-with-application-display-templates}{Styling
Apps with Application Display Templates}

\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-javascript-apis}{Liferay
JavaScript APIs}

\href{/docs/7-0/tutorials/-/knowledge_base/t/internationalization}{Internationalization}

\chapter{Mobile}\label{mobile}

Liferay provides two ways to create native Android and iOS apps that
work with your Liferay instances: Liferay Screens and the Liferay Mobile
SDK. Liferay Screens does this via ready-to-use components called
\emph{Screenlets}. Since Screenlets already contain the code required to
call your Liferay instance--and a complete UI--all you need to do is
insert and configure them in your Android or iOS app. Screens provides
Screenlets for common tasks such as logging in, viewing web content,
adding DDL records, and more. You can also customize each Screenlet to
fit your specific needs, or write your own Screenlet. Behind the scenes,
Screenlets use the Liferay Mobile SDK to call Liferay's remote services.

The Liferay Mobile SDK is a lower-level tool that lets you manually
invoke Liferay's remote services. You'll need to use the Mobile SDK to
write your own Screenlets, or call Liferay's remote services independent
of Screens. In most cases, you'll find that using Screens saves you time
and effort. For example, although you can use the Mobile SDK to
implement login in your app, Screens already provides this via Login
Screenlet. There are certain cases, however, where using the Mobile SDK
makes sense. For example, if you need to call one or more Liferay remote
services but your app's UI doesn't need to reflect this, then it doesn't
make sense to use Screenlets for this purpose. Each Screenlet must
contain a UI.

Regardless of your specific needs, Liferay has you covered with Liferay
Screens and the Liferay Mobile SDK. This section of tutorials contains
the following sections that show you how to use both:

\begin{itemize}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/android-apps-with-liferay-screens}{Android
  Apps with Liferay Screens}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/ios-apps-with-liferay-screens}{iOS
  Apps with Liferay Screens}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/using-xamarin-with-liferay-screens}{Using
  Xamarin with Liferay Screens}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/mobile-sdk}{Liferay
  Mobile SDK}
\end{itemize}

Venture forth to become a mobile guru!

\chapter{Android Apps with Liferay
Screens}\label{android-apps-with-liferay-screens}

Liferay Screens speeds up and simplifies developing native mobile apps
that use Liferay. Its power lies in its \emph{Screenlets}. A Screenlet
is a visual component that you insert into your native app to leverage
Liferay Portal's content and
\href{/docs/7-0/tutorials/-/knowledge_base/t/invoking-remote-services}{services}.
On Android, Screenlets are available to log in to your portal, create
accounts, submit forms, display content, and more. You can use any
number of Screenlets in your app; they're independent, so you can use
them in modular fashion. Screenlets on Android also deliver UI
flexibility with pluggable \emph{Views} that implement elegant user
interfaces. Liferay's reference documentation for
\href{/docs/7-0/reference/-/knowledge_base/r/screenlets-in-liferay-screens-for-android}{Android}
Screenlets describes each Screenlet's features and Views.

You might be thinking, ``These Screenlets sound like the greatest thing
since taco Tuesdays, but what if they don't fit in with my app's UI?
What if they don't behave exactly how I want them to? What if there's no
Screenlet for what I want to do?'' Fret not! You can customize
Screenlets to fit your needs by changing or extending their UI and
behavior. You can even write your own Screenlets! What's more, Screens
seamlessly integrates with your existing Android projects.

\begin{figure}
\centering
\includegraphics{./images/screens-android-intro.png}
\caption{Here's an app that uses a Liferay Screens Sign Up Screenlet.}
\end{figure}

Screenlets leverage the
\href{https://www.liferay.com/community/liferay-projects/liferay-mobile-sdk/overview}{Liferay
Mobile SDK} to make server calls. The Mobile SDK is a low-level layer on
top of the Liferay JSON API. To write your own Screenlets, you must
familiarize yourself with Liferay's
\href{/docs/7-0/tutorials/-/knowledge_base/t/invoking-remote-services}{remote
services}. If no existing Screenlet meets your needs, consider
customizing an existing Screenlet, creating a Screenlet, or directly
using the Mobile SDK. Creating a Screenlet involves writing Mobile SDK
calls and constructing the Screenlet; if you don't plan to reuse or
distribute the implementation then you may want to forgo writing a
Screenlet and, instead, work with the
\href{/docs/7-0/tutorials/-/knowledge_base/t/mobile-sdk}{Mobile SDK}. A
benefit of integrating an existing Screenlet into your app, however, is
that the Mobile SDK's details are abstracted from you.

These tutorials show you how to use, customize, create, and distribute
Screenlets for Android. They show you how to create Views too. There's
even a tutorial that explains the nitty-gritty details of the Liferay
Screens architecture. No matter how deep you want to go, you'll use
Screenlets in no time. Start by preparing your
\href{/docs/7-0/tutorials/-/knowledge_base/t/preparing-android-projects-for-liferay-screens}{Android
project} to use Liferay Screens.

\section{Preparing Android Projects for Liferay
Screens}\label{preparing-android-projects-for-liferay-screens}

To use Liferay Screens, you must install it in your Android project and
then configure it to communicate with your Liferay DXP instance. Note
that Screens is released as an
\href{http://tools.android.com/tech-docs/new-build-system/aar-format}{AAR}
file hosted in jCenter.

There are three different ways to install Screens. This tutorial shows
you each:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  With Gradle: Gradle is the build system Android Studio uses to build
  Android projects. We therefore recommend that you use it to install
  Screens.
\item
  With Maven
\item
  Manually
\end{enumerate}

\noindent\hrulefill

\textbf{Note:} After installation, you must configure Liferay Screens to
communicate with your Liferay DXP instance. The last section in this
tutorial shows you how to do this.

\noindent\hrulefill

\subsection{Requirements}\label{requirements}

Liferay Screens for Android includes the Component Library (the
Screenlets) and a sample project. It requires the following software:

\begin{itemize}
\tightlist
\item
  Android Studio 3.0 or above.
\item
  Android SDK 4.1 (API Level 16) or above.
\item
  \href{http://www.liferay.com/downloads/liferay-portal/available-releases}{Liferay
  Portal 6.2 CE/EE, Liferay CE Portal 7.0/7.1, or Liferay DXP 7.0}
\item
  Liferay Screens Compatibility Plugin
  (\href{http://www.liferay.com/marketplace/-/mp/application/54365664}{CE}
  or
  \href{http://www.liferay.com/marketplace/-/mp/application/54369726}{DXP/EE},
  depending on your portal edition). This app is preinstalled in Liferay
  CE Portal 7.0/7.1 CE and Liferay DXP 7.0.
\item
  Liferay Screens source code.
\end{itemize}

Liferay Screens for Android uses
\href{https://github.com/greenrobot/EventBus}{EventBus} internally.

\subsection{Securing JSON Web
Services}\label{securing-json-web-services}

Each Screenlet in Liferay Screens calls one or more of Liferay DXP's
JSON web services, which are enabled by default. The Screenlet
\href{/docs/7-0/reference/-/knowledge_base/r/screenlets-in-liferay-screens-for-android}{reference
documentation} lists the web services that each Screenlet calls. To use
a Screenlet, its web services must be enabled in the portal. It's
possible, however, to disable the web services needed by Screenlets
you're not using. For instructions on this, see the tutorial
\href{/docs/7-0/tutorials/-/knowledge_base/t/portal-configuration-of-json-web-services}{Configuring
JSON Web Services}. You can also use
\href{/docs/7-0/tutorials/-/knowledge_base/t/service-access-policies}{Service
Access Policies} for more fine-grained control over accessible services.

\subsection{Using Gradle to Install Liferay
Screens}\label{using-gradle-to-install-liferay-screens}

To use Gradle to install Liferay Screens in your Android Studio project,
you must edit your app's \texttt{build.gradle} file. Note that your
project has two \texttt{build.gradle} files: one for the project and
another for the app module. You can find them under Gradle Scripts in
your Android Studio project. This screenshot highlights the app module's
\texttt{build.gradle} file:

\begin{figure}
\centering
\includegraphics{./images/screens-android-gradle-app-module.png}
\caption{The app module's \texttt{build.gradle} file.}
\end{figure}

In the app module's \texttt{build.gradle} file, add the following line
of code inside the \texttt{dependencies} element:

\begin{verbatim}
implementation 'com.liferay.mobile:liferay-screens:+'
\end{verbatim}

Note that the \texttt{+} symbol tells Gradle to install the newest
version of Screens. If your app relies on a specific version of Screens,
you can replace the \texttt{+} symbol with that version.

If you're not sure where to add the above lines, see the below
screenshot.

Once you edit \texttt{build.gradle}, a message appears at the top of the
file that asks you to \emph{sync} your app with its Gradle files.
Syncing the Gradle files incorporates the changes you make to them.
Syncing also downloads and installs any new dependencies, like the
Liferay Screens dependency that you just added. Sync the Gradle files
now by clicking the \emph{Sync Now} link in the message. The following
screenshot shows the top of an edited \texttt{build.gradle} file with
the Sync Now link highlighted by a red box:

\begin{figure}
\centering
\includegraphics{./images/screens-android-gradle-sync.png}
\caption{After editing the app module's \texttt{build.gradle} file,
click \emph{Sync Now} to incorporate the changes in your app.}
\end{figure}

In the case of conflict with the \texttt{appcompat-v7} or other support
libraries (\texttt{com.android.support:appcompat-v7},
\texttt{com.android.support:support-v4}), you have several options:

\begin{itemize}
\item
  Explicitly add the versions of the conflicting libraries you want to
  use. For example:

\begin{verbatim}
implementation 'com.android.support:design:27.0.2'
implementation 'com.android.support:support-media-compat:27.0.2'
implementation 'com.android.support:exifinterface:27.0.2'
\end{verbatim}
\item
  Remove the \texttt{com.android.support:appcompat-v7} dependency from
  your project and use the one embedded in Liferay Screens.
\item
  Exclude the problematic library from Liferay Screens. For example:

\begin{verbatim}
implementation ('com.liferay.mobile:liferay-screens:+') {
    exclude group: 'com.android.support:', module: 'design'
}
\end{verbatim}
\item
  Ignore the inspection, adding a comment like this:

\begin{verbatim}
//noinspection GradleCompatible
\end{verbatim}
\item
  Ignore the warning--Liferay Screens will work without problems.
\end{itemize}

Although we strongly recommend that you use Gradle to install Screens,
the following section shows you how to install Screens with Maven.

\subsection{Using Maven to Install Liferay
Screens}\label{using-maven-to-install-liferay-screens}

Note that we strongly recommend that you use Gradle to install Screens.
It's possible though to use Maven to install Screens. Follow these steps
to configure Liferay Screens in a Maven project:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add the following dependency to your \texttt{pom.xml}:

\begin{verbatim}
 <dependency>
     <groupId>com.liferay.mobile</groupId>
     <artifactId>liferay-screens</artifactId>
     <version>LATEST</version>
 </dependency>
\end{verbatim}
\item
  Force a Maven update to download all the dependencies.
\end{enumerate}

If Maven doesn't automatically locate the artifact, you must add jCenter
as a new repository in your maven settings (e.g.,
\texttt{.m2/settings.xml} file):

\begin{verbatim}
<profiles>
    <profile>
        <repositories>
            <repository>
                <id>bintray-liferay-liferay-mobile</id>
                <name>bintray</name>
                <url>http://dl.bintray.com/liferay/liferay-mobile</url>
            </repository>
        </repositories>
        <pluginRepositories>
            <pluginRepository>
                <id>bintray-liferay-liferay-mobile</id>
                <name>bintray-plugins</name>
                <url>http://dl.bintray.com/liferay/liferay-mobile</url>
            </pluginRepository>
        </pluginRepositories>
        <id>bintray</id>
    </profile>
</profiles>
<activeProfiles>
    <activeProfile>bintray</activeProfile>
</activeProfiles>
\end{verbatim}

Nice work!

\subsection{Manual Configuration in
Gradle}\label{manual-configuration-in-gradle}

Although we strongly recommend that you use Gradle to install Screens
automatically, it's possible to use Gradle to install Screens manually.
Follow these steps to use Gradle to install Screens and its dependencies
manually in your Android project:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \href{https://github.com/liferay/liferay-screens/releases}{Download}
  the latest version of Liferay Screens for Android.
\item
  Copy the contents of \texttt{Android/library} into a folder outside
  your project.
\item
  In your project, configure a \texttt{settings.gradle} file with the
  paths to the library folders:

\begin{verbatim}
 include ':core'
 project(':core').projectDir = new File(settingsDir, '../../library/core')
 project(':core').name = 'liferay-screens'
\end{verbatim}
\item
  Include the required dependencies in your \texttt{build.gradle} file:

\begin{verbatim}
 implementation project(':liferay-screens')
\end{verbatim}
\end{enumerate}

You can also configure the \texttt{.aar} binary files (in
\texttt{Android/dist}) as local \texttt{.aar} file dependencies. You can
download all necessary files from
\href{https://bintray.com/liferay/liferay-mobile/liferay-screens/view}{jCenter}.

To check your configuration, you can compile and execute a blank
activity and import a Liferay Screens class (like Login Screenlet).

Next, you'll set up communication with Liferay DXP.

\subsection{Configuring Communication with Liferay
DXP}\label{configuring-communication-with-liferay-dxp-1}

Before using Liferay Screens, you must configure it to communicate with
your Liferay DXP instance. To do this, you must provide Screens the
following information:

\begin{itemize}
\item
  Your Liferay DXP instance's ID
\item
  The ID of the site your app needs to communicate with
\item
  Your Liferay DXP instance's version
\item
  Any other information required by specific Screenlets
\end{itemize}

Fortunately, this is straightforward. In your Android project's
\texttt{res/values} folder, create a new file called
\texttt{server\_context.xml}. Add the following code to the new file:

\begin{verbatim}
<?xml version="1.0" encoding="utf-8"?>
<resources>

    <!-- Change these values for your Liferay DXP installation -->

    <string name="liferay_server">http://10.0.2.2:8080</string>

    <string name="liferay_company_id">10155</string>
    <string name="liferay_group_id">10182</string>
    
    <integer name="liferay_portal_version">70</integer>

</resources>
\end{verbatim}

As the above comment indicates, make sure to change these values to
match your Liferay DXP instance. The server address
\texttt{http://10.0.2.2:8080} is suitable for testing with Android
Studio's emulator, because it corresponds to \texttt{localhost:8080}
through the emulator. If you're using the Genymotion emulator, you
should, however, use address \texttt{192.168.56.1} instead of
\texttt{localhost}.

The \texttt{liferay\_company\_id} value is your Liferay DXP instance's
ID. You can find it in your Liferay DXP instance at \emph{Control Panel}
→ \emph{Configuration} → \emph{Virtual Instances}. The instance's ID is
in the \emph{Instance ID} column. Copy and paste this value into the
\texttt{liferay\_company\_id} value in \texttt{server\_context.xml}.

The \texttt{liferay\_group\_id} value is the ID of the site your app
needs to communicate with. To find this value, first go to the site in
your Liferay DXP instance that you want your app to communicate with. In
the \emph{Site Administration} menu, select \emph{Configuration} →
\emph{Site Settings}. The site ID is listed at the top of the
\emph{General} tab. Copy and paste this value into the
\texttt{liferay\_group\_id} value in \texttt{server\_context.xml}.

The \texttt{liferay\_portal\_version} value \texttt{70} tells Screens
that it's communicating with a Liferay CE Portal 7.0 or Liferay DXP 7.0
instance. Here are the supported \texttt{liferay\_portal\_version}
values and the portal versions they correspond to:

\begin{itemize}
\tightlist
\item
  \texttt{71}: Liferay CE Portal 7.1 or Liferay DXP 7.1
\item
  \texttt{70}: Liferay CE Portal 7.0 or Liferay DXP 7.0
\item
  \texttt{62}: Liferay Portal 6.2 CE/EE
\end{itemize}

You can also configure Screenlet properties in your
\texttt{server\_context.xml} file. The example properties listed below,
\texttt{liferay\_recordset\_id} and \texttt{liferay\_recordset\_fields},
enable DDL Form Screenlet and DDL List Screenlet to interact with a
Liferay DXP instance's DDLs. You can see an additional example
\texttt{server\_context.xml} file
\href{https://github.com/liferay/liferay-screens/blob/master/android/samples/bankofwesteros/src/main/res/values/server_context.xml}{here}.

\begin{verbatim}
<!-- Change these values for your Liferay DXP installation -->

<string name="liferay_recordset_id">20935</string>
<string name="liferay_recordset_fields">Title</string>
\end{verbatim}

Super! Your Android project's ready for Liferay Screens.

\subsection{Example Apps}\label{example-apps}

As you use Screens to develop your apps, you may want to refer to some
example apps that also use it. There are two demo applications
available:

\begin{itemize}
\tightlist
\item
  \href{https://github.com/liferay/liferay-screens/tree/master/android/samples/test-app}{test-app}:
  A showcase app containing all the currently available Screenlets.
\item
  \href{https://github.com/liferay/liferay-screens/tree/master/android/samples/bankofwesteros}{Westeros
  Bank}: An example app that uses Screenlets to manage technical issues
  for the \emph{Westeros Bank}. It's also available in
  \href{https://play.google.com/store/apps/details?id=com.liferay.mobile.screens.bankofwesteros}{Google
  Play}.
\end{itemize}

Great! Now you're ready to put Screens to use. The following tutorials
show you how to do this.

\subsection{Related Topics}\label{related-topics-64}

\href{/docs/7-0/tutorials/-/knowledge_base/t/using-screenlets-in-android-apps}{Using
Screenlets in Android Apps}

\href{/docs/7-0/tutorials/-/knowledge_base/t/using-views-in-android-screenlets}{Using
Views in Android Screenlets}

\href{/docs/7-0/tutorials/-/knowledge_base/t/preparing-ios-projects-for-liferay-screens}{Preparing
iOS Projects for Liferay Screens}

\section{Using Screenlets in Android
Apps}\label{using-screenlets-in-android-apps}

You can start using Screenlets once you've
\href{/docs/7-0/tutorials/-/knowledge_base/t/preparing-android-projects-for-liferay-screens}{prepared}
your project to use Liferay Screens. There are plenty of Liferay
Screenlets available and they're described in the Screenlet
\href{/docs/7-0/reference/-/knowledge_base/r/screenlets-in-liferay-screens-for-android}{reference
documentation}. It is very straightforward to use Screenlets. This
tutorial shows you how to insert Screenlets into your android app and
configure them. You'll be a Screenlet master in no time!

First, in Android Studio's visual layout editor or your favorite editor,
open your app's layout XML file and insert the Screenlet in your
activity or fragment layout. The following screenshot, for example,
shows the Login Screenlet inserted in an activity's
\texttt{FrameLayout}.

\begin{figure}
\centering
\includegraphics{./images/screens-android-insert-screenlet.png}
\caption{Here's the Login Screenlet in an activity's layout in Android
Studio.}
\end{figure}

Next, set the Screenlet's attributes. If it's a Liferay Screenlet, refer
to the Screenlet
\href{/docs/7-0/reference/-/knowledge_base/r/screenlets-in-liferay-screens-for-android}{reference
documentation} to learn the Screenlet's required and supported
attributes. This screenshot shows the attributes of the Login Screenlet
being set:

\begin{figure}
\centering
\includegraphics{./images/screens-android-screenlet-attributes.png}
\caption{You can set a Screenlet's attributes via the app's layout XML
file.}
\end{figure}

To configure your app to listen for events the Screenlet triggers,
implement the Screenlet's listener interface in your activity or
fragment class. Refer to the Screenlet's documentation to learn its
listener interface. Then register your activity or fragment as the
Screenlet's listener. The activity class, for example, in the screenshot
below, declares that it implements the Login Screenlet's
\texttt{LoginListener} interface, and it registers itself to listen for
the Screenlet's events.

\begin{figure}
\centering
\includegraphics{./images/screens-android-screenlet-listener.png}
\caption{Implement the Screenlet's listener in your activity or fragment
class.}
\end{figure}

Make sure to implement all methods required by the Screenlet's listener
interface. For Liferay's Screenlets, the listener methods are listed in
each Screenlet's
\href{/docs/7-0/reference/-/knowledge_base/r/screenlets-in-liferay-screens-for-android}{reference
documentation}. That's all there is to it! Awesome! Now you know how to
use Screenlets in your Android apps.

\textbf{Related Topics}

\href{/docs/7-0/tutorials/-/knowledge_base/t/preparing-android-projects-for-liferay-screens}{Preparing
Android Projects for Liferay Screens}

\href{/docs/7-0/tutorials/-/knowledge_base/t/using-views-in-android-screenlets}{Using
Views in Android Screenlets}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-android-screenlets}{Creating
Android Screenlets}

\href{/docs/7-0/tutorials/-/knowledge_base/t/using-screenlets-in-ios-apps}{Using
Screenlets in iOS apps}

\section{Using Views in Android
Screenlets}\label{using-views-in-android-screenlets}

You can use a Liferay Screens \emph{View} to set a Screenlet's look and
feel independent of the Screenlet's core functionality. Liferay's
Screenlets come with several Views, and more are being developed by
Liferay and the community.
\href{/docs/7-0/reference/-/knowledge_base/r/screenlets-in-liferay-screens-for-android}{The
Screenlet reference documentation} lists the Views available for each
Screenlet included with Screens. This tutorial shows you how to use
Views in Android Screenlets. It's straightforward; you'll master using
Views in no time!

\subsection{Views and View Sets}\label{views-and-view-sets}

Before using Views, you should know what components make them up. Note
that what follows is a simple description, sufficient for learning how
to use different Views. For a detailed description of the View layer in
Liferay Screens, see the tutorial
\href{/docs/7-0/tutorials/-/knowledge_base/t/architecture-of-liferay-screens-for-android}{Architecture
of Liferay Screens for Android}.

A View consists of the following items:

\textbf{Screenlet class:} A Java class that coordinates and implements
the Screenlet's functionality. The Screenlet class contains attributes
for configuring the Screenlet's behavior, a reference to the Screenlet's
View class, methods for invoking server operations, and more.

\textbf{View class:} A Java class that implements a View's behavior.
This class usually listens for the UI components' events.

\textbf{Layout:} An XML file that defines a View's UI components. The
View class is usually this file's root element. To use a View, you must
specify its layout in the Screenlet XML (you'll see an example of this
shortly).

Note that because it contains a Screenlet class and a specific set of UI
components, a View can only be used with one particular Screenlet. For
example, the Default View for Login Screenlet can only be used with
Login Screenlet. Multiple Views for several Screenlets can be combined
into a \emph{View Set}. A View Set typically implements a similar look
and feel for several Screenlets. This lets an app use a View Set to
present a cohesive look and feel. For example,
\href{https://github.com/liferay/liferay-screens/tree/master/android/samples/bankofwesteros}{the
Bank of Westeros sample app} uses the
\href{https://github.com/liferay/liferay-screens/tree/master/android/viewsets/westeros/src/main}{Westeros
View Set's} Views with several Screenlets to present the red and white
motif you can see
\href{https://play.google.com/store/apps/details?id=com.liferay.mobile.screens.bankofwesteros}{here
on Google Play}. Liferay Screens for Android comes with the Default View
Set, but Liferay makes additional View Sets, like Material and Westeros,
available in jCenter. Anyone can create View Sets and publish them in
public repositories like Maven Central and jCenter.

To install View Sets besides Default, add them as dependencies in your
project. The \texttt{build.gradle} file code snippet below specifies the
Material and Westeros View Sets as dependencies:

\begin{verbatim}
dependencies {
    ...
    implementation 'com.liferay.mobile:liferay-material-viewset:+'
    implementation 'com.liferay.mobile:liferay-westeros-viewset:+'  
    ...
}
\end{verbatim}

Here are the View Sets that Liferay currently provides for Screens:

\textbf{Default:} Comes standard with a Screenlet. It's used by a
Screenlet if no layout ID is specified or if no View is found with the
layout ID. The Default Views can be used as parent Views for your custom
Views. Refer to the
\href{/docs/7-0/tutorials/-/knowledge_base/t/architecture-of-liferay-screens-for-android}{architecture
tutorial} for more details.

\textbf{Material:} Demonstrates Views built from scratch. It follows
Google's
\href{https://developer.android.com/design/material/index.html}{Material
Design} guidelines. Refer to the
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-android-views}{View
creation tutorial} for instructions on creating your own Views.

\textbf{Westeros:} Customizes the behavior and appearance of the
\href{https://github.com/liferay/liferay-screens/tree/master/android/samples/bankofwesteros}{Westeros
Bank} demo app.

Now that you know about Views and View Sets, you're ready to put them to
use!

\subsection{Using Views}\label{using-views}

To use a View in a Screenlet, specify the View's layout as the
\texttt{liferay:layoutId} attribute's value when inserting the Screenlet
XML in an activity or fragment layout. For example, to use Login
Screenlet with its Material View, insert the Screenlet's XML with
\texttt{liferay:layoutId} set to \texttt{@layout/login\_material}:

\begin{verbatim}
<com.liferay.mobile.screens.auth.login.LoginScreenlet
    android:id="@+id/login_screenlet"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    liferay:layoutId="@layout/login_material"
    />
\end{verbatim}

The following links list the View layouts available in each View Set:

\begin{itemize}
\tightlist
\item
  \href{https://github.com/liferay/liferay-screens/tree/master/android/library/src/main/res/layout}{Default}
\item
  \href{https://github.com/liferay/liferay-screens/tree/master/android/viewsets/material/src/main/res/layout}{Material}
\item
  \href{https://github.com/liferay/liferay-screens/tree/master/android/viewsets/westeros/src/main/res/layout}{Westeros}
\end{itemize}

If the View you want to use is part of a View Set, your app or
activity's theme must also inherit the theme that defines that View
Set's styles. For example, the following code in an app's
\texttt{res/values/styles.xml} tells \texttt{AppTheme.NoActionBar} to
use the Material View Set as its parent theme:

\begin{verbatim}
<resources>

    <style name="AppTheme.NoActionBar" parent="material_theme">
        <item name="colorPrimary">@color/colorPrimary</item>
        <item name="colorPrimaryDark">@color/colorPrimaryDark</item>
        <item name="colorAccent">@color/colorAccent</item>

        <item name="windowActionBar">false</item>
        <item name="windowNoTitle">true</item>
    </style>
    ...
</resources>
\end{verbatim}

To use the Default or Westeros View Set, inherit \texttt{default\_theme}
or \texttt{westeros\_theme}, respectively.

That's it! Great! Now you know how to use Views to spruce up your
Android Screenlets. This opens up a world of possibilities, like
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-android-views}{writing
your own Views}.

\subsection{Related Topics}\label{related-topics-65}

\href{/docs/7-0/tutorials/-/knowledge_base/t/preparing-android-projects-for-liferay-screens}{Preparing
Android Projects for Liferay Screens}

\href{/docs/7-0/tutorials/-/knowledge_base/t/using-screenlets-in-android-apps}{Using
Screenlets in Android Apps}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-android-views}{Creating
Android Views}

\href{/docs/7-0/tutorials/-/knowledge_base/t/architecture-of-liferay-screens-for-android}{Architecture
of Liferay Screens for Android}

\href{/docs/7-0/tutorials/-/knowledge_base/t/using-themes-in-ios-screenlets}{Using
Themes in iOS Screenlets}

\section{Using Offline Mode in
Android}\label{using-offline-mode-in-android}

Offline mode in Liferay Screens lets your apps function when
connectivity is unavailable or intermittent. Even though the steady
march of technology makes connections more stable and prevalent, there
are still plenty of places the Internet has trouble reaching. Areas with
complex terrain, including cities with large buildings, often lack
stable connections. Remote areas typically don't have connections at
all. Using Screens's offline mode in your apps gives your users
flexibility in these situations.

This tutorial shows you how to use offline mode in Screenlets. For an
explanation of how offline mode works, see the tutorial
\href{/docs/7-0/tutorials/-/knowledge_base/t/architecture-of-offline-mode-in-liferay-screens}{Architecture
of Offline Mode in Liferay Screens}. Offline mode's architecture is the
same on iOS and Android, although its use on these platforms differs.

\subsection{Configuring Screenlets for Offline
Mode}\label{configuring-screenlets-for-offline-mode}

If you want to enable offline mode in any of your screenlets, you must
configure the \texttt{offlinePolicy} attribute when inserting the
Screenlet's XML in a layout. This attribute can take four possible
values:

\begin{itemize}
\tightlist
\item
  \texttt{REMOTE\_ONLY}
\item
  \texttt{CACHE\_ONLY}
\item
  \texttt{REMOTE\_FIRST}
\item
  \texttt{CACHE\_FIRST}
\end{itemize}

For a description of these values, see the section
\href{/docs/7-0/tutorials/-/knowledge_base/t/architecture-of-offline-mode-in-liferay-screens\#using-policies-with-offline-mode}{Using
Policies with Offline Mode} in the offline mode architecture tutorial.
Note that each Screenlet behaves a bit differently with offline mode.
For specific details, see the
\href{/docs/7-0/reference/-/knowledge_base/r/screenlets-in-liferay-screens-for-android}{Screenlet
reference documentation}.

\subsection{Handling Synchronization}\label{handling-synchronization}

Under some scenarios, values stored in the local cache need to be
synchronized with the portal. To do this, you need to use the
\texttt{CacheSyncService} class. This class sends information from the
local cache to the portal. To register \texttt{CacheSyncService} with
your app, you must add the following code to your
\texttt{AndroidManifest.xml} file:

\begin{verbatim}
<receiver android:name=".CacheReceiver">
    <intent-filter>
        <action android:name="com.liferay.mobile.screens.auth.login.success"/>
        <action android:name="com.liferay.mobile.screens.cache.resync"/>
        <action android:name="android.net.conn.CONNECTIVITY_CHANGE"/>
    </intent-filter>
</receiver>

<service
    android:name=".CacheSyncService"
    android:exported="false"/>
\end{verbatim}

This code registers the \texttt{CacheReceiver} and
\texttt{CacheSyncService} components. The \texttt{CacheReceiver} is
invoked in the following scenarios:

\begin{itemize}
\tightlist
\item
  When a connectivity change occurs (for example, when the network
  connection is restored).
\item
  When Login Screenlet successfully completes the login.
\item
  When a specific \texttt{resync} intent is broadcasted. In this case,
  use
  \texttt{context.sendBroadcast(new\ Intent("com.liferay.mobile.screens.cache.resync"));}.
\end{itemize}

The \texttt{CacheSyncService} performs the synchronization process when
invoked from the above receiver. This is currently an unassisted
process. Future versions will include some kind of control mechanism.

\subsection{Related Topics}\label{related-topics-66}

\href{/docs/7-0/tutorials/-/knowledge_base/t/architecture-of-offline-mode-in-liferay-screens}{Architecture
of Offline Mode in Liferay Screens}

\href{/docs/7-0/tutorials/-/knowledge_base/t/using-screenlets-in-android-apps}{Using
Screenlets in Android Apps}

\href{/docs/7-0/tutorials/-/knowledge_base/t/using-offline-mode-in-ios}{Using
Offline Mode in iOS}

\href{/docs/7-0/tutorials/-/knowledge_base/t/using-screenlets-in-ios-apps}{Using
Screenlets in iOS Apps}

\section{Architecture of Liferay Screens for
Android}\label{architecture-of-liferay-screens-for-android}

Liferay Screens applies architectural ideas from
\href{http://en.wikipedia.org/wiki/Model-view-presenter}{Model View
Presenter},
\href{http://en.wikipedia.org/wiki/Model_View_ViewModel}{Model View
ViewModel}, and \href{http://www.objc.io/issue-13/viper.html}{VIPER}.
Screens isn't considered a canonical implementation of these
architectures, because it isn't an app, but it borrows from them to
separate presentation layers from business-logic. This tutorial explains
Screen's high-level architecture, its components' low-level
architecture, and the Android Screenlet lifecycle. Now go ahead and get
started examining Screens's building blocks!

\subsection{High-Level Architecture}\label{high-level-architecture}

Liferay Screens for Android is composed of a Core, a Screenlet layer, a
View layer, Interactors, and Server Connectors. Interactors are
technically part of the core, but are worth covering separately. They
facilitate interaction with both local and remote data sources, as well
as communication between the Screenlet layer and the
\href{/docs/7-0/tutorials/-/knowledge_base/t/mobile-sdk}{Liferay Mobile
SDK}.

\begin{figure}
\centering
\includegraphics{./images/screens-android-architecture-01.png}
\caption{Here are the high-level components of Liferay Screens for
Android. The dashed arrow connectors represent a ``uses'' relationship,
in which a component uses the component its pointing to.}
\end{figure}

Each component is described below.

\textbf{Core:} includes all the base classes for developing other
Screens components. It's a micro-framework that lets developers write
their own Screenlets, Views, and Interactors.

\textbf{Screenlets:} Java view classes for inserting into any activity
or fragment view hierarchy. They render a selected layout in the runtime
and in Android Studio's visual editor and react to UI events, sending
any necessary server requests. You can set a Screenlet's properties from
its layout XML file and Java classes. The Screenlets bundled with
Liferay Screens are known collectively as the
\href{/docs/7-0/reference/-/knowledge_base/r/screenlets-in-liferay-screens-for-android}{Screenlet
Library}.

\textbf{Server Connectors:} a collection of classes that interact with
different Liferay DXP versions. These classes abstract away the
complexity of communicating with different versions. This allows the
developer to call API methods and the correct Interactor without
worrying about the specific Liferay DXP version.

\textbf{Interactors:} implement specific use cases for communicating
with servers. They can use local and remote data sources. Most
Interactors use the
\href{/docs/7-0/tutorials/-/knowledge_base/t/mobile-sdk}{Liferay Mobile
SDK} to exchange data with a Liferay instance. If a user action or use
case needs to execute more than one query on a local or remote store,
the sequence is done in the corresponding Interactor. If a Screenlet
supports more than one user action or use case, an Interactor must be
created for each. Interactors are typically bound to one specific
Liferay version, and instantiated by a Server Connector. Interactors run
in a background thread and can therefore perform intensive operations
without blocking the UI thread.

\textbf{Views:} a set of layouts and accompanying custom view classes
that present Screenlets to the user.

Next, the core layer is described in detail.

\subsection{Core Layer}\label{core-layer}

The core layer is the micro-framework that lets developers write
Screenlets in a structured and isolated way. All Screenlets share a
common structure based on the core classes, but each Screenlet can have
a unique purpose and communication API.

\begin{figure}
\centering
\includegraphics{./images/screens-android-architecture-02.png}
\caption{Here's the core layer of Liferay Screens for Android.}
\end{figure}

Here are the core's main components:

\href{https://github.com/liferay/liferay-screens/blob/master/android/library/core/src/main/java/com/liferay/mobile/screens/base/interactor/Interactor.java}{\textbf{Interactor:}}
the base class for all Liferay Portal interactions and use cases that a
Screenlet supports. Interactors call services through the Liferay Mobile
SDK and receive responses asynchronously through the
\href{https://github.com/greenrobot/EventBus}{EventBus}, eventually
changing a View's state. Their actions can vary in complexity, from
performing simple algorithms to requesting data asynchronously from a
server or database. A Screenlet can have multiple Interactors, each
dedicated to supporting a specific operation.

\href{https://github.com/liferay/liferay-screens/blob/master/android/library/core/src/main/java/com/liferay/mobile/screens/base/BaseScreenlet.java}{\textbf{BaseScreenlet:}}
the base class for all Screenlet classes. It receives user events from a
Screenlet's View, instantiates and calls the Interactors, and then
updates the View with operation results. Classes that extend it can
override its
\href{http://www.oodesign.com/template-method-pattern.html}{template
methods}:

\begin{itemize}
\tightlist
\item
  \emph{createScreenletView:} typically inflates the Screenlet's View
  and gets the attribute values from the XML definition.
\item
  \emph{createInteractor:} instantiates an Interactor for the specified
  action. If a Screenlet only supports one Interactor type then that
  type of Interactor is always instantiated.
\item
  \emph{onUserAction:} runs the Interactor associated with the specified
  action.
\end{itemize}

\textbf{Screenlet View:} implements the Screenlet's UI. It's
instantiated by the Screenlet's \texttt{createScreenletView} method. It
renders a specific UI using standard layout files and updates the UI
with data changes. When developing your own Views that extend a parent
View, you can read the parent Screenlet's properties or call its methods
from this class.

\href{https://github.com/greenrobot/EventBus}{\textbf{EventBus:}}
notifies the Interactor when asynchronous operations complete. It
decouples the \texttt{AsyncTask} class instance from the activity life
cycle, to avoid problems typically associated with \texttt{AsyncTask}
instances.

\href{https://www.liferay.com/community/liferay-projects/liferay-mobile-sdk/overview}{\textbf{Liferay
Mobile SDK:}} calls a Liferay instance's remote services in a type-safe
and transparent way.

\href{https://github.com/liferay/liferay-screens/blob/master/android/library/core/src/main/java/com/liferay/mobile/screens/context/SessionContext.java}{\textbf{SessionContext:}}
a singleton class that holds the logged in user's session. Apps can use
an implicit login, invisible to the user, or a login that relies on
explicit user input to create the session. User logins can be
implemented with the
\href{/docs/7-0/reference/-/knowledge_base/r/loginscreenlet-for-android}{Login
Screenlet}. This is explained in detail
\href{/docs/7-0/tutorials/-/knowledge_base/t/accessing-the-liferay-session-in-android}{here}.

\href{https://github.com/liferay/liferay-screens/blob/master/android/library/core/src/main/java/com/liferay/mobile/screens/context/LiferayServerContext.java}{\textbf{LiferayServerContext:}}
a singleton object that holds server configuration parameters. It's
loaded from the \texttt{server\_context.xml} file, or from any other XML
file that overrides the keys defined in the
\texttt{server\_context.xml}.

\href{https://github.com/liferay/liferay-screens/blob/develop/android/library/core/src/main/res/values/server_context.xml}{\textbf{server\_context.xml:}}
specifies the default server, \texttt{companyId} (Liferay instance ID)
and \texttt{groupId} (site ID). You can also configure other Screens
parameters in this file, such as the current Liferay version (with the
attribute \texttt{liferay\_portal\_version}) or an alternative
\texttt{ServiceVersionFactory} to access custom backends.

\href{https://github.com/liferay/liferay-screens/blob/master/android/library/core/src/main/java/com/liferay/mobile/screens/context/LiferayScreensContext.java}{\textbf{LiferayScreensContext:}}
a singleton object that holds a reference to the application context.
It's used internally where necessary.

\href{https://github.com/liferay/liferay-screens/blob/develop/android/library/core/src/main/java/com/liferay/mobile/screens/util/ServiceVersionFactory.java}{\textbf{ServiceVersionFactory:}}
an interface that defines all the server operations supported in Liferay
Screens. This is created and accessed through a
\href{https://github.com/liferay/liferay-screens/blob/develop/android/library/core/src/main/java/com/liferay/mobile/screens/util/ServiceProvider.java}{\texttt{ServiceProvider}}
that creates the Server Connectors needed to interact with a specific
Liferay version. The \texttt{ServiceVersionFactory} is an implementation
of an
\href{https://en.wikipedia.org/wiki/Abstract_factory_pattern}{Abstract
Factory pattern}.

Now that you know what makes up the core layer, you're ready to learn
the Screenlet layer's details.

\subsection{Screenlet Layer}\label{screenlet-layer}

The Screenlet layer contains the Screenlets available in Liferay Screens
for Android. The following diagram uses Screenlet classes prefixed with
\emph{MyScreenlet} to show the Screenlet layer's relationship with the
core, View, and Interactor components.

\begin{figure}
\centering
\includegraphics{./images/screens-android-architecture-03.png}
\caption{This diagram illustrates the Android Screenlet layer's
relationship to other Screens components.}
\end{figure}

Screenlets are comprised of several Java classes and an XML descriptor
file:

\textbf{MyScreenletViewModel:} an interface that defines the attributes
shown in the UI. It typically accounts for all the input and output
values presented to the user. For instance,
\href{https://github.com/liferay/liferay-screens/blob/master/android/library/core/src/main/java/com/liferay/mobile/screens/auth/login/view/LoginViewModel.java}{\texttt{LoginViewModel}}
includes attributes like the user name and password. The Screenlet can
read the attribute values, invoke Interactor operations, and change
these values based on operation results.

\textbf{MyScreenlet:} a class that represents the Screenlet component
the app developer interacts with. It includes the following things:

\begin{itemize}
\tightlist
\item
  Attribute fields for configuring the Screenlet's behavior. They are
  read in the Screenlet's \texttt{createScreenletView} method and their
  default values can optionally be set there too.
\item
  A reference to the Screenlet's View, specified by the
  \texttt{liferay:layoutId} attribute's value. Note: a View must
  implement the Screenlet's \texttt{ViewModel} interface.
\item
  Any number of methods for invoking Interactor operations. You can
  optionally make them public for app developers to call. They can also
  handle UI events received in the view class through a regular listener
  (such as Android's \texttt{OnClickListener}) or events forwarded to
  the Screenlet via the \texttt{performUserAction} method.
\item
  An optional (but recommended) listener object for the Screenlet to
  call on a particular event.
\end{itemize}

\textbf{MyScreenletInteractor:} implements an end-to-end use case that
communicates with a server or consumes a Liferay service. It might
perform several intermediate steps. For example, it might send a request
to a server, compute a local value based on the response, and then send
this value to a different server. On completing an interaction, the
Interactor must notify its listeners, one of which is typically the
Screenlet class instance. The number of Interactors a Screenlet requires
depends on the number of server use cases it supports. For example, the
\href{https://github.com/liferay/liferay-screens/blob/master/android/library/core/src/main/java/com/liferay/mobile/screens/auth/login/LoginScreenlet.java}{Login
Screenlet} class only supports one use case (log in the user), so it has
only one Interactor. The
\href{https://github.com/liferay/liferay-screens/blob/master/android/library/core/src/main/java/com/liferay/mobile/screens/ddl/form/DDLFormScreenlet.java}{DDL
Forms Screenlet} class, however, supports several use cases (load the
form, load a record, submit the form, etc.), so it uses a different
Interactor class for each use case.

\textbf{MyScreenletConnector62} and \textbf{MyScreenletConnector70}: the
classes that create the Interactors required to communicate with a
specific Liferay version. The \texttt{ServiceProvider} creates a
singleton \texttt{ServiceVersionFactory} that returns the right
Connector.

\textbf{MyScreenletDefaultView:} a class that renders the Screenlet's UI
with the default layout. The class in Figure 3, for example, belongs to
the Default View set. The View object and the layout file communicate
using standard mechanisms, like a \texttt{findViewById} method or a
listener object. User actions are received by a specified listener (for
example, \texttt{OnClickListener}) and then passed to the Screenlet
object via the \texttt{performUserAction} method.

\textbf{myscreenlet\_default.xml:} an XML file that specifies how to
render the Screenlet's View. Here's a skeleton of a Screenlet's layout
XML file:

\begin{verbatim}
<?xml version="1.0" encoding="utf-8"?>
<com.your.package.MyScreenletView 
    xmlns:android="http://schemas.android.com/apk/res/android">

    <!-- Put your regular components here: EditText, Button, etc. -->

</com.your.package.MyScreenletView>
\end{verbatim}

Refer to the tutorial
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-android-screenlets}{Creating
Android Screenlets} for more Screenlet details. Next, the View layer's
details are described.

\subsection{View Layer}\label{view-layer}

The View layer lets developers set a Screenlet's look and feel. Each
Screenlet's \texttt{liferay:layoutId} attribute specifies its View. A
View consists of a Screenlet class, view class, and layout XML file. The
layout XML file specifies the UI components, while the Screenlet class
and view class control the View's behavior. By inheriting one or more of
these View layer components from another View, the different View
\emph{types} allow varying levels of control over a Screenlet's UI
design and behavior.

There are several different View types:

\textbf{Themed:} presents the same structure as the current View, but
alters the theme colors and tints of the View's resources. All existing
Views can be themed with different styles. The View's colors reflect the
current value of the Android
\href{https://www.google.com/design/spec/style/color.html\#color-color-palette}{color
palette}. If you want to use one View Set with another View Set's
colors, you can use those colors in your app's theme
(e.g.~\texttt{colorPrimary\_default}, \texttt{colorPrimary\_material},
\texttt{colorPrimary\_westeros}).

\textbf{Child:} presents the same behavior and UI components as its
parent, but can change the UI components' appearance and position. A
Child View specifies visual changes in its own layout XML file; it
inherits the parent's view class and Screenlet class. It can't add or
remove any UI components. The parent must be a Full View. Creating a
Child View is ideal when you only need to make visual changes to an
existing View. For example, you might create a Child View for Login
Screenlet's Default View to set new positions and sizes for the standard
text boxes.

\textbf{Extended:} inherits the parent View's behavior and appearance,
but lets you change and add to both. You can do so by creating a custom
view class and a new layout XML file. An Extended View inherits all the
parent View's other classes, including its Screenlet, listeners, and
Interactors; if you need to customize any of them, you must create a
Full View to do so. An Extended View's parent must be a Full View.
Creating an Extended View is ideal for adding, removing, or changing an
existing View's UI components. For example, you can extend the Login
Screenlet's Default View to present different UI components for the user
name and password fields.

\textbf{Full:} provides a complete standalone View. It doesn't inherit
another View's UI components or behavior. When creating a Full View, you
must therefore create its Screenlet class, view class, and layout XML
file. You should create a Full View when you don't need to inherit
another View or when you need to alter the core behavior of a Screenlet
by customizing its listeners or calling custom Interactors. For example,
you could implement a Full View with a new Interactor for calling a
different Liferay Portal instance. Default Views are Full Views.

Liferay Screens Views are organized into \emph{View sets} that contain
Views for several Screenlets. Liferay's available View sets are listed
here:

\begin{itemize}
\item
  \href{https://github.com/liferay/liferay-screens/tree/master/android/library/core/src/main/java/com/liferay/mobile/screens/viewsets/defaultviews}{\emph{Default:}}
  a mandatory View Set supplied by Liferay. It's used by a Screenlet if
  no layout ID is specified or if no View is found with the layout ID.
  The Default View Set uses a neutral, flat white and blue design with
  standard UI components. In the
  \href{https://github.com/liferay/liferay-screens/tree/master/android/library/core/src/main/java/com/liferay/mobile/screens/auth/login}{Login
  Screenlet}, for example, the Default View uses standard text boxes for
  the user name and password, but the text boxes are styled with the
  Default View's flat white and blue design. You can customize this View
  Set's properties, such as its components' colors, positions, and
  sizes. See the Default View Set's
  \href{https://github.com/liferay/liferay-screens/blob/master/android/library/core/src/main/res/values/styles.xml}{\texttt{styles.xml}}
  file for specific values. Since the Default View Set contains Full
  Views, you can use them to create your own custom Child and Extended
  Views.
\item
  \href{https://github.com/liferay/liferay-screens/tree/master/android/viewsets/material}{\emph{Material:}}
  the View Set containing Views that conform to Android's
  \href{https://developer.android.com/design/material/index.html}{Material
  design guidelines}.
\item
  \href{https://github.com/liferay/liferay-screens/tree/master/android/viewsets/westeros}{\emph{Westeros:}}
  the View Set containing Views for the
  \href{https://github.com/liferay/liferay-screens/tree/master/android/samples/bankofwesteros}{Bank
  of Westeros} sample app.
\end{itemize}

For information on creating or customizing Views, see the tutorial
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-android-views}{Creating
Android Views}.

Great! Now you know how Liferay Screens for Android is composed.
However, there's something you should know before moving on: how
Screenlets interact with the Android life cycle.

\subsection{Screenlet Lifecycle}\label{screenlet-lifecycle}

Liferay Screens automatically saves and restores Screenlets' states
using the Android SDK methods \texttt{onSaveInstanceState} and
\texttt{onRestoreInstanceState}. Each Screenlet uses a uniquely
generated identifier (\texttt{screenletId}) to assign action results to
action sources.

The Screenlets' states are restored after the \texttt{onCreate} and
\texttt{onStart} methods, as specified by the
\href{http://developer.android.com/training/basics/activity-lifecycle/recreating.html}{standard
Android lifecycle}. It's a best practice to execute Screenlet methods
inside the activity's \texttt{onResume} method; this helps assure that
actions and tasks find their destinations.

Awesome! Now you know the nitty gritty architectural details of Liferay
Screens for Android. Let this tutorial be a resource for you as you work
with Liferay Screens.

\subsection{Related Topics}\label{related-topics-67}

\href{/docs/7-0/tutorials/-/knowledge_base/t/using-screenlets-in-android-apps}{Using
Screenlets in Android Apps}

\href{/docs/7-0/tutorials/-/knowledge_base/t/using-views-in-android-screenlets}{Using
Views in Android Screenlets}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-android-screenlets}{Creating
Android Screenlets}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-android-views}{Creating
Android Views}

\section{Architecture of Offline Mode in Liferay
Screens}\label{architecture-of-offline-mode-in-liferay-screens}

Mobile users may encounter difficulty getting or maintaining a network
connection at certain locations or times of day. Using offline mode with
Screenlets ensures that your app still functions in these situations.
You should note, however, that some difficulties may arise when using an
app offline. For example, allowing users to edit data in an app when
they're offline may cause synchronization conflicts with the portal when
they reconnect. By detailing how offline mode is implemented in Liferay
Screens, this tutorial helps you be aware of such difficulties and know
how to handle them.

\subsection{Understanding Offline Mode's
Basics}\label{understanding-offline-modes-basics}

Screenlets in Liferay Screens support the following phases:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Get information from the portal.
\item
  Show information to the user.
\item
  Collect the user's input (if necessary).
\item
  Send input to the portal (if necessary).
\end{enumerate}

The following diagram summarizes these phases:

\begin{figure}
\centering
\includegraphics{./images/screens-offline-01.png}
\caption{A Screenlet's basic phases when requesting and submitting data
to the portal.}
\end{figure}

Note that not all Screenlets need to execute each phase. For example,
the Web Content Display Screenlet only needs to retrieve and display
portal content. Conversely, Login Screenlet and Sign Up Screenlet only
need to handle user input. Only the most complex Screenlets, like the
DDL Form Screenlet and the User Portrait Screenlet, need to do both.

So what does all this have to do with offline mode? Liferay Screens's
offline infrastructure is a small layer of code that intercepts
information going to and coming from the portal. It stores this
information in a local data store for use when there's no Internet
connection. The following diagram illustrates this, with \emph{Local
cache} representing the local data store:

\begin{figure}
\centering
\includegraphics{./images/screens-offline-02.png}
\caption{This is the same diagram as before, with the addition of the
local cache for offline mode.}
\end{figure}

With offline mode enabled, any Screenlet can persist information
exchanged with the portal. You can also configure exactly how offline
mode works with the Screenlet you're using. You do this through
\emph{policies}.

\subsection{Using Policies with Offline
Mode}\label{using-policies-with-offline-mode}

Policies configure how a Screenlet behaves with offline mode when it
sends or receives data. The Screenlet adheres to the policy even if the
data operation fails. Screenlets support the following policies:

\textbf{remote-only:} The Screenlet only uses network connections to
load data. Screenlets functioned this way prior to the introduction of
offline mode. Use this policy when you want the Screenlet always to use
remote content. Your app won't work, however, if a network connection is
unavailable. Also, apps using this policy tend to be slower due to
network lag. Note that if the request succeeds, the Screenlet stores the
data in the local cache for later use.

\textbf{cache-only:} The Screenlet only uses local storage to load data
(it doesn't use the network connection). Use this policy when you want
the Screenlet to always use offline content. Note that in the app's
local cache, some portal data may not exist or may be outdated.

\textbf{remote-first:} The Screenlet first tries to use the network
connection to load data. If this fails, it then tries to load data from
local storage. Use this policy when you want the Screenlet to use the
latest portal data when there's a connection, but also want to support a
fallback mechanism when the connection is gone. Note that the Screenlet
may use outdated information when there's no connection. In many cases,
however, this is better than showing your users no information at all.

\textbf{cache-first:} The Screenlet first tries to load data from local
storage. If this fails, it then tries to use the network connection. Use
this policy when you want the Screenlet to optimize performance and
network efficiency. You can update data in a background process, or let
the user update on-demand (via an option, for example). Note that while
the information retrieved from local storage may be outdated, loading
times and bandwidth consumption are typically lower.

These policies behave a bit differently depending on the data's
direction. In other words, when a Screenlet set to a specific policy
retrieves information from the portal, it may behave differently than
when it submits information to the portal. As an example, consider the
possible scenarios for User Portrait Screenlet:

\begin{itemize}
\tightlist
\item
  When loading the portrait:

  \begin{itemize}
  \item
    \textbf{remote-only:} The Screenlet always attempts to load the
    portrait from the portal. If the request fails, the operation also
    fails.
  \item
    \textbf{cache-only}: The Screenlet always attempts to load the
    portrait from the local cache. The operation fails if the portrait
    doesn't exist there.
  \item
    \textbf{remote-first:} The Screenlet first attempts to load the
    portrait from the portal. If the request succeeds, the Screenlet
    stores the portrait locally for later use. If the request fails, the
    Screenlet tries to load the portrait from the local cache. If the
    local cache doesn't contain the portrait, the Screenlet can't load
    it, and calls the standard error handling code (call the delegate,
    use the default placeholder, etc\ldots).
  \item
    \textbf{cache-first:} The Screenlet first attempts to load the
    portrait from the local cache. If the portrait doesn't exist there,
    it's then requested from the server.
  \end{itemize}
\item
  When submitting the portrait:

  \begin{itemize}
  \item
    \textbf{remote-only:} The Screenlet first sends the new portrait to
    the portal. If the submission succeeds, the Screenlet also stores
    the portrait in the local cache. If the submission fails, the
    operation also fails.
  \item
    \textbf{cache-only}: The Screenlet only stores the portrait locally.
    The portrait may be loaded from the cache later, or synchronized
    with the portal.
  \item
    \textbf{remote-first:} The Screenlet first tries to send the new
    portrait to the portal. If this fails due to lack of network
    connectivity, the Screenlet stores the portrait in the local cache
    for later synchronization with the portal.
  \item
    \textbf{cache-first:} The screenlet first stores the new portrait
    locally, then sends it to the portal. If the submission fails, the
    Screenlet still stores the portrait locally, but the send operation
    fails.
  \end{itemize}
\end{itemize}

\subsection{Understanding
Synchronization}\label{understanding-synchronization}

Synchronization can be a tricky problem to solve. What initially seems
straightforward quickly evolves into scenarios where you're not sure
which version of the data to use. Having offline users complicates
things further. The following diagram illustrates how the Screenlet
retrieves and stores portal data.

\begin{figure}
\centering
\includegraphics{./images/screens-offline-03.png}
\caption{The Screenlet requests the resource from the portal and stores
it in the app's local cache.}
\end{figure}

When a user edits the data in the app, the Screenlet needs to send the
new data to the portal. But what happens if the user is offline? In this
case, the new data can't reach the portal and the local and portal data
are out-of-sync. In this scenario, the app has the new data while the
portal has the old data. The app's data in this synchronization state is
called the \emph{dirty version}. Put away your soap and washcloth. We
don't recommend giving your mobile device a bath. In this context, dirty
means that the data should be synchronized with the portal as soon as
possible. When the Screenlet synchronizes the dirty version, it removes
the dirty flag from the local data.

\begin{figure}
\centering
\includegraphics{./images/screens-offline-04.png}
\caption{The updated data is said to be dirty when the Screenlet can't
send it to the portal.}
\end{figure}

\begin{figure}
\centering
\includegraphics{./images/screens-offline-05.png}
\caption{The dirty flag is removed once synchronization completes.}
\end{figure}

There are other complicated synchronization states. For example, portal
data may change while out-of-sync with a Screenlet's local data. To
avoid data loss, the local data can't overwrite the portal data, and
vice versa. In this situation, the synchronization process produces a
conflict when it runs. The following diagram illustrates this.

\begin{figure}
\centering
\includegraphics{./images/screens-offline-06.png}
\caption{Users have changed the data independently in the app and in the
portal, causing a synchronization conflict.}
\end{figure}

The developer needs to resolve the conflict by choosing the local data
or portal data. Synchronization conflicts have four possible
resolutions:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{Keep the local version:} The Screenlet overwrites the portal
  data with the local data. This results in the local cache and the
  portal having the same version of the data (Version 2 in the above
  diagram).
\item
  \textbf{Keep remote version:} The Screenlet overwrites the local data
  with the portal data. This results in the local cache and the portal
  having the same version of the data (Version 3 in the above diagram).
\item
  \textbf{Discard:} The Screenlet removes the local data, and the portal
  data isn't overwritten.
\item
  \textbf{Ignore:} The Screenlet doesn't change any data. The next
  synchronization event reproduces the conflict.
\end{enumerate}

Great! Now that you know how offline mode works, you're ready to put it
to use.

\subsection{Related Topics}\label{related-topics-68}

\href{/docs/7-0/tutorials/-/knowledge_base/t/using-offline-mode-in-android}{Using
Offline Mode in Android}

\href{/docs/7-0/tutorials/-/knowledge_base/t/using-offline-mode-in-ios}{Using
Offline Mode in iOS}

\href{/docs/7-0/tutorials/-/knowledge_base/t/using-screenlets-in-android-apps}{Using
Screenlets in Android Apps}

\href{/docs/7-0/tutorials/-/knowledge_base/t/using-screenlets-in-ios-apps}{Using
Screenlets in iOS Apps}

\section{Creating Android Screenlets}\label{creating-android-screenlets}

The
\href{/docs/7-0/reference/-/knowledge_base/r/screenlets-in-liferay-screens-for-android}{Screenlets}
that come with Liferay Screens cover common use cases for mobile apps
that use Liferay. They authenticate users, interact with Dynamic Data
Lists, view assets, and more. However, what if there's no Screenlet for
\emph{your} specific use case? No sweat! You can create your own.
Extensibility is a key strength of Liferay Screens.

This tutorial explains how to create your own Screenlets. As an example,
it references code from the sample
\href{https://github.com/liferay/liferay-screens/tree/master/android/samples/addbookmarkscreenlet}{Add
Bookmark Screenlet}, that saves bookmarks to Liferay's Bookmarks
portlet.

In general, you use the following steps to create Screenlets:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/creating-android-screenlets\#determining-your-screenlets-location}{Determine
  your Screenlet's location}. Where you create your Screenlet depends on
  how you'll use it.
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/creating-android-screenlets\#creating-the-screenlets-ui}{Create
  the Screenlet's UI (its View)}. Although this tutorial presents all
  the information you need to create a View for your Screenlet, you may
  first want to learn how to
  \href{/docs/7-0/tutorials/-/knowledge_base/t/creating-android-views}{create
  a View}. For more information on Views in general, see
  \href{/docs/7-0/tutorials/-/knowledge_base/t/using-views-in-android-screenlets}{the
  tutorial on using Views with Screenlets}.
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/creating-android-screenlets\#creating-the-screenlets-Interactor-class}{Create
  the Screenlet's Interactor}. Interactors are Screenlet components that
  make server calls.
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/creating-android-screenlets\#defining-screenlet-attributes-in-your-app}{Define
  the Screenlet's attributes}. These are the XML attributes the app
  developer can set when inserting the Screenlet's XML. These attributes
  control aspects of the Screenlet's behavior. You'll add functionality
  to these attributes in the Screenlet class.
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/creating-android-screenlets\#creating-the-screenlet-class}{Create
  the Screenlet class}. The Screenlet class is the Screenlet's central
  component. It controls the Screenlet's behavior and is the component
  the app developer interacts with when inserting a Screenlet.
\end{enumerate}

To understand the components that make up a Screenlet, you should first
learn the
\href{/docs/7-0/tutorials/-/knowledge_base/t/architecture-of-liferay-screens-for-android}{architecture
of Liferay Screens for Android}.

Without further ado, let the Screenlet creation begin!

\subsection{Determining Your Screenlet's
Location}\label{determining-your-screenlets-location}

Where you should create your Screenlet depends on how you plan to use
it. If you don't plan to reuse your Screenlet in another app or don't
want to redistribute it, create it in a new package inside your Android
app project. This lets you reference and access Liferay Screens's core,
in addition to all the View Sets you may have imported.

If you want to reuse your Screenlet in another app, create it in a new
Android application module. The tutorial
\href{/docs/7-0/tutorials/-/knowledge_base/t/packaging-your-android-screenlets}{Packaging
Android Screenlets} explains how to do this. When your Screenlet's
project is in place, you can start by creating the Screenlet's UI.

\subsection{Creating the Screenlet's
UI}\label{creating-the-screenlets-ui}

In Liferay Screens for Android, Screenlet UIs are called Views. Every
Screenlet must have at least one View. A View consists of the following
components:

\begin{itemize}
\item
  The View Model interface: defines the methods the View needs to update
  the UI.
\item
  A layout XML file: defines the UI components that the View presents to
  the end user.
\item
  A View class: renders the UI, handles user interactions, and
  communicates with the Screenlet class. The View class implements the
  View Model interface.
\item
  The Screenlet class: Although technically part of a View, the
  Screenlet class depends on all the other Screenlet components. You
  therefore won't create the Screenlet class until the end of this
  tutorial.
\end{itemize}

The first items to create for a Screenlet's View are its View Model
interface and layout. The following steps explain how:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  To define the methods that every Screenlet's View class must
  implement, Screens provides the
  \href{https://github.com/liferay/liferay-screens/blob/master/android/library/src/main/java/com/liferay/mobile/screens/base/view/BaseViewModel.java}{\texttt{BaseViewModel}
  interface}. Your View Model interface should extend
  \texttt{BaseViewModel} to define any additional methods needed by your
  Screenlet. This includes any getters and setters for the attributes
  you want to use.

  For example, Add Bookmark Screenlet needs attributes for each
  bookmark's URL and title. Its View Model interface,
  \texttt{AddBookmarkViewModel}, therefore, defines getters and setters
  for these attributes:

\begin{verbatim}
public interface AddBookmarkViewModel extends BaseViewModel {
    String getURL();

    void setURL(String value);

    String getTitle();

    void setTitle(String value);
}
\end{verbatim}
\item
  Define your Screenlet's UI by writing a standard Android layout XML
  file. The layout's root element should be the fully qualified class
  name of your Screenlet's View class. You'll create that class in the
  next step, but determine its name now and name the layout's root
  element after it. Finally, add any UI elements your View needs.

  For example, Add Bookmark Screenlet's layout needs two text fields:
  one for entering a bookmark's URL and one for entering its title. The
  layout also needs a button for saving the bookmark. The Screenlet
  defines this UI in its
  \href{https://github.com/liferay/liferay-screens/blob/master/android/samples/addbookmarkscreenlet/src/main/res/layout/bookmark_default.xml}{\texttt{bookmark\_default.xml}
  layout file}:

\begin{verbatim}
<?xml version="1.0" encoding="utf-8"?>
<com.your.package.AddBookmarkView 
    xmlns:android="http://schemas.android.com/apk/res/android"
    style="@style/default_screenlet">

    <EditText
        android:id="@+id/url"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_marginBottom="15dp"
        android:hint="URL Address"
        android:inputType="textUri"/>

    <EditText
        android:id="@+id/title"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_marginBottom="15dp"
        android:hint="Title"/>

    <Button
        android:id="@+id/add_button"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Add Bookmark"/>

</com.your.package.AddBookmarkView>
\end{verbatim}
\end{enumerate}

Next, you'll create your Screenlet's View class.

\subsubsection{Creating the Screenlet's View
Class}\label{creating-the-screenlets-view-class}

Your Screenlet needs a View class to support the layout you just
created. This class must extend an Android layout class
(e.g.~\texttt{LinearLayout}, \texttt{ListView}), implement your View
Model interface, and implement a separate listener interface to handle
user actions. Follow these steps to create this View class:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a View class that extends the Android layout class appropriate
  for your Screenlet's UI. For example, Add Bookmark Screenlet renders
  its UI components in a single column, so
  \href{https://github.com/liferay/liferay-screens/blob/master/android/samples/addbookmarkscreenlet/src/main/java/com/liferay/mobile/screens/bookmark/view/AddBookmarkView.java}{its
  View class (\texttt{AddBookmarkView})} extends
  \href{https://developer.android.com/reference/android/widget/LinearLayout.html}{Android's
  \texttt{LinearLayout}}. Your View class's constructors should call the
  parent layout class's constructors. For example,
  \href{https://github.com/liferay/liferay-screens/blob/master/android/samples/addbookmarkscreenlet/src/main/java/com/liferay/mobile/screens/bookmark/view/AddBookmarkView.java\#L20-L30}{\texttt{AddBookmarkView}'s
  constructors} call those of \texttt{LinearLayout}:

\begin{verbatim}
public AddBookmarkView(Context context) {
    super(context);
}

public AddBookmarkView(Context context, AttributeSet attributes) {
    super(context, attributes);
}

public AddBookmarkView(Context context, AttributeSet attributes, int defaultStyle) {
    super(context, attributes, defaultStyle);
}
\end{verbatim}
\item
  Add instance variables for your View Model's attributes and
  \texttt{BaseScreenlet}. For example, Add Bookmark Screenlet needs
  instance variables for a bookmark's URL and title. Because all
  Screenlet classes extend the
  \href{https://github.com/liferay/liferay-screens/blob/master/android/library/src/main/java/com/liferay/mobile/screens/base/BaseScreenlet.java}{\texttt{BaseScreenlet}
  class}, a \texttt{BaseScreenlet} variable in your View class ensures
  that your View always has a reference to the Screenlet. For example,
  here are \texttt{AddBookmarkView}'s instance variables:

\begin{verbatim}
private EditText urlText;
private EditText titleText;
private BaseScreenlet screenlet;
\end{verbatim}
\item
  Implement your View Model interface. Implement your View Model's
  getter and setter methods to get and set the inner value of each
  component, respectively. For example, here's
  \texttt{AddBookmarkView}'s implementation of
  \texttt{AddBookmarkViewModel}:

\begin{verbatim}
public String getURL() {
    return urlText.getText().toString();
}

public void setURL(String value) {
    urlText.setText(value);
}

public String getTitle() {
    return titleText.getText().toString();
}

public void setTitle(String value) {
    titleText.setText(value);
}
\end{verbatim}
\item
  Implement a listener interface to handle user actions in the
  Screenlet. For example, Add Bookmark Screenlet must detect when the
  user presses the save button. The \texttt{AddBookmarkView} class
  enables this by implementing
  \href{https://developer.android.com/reference/android/view/View.OnClickListener.html}{Android's
  \texttt{View.OnClickListener} interface}, which defines a single
  method: \texttt{onClick}. The Screenlet's \texttt{onClick}
  implementation gets a reference to the Screenlet and calls its
  \texttt{performUserAction()} method (you'll create
  \texttt{performUserAction()} in the Screenlet class shortly):

\begin{verbatim}
public void onClick(View v) {
    AddBookmarkScreenlet screenlet = (AddBookmarkScreenlet) getParent();

    screenlet.performUserAction();
}
\end{verbatim}

  You can set the listener to the appropriate UI element by implementing
  an \texttt{onFinishInflate()} method. This method should also retrieve
  and assign any other UI elements from your layout. For example, the
  \texttt{onFinishInflate()} implementation in \texttt{AddBookmarkView}
  retrieves the URL and title attributes from the layout, and sets them
  to the \texttt{urlText} and \texttt{titleText} variables,
  respectively. This method then retrieves the button from the layout
  and sets this View class as the button's click listener:

\begin{verbatim}
protected void onFinishInflate() {
    super.onFinishInflate();

    urlText = (EditText) findViewById(R.id.url);
    titleText = (EditText) findViewById(R.id.title_bookmark);

    Button addButton = (Button) findViewById(R.id.add_button);
    addButton.setOnClickListener(this);
}
\end{verbatim}
\item
  Implement
  \href{https://github.com/liferay/liferay-screens/blob/master/android/library/src/main/java/com/liferay/mobile/screens/base/view/BaseViewModel.java}{the
  \texttt{BaseViewModel} interface}'s methods:
  \texttt{showStartOperation}, \texttt{showFinishOperation},
  \texttt{showFailedOperation}, \texttt{getScreenlet}, and
  \texttt{setScreenlet}. In the \texttt{show*Operation} methods, you can
  log what happens in your Screenlet when the server operation starts,
  finishes successfully, or fails, respectively. In the
  \texttt{getScreenlet} and \texttt{setScreenlet} methods, you must get
  and set the \texttt{BaseScreenlet} variable, respectively. This
  ensures that the View always has a Screenlet reference. For example,
  Add Bookmark Screenlet implements these methods as follows:

\begin{verbatim}
@Override
public void showStartOperation(String actionName) {

}

@Override
public void showFinishOperation(String actionName) {
    LiferayLogger.i("Add bookmark successful");
}

@Override
public void showFailedOperation(String actionName, Exception e) {
    LiferayLogger.e("Could not add bookmark", e);
}

@Override
public BaseScreenlet getScreenlet() {
    return screenlet;
}

@Override
public void setScreenlet(BaseScreenlet screenlet) {
    this.screenlet = screenlet;
}
\end{verbatim}

  Note that although you must implement the
  \texttt{show{[}something{]}Operation} methods, you can leave their
  implementations empty if you don't need to take any specific action.
\end{enumerate}

\href{https://github.com/liferay/liferay-screens/blob/master/android/samples/addbookmarkscreenlet/src/main/java/com/liferay/mobile/screens/bookmark/view/AddBookmarkView.java}{Click
here} to see the complete example \texttt{AddBookmarkView} class.

Great! Your View class is finished. Now you're ready to create your
Screenlet's Interactor class.

\subsection{Creating the Screenlet's
Interactor}\label{creating-the-screenlets-interactor}

A Screenlet's Interactor makes the service call to retrieve the data you
need from a Liferay instance. An Interactor is made up of several
components:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  The event class. This class lets you handle communication between the
  Screenlet's components via event objects that contain the server
  call's results. Screens uses the
  \href{https://greenrobot.github.io/EventBus/}{EventBus} library for
  this. Screens supplies the
  \href{https://github.com/liferay/liferay-screens/blob/master/android/library/src/main/java/com/liferay/mobile/screens/base/interactor/event/BasicEvent.java}{\texttt{BasicEvent}
  class} and
  \href{https://github.com/liferay/liferay-screens/blob/master/android/library/src/main/java/com/liferay/mobile/screens/base/list/interactor/BaseListEvent.java}{\texttt{BaseListEvent}
  class} for communicating \texttt{JSONObject} and \texttt{JSONArray}
  results within Screenlets, respectively. You can create your own event
  classes by extending \texttt{BasicEvent}. You should create your own
  event classes when you must communicate objects other than
  \texttt{JSONObject} or \texttt{JSONArray}. The example Add Bookmark
  Screenlet only needs to communicate \texttt{JSONObject} instances, so
  it uses \texttt{BasicEvent}.
\item
  The listener interface. This defines the methods the app developer
  needs to respond to the Screenlet's behavior. For example,
  \href{/docs/7-0/reference/-/knowledge_base/r/loginscreenlet-for-android\#listener}{Login
  Screenlet's listener} defines the \texttt{onLoginSuccess} and
  \texttt{onLoginFailure} methods. Screens calls these methods when
  login succeeds or fails, respectively. By implementing these methods
  in the activity or fragment class that contains the Screenlet, the app
  developer can respond to login success and failure. Similarly, the
  \href{https://github.com/liferay/liferay-screens/blob/master/android/samples/addbookmarkscreenlet/src/main/java/com/liferay/mobile/screens/bookmark/interactor/AddBookmarkListener.java}{example
  Add Bookmark Screenlet's listener interface} defines two methods: one
  for responding to the Screenlet's failure to add a bookmark and one
  for responding to its success to add a bookmark:

\begin{verbatim}
 public interface AddBookmarkListener {

     void onAddBookmarkFailure(Exception exception);

     void onAddBookmarkSuccess();
 }
\end{verbatim}
\item
  The Interactor class. This class must extend
  \href{https://github.com/liferay/liferay-screens/blob/master/android/library/src/main/java/com/liferay/mobile/screens/base/interactor/BaseRemoteInteractor.java}{Screens's
  \texttt{BaseRemoteInteractor}} with your listener and event as type
  arguments. The listener lets the Interactor class send the server
  call's results to any classes that implement the listener. In the
  implementation of the method that makes the server call, the
  \texttt{execute} method, you must
  \href{/docs/7-0/tutorials/-/knowledge_base/t/invoking-services-asynchronously-from-your-android-app}{use
  the Mobile SDK to make an asynchronous service call}. This means you
  must get a session and then make the server call. You make the server
  call by creating an instance of the Mobile SDK service (e.g.,
  \texttt{BookmarksEntryService}) that can call the Liferay service you
  need and then making the call. The Interactor class must also process
  the event object that contains the call's results and then notify the
  listener of those results. You do this by implementing the
  \texttt{onSuccess} and \texttt{onFailure} methods to invoke the
  corresponding \texttt{getListener()} methods.

  For example, the
  \href{https://github.com/liferay/liferay-screens/blob/master/android/samples/addbookmarkscreenlet/src/main/java/com/liferay/mobile/screens/bookmark/interactor/AddBookmarkInteractor.java}{\texttt{AddBookmarkInteractor}
  class} is Add Bookmark Screenlet's Interactor class. This class
  implements the \texttt{execute} method, which adds a bookmark to a
  folder in a Liferay instance's Bookmarks portlet. This method first
  validates the bookmark's URL and folder. It then calls the
  \texttt{getJSONObject} method to add the bookmark, and concludes by
  returning a new \texttt{BasicEvent} object created from the
  \texttt{JSONObject}. The \texttt{if} statement in the
  \texttt{getJSONObject} method checks the Liferay version so it can
  create the appropriate \texttt{BookmarksEntryService} instance needed
  to make the server call. Regardless of the Liferay version, the
  \texttt{getSession()} method retrieves the existing session created by
  Login Screenlet upon successful login. The session's \texttt{addEntry}
  method makes the server call. The Screenlet calls the
  \texttt{onSuccess} or \texttt{onFailure} method to notify the listener
  of the server call's success or failure, respectively. In either case,
  the \texttt{BasicEvent} object contains the server call's results.
  Since this Screenlet doesn't retrieve anything from the server,
  however, there's no need to process the \texttt{BasicEvent} object in
  the \texttt{onSuccess} method; calling the listener's
  \texttt{onAddBookmarkSuccess} method is sufficient. Here's the
  complete code for \texttt{AddBookmarkInteractor}:

\begin{verbatim}
 public class AddBookmarkInteractor extends BaseRemoteInteractor<AddBookmarkListener, BasicEvent> {

     @Override
     public BasicEvent execute(Object[] args) throws Exception {
         String url = (String) args[0];
         String title = (String) args[1];
         long folderId = (long) args[2];

         validate(url, folderId);

         JSONObject jsonObject = getJSONObject(url, title, folderId);
         return new BasicEvent(jsonObject);
     }

     @Override
     public void onSuccess(BasicEvent event) throws Exception {
         getListener().onAddBookmarkSuccess();
     }

     @Override
     public void onFailure(BasicEvent event) {
         getListener().onAddBookmarkFailure(event.getException());
     }

     private void validate(String url, long folderId) {
         if (url == null || url.isEmpty() || !URLUtil.isValidUrl(url)) {
             throw new IllegalArgumentException("Invalid url");
         } else if (folderId == 0) {
             throw new IllegalArgumentException("folderId not set");
         }
     }

     @NonNull
     private JSONObject getJSONObject(String url, String title, long folderId) throws Exception {
         if (LiferayServerContext.isLiferay7()) {
             return new BookmarksEntryService(getSession()).addEntry(LiferayServerContext.getGroupId(), 
                 folderId, title, url, "", null);
         } else {
             return new com.liferay.mobile.android.v62.bookmarksentry.BookmarksEntryService(
                 getSession()).addEntry(LiferayServerContext.getGroupId(), folderId, title, url, "", null);
         }
     }
 }
\end{verbatim}
\end{enumerate}

Sweetness! Your Screenlet's Interactor is done. Next, you'll create the
Screenlet class.

\subsection{Defining Screenlet Attributes in Your
App}\label{defining-screenlet-attributes-in-your-app}

Before creating the Screenlet class, you should define its attributes.
These are the attributes the app developer can set when inserting the
Screenlet's XML in an activity or fragment layout. For example, to use
\href{/docs/7-0/reference/-/knowledge_base/r/loginscreenlet-for-android}{Login
Screenlet}, the app developer could insert the following Login Screenlet
XML in an activity or fragment layout:

\begin{verbatim}
<com.liferay.mobile.screens.auth.login.LoginScreenlet
    android:id="@+id/login_screenlet"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    app:basicAuthMethod="email"
    app:layoutId="@layout/login_default"
    />
\end{verbatim}

The app developer can set the \texttt{liferay} attributes
\texttt{basicAuthMethod} and \texttt{layoutId} to set Login Screenlet's
authentication method and View, respectively. The Screenlet class reads
these settings to enable the appropriate functionality.

When creating a Screenlet, you can define the attributes you want to
make available to app developers. You do this in an XML file inside your
Android project's \texttt{res/values} directory. For example, Add
Bookmark Screenlet's attributes are defined in the
\href{https://github.com/liferay/liferay-screens/blob/master/android/samples/addbookmarkscreenlet/src/main/res/values/bookmark_attrs.xml}{Screenlet's
\texttt{bookmark\_attrs.xml} file}:

\begin{verbatim}
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <declare-styleable name="AddBookmarkScreenlet">
        <attr name="layoutId"/>
        <attr name="folderId"/>
        <attr name="defaultTitle" format="string"/>
    </declare-styleable>
</resources>
\end{verbatim}

This defines the attributes \texttt{layoutId}, \texttt{folderId}, and
\texttt{defaultTitle}. Add Bookmark Screenlet's Screenlet class adds
functionality to these attributes. Here's a brief description of what
each does:

\begin{itemize}
\item
  \texttt{layoutId}: Sets the View that displays the Screenlet. This
  functions the same as the \texttt{layoutId} attribute in
  \href{/docs/7-0/reference/-/knowledge_base/r/screenlets-in-liferay-screens-for-android}{Liferay's
  existing Screenlets}.
\item
  \texttt{folderId}: Sets the folder ID in the Bookmarks portlet where
  the Screenlet adds bookmarks.
\item
  \texttt{defaultTitle}: Sets each Bookmark's default title.
\end{itemize}

Now that you've defined your Screenlet's attributes, you're ready to
create the Screenlet class.

\subsection{Creating the Screenlet
Class}\label{creating-the-screenlet-class-3}

The Screenlet class is the central hub of a Screenlet. It contains
attributes for configuring the Screenlet's behavior, a reference to the
Screenlet's View, methods for invoking Interactor operations, and more.
When using a Screenlet, app developers primarily interact with its
Screenlet class. In other words, if a Screenlet were to become
self-aware, it would happen in its Screenlet class (though we're
reasonably confident this won't happen).

To make all this possible, your Screenlet class must implement the
Interactor's listener interface and extend
\href{https://github.com/liferay/liferay-screens/blob/master/android/library/src/main/java/com/liferay/mobile/screens/base/BaseScreenlet.java}{Screens's
\texttt{BaseScreenlet} class} with the View Model interface and
Interactor class as type arguments. Your Screenlet class should also
contain instance variables and accompanying getters and setters for the
listener and any other attributes that the app developer needs to
access. For constructors, you can call
\href{https://github.com/liferay/liferay-screens/blob/master/android/library/src/main/java/com/liferay/mobile/screens/base/BaseScreenlet.java\#L45-L61}{\texttt{BaseScreenlet}'s
constructors}.

For example,
\href{https://github.com/liferay/liferay-screens/blob/master/android/samples/addbookmarkscreenlet/src/main/java/com/liferay/mobile/screens/bookmark/AddBookmarkScreenlet.java}{Add
Bookmark Screenlet's Screenlet class} extends
\texttt{BaseScreenlet\textless{}AddBookmarkViewModel,\ AddBookmarkInteractor\textgreater{}}
and implements \texttt{AddBookmarkListener}. It also contains instance
variables for \texttt{AddBookmarkListener} and the bookmark's folder ID,
and getters and setters for these variables. Also note the constructors
call \texttt{BaseScreenlet}'s constructors:

\begin{verbatim}
public class AddBookmarkScreenlet extends 
    BaseScreenlet<AddBookmarkViewModel, AddBookmarkInteractor>
    implements AddBookmarkListener {

    private long folderId;
    private AddBookmarkListener listener;

    public AddBookmarkScreenlet(Context context) {
        super(context);
    }

    public AddBookmarkScreenlet(Context context, AttributeSet attributes) {
        super(context, attributes);
    }

    public AddBookmarkScreenlet(Context context, AttributeSet attributes, int defaultStyle) {
        super(context, attributes, defaultStyle);
    }

    public long getFolderId() {
        return folderId;
    }

    public void setFolderId(long folderId) {
        this.folderId = folderId;
    }

    public AddBookmarkListener getListener() {
        return listener;
    }

    public void setListener(AddBookmarkListener listener) {
        this.listener = listener;
    }

    ...
\end{verbatim}

Next, implement the Screenlet's listener methods. This lets the
Screenlet class receive the server call's results and thus act as the
listener. These methods should communicate the server call's results to
the View (via the View Model) and any other listener instances (via the
Screenlet class's listener instance). For example, here are Add Bookmark
Screenlet's listener method implementations:

\begin{verbatim}
public void onAddBookmarkSuccess() {
    getViewModel().showFinishOperation(null);

    if (listener != null) {
        listener.onAddBookmarkSuccess();
    }
}

public void onAddBookmarkFailure(Exception e) {
    getViewModel().showFailedOperation(null, e);

    if (listener != null) {
        listener.onAddBookmarkFailure(e);
    }
}
\end{verbatim}

These methods are called when the server call succeeds or fails,
respectively. They first use \texttt{getViewModel()} to get a View Model
instance and then call the \texttt{BaseViewModel} methods
\texttt{showFinishOperation} and \texttt{showFailedOperation} to send
the server call's results to the View. The \texttt{showFinishOperation}
call sends \texttt{null} because a successful server call to add a
bookmark doesn't return any objects. If a successful server call in your
Screenlet returns any objects you need to display, then you should send
them in this \texttt{showFinishOperation} call. The
\texttt{showFailedOperation} call sends the \texttt{Exception} that
results from a failed server call to the View. This lets you display an
informative error to the user. The \texttt{onAddBookmarkSuccess} and
\texttt{onAddBookmarkFailure} implementations then call the listener
instance's method of the same name. This sends the server call's results
to any other classes that implement the listener interface, such as the
activity or fragment that uses the Screenlet.

Next, you must implement \texttt{BaseScreenlet}'s abstract methods:

\begin{itemize}
\item
  \texttt{createScreenletView}: Reads the app developer's Screenlet
  attribute settings, and inflates the View. You'll use an
  \href{https://developer.android.com/reference/android/content/res/TypedArray.html}{Android
  \texttt{TypedArray}} to retrieve the attribute settings. You should
  set the attribute values to the appropriate variables, and set any
  default values you need to display via a View Model reference.

  For example, Add Bookmark Screenlet's \texttt{createScreenletView}
  method gets the app developer's attribute settings via a
  \texttt{TypedArray}. This includes the \texttt{layoutId},
  \texttt{defaultTitle}, and \texttt{folderId} attributes. The
  \texttt{layoutId} is used to inflate a View reference (\texttt{view}),
  which is then cast to a View Model instance (\texttt{viewModel}). The
  View Model instance's \texttt{setTitle} method is then called with
  \texttt{defaultTitle} to set the bookmark's default title. The method
  concludes by returning the View reference.

\begin{verbatim}
  @Override
  protected View createScreenletView(Context context, AttributeSet attributes) {
      TypedArray typedArray = context.getTheme()
          .obtainStyledAttributes(attributes, R.styleable.AddBookmarkScreenlet, 0, 0);

      int layoutId = typedArray.getResourceId(R.styleable.AddBookmarkScreenlet_layoutId, 0);

      View view = LayoutInflater.from(context).inflate(layoutId, null);

      String defaultTitle = typedArray.getString(R.styleable.AddBookmarkScreenlet_defaultTitle);

      folderId = castToLong(typedArray.getString(R.styleable.AddBookmarkScreenlet_folderId));

      typedArray.recycle();

      AddBookmarkViewModel viewModel = (AddBookmarkViewModel) view;
      viewModel.setTitle(defaultTitle);

      return view;
  }
\end{verbatim}
\item
  \texttt{createInteractor}: Instantiates the Screenlet's Interactor.
  For example, Add Bookmark Screenlet's \texttt{createInteractor} method
  calls the \texttt{AddBookmarkInteractor} constructor to create a new
  instance of this Interactor:

\begin{verbatim}
  @Override
  protected AddBookmarkInteractor createInteractor(String actionName) {
      return new AddBookmarkInteractor(getScreenletId());
  }
\end{verbatim}
\item
  \texttt{onUserAction}: Retrieves any data the user has entered in the
  View, and starts the Screenlet's server operation via an Interactor
  instance. If your Screenlet doesn't take user input, this method only
  needs to do the latter.

  The example Add Bookmark Screenlet takes user input (the bookmark's
  URL and title), so its \texttt{onUserAction} method must retrieve this
  data. This method does so via a View Model instance it retrieves with
  the \texttt{getViewModel()} method. The \texttt{onUserAction} method
  starts the server operation by calling the Interactor's \texttt{start}
  method with the user input. Note that the Interactor inherits the
  \texttt{start} method from the
  \href{https://github.com/liferay/liferay-screens/blob/master/android/library/src/main/java/com/liferay/mobile/screens/base/interactor/BaseInteractor.java}{\texttt{BaseInteractor}
  class}. Invoking the \texttt{start} method causes the Interactor's
  \texttt{execute} method to run in a background thread:

\begin{verbatim}
  @Override
  protected void onUserAction(String userActionName, AddBookmarkInteractor interactor, Object... args) {
      AddBookmarkViewModel viewModel = getViewModel();
      String url = viewModel.getURL();
      String title = viewModel.getTitle();

      interactor.start(url, title, folderId);
  }
\end{verbatim}
\end{itemize}

Nice! Your Screenlet is finished! You can now use it
\href{/docs/7-0/tutorials/-/knowledge_base/t/using-screenlets-in-android-apps}{the
same way you would any other}. If you created your Screenlet in its own
project, you can also
\href{/docs/7-0/tutorials/-/knowledge_base/t/packaging-your-android-screenlets}{package
and distribute} it via the Screens project, JCenter, or Maven Central.

To finish the Add Bookmark Screenlet example, the following section
shows you how to use this Screenlet. It also shows how you can set
default attribute values in an app's \texttt{server\_context.xml} file.
Although you may not need to do this when using your Screenlets, it
might come in handy on your way to becoming a master of Screenlets.

\subsection{Using Your Screenlet}\label{using-your-screenlet}

To use any Screenlet, you must follow these
\href{/docs/7-0/tutorials/-/knowledge_base/t/using-screenlets-in-android-apps}{general
steps}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Insert the Screenlet's XML in the activity or fragment layout you want
  the Screenlet to appear in. You can fine-tune the Screenlet's behavior
  by setting the Screenlet XML's attributes.
\item
  Implement the Screenlet's listener in the activity or fragment class.
\end{enumerate}

As an example of this, the Liferay Screens
\href{https://github.com/liferay/liferay-screens/tree/master/android/samples/test-app}{Test
App} uses Add Bookmark Screenlet. You can find the following Add
Bookmark Screenlet XML in the
\href{https://github.com/liferay/liferay-screens/blob/master/android/samples/test-app/src/main/res/layout/add_bookmark.xml}{Test
App's \texttt{add\_bookmark.xml} layout}:

\begin{verbatim}
<com.liferay.mobile.screens.bookmark.AddBookmarkScreenlet
    android:id="@+id/bookmark_screenlet"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    app:folderId="@string/bookmark_folder"
    app:layoutId="@layout/bookmark_default" />
\end{verbatim}

Note that the layout specified by \texttt{app:layoutId}
(\texttt{bookmark\_default}) matches the layout file of the Screenlet's
View (\texttt{bookmark\_default.xml}). This is how you specify the View
that displays your Screenlet. For example, if Add Bookmark Screenlet had
another View defined in a layout file named
\texttt{bookmark\_awesome.xml}, you could use that layout by specifying
\texttt{@layout/bookmark\_awesome} as the \texttt{app:layoutId}
attribute's value.

Also note that the \texttt{app:folderId} attribute specifies
\texttt{@string/bookmark\_folder} as the bookmark folder's ID. This is
an alternative way of specifying an attribute's value. Instead of
specifying the value directly, the Test App specifies the value in its
\href{https://github.com/liferay/liferay-screens/blob/master/android/samples/test-app/src/main/res/values/server_context.xml\#L23-L24}{\texttt{server\_context.xml}
file}:

\begin{verbatim}
...
<string name="bookmark_folder">20622</string>
...
\end{verbatim}

This \texttt{name} attribute's value, \texttt{bookmark\_folder} is then
used in the Screenlet XML to set the \texttt{app:folderId} attribute to
\texttt{20622}.

Great! Now you know how to use the Screenlets you create. You also know
a convenient way to specify default values for a Screenlet's attributes.

\subsection{Related Topics}\label{related-topics-69}

\href{/docs/7-0/tutorials/-/knowledge_base/t/using-screenlets-in-android-apps}{Using
Screenlets in Android Apps}

\href{/docs/7-0/tutorials/-/knowledge_base/t/architecture-of-liferay-screens-for-android}{Architecture
of Liferay Screens for Android}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-android-views}{Creating
Android Views}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-ios-screenlets}{Creating
iOS Screenlets}

\section{Creating Android List
Screenlets}\label{creating-android-list-screenlets}

It's very common for mobile apps to display lists. Liferay Screens lets
you display asset lists and DDL lists in your Android app by using
\href{/docs/7-0/reference/-/knowledge_base/r/assetlistscreenlet-for-android}{Asset
List Screenlet} and
\href{/docs/7-0/reference/-/knowledge_base/r/ddllistscreenlet-for-android}{DDL
List Screenlet}, respectively. Screens also includes list Screenlets for
displaying lists of other Liferay entities like web content articles,
images, and more.
\href{/docs/7-0/reference/-/knowledge_base/r/screenlets-in-liferay-screens-for-android}{The
Screenlet reference documentation} lists all the Screenlets included
with Liferay Screens. If there's not a list Screenlet for the entity you
want to display in a list, you must create your own. A list Screenlet
can display any entity from a Liferay instance. For example, you can
create a list Screenlet that displays standard Liferay entities like
\texttt{User}, or custom entities from custom Liferay apps.

This tutorial uses code from the sample Bookmark List Screenlet to show
you how to create your own list Screenlet. This Screenlet displays a
list of bookmarks from Liferay's Bookmarks portlet. You can find this
Screenlet's complete code
\href{https://github.com/liferay/liferay-screens/tree/master/android/samples/listbookmarkscreenlet}{here
in GitHub}.

Note that because this tutorial focuses on creating a list Screenlet, it
doesn't explain general Screenlet concepts and components. Before
beginning, you should therefore read the following tutorials:

\begin{itemize}
\tightlist
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/architecture-of-liferay-screens-for-android}{Screens
  architecture tutorial}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/creating-android-screenlets}{Basic
  Screenlet creation tutorial}
\end{itemize}

You'll create the list Screenlet by following these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/creating-android-list-screenlets\#creating-the-model-class}{Creating
  the Model Class}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/creating-android-list-screenlets\#creating-the-screenlets-view}{Creating
  the View}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/creating-android-list-screenlets\#creating-the-screenlets-interactor}{Creating
  the Interactor}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/creating-android-list-screenlets\#creating-the-screenlet-class}{Creating
  the Screenlet Class}
\end{enumerate}

First though, you should understand how pagination works with list
Screenlets.

\subsection{Pagination}\label{pagination-2}

To ensure that users can scroll smoothly through large lists of items,
list Screenlets support fluent pagination. Support for this is built
into the list Screenlet framework. You'll see this as you construct your
list Screenlet.

Now you're ready to begin!

\subsection{Creating the Model Class}\label{creating-the-model-class-2}

Entities come back from Liferay in JSON. To work with these results
efficiently in your app, you must convert them to model objects that
represent the entity in Liferay. Although Screens's
\href{https://github.com/liferay/liferay-screens/blob/master/android/library/src/main/java/com/liferay/mobile/screens/base/list/interactor/BaseListInteractor.java}{\texttt{BaseListInteractor}}
transforms the JSON entities into \texttt{Map} objects for you, you
still must convert these into proper entity objects for use in your app.
You'll do this via a model class.

For example, Bookmark List Screenlet's model class (\texttt{Bookmark})
creates \texttt{Bookmark} objects that contain a bookmark's URL and
other data. To ensure quick access to the URL, the constructor that
takes a \texttt{Map\textless{}String,\ Object\textgreater{}} extracts it
from the \texttt{Map} and sets it to the \texttt{url} variable. To allow
access to any other data, the same constructor sets the entire
\texttt{Map} to the \texttt{values} variable. Besides the getters and
setter, the rest of this class implements
\href{https://developer.android.com/reference/android/os/Parcelable.html}{Android's
\texttt{Parcelable} interface}:

\begin{verbatim}
import android.os.Parcel;
import android.os.Parcelable;

import java.util.Map;

public class Bookmark implements Parcelable {

    private String url;
    private Map values;

    public static final Creator<Bookmark> CREATOR = new Creator<Bookmark>() {
        @Override
        public Bookmark createFromParcel(Parcel in) {
            return new Bookmark(in);
        }

        @Override
        public Bookmark[] newArray(int size) {
            return new Bookmark[size];
        }
    };

    public Bookmark() {
        super();
    }

    protected Bookmark(Parcel in) {
        url = in.readString();
    }

    public Bookmark(Map<String, Object> stringObjectMap) {
        url = (String) stringObjectMap.get("url");
        values = stringObjectMap;
    }

    @Override
    public void writeToParcel(Parcel dest, int flags) {
        dest.writeString(url);
    }

    @Override
    public int describeContents() {
        return 0;
    }

    public String getUrl() {
        return url;
    }

    public Map getValues() {
        return values;
    }

    public void setValues(Map values) {
        this.values = values;
    }

}
\end{verbatim}

Now that you have your model class, you can create your Screenlet's
View.

\subsection{Creating the Screenlet's
View}\label{creating-the-screenlets-view}

Recall from
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-android-screenlets\#creating-the-screenlets-ui}{the
basic Screenlet creation tutorial} that a View defines a Screenlet's UI.
To accommodate its list, a list Screenlet's View is constructed a bit
differently than that of a non-list Screenlet. To create a List
Screenlet's View, you'll create the following components:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Row Layout: the layout for each list row.
\item
  Adapter Class: an
  \href{http://developer.android.com/guide/topics/ui/declaring-layout.html\#AdapterViews}{Android
  adapter class} that populates each list row with data.
\item
  View Class: the class that controls the View. This class serves the
  same purpose in list Screenlets as it does in non-list Screenlets.
\item
  Main Layout: the layout for the list as a whole. Note this is
  different from the row layout, which defines the UI for individual
  rows.
\end{enumerate}

First, you'll create the row layout.

\subsubsection{Creating the Row Layout}\label{creating-the-row-layout-2}

Before constructing the rest of the View, you should first define the
layout to use for each row in the list. For example, Bookmark List
Screenlet needs to display a bookmark in each row. Its row layout
(\texttt{res/layout/bookmark\_row.xml}) is therefore a
\texttt{LinearLayout} containing a single \texttt{TextView} that
displays the bookmark's URL:

\begin{verbatim}
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="vertical">

    <TextView
        android:id="@+id/bookmark_url"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"/>

</LinearLayout>
\end{verbatim}

As you can see, this example is very simple. Row layouts, however, can
be as simple or complex as you need them to be to display your content.

Next, you'll create the adapter class.

\subsubsection{Creating the Adapter
Class}\label{creating-the-adapter-class-2}

\href{https://developer.android.com/guide/topics/ui/declaring-layout.html\#AdapterViews}{Android
adapters} fill a layout with content. In the example Bookmark List
Screenlet, the layout is the row layout (\texttt{bookmark\_row.xml}) and
the content is each list item (a URL). To make list scrolling smooth,
the adapter class should use an
\href{https://developer.android.com/training/improving-layouts/smooth-scrolling.html\#ViewHolder}{Android
view holder}. To make this easier, you can extend the list Screenlet
framework's
\href{https://github.com/liferay/liferay-screens/blob/master/android/library/src/main/java/com/liferay/mobile/screens/base/list/BaseListAdapter.java}{\texttt{BaseListAdapter}
class} with your model class and view holder as type arguments. By
extending \texttt{BaseListAdapter}, your adapter needs only two methods:

\begin{itemize}
\tightlist
\item
  \texttt{createViewHolder}: instantiates the view holder
\item
  \texttt{fillHolder}: fills in the view holder for each row
\end{itemize}

Your view holder should also contain variables for any data each row
needs to display. The view holder must assign these variables to the
corresponding row layout elements, and set the appropriate data to them.

For example, Bookmark List Screenlet's adapter class
(\texttt{BookmarkAdapter}) extends \texttt{BaseListAdapter} with
\texttt{Bookmark} and \texttt{BookmarkAdapter.BookmarkViewHolder} as
type arguments. This class's view holder is an inner class that extends
\texttt{BaseListAdapter}'s view holder. Since Bookmark List Screenlet
only needs to display a URL in each row, the view holder only needs one
variable: \texttt{url}. The view holder's constructor assigns the
\texttt{TextView} from \texttt{bookmark\_row.xml} to this variable. The
\texttt{bind} method then sets the bookmark's URL as the
\texttt{TextView}'s text. The other methods in \texttt{BookmarkAdapter}
leverage the view holder. The \texttt{createViewHolder} method
instantiates \texttt{BookmarkViewHolder}. The \texttt{fillHolder} method
calls the view holder's \texttt{bind} method to set the bookmark's URL
as the \texttt{url} variable's text:

\begin{verbatim}
public class BookmarkAdapter extends BaseListAdapter<Bookmark, BookmarkAdapter.BookmarkViewHolder> {

    public BookmarkAdapter(int layoutId, int progressLayoutId, BaseListAdapterListener listener) {
        super(layoutId, progressLayoutId, listener);
    }

    @NonNull
    @Override
    public BookmarkViewHolder createViewHolder(View view, BaseListAdapterListener listener) {
        return new BookmarkAdapter.BookmarkViewHolder(view, listener);
    }

    @Override
    protected void fillHolder(Bookmark entry, BookmarkViewHolder holder) {
        holder.bind(entry);
    }

    public class BookmarkViewHolder extends BaseListAdapter.ViewHolder {

        private final TextView url;

        public BookmarkViewHolder(View view, BaseListAdapterListener listener) {
            super(view, listener);

            url = (TextView) view.findViewById(R.id.bookmark_url);
        }

        public void bind(Bookmark entry) {
            url.setText(entry.getUrl());
        }
    }
}
\end{verbatim}

Great! Your adapter class is finished. Next, you'll create the View
class.

\subsubsection{Creating the View Class}\label{creating-the-view-class-2}

Now that your adapter exists, you can create your list Screenlet's View
class. Recall from
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-android-screenlets\#creating-the-screenlets-ui}{the
basic Screenlet creation tutorial} that the View class is the central
hub of any Screenlet's UI. It renders the UI, handles user interactions,
and communicates with the Screenlet class. The list Screenlet framework
provides most of this functionality for you via
\href{https://github.com/liferay/liferay-screens/blob/master/android/library/src/main/java/com/liferay/mobile/screens/base/list/BaseListScreenletView.java}{the
\texttt{BaseListScreenletView} class}. Your View class must extend this
class to provide your row layout ID and an instance of your adapter.
You'll do this by overriding \texttt{BaseListScreenletView}'s
\texttt{getItemLayoutId} and \texttt{createListAdapter} methods. Note
that in many cases this is the only custom functionality your View class
needs. If it needs more, you can provide it by creating new methods or
overriding other \texttt{BaseListScreenletView} methods.

Create your View class by extending \texttt{BaseListScreenletView} with
your model class, view holder, and adapter as type arguments. This is
required for your View class to represent your model objects in a view
holder, inside an adapter. For example, Bookmark List Screenlet's View
class (\texttt{BookmarkListView}) must represent \texttt{Bookmark}
instances in a \texttt{BookmarkViewHolder} inside a
\texttt{BookmarkAdapter}. The \texttt{BookmarkListView} class must
therefore extend \texttt{BaseListScreenletView} parameterized with
\texttt{Bookmark}, \texttt{BookmarkAdapter.BookmarkViewHolder}, and
\texttt{BookmarkAdapter}. Besides overriding \texttt{createListAdapter}
to return a \texttt{BookmarkAdapter} instance, the only other
functionality that this View class needs to support is to get the layout
for each row in the list. The overridden \texttt{getItemLayoutId} method
does this by returning the row layout \texttt{bookmark\_row}:

\begin{verbatim}
import android.content.Context;
import android.util.AttributeSet;

import com.liferay.mobile.screens.base.list.BaseListScreenletView;

public class BookmarkListView
    extends BaseListScreenletView<Bookmark, BookmarkAdapter.BookmarkViewHolder, BookmarkAdapter> {

    public BookmarkListView(Context context) {
        super(context);
    }

    public BookmarkListView(Context context, AttributeSet attributes) {
        super(context, attributes);
    }

    public BookmarkListView(Context context, AttributeSet attributes, int defaultStyle) {
        super(context, attributes, defaultStyle);
    }

    @Override
    protected BookmarkAdapter createListAdapter(int itemLayoutId, int itemProgressLayoutId) {
        return new BookmarkAdapter(itemLayoutId, itemProgressLayoutId, this);
    }

    @Override
    protected int getItemLayoutId() {
        return R.layout.bookmark_row;
    }
}
\end{verbatim}

Next, you'll create your View's main layout.

\subsubsection{Creating the View's Main
Layout}\label{creating-the-views-main-layout}

Although you already created a layout for your list rows, you must still
create a layout to define the list as a whole. This layout must contain:

\begin{itemize}
\tightlist
\item
  The View class's fully qualified name as the layout's first element.
\item
  An
  \href{http://developer.android.com/training/material/lists-cards.html\#RecyclerView}{Android
  \texttt{RecyclerView}} to let your app efficiently scroll through a
  potentially large list of items.
\item
  An
  \href{https://developer.android.com/reference/android/widget/ProgressBar.html}{Android
  \texttt{ProgressBar}} to indicate progress when loading the list.
\end{itemize}

Apart from the View class and styling, this layout's code is the same
for all list Screenlets. For example, here's Bookmark List Screenlet's
layout \texttt{res/layout/list\_bookmarks.xml}:

\begin{verbatim}
<com.liferay.mobile.screens.listbookmark.BookmarkListView
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:id="@+id/liferay_list_screenlet"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <ProgressBar
        android:id="@+id/liferay_progress"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="center"
        android:visibility="gone"/>

    <android.support.v7.widget.RecyclerView
        android:id="@+id/liferay_recycler_list"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:visibility="gone"/>
</com.liferay.mobile.screens.listbookmark.BookmarkListView>
\end{verbatim}

\noindent\hrulefill

\textbf{Warning:} The \texttt{android:id} values in your View's layout
XML must \textbf{exactly} match the ones shown here. These values are
hardcoded into the Screens framework and changing them will cause your
app to crash.

\noindent\hrulefill

Great job! Your View is finished. Next, you'll create your Screenlet's
Interactor.

\subsection{Creating the Screenlet's
Interactor}\label{creating-the-screenlets-interactor-1}

Recall from
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-android-screenlets\#creating-the-screenlets-Interactor-class}{the
basic Screenlet creation tutorial} that Interactors retrieve and process
a server call's results. Also recall that the following components make
up an Interactor:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Event
\item
  Listener
\item
  Interactor Class
\end{enumerate}

These components perform the same basic functions in list Screenlets as
they do in non-list Screenlets. Creating them, however, is a bit
different. Each of the following sections show you how to create one of
these components. First, you'll create the event.

\subsubsection{Creating the Event}\label{creating-the-event}

Screens uses the \href{http://greenrobot.org/eventbus/}{EventBus}
library to handle communication within Screenlets. Screenlet components
therefore communicate with each other by using event classes that
contain the server call's results. Your list Screenlet's event class
must extend
\href{https://github.com/liferay/liferay-screens/blob/master/android/library/src/main/java/com/liferay/mobile/screens/base/list/interactor/ListEvent.java}{the
\texttt{ListEvent} class} parameterized with your model class. Your
event class should also contain a private instance variable for the
model class, a constructor that sets this variable, and a no-argument
constructor that calls the superclass constructor. For example, Bookmark
List Screenlet's event class (\texttt{BookmarkEvent}) communicates
\texttt{Bookmark} objects. It therefore extends \texttt{ListEvent} with
\texttt{Bookmark} as a type argument, and defines a private
\texttt{Bookmark} variable that its
\texttt{BookmarkEvent(Bookmark\ bookmark)} constructor sets:

\begin{verbatim}
public class BookmarkEvent extends ListEvent<Bookmark> {

      private Bookmark bookmark;

      public BookmarkEvent() {
            super();
      }

      public BookmarkEvent(Bookmark bookmark) {
          this.bookmark = bookmark;
      }
    ...
\end{verbatim}

You must also implement \texttt{ListEvent}'s abstract methods in your
event class. Note that these methods support
\href{/docs/7-0/tutorials/-/knowledge_base/t/using-offline-mode-in-android}{offline
mode}. Although these methods are briefly described here, supporting
offline mode in your Screenlets is addressed in detail in a separate
tutorial.

\begin{itemize}
\item
  \texttt{getListKey}: returns the ID for the cache. This ID is
  typically the data each list row displays. For example, the
  \texttt{getListKey} method in \texttt{BookmarkEvent} returns the
  bookmark's URL:

\begin{verbatim}
  @Override
  public String getListKey() {
      return bookmark.getUrl();
  }
\end{verbatim}
\item
  \texttt{getModel}: unwraps the model entity to the cache by returning
  the model class instance. For example, the \texttt{getModel} method in
  \texttt{BookmarkEvent} method returns the bookmark:

\begin{verbatim}
  @Override
  public Bookmark getModel() {
      return bookmark;
  }
\end{verbatim}
\end{itemize}

Next, you'll create your Screenlet's listener.

\subsubsection{Creating the Listener}\label{creating-the-listener}

Recall that listeners let the app developer respond to events that occur
in Screenlets. For example, an app developer using Login Screenlet in an
activity must implement \texttt{LoginListener} in that activity to
respond to login success or failure. When creating a list Screenlet,
however, you don't have to create a separate listener. Developers can
use your list Screenlet in an activity or fragment by implementing
\href{https://github.com/liferay/liferay-screens/blob/master/android/library/src/main/java/com/liferay/mobile/screens/base/list/BaseListListener.java}{the
\texttt{BaseListListener} interface} parameterized with your model
class. For example, to use Bookmark List Screenlet in an activity, an
app developer's activity declaration could look like this:

\begin{verbatim}
public class BookmarkListActivity extends AppCompatActivity 
    implements BaseListListener<Bookmark> {...
\end{verbatim}

The \texttt{BaseListListener} interface defines the following methods
that the app developer can implement in their activity or fragment:

\begin{itemize}
\item
  \texttt{void\ onListPageFailed(int\ startRow,\ Exception\ e)}:
  Responds to the Screenlet's failure to retrieve entities from the
  server.
\item
  \texttt{void\ onListPageReceived(int\ startRow,\ int\ endRow,\ List\textless{}E\textgreater{}\ entries,\ int\ rowCount)}:
  Responds to the Screenlet's success in retrieving entities from the
  server.
\item
  \texttt{void\ onListItemSelected(E\ element,\ View\ view)}: Responds
  to a user selection in the list.
\end{itemize}

If these methods meet your list Screenlet's needs, then you can move on
to the next section in this tutorial. If you want to let app developers
respond to more actions, however, you must create your own listener that
extends \texttt{BaseListListener} parameterized with your model class.
For example, Bookmark List Screenlet contains such a listener:
\texttt{BookmarkListListener}. This listener defines a single method
that notifies the app developer when the Interactor is called:

\begin{verbatim}
public interface BookmarkListListener extends BaseListListener<Bookmark> {
    void interactorCalled();
}
\end{verbatim}

Next, you'll create the Interactor class.

\subsubsection{Creating the Interactor
Class}\label{creating-the-interactor-class-2}

Recall that as an Interactor's central component, the Interactor class
makes the service call to retrieve entities from Liferay DXP, and
processes the results of that call. The list Screenlet framework's
\href{https://github.com/liferay/liferay-screens/blob/master/android/library/src/main/java/com/liferay/mobile/screens/base/list/interactor/BaseListInteractor.java}{\texttt{BaseListInteractor}
class} provides most of the functionality that Interactor classes in
list Screenlets require. You must, however, extend
\texttt{BaseListInteractor} to make your service calls and handle their
results via your model and event classes. Your Interactor class must
therefore extend \texttt{BaseListInteractor}, parameterized with
\texttt{BaseListInteractorListener\textless{}YourModelClass\textgreater{}}
and your event class. For example, Bookmark List Screenlet's Interactor
class, \texttt{BookmarkListInteractor}, extends
\texttt{BaseListInteractor} parameterized with
\texttt{BaseListInteractorListener\textless{}Bookmark\textgreater{}} and
\texttt{BookmarkEvent}:

\begin{verbatim}
public class BookmarkListInteractor extends 
    BaseListInteractor<BaseListInteractorListener<Bookmark>, BookmarkEvent> {...
\end{verbatim}

Your Interactor must also override the methods needed to make the server
call and process the results:

\begin{itemize}
\item
  \texttt{getPageRowsRequest}: Retrieves the specified page of entities.
  In the example \texttt{BookmarkListInteractor}, this method first uses
  the \texttt{args} parameter to retrieve the ID of the folder to
  retrieve bookmarks from. It then sets the comparator (more on this
  shortly) if the app developer sets one when inserting the Screenlet
  XML in a fragment or activity. The \texttt{getPageRowsRequest} method
  finishes by calling \texttt{BookmarksEntryService}'s
  \texttt{getEntries} method to retrieve a page of bookmarks. Note that
  the service call, like the service call in the
  \href{/docs/7-0/tutorials/-/knowledge_base/t/creating-android-screenlets\#creating-the-screenlets-Interactor-class}{basic
  Screenlet creation tutorial}, uses
  \texttt{LiferayServerContext.isLiferay7()} to check the portal version
  to make sure the correct service instance is used. This isn't required
  if you only plan to use your Screenlet with one portal version. Also
  note that the \texttt{groupId} variable used to make the service calls
  isn't set anywhere in \texttt{getPageRowsRequest} or
  \texttt{BookmarkListInteractor}. Interactors that extend
  \texttt{BaseListInteractor}, like \texttt{BookmarkListInteractor},
  inherit this variable via the Screens framework. You'll set it when
  you create the Screenlet class. Here's
  \texttt{BookmarkListInteractor}'s complete \texttt{getPageRowsRequest}
  method:

\begin{verbatim}
  @Override
  protected JSONArray getPageRowsRequest(Query query, Object... args) throws Exception {
      long folderId = (long) args[0];

      if (args[1] != null) {
          query.setComparator((String) args[1]);
      }

      if (LiferayServerContext.isLiferay7()) {
          return new BookmarksEntryService(getSession()).getEntries(groupId, folderId, 
              query.getStartRow(), query.getEndRow(), query.getComparatorJSONWrapper());
      } else {
          return new com.liferay.mobile.android.v62.bookmarksentry.BookmarksEntryService(
              getSession()).getEntries(groupId, folderId, query.getStartRow(), 
              query.getEndRow(), query.getComparatorJSONWrapper());
      }
  }
\end{verbatim}

  You might now be asking yourself what a comparator is. A comparator is
  a class in the Liferay DXP instance that sorts a portlet's entities.
  For example, the Bookmarks portlet contains several comparators that
  can sort entities by different criteria.
  \href{https://github.com/liferay/liferay-portal/tree/master/modules/apps/collaboration/bookmarks/bookmarks-api/src/main/java/com/liferay/bookmarks/util/comparator}{Click
  here} to see these comparators. Although it's not required, you can
  develop your list Screenlet to use a comparator to sort its entities.
  Since Bookmark List Screenlet supports comparators, you'll see more of
  this as you progress through this tutorial.
\item
  \texttt{getPageRowCountRequest}: Retrieves the number of entities, to
  enable pagination. In the example \texttt{BookmarkListInteractor},
  this method first uses the \texttt{args} parameter to get the ID of
  the folder in which to count bookmarks. It then calls
  \texttt{BookmarksEntryService}'s \texttt{getEntriesCount} method to
  retrieve the number of bookmarks:

\begin{verbatim}
  @Override
  protected Integer getPageRowCountRequest(Object... args) throws Exception {
      long folderId = (long) args[0];

      if (LiferayServerContext.isLiferay7()) {
          return new BookmarksEntryService(getSession()).getEntriesCount(groupId, folderId);
      } else {
          return new com.liferay.mobile.android.v62.bookmarksentry.BookmarksEntryService(
              getSession()).getEntriesCount(groupId, folderId);
      }
  }
\end{verbatim}
\item
  \texttt{createEntity}: Returns an instance of your event that contains
  the server call's results. This method receives the results as
  \texttt{Map\textless{}String,\ Object\textgreater{}}, which it uses to
  instantiate your model class. It then uses this model instance to
  create the event object. In the example
  \texttt{BookmarkListInteractor}, this method passes the
  \texttt{Map\textless{}String,\ Object\textgreater{}} to the
  \texttt{Bookmark} constructor. It then uses the resulting
  \texttt{Bookmark} to create and return a \texttt{BookmarkEvent}:

\begin{verbatim}
  @Override
  protected BookmarkEvent createEntity(Map<String, Object> stringObjectMap) {
      Bookmark bookmark = new Bookmark(stringObjectMap);
      return new BookmarkEvent(bookmark);
  }
\end{verbatim}
\item
  \texttt{getIdFromArgs}: a boilerplate method that returns the value of
  the first object argument as a string. This serves as a cache key for
  \href{/docs/7-0/tutorials/-/knowledge_base/t/using-offline-mode-in-android}{offline
  mode}:

\begin{verbatim}
  @Override
  protected String getIdFromArgs(Object... args) {
      return String.valueOf(args[0]);
  }
\end{verbatim}

  You must implement this method even if you don't intend to support
  offline mode in your Screenlet. Having this method in your Interactor
  class makes it simpler to add offline mode functionality later.
  Supporting offline mode in your Screenlets is addressed in detail in a
  separate tutorial.
\end{itemize}

To see the complete \texttt{BookmarkListInteractor} class,
\href{https://github.com/liferay/liferay-screens/blob/master/android/samples/listbookmarkscreenlet/src/main/java/com/liferay/mobile/screens/listbookmark/BookmarkListInteractor.java}{click
here}.

Next, you'll create the Screenlet class.

\subsection{Creating the Screenlet
Class}\label{creating-the-screenlet-class-4}

Recall from
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-android-screenlets\#creating-the-screenlet-class}{the
basic Screenlet creation tutorial} that the Screenlet class serves as
your Screenlet's focal point. It governs the Screenlet's behavior and is
the primary component the app developer interacts with. As with non-list
Screenlets, you should first define any XML attributes that you want to
make available to the app developer. For example, Bookmark List
Screenlet defines the following attributes:

\begin{itemize}
\tightlist
\item
  \texttt{groupId}: the ID of the site containing the Bookmarks portlet
\item
  \texttt{folderId}: the ID of the Bookmarks portlet folder to retrieve
  bookmarks from
\item
  \texttt{comparator}: the name of the comparator to use to sort the
  bookmarks
\end{itemize}

The Screenlet defines these attributes in its
\texttt{res/values/bookmark\_attrs.xml} file:

\begin{verbatim}
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <declare-styleable name="BookmarkListScreenlet">
        <attr name="groupId"/>
        <attr name="folderId"/>
        <attr format="string" name="comparator"/>
    </declare-styleable>
</resources>
\end{verbatim}

Now you're ready to create your Screenlet class. Because
\href{https://github.com/liferay/liferay-screens/blob/master/android/library/src/main/java/com/liferay/mobile/screens/base/list/BaseListScreenlet.java}{the
\texttt{BaseListScreenlet} class} provides the basic functionality for
all Screenlet classes in list Screenlets, including methods for
pagination and other default behavior, your Screenlet class must extend
\texttt{BaseListScreenlet} with your model class and Interactor as type
arguments.

For example, Bookmark List Screenlet's Screenlet
class--\texttt{BookmarkListScreenlet}--extends
\texttt{BaseListScreenlet} parameterized with \texttt{Bookmark} and
\texttt{BookmarkListInteractor}:

\begin{verbatim}
public class BookmarkListScreenlet 
    extends BaseListScreenlet<Bookmark, BookmarkListInteractor> {...
\end{verbatim}

You must also create instance variables for the XML attributes that you
want to pass to your Interactor. For example, recall that the request
methods in \texttt{BookmarkListInteractor} receive two \texttt{Object}
arguments: the folder ID and the comparator. The
\texttt{BookmarkListScreenlet} class must therefore contain variables
for these parameters so it can pass them to the Interactor:

\begin{verbatim}
private long folderId;
private String comparator;
\end{verbatim}

For constructors, leverage the superclass constructors. For example,
here are \texttt{BookmarkListScreenlet}'s constructors:

\begin{verbatim}
public BookmarkListScreenlet(Context context) {
    super(context);
}

public BookmarkListScreenlet(Context context, AttributeSet attrs) {
    super(context, attrs);
}

public BookmarkListScreenlet(Context context, AttributeSet attrs, int defStyleAttr) {
    super(context, attrs, defStyleAttr);
}

public BookmarkListScreenlet(Context context, AttributeSet attrs, int defStyleAttr, 
    int defStyleRes) {
        super(context, attrs, defStyleAttr, defStyleRes);
}
\end{verbatim}

Now you must implement the \texttt{error} method. This is a boilerplate
method that uses a listener in the Screenlet framework to propagate any
exception, and the user action that produced it, that occurs during the
service call. This method does this by checking for a listener and then
calling its \texttt{error} method with the \texttt{Exception} and
\texttt{userAction}:

\begin{verbatim}
@Override
public void error(Exception e, String userAction) {
    if (getListener() != null) {
        getListener().error(e, userAction);
    }
}
\end{verbatim}

Next, override the \texttt{createScreenletView} method to read the
values of the XML attributes you defined earlier and create the
Screenlet's View. Recall from
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-android-screenlets\#creating-the-screenlet-class}{the
basic Screenlet creation tutorial} that this method assigns the
attribute values to their corresponding instance variables. For example,
the \texttt{createScreenletView} method in
\texttt{BookmarkListScreenlet} assigns the \texttt{folderId} and
\texttt{comparator} attribute values to variables of the same name. This
method also sets the local variable \texttt{groupId}. Recall that the
Screens framework propagates this variable to your Interactor. Finish
the \texttt{createScreenletView} method by calling the superclass's
\texttt{createScreenletView} method. This instantiates the View for you:

\begin{verbatim}
@Override
protected View createScreenletView(Context context, AttributeSet attributes) {
    TypedArray typedArray = context.getTheme().obtainStyledAttributes(attributes, 
        R.styleable.BookmarkListScreenlet, 0, 0);
    groupId = typedArray.getInt(R.styleable.BookmarkListScreenlet_groupId, 
        (int) LiferayServerContext.getGroupId());
    folderId = typedArray.getInt(R.styleable.BookmarkListScreenlet_folderId, 0);
    comparator = typedArray.getString(R.styleable.BookmarkListScreenlet_comparator);
    typedArray.recycle();

    return super.createScreenletView(context, attributes);
}
\end{verbatim}

Next, override the \texttt{loadRows} method to start your Interactor and
thereby retrieve the list rows from the server. This method takes an
instance of your Interactor as an argument, which you use to call the
Interactor's \texttt{start} method. Note that the Interactor inherits
\texttt{start} from \texttt{BaseListInteractor}. You can also use the
\texttt{loadRows} method to execute any other code that you want to run
when the Interactor starts. For example, the \texttt{loadRows} method in
\texttt{BookmarkListScreenlet} first retrieves a listener instance so it
can call the listener's \texttt{interactorCalled} method. It then starts
the server operation to retrieve the list rows by calling the
Interactor's \texttt{start} method with \texttt{folderId} and
\texttt{comparator}:

\begin{verbatim}
@Override
protected void loadRows(BookmarkListInteractor interactor) {

    ((BookmarkListListener) getListener()).interactorCalled();

    interactor.start(folderId, comparator);
}
\end{verbatim}

Note that if your Interactor doesn't require arguments, then you can
pass the \texttt{start} method \texttt{0} or \texttt{null}. Calling
\texttt{start} with no arguments, however, causes the server call to
fail.

Lastly, override the \texttt{createInteractor} method to instantiate
your Interactor. Since that's all this method needs to do, call your
Interactor's constructor and return the new instance. For example,
\texttt{BookmarkListScreenlet}'s \texttt{createInteractor} method
returns a new \texttt{BookmarkListInteractor}:

\begin{verbatim}
@Override
protected BookmarkListInteractor createInteractor(String actionName) {
    return new BookmarkListInteractor();
}
\end{verbatim}

You're done! Your Screenlet is a ready-to-use component that you can use
in your app. You can even
\href{/docs/7-0/tutorials/-/knowledge_base/t/packaging-your-android-screenlets}{package
your Screenlet} and contribute it to the Screens project, or distribute
it in Maven Central or jCenter.

\subsection{Using the Screenlet}\label{using-the-screenlet}

You can now use your new list Screenlet
\href{/docs/7-0/tutorials/-/knowledge_base/t/using-screenlets-in-android-apps}{the
same way you use any other Screenlet}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Insert the Screenlet's XML in the layout of the activity or fragment
  you want to use the Screenlet in. For example, here's Bookmark List
  Screenlet's XML:

\begin{verbatim}
 <com.liferay.mobile.screens.listbookmark.BookmarkListScreenlet
     android:id="@+id/bookmarklist_screenlet"
     android:layout_width="match_parent"
     android:layout_height="match_parent"
     app:comparator="FULLY_QUALIFIED_COMPARATOR_CLASS"
     app:folderId="YOUR_FOLDER_ID"
     app:groupId="YOUR_GROUP_ID"
     app:layoutId="@layout/list_bookmarks"/>
\end{verbatim}

  Note that to set a comparator, you must use its fully qualified class
  name. For example, to use
  \href{https://github.com/liferay/liferay-portal/blob/7.0.6-ga7/modules/apps/collaboration/bookmarks/bookmarks-api/src/main/java/com/liferay/bookmarks/util/comparator/EntryURLComparator.java}{the
  Bookmarks portlet's \texttt{EntryURLComparator}}, set
  \texttt{app:comparator} in the Screenlet XML as follows:

\begin{verbatim}
 app:comparator="com.liferay.bookmarks.util.comparator.EntryURLComparator"
\end{verbatim}
\item
  Implement the Screenlet's listener in the activity or fragment class.
  If your list Screenlet doesn't have a custom listener, then you can do
  this by implementing \texttt{BaseListListener} parameterized with your
  model class. For example:

\begin{verbatim}
 public class YourListActivity extends AppCompatActivity 
     implements BaseListListener<YourModelClass> {...
\end{verbatim}

  If you created a custom listener for your list Screenlet, however,
  then your activity or fragment must implement it instead. For example,
  recall that the example Bookmark List Screenlet's listener is
  \texttt{BookmarkListListener}. To use this Screenlet, you must
  therefore implement this listener in the class of the activity or
  fragment that you want to use the Screenlet in. For example:

\begin{verbatim}
 public class ListBookmarksActivity extends AppCompatActivity 
     implements BookmarkListListener {...
\end{verbatim}

  See the full example of this
  \href{https://github.com/liferay/liferay-screens/blob/master/android/samples/test-app/src/main/java/com/liferay/mobile/screens/testapp/ListBookmarksActivity.java}{here
  in GitHub}.
\end{enumerate}

Well done! Now you know how to create list Screenlets.

\subsection{Related Topics}\label{related-topics-70}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-android-screenlets}{Creating
Android Screenlets}

\href{/docs/7-0/tutorials/-/knowledge_base/t/architecture-of-liferay-screens-for-android}{Architecture
of Liferay Screens for Android}

\href{/docs/7-0/tutorials/-/knowledge_base/t/packaging-your-android-screenlets}{Packaging
Your Android Screenlets}

\href{/docs/7-0/tutorials/-/knowledge_base/t/using-views-in-android-screenlets}{Using
Views in Android Screenlets}

\href{/docs/7-0/tutorials/-/knowledge_base/t/using-screenlets-in-android-apps}{Using
Screenlets in Android Apps}

\section{Creating Android Views}\label{creating-android-views}

By creating your own Views, you can customize your mobile app's layout,
style, and functionality. You can create them from scratch or use an
existing View as a foundation. Views include a View class for
implementing Screenlet behavior, a Screenlet class for notifying
listeners and invoking Interactors, and an XML file for specifying the
UI. The four Liferay Screens View types support different levels of
customization and parent View inheritance. Here's what each View type
offers:

\textbf{Themed View:} presents the same structure as the current View,
but alters the theme colors and tints of the View's resources. All
existing Views can be themed with different styles. The View's colors
reflect the current value of the Android
\href{https://www.google.com/design/spec/style/color.html\#color-color-palette}{color
palette}. If you want to use one View Set with another View Set's
colors, you can use those colors in your app's theme
(e.g.~\texttt{colorPrimary\_default}, \texttt{colorPrimary\_material},
\texttt{colorPrimary\_westeros}).

\textbf{Child View:} presents the same UI components as its parent View,
but lets you change their appearance and position.

\textbf{Extended View:} inherits its parent View's functionality and
appearance, but lets you add to and modify both.

\textbf{Full View:} provides a complete standalone View for a Screenlet.
A full View is ideal for implementing completely different functionality
and appearance from a Screenlet's current theme.

This tutorial explains how to create all four types of Views. To
understand View concepts and components, you might want to examine the
\href{/docs/7-0/tutorials/-/knowledge_base/t/architecture-of-liferay-screens-for-android}{architecture}
of Liferay Screens for Android. And the tutorial
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-android-screenlets}{Creating
Android Screenlets} can help you create or extend any Screenlet classes
your View requires. Now get ready to create some great Views!

\subsection{Determining Your View's
Location}\label{determining-your-views-location}

First, decide whether you'll reuse your view or if it's just for your
current app. If you don't plan to reuse it in another app or don't want
to redistribute it, create it in your app project.

If you want to reuse your View in another app, create it in a new
Android application module; the tutorial
\href{/docs/7-0/tutorials/-/knowledge_base/t/packaging-your-android-screenlets}{Packaging
Android Screenlets} explains how. When your View's project is in place,
you can start creating it.

First, you'll learn how to create a Themed View.

\subsection{Themed View}\label{themed-view}

Screens provides several existing View Sets that you can reuse and
customize in your app to create a Themed View. If you use or override
the Android color palette's values (for example, \texttt{primaryColor},
\texttt{secondaryColor}, etc\ldots), you'll reuse the View Set's general
structure, but be able to use the new colors (also with tinted
resources). Note that you must create Themed Views inside your app. This
is because Themed Views depend on the app or activity theme.

Each View Set has its own Android theme. These are listed here:

\begin{itemize}
\tightlist
\item
  \textbf{Default View Set:} \texttt{default\_theme}
\item
  \textbf{Material View Set:} \texttt{material\_theme}
\item
  \textbf{Westeros View Set:} \texttt{westeros\_theme}
\end{itemize}

You can easily style all your Screenlets by setting your app or activity
theme to inherit a View Set's Android theme. For example, you can use
the following code to reuse the styles (and layouts) from
\texttt{material\_theme} in your own theme:

\begin{verbatim}
<style name="AppTheme.NoActionBar" parent="material_theme">
    <item name="colorPrimary">#B91D6D</item>
    <item name="colorPrimaryDark">#670E3B</item>
    <item name="colorAccent">#BBBBBB</item>
</style>

<application android:theme="@style/AppTheme.NoActionBar"
    ...
>
\end{verbatim}

Note that this code overrides the \texttt{AppTheme.NoActionBar} theme's
colors with your own color settings for \texttt{colorPrimary},
\texttt{colorPrimaryDark}, and \texttt{colorAccent}. Screenlets will
also use these new colors, and tint images and other resources
accordingly. Liferay Screens uses the default Android color palette
names from the Support Library.

You can also override only the parent View Set's theme colors. This way
you can set a default color palette and override only the View Set
colors you want. The color names for each View Set are the default
Android names, followed by an underscore and the View Set's lowercase
name (\texttt{\_default}, \texttt{\_material}, and \texttt{\_westeros}).
For example, the following code overrides \texttt{colorPrimary},
\texttt{colorPrimaryDark}, and \texttt{colorAccent} for only the
\texttt{material\_theme}:

\begin{verbatim}
<resources>
    <color name="colorPrimary_material">#B91D6D</color>
    <color name="colorPrimaryDark_material">#670E3B</color>
    <color name="colorAccent_material">#BBBBBB</color>
</resources>
\end{verbatim}

Liferay Screens also lets you use one View Set's layout with a
Screenlet, and use another View Set's general style and colors. To do
this, pass a \texttt{layoutId} attribute to a Screenlet that is already
styled with another View Set's theme. The Screenlet uses the layout
structure specified in \texttt{layoutId}, but inherits the general style
and colors from the View Set's theme. For example, this code tells Login
Screenlet to use the Default View Set's layout structure, but use the
styles and colors defined earlier in \texttt{AppTheme.NoActionBar}:

\begin{verbatim}
<com.liferay.mobile.screens.auth.login.LoginScreenlet
    android:id="@+id/login_screenlet"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    app:basicAuthMethod="email"
    app:layoutId="@layout/login_default"
    app:credentialsStorage="shared_preferences" />

<application android:theme="@style/AppTheme.NoActionBar"
    ...
>
\end{verbatim}

Next, you'll learn how to create a Child View.

\subsection{Child View}\label{child-view}

A Child View presents the same behavior and UI components as its parent,
but can change the UI components' appearance and position. It can't add
or remove any UI components. A Child View specifies visual changes in
its own layout XML file; it inherits the parent's View class and
Screenlet class. The parent must be a Full View.

The Child View discussed here presents the same UI components as the
\href{https://github.com/liferay/liferay-screens/tree/master/android/library/core/src/main/java/com/liferay/mobile/screens/auth/login}{Login
Screenlet's} Default View, but uses a more compact layout.

You can follow these steps to create a Child View:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a new layout XML file named after the View's Screenlet and its
  intended use case. A good way to start building your UI is to
  duplicate the parent's layout XML file and use it as a template.
  However you start building your UI, name the root element after the
  parent View's fully-qualified class name and specify the parent's UI
  components with the same IDs.

  In the example here, the Child View's layout file
  \texttt{login\_compact.xml} resembles its parent's layout file
  \href{https://github.com/liferay/liferay-screens/blob/master/android/library/core/src/main/res/layout/login_default.xml}{\texttt{login\_default.xml}}--
  the layout of the Login Screenlet's Default View. The child View's
  name \emph{compact} describes its use case: display the Screenlet's
  components in a more compact layout. The IDs of its \texttt{EditText}
  and \texttt{Button} components match those of the parent View. Its
  root element uses the parent View class's fully-qualified name:

\begin{verbatim}
<?xml version="1.0" encoding="utf-8"?>
<com.liferay.mobile.screens.viewsets.defaultviews.auth.login.LoginView
    xmlns:android="http://schemas.android.com/apk/res/android"
    style="@style/default_screenlet">

    <EditText
        android:id="@+id/liferay_login"
        style="@style/default_edit_text"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_marginBottom="15dp"
        android:drawableLeft="@drawable/default_mail_icon"
        android:hint="@string/email_address"
        android:inputType="text" />

    <EditText
        android:id="@+id/liferay_password"
        style="@style/default_edit_text"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_marginBottom="15dp"
        android:drawableLeft="@drawable/default_lock_icon"
        android:hint="@string/password"
        android:inputType="textPassword" />

    <Button
        android:id="@+id/liferay_login_button"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        style="@style/default_button"
        android:text="@string/sign_in" />

</com.liferay.mobile.screens.viewsets.defaultviews.auth.login.LoginView>
\end{verbatim}

  You can browse other layouts for Screens's Default Views on
  \href{https://github.com/liferay/liferay-screens/tree/master/android/library/core/src/main/res/layout}{GitHub}.
\item
  Insert your View's Screenlet in any of your activities or fragments,
  using your new layout's name as the \texttt{liferay:layoutId}
  attribute's value. For example, to use the new \texttt{login\_compact}
  layout, insert \texttt{LoginScreenlet} in an activity or fragment and
  set \texttt{liferay:layoutId="@layout/login\_compact"}.
\end{enumerate}

Another good Child View layout file to examine is
\href{https://github.com/liferay/liferay-screens/blob/master/android/viewsets/material/src/main/res/layout/sign_up_material.xml}{\texttt{sign\_up\_material.xml}}.
It presents the same UI components and functionality as the Sign Up
Screenlet's Default View, but using
\href{http://www.google.com/design/spec/material-design/introduction.html}{Android's
Material design}.

Stupendous! Now you know how to create Child Views. Next, you'll learn
how to create Extended Views.

\subsection{Extended View}\label{extended-view}

An Extended View inherits the parent View's behavior and appearance, but
lets you change and add to both. You can do so by writing a custom View
class and a new layout XML file. An Extended View inherits all of the
parent View's other classes, including its Screenlet, listeners, and
Interactors. An Extended View's parent must be a Full View.

The example Extended View discussed here presents the same UI components
as the Login Screenlet's Default View, but adds functionality: computing
password strength. Of course, you're not restricted to password strength
computations; you can implement anything you want.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a new layout XML file named after the View's Screenlet and its
  intended use case. A good way to start building your UI is to
  duplicate the parent's layout XML file and use it as a template. The
  new layout file for the Login Screenlet's Extended View is called
  \texttt{login\_password.xml}, because it's based on the Login
  Screenlet's Default View layout file
  \href{https://github.com/liferay/liferay-screens/blob/master/android/library/core/src/main/res/layout/login_default.xml}{\texttt{login\_default.xml}}
  and it adds a password strength computation.
\item
  Create a new custom View class that extends the parent View class.
  Name it after the Screenlet and the functionality you'll add or
  override. The example View class \texttt{LoginCheckPasswordView}
  extends the Default View's
  \href{https://github.com/liferay/liferay-screens/blob/master/android/library/core/src/main/java/com/liferay/mobile/screens/viewsets/defaultviews/auth/login/LoginView.java}{\texttt{LoginView}}
  class, overriding the \texttt{onClick} method to compute password
  strength:

\begin{verbatim}
public class LoginCheckPasswordView extends LoginView {

    // parent's constructors go here...

    @Override
    public void onClick(View view) {
        // compute password strength

        if (passwordIsStrong) {
            super.onClick(view);
        }
        else {
            // Present user message
        }
    }

}
\end{verbatim}
\item
  Rename the layout XML file's root element after your custom View's
  fully-qualified class name. For example, the root element in
  \texttt{login\_password.xml} is
  \texttt{com.your.package.LoginCheckPasswordView}:

\begin{verbatim}
<com.your.package.LoginCheckPasswordView
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="vertical">
    ...
\end{verbatim}
\item
  Insert your View's Screenlet in any of your activities or fragments,
  using your new layout's name as the \texttt{liferay:layoutId}
  attribute's value. For example, to use the new
  \texttt{login\_password} layout, insert \texttt{LoginScreenlet} in an
  activity or fragment, and set
  \texttt{liferay:layoutId="@layout/login\_password"}.
\end{enumerate}

The
\href{https://github.com/liferay/liferay-screens/tree/master/android/samples/bankofwesteros}{Bank
of Westeros} sample app's
\href{https://github.com/liferay/liferay-screens/tree/master/android/viewsets/westeros}{Westeros
View Set} has a couple of Extended Views that you can examine. It has an
Extended View that adds a new button to show the password in the clear
for the Login Screenlet. The View uses custom layout file
\href{https://github.com/liferay/liferay-screens/blob/master/android/viewsets/westeros/src/main/res/layout/login_westeros.xml}{\texttt{login\_westeros.xml}}
and custom View class
\href{https://github.com/liferay/liferay-screens/blob/master/android/viewsets/westeros/src/main/java/com/liferay/mobile/screens/viewsets/westeros/auth/login/LoginView.java}{\texttt{LoginView}}.
The Westeros View Set also contains an Extended View for the User
Portrait Screenlet; it changes the border color and width of the user's
portrait picture and it uses the custom layout file
\href{https://github.com/liferay/liferay-screens/blob/master/android/viewsets/westeros/src/main/res/layout/userportrait_westeros.xml}{\texttt{userportrait\_westeros.xml}}
and the custom View class
\href{https://github.com/liferay/liferay-screens/blob/master/android/viewsets/westeros/src/main/java/com/liferay/mobile/screens/viewsets/westeros/userportrait/UserPortraitView.java}{\texttt{UserPortraitView}}.

Awesome! Now you know how to create Extended Views. Next, you can learn
how to create a Full View.

\subsection{Full View}\label{full-view}

A Full View has a unique Screenlet class, a View class, and layout XML
file. It's standalone and doesn't inherit from any View. You should
create a Full View if there's no other View that you can extend to meet
your needs or if your Screenlet's behavior can only be augmented by
customizing its listeners or calling custom Interactors. To create a
Full View, you must create its Screenlet class, View class, and layout
XML file. The example Full View here for the Login Screenlet presents a
single \texttt{EditText} component for the user name. For the password,
it uses
\href{http://developer.android.com/reference/android/provider/Settings.Secure.html\#ANDROID_ID}{\texttt{Secure.ANDROID\_ID}}.
The
\href{https://github.com/liferay/liferay-screens/tree/master/android/samples/test-app}{Screens
Test App} uses
\href{https://github.com/liferay/liferay-screens/tree/master/android/samples/test-app/src/main/java/com/liferay/mobile/screens/testapp/fullview}{this
Full View}.

You can follow these steps to create a Full View:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a new layout XML file and build your UI in it. A good way to
  start building your UI is to duplicate another View's layout XML file
  and use it as a template. Name your layout XML file after the View's
  Screenlet and intended use case. Name its root element after the
  fully-qualified class name of your custom View (you'll create this
  next).

  The Test App's Full View layout XML file for the Login Screenlet is
  called
  \href{https://github.com/liferay/liferay-screens/blob/master/android/samples/test-app/src/main/res/layout/login_full.xml}{\texttt{login\_full.xml}}.
  It specifies \texttt{EditText} and \texttt{Button} elements copied
  from the LongScreenlet's Default View file
  \href{https://github.com/liferay/liferay-screens/blob/master/android/library/core/src/main/res/layout/login_default.xml}{\texttt{login\_default.xml}}.

\begin{verbatim}
<?xml version="1.0" encoding="utf-8"?>
<com.your.package.LoginFullView
        xmlns:android="http://schemas.android.com/apk/res/android"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="vertical">

<EditText
        android:id="@+id/liferay_login"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_marginBottom="20dp"
        android:hint="Email Address"
        android:inputType="textEmailAddress"/>

<Button
        android:id="@+id/liferay_login_button"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Sign In"/>

</com.your.package.LoginFullView>
\end{verbatim}
\item
  Create a new custom View class named after the layout's root element.
  The tutorial on creating Android Screenlets explains how to
  \href{/docs/7-0/tutorials/-/knowledge_base/t/creating-android-screenlets\#creating-the-screenlets-view-class}{create
  a View class}. Note that you don't have to extend a View class to
  implement a View Model interface, but you might want to for
  convenience. The custom View class
  \href{https://github.com/liferay/liferay-screens/blob/master/android/samples/test-app/src/main/java/com/liferay/mobile/screens/testapp/fullview/LoginFullView.java}{\texttt{LoginFullView}},
  for example, implements the
  \href{https://github.com/liferay/liferay-screens/blob/master/android/library/core/src/main/java/com/liferay/mobile/screens/auth/login/view/LoginViewModel.java}{\texttt{LoginViewModel}}
  interface by extending the Default
  \href{https://github.com/liferay/liferay-screens/blob/master/android/library/core/src/main/java/com/liferay/mobile/screens/viewsets/defaultviews/auth/login/LoginView.java}{\texttt{LoginView}}
  class. To return the \texttt{ANDROID\_ID}, the \texttt{LoginFullView}
  custom View class overrides the \texttt{getPassword()} method.
\item
  Create a new Screenlet class that inherits the base Screenlet class.
  This new class is where you can add custom behavior to the listeners
  or call custom Interactors. The Screenlet class
  \href{https://github.com/liferay/liferay-screens/blob/master/android/samples/test-app/src/main/java/com/liferay/mobile/screens/testapp/fullview/LoginFullScreenlet.java}{\texttt{LoginFullScreenlet}},
  for example, extends
  \href{https://github.com/liferay/liferay-screens/blob/master/android/library/core/src/main/java/com/liferay/mobile/screens/auth/login/LoginScreenlet.java}{\texttt{LoginScreenlet}}
  and overrides the \texttt{onUserAction} method to log Interactor
  calls.
\item
  Insert your View's Screenlet in any of your activities or fragments,
  using your new layout's name as the \texttt{liferay:layoutId}
  attribute's value. For example, to use the new
  \texttt{login\_password} layout, insert \texttt{LoginScreenlet} in an
  activity or fragment, and set
  \texttt{liferay:layoutId="@layout/login\_password"}.
\end{enumerate}

The
\href{https://github.com/liferay/liferay-screens/tree/master/android/viewsets/westeros/src/main/java/com/liferay/mobile/screens/viewsets/westeros/auth/signup}{Westeros
View Set's full view for the Sign Up Screenlet} uses a
\href{https://github.com/liferay/liferay-screens/blob/master/android/viewsets/westeros/src/main/java/com/liferay/mobile/screens/viewsets/westeros/auth/signup/SignUpScreenlet.java}{custom
Screenlet class} to add a
\href{https://github.com/liferay/liferay-screens/blob/master/android/viewsets/westeros/src/main/java/com/liferay/mobile/screens/viewsets/westeros/auth/signup/SignUpListener.java}{new
listener}. The custom Screenlet class also adds a new user action that
calls the base Interactor \texttt{SignUpInteractor}.

Sweetness! Now you know how to create a Full View. Next, you'll learn
how to package Views for distribution.

\subsection{Packaging Your Views}\label{packaging-your-views}

If you want to distribute or reuse Views, you should package them in a
module that is then added as an app's project dependency. To do this,
use the
\href{https://github.com/liferay/liferay-screens/tree/master/android/viewsets/material}{material}
sub-project as a template for your new
\href{https://github.com/liferay/liferay-screens/blob/master/android/viewsets/material/build.gradle}{\texttt{build.gradle}}
file.

To use a packaged View, you must import its module into your project by
specifying its location in your
\href{https://github.com/liferay/liferay-screens/blob/master/android/samples/bankofwesteros/settings.gradle}{\texttt{settings.gradle}}
file. The Bank of Westeros and test-app projects use custom Views
\texttt{westeros} and \texttt{material}, respectively. These projects
exemplify using independent Views in a project.

If you want to redistribute your View and let others use it, you can
upload it to jCenter or Maven Central. In the example
\href{https://github.com/liferay/liferay-screens/blob/master/android/samples/bankofwesteros/build.gradle}{\texttt{build.gradle}}
file, after entering your bintray api key you can execute
\texttt{gradlew\ bintrayupload} to upload your project to jCenter. When
finished, anyone can use the View as they would any Android dependency
by adding the repository, artifact, group ID, and version to their
Gradle file.

Super! Now you know how to create and package Views in Liferay Screens
for Android. This gives you extensive control over your app's visual
design and behavior and also lets you distribute and reuse your Views.

\subsection{Related Topics}\label{related-topics-71}

\href{/docs/7-0/tutorials/-/knowledge_base/t/using-views-in-android-screenlets}{Using
Views in Android Screenlets}

\href{/docs/7-0/tutorials/-/knowledge_base/t/architecture-of-liferay-screens-for-android}{Architecture
of Liferay Screens for Android}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-android-screenlets}{Creating
Android Screenlets}

\section{Packaging Your Android
Screenlets}\label{packaging-your-android-screenlets}

To reuse your Screenlet in another app or distribute it, you can package
it in a module (Android library). You can optionally share it with other
developers via jCenter or Maven Central. Developers can then use your
Screenlet by adding its module as a project dependency in their apps.
This tutorial explains how to package and distribute Screenlets by
following these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Create a new Android module.
\item
  Configure dependencies between each module.
\item
  Distribute the module by uploading it to jCenter or Maven Central.
\end{enumerate}

Now get ready to package and distribute Screenlets like a pro!

\subsection{Create a New Android
Module}\label{create-a-new-android-module}

Android Studio's \emph{Create New Module} wizard can automatically
create a module and add it to your \texttt{settings.gradle} file. Go to
\emph{File} → \emph{New Module\ldots{}}, select \emph{Android Library}
in the More Modules section, and click \emph{Next}. Then name your
module and click \emph{Next}. The wizard's final step lets you add a new
activity. Since your module doesn't need one, select \emph{Blank
Activity} and click \emph{Finish}. Android Studio creates a new
\texttt{build.gradle} file with an Android Library configuration and
adds the new module to your \texttt{settings.gradle} file.

If you prefer to create a new module manually, examine the
\texttt{build.gradle} file from the
\href{https://github.com/liferay/liferay-screens/blob/master/android/viewsets/material/build.gradle}{Material
View set} or
\href{https://github.com/liferay/liferay-screens/blob/master/android/viewsets/westeros/build.gradle}{Westeros
app} as an example. After creating the module, import it into your
project by specifying its location in
\href{https://github.com/liferay/liferay-screens/blob/master/android/samples/test-app/settings.gradle}{\texttt{settings.gradle}}.
Here's an example configuration:

\begin{verbatim}
// Change YOUR_MODULE_NAME and RELATIVE_ROUTE_TO_YOUR_MODULE to match your module

include ':YOUR_MODULE_NAME'
project(':YOUR_MODULE_NAME').projectDir = new File(settingsDir, 'RELATIVE_ROUTE_TO_YOUR_MODULE')
\end{verbatim}

Now that you have a module, you're ready to configure its dependencies.

\subsection{Configure Dependencies Between Each
Module}\label{configure-dependencies-between-each-module}

Next, you must configure your app to use the module. To do so, add a
project implementation statement to your \texttt{build.gradle} file's
dependencies:

\begin{verbatim}
// Change YOUR_MODULE_NAME to match your module's name

dependencies {
    ...
    implementation project (':YOUR_MODULE_NAME')
    ...
}
\end{verbatim}

Your module must also specify dependencies for overriding existing
Screenlets and creating new ones. This usually requires adding Liferay
Screens and the View Sets your Screenlet currently uses to your
\texttt{build.gradle} file's dependencies. To add Liferay Screens as a
dependency, add to your \texttt{build.gradle} file's dependencies the
following project implementation statement:

\begin{verbatim}
implementation 'com.liferay.mobile:liferay-screens:+'
\end{verbatim}

Awesome! Now you're ready to share your Screenlet with the world!

\subsection{Upload the Module to jCenter or Maven
Central}\label{upload-the-module-to-jcenter-or-maven-central}

To make your module available to anyone, you can upload your module to
jCenter or Maven Central. Before doing so, you must configure your
\texttt{build.gradle} file appropriately for those repositories. Use the
material or Westeros View Set's
\href{https://github.com/liferay/liferay-screens/blob/master/android/viewsets/westeros/build.gradle}{\texttt{build.gradle}}
file as an example. After entering your bintray api key, execute
\texttt{gradlew\ bintrayupload} to upload your project to jCenter.
Developers can then use your Screenlet as any other Android dependency
by specifying its repository, artifact, group ID, and version in their
Gradle files. Congratulations on publishing your Screenlet!

\subsection{Related Topics}\label{related-topics-72}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-android-screenlets}{Creating
Android Screenlets}

\href{/docs/7-0/tutorials/-/knowledge_base/t/preparing-android-projects-for-liferay-screens}{Preparing
Android Projects for Liferay Screens}

\href{/docs/7-0/tutorials/-/knowledge_base/t/using-screenlets-in-android-apps}{Using
Screenlets in Android Apps}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-android-views}{Creating
Android Views}

\section{Using Liferay Push in Android
Apps}\label{using-liferay-push-in-android-apps}

Liferay Screens supports push notifications in Android apps. To use
them, you must configure some APIs and modify your app to consume and/or
produce push notifications. This tutorial shows how to do all these
things.

\subsection{Configuring to Use Liferay Push
Notifications}\label{configuring-to-use-liferay-push-notifications}

Your first step is to create and configure a Google project to use
Google Cloud Messaging
(\href{https://developers.google.com/cloud-messaging/}{GCM}). You also
need to configure the Liferay Push app to use the project's GCM API.

Follow these steps to create and configure a Google project to support
cloud messaging:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  On the
  \href{https://developers.google.com/cloud-messaging/android/start/}{Google
  Cloud Messaging page}, create a configuration file by clicking
  \emph{Get a Configuration File}. On the screen that appears, set your
  \emph{App name} and \emph{Android package name}, and then click
  \emph{Continue To Choose and Configure Services}. On the next screen,
  click \emph{Enable Google Cloud Messaging}.
\item
  Copy and save the \emph{Server API Key} and \emph{Sender ID} values
  you're presented with. You'll need to use these values later as the
  push notifications API keys for Liferay Push.

\begin{verbatim}
![ You need the Server API Key and Sender ID to enable Liferay Push.](./images/screens-android-push-project-and-server-key.png)
\end{verbatim}
\end{enumerate}

Now that you've set up your Google project, you can configure the
Liferay Push app to use the project's GCM API. Install the Liferay Push
app from the \href{http://www.liferay.com/marketplace}{Liferay
Marketplace}. In your Liferay DXP instance's Control Panel, navigate to
\emph{Configuration} → \emph{System Settings}, select the \emph{Other}
tab, then select \emph{Android Push Notifications Sender}. Set the push
notifications \emph{API Key} to the value of the Server API Key you
generated in your Google project. You can also set the number of retries
in the event that sending a notification fails.

\begin{figure}
\centering
\includegraphics{./images/push-android-settings.png}
\caption{Set the API key and number of retries in your Liferay DXP
instance.}
\end{figure}

Great! Your Liferay DXP instance is now ready to send push notifications
to your Android apps!

\subsection{Receiving and Sending Push
Notifications}\label{receiving-and-sending-push-notifications}

\href{https://github.com/liferay-mobile/liferay-push-android}{The
Liferay Push Client for Android} streamlines registering a device with
the portal for receiving and sending push notifications. Although the
information below contains the main steps needed to use the client, the
\href{https://github.com/liferay-mobile/liferay-push-android/blob/master/README.md}{readme}
explains them in detail.

In your Android application's Gradle build file,
\href{/docs/7-0/tutorials/-/knowledge_base/t/configuring-dependencies}{add
a new dependency} on the Liferay Push Client for Android:

\begin{verbatim}
dependencies {

    ...

    implementation 'com.liferay.mobile:liferay-push:1.2.1'
}
\end{verbatim}

Make sure your app's \texttt{liferay-plugin-package.properties} file
specifies the Push Notifications portlet as a required deployment
context:

\begin{verbatim}
required-deployment-contexts=\
    push-notifications-portlet\
    ...
\end{verbatim}

Next, you'll learn how to register listeners for push notifications.

\subsubsection{Receiving Push
Notifications}\label{receiving-push-notifications}

First, register your device in GCM with the \texttt{SENDER\_ID} you
generated previously:

\begin{verbatim}
Session session = new SessionImpl(YOUR_SERVER, new BasicAuthentication(YOUR_USER, YOUR_PASSWORD));

Push.with(session).register(this, YOUR_SENDER_ID);
\end{verbatim}

If you're using Liferay Screens to maintain a session, you can retrieve
it and use it instead of creating a new one:

\begin{verbatim}
Push.with(SessionContext.createSessionFromCurrentSession()).register(this, YOUR_SENDER_ID);
\end{verbatim}

If you use these example lines of code, make sure to replace
\texttt{YOUR\_SERVER}, \texttt{YOUR\_USER}, \texttt{YOUR\_PASSWORD}, and
\texttt{YOUR\_SENDER\_ID} with your own values.

That's it! You can attach a listener to store the registration ID or to
process the notification sent to the activity (using
\texttt{onPushNotification()}). You can also register a receiver and
service to process the notification. You can refer to the
\href{https://github.com/liferay/liferay-screens/tree/master/android/samples/pushnotifications}{Push
Notifications project} as an example push notifications implementation.

Next, you'll learn how to send push notifications.

\subsubsection{Sending Push
Notifications}\label{sending-push-notifications}

Using the Liferay Push app, sending notifications to your app's users is
straightforward. You can specify the user IDs along with the message
content:

\begin{verbatim}
PushNotificationsDeviceLocalServiceUtil.sendPushNotification(userIds, content);
\end{verbatim}

This \href{https://github.com/nhpatt/push-with-ddl-hook}{example hook
plugin} sends a push notification each time a user creates a new DDL
record or updates an existing one.

In your app's \texttt{portal.properties} file, you can add a listener
for a class by creating a
\href{https://docs.liferay.com/portal/6.2/propertiesdoc/portal.properties.html\#Value\%20Object}{\emph{value.object.listener}}
property, set to a comma separated list of intended listener classes.
Here's an example listener setting for \texttt{DDLRecord} objects:

\begin{verbatim}
value.object.listener.com.liferay.portlet.dynamicdatalists.model.DDLRecord=com.liferay.push.hooks.DDLRecordModelListener
\end{verbatim}

Great! Now you know how to configure your Android apps to receive push
notifications from Liferay DXP.

In this tutorial, you've configured your portal to accommodate push
notifications, registered notification listeners, and implemented
sending push notifications. Way to go!

\subsection{Related Topics}\label{related-topics-73}

\href{/docs/7-0/tutorials/-/knowledge_base/t/preparing-android-projects-for-liferay-screens}{Preparing
Android Projects for Liferay Screens}

\href{/docs/7-0/tutorials/-/knowledge_base/t/using-screenlets-in-android-apps}{Using
Screenlets in Android Apps}

\section{Accessing the Liferay Session in
Android}\label{accessing-the-liferay-session-in-android}

A session is a conversation state between the client and server. It
typically consists of multiple requests and responses between the two.
To facilitate this communication, the session must have the server IP
address, and a user's login credentials. Liferay Screens uses a Liferay
Session to access and query the JSON web services provided by Liferay
Portal. When you log in using a Liferay Session, the portal returns the
user's information (name, email, user ID, etc\ldots). Screens stores
this information and the active Liferay Session in Screens's
\texttt{SessionContext} class.

The \texttt{SessionContext} class is very powerful and lets you use
Screens in many different scenarios. For example, you can use
\texttt{SessionContext} to request information with the JSON WS API
provided by Liferay. You can also use \texttt{SessionContext} to create
anonymous sessions, or to log in a user without showing a Login
Screenlet.

This tutorial explains some common \texttt{SessionContext} use cases,
and and also describes the class's most important methods.

\subsection{Creating a Session from an Existing
Session}\label{creating-a-session-from-an-existing-session}

When working with Liferay Screens, you may wish to call the remote JSON
web services provided by the Liferay Mobile SDK. Every operation with
the Liferay Mobile SDK needs a Liferay Session to provide the server
address, user credentials, and any other required parameters. Since the
Login Screenlet creates a session when a user successfully logs in, you
can retrieve this session with the \texttt{SessionContext} method
\texttt{createSessionFromCurrentSession()}. You can then use that
session to make the Mobile SDK service call. The following example shows
this for calling the Mobile SDK's \texttt{BookmarksEntryService}:

\begin{verbatim}
Session sessionFromCurrentSession = SessionContext.createSessionFromCurrentSession();
sessionFromCurrentSession.setCallback(callback);

new BookmarksEntryService(sessionFromCurrentSession).methodCall()
\end{verbatim}

If you need to check first to see if a user has logged in, you can use
\texttt{SessionContext.isLoggedIn()}.

Great! Now you know how to retrieve an existing session in your app. But
what if you're not using the Login Screenlet? There won't be an existing
session to retrieve. No sweat! You can still use \texttt{SessionContext}
to create one manually. The next section shows you how to do this.

\subsection{Creating a Session
Manually}\label{creating-a-session-manually}

If you don't use the Login Screenlet, then \texttt{SessionContext}
doesn't have a session for you to retrieve. In this case, you must
create one manually. You can do this with the \texttt{SessionContext}
method \texttt{createBasicSession}. The method takes a username and
password as parameters, and creates a session with those credentials. If
you also need to access a user's information, you must manually call the
\texttt{User} JSON web service, or call
\texttt{SessionContext.setLoggedUser()}. The following code creates a
session with \texttt{createBasicSession} and then uses
\texttt{setLoggedUser} to set the user in \texttt{SessionContext}:

\begin{verbatim}
LiferayScreensContext.init(this);

Session session = SessionContext.createBasicSession(USERNAME, PASSWORD);
SessionContext.setLoggedUser(USER);
\end{verbatim}

Note that you can achieve the same thing by calling the interactor
directly:

\begin{verbatim}
LoginBasicInteractor loginBasicInteractor = new LoginBasicInteractor(0);
loginBasicInteractor.onScreenletAttached(this);
loginBasicInteractor.setLogin(USERNAME);
loginBasicInteractor.setPassword(PASSWORD);
loginBasicInteractor.login();
\end{verbatim}

Super! Now you know how to create a session manually. The next section
shows you how to implement auto-login, and save or restore a session.

\subsection{Implementing Auto-login and Saving or Restoring a
Session}\label{implementing-auto-login-and-saving-or-restoring-a-session}

Although the Login Screenlet is awesome, your users may not want to
enter their credentials every time they open your app. It's very common
for apps to only require a single login. To implement this in your app,
see \href{https://www.youtube.com/watch?v=kEZEahTzuck}{this video}.

In short, you need to pass a storage type to the Login Screenlet, and
then use \texttt{SessionContext.isLoggedIn()} to check for a session. If
a session doesn't exist, load the stored session from
\texttt{CredentialsStorage} with
\texttt{loadStoredCredentials(StorageType\ storageType)}. The following
code shows a typical implementation of this:

\begin{verbatim}
LiferayScreensContext.init(this); // If you haven't called a Screenlet yet
SessionContext.loadStoredCredentials(SHARED_PREFERENCES);

if (SessionContext.isLoggedIn()) {
    // logged in
    // consider doing a relogin here (see next section)
} else {
    // send user to login form
}
\end{verbatim}

Awesome! Now you know how to implement auto-login in your Liferay
Screens apps. For more information on available \texttt{SessionContext}
methods, see the
\href{/docs/7-0/tutorials/-/knowledge_base/t/accessing-the-liferay-session-in-android\#methods}{Methods
section} at the end of this tutorial. Next, you'll learn how to
implement relogin for cases where a user's credentials change on the
server while they're logged in.

\subsection{Implementing Relogin}\label{implementing-relogin}

A session, whether created via Login Screenlet or auto-login, contains
basic user data that verifies the user in the Liferay instance. If that
data changes in the server, then your session is outdated, which may
cause your app to behave inconsistently. Also, if a user is deleted,
deactivated, or otherwise changes their credentials in the server, the
auto-login feature won't deny access because it doesn't perform server
transactions: it only retrieves an existing session from local storage.
This isn't an optimal situation!

For such scenarios, you can use the relogin feature. This feature is
implemented in a simple method that determines if the current session is
still valid. If the session is still valid, the user's data is updated
with the most recent data from the server. If the session isn't valid,
the user is logged out and must then log in again to create a new
session.

To use this feature, call the \texttt{SessionContext} method
\texttt{relogin}, with an object that implements the
\texttt{LoginListener} interface as an argument:

\begin{verbatim}
SessionContext.relogin(listener);
\end{verbatim}

This method handles success or failure via the listener's
\texttt{onLoginSuccess} and \texttt{onLoginFailure} methods,
respectively. Note that this operation is done asynchronously in a
background thread, so the listener is called in that thread. If you also
want to perform any UI operations, you must do so in your UI thread. For
example:

\begin{verbatim}
@Override
public void onLoginSuccess(final User user) {
    runOnUiThread(new Runnable() {
        @Override
        public void run() {
            // do any UI operation here
        }
    });
}
\end{verbatim}

Great! Now you know how to implement relogin in your app. You've also
seen how handy \texttt{SessionContext} can be. It can do even more! The
next section lists some additional \texttt{SessionContext} methods, and
some more detail on the ones used in this tutorial.

\subsection{Methods}\label{methods}

\noindent\hrulefill

Method \textbar{} Return Type \textbar{} Explanation \textbar{}
\texttt{logout()} \textbar{} \texttt{void} \textbar{} Clears the stored
user attributes and session. \textbar{} \texttt{relogin(LoginListener)}
\textbar{} \texttt{void} \textbar{} Refreshes user data from the server.
This recreates the \texttt{currentUser} object if successful, or calls
\texttt{logout()} on failure. When the server data is received, the
listener method \texttt{onLoginSuccess} is called with received user's
attributes. If an error occurs, the listener method
\texttt{onLoginFailure} is called. \textbar{} \texttt{isLoggedIn()}
\textbar{} \texttt{boolean} \textbar{} Returns \texttt{true} if there is
a stored Liferay Session in \texttt{SessionContext}. \textbar{}
\texttt{createBasicSession(String\ username,\ String\ password)}
\textbar{} \texttt{Session} \textbar{} Creates a Liferay Session using
the default server and the supplied username and password. \textbar{}
\texttt{createSessionFromCurrentSession()} \textbar{} \texttt{Session}
\textbar{} Creates a Liferay Session based on the stored credentials and
server. \textbar{} \texttt{getCurrentUser()} \textbar{} \texttt{User}
\textbar{} Returns a \texttt{User} object containing the server
attributes of the logged-in user. This includes the user's email, user
ID, name, and portrait ID. \textbar{}
\texttt{storeCredentials(StorageType\ storageType)} \textbar{}
\texttt{void} \textbar{} Stores the current session in the
\texttt{StorageType} supplied as a parameter. \textbar{}
\texttt{removeStoredCredentials(StorageType\ storageType)} \textbar{}
\texttt{void} \textbar{} Clears the \texttt{StorageType} of any user
information and session. \textbar{}
\texttt{loadStoredCredentials(StorageType\ storageType)} \textbar{}
\texttt{void} \textbar{} Loads the session and user information from the
\texttt{StorageType} parameter, and uses it as the current session and
user. \textbar{}

\noindent\hrulefill

For more information, see the
\href{https://github.com/liferay/liferay-screens/blob/master/android/library/core/src/main/java/com/liferay/mobile/screens/context/SessionContext.java}{\texttt{SessionContext}
source code in GitHub}.

\subsection{Related Topics}\label{related-topics-74}

\href{/docs/7-0/reference/-/knowledge_base/r/loginscreenlet-for-android}{Login
Screenlet for Android}

\href{/docs/7-0/tutorials/-/knowledge_base/t/using-screenlets-in-android-apps}{Using
Screenlets in Android Apps}

\section{Adding Custom Interactors to Android
Screenlets}\label{adding-custom-interactors-to-android-screenlets}

Interactors are Screenlet components that implement server communication
for a specific use case. For example, the Login Screenlet's interactor
calls the Liferay Mobile SDK service that authenticates a user to the
portal. Similarly, the interactor for
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-android-screenlets}{the
Add Bookmark Screenlet} calls the Liferay Mobile SDK service that adds a
bookmark to the Bookmarks portlet.

That's all fine and well, but what if you want to customize a
Screenlet's server call? What if you want to use a different back-end
with a Screenlet? No problem! You can implement a custom interactor for
the Screenlet. You can plug in a different interactor that makes its
server call by using custom logic or network code. To do this, you must
implement the current interactor's interface and then pass it to the
Screenlet you want to override. You should do this inside your app's
code, either in an inner class or a separate class.

In this tutorial, you'll see an example interactor that overrides the
Login Screenlet to always log in the same user, without a password. You
can find the complete code in the
\href{https://github.com/liferay/liferay-screens/blob/master/android/samples/test-app/src/main/java/com/liferay/mobile/screens/testapp/CustomInteractorActivity.java}{test-app
on GitHub.}. Note that this example implements the custom interactor in
an inner class of an activity.

\subsection{Implementing a Custom
Interactor}\label{implementing-a-custom-interactor}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Implement your custom interactor. You must inherit the original
  interactor's interface, as shown here:

\begin{verbatim}
 private class CustomLoginInteractor extends LoginBasicInteractor {

     public CustomLoginInteractor(int targetScreenletId) {
         super(targetScreenletId);
     }

     @Override
     public void login() throws Exception {
         //custom implementation
     }
 }
\end{verbatim}
\item
  Call the interactor's listener. In your custom logic, you must call
  the interactor's listener. In this example, you must call
  \texttt{onLoginFailure} and \texttt{onLoginSuccess}, depending on your
  custom logic's result:

\begin{verbatim}
 if (SUCCESS) {
     getListener().onLoginSuccess(fakeUser);
 }
 else {
     getListener().onLoginFailure(new AuthenticationException("bad login"));
 }
\end{verbatim}
\item
  Return your interactor in the custom listener. You must use
  \texttt{setCustomInteractorListener} to set a specific listener that
  expects an Interactor created with \texttt{actionName} (a string):

\begin{verbatim}
 _screenlet.setCustomInteractorListener(this);

 @Override
 public LoginInteractor createInteractor(String actionName) {
     return new CustomLoginInteractor(_loginScreenlet.getScreenletId());
 }
\end{verbatim}
\end{enumerate}

Great! Now you know how to implement custom interactors for Android
Screenlets. The next example builds on this by showing you how to access
non-Liferay backends with a custom interactor.

\subsection{Using Custom Interactors to Access Other
Backends}\label{using-custom-interactors-to-access-other-backends}

Custom interactors are also capable of communicating with non-Liferay
backends. The following example illustrates this by creating a custom
interactor for the
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-android-screenlets}{Add
Bookmark Screenlet} that can store bookmarks at
\href{https://delicious.com}{Delicious}. You can find this example's
complete code
\href{https://gist.github.com/nhpatt/7cbeb0df6f39ec8a9176}{at this
gist}.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a new custom interactor. This interactor inherits
  \texttt{BaseRemoteInteractor}, the base class of all interactors, with
  \texttt{AddBookmarkListener} as a type parameter. It also implements
  the \texttt{AddBookmarkInteractor} class. The base code for this new
  interactor is shown here:

\begin{verbatim}
 public class AddDeliciousInteractorImpl extends BaseRemoteInteractor<AddBookmarkListener>
     implements AddBookmarkInteractor {

     public AddDeliciousInteractorImpl(int targetScreenletId) {
         super(targetScreenletId);
     }

     public void addBookmark(final String url, final String title, long folderId) throws Exception {
         ...
     }
 }
\end{verbatim}
\item
  Implement your custom logic. In this example, you must implement the
  code for accessing Delicious and inserting a new bookmark with the
  Delicious API. You can use the
  \href{http://square.github.io/okhttp/}{OkHttp library} to pass the API
  your bookmark's URL and description. The following code shows this:

\begin{verbatim}
 new Thread(new Runnable() {
     @Override
     public void run() {
         try {

             Headers headers = Headers.of("Authorization", "Bearer _OAUTH_TOKEN_");

             OkHttpClient client = new OkHttpClient();

             Request add = new Request.Builder()
                 .url("https://api.del.icio.us/api/v1/posts/add?url=" + url + "&description=" + title)
                 .headers(headers)
                 .build();

             com.squareup.okhttp.Response response = client.newCall(get).execute();

             String text = response.body().string();

             ...

         }
         catch (IOException e) {
             LiferayLogger.e("Error sending", e);
             ...
         }
     }
 }).start();
\end{verbatim}
\item
  Notify your app of the results. You should use the
  \texttt{EventBusUtil} class to post an event for this. Use the event
  to let other classes listen for the event. The following code uses
  \texttt{EventBusUtil.post(text)} to post the event, and the
  \texttt{onEvent} method to notify the listener:

\begin{verbatim}
 EventBusUtil.post(text);

 ...

 public void onEvent(String text) {
     getListener().onAddBookmarkSuccess();
 }
\end{verbatim}

  Note that the code in
  \href{https://gist.github.com/nhpatt/7cbeb0df6f39ec8a9176}{the gist}
  uses the custom \texttt{BookmarkAdded} class to model the operation's
  results.
\item
  In the activity or fragment you're using the Screenlet in, implement
  \texttt{CustomInteractorListener}. You must also reference your new
  custom interactor and connect it to the Screenlet:

\begin{verbatim}
 _screenlet.setCustomInteractorListener(this);

 @Override
 public Interactor createInteractor(String actionName) {
     return new AddDeliciousInteractorImpl(_screenlet.getScreenletId());
 }
\end{verbatim}
\end{enumerate}

Awesome! Now you know how to create a custom interactor that can
communicate with a non-Liferay backend. This opens up even more
possibilities for your apps.

\subsection{Related Topics}\label{related-topics-75}

\href{/docs/7-0/tutorials/-/knowledge_base/t/architecture-of-liferay-screens-for-android}{Architecture
of Liferay Screens for Android}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-android-screenlets}{Creating
Android Screenlets}

\section{Rendering Web Content in Your Android
App}\label{rendering-web-content-in-your-android-app}

Liferay DXP represents
\href{/docs/7-0/user/-/knowledge_base/u/creating-web-content}{web
content} articles as \texttt{JournalArticle} entities. Liferay Screens
provides several ways to render these entities in your apps.

The simplest way to display a \texttt{JournalArticle}'s HTML in your app
is to use
\href{/docs/7-0/reference/-/knowledge_base/r/webcontentdisplayscreenlet-for-android}{Web
Content Display Screenlet}. This Screenlet is very powerful and supports
several complex use cases to fit your needs. You can also use
\href{/docs/7-0/reference/-/knowledge_base/r/web-content-list-screenlet-for-android}{Web
Content List Screenlet} to display lists of web content articles. This
tutorial shows you how to use both Screenlets to display web content in
your apps.

\subsection{Retrieving Basic Web
Content}\label{retrieving-basic-web-content}

Web Content Display Screenlet's simplest use case is to render a
\texttt{JournalArticle}'s HTML in an
\href{http://developer.android.com/guide/webapps/webview.html}{Android
\texttt{WebView}}. Simply provide the \texttt{JournalArticle}'s
\texttt{articleId} in the Screenlet XML, and the Screenlet takes care of
the rest (including decorating itself with the CSS needed to render it
in a small display). The following Screenlet XML shows this:

\begin{verbatim}
<com.liferay.mobile.screens.webcontent.display.WebContentDisplayScreenlet
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    app:articleId="YOUR_ARTICLE_ID" />
\end{verbatim}

To render the content \emph{exactly} as it appears on your mobile site,
however, you must provide the CSS inline or use a template. The HTML
returned isn't aware of a Liferay instance's global CSS.

You can also use a listener to modify the HTML, as explained in the
\href{/docs/7-0/reference/-/knowledge_base/r/webcontentdisplayscreenlet-for-android}{Screenlet
reference documentation}.

In the default security policy, an Android \texttt{WebView} doesn't
execute a page's JavaScript. You can enable such JavaScript execution by
setting the \texttt{javascriptEnabled} property via XML:

\begin{verbatim}
<com.liferay.mobile.screens.webcontent.display.WebContentDisplayScreenlet
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    app:articleId="YOUR_ARTICLE_ID"
    app:javascriptEnabled="true" />
\end{verbatim}

Alternatively, you can set this property in your app's fragment or
activity class that contains the Screenlet:

\begin{verbatim}
...
screenlet.setJavascriptEnabled(true);
...
\end{verbatim}

You can also use the \texttt{isJavascriptEnabled()} method to check this
property's setting.

As you can see, this is all straightforward. What could go wrong? Famous
last words. A common mistake is to use the default \texttt{groupId}
instead of the one for the site that contains your
\texttt{JournalArticle} entities.

If you need to use a default \texttt{groupId} in the rest of your app,
but render another site's HTML, you can set the Web Content Display
Screenlet's \texttt{groupId} with the \texttt{app:groupId} attribute.
You can alternatively use the \texttt{setGroupId} method in the activity
or fragment code that uses the Screenlet.

\subsection{Using Templates}\label{using-templates}

Web Content Display Screenlet can also use
\href{/docs/7-0/user/-/knowledge_base/u/designing-uniform-content\#designing-web-content-with-templates}{templates}
to render \texttt{JournalArticle} entities. For example, your Liferay
instance may have a custom template specifically designed to display
content on mobile devices.

To use a template, specify its ID in the Screenlet XML's
\texttt{templateId} property:

\begin{verbatim}
<com.liferay.mobile.screens.webcontent.display.WebContentDisplayScreenlet
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    app:articleId="YOUR_ARTICLE_ID"
    app:templateId="YOUR_TEMPLATE_ID" />
\end{verbatim}

\subsection{Using Structures}\label{using-structures}

Since mobile devices have limited screen space, you must often display
only the most important parts of a web content article. If your web
content is
\href{/docs/7-0/user/-/knowledge_base/u/designing-uniform-content\#creating-structured-web-content}{structured},
you can do this by using Web Content Display Screenlet to display only
specific fields from a \texttt{JournalArticle}'s structure. The simplest
way to do this is to specify the structure's ID and a comma-delimited
list of fields in the Screenlet XML's \texttt{structureId} and
\texttt{labelFields} attributes, respectively. The following example
illustrates this:

\begin{verbatim}
<com.liferay.mobile.screens.webcontent.display.WebContentDisplayScreenlet
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    liferay:articleId="YOUR_ARTICLE_ID"
    liferay:labelFields="YOUR_LABELS"
    liferay:layoutId="@layout/webcontentdisplay_structured_default"
    liferay:structureId="YOUR_STRUCTURE_ID" />
\end{verbatim}

You can also use your own layout to render the structure fields exactly
how you want. To do this, your layout should inherit from
\texttt{WebContentStructuredDisplayView} and read the information parsed
and stored in the \texttt{webContent} entity. By displaying two
structure fields with such a custom layout, the
\href{https://github.com/liferay/liferay-screens/tree/master/android/samples/test-app}{test
app} contains a complete example of this:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  The
  \href{https://github.com/liferay/liferay-screens/blob/master/android/samples/test-app/src/main/res/layout/webcontentdisplaystructured_example.xml}{layout
  file \texttt{webcontentdisplaystructured\_example.xml}} defines the
  custom layout:

\begin{verbatim}
 <com.liferay.mobile.screens.testapp.webviewstructured.WebContentDisplayView 
     xmlns:android="http://schemas.android.com/apk/res/android"
     android:layout_width="match_parent"
     android:layout_height="match_parent">

     <TextView
         android:id="@+id/web_content_first_field"
         android:layout_width="match_parent"
         android:layout_height="wrap_content"
         android:background="@android:color/holo_red_light" />

     <TextView
         android:id="@+id/web_content_second_field"
         android:layout_width="match_parent"
         android:layout_height="wrap_content"
         android:background="@android:color/holo_green_light" />

 </com.liferay.mobile.screens.testapp.webviewstructured.WebContentDisplayView>
\end{verbatim}
\item
  The
  \href{https://github.com/liferay/liferay-screens/blob/master/android/samples/test-app/src/main/java/com/liferay/mobile/screens/testapp/webviewstructured/WebContentDisplayView.java}{\texttt{WebContentDisplayView}
  class} sets the custom layout's functionality:

\begin{verbatim}
 public class WebContentDisplayView extends WebContentStructuredDisplayView {

     ...

     @Override
     public void showFinishOperation(WebContent webContent) {
         super.showFinishOperation(webContent);

         DDMStructure ddmStructure = webContent.getDDMStructure();

         TextView firstField = (TextView) findViewById(R.id.first_field);
         firstField.setText(String.valueOf(ddmStructure.getField(0).getCurrentValue()));

         TextView secondField = (TextView) findViewById(R.id.second_field);
         secondField.setText(String.valueOf(ddmStructure.getField(1).getCurrentValue()));
     }
 }
\end{verbatim}
\item
  The
  \href{https://github.com/liferay/liferay-screens/blob/master/android/samples/test-app/src/main/res/layout/web_content_display_structured.xml}{Screenlet
  XML's} \texttt{layoutId} attribute specifies the custom layout to use:

\begin{verbatim}
 <com.liferay.mobile.screens.webcontent.display.WebContentDisplayScreenlet
     android:layout_width="match_parent"
     android:layout_height="wrap_content"
     liferay:articleId="@string/liferay_article_structured_article_id"
     liferay:labelFields="@string/liferay_article_structured_label_fields_first_field"
     liferay:layoutId="@layout/webcontentdisplaystructured_example"
     liferay:offlinePolicy="REMOTE_FIRST"
     liferay:structureId="@string/liferay_article_structured_structure_id" />
\end{verbatim}
\end{enumerate}

Great! Now you know how to use structured web content with Web Content
Display Screenlet. Next, you'll learn how to display a list of web
content articles in your app.

\subsection{Displaying a List of Web Content
Articles}\label{displaying-a-list-of-web-content-articles}

The preceding examples show you how to use Web Content Display Screenlet
to display a single web content article's contents in your app. But what
if you want to display a list of articles instead? No problem! You can
use Web Content List Screenlet for this. Web Content List Screenlet can
retrieve the contents of a web content folder and display only the
labels you want. The Screenlet is also aware of
\href{/docs/7-0/user/-/knowledge_base/u/designing-uniform-content\#creating-structured-web-content}{structured}
content, so you can render each row with certain structure fields. You
can also do this via a custom layout.

To use a web content folder with Web Content List Screenlet, specify the
folder's ID in the Screenlet XML's \texttt{folderId} attribute. To
render a specific structure field for each article in the list, specify
that field in the Screenlet XML's \texttt{labelFields} attribute. For
example:

\begin{verbatim}
<com.liferay.mobile.screens.webcontent.list.WebContentListScreenlet
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    app:folderId="YOUR_FOLDER_ID"
    app:labelFields="Text" />
\end{verbatim}

You can also see an example of this in the test app's
\href{https://github.com/liferay/liferay-screens/blob/master/android/samples/test-app/src/main/res/layout/web_content_display_list.xml}{\texttt{web\_content\_display\_list.xml}
layout file}.

Also note that several methods in
\href{https://github.com/liferay/liferay-screens/blob/master/android/library/src/main/java/com/liferay/mobile/screens/webcontent/WebContent.java}{Screens's
\texttt{WebContent} class} help you render content from different
locales. For example, \texttt{getLocalized(name)} receives a field's
name and returns the value in the mobile device's current locale. Such
methods help you render a custom view without worrying about the
underlying structure, XML parsing, or HTTP calls.

\subsection{Displaying a List of
Assets}\label{displaying-a-list-of-assets}

To render a list of different assets in your app, including web content
articles, you can use Asset List Screenlet. Asset List Screenlet can
display a list of any assets from a Liferay instance. Like Web Content
List Screenlet, you can also access a web content article's structure
fields, or use a custom layout to render each asset type. For more
information, see the
\href{/docs/7-0/reference/-/knowledge_base/r/assetlistscreenlet-for-android}{reference
documentation for Asset List Screenlet}.

\subsection{Related Topics}\label{related-topics-76}

\href{/docs/7-0/tutorials/-/knowledge_base/t/using-screenlets-in-android-apps}{Using
Screenlets in Android Apps}

\href{/docs/7-0/tutorials/-/knowledge_base/t/using-views-in-android-screenlets}{Using
Views in Android Screenlets}

\href{/docs/7-0/reference/-/knowledge_base/r/webcontentdisplayscreenlet-for-android}{Web
Content Display Screenlet for Android}

\href{/docs/7-0/reference/-/knowledge_base/r/web-content-list-screenlet-for-android}{Web
Content List Screenlet for Android}

\href{/docs/7-0/reference/-/knowledge_base/r/assetlistscreenlet-for-android}{Asset
List Screenlet for Android}

\section{Rendering Web Pages in Your Android
App}\label{rendering-web-pages-in-your-android-app}

The
\href{/docs/7-0/tutorials/-/knowledge_base/t/rendering-web-content-in-your-android-app}{Rendering
Web Content} tutorial shows you how to display
\href{/docs/7-0/user/-/knowledge_base/u/creating-web-content}{web
content} from a Liferay DXP site in your Android app. Displaying content
is great, but what if you want to display an entire page? No problem!
\href{/docs/7-0/reference/-/knowledge_base/r/web-screenlet-for-android}{Web
Screenlet} lets you display any web page. You can even customize the
page by injecting local or remote JavaScript and CSS files. When
combined with Liferay DXP's server-side customization features (e.g.,
\href{/docs/7-0/user/-/knowledge_base/u/styling-apps-with-application-display-templates}{Application
Display Templates}), Web Screenlet gives you almost limitless
possibilities for displaying web pages in your Android apps.

In this tutorial, you'll learn how to use Web Screenlet to display web
pages in your Android app.

\subsection{Inserting Web Screenlet in Your
App}\label{inserting-web-screenlet-in-your-app}

Inserting Web Screenlet in your app is the same as
\href{/docs/7-0/tutorials/-/knowledge_base/t/using-screenlets-in-android-apps}{inserting
any Screenlet in your app}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Insert the Screenlet's XML in the layout of the activity or fragment
  you want to use the Screenlet in. Also be sure to set any attributes
  that you need. For a list of Web Screenlet's available attributes, see
  \href{/docs/7-0/reference/-/knowledge_base/r/web-screenlet-for-android\#attributes}{the
  Attributes section} of the Web Screenlet reference doc.

  For example, here's Web Screenlet's XML with the Screenlet's
  \texttt{layoutId} and \texttt{autoLoad} attributes set to
  \texttt{web\_default} and \texttt{false}, respectively:

\begin{verbatim}
<com.liferay.mobile.screens.web.WebScreenlet
    android:id="@+id/web_screenlet"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    app:layoutId="@layout/web_default"
    app:autoLoad="false"
    /> 
\end{verbatim}

  Note that \texttt{web\_default} specifies the Screenlet's Default
  View, which is part of the Default View Set.
\item
  To use a View that is part of a View Set, like the Default View, the
  app or activity theme must inherit the theme that sets the View Set's
  styles. For the Default View Set, this is \texttt{default\_theme}. For
  example, to set the app's theme to inherit \texttt{default\_theme},
  open \texttt{res/values/styles.xml} and set the base app theme's
  parent to \texttt{default\_theme}. In this example, the base app theme
  is \texttt{AppTheme}:

\begin{verbatim}
<style name="AppTheme" parent="default_theme">
    ...
\end{verbatim}
\end{enumerate}

Next, you'll implement Web Screenlet's listener.

\subsection{Implementing Web Screenlet's
Listener}\label{implementing-web-screenlets-listener}

To use any Screenlet in an activity or fragment, you must also implement
the Screenlet's listener in that activity or fragment's class. Web
Screenlet's listener is \texttt{WebListener}. Follow these steps to
implement \texttt{WebListener}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Change the class declaration to implement \texttt{WebListener}, and
  import \texttt{com.liferay.mobile.screens.web.WebListener}:

\begin{verbatim}
...
import com.liferay.mobile.screens.web.WebListener;
...

public class YourActivity extends AppCompatActivity implements WebListener {...
\end{verbatim}
\item
  Implement \texttt{WebListener}'s \texttt{onPageLoaded} method. This
  method is called when the Screenlet loads the page successfully. How
  you implement it depends on what (if anything) you want to happen upon
  page load. For example, this \texttt{onPageLoaded} implementation
  displays a toast message indicating success:

\begin{verbatim}
@Override
public void onPageLoaded(String url) {
    Toast.makeText(this, "Page load successful!", Toast.LENGTH_SHORT).show();
}
\end{verbatim}
\item
  Implement \texttt{WebListener}'s \texttt{onScriptMessageHandler}
  method. This method is called when
  \href{https://developer.android.com/reference/android/webkit/WebView.html}{the
  Screenlet's \texttt{WebView}} sends a message. The \texttt{namespace}
  argument is the source namespace key, and the \texttt{body} argument
  is the source namespace body. For example, this
  \texttt{onScriptMessageHandler} implementation parses data from the
  source namespace body if it matches a specific namespace, and then
  starts a new activity with that data via an intent:

\begin{verbatim}
@Override
public void onScriptMessageHandler(String namespace, String body) {
    if ("gallery".equals(namespace)) {
        String[] allImgSrc = body.split(",");
        int imgSrcPosition = Integer.parseInt(allImgSrc[allImgSrc.length - 1]);

        Intent intent = new Intent(getApplicationContext(), DetailMediaGalleryActivity.class);
        intent.putExtra("allImgSrc", allImgSrc);
        intent.putExtra("imgSrcPosition", imgSrcPosition);
        startActivity(intent);
    }
}
\end{verbatim}
\item
  Implement the \texttt{error} method. This method is called when an
  error occurs in the process. The \texttt{e} argument contains the
  exception, and the \texttt{userAction} argument distinguishes the
  specific action in which the error occurred. In most cases, you'll use
  these arguments to log or display the error. For example, this
  \texttt{error} implementation displays a toast message with the
  exception's message:

\begin{verbatim}
@Override
public void error(Exception e, String userAction) {
    Toast.makeText(this, "Bad things happened: " + e.getMessage(), Toast.LENGTH_LONG).show();
}
\end{verbatim}
\item
  Get a \texttt{WebScreenlet} reference and set the activity or fragment
  class as its listener. To do so, import
  \texttt{com.liferay.mobile.screens.web.WebScreenlet} and add the
  following code to the end of the \texttt{onCreate} method:

\begin{verbatim}
WebScreenlet screenlet = (WebScreenlet) findViewById(R.id.web_screenlet);
screenlet.setListener(this);
\end{verbatim}

  Note that the \texttt{findViewById} references the \texttt{android:id}
  value set in the Screenlet's XML.
\end{enumerate}

Next, you'll use the same \texttt{WebScreenlet} reference to set the
Screenlet's parameters.

\subsection{Setting Web Screenlet's
Parameters}\label{setting-web-screenlets-parameters}

Web Screenlet has \texttt{WebScreenletConfiguration} and
\texttt{WebScreenletConfiguration.Builder} objects that supply the
parameters the Screenlet needs to work. These parameters include the URL
of the page to load and the location of any JavaScript or CSS files that
customize the page. You'll set most of these parameters via
\texttt{WebScreenletConfiguration.Builder}'s methods.

\noindent\hrulefill

\textbf{Note:} For a full list of
\texttt{WebScreenletConfiguration.Builder}'s methods, and a description
of each, see the table in
\href{/docs/7-0/reference/-/knowledge_base/r/web-screenlet-for-android\#configuration}{the
Configuration section} of Web Screenlet's reference doc.

\noindent\hrulefill

To set Web Screenlet's parameters, follow these steps in the method that
initializes the activity or fragment containing the Screenlet (e.g.,
\texttt{onCreate} in activities, \texttt{onCreateView} in fragments).
You can, however, do this in other methods as needed.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Use
  \texttt{WebScreenletConfiguration.Builder(\textless{}url\textgreater{})},
  where \texttt{\textless{}url\textgreater{}} is the web page's URL
  string, to create a \texttt{WebScreenletConfiguration.Builder} object.
  If the page requires Liferay DXP authentication, then the user must be
  logged in via
  \href{/docs/7-0/reference/-/knowledge_base/r/loginscreenlet-for-android}{Login
  Screenlet} or a \texttt{SessionContext} method, and you must provide a
  relative URL to the \texttt{WebScreenletConfiguration.Builder}
  constructor. For example, if such a page's full URL is
  \texttt{http://your.liferay.instance/web/guest/blog}, then the
  constructor's argument is \texttt{/web/guest/blog}. For any other page
  that doesn't require Liferay DXP authentication, you must supply the
  full URL to the constructor.
\item
  Call the \texttt{WebScreenletConfiguration.Builder} methods to set the
  parameters that you need.
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** If the URL you supplied to the `WebScreenletConfiguration.Builder`
 constructor is to a page that doesn't require Liferay DXP authentication, then
 you must call the `WebScreenletConfiguration.Builder` method
 `setWebType(WebScreenletConfiguration.WebType.OTHER)`. The default `WebType`
 is `LIFERAY_AUTHENTICATED`, which is required to load Liferay DXP pages that
 require authentication. If you need to set `LIFERAY_AUTHENTICATED` manually,
 call `setWebType(WebScreenletConfiguration.WebType.LIFERAY_AUTHENTICATED)`.
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\item
  Call the \texttt{WebScreenletConfiguration.Builder} instance's
  \texttt{load()} method, which returns a
  \texttt{WebScreenletConfiguration} object.
\item
  Use Web Screenlet's \texttt{setWebScreenletConfiguration} method to
  set the \texttt{WebScreenletConfiguration} object to the Web Screenlet
  instance.
\item
  Call the Web Screenlet instance's \texttt{load()} method.
\end{enumerate}

Here's an example snippet of these steps in the \texttt{onCreate()}
method of an activity in which the Web Screenlet instance is
\texttt{screenlet}, and the \texttt{WebScreenletConfiguration} object is
\texttt{webScreenletConfiguration}:

\begin{verbatim}
WebScreenletConfiguration webScreenletConfiguration =
            new WebScreenletConfiguration.Builder("/web/westeros-hybrid/companynews")
                .addRawCss(R.raw.portlet, "portlet.css")
                .addLocalCss("gallery.css")
                .addLocalJs("gallery.js")
                .load();

        screenlet.setWebScreenletConfiguration(webScreenletConfiguration);
        screenlet.load();
\end{verbatim}

There are a few things to note about this example:

\begin{itemize}
\item
  The relative URL \texttt{/web/westeros-hybrid/companynews} supplied to
  the \texttt{WebScreenletConfiguration.Builder} constructor, and the
  lack of a \texttt{setWebType(WebScreenletConfiguration.WebType.OTHER)}
  call, indicates that this Web Screenlet instance loads a Liferay DXP
  page that requires authentication.
\item
  The \texttt{addRawCss} method adds the CSS file \texttt{portlet.css}
  from the app's \texttt{res/raw} folder. Any files that you add via the
  methods \texttt{addRawCss} or \texttt{addRawJs} must be located in
  \texttt{res/raw} (create this folder if it doesn't exist). Also note
  that you must reference these files with \texttt{R.raw.yourfilename}.
  For instance, the \texttt{portlet.css} file in this is example is
  referenced with \texttt{R.raw.portlet}.
\item
  The \texttt{addLocalCss} and \texttt{addLocalJs} methods add the local
  files \texttt{gallery.css} and \texttt{gallery.js}, respectively. Any
  files that you add via these methods must be in the first level of
  your app's \texttt{assets} folder. This folder must exist at the same
  level as your app's \texttt{res} folder. Create the \texttt{assets}
  folder in that location if it doesn't exist.
\end{itemize}

Great! Now you know how to use Web Screenlet in your Android apps.

\subsection{Related Topics}\label{related-topics-77}

\href{/docs/7-0/reference/-/knowledge_base/r/web-screenlet-for-android}{Web
Screenlet for Android}

\href{/docs/7-0/tutorials/-/knowledge_base/t/using-web-screenlet-with-cordova-in-your-android-app}{Using
Web Screenlet with Cordova in Your Android App}

\href{/docs/7-0/tutorials/-/knowledge_base/t/using-screenlets-in-android-apps}{Using
Screenlets in Android Apps}

\href{/docs/7-0/tutorials/-/knowledge_base/t/rendering-web-content-in-your-android-app}{Rendering
Web Content in Your Android App}

\section{Using Web Screenlet with Cordova in Your Android
App}\label{using-web-screenlet-with-cordova-in-your-android-app}

By using \href{https://cordova.apache.org/plugins/}{Cordova plugins} in
\href{/docs/7-0/tutorials/-/knowledge_base/t/rendering-web-pages-in-your-android-app}{Web
Screenlet}, you can extend the functionality of the web page that the
Screenlet renders. This lets you tailor that page to your app's needs.

You'll get started by installing and configuring Cordova. There are two
ways to do this: automatically, or manually. The automatic method is
covered first.

\subsection{Installing and Configuring Cordova
Automatically}\label{installing-and-configuring-cordova-automatically}

Follow these steps to automatically create an empty Android project
configured to use Cordova. Note that you must have
\href{https://git-scm.com/}{git}, \href{https://nodejs.org/en/}{Node.js,
and npm} installed.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Install \texttt{screens-cli}:

\begin{verbatim}
npm install -g screens-cli
\end{verbatim}
\item
  Create the file \texttt{.plugins.screens} in the folder you want to
  create your project in. In this file, add all the Cordova plugins you
  want to use in your app. For example, you can add plugins from Cordova
  or GitHub:

\begin{verbatim}
https://github.com/apache/cordova-plugin-wkwebview-engine.git
cordova-plugin-call-number
cordova-plugin-camera
\end{verbatim}
\item
  In the folder containing your \texttt{.plugins.screens} file, run
  \texttt{screens-cli} to create your project:

\begin{verbatim}
screens-cli android <project-name>
\end{verbatim}

  This creates your project in the folder
  \texttt{platforms/android/\textless{}project-name\textgreater{}}. You
  can open it with Android Studio.
\end{enumerate}

\subsection{Installing and Configuring Cordova
Manually}\label{installing-and-configuring-cordova-manually}

To install and configure Cordova manually, follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Follow \href{https://cordova.apache.org/\#getstarted}{the Cordova
  getting started guide} to install Cordova, create a Cordova project,
  and add the Android platform to your Cordova project.
\item
  Install any Cordova plugins you want to use in your app. For example,
  this command adds
  \href{https://www.npmjs.com/package/cordova-plugin-call-number}{the
  Cordova plugin \texttt{cordova-plugin-call-number}}:

\begin{verbatim}
cordova plugin add cordova-plugin-call-number
\end{verbatim}

  You can use \texttt{cordova\ plugin} to view the currently installed
  plugins.
\item
  Copy the following files and folders from your Cordova project to your
  Android project's root folder:

  \begin{itemize}
  \tightlist
  \item
    \texttt{/platforms/android/res/xml/config.xml}
  \item
    \texttt{/platforms/android/assets/www}
  \end{itemize}

  You should also review other files like \texttt{AndroidManifest.xml},
  resource files, and so on. Some plugins add permissions or styles in
  such files that you may need to copy for those plugins to work
  correctly in your Android app.
\end{enumerate}

\subsection{Using Cordova in Web
Screenlet}\label{using-cordova-in-web-screenlet}

Now that you've installed and configured Cordova in your Android
project, you're ready to use it with Web Screenlet. Follow these steps
to do so:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/rendering-web-pages-in-your-android-app}{Insert
  and configure Web Screenlet in your app}.
\item
  When you set Web Screenlet's parameters via the
  \texttt{WebScreenletConfiguration.Builder} object, you must enable
  Cordova by calling the \texttt{enableCordova} method with a
  \texttt{CordovaLifeCycleObserver} argument.
  \texttt{CordovaLifeCycleObserver} informs Cordova about the activity
  lifecycle. You can create an instance of this observer by using its
  no-argument constructor.

  For example, this code creates a \texttt{CordovaLifeCycleObserver}
  object that it then uses with \texttt{enableCordova} when setting Web
  Screenlet's parameters:

\begin{verbatim}
CordovaLifeCycleObserver observer = new CordovaLifeCycleObserver();

WebScreenletConfiguration configuration =
        new WebScreenletConfiguration
                .Builder("/")
                .addLocalJs("call.js")
                .enableCordova(observer)
                .load();

webScreenlet.setWebScreenletConfiguration(configuration);
webScreenlet.load();
\end{verbatim}
\item
  Override the following \texttt{Activity} methods to call their
  corresponding observer methods:

\begin{verbatim}
@Override
protected void onStart() {
    super.onStart();
    observer.onStart();
}

@Override
protected void onStop() {
    super.onStop();

    observer.onStop();
}

@Override
public void onPause() {
    super.onPause();

    observer.onPause();
}

@Override
public void onResume() {
    super.onResume();

    observer.onResume();
}

@Override
public void onDestroy() {
    super.onDestroy();

    observer.onDestroy();
}

@Override
public void onSaveInstanceState(Bundle outState) {
    super.onSaveInstanceState(outState);

    observer.onSaveInstanceState(outState);
}

@Override
protected void onActivityResult(int requestCode, int resultCode, Intent data) {
    super.onActivityResult(requestCode, resultCode, data);

    observer.onActivityResult(requestCode, resultCode, data);
}

@Override
public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, 
    @NonNull int[] grantResults) {
        super.onRequestPermissionsResult(requestCode, permissions, grantResults);

        observer.onRequestPermissionsResult(requestCode, permissions, grantResults);
}

@Override
public void onConfigurationChanged(Configuration newConfig) {
    super.onConfigurationChanged(newConfig);

    observer.onConfigurationChanged(newConfig);
}
\end{verbatim}
\end{enumerate}

That's it! Note, however, that you may also need to invoke Cordova from
a JavaScript file, depending on what you're doing. For example, to use
\href{https://www.npmjs.com/package/cordova-plugin-call-number}{the
Cordova plugin \texttt{cordova-plugin-call-number}} to call a number,
you must add a JavaScript file with the following code:

\begin{verbatim}
function callNumber() {
    //This line triggers the Cordova plugin and makes a call
    window.plugins.CallNumber.callNumber(null, function(){ alert("Calling failed.") }, "900000000", true);
}

setTimeout(callNumber, 3000);
\end{verbatim}

If you run the app containing this code and wait three seconds, the
plugin activates and calls the number in the JavaScript file.

Great! Now you know how to use Web Screenlet with Cordova.

\subsection{Related Topics}\label{related-topics-78}

\href{/docs/7-0/tutorials/-/knowledge_base/t/rendering-web-pages-in-your-android-app}{Rendering
Web Pages in Your Android App}

\href{/docs/7-0/reference/-/knowledge_base/r/web-screenlet-for-android}{Web
Screenlet for Android}

\section{Adding Offline Mode Support to Your Android
Screenlet}\label{adding-offline-mode-support-to-your-android-screenlet}

Offline mode lets Screenlets function without a network connection. For
offline mode to work with your Screenlet, you must manually add support
for it. Fortunately, Liferay Screens 2.0 introduced a simpler way of
implementing offline mode support in Android Screenlets:

\begin{itemize}
\tightlist
\item
  Update your Screenlet's classes to leverage the offline mode cache
\item
  Create an event class (if your Screenlet doesn't already have one)
\end{itemize}

Implementing these steps, however, differs somewhat depending on how
your Screenlet communicates with the server:

\begin{itemize}
\tightlist
\item
  \textbf{A write Screenlet:} writes data to a server. The Add Bookmark
  Screenlet created in the
  \href{/docs/7-0/tutorials/-/knowledge_base/t/creating-android-screenlets}{basic
  Screenlet creation tutorial} is a good example of a simple write
  Screenlet. It asks the user to enter a URL and a title, which it then
  sends to the Bookmarks portlet in Liferay DXP to create a bookmark.
\item
  \textbf{A read Screenlet:} reads data from a server. The Web Content
  Display Screenlet included with Liferay Screens is a good example of a
  read Screenlet. It retrieves web content from Liferay DXP for display
  in an Android app.
  \href{/docs/7-0/reference/-/knowledge_base/r/webcontentdisplayscreenlet-for-android}{Click
  here} to see Web Content Display Screenlet's documentation.
\end{itemize}

This tutorial shows you how to add offline mode support to both kinds of
Screenlets. You'll start with write Screenlets, using Add Bookmark
Screenlet as an example. Before getting started, be sure to read
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-android-screenlets}{the
basic Screenlet creation tutorial} to familiarize yourself with Add
Bookmark Screenlet's code. You'll conclude by learning how offline mode
implementation in read Screenlets differs from that of write Screenlets.

\subsection{Adding Offline Mode Support to Write
Screenlets}\label{adding-offline-mode-support-to-write-screenlets}

To add offline mode support to write Screenlets, you'll follow these
steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/adding-offline-mode-support-to-your-android-screenlet\#create-or-update-the-event-class}{Create
  or update the event class}.
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/adding-offline-mode-support-to-your-android-screenlet\#update-the-listener}{Update
  the listener interface}.
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/adding-offline-mode-support-to-your-android-screenlet\#update-the-interactor-class}{Update
  the Interactor class}.
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/adding-offline-mode-support-to-your-android-screenlet\#update-the-screenlet-class}{Update
  the Screenlet class}.
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/adding-offline-mode-support-to-your-android-screenlet\#sync-the-cache-with-the-server}{Sync
  the cache with the server}.
\end{enumerate}

Each of the sections that follow detail one of these steps. You'll begin
by creating or updating the event class.

\subsubsection{Create or Update the Event
Class}\label{create-or-update-the-event-class}

Recall from the basic Screenlet creation tutorial that an event class is
required to handle communication between Screenlet components. Also
recall that many Screenlets can use the event class included with
Screens, \texttt{BasicEvent}, as their event class. For offline mode to
work, however, you must create an event class that extends
\texttt{CacheEvent}
(\href{https://github.com/liferay/liferay-screens/blob/master/android/library/src/main/java/com/liferay/mobile/screens/base/interactor/event/CacheEvent.java}{click
here} to see \texttt{CacheEvent}). Your event class has one primary
responsibility: store and provide access to the arguments passed to the
Interactor. To accomplish this, your event class should do these things:

\begin{itemize}
\tightlist
\item
  Extend \texttt{CacheEvent}. For the arguments, define variables and
  public getter methods.
\item
  Define a no-argument constructor that only calls the corresponding
  superclass constructor.
\item
  Define a constructor that sets the Interactor's arguments.
\end{itemize}

In the case of Add Bookmark Screenlet, the arguments are the bookmark's
URL, folder ID, and title. For example, here's the full code for this
Screenlet's event class, \texttt{BookmarkEvent}:

\begin{verbatim}
public class BookmarkEvent extends CacheEvent {

    private String url; 
    private String title; 
    private long folderId; 

    public BookmarkEvent() { 
        super(); 
    }

    public BookmarkEvent(String url, String title, long folderId) {

        this.url = url; 
        this.title = title; 
        this.folderId = folderId; 
    }

    public String getURL() { 
        return url; 
    }

    public String getTitle() { 
        return title; 
    }

    public long getFolderId() { 
        return folderId; 
    } 
}
\end{verbatim}

Next, you'll update the listener.

\subsubsection{Update the Listener}\label{update-the-listener}

Recall from the basic Screenlet creation tutorial that the listener
interface defines a success method and a failure method. This lets
implementing classes respond to the server call's success or failure.
Listeners that support offline mode offer the same functionality,
although differently. Offline mode listeners must extend
\texttt{BaseCacheListener}, which defines only this \texttt{error}
method:

\begin{verbatim}
void error(Exception e, String userAction);
\end{verbatim}

By extending \texttt{BaseCacheListener}, your listener no longer needs
an explicit failure method because it inherits the \texttt{error} method
instead. This \texttt{error} method also includes an argument for the
user action that triggered the exception.

You can therefore update your listener to support offline mode by
extending \texttt{BaseCacheListener} and deleting the failure method.
For example, here's Add Bookmark Screenlet's listener,
\texttt{AddBookmarkListener}, after being updated to support offline
mode:

\begin{verbatim}
public interface AddBookmarkListener extends BaseCacheListener {

    onAddBookmarkSuccess(); 
}
\end{verbatim}

Note that you must also remove any failure method implementations (such
as in an activity or fragment that implements the listener), and replace
any failure method calls with \texttt{error} method calls. You'll do the
latter next when updating the Interactor class.

\subsubsection{Update the Interactor
Class}\label{update-the-interactor-class}

Recall from the basic Screenlet creation tutorial that Interactor
classes extend \texttt{BaseRemoteInteractor} with the listener and event
as type arguments. To support offline mode, your Interactor class must
instead extend one of the following classes. Which one depends on
whether your Interactor writes data to or reads data from a server:

\begin{itemize}
\tightlist
\item
  \texttt{BaseCacheWriteInteractor}: writes data to a server. Extend
  this class if your Screenlet is a write Screenlet.
  \href{https://github.com/liferay/liferay-screens/blob/master/android/library/src/main/java/com/liferay/mobile/screens/base/interactor/BaseCacheWriteInteractor.java}{Click
  here} to see this class.
\item
  \texttt{BaseCacheReadInteractor}: reads data from a server. Extend
  this class if your Screenlet is a read Screenlet.
  \href{https://github.com/liferay/liferay-screens/blob/master/android/library/src/main/java/com/liferay/mobile/screens/base/interactor/BaseCacheReadInteractor.java}{Click
  here} to see this class.
\end{itemize}

In either case, the type arguments are the same: the listener and the
event. Note, however, that the event must extend \texttt{CacheEvent} as
described above. For example, since Add Bookmark Screenlet is a write
Screenlet, to support offline mode its Interactor class must extend
\texttt{BaseCacheWriteInteractor} with \texttt{AddBookmarkListener} and
\texttt{AddBookmarkEvent} as type arguments:

\begin{verbatim}
public class AddBookmarkInteractor extends
    BaseCacheWriteInteractor<AddBookmarkListener, BookmarkEvent> {...
\end{verbatim}

You must also make a few changes to the Interactor class's code. The
main change is that the \texttt{execute} method now takes the event
instead of var args. You can then retrieve the data you need from the
event. For example, to support offline mode, the \texttt{execute} method
in \texttt{AddBookmarkInteractor} takes \texttt{BookmarkEvent} as an
argument. The bookmark's URL, title, and folder ID are then retrieved
from the event for use in the \texttt{getJSONObject} method that makes
the server call. The \texttt{execute} method finishes by setting the
resulting \texttt{JSONObject} to the event, and then returning the
event:

\begin{verbatim}
@Override 
public BookmarkEvent execute(BookmarkEvent bookmarkEvent) throws Exception {

    validate(bookmarkEvent.getUrl(), bookmarkEvent.getFolderId());

    JSONObject jsonObject = getJSONObject(bookmarkEvent.getUrl(), bookmarkEvent.getTitle(), 
        bookmarkEvent.getFolderId());
    bookmarkEvent.setJSONObject(jsonObject); 
    return bookmarkEvent; 
}
\end{verbatim}

You should also change the \texttt{onSuccess} method to take an instance
of your event class instead of \texttt{BasicEvent}. This is the only
change you need to make to this method. For example, the
\texttt{onSuccess} method in \texttt{AddBookmarkInteractor} supports
offline mode by taking a \texttt{BookmarkEvent} instead of a
\texttt{BasicEvent}:

\begin{verbatim}
@Override 
public void onSuccess(BookmarkEvent event) {
    getListener().onAddBookmarkSuccess(); 
}
\end{verbatim}

Now make the same change to the \texttt{onFailure} method, but replace
the listener's failure method call with a call to the \texttt{error}
method inherited from \texttt{BaseCacheListener} (see the listener
section above for an explanation of this method). For the \texttt{error}
method's arguments, you can retrieve the exception from the event and
define a string to use as the user action. For example, to support
offline mode the \texttt{onFailure} method in
\texttt{AddBookmarkInteractor} takes a \texttt{BookmarkEvent} instead of
a \texttt{BasicEvent}. Also, the method's \texttt{error} call defines
the ``ADD\_BOOKMARK'' string to indicate that the error occurred while
trying to add a bookmark to the server:

\begin{verbatim}
@Override public void onFailure(BookmarkEvent event) {
    getListener().error(event.getException(), "ADD_BOOKMARK"); 
}
\end{verbatim}

\subsubsection{Update the Screenlet
Class}\label{update-the-screenlet-class}

Updating the Screenlet class for offline mode is straightforward. In the
Screenlet class's \texttt{onUserAction} method, you'll change the call
to the Interactor's \texttt{start} method so that it takes only an event
as an argument. Before doing this, however, you should create an event
instance and set its cache key. A cache key is a value that identifies
an entity in the local cache. This lets you retrieve the entity from the
cache for later synchronization with the server.

In Add Bookmark Screenlet, for example, a bookmark's URL makes a good
cache key. To support offline mode, the \texttt{onUserAction} method in
\texttt{AddBookmarkScreenlet} creates a new \texttt{BookmarkEvent}
instance with a bookmark's data and then uses the \texttt{setCacheKey}
method to set the bookmark's URL as the event's cache key. The
Interactor's start method takes this event as its argument:

\begin{verbatim}
BookmarkEvent event = new BookmarkEvent(url, title, folderId);
event.setCacheKey(url); 
interactor.start(event);
\end{verbatim}

Note that you don't have to set a cache key to use offline mode.
Instead, you can pass the event to the \texttt{start} method without
calling \texttt{setCacheKey}. However, this means that you'll only be
able to access the most recent entity in the cache.

That's it! Your write Screenlet now supports offline mode. There's one
more detail to keep in mind, however, when using the Screenlet: syncing
the cache with the server. You'll learn about this next.

\subsubsection{Sync the Cache with the
Server}\label{sync-the-cache-with-the-server}

When using a write Screenlet that supports offline mode, new data
written to the cache must also be synced with the server. The write
Screenlets included with Liferay Screens do this for you. However, you
must do this manually when using a custom write Screenlet. You should do
this in the activity or fragment that uses the Screenlet--exactly where
in this activity or fragment is up to you though.

To sync a write Screenlet's data with the server manually, follow these
steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Retrieve the event that needs to be synced with the server. To do
  this, you must first get the cache key associated with the event. Then
  use the key as an argument to the \texttt{Cache.getObject} method.
\item
  Call the Interactor with the event. This syncs the data with the
  server.
\end{enumerate}

For example, the following code uses the \texttt{Cache.findKeys} method
to retrieve all \texttt{BookmarkEvent} keys in the cache. The loop that
follows then retrieves the event that corresponds to each key, and syncs
it to the server by calling the Interactor:

\begin{verbatim}
String[] keys = Cache.findKeys(BookmarkEvent.class, groupId, userId, locale, 0, 
    Integer.MAX_VALUE); 
for (String key : keys) {

    BookmarkEvent event = Cache.getObject(BookmarkEvent.class, groupId, userId, key); 
    new AddBookmarkInteractor().execute(event); 
}
\end{verbatim}

Note that if you opted not to set a cache key in your Screenlet class,
you can pass \texttt{null} in place of a key.

Also note that you can use Android's \texttt{SharedPreferences} APIs as
an alternative way to store and retrieve cache keys. For example, the
following code stores cache keys in shared preferences:

\begin{verbatim}
SharedPreferences sharedPreferences = getSharedPreferences("MY_PREFERENCES", Context.MODE_PRIVATE); 
HashSet<String> values = new HashSet<>();
sharedPreferences.edit().putStringSet("keysToSync", values).apply();
\end{verbatim}

You can then retrieve the keys as you would retrieve any other key-value
set from shared preferences:

\begin{verbatim}
SharedPreferences sharedPreferences = getSharedPreferences("MY_PREFERENCES", Context.MODE_PRIVATE); 
HashSet<String> keysToSync = sharedPreferences.getStringSet("keysToSync", new HashSet<>());
\end{verbatim}

Next, you'll learn how to add offline mode support to read Screenlets.

\subsection{Adding Offline Mode Support to Read
Screenlets}\label{adding-offline-mode-support-to-read-screenlets}

Implementing offline mode support in a read Screenlet is almost
identical to doing so in a write Screenlet. There are two small
differences, though:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  You can still pass arguments to the Interactor with var args instead
  of an event.
\item
  The Interactor class must extend \texttt{BaseCacheReadInteractor},
  which forces you to implement the \texttt{getIdFromArgs} method. This
  method takes the var args passed to the Interactor so you can return
  the argument that identifies your entity. Note that because this
  method requires you to return a \texttt{String}, you'll often use
  \texttt{String.valueOf} to return non-string arguments as a string.
  For example, the \texttt{getIdFromArgs} implementation in Comment
  Display Screenlet's \texttt{CommentLoadInteractor} retrieves the
  comment ID (a \texttt{long}) from the first argument and then returns
  it as a \texttt{String}:

\begin{verbatim}
 @Override 
 protected String getIdFromArgs(Object... args) { 
     long commentId = (long) args[0]; 
     return String.valueOf(commentId); 
 }
\end{verbatim}
\end{enumerate}

That's it! Next, you'll learn about list Screenlets and offline mode
support.

\subsubsection{Adding Offline Mode Support to List
Screenlets}\label{adding-offline-mode-support-to-list-screenlets}

A list Screenlet is a special type of read Screenlet that displays
entities in a list. Recall from the
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-android-list-screenlets}{list
Screenlet creation tutorial} that list Screenlets have a model class
that encapsulates entities retrieved from the server. To support offline
mode, a list Screenlet's event class must extend \texttt{ListEvent} with
the model class as a type argument. This event class also needs three
things:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  A default constructor
\item
  A \texttt{getListKey} method that returns a unique ID to store the
  entity with
\item
  A \texttt{getModel} method that returns the model instance
\end{enumerate}

The list Screenlet creation tutorial contains example model and event
classes that support offline mode for Bookmark List Screenlet. Click the
following links to see the sections in the tutorial that show you how to
create these classes:

\begin{itemize}
\tightlist
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/creating-android-list-screenlets\#creating-the-model-class}{Creating
  the Model Class}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/creating-android-list-screenlets\#creating-the-screenlets-event}{Creating
  the Event}
\end{itemize}

And that's all! Now you know how to support offline mode in your
Screenlets.

\subsection{Related Topics}\label{related-topics-79}

\href{/docs/7-0/tutorials/-/knowledge_base/t/using-offline-mode-in-android}{Using
Offline Mode in Android}

\href{/docs/7-0/tutorials/-/knowledge_base/t/architecture-of-offline-mode-in-liferay-screens}{Architecture
of Offline Mode in Liferay Screens}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-android-screenlets}{Creating
Android Screenlets}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-android-list-screenlets}{Creating
Android List Screenlets}

\section{Android Best Practices}\label{android-best-practices}

When developing Android projects with Liferay Screens, there are a few
best practices that you should follow to ensure your code is as clean
and bug-free as possible. This tutorial lists these.

\subsection{Update Your Tools}\label{update-your-tools}

You should first make sure that you have the latest tools installed. You
should use the latest Android API level with the latest version of
Android Studio. Although Screens \emph{may} work with Eclipse ADT or
manual Gradle builds, Android Studio is the preferred IDE.

\subsection{See the Breaking Changes
Document}\label{see-the-breaking-changes-document}

When updating an app or Screenlet to a new version of Liferay Screens,
make sure to see the
\href{/docs/7-0/reference/-/knowledge_base/r/android-breaking-changes}{Android
breaking changes reference article}. This article lists changes to
Screens that break functionality in prior versions. In most cases,
updating your code is relatively straightforward.

\subsection{Naming Conventions}\label{naming-conventions}

Using the naming conventions described here leads to consistency and a
better understanding of the Screens library. This makes working with
your Screenlets much simpler.

Also note that Liferay Screens follows
\href{https://github.com/square/java-code-styles}{Square's Java
conventions} for Android, with tabs as separator. The configuration for
IDEA, findbugs, PMD, and checkstyle is available in the project's source
code.

\subsubsection{Screenlet Folder}\label{screenlet-folder}

Your Screenlet folder's name should indicate your Screenlet's
functionality. For example,
\href{https://github.com/liferay/liferay-screens/tree/master/android/library/src/main/java/com/liferay/mobile/screens/auth/login}{Login
Screenlet's folder is named \texttt{login}}.

If you have multiple Screenlets that operate on the same entity, you can
place them inside a folder named for that entity. For example,
\href{/docs/7-0/reference/-/knowledge_base/r/asset-display-screenlet-for-android}{Asset
Display Screenlet} and
\href{/docs/7-0/reference/-/knowledge_base/r/assetlistscreenlet-for-android}{Asset
List Screenlet} both work with Liferay assets. They're therefore in the
Screens library's
\href{https://github.com/liferay/liferay-screens/tree/master/android/library/src/main/java/com/liferay/mobile/screens/asset}{\texttt{asset}
folder}.

\subsubsection{Screenlets}\label{screenlets}

Naming Screenlets properly is very important; they're the main focus of
Liferay Screens. You should name your Screenlet with its principal
action first, followed by \emph{Screenlet}. Its Screenlet class should
also follow this pattern. For example,
\href{/docs/7-0/reference/-/knowledge_base/r/loginscreenlet-for-android}{Login
Screenlet's} principal action is to log users into a Liferay DXP
installation. This Screenlet's Screenlet class is therefore
\texttt{LoginScreenlet}.

\subsubsection{View Models}\label{view-models}

Name your View models the same way you name Screenlets, but substitute
\texttt{ViewModel} for \texttt{Screenlet}. Also, place your View Models
in a \texttt{view} folder in your Screenlet's root folder. For example,
Login Screenlet's View Model is named \texttt{LoginViewModel} and is in
the
\href{https://github.com/liferay/liferay-screens/tree/master/android/library/src/main/java/com/liferay/mobile/screens/auth/login/view}{\texttt{login/view}
folder}.

\subsubsection{Interactors}\label{interactors}

Place your Screenlet's Interactors in a folder named \texttt{interactor}
in your Screenlet's root folder. Name each Interactor first with the
object it operates on, followed by its action and the suffix
\emph{Interactor}. If you wish, you can also put each Interactor in its
own folder named after its action. For example,
\href{/docs/7-0/reference/-/knowledge_base/r/rating-screenlet-for-android}{Rating
Screenlet} has three Interactors. Each is in its own folder inside
\href{https://github.com/liferay/liferay-screens/tree/master/android/library/src/main/java/com/liferay/mobile/screens/rating/interactor}{the
\texttt{interactor} folder}:

\begin{itemize}
\tightlist
\item
  \texttt{delete/RatingDeleteInteractor}: Deletes an asset's ratings
\item
  \texttt{load/RatingLoadInteractor}: Loads an asset's ratings
\item
  \texttt{update/RatingUpdateInteractor}: Updates an asset's ratings
\end{itemize}

\subsubsection{Views}\label{views}

Place Views in a \texttt{view} folder in the Screenlet's root folder. If
you're creating a View Set, however, you can place its Views in a
separate \texttt{viewsets} folder outside your Screenlets' root folders.
This is what the Screens Library does for
\href{https://github.com/liferay/liferay-screens/tree/master/android/viewsets}{its
Material and Westeros View Sets}. The \texttt{material} and
\texttt{westeros} folders contain those View Sets, respectively. Also
note that in each View, each Screenlet's View class is in its own
folder. For example, the View class for
\href{/docs/7-0/reference/-/knowledge_base/r/forgotpasswordscreenlet-for-android}{Forgot
Password Screenlet's} Material View is in
\href{https://github.com/liferay/liferay-screens/tree/master/android/viewsets/material/src/main/java/com/liferay/mobile/screens/viewsets/material/auth/forgotpassword}{the
folder
\texttt{viewsets/material/src/main/java/com/liferay/mobile/screens/viewsets/material/auth/forgotpassword}}.
Note that the \texttt{auth} folder in this path is the Screenlet's
module. Creating your Screenlets and Views in modules isn't required.
Also note that the
\href{https://github.com/liferay/liferay-screens/blob/master/android/viewsets/material/src/main/res/layout/forgotpassword_material.xml}{View's
layout file \texttt{forgotpassword\_material.xml}} is in
\texttt{viewsets/material/src/main/res/layout}.

Name a View's layout XML and View class after your Screenlet,
substituting \emph{View} for \emph{Screenlet} where necessary. The
layout's filename should also be suffixed with \texttt{\_yourViewName}.
For example, the XIB file and View class for Forgot Password Screenlet's
Material View are \texttt{forgotpassword\_material.xml} and
\texttt{ForgotPasswordView.java}, respectively.

\subsection{Avoid Hard Coded Elements}\label{avoid-hard-coded-elements}

Using constants instead of hard-coded elements is a simple way to avoid
bugs. Constants reduce the likelihood that you'll make a typo when
referring to common elements. They also gather these elements in a
single location. For example,
\href{https://github.com/liferay/liferay-screens/blob/master/android/library/src/main/java/com/liferay/mobile/screens/ddl/form/DDLFormScreenlet.java}{DDL
Form Screenlet's Screenlet class} defines the following constants for
the user action names:

\begin{verbatim}
public static final String LOAD_FORM_ACTION = "loadForm";
public static final String LOAD_RECORD_ACTION = "loadRecord";
public static final String ADD_RECORD_ACTION = "addRecord";
public static final String UPDATE_RECORD_ACTION = "updateRecord";
public static final String UPLOAD_DOCUMENT_ACTION = "uploadDocument";
\end{verbatim}

\subsection{Avoid State in
Interactors}\label{avoid-state-in-interactors}

Liferay Screens uses \href{http://greenrobot.org/eventbus/}{EventBus} to
ensure that the network or background operation isn't lost when the
device changes orientation. For this to work, however, you must ensure
that your Interactor's request is stateless.

If an Interactor needs some piece of information, you should pass it to
the Interactor via the \texttt{start} call and then attach it to the
event. You can see an example of this in the sample Add Bookmark
Screenlet from
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-android-screenlets}{the
Screenlet creation tutorial}. The \texttt{onUserAction} method in the
Screenlet class (\texttt{AddBookmarkScreenlet}) passes a Bookmark's URL
and title from the View Model to the Interactor via the Interactor's
\texttt{start} method:

\begin{verbatim}
@Override
protected void onUserAction(String userActionName, AddBookmarkInteractor interactor, 
    Object... args) {
        AddBookmarkViewModel viewModel = getViewModel();
        String url = viewModel.getURL();
        String title = viewModel.getTitle();

        interactor.start(url, title, folderId);
}
\end{verbatim}

The \texttt{start} method calls the Interactor's \texttt{execute} method
in a background thread. The \texttt{execute} method in Add Bookmark
Screenlet's Interactor (\texttt{AddBookmarkInteractor}) creates a
\texttt{BasicEvent} object that contains the \texttt{start} method's
arguments:

\begin{verbatim}
@Override
public BasicEvent execute(Object[] args) throws Exception {
    String url = (String) args[0];
    String title = (String) args[1];
    long folderId = (long) args[2];

    validate(url, folderId);

    JSONObject jsonObject = getJSONObject(url, title, folderId);
    return new BasicEvent(jsonObject);
}
\end{verbatim}

\subsection{Stay in Your Layer}\label{stay-in-your-layer}

When accessing variables that belong to other Screenlet components, you
should avoid those outside your current Screenlet layer. This achieves
better decoupling between the layers, which tends to reduce bugs and
simplify maintenance. For an explanation of the layers in Liferay
Screens, see
\href{/docs/7-0/tutorials/-/knowledge_base/t/architecture-of-liferay-screens-for-android}{the
architecture tutorial}. For example, don't directly access View
variables from an Interactor. Instead, pass data from a View Model to
the Interactor via the Interactor's \texttt{start} method. The example
\texttt{onUserAction} method in the previous section illustrates this.

\subsection{Related Topics}\label{related-topics-80}

\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-screens-for-android-troubleshooting-and-faqs}{Liferay
Screens for Android Troubleshooting and FAQs}

\href{/docs/7-0/tutorials/-/knowledge_base/t/architecture-of-liferay-screens-for-android}{Architecture
of Liferay Screens for Android}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-android-screenlets}{Creating
Android Screenlets}

\href{/docs/7-0/reference/-/knowledge_base/r/android-breaking-changes}{Android
Breaking Changes}

\section{Liferay Screens for Android Troubleshooting and
FAQs}\label{liferay-screens-for-android-troubleshooting-and-faqs}

Even though Liferay developed Screens for Android with great care, you
may still run into some common issues. Here are solutions and tips for
solving these issues. You'll also find answers to common questions about
Screens for Android.

\subsection{General Troubleshooting}\label{general-troubleshooting}

Before delving into specific issues, you should first make sure that you
have the latest tools installed and know where to get additional help if
you need it. You should use the latest Android API level, with the
latest version of Android Studio. Although Screens \emph{can} work with
Eclipse ADT or manual Gradle builds, Android Studio is the preferred
IDE.

If you're having trouble using Liferay Screens, it may help to
investigate the sample apps developed by Liferay. Both serve as good
examples of how to use Screenlets and Views:

\begin{itemize}
\tightlist
\item
  \href{https://github.com/liferay/liferay-screens/tree/master/android/samples/bankofwesteros}{Westeros
  Bank}
\item
  \href{https://github.com/liferay/liferay-screens/tree/master/android/samples/test-app}{Test
  App}
\end{itemize}

When updating an app or Screenlet to a new version of Liferay Screens,
make sure to see the
\href{/docs/7-0/reference/-/knowledge_base/r/android-breaking-changes}{Android
breaking changes reference article}. This article lists changes to
Screens that break functionality in prior versions. In most cases,
updating your code is relatively straightforward.

If you get stuck at any point, you can post your question on our
\href{https://www.liferay.com/community/forums/-/message_boards/category/42706063}{forum}.
We're happy to assist you! If you found a bug or want to suggest an
improvement, file a ticket in our
\href{https://issues.liferay.com/browse/LMW/}{Jira}. Note that you must
\href{https://issues.liferay.com/login.jsp?os_destination=\%2Fbrowse\%2F}{log
in} first to be able to see the project.

\subsection{Common Issues}\label{common-issues}

This section contains information on common issues that can occur when
using Liferay Screens.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Could not find \texttt{com.liferay.mobile:liferay-screens}

  This error occurs when Gradle isn't able to find Liferay Screens or
  the repository. First, check that the Screens version number you're
  trying to use exists in jCenter. You can use this
  \href{https://bintray.com/liferay/liferay-mobile/liferay-screens/view}{link}
  to see all uploaded versions.

  It's also possible that you're using an old Gradle plugin that doesn't
  use jCenter as the default repository. Screens uses version 1.2.3 and
  later. You can add jCenter as a new repository by placing this code in
  your project's \texttt{build.gradle} file:

\begin{verbatim}
repositories {
    jcenter()
}
\end{verbatim}
\item
  Failed to resolve: \texttt{com.android.support:appcompat-v7}

  Liferay Screens uses the appcompat library from Google, as do all new
  Android projects created with the latest Android Studio. The appcompat
  library uses a custom repository maintained by Google, so it must be
  updated manually using the Android SDK Manager.

  In the Android SDK Manager (located at \emph{Tools} → \emph{Android} →
  \emph{SDK Manager} in Android Studio), you must install at least
  version 14 of the Android Support Repository (in the \emph{Extras}
  menu), and version 22.1.1 of the Android Support Library.
\item
  Duplicate files copied in \texttt{APK\ META-INF}\ldots{}

  This is a common Android error when using libraries. It occurs because
  Gradle can't merge duplicated files such as license or notice files.
  To prevent this error, add the following code to your
  \texttt{build.gradle} file:

\begin{verbatim}
android {
    ...
    packagingOptions {
        exclude 'META-INF/LICENSE'
        exclude 'META-INF/NOTICE'
    }
    ...
}
\end{verbatim}

  This error may not happen right away, but may only appear later on in
  the development process. For this reason, it's recommended that you
  put the above code in your \texttt{build.gradle} file after creating
  your project.
\item
  Connect failed: ECONNREFUSED (Connection refused), or
  \texttt{org.apache.http.conn.HttpHostConnectException}

  This error occurs when Liferay Screens and the underlying Liferay
  Mobile SDK can't connect to the Liferay Portal instance. If you get
  this error, you should first check the IP address of the server to
  make sure it's available. If you've
  \href{/docs/7-0/tutorials/-/knowledge_base/t/preparing-android-projects-for-liferay-screens\#configuring-communication-with-liferay}{overridden
  the default IP address in \texttt{server\_context.xml}}, you should
  check to make sure that you've set it to the correct IP. Also, if
  you're using the Genymotion emulator, you must use
  \texttt{192.168.56.1} instead of localhost for your app to communicate
  with a local Liferay instance.
\item
  \texttt{java.io.IOException}: open failed: EACCES (Permission denied)

  Some Screenlets use temporary files to store information, such as when
  the User Portrait Screenlet uploads a new portrait, or the DDL Form
  Screenlet uploads new files to the portal. Your app needs to have the
  necessary permissions to use a specific Screenlet's functionality. In
  this case, add the following line to your
  \texttt{AndroidManifest.xml}:

\begin{verbatim}
<uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
\end{verbatim}

  If you're using the device's camera, you also need to add the
  following permission:

\begin{verbatim}
<uses-permission android:name="android.permission.CAMERA"/>
\end{verbatim}
\item
  No JSON web service action with path \ldots{}

  This error most commonly occurs if you haven't installed the
  \href{https://github.com/liferay/liferay-screens/tree/master/portal}{Liferay
  Screens Compatibility Plugin}. This plugin adds new API calls to
  Liferay Portal.
\end{enumerate}

\subsection{FAQs}\label{faqs}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Do I have to use Android Studio?

  No, Liferay Screens also works with Eclipse ADT. You can also compile
  your project manually with Gradle or another build system. Just make
  sure you use the compiled \texttt{aar} in your project's \texttt{lib}
  folder.

  We \emph{strongly} recommend, however, that you use Android Studio.
  Android Studio is the official IDE for developing Android apps, and
  Eclipse ADT is no longer supported. Using Eclipse ADT or compiling
  manually may cause unexpected issues that are difficult to overcome.
\item
  How does Screens handle orientation changes?

  Liferay Screens uses an event bus,
  \href{http://greenrobot.github.io/EventBus/}{the \texttt{EventBus}
  library}, to notify activities when the interactor has finished its
  work.
\item
  How can I use a Liferay feature not available in Screens?

  There are several ways you can use Liferay features not currently
  available in Screens. The
  \href{https://github.com/liferay/liferay-mobile-sdk}{Liferay Mobile
  SDK} gives you access to all of Liferay's remote APIs. You can also
  create a custom Screenlet to support any features not included in
  Screens by default.
\item
  How do I create a new Screenlet?

  Screenlet creation is explained in detail
  \href{/docs/7-0/tutorials/-/knowledge_base/t/creating-android-screenlets}{here}.
\item
  How can I customize a Screenlet?

  You can customize Screenlets by creating new Views. Fortunately,
  there's a
  \href{/docs/7-0/tutorials/-/knowledge_base/t/creating-android-views}{tutorial}
  for this!
\item
  Does Screens have offline support?

  Yes, since Liferay Screens 1.3!
\end{enumerate}

\subsection{Related Topics}\label{related-topics-81}

\href{/docs/7-0/tutorials/-/knowledge_base/t/preparing-android-projects-for-liferay-screens}{Preparing
Android Projects for Liferay Screens}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-android-screenlets}{Creating
Android Screenlets}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-android-views}{Creating
Android Views}

\href{/docs/7-0/tutorials/-/knowledge_base/t/mobile-sdk}{Mobile SDK}

\href{/docs/7-0/reference/-/knowledge_base/r/android-breaking-changes}{Android
Breaking Changes}

\chapter{iOS Apps with Liferay
Screens}\label{ios-apps-with-liferay-screens}

Liferay Screens speeds up and simplifies developing native mobile apps
that use Liferay. Its power lies in its \emph{Screenlets}. A Screenlet
is a visual component that you insert into your native app to leverage
Liferay Portal's content and
\href{/docs/7-0/tutorials/-/knowledge_base/t/invoking-remote-services}{services}.
On iOS, Screenlets are available to log in to your portal, create
accounts, submit forms, display content, and more. You can use any
number of Screenlets in your app; they're independent, so you can use
them in modular fashion. Screenlets on iOS also deliver UI flexibility
with pluggable \emph{Themes} that implement elegant user interfaces.
Liferay's reference documentation for
\href{/docs/7-0/reference/-/knowledge_base/r/screenlets-in-liferay-screens-for-ios}{iOS}
Screenlets describes each Screenlet's features and Themes.

You might be thinking, ``These Screenlets sound like the greatest thing
since taco Tuesdays, but what if they don't fit in with my app's UI?
What if they don't behave exactly how I want them to? What if there's no
Screenlet for what I want to do?'' Fret not! You can customize
Screenlets to fit your needs by changing or extending their UI and
behavior. You can even write your own Screenlets! What's more, Screens
seamlessly integrates with your existing iOS projects.

\begin{figure}
\centering
\includegraphics{./images/screens-ios-intro.png}
\caption{Here's an app that uses a Liferay Screens Sign Up Screenlet.}
\end{figure}

Screenlets leverage the
\href{https://www.liferay.com/community/liferay-projects/liferay-mobile-sdk/overview}{Liferay
Mobile SDK} to make server calls. The Mobile SDK is a low-level layer on
top of the Liferay JSON API. To write your own Screenlets, you must
familiarize yourself with Liferay's
\href{/docs/7-0/tutorials/-/knowledge_base/t/invoking-remote-services}{remote
services}. If no existing Screenlet meets your needs, consider
customizing an existing Screenlet, creating a Screenlet, or directly
using the Mobile SDK. Creating a Screenlet involves writing Mobile SDK
calls and constructing the Screenlet; if you don't plan to reuse or
distribute the implementation then you may want to forgo writing a
Screenlet and, instead, work with the
\href{/docs/7-0/tutorials/-/knowledge_base/t/mobile-sdk}{Mobile SDK}. A
benefit of integrating an existing Screenlet into your app, however, is
that the Mobile SDK's details are abstracted from you.

These tutorials show you how to use, customize, create, and distribute
Screenlets for iOS. They show you how to create Themes too. There's even
a tutorial that explains the nitty-gritty details of the Liferay Screens
architecture. No matter how deep you want to go, you'll use Screenlets
in no time. Start by preparing your
\href{/docs/7-0/tutorials/-/knowledge_base/t/preparing-ios-projects-for-liferay-screens}{iOS
project} to use Liferay Screens.

\section{Preparing iOS Projects for Liferay
Screens}\label{preparing-ios-projects-for-liferay-screens}

To develop iOS apps with Liferay Screens, you must first install and
configure Screens in your iOS project. Screens is released as a standard
\href{https://cocoapods.org}{CocoaPods} dependency. You must therefore
install Screens via CocoaPods. After completing the installation, you
must configure your iOS project to communicate with your Liferay DXP
instance. This tutorial walks you through these processes. You'll be up
and running in no time!

First, you'll review the requirements for Liferay Screens.

\subsection{Requirements}\label{requirements-1}

Liferay Screens for iOS includes the Component Library (the Screenlets)
and some sample projects written in Swift. Screens is developed using
Swift and development techniques that leverage functional Swift code and
the
\href{http://en.wikipedia.org/wiki/Model\%E2\%80\%93view\%E2\%80\%93presenter}{Model
View Presenter} architecture. You can use Swift or Objective-C with
Screens, and you can run Screens apps on iOS 9 and above.

Liferay Screens for iOS requires the following software:

\begin{itemize}
\tightlist
\item
  Xcode 9.3 or newer
\item
  iOS 11 SDK
\item
  \href{http://cocoapods.org}{CocoaPods} 1 or newer
\item
  \href{http://www.liferay.com/downloads/liferay-portal/available-releases}{Liferay
  Portal 6.2 CE/EE, Liferay CE Portal 7.0/7.1, or Liferay DXP 7.0}
\item
  Liferay Screens Compatibility Plugin
  (\href{http://www.liferay.com/marketplace/-/mp/application/54365664}{CE}
  or
  \href{http://www.liferay.com/marketplace/-/mp/application/54369726}{DXP/EE},
  depending on your portal edition). This app is preinstalled in Liferay
  CE Portal 7.0/7.1 CE and Liferay DXP 7.0.
\end{itemize}

\subsection{Securing JSON Web
Services}\label{securing-json-web-services-1}

Each Screenlet in Liferay Screens calls one or more of Liferay DXP's
JSON web services, which are enabled by default. The Screenlet
\href{/docs/7-0/reference/-/knowledge_base/r/screenlets-in-liferay-screens-for-ios}{reference
documentation} lists the web services that each Screenlet calls. To use
a Screenlet, its web services must be enabled in the portal. It's
possible, however, to disable the web services needed by Screenlets
you're not using. For instructions on this, see the tutorial
\href{/docs/7-0/tutorials/-/knowledge_base/t/portal-configuration-of-json-web-services}{Configuring
JSON Web Services}. You can also use
\href{/docs/7-0/tutorials/-/knowledge_base/t/service-access-policies}{Service
Access Policies} for more fine-grained control over accessible services.

\subsection{Configuring Your Project with
CocoaPods}\label{configuring-your-project-with-cocoapods}

To use CocoaPods to prepare your iOS 9.0 (or above) project for Liferay
Screens, follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In your project's root folder, add the following code to the file
  named \texttt{Podfile}, or create this file if it doesn't exist. Be
  sure to replace \texttt{Your\ Target} with your target's name:

\begin{verbatim}
source 'https://github.com/CocoaPods/Specs.git'

platform :ios, '9.0'
use_frameworks!

target "Your Target" do
    pod 'LiferayScreens'
end

# the rest of your podfile
\end{verbatim}

  Note that Liferay Screens and some of its dependencies aren't
  compatible with Swift 3.2 or Swift 4.0. If your iOS project is
  compiled in Swift 3.2 or Swift 4.0, then your \texttt{Podfile} must
  specify Screens and those dependencies for compilation in Swift 4.2.
  The \texttt{post\_install} code in the following \texttt{Podfile} does
  this. You must therefore use this \texttt{Podfile} if you want to use
  Screens in a Swift 3.2 or Swift 4.0 app:

\begin{verbatim}
source 'https://github.com/CocoaPods/Specs.git'

platform :ios, '9.0'
use_frameworks!

target "Your Target" do
    pod 'LiferayScreens'
end

post_install do |installer|
  incompatiblePods = [
    'Cosmos',
    'CryptoSwift',
    'KeychainAccess',
    'Liferay-iOS-SDK',
    'Liferay-OAuth',
    'LiferayScreens',
    'Kingfisher'
  ]

  installer.pods_project.targets.each do |target|
    if incompatiblePods.include? target.name
      target.build_configurations.each do |config|
        config.build_settings['SWIFT_VERSION'] = '4.2'
      end
    end
    target.build_configurations.each do |config|
        config.build_settings['CONFIGURATION_BUILD_DIR'] = '$PODS_CONFIGURATION_BUILD_DIR'
    end
  end
end

# the rest of your podfile 
\end{verbatim}
\item
  On the terminal, navigate to your project's root folder and run this
  command:

\begin{verbatim}
pod repo update
\end{verbatim}

  This ensures you have the latest version of the CocoaPods repository
  on your machine. Note that this command can take a while to run.
\item
  Still in your project's root folder in the terminal, run this command:

\begin{verbatim}
pod install
\end{verbatim}

  Once this completes, quit Xcode and reopen your project by using the
  \texttt{*.xcworkspace} file in your project's root folder. From now
  on, you must use this file to open your project.
\end{enumerate}

Great! To configure your project's communication with Liferay DXP, you
can skip the next section and follow the instructions in the final
section.

\subsection{Configuring Communication with Liferay
DXP}\label{configuring-communication-with-liferay-dxp-2}

Configuring communication between Screenlets and Liferay DXP is easy.
Liferay Screens uses a property list (\texttt{.plist}) file to access
your Liferay DXP instance. It must include the server's URL, the
portal's company ID, and the site's group ID. Create a
\texttt{liferay-server-context.plist} file and specify values required
for communicating with your Liferay DXP instance. As an example, refer
to
\href{https://github.com/liferay/liferay-screens/blob/master/ios/Framework/Core/Resources/liferay-server-context-sample.plist}{\texttt{liferay-server-context-sample.plist}}.

\begin{figure}
\centering
\includegraphics{./images/screens-ios-liferay-context.png}
\caption{Here's a property list file, called
\texttt{liferay-context.plist}.}
\end{figure}

The values you need to specify in your
\texttt{liferay-server-context.plist} are:

\begin{itemize}
\tightlist
\item
  \texttt{server}: Your Liferay DXP instance's URL.
\item
  \texttt{version}: Your Liferay DXP instance's version. Supported
  values are \texttt{71} for Liferay CE Portal 7.1 or Liferay DXP 7.1,
  \texttt{70} for Liferay CE Portal 7.0 or Liferay DXP 7.0, and
  \texttt{62} for Liferay Portal 6.2 CE/EE.
\item
  \texttt{companyId}: Your Liferay DXP instance's identifier. You can
  find this value in the \emph{Instance ID} column of \emph{Control
  Panel} → \emph{Portal Instances}.
\item
  \texttt{groupId}: The ID of the default site you want Screens to
  communicate with. You can find this value in the Site ID field of the
  site's \emph{Site Administration} → \emph{Configuration} → \emph{Site
  Settings} menu.
\item
  \texttt{connectorFactoryClassName}: Your Connector's factory class
  name. This is optional. If you don't include it, the \texttt{version}
  value is used to determine which factory is the most suitable for that
  version of Liferay DXP.
\end{itemize}

Great! Your iOS project is ready for Liferay Screens.

\subsection{Related Topics}\label{related-topics-82}

\href{/docs/7-0/tutorials/-/knowledge_base/t/using-screenlets-in-ios-apps}{Using
Screenlets in iOS Apps}

\href{/docs/7-0/tutorials/-/knowledge_base/t/using-themes-in-ios-screenlets}{Using
Themes in iOS Screenlets}

\href{/docs/7-0/tutorials/-/knowledge_base/t/preparing-android-projects-for-liferay-screens}{Preparing
Android Projects for Liferay Screens}

\section{Using Screenlets in iOS
Apps}\label{using-screenlets-in-ios-apps}

Once you've
\href{/docs/7-0/tutorials/-/knowledge_base/t/preparing-ios-projects-for-liferay-screens}{prepared}
your iOS project to use Liferay Screens, you can use Screenlets in your
app. There are plenty of Liferay Screenlets available, and they're
described in the Screenlet
\href{/docs/7-0/reference/-/knowledge_base/r/screenlets-in-liferay-screens-for-ios}{reference
documentation}. This tutorial shows you how to insert and configure
Screenlets in iOS apps written in Swift and Objective-C. It also
explains how to localize them. You'll be a Screenlet master in no time!

\subsection{Inserting and Configuring Screenlets in iOS
Apps}\label{inserting-and-configuring-screenlets-in-ios-apps}

The first step to using Screenlets in your iOS project is to add a new
UIView to your project. In Interface Builder, insert a new UIView into
your Storyboard or XIB file. Figure 1 shows this.

\begin{figure}
\centering
\includegraphics{./images/screens-ios-add-uiwindow.png}
\caption{Add a new UIView to your project.}
\end{figure}

Next, enter the Screenlet's name as the Custom Class. For example, if
you're using the Login Screenlet, then enter Login Screenlet as the
class.

\begin{figure}
\centering
\includegraphics{./images/screens-ios-custom-class.png}
\caption{Change the Custom Class to match the Screenlet.}
\end{figure}

Now you need to conform the Screenlet's delegate protocol in your
\texttt{ViewController} class. For example, the Login Screenlet's
delegate class is \texttt{LoginScreenletDelegate}. This is shown in the
code that follows. Note that you need to implement the functionality of
\texttt{onLoginResponse} and \texttt{onLoginError}. This is indicated by
the comments in the code here:

\begin{verbatim}
class ViewController: UIViewController, LoginScreenletDelegate {

    ...

   func screenlet(screenlet: BaseScreenlet,
           onLoginResponseUserAttributes attributes: [String:AnyObject]) {
       // handle succeeded login using passed user attributes
    }

    func screenlet(screenlet: BaseScreenlet,
            onLoginError error: NSError) {
        // handle failed login using passed error
    }

    ...
\end{verbatim}

If you're using CocoaPods, you need to import Liferay Screens in your
View Controller:

\begin{verbatim}
import LiferayScreens
\end{verbatim}

Now that the Screenlet's delegate protocol conforms in your
\texttt{ViewController} class, go back to Interface Builder and connect
the Screenlet's delegate to your View Controller. If the Screenlet
you're using has more outlets, you can assign them as well.

Note that currently Xcode has some
\href{http://stackoverflow.com/questions/26180268/interface-builder-iboutlet-and-protocols-for-delegate-and-datasource-in-swift/26180481\#26180481}{issues}
connecting outlets to Swift source code. To get around this, you can
change the delegate data type or assign the outlets in your code. In
your View Controller, follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Declare an outlet to hold a reference to the Screenlet. You can
  connect it in Interface Builder without any issues.

  \begin{figure}
  \centering
  \includegraphics{./images/screens-ios-xcode-add-screenlet-delegate.png}
  \caption{Connect the outlet with the Screenlet reference.}
  \end{figure}
\item
  Assign the Screenlet's delegate the \texttt{viewDidLoad} method. This
  is the connection typically done in Interface Builder.
\end{enumerate}

These steps are shown in the following code for Login Screenlet's View
Controller.

\begin{verbatim}
class ViewController: UIViewController, LoginScreenletDelegate {

    @IBOutlet var screenlet: LoginScreenlet?

    override func viewDidLoad() {
        super.viewDidLoad()
        self.screenlet?.delegate = self
    }

    ...
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/screens-ios-xcode-delegate.png}
\caption{Connect the Screenlet's delegate in Interface Builder.}
\end{figure}

Awesome! Now you know how to use Screenlets in your apps. If you need to
use Screenlets from Objective-C code, follow the instructions in the
next section.

\subsection{Using Screenlets from
Objective-C}\label{using-screenlets-from-objective-c}

If you want to invoke Screenlet classes from Objective-C code, there is
an additional header file that you must import. You can import the
header file \texttt{LiferayScreens-Swift.h} in all your Objective-C
files or configure a precompiler header file.

The first option involves adding the following import line all of your
Objective-C files:

\begin{verbatim}
#import "LiferayScreens-Swift.h"
\end{verbatim}

Alternatively, you can configure a precompiler header file by following
these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a precompiler header file (e.g., \texttt{PrefixHeader.pch}) and
  add it to your project.
\item
  Import \texttt{LiferayScreens-Swift.h} in the precompiler header file
  you just created.
\item
  Edit the following build settings of your target. Remember to replace
  \texttt{path/to/your/file/} with the path to your
  \texttt{PrefixHeader.pch} file:

  \begin{itemize}
  \tightlist
  \item
    Precompile Prefix Header: \texttt{Yes}
  \item
    Prefix Header: \texttt{path/to/your/file/PrefixHeader.pch}
  \end{itemize}

  \begin{figure}
  \centering
  \includegraphics{./images/screens-ios-xcode-prefix.png}
  \caption{The \texttt{PrefixHeader.pch} configuration in Xcode
  settings.}
  \end{figure}
\end{enumerate}

You can use the precompiler header file
\href{https://github.com/liferay/liferay-screens/blob/master/ios/Samples/Showcase-objc/LiferayScreens-Showcase-Objc/PrefixHeader.pch}{\texttt{PrefixHeader.pch}}
as a template.

Super! Now you know how to use Screenlets from Objective-C code in your
apps.

\subsection{Localizing Screenlets}\label{localizing-screenlets}

Follow Apple's
\href{https://developer.apple.com/library/ios/documentation/MacOSX/Conceptual/BPInternational/Introduction/Introduction.html}{standard
mechanism} to implement localization in your Screenlet. Note: even
though a Screenlet may support several languages, you must also support
those languages in your app. In other words, a Screenlet's support for a
language is only valid if your app supports that language. To support a
language, make sure to add it as a localization in your project's
settings.

\begin{figure}
\centering
\includegraphics{./images/screens-ios-xcode-localizations.png}
\caption{The Xcode localizations in the project's settings.}
\end{figure}

Way to go! You now know how to use Screenlets in your iOS apps.

\subsection{Related Topics}\label{related-topics-83}

\href{/docs/7-0/tutorials/-/knowledge_base/t/preparing-ios-projects-for-liferay-screens}{Preparing
iOS Projects for Liferay Screens}

\href{/docs/7-0/tutorials/-/knowledge_base/t/using-themes-in-ios-screenlets}{Using
Themes in iOS Screenlets}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-ios-screenlets}{Creating
iOS Screenlets}

\href{/docs/7-0/tutorials/-/knowledge_base/t/using-screenlets-in-android-apps}{Using
Screenlets in Android apps}

\section{Using Themes in iOS
Screenlets}\label{using-themes-in-ios-screenlets}

Using a Liferay Screens \emph{Theme}, you can set your Screenlet's UI
components, style, and behavior. They let you focus on a Screenlet's UI
and UX, without having to worry about its core functionality. Liferay's
Screenlets come with several Themes, and more are being developed by
Liferay and the community. A Liferay Screenlet's Themes are specified in
its
\href{/docs/7-0/reference/-/knowledge_base/r/screenlets-in-liferay-screens-for-ios}{reference
documentation}. This tutorial shows you how to use Themes in your iOS
Screenlets.

To install a Theme in your iOS app's Screenlet, you have two options,
depending on how the Theme has been published:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  If the Theme has been packaged as a CocoaPods pod dependency, you can
  install it by adding a line to your Podfile:

\begin{verbatim}
pod 'LiferayScreensThemeName'
\end{verbatim}

  Make sure to replace \texttt{LiferayScreensThemeName} with the Theme's
  CocoaPods project name.
\item
  If the Theme isn't available through CocoaPods, you can drag and drop
  the Theme's folder into your project. Liferay Screens detects the new
  classes and then applies the new design in the runtime and in
  Interface Builder.
\end{enumerate}

\begin{figure}
\centering
\includegraphics{./images/screens-ios-xcode-install-theme.png}
\caption{To install a Theme into an Xcode project, drag and drop the
Theme's folder into it.}
\end{figure}

To use the installed Theme, specify its name in the \emph{Theme Name}
property field of the \emph{Base Screenlet} in Interface Builder. The
names of each Screenlet's Themes are listed in the \emph{Themes} section
of the Screenlet's
\href{/docs/7-0/reference/-/knowledge_base/r/screenlets-in-liferay-screens-for-ios}{reference
documentation}. If you leave the Theme name property blank or enter a
name for a Theme that can't be found, the Screenlet's Default Theme is
used.

\begin{figure}
\centering
\includegraphics{./images/screens-ios-themes-property.png}
\caption{In Interface Builder, you specify a Screenlet's Theme by
entering its name in the \emph{Theme Name} field; this sets the
Screenlet's \texttt{themeName} property.}
\end{figure}

The initial release of Liferay Screens for iOS includes the following
Themes for its Screenlets:

\begin{itemize}
\tightlist
\item
  \emph{Default}: Comes standard with a Screenlet. It's used by a
  Screenlet if no Theme name is specified or the named Theme can't be
  found. The Default Theme can be used as the parent Theme for your
  custom Themes. Refer to the
  \href{/docs/7-0/tutorials/-/knowledge_base/t/architecture-of-liferay-screens-for-ios}{architecture
  tutorial} for more details.
\item
  \emph{Flat7}: Demonstrates a Theme made from scratch. Refer to the
  \href{/docs/7-0/tutorials/-/knowledge_base/t/creating-ios-themes}{Theme
  creation tutorial} for instructions on creating your own Theme.
\item
  \emph{Westeros}: Customizes the behavior and appearance of the
  \href{https://github.com/liferay/liferay-screens/tree/master/ios/Samples/WesterosBank}{Westeros
  Bank} demo app.
\end{itemize}

That's all there is to it! Great! Now you know how to use Themes to
dress up Screenlets in your iOS app. This opens up a world of
possibilities--like
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-ios-themes}{writing
your own Themes}.

\textbf{Related Topics}

\href{/docs/7-0/tutorials/-/knowledge_base/t/preparing-ios-projects-for-liferay-screens}{Preparing
iOS Projects for Liferay Screens}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-ios-themes}{Creating
iOS Themes}

\href{/docs/7-0/tutorials/-/knowledge_base/t/using-screenlets-in-ios-apps}{Using
Screenlets in iOS Apps}

\href{/docs/7-0/tutorials/-/knowledge_base/t/architecture-of-liferay-screens-for-ios}{Architecture
of Liferay Screens for iOS}

\href{/docs/7-0/tutorials/-/knowledge_base/t/using-views-in-android-screenlets}{Using
Views in Android Screenlets}

\section{Using Offline Mode in iOS}\label{using-offline-mode-in-ios}

Offline mode in Liferay Screens lets your apps function when
connectivity is unavailable or intermittent. Even though the steady
march of technology makes connections more stable and prevalent, there
are still plenty of places the Internet has trouble reaching. Areas with
complex terrain, including cities with large buildings, often lack
stable connections. Remote areas typically don't have connections at
all. Using Screens's offline mode in your apps gives your users
flexibility in these situations.

This tutorial shows you how to use offline mode in Screenlets. For an
explanation of how offline mode works, see the tutorial
\href{/docs/7-0/tutorials/-/knowledge_base/t/architecture-of-offline-mode-in-liferay-screens}{Architecture
of Offline Mode in Liferay Screens}. Offline mode's architecture is the
same on iOS and Android, although its use on these platforms differs.

\subsection{Configuring Screenlets for Offline
Mode}\label{configuring-screenlets-for-offline-mode-1}

If you want to enable the offline mode in any of your screenlets, you
must configure the attribute \texttt{offlinePolicy}. This attribute can
take four possible values. For a description of these values, see the
section
\href{/docs/7-0/tutorials/-/knowledge_base/t/architecture-of-offline-mode-in-liferay-screens\#using-policies-with-offline-mode}{Using
Policies with Offline Mode} in the offline mode architecture tutorial.
Note that each Screenlet behaves a bit differently with offline mode.
For specific details, see the
\href{/docs/7-0/reference/-/knowledge_base/r/screenlets-in-liferay-screens-for-ios}{Screenlet
reference documentation}.

\subsection{Handling Synchronization}\label{handling-synchronization-1}

Under some scenarios, values stored in the local cache need to be
synchronized with the portal. For that purpose you must use the
\texttt{SyncManager} class. This class is responsible for sending the
information stored in the local cache that hasn't been sent to the
portal yet.

Use the following steps to start a synchronization process:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create an instance of the \texttt{SyncManager} class. You must pass a
  \texttt{CacheManager} object in the constructor. You can get the
  current cache manager using
  \texttt{SessionContext.currentCacheManager}.
\item
  Set the delegate property. This delegate object receives the events
  produced in the synchronization process. For more details on the
  delegate's methods, see
  \href{/docs/7-0/reference/-/knowledge_base/r/syncmanagerdelegate}{the
  API reference documentation for the \texttt{SyncManagerDelegate}
  class}.
\item
  Make sure you keep a strong reference to the \texttt{SyncManager}
  object while the process is running.
\end{enumerate}

\subsection{Related Topics}\label{related-topics-84}

\href{/docs/7-0/tutorials/-/knowledge_base/t/architecture-of-offline-mode-in-liferay-screens}{Architecture
of Offline Mode in Liferay Screens}

\href{/docs/7-0/tutorials/-/knowledge_base/t/using-screenlets-in-ios-apps}{Using
Screenlets in iOS Apps}

\href{/docs/7-0/tutorials/-/knowledge_base/t/using-offline-mode-in-android}{Using
Offline Mode in Android}

\href{/docs/7-0/tutorials/-/knowledge_base/t/using-screenlets-in-android-apps}{Using
Screenlets in Android Apps}

\section{Architecture of Liferay Screens for
iOS}\label{architecture-of-liferay-screens-for-ios}

Liferay Screens separates its presentation and business-logic code using
ideas from
\href{http://en.wikipedia.org/wiki/Model-view-presenter}{Model View
Presenter},
\href{http://en.wikipedia.org/wiki/Model_View_ViewModel}{Model View
ViewModel}, and \href{http://www.objc.io/issue-13/viper.html}{VIPER}.
However, Screens isn't a canonical implementation of these architectures
because they're designed for apps. Screens isn't an app; it's a suite of
visual components intended for use \emph{in} apps.

This tutorial explains the architecture of Liferay Screens for iOS. It
begins with an overview of the high level components that make up the
system. This includes the Core, Screenlets, and Themes. These components
are then described in detail in the sections that follow. After you get
done examining Screens's building blocks, you'll be ready to create some
amazing Screenlets and Themes!

\subsection{High Level Architecture of Liferay Screens for
iOS}\label{high-level-architecture-of-liferay-screens-for-ios}

Liferay Screens for iOS is composed of a Core, a Screenlet layer, a View
layer, and Server Connectors. Server Connectors are technically part of
the Core, but are worth describing separately. They facilitate
interaction with local and remote data sources and communication between
the Screenlet layer and the
\href{/docs/7-0/tutorials/-/knowledge_base/t/mobile-sdk}{Liferay Mobile
SDK}.

\begin{figure}
\centering
\includegraphics{./images/screens-ios-architecture-01.png}
\caption{The high level components of Liferay Screens for iOS.}
\end{figure}

Each component is described below.

\textbf{Core:} includes all the base classes for developing other
Screens components. It's a micro-framework that lets developers write
their own Screenlets, views, and Server Connector classes.

\textbf{Screenlets:} Swift classes for inserting into any
\texttt{UIView}. They render a selected Theme in the runtime and in
Interface Builder. They also react to UI events to start server requests
(via Server Connectors), and define a set of \texttt{@IBInspectable}
properties that can be configured from Interface Builder. The Screenlets
bundled with Liferay Screens are known as the
\href{/docs/7-0/reference/-/knowledge_base/r/screenlets-in-liferay-screens-for-ios}{Screenlet
library}.

\textbf{Interactors:} implement specific use cases for communicating
with servers or any other data store. Interactors can use local and
remote data sources by using \emph{Server Connectors} or custom classes.
If a user action or use case needs to execute more than one query on a
local or remote store, the sequence is done in the corresponding
Interactor. If a Screenlet supports more than one user action or use
case, an Interactor must be created for each.

\textbf{Connectors} (or Server Connectors): a collection of classes that
can interact with local and remote data sources and Liferay instances.
Liferay's own set of Connectors, Liferay Connector, use the
\href{/docs/7-0/tutorials/-/knowledge_base/t/invoking-liferay-services-in-your-ios-app}{Liferay
Mobile SDK}. All Server Connectors can be run concurrently since they
use the
\href{https://developer.apple.com/library/mac/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationObjects/OperationObjects.html\#//apple_ref/doc/uid/TP40008091-CH101-SW1}{\texttt{NSOperation}
framework}. It's very easy to define priorities and dependencies between
Connectors, so you can build your own graph of Connectors (aka
operations) that can be resolved by the framework. Connectors are always
created using a
\href{https://en.wikipedia.org/wiki/Abstract_factory_pattern}{factory
class} so they can be injected by the app developer.

\textbf{Themes:} a set of XIB files and accompanying \texttt{UIView}
classes that present Screenlets to the user.

The next section describes the Core in detail.

\subsection{Core}\label{core}

The Core is the micro-framework that lets developers write Screenlets in
a structured and isolated way. All Screenlets share a common structure
based on the Core classes, but each Screenlet can have a unique purpose
and communication API.

\begin{figure}
\centering
\includegraphics{./images/screens-ios-architecture-02.png}
\caption{Here's the core layer of Liferay Screens for iOS.}
\end{figure}

From right to left, these are the main components:

\href{https://github.com/liferay/liferay-screens/blob/master/ios/Framework/Core/Base/BaseScreenletView.swift}{\textbf{BaseScreenletView}}:
the base class for all Screenlet View classes. Its child classes belong
to the Theme layer. View classes use standard XIB files to render a UI
and then update it when the data changes. The \texttt{BaseScreenletView}
class contains template methods that child classes may overwrite. When
developing your own Theme from a parent Theme, you can read the
Screenlet's properties or call its methods from this class. Any user
action in the UI is received in this class, and then redirected to the
Screenlet class.

\href{https://github.com/liferay/liferay-screens/blob/master/ios/Framework/Core/Base/BaseScreenlet.swift}{\textbf{BaseScreenlet}}:
the base class for all Screenlet classes. Screenlet classes receive UI
events through the \texttt{ScreenletView} class, then instantiate
Interactors to process and respond to that UI event. When the
Interactor's result is received, the \texttt{ScreenletView} (the UI) is
updated accordingly. The \texttt{BaseScreenlet} class contains a set of
\href{http://www.oodesign.com/template-method-pattern.html}{template
methods} that child classes may overwrite.

\href{https://github.com/liferay/liferay-screens/blob/master/ios/Framework/Core/Base/Interactor.swift}{\textbf{Interactor}}:
the base class for all Interactors that a Screenlet supports. The
Interactor class implements a specific use case supported by the
Screenlet. If the Screenlet supports several use cases, it needs
different Interactors. If the Interactor needs to retrieve remote data,
it uses a Server Connector to do so. When the Server Connector returns
the operation's result, the Interactor returns that result to the
Screenlet. The Screenlet then changes the \texttt{ScreenletView} (the
UI) status.

\href{https://github.com/liferay/liferay-screens/blob/master/ios/Framework/Core/Base/BaseConnectors/ServerConnector.swift}{\textbf{ServerConnector}}:
the base class for all Liferay Connectors that a Screenlet supports.
Connectors retrieve data asynchronously from local or remote data
sources. The Interactor classes instantiate and start these Connector
classes.

\href{https://github.com/liferay/liferay-screens/blob/master/ios/Framework/Core/Context/SessionContext.swift}{\textbf{SessionContext}}:
an object (typically a singleton) that holds the logged in user's
session. Apps can use an implicit login, invisible to the user, or a
login that relies on explicit user input to create the session. User
logins can be implemented with
\href{/docs/7-0/reference/-/knowledge_base/r/loginscreenlet-for-ios}{Login
Screenlet}. This is explained in detail
\href{/docs/7-0/tutorials/-/knowledge_base/t/accessing-the-liferay-session-in-ios}{here}.

\href{https://github.com/liferay/liferay-screens/blob/master/ios/Framework/Core/Context/LiferayServerContext.swift}{\textbf{LiferayServerContext}}:
a singleton object that holds server configuration parameters. It's
loaded from the \texttt{liferay-server-context.plist} file. Most
Screenlets use these parameters as default values.

Now that you know what the Core contains, you're ready to learn the
Screenlet layer's details.

\subsection{Screenlet Layer}\label{screenlet-layer-1}

The Screenlet layer contains the available Screenlets in Liferay Screens
for iOS. The following diagram shows the Screenlet layer in relation to
the Core, Interactor, Theme, and Connector layers. The Screenlet classes
in the diagram are explained in this section.

\begin{figure}
\centering
\includegraphics{./images/screens-ios-architecture-03.png}
\caption{This diagram illustrates the iOS Screenlet Layer's relationship
to other Screens components.}
\end{figure}

Screenlets are comprised of several Swift classes and an XIB file:

\textbf{MyScreenletViewModel:} a protocol that defines the attributes
shown in the UI. It typically accounts for all the input and output
values presented to the user. For example,
\href{https://github.com/liferay/liferay-screens/blob/master/ios/Framework/Core/Auth/LoginScreenlet/LoginViewModel.swift}{\texttt{LoginViewModel}}
includes attributes like the user name and password. A Connector can be
configured by reading and validating these values. Also, the Screenlet
can change these values based on any default values and operation
results.

\textbf{MyScreenlet:} a class that represents the Screenlet component
the app developer interacts with. It includes the following things:

\begin{itemize}
\tightlist
\item
  Inspectable parameters for configuring the Screenlet's behavior. The
  initial state can be set in the Screenlet's data.
\item
  A reference to the Screenlet's View, based on the selected Theme. To
  meet the Screenlet's requirements, all Themes must implement the
  \texttt{ViewModel} protocol.
\item
  Any number of methods for invoking Connectors. You can optionally make
  them public for app developers to call.\\
\item
  An optional (but recommended)
  \href{https://developer.apple.com/library/ios/documentation/general/conceptual/DevPedia-CocoaCore/Delegation.html}{delegate
  object} the Screenlet can call on for particular events.
\end{itemize}

\textbf{MyUserCaseInteractor:} Each Interactor runs the operations that
implement the use case. These can be local operations, remote
operations, or a combination thereof. Operations can be executed
sequentially or in parallel. The final results are stored in a
\texttt{result} object that can be read by the Screenlet when notified.
The number of Interactor classes a Screenlet requires depends on the
number of use cases it supports.

\textbf{MyOperationConnector:} This is related to the Interactor, but
has one or more Connectors. If the Server Connector is a back-end call,
then there's typically only a single request. Each Server Connector is
responsible for retrieving a set of related values. The results are
stored in a \texttt{result} object that can be read by the Interactor
when notified. The number of Server Connector classes an Interactor
requires depends on the number of endpoints you need to query, or even
the number of different servers you need to support. Connectors are
always created using a
\href{https://en.wikipedia.org/wiki/Abstract_factory_pattern}{factory
class}. You can therefore take advantage of
\href{https://en.wikipedia.org/wiki/Inversion_of_control}{Inversion of
Control}. This way, you can implement your own factory class to use to
create your own Connector objects. To tell Screens to use your factory
class, specify it in the \texttt{liferay-server-context.plist} file as
described
\href{/docs/7-0/tutorials/-/knowledge_base/t/preparing-ios-projects-for-liferay-screens\#configuring-communication-with-liferay}{in
the tutorial on preparing your iOS project for Screens}.

\textbf{MyScreenletView\_themeX:} A class that belongs to one specific
Theme. In the diagram, this Theme is \emph{ThemeX}. The class renders
the Screenlet's UI by using its related XIB file. The View object and
XIB file communicate using standard mechanisms like \texttt{@IBOutlet}
and \texttt{@IBAction}. When a user action occurs in the XIB file, it's
received by \texttt{BaseScreenletView} and then passed to the Screenlet
class via the \texttt{performAction} method. To identify different
events, the component's \texttt{restorationIdentifier} property is
passed to the \texttt{performAction} method.

\textbf{MyScreenletView\_themeX.xib:} an XIB file that specifies how to
render the Screenlet's View. Its name is very important. By convention,
a Screenlet with a view class named \emph{FooScreenletView} and a Theme
named \emph{BarTheme} must have an XIB file named
\texttt{FooScreenletView\_barTheme.xib}.

For more details, refer to the tutorial
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-ios-screenlets}{Creating
iOS Screenlets}. Next, the Theme Layer of Screens for iOS is described.

\subsection{Theme Layer}\label{theme-layer}

The Theme Layer lets developers set a Screenlet's look and feel. The
Screenlet property \texttt{themeName} determines the Theme to load. This
can be set by the Screenlet's \emph{Theme Name} field in Interface
Builder. A Theme consists of a view class for Screenlet behavior and an
XIB file for the UI. By inheriting one or more of these components from
another Theme, the different Theme \emph{types} allow varying levels of
control over a Screenlet's UI design and behavior.

\begin{figure}
\centering
\includegraphics{./images/screens-ios-architecture-04.png}
\caption{The Theme Layer of Liferay Screens for iOS.}
\end{figure}

There are several different Theme types:

\textbf{Default Theme:} The standard Theme provided by Liferay. It can
be used as a template to create other Themes, or as the parent Theme of
other Themes. Each Theme for each Screenlet requires a View class. A
Default Theme's View class is named \texttt{MyScreenletView\_default},
where \texttt{MyScreenlet} is the Screenlet's name. This class is
similar to the standard \texttt{ViewController} in iOS; it receives and
handles UI events by using the standard \texttt{@IBAction} and
\texttt{@IBOutlet}. The View class usually uses an XIB file to build the
UI components. This XIB file is bound to the class.

\textbf{Child Theme:} Presents the same UI components as the parent
Theme, but can change the UI components' appearance and position. A
Child Theme specifies visual changes in its own XIB file; it can't add
or remove any UI components. In the diagram, the Child Theme inherits
from the Default Theme. Creating a Child Theme is ideal when you only
need to make visual changes to an existing Theme. For example, you can
create a Child Theme that sets new positions and sizes for the standard
text boxes in Login Screenlet's Default Theme, but without adding or
overwriting existing code.

\textbf{Full:} Provides a complete standalone theme. It has no parent
Theme and implements unique behavior and appearance for a Screenlet. Its
View class must extend Screens's \texttt{BaseScreenletView} class and
conform to the Screenlet's view model protocol. It must also specify a
new UI in an XIB file. Refer to the
\href{https://github.com/liferay/liferay-screens/tree/master/ios/Framework/Themes/Default}{Default
Theme} for an example of a Full Theme.

\textbf{Extended:} Inherits the parent Theme's behavior and appearance,
but lets you change and add code to both. You can do so by creating a
new XIB file and a custom View class that extends the parent Theme's
View class. In the diagram, the Extended Theme inherits the Full Theme
and extends its Screenlet's View class. Refer to the
\href{https://github.com/liferay/liferay-screens/tree/master/ios/Framework/Themes/Flat7}{Flat7
Theme} for an example of an Extended Theme.

Themes in Liferay Screens are organized into sets that contain Themes
for several Screenlets. Liferay's available Theme sets are listed here:

\begin{itemize}
\item
  \href{https://github.com/liferay/liferay-screens/tree/master/ios/Framework/Themes/Default}{\emph{Default:}}
  A mandatory Theme set supplied by Liferay. It's used if the
  Screenlet's \texttt{themeName} isn't specified or is invalid. The
  Default Theme uses a neutral, flat white and blue design with standard
  UI components. For example, the
  \href{https://github.com/liferay/liferay-screens/tree/master/ios/Framework/Core/Auth/LoginScreenlet}{Login
  Screenlet} uses standard text boxes for the user name and password
  fields, but uses the Default Theme's flat white and blue design.
\item
  \href{https://github.com/liferay/liferay-screens/tree/master/ios/Framework/Themes/Flat7}{\emph{Flat7:}}
  A collection of Themes that use a flat black and green design, and UI
  components with rounded edges. They're Extended Themes.
\item
  \href{https://github.com/liferay/liferay-screens/tree/master/ios/Samples/WesterosBank/Theme}{\emph{Westeros:}}
  The Theme for the
  \href{https://github.com/liferay/liferay-screens/tree/master/ios/Samples/WesterosBank/App}{Bank
  of Westeros} sample app.
\end{itemize}

For more details on Theme creation, see the tutorial
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-ios-themes}{Creating
iOS Themes}.

Awesome! Now you know the nitty gritty details of Liferay Screens for
iOS. This information is invaluable when using Screens to develop your
apps.

\subsection{Related Topics}\label{related-topics-85}

\href{/docs/7-0/tutorials/-/knowledge_base/t/using-screenlets-in-ios-apps}{Using
Screenlets in iOS Apps}

\href{/docs/7-0/tutorials/-/knowledge_base/t/using-themes-in-ios-screenlets}{Using
Themes in iOS Screenlets}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-ios-screenlets}{Creating
iOS Screenlets}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-ios-themes}{Creating
iOS Themes}

\section{Creating iOS Screenlets}\label{creating-ios-screenlets}

The built-in
\href{/docs/7-0/reference/-/knowledge_base/r/screenlets-in-liferay-screens-for-ios}{Screenlets}
cover common use cases for mobile apps that use Liferay. They
authenticate users, interact with Dynamic Data Lists, display assets,
and more. What if, however, there's no Screenlet for \emph{your} use
case? No problem! You can create your own. Extensibility is a key
strength of Liferay Screens.

This tutorial explains how to create your own Screenlets. As an example,
it references code from the sample
\href{https://github.com/liferay/liferay-screens/tree/master/ios/Samples/Bookmark}{Add
Bookmark Screenlet}, that saves bookmarks to Liferay's Bookmarks
portlet.

In general, you use the following steps to create Screenlets:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Plan Your Screenlet: Your Screenlet's features and use cases determine
  where you'll create it and the Liferay remote services you'll call.
\item
  Create Your Screenlet's UI (its Theme): Although this tutorial
  presents all the information you need to create a Theme for your
  Screenlet, you may first want to learn the steps for
  \href{/docs/7-0/tutorials/-/knowledge_base/t/creating-ios-themes}{creating
  a Theme}. For more information on Themes in general, see
  \href{/docs/7-0/tutorials/-/knowledge_base/t/using-themes-in-ios-screenlets}{the
  tutorial on using Themes with Screenlets}.
\item
  Create the Screenlet's Interactor. Interactors are Screenlet
  components that make server calls.
\item
  Create the Screenlet class. The Screenlet class is the Screenlet's
  central component. It controls the Screenlet's behavior and is the
  component the app developer interacts with when inserting a Screenlet.
\end{enumerate}

Before getting started, make sure that you're familiar with the
architecture of Liferay Screens.
\href{/docs/7-0/tutorials/-/knowledge_base/t/architecture-of-liferay-screens-for-ios}{Click
here} to read the Screens architecture tutorial.

Without further ado, let the Screenlet creation begin!

\subsection{Planning Your Screenlet}\label{planning-your-screenlet}

Before creating your Screenlet, you must determine what it needs to do
and how you want developers to use it. This determines where you'll
create your Screenlet and its functionality.

Where you should create your Screenlet depends on how you plan to use
it. If you want to reuse or redistribute it, you should create it in an
empty Cocoa Touch Framework project in Xcode. You can then use CocoaPods
to publish it. The tutorial
\href{/docs/7-0/tutorials/-/knowledge_base/t/packaging-ios-themes}{Packaging
iOS Themes} explains how to publish an iOS Screenlet. Even though that
tutorial refers to Themes, the steps for preparing Screenlets for
publication are the same. If you don't plan to reuse or redistribute
your Screenlet, create it in your app's Xcode project.

You must also determine your Screenlet's functionality and what data
your Screenlet requires. This determines the actions your Screenlet must
support and the Liferay remote services it must call. For example, Add
Bookmark Screenlet only needs to respond to one action: adding a
bookmark to Liferay's Bookmarks portlet. To add a bookmark, this
Screenlet must call the Liferay instance's \texttt{add-entry} service
for \texttt{BookmarksEntry}. If you're running a Liferay instance
locally on port 8080,
\href{http://localhost:8080/api/jsonws?contextName=bookmarks&signature=\%2Fbookmarks.bookmarksentry\%2Fadd-entry-6-groupId-folderId-name-url-description-serviceContext}{click
here} to see this service. To add a bookmark, this service requires the
following parameters:

\begin{itemize}
\item
  \texttt{groupId}: The site ID in the Liferay instance that contains
  the Bookmarks portlet.
\item
  \texttt{folderId}: The folder ID in the Bookmarks portlet that
  receives the new bookmark.
\item
  \texttt{name}: The new bookmark's title.
\item
  \texttt{url}: The new bookmark's URL.
\item
  \texttt{description}: The new bookmark's description.
\item
  \texttt{serviceContext}: A
  \href{/docs/7-0/tutorials/-/knowledge_base/t/understanding-servicecontext}{Liferay
  \texttt{ServiceContext}} object.
\end{itemize}

Add Bookmark Screenlet must therefore account for each of these
parameters. When saving a bookmark, the Screenlet asks the user to enter
the bookmark's URL and name. The user isn't required, however, to enter
any other parameters. This is because the app developer sets the
\texttt{groupId} and \texttt{folderId} via the app's code. Also, the
Screenlet's code automatically populates the \texttt{description} and
\texttt{serviceContext}.

Great! Now you're ready to create your Screenlet's Theme!

\subsection{Creating the Screenlet's
UI}\label{creating-the-screenlets-ui-1}

In Liferay Screens for iOS, a Screenlet's UI is called a Theme. Every
Screenlet must have at least one Theme. A Theme has the following
components:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  An XIB file: defines the UI components that the Theme presents to the
  end user.
\item
  A View class: renders the UI, handles user interactions, and
  communicates with the Screenlet class.
\end{enumerate}

First, create a new XIB file and use Interface Builder to construct your
Screenlet's UI. In many cases, the Screenlet's actions must be triggered
from the Theme. To achieve this, make sure to use a
\texttt{restorationIdentifier} property to assign a unique ID to each UI
component that triggers an action. The user triggers the action by
interacting with the UI component. If the action only changes the UI's
state (that is, changes the UI component's properties), then you can
associate that component's event to an \texttt{IBAction} method as
usual. Actions using \texttt{restorationIdentifier} are intended for use
by actions that need an Interactor, such as actions that make server
requests or retrieve data from a database.

For example, Add Bookmark Screenlet's UI needs text boxes for entering a
bookmark's URL and title. This UI also needs a button to support the
Screenlet's action: sending the bookmark to a Liferay instance. The
\href{https://github.com/liferay/liferay-screens/tree/master/ios/Samples/Bookmark/AddBookmarkScreenlet/Basic/Themes/AddBookmarkView_default.xib}{XIB
file \texttt{AddBookmarkView\_default.xib}} defines this UI. Because the
button triggers the Screenlet's action, it contains
\texttt{restorationIdentifier="add-bookmark"}.

\begin{figure}
\centering
\includegraphics{./images/screens-ios-xcode-add-bookmark.png}
\caption{Here's the sample Add Bookmark Screenlet's XIB file rendered in
Interface Builder.}
\end{figure}

\noindent\hrulefill

\textbf{Note:} The Screenlet in this tutorial doesn't support multiple
Themes. If you want your Screenlet to support multiple Themes, your View
class must also conform a \emph{View Model} protocol that you create.
For instructions on this, see the tutorial
\href{/docs/7-0/tutorials/-/knowledge_base/t/supporting-multiple-themes-in-your-screenlet}{Supporting
Multiple Themes in Your Screenlet}.

\noindent\hrulefill

Now you must create your Screenlet's View class. This class controls the
UI you just defined. In the
\href{https://github.com/liferay/liferay-screens/blob/master/ios/Framework/Core/Base/BaseScreenletView.swift}{\texttt{BaseScreenletView}
class}, Screens provides the default functionality required by all View
classes. Your View class must therefore extend
\texttt{BaseScreenletView} to provide the functionality unique to your
Screenlet. To support your UI, use standard \texttt{@IBOutlet}s and
\texttt{@IBAction}s to connect all your XIB's UI components and events
to your View class. You should also implement getters and setters to get
values from and set values to the UI components. Your View class should
also implement any required animations or front-end logic.

For example,
\href{https://github.com/liferay/liferay-screens/tree/master/ios/Samples/Bookmark/AddBookmarkScreenlet/Basic/Themes/AddBookmarkView_default.swift}{\texttt{AddBookmarkView\_default}}
is Add Bookmark Screenlet's View class. This class extends
\texttt{BaseScreenletView} and contains \texttt{@IBOutlet} references to
the XIB's text fields. The getters for these references let the Theme
retrieve the data the user enters into the corresponding text field:

\begin{verbatim}
import UIKit
import LiferayScreens

class AddBookmarkView_default: BaseScreenletView {

   @IBOutlet weak var URLTextField: UITextField?
   @IBOutlet weak var titleTextField: UITextField?

   var URL: String? {
       return URLTextField?.text
   }

   var title: String? {
       return titleTextField?.text
   }
}
\end{verbatim}

In Interface Builder, you must now specify your View class as your XIB
file's custom class. In Add Bookmark Screenlet, for example,
\texttt{AddBookmarkView\_default} is set as the
\texttt{AddBookmarkView\_default.xib} file's custom class in Interface
Builder.

If you're using CocoaPods, make sure to explicitly set a valid module
for the custom class--the grayed-out \emph{Current} default value only
suggests a module.

\begin{figure}
\centering
\includegraphics{./images/screens-ios-theme-custom-module-wrong.png}
\caption{In this XIB file, the custom class's module is NOT specified.}
\end{figure}

\begin{figure}
\centering
\includegraphics{./images/screens-ios-theme-custom-module-right.png}
\caption{The XIB file is bound to the custom class name, with the
specified module.}
\end{figure}

Next, you'll create your Screenlet's Interactor.

\subsection{Creating the Interactor}\label{creating-the-interactor-2}

Create an Interactor class for each of your Screenlet's actions. In the
\href{https://github.com/liferay/liferay-screens/blob/master/ios/Framework/Core/Base/Interactor.swift}{\texttt{Interactor}
class}, Screens provides the default functionality required by all
Interactor classes. Your Interactor class must therefore extend
\texttt{Interactor} to provide the functionality unique to your
Screenlet.

\noindent\hrulefill

\textbf{Note:} You may wish to make your server call in a Connector
instead of an Interactor. Doing so provides an additional abstraction
layer for your server call, leaving your Interactor to instantiate your
Connector and receive its results. For instructions on this, see the
tutorial
\href{/docs/7-0/tutorials/-/knowledge_base/t/create-and-use-a-connector-with-your-screenlet}{Create
and Use a Connector with Your Screenlet}.

\noindent\hrulefill

Interactors work synchronously, but you can use callbacks (delegates) or
Connectors to run their operations in the background. For example, the
Liferay Mobile SDK provides the
\href{https://github.com/liferay/liferay-mobile-sdk/blob/master/ios/Source/Core/LRCallback.h}{\texttt{LRCallback}
protocol} for this purpose. This is described in
\href{/docs/7-0/tutorials/-/knowledge_base/t/invoking-services-asynchronously-from-your-ios-app}{the
Mobile SDK tutorial on invoking Liferay services asynchronously}.
Screens bridges this protocol to make it available in Swift. Your
Interactor class can conform this protocol to make its server calls
asynchronously. To implement an Interactor class:

\begin{itemize}
\tightlist
\item
  Your initializer must receive all required properties and a reference
  to the Screenlet.
\item
  Override \texttt{Interactor}'s \texttt{start} method to perform the
  server operations your Screenlet requires (e.g., invoke a Liferay
  operation via a Liferay Mobile SDK service).
\item
  Save the server response to an accessible property, if necessary. For
  example, if the server call returns objects from a Liferay instance,
  you should store these objects in an accessible property. This way
  your Screenlet can display those results to the user.
\item
  You must invoke the methods \texttt{callOnSuccess} and
  \texttt{callOnFailure} to execute the closures \texttt{onSuccess} and
  \texttt{onFailure}, respectively.
\end{itemize}

For example, the sample Add Bookmark Screenlet's Interactor class
\href{https://github.com/liferay/liferay-screens/tree/master/ios/Samples/Bookmark/AddBookmarkScreenlet/Basic/Interactor/AddBookmarkInteractor.swift}{\texttt{AddBookmarkInteractor}}
makes the server call that adds a bookmark to a Liferay instance. This
class extends the \texttt{Interactor} class and conforms the
\texttt{LRCallback} protocol. The latter ensures that the Interactor's
server call runs asynchronously:

\begin{verbatim}
public class AddBookmarkInteractor: Interactor, LRCallback {...
\end{verbatim}

To save the server call's results, \texttt{AddBookmarkInteractor}
defines the public variable \texttt{resultBookmarkInfo}. This class also
defines public constants for the bookmark's folder ID, title, and URL.
The initializer sets these variables and calls \texttt{Interactor}'s
constructor with a reference to the base Screenlet class
(\texttt{BaseScreenlet}):

\begin{verbatim}
public var resultBookmarkInfo: [String:AnyObject]?
public let folderId: Int64
public let title: String
public let url: String

public init(screenlet: BaseScreenlet, folderId: Int64, title: String, url: String) {
    self.folderId = folderId
    self.title = title
    self.url = url
    super.init(screenlet: screenlet)
}
\end{verbatim}

The \texttt{AddBookmarkInteractor} class's \texttt{start} method makes
the server call. To do so, it must first get a \texttt{Session}. Since
Login Screenlet creates a session automatically upon successful login,
the \texttt{start} method retrieves this session with
\texttt{SessionContext.createSessionFromCurrentSession()}. To make the
server call asynchronously, the \texttt{start} method must set a
callback to this session. Because \texttt{AddBookmarkInteractor}
conforms the \texttt{LRCallback} protocol, setting \texttt{self} as the
session's callback accomplishes this. The \texttt{start} method must
then create a \texttt{LRBookmarksEntryService\_v7} instance and call
this instance's \texttt{addEntryWithGroupId} method. The latter method
calls a Liferay instance's \texttt{add-entry} service for
\texttt{BookmarksEntry}. The \texttt{start} method therefore provides
the \texttt{groupId}, \texttt{folderId}, \texttt{name}, \texttt{url},
\texttt{description}, and \texttt{serviceContext} arguments to
\texttt{addEntryWithGroupId}. Note that this example provides a
hard-coded string for the \texttt{description}. Also, the
\texttt{serviceContext} is \texttt{nil} because the Mobile SDK handles
the \texttt{ServiceContext} object for you:

\begin{verbatim}
override public func start() -> Bool {
    let session = SessionContext.createSessionFromCurrentSession()
    session?.callback = self

    let service = LRBookmarksEntryService_v7(session: session)

    do {
        try service.addEntryWithGroupId(LiferayServerContext.groupId,
                        folderId: folderId,
                        name: title,
                        url: url,
                        description: "Added from Liferay Screens",
                        serviceContext: nil)

        return true
    }
    catch {
        return false
    }
}
\end{verbatim}

Finally, the \texttt{AddBookmarkInteractor} class must conform the
\texttt{LRCallback} protocol by implementing the \texttt{onFailure} and
\texttt{onSuccess} methods. The \texttt{onFailure} method communicates
the \texttt{NSError} object that results from a failed server call. It
does this by calling the base \texttt{Interactor} class's
\texttt{callOnFailure} method with the error. When the server call
succeeds, the \texttt{onSuccess} method sets the server call's results
(the \texttt{result} argument) to the \texttt{resultBookmarkInfo}
variable. The \texttt{onSuccess} method finishes by calling the base
\texttt{Interactor} class's \texttt{callOnSuccess} method to communicate
the success status throughout the Screenlet:

\begin{verbatim}
public func onFailure(error: NSError!) {
    self.callOnFailure(error)
}

public func onSuccess(result: AnyObject!) {
    //Save result bookmark info
    resultBookmarkInfo = (result as! [String:AnyObject])

    self.callOnSuccess()
}
\end{verbatim}

Next, you'll create the Screenlet class.

\subsection{Creating the Screenlet
Class}\label{creating-the-screenlet-class-5}

The Screenlet class is the central hub of a Screenlet. It contains the
Screenlet's properties, a reference to the Screenlet's View class,
methods for invoking Interactor operations, and more. When using a
Screenlet, app developers primarily interact with its Screenlet class.
In other words, if a Screenlet were to become self-aware, it would
happen in its Screenlet class (though we're reasonably confident this
won't happen).

\href{https://github.com/liferay/liferay-screens/blob/master/ios/Framework/Core/Base/BaseScreenlet.swift}{Screens's
\texttt{BaseScreenlet} class} is a base Screenlet class implementation.
Since \texttt{BaseScreenlet} provides most of a Screenlet class's
required functionality, your Screenlet class should extend
\texttt{BaseScreenlet}. This lets you focus on your Screenlet's unique
functionality. Your Screenlet class must also include any
\texttt{@IBInspectable} properties your Screenlet requires and a
reference to your Screenlet's View class. To perform your Screenlet's
action, your Screenlet class must override \texttt{BaseScreenlet}'s
\texttt{createInteractor} method. This method should create an instance
of your Interactor and then set the Interactor's \texttt{onSuccess} and
\texttt{onFailure} closures to define what happens when the server call
succeeds or fails, respectively.

For example, the
\href{https://github.com/liferay/liferay-screens/blob/master/ios/Samples/Bookmark/AddBookmarkScreenlet/Basic/AddBookmarkScreenlet.swift}{\texttt{AddBookmarkScreenlet}
class} is the Screenlet class in Add Bookmark Screenlet. This class
extends \texttt{BaseScreenlet} and contains an \texttt{@IBInspectable}
variable for the bookmark folder's ID (\texttt{folderId}). The
\texttt{AddBookmarkScreenlet} class's \texttt{createInteractor} method
first gets a reference to the View class
(\texttt{AddBookmarkView\_default}). It then creates an
\texttt{AddBookmarkInteractor} instance with this Screenlet class
(\texttt{self}), the \texttt{folderId}, the bookmark's title, and the
bookmark's URL. Note that the View class reference contains the bookmark
title and URL that the user entered into the UI. The
\texttt{createInteractor} method then sets the Interactor's
\texttt{onSuccess} closure to print a success message when the server
call succeeds. Likewise, the Interactor's \texttt{onFailure} closure is
set to print an error message when the server call fails. Note that
you're not restricted to only printing messages here: you should set
these closures to do whatever is best for your Screenlet. The
\texttt{createInteractor} method finishes by returning the Interactor
instance. Here's the complete \texttt{AddBookmarkScreenlet} class:

\begin{verbatim}
import UIKit
import LiferayScreens


public class AddBookmarkScreenlet: BaseScreenlet {

    //MARK: Inspectables

    @IBInspectable var folderId: Int64 = 0

    //MARK: BaseScreenlet

    override public func createInteractor(name name: String?, sender: AnyObject?) -> Interactor? {

        let view = self.screenletView as! AddBookmarkView_default

        let interactor = AddBookmarkInteractor(screenlet: self,
                                           folderId: folderId,
                                           title: view.title!,
                                           url: view.URL!)

        //Called when the Interactor's server call finishes succesfully
        interactor.onSuccess = {
            let bookmarkName = interactor.resultBookmarkInfo!["name"] as! String
            print("Bookmark \"\(bookmarkName)\" saved!")
        }

        //Called when the Interactor's server call fails
        interactor.onFailure = { _ in
            print("An error occurred saving the bookmark")
        }

        return interactor
    }

}
\end{verbatim}

For reference, the sample Add Bookmark Screenlet's final code is
\href{https://github.com/liferay/liferay-screens/tree/master/ios/Samples/Bookmark/AddBookmarkScreenlet/Basic/AddBookmarkScreenlet.swift}{here
on GitHub}.

You're done! Your Screenlet is a ready-to-use component that you can add
to your storyboard. You can even
\href{/docs/7-0/tutorials/-/knowledge_base/t/packaging-ios-themes}{package
it} to contribute to the Screens project or distribute it with
CocoaPods. Now you know how to create iOS Screenlets!

\subsection{Related Topics}\label{related-topics-86}

\href{/docs/7-0/tutorials/-/knowledge_base/t/supporting-multiple-themes-in-your-screenlet}{Supporting
Multiple Themes in Your Screenlet}

\href{/docs/7-0/tutorials/-/knowledge_base/t/adding-screenlet-actions}{Adding
Screenlet Actions}

\href{/docs/7-0/tutorials/-/knowledge_base/t/create-and-use-a-connector-with-your-screenlet}{Create
and Use a Connector with Your Screenlet}

\href{/docs/7-0/tutorials/-/knowledge_base/t/add-a-screenlet-delegate}{Add
a Screenlet Delegate}

\href{/docs/7-0/tutorials/-/knowledge_base/t/using-and-creating-progress-presenters}{Using
and Creating Progress Presenters}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-and-using-your-screenlets-model-class}{Creating
and Using Your Screenlet's Model Class}

\href{/docs/7-0/tutorials/-/knowledge_base/t/using-screenlets-in-ios-apps}{Using
Screenlets in iOS Apps}

\href{/docs/7-0/tutorials/-/knowledge_base/t/architecture-of-liferay-screens-for-ios}{Architecture
of Liferay Screens for iOS}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-ios-themes}{Creating
iOS Themes}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-android-screenlets}{Creating
Android Screenlets}

\section{Supporting Multiple Themes in Your
Screenlet}\label{supporting-multiple-themes-in-your-screenlet}

Themes let you present the same Screenlet with a different look and
feel. For example, if you have multiple apps that use the same
Screenlet, you can use different Themes to match the Screenlet's
appearance to each app's style. Each Screenlet that comes with Liferay
Screens supports the use of multiple Themes. For your custom Screenlet
to support different Themes, however, it must contain a \emph{View
Model} protocol. A View Model abstracts the Theme used to display the
Screenlet, thus letting developers use other Themes. For example, note
that the Screenlet class's \texttt{createInteractor} method in
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-ios-screenlets}{the
Screenlet creation tutorial} accesses the View class
(\texttt{AddBookmarkView\_default}) directly when getting a reference to
the View class:

\begin{verbatim}
let view = self.screenletView as! AddBookmarkView_default
\end{verbatim}

This is all fine and well, except it hard codes the Theme defined by
\texttt{AddBookmarkView\_default}! To use a different Theme, you'd have
to rewrite this line of code to use that Theme's View class. This isn't
very flexible! Instead of making your Screenlet take expensive yoga
classes, you can abstract the Theme's View class via a View Model
protocol.

This tutorial shows you how to add a View Model to your Screenlet. The
Add Bookmark Screenlet created in
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-ios-screenlets}{the
Screenlet creation tutorial} is used as an example. Note that you can
also follow these steps to add a View Model while creating your
Screenlet.

\subsection{Creating and Using a View
Model}\label{creating-and-using-a-view-model}

Follow these steps to add and use a View Model in your Screenlet:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a View Model protocol that defines your Screenlet's attributes.
  These attributes are the View class properties your Screenlet class
  uses. For example, the
  \href{https://github.com/liferay/liferay-screens/blob/develop/ios/Samples/Bookmark/AddBookmarkScreenlet/Basic/AddBookmarkScreenlet.swift}{Screenlet
  class in Add Bookmark Screenlet} uses the View class properties
  \texttt{title} and \texttt{URL}. Add Bookmark Screenlet's View Model
  protocol (\texttt{AddBookmarkViewModel}) must therefore define
  variables for these properties:

\begin{verbatim}
 import UIKit

 @objc protocol AddBookmarkViewModel {

     var URL: String? {get}

     var title: String? {get}

 }
\end{verbatim}
\item
  Conform your View class to your Screenlet's View Model protocol. Make
  sure to get/set all the protocol's properties. For example, here's Add
  Bookmark Screenlet's View Class (\texttt{AddBookmarkView\_default})
  conformed to \texttt{AddBookmarkViewModel}:

\begin{verbatim}
 import UIKit
 import LiferayScreens

 class AddBookmarkView_default: BaseScreenletView, AddBookmarkViewModel {

     @IBOutlet weak var URLTextField: UITextField?
     @IBOutlet weak var titleTextField: UITextField?

     var URL: String? {
         return URLTextField?.text
     }

     var title: String? {
         return titleTextField?.text
     }

 }
\end{verbatim}
\item
  Create and use a View Model reference in your Screenlet class. By
  retrieving data from this reference instead of a direct View class
  reference, you can use your Screenlet with other Themes. For example,
  here's the \texttt{AddBookmarkScreenlet} class with a
  \texttt{viewModel} property instead of a direct reference to
  \texttt{AddBookmarkView\_default}. This class's
  \texttt{createInteractor} method then uses this property to get the
  \texttt{title} and \texttt{URL} properties in the
  \texttt{AddBookmarkInteractor} constructor:

\begin{verbatim}
 ...
 //View Model reference
 var viewModel: AddBookmarkViewModel {
     return self.screenletView as! AddBookmarkViewModel
 }

 override public func createInteractor(name name: String?, sender: AnyObject?) -> Interactor? {

     let interactor = AddBookmarkInteractor(screenlet: self,
                                            folderId: folderId,
                                            title: viewModel.title!,
                                            url: viewModel.URL!)

     // Called when the Interactor finishes succesfully
     interactor.onSuccess = {
         let bookmarkName = interactor.resultBookmarkInfo!["name"] as! String
         print("Bookmark \"\(bookmarkName)\" saved!")
     }

     // Called when the Interactor finishes with an error
     interactor.onFailure = { _ in
         print("An error occurred saving the bookmark")
     }

     return interactor
 }
 ...
\end{verbatim}
\end{enumerate}

That's it! Now your Screenlet is ready to use other Themes that you
create for it. See the tutorial
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-ios-themes}{Creating
iOS Themes} for instructions on creating a Theme.

\subsection{Related Topics}\label{related-topics-87}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-ios-themes}{Creating
iOS Themes}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-ios-screenlets}{Creating
iOS Screenlets}

\href{/docs/7-0/tutorials/-/knowledge_base/t/architecture-of-liferay-screens-for-ios}{Architecture
of Liferay Screens for iOS}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-ios-list-screenlets}{Creating
iOS List Screenlets}

\section{Adding Screenlet Actions}\label{adding-screenlet-actions}

With multiple Interactors, it's possible for a Screenlet to have
multiple actions. You must create an Interactor class for each action.
For example, if your Screenlet needs to make two server calls, then you
need two Interactors: one for each call. Your Screenlet class's
\texttt{createInteractor} method must return an instance of each
Interactor. Also, recall that each action name is given by the
\texttt{restorationIdentifier} of the UI components that trigger them.
You should set this \texttt{restorationIdentifier} to a constant in your
Screenlet.

This tutorial walks you through the steps necessary to add an action to
your Screenlet, and trigger an action programmatically. As an example,
this tutorial uses the
\href{https://github.com/liferay/liferay-screens/tree/master/ios/Samples/Bookmark/AddBookmarkScreenlet/Advanced}{advanced
version of the sample Add Bookmark Screenlet}. This Screenlet is similar
to the sample Add Bookmark Screenlet created in
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-ios-screenlets}{the
Screenlet creation tutorial}. The advanced Add Bookmark Screenlet,
however, contains two actions:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add Bookmark: Adds a bookmark to the Bookmarks portlet in a Liferay
  DXP installation. This is the Screenlet's main action, created in
  \href{/docs/7-0/tutorials/-/knowledge_base/t/creating-ios-screenlets}{the
  Screenlet creation tutorial}.
\item
  Get Title: Retrieves the title from a bookmark URL entered by the
  user. This tutorial shows you how to implement this action.
\end{enumerate}

Note that this tutorial doesn't explain Screenlet creation in general.
Before proceeding, make sure you've read
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-ios-screenlets}{the
Screenlet creation tutorial}. And without any further ado, it's time to
implement your Screenlet's action!

\subsection{Implementing Your Action}\label{implementing-your-action}

Use the following steps to add an action to your your Screenlet:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a constant in your Screenlet class for each of your Screenlet's
  actions. For example, here are the constants in Add Bookmark
  Screenlet's Screenlet class (\texttt{AddBookmarkScreenlet}):

\begin{verbatim}
 static let AddBookmarkAction = "add-bookmark"
 static let GetTitleAction = "get-title"
\end{verbatim}
\item
  In your Theme's XIB file, add any new UI components that you need to
  perform the action. For example, Add Boookmark Screenlet's XIB file
  needs a new button for getting the URL's title:

  \begin{figure}
  \centering
  \includegraphics{./images/screens-ios-xcode-add-bookmark-advanced.png}
  \caption{The sample Add Bookmark Screenlet's XIB file contains a new
  button next to the \emph{Title} field for retrieving the URL's title.}
  \end{figure}
\item
  Wire the UI components in your XIB file to your View class. In your
  View class, you must also register the events you want to react to
  (e.g., button clicks). The
  \href{https://github.com/liferay/liferay-screens/blob/master/ios/Framework/Core/Base/BaseScreenletView.swift}{\texttt{BaseScreenletView}
  class} contains a set of \texttt{userAction} methods that you can call
  in your View class to perform actions programmatically. For example,
  it's possible to trigger Add Bookmark Screenlet's
  \texttt{GetTitleAction} automatically whenever the user leaves the
  \texttt{URLTextField}. Since \texttt{BaseScreenletView} is the
  delegate for all \texttt{UITextField} objects by default, this is done
  in the View class (\texttt{AddBookmarkView\_default}) by implementing
  the
  \href{https://developer.apple.com/reference/uikit/uitextfielddelegate/1619591-textfielddidendediting}{\texttt{textFieldDidEndEditing}
  method} to call the \texttt{userAction} method with the action name:

\begin{verbatim}
 func textFieldDidEndEditing(textField: UITextField) {
     if textField == URLTextField {
         userAction(name: AddBookmarkScreenlet.GetTitleAction)
     }
 }
\end{verbatim}
\item
  Update your View class or View Model protocol to account for the new
  action. For example, Add Bookmark Screenlet contains a View Model
  (\texttt{AddBookmarkViewModel}) so it can
  \href{/docs/7-0/tutorials/-/knowledge_base/t/supporting-multiple-themes-in-your-screenlet}{support
  multiple Themes}. This View Model must allow the new action to set its
  \texttt{title} variable:

\begin{verbatim}
 import UIKit

 @objc protocol AddBookmarkViewModel {
     var URL: String? {get}
     var title: String? {set get}
 }
\end{verbatim}
\item
  If your Screenlet uses a View Model, conform your View class to the
  updated View Model. For example, the \texttt{title} variable in Add
  Bookmark Screenlet's View class (\texttt{AddBookmarkView\_default})
  must implement the setter from the previous step:

\begin{verbatim}
 var title: String? {
     get {
         return titleTextField?.text
     }
     set {
         self.titleTextField?.text = newValue
     }
 }
\end{verbatim}
\item
  Create a new Interactor class for the new action. To do this, use the
  same steps detailed in the
  \href{/docs/7-0/tutorials/-/knowledge_base/t/creating-ios-screenlets\#creating-the-interactor}{Screenlet
  creation tutorial}. For example, here's the Interactor class for Add
  Bookmark Screenlet's Get Title action:

\begin{verbatim}
 import UIKit
 import LiferayScreens


 public class GetWebTitleInteractor: Interactor {

     public var resultTitle: String?

     var url: String

     //MARK: Initializer

     public init(screenlet: BaseScreenlet, url: String) {
         self.url = url
         super.init(screenlet: screenlet)
     }

     override public func start() -> Bool {
         if let URL = NSURL(string: url) {

             // Use the NSURLSession class to retrieve the HTML
             NSURLSession.sharedSession().dataTaskWithURL(URL) {
                     (data, response, error) in

                 if let errorValue = error {
                     self.callOnFailure(errorValue)
                 }
                 else {
                     if let data = data, html = NSString(data: data, encoding: NSUTF8StringEncoding) {
                         self.resultTitle = self.parseTitle(html)
                     }

                     self.callOnSuccess()
                 }
             }.resume()

             return true
         }

         return false
     }

     // Parse the title from a webpage HTML
     private func parseTitle(html: NSString) -> String {
         let range1 = html.rangeOfString("<title>")
         let range2 = html.rangeOfString("</title>")

         let start = range1.location + range1.length

         return html.substringWithRange(NSMakeRange(start, range2.location - start))
     }

 }
\end{verbatim}
\item
  Update your Screenlet class's \texttt{createInteractor} method so it
  returns the correct Interactor for each action. For example, the
  \texttt{createInteractor} method in Add Bookmark Screenlet's Screenlet
  class (\texttt{AddBookmarkScreenlet}) contains a \texttt{switch}
  statement that returns an \texttt{AddBookmarkInteractor} or
  \texttt{GetWebTitleInteractor} instance when the Add Bookmark or Get
  Title action is called, respectively. Note that the
  \texttt{createAddBookmarkInteractor()} and
  \texttt{createGetTitleInteractor()} methods create these instances.
  Although you don't have to create your Interactor instances in
  separate methods, doing so leads to cleaner code:

\begin{verbatim}
 ... 
 override public func createInteractor(name name: String, sender: AnyObject?) 
     -> Interactor? {
         switch name {
         case AddBookmarkScreenlet.AddBookmarkAction:
             return createAddBookmarkInteractor()
         case AddBookmarkScreenlet.GetTitleAction:
             return createGetTitleInteractor()
         default:
             return nil
         }
     }

 private func createAddBookmarkInteractor() -> Interactor {
     let interactor = AddBookmarkInteractor(screenlet: self,
                                            folderId: folderId,
                                            title: viewModel.title!,
                                            url: viewModel.URL!)

     // Called when the Interactor finishes succesfully
     interactor.onSuccess = {
         let bookmarkName = interactor.resultBookmarkInfo!["name"] as! String
         print("Bookmark \"\(bookmarkName)\" saved!")
     }

     // Called when the Interactor finishes with an error
     interactor.onFailure = { _ in
         print("An error occurred saving the bookmark")
     }

     return interactor
 }

 private func createGetTitleInteractor() -> Interactor {
     let interactor = GetWebTitleInteractor(screenlet: self, url: viewModel.URL!)

     // Called when the Interactor finishes succesfully
     interactor.onSuccess = {
         let title = interactor.resultTitle
         self.viewModel.title = title
     }

     // Called when the Interactor finishes with an error
     interactor.onFailure = { _ in
         print("An error occurred retrieving the title")
     }

     return interactor
 }
 ...
\end{verbatim}
\end{enumerate}

Great! Now you know how to support multiple actions in your Screenlets.

\subsection{Related Topics}\label{related-topics-88}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-ios-screenlets}{Creating
iOS Screenlets}

\href{/docs/7-0/tutorials/-/knowledge_base/t/create-and-use-a-connector-with-your-screenlet}{Create
and Use a Connector with Your Screenlet}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-ios-list-screenlets}{Creating
iOS List Screenlets}

\href{/docs/7-0/tutorials/-/knowledge_base/t/architecture-of-liferay-screens-for-ios}{Architecture
of Liferay Screens for iOS}

\section{Create and Use a Connector with Your
Screenlet}\label{create-and-use-a-connector-with-your-screenlet}

In Liferay Screens, a Connector is a class that interacts asynchronously
with local and remote data sources and Liferay instances. Recall that
callbacks also make asynchronous service calls. So why bother with a
Connector? Connectors provide a layer of abstraction by making your
service call outside your Interactor. For example,
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-ios-screenlets\#creating-the-interactor}{the
Interactor in the Screenlet creation tutorial} makes the server call and
and processes its results via \texttt{LRCallback}. This Screenlet could
instead make its server call in a separate Connector class, leaving the
Interactor to instantiate the Connector and receive its results.
Connectors also let you validate your Screenlet's data. For more
information on Connectors, see the
\href{/docs/7-0/tutorials/-/knowledge_base/t/architecture-of-liferay-screens-for-ios}{tutorial
on the architecture of Liferay Screens for iOS}.

This tutorial walks you through the steps required to create and use a
Connector with your Screenlets, using the
\href{https://github.com/liferay/liferay-screens/tree/master/ios/Samples/Bookmark/AddBookmarkScreenlet/Advanced}{advanced
version of the sample Add Bookmark Screenlet} as an example. This
Screenlet contains two actions:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add Bookmark: Adds a bookmark to the Bookmarks portlet in a Liferay
  DXP installation. This tutorial shows you how to create and use a
  Connector for this action.
\item
  Get Title: Retrieves the title from a bookmark URL entered by the
  user. This tutorial shows you how to use a pre-existing Connector with
  this action.
\end{enumerate}

Before proceeding, make sure you've read
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-ios-screenlets}{the
Screenlet creation tutorial}. First, you'll learn how to create your
Connector.

\subsection{Creating Connectors}\label{creating-connectors}

When you create your Connector class, be sure to follow the
\href{/docs/7-0/tutorials/-/knowledge_base/t/ios-best-practices\#naming-conventions}{naming
convention} specified in the best practices tutorial.

Use the following steps to implement your Connector class:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create your Connector class by extending the
  \href{https://github.com/liferay/liferay-screens/blob/master/ios/Framework/Core/Base/BaseConnectors/ServerConnector.swift}{\texttt{ServerConnector}
  class}. For example, here's the class declaration for Add Bookmark
  Screenlet's Connector class, \texttt{AddBookmarkLiferayConnector}:

\begin{verbatim}
public class AddBookmarkLiferayConnector: ServerConnector {
    ...
}
\end{verbatim}
\item
  Add the properties needed to call the Mobile SDK service, then create
  an initializer that sets those properties. For example,
  \texttt{AddBookmarkLiferayConnector} needs properties for the
  bookmark's folder ID, title, and URL. It also needs an initializer to
  set those properties:

\begin{verbatim}
public let folderId: Int64
public let title: String
public let url: String

public init(folderId: Int64, title: String, url: String) {
    self.folderId = folderId
    self.title = title
    self.url = url
    super.init()
}
\end{verbatim}
\item
  If you want to validate any of your Screenlet's properties, override
  the \texttt{validateData} method to implement validation for those
  properties. You can use the
  \href{https://github.com/liferay/liferay-screens/blob/develop/ios/Framework/Core/Extensions/NSError\%2BScreens.swift}{\texttt{ValidationError}
  class} to encapsulate the errors. For example, the following
  \texttt{validateData} implementation in
  \texttt{AddBookmarkLiferayConnector} ensures that \texttt{folderId} is
  greater than \texttt{0}, and \texttt{title} and \texttt{url} contain
  values. This method also uses \texttt{ValidationError} to represent
  the error:

\begin{verbatim}
override public func validateData() -> ValidationError? {
    let error = super.validateData()

    if error == nil {

        if folderId <= 0 {
            return ValidationError("Undefined folderId")
        }

        if title.isEmpty {
            return ValidationError("Title cannot be empty")
        }

        if url.isEmpty {
            return ValidationError("URL cannot be empty")
        }
    }

    return error
}
\end{verbatim}
\item
  Override the \texttt{doRun} method to call the Mobile SDK service you
  need to call. This method should retrieve the result from the service
  and store it in a public property. Also be sure to handle errors and
  empty results. For example, the following code defines the
  \texttt{resultBookmarkInfo} property for storing the service's results
  retrieved in the \texttt{doRun} method. Note that this method's
  service call is identical to the one in the
  \texttt{AddBookmarkInteractor} class's \texttt{start} method in the
  \href{/docs/7-0/tutorials/-/knowledge_base/t/creating-ios-screenlets}{Screenlet
  creation tutorial}. The \texttt{doRun} method, however, takes the
  additional step of saving the result to the
  \texttt{resultBookmarkInfo} property. Also note that this
  \texttt{doRun} method handles errors as \texttt{NSError} objects:

\begin{verbatim}
public var resultBookmarkInfo: [String:AnyObject]?

override public func doRun(session session: LRSession) {

    let service = LRBookmarksEntryService_v7(session: session)

    do {
        let result = try service.addEntryWithGroupId(LiferayServerContext.groupId,
                                                     folderId: folderId,
                                                     name: title,
                                                     url: url,
                                                     description: "Added from Liferay Screens",
                                                     serviceContext: nil)

        if let result = result as? [String: AnyObject] {
            resultBookmarkInfo = result
            lastError = nil
        }
        else {
            lastError = NSError.errorWithCause(.InvalidServerResponse)
            resultBookmarkInfo = nil
        }
    }
    catch let error as NSError {
        lastError = error
        resultBookmarkInfo = nil
    }

}
\end{verbatim}
\end{enumerate}

Well done! Now you know how to create a Connector class. To see the
finished example \texttt{AddBookmarkLiferayConnector} class,
\href{https://github.com/liferay/liferay-screens/blob/master/ios/Samples/Bookmark/AddBookmarkScreenlet/Advanced/Connector/AddBookmarkLiferayConnector.swift}{click
here}.

\subsection{Using Connectors}\label{using-connectors}

To use a Connector, your Interactor class must extend the
\href{https://github.com/liferay/liferay-screens/blob/master/ios/Framework/Core/Base/BaseConnectors/ServerConnectorInteractor.swift}{\texttt{ServerConnectorInteractor}
class} or one of its following subclasses:

\begin{itemize}
\item
  \href{https://github.com/liferay/liferay-screens/blob/master/ios/Framework/Core/Base/BaseConnectors/ServerReadConnectorInteractor.swift}{\texttt{ServerReadConnectorInteractor}:}
  Your Interactor class should extend this class when implementing an
  action that retrieves information from a server or data source.
\item
  \href{https://github.com/liferay/liferay-screens/blob/master/ios/Framework/Core/Base/BaseConnectors/ServerWriteConnectorInteractor.swift}{\texttt{ServerWriteConnectorInteractor}:}
  Your Interactor class should extend this class when implementing an
  action that writes information to a server or data source.
\end{itemize}

When extending \texttt{ServerConnectorInteractor} or one of its
subclasses, your Interactor class only needs to override the
\texttt{createConnector} and \texttt{completedConnector} methods. These
methods create a Connector instance and recover the Connector's result,
respectively.

Follow these steps to use a Connector in your Interactor:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Set your Interactor class's superclass to
  \texttt{ServerConnectorInteractor} or one of its subclasses. You
  should also remove any code that conforms a callback protocol, if it
  exists. For example, Add Bookmark Screenlet's Interactor class
  (\texttt{AddBookmarkInteractor}) extends
  \texttt{ServerWriteConnectorInteractor} because it writes data to a
  Liferay DXP installation. At this point, your Interactor should
  contain only the properties and initializer that it requires:

\begin{verbatim}
 public class AddBookmarkInteractor: ServerWriteConnectorInteractor {

     public let folderId: Int64
     public let title: String
     public let url: String

     public var resultBookmark: Bookmark?

     //MARK: Initializer

     public init(screenlet: BaseScreenlet, folderId: Int64, title: String, url: String) {
         self.folderId = folderId
         self.title = title
         self.url = url
         super.init(screenlet: screenlet)
     }
 }
\end{verbatim}
\item
  Override the \texttt{createConnector} method to return an instance of
  your Connector. For example, the \texttt{createConnector} method in
  \texttt{AddBookmarkInteractor} returns an
  \texttt{AddBookmarkLiferayConnector} instance created with the
  \texttt{folderId}, \texttt{title}, and \texttt{url} properties:

\begin{verbatim}
 public override func createConnector() -> ServerConnector? {
     return AddBookmarkLiferayConnector(folderId: folderId, title: title, url: url)
 }
\end{verbatim}
\item
  Override the \texttt{completedConnector} method to get the result from
  the Connector and store it in the appropriate property. For example,
  the \texttt{completedConnector} method in
  \texttt{AddBookmarkInteractor} first casts its
  \texttt{ServerConnector} argument to
  \texttt{AddBookmarkLiferayConnector}. It then gets the Connector's
  \texttt{resultBookmarkInfo} property and sets it to the Interactor's
  \texttt{resultBookmark} property:

\begin{verbatim}
 override public func completedConnector(c: ServerConnector) {
     if let addCon = (c as? AddBookmarkLiferayConnector),
         bookmarkInfo = addCon.resultBookmarkInfo {
         self.resultBookmark = bookmarkInfo
     }
 }
\end{verbatim}
\end{enumerate}

That's it! To see the complete example \texttt{AddBookmarkInteractor},
\href{https://github.com/liferay/liferay-screens/blob/master/ios/Samples/Bookmark/AddBookmarkScreenlet/Advanced/Interactor/AddBookmarkInteractor.swift}{click
here}.

If your Screenlet uses multiple Interactors, follow the same steps to
use Connectors. Also, Screens provides
\href{https://github.com/liferay/liferay-screens/blob/master/ios/Framework/Core/Base/BaseConnectors/HttpConnector.swift}{the
ready-to-use \texttt{HttpConnector}} for interacting with non-Liferay
URL's. To use this Connector, set your Interactor to use
\texttt{HttpConnector}. For example, the Add Bookmark Screenlet action
that retrieves a URL's title doesn't interact with a Liferay DXP
installation; it retrieves the title directly from the URL. Because this
action's Interactor class (\texttt{GetWebTitleInteractor}) retrieves
data, it extends \texttt{ServerReadConnectorInteractor}. It also
overrides the \texttt{createConnector} and \texttt{completedConnector}
methods to use \texttt{HttpConnector}. Here's the complete
\texttt{GetWebTitleInteractor}:

\begin{verbatim}
import UIKit
import LiferayScreens

public class GetWebTitleInteractor: ServerReadConnectorInteractor {

    public let url: String?

    // title from the webpage
    public var resultTitle: String?

    //MARK: Initializer

    public init(screenlet: BaseScreenlet, url: String) {
        self.url = url
        super.init(screenlet: screenlet)
    }

    //MARK: ServerConnectorInteractor

    public override func createConnector() -> ServerConnector? {
        if let url = url, URL = NSURL(string: url) {
            return HttpConnector(url: URL)
        }

        return nil
    }

    override public func completedConnector(c: ServerConnector) {
        if let httpCon = (c as? HttpConnector), data = httpCon.resultData,
            html = NSString(data: data, encoding: NSUTF8StringEncoding) {
            self.resultTitle = parseTitle(html)
        }
    }

    //MARK: Private methods

    // Parse the title from the webpage's HTML
    private func parseTitle(html: NSString) -> String {
        let range1 = html.rangeOfString("<title>")
        let range2 = html.rangeOfString("</title>")

        let start = range1.location + range1.length

        return html.substringWithRange(NSMakeRange(start, range2.location - start))
    }

}
\end{verbatim}

Awesome! Now you know how to create and use Connectors in your
Screenlets.

\subsection{Related Topics}\label{related-topics-89}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-ios-screenlets}{Creating
iOS Screenlets}

\href{/docs/7-0/tutorials/-/knowledge_base/t/adding-screenlet-actions}{Adding
Screenlet Actions}

\href{/docs/7-0/tutorials/-/knowledge_base/t/architecture-of-liferay-screens-for-ios}{Architecture
of Liferay Screens for iOS}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-ios-list-screenlets}{Creating
iOS List Screenlets}

\section{Add a Screenlet Delegate}\label{add-a-screenlet-delegate}

Screenlet delegates let other classes respond to your Screenlet's
actions. For example,
\href{/docs/7-0/reference/-/knowledge_base/r/loginscreenlet-for-ios\#delegate}{Login
Screenlet's delegate} lets the app developer implement methods that
respond to login success or failure. Note that the
\href{/docs/7-0/reference/-/knowledge_base/r/screenlets-in-liferay-screens-for-ios}{reference
documentation} for each Screenlet that comes with Liferay Screens lists
the Screenlet's delegate methods.

You can also create a delegate for your own Screenlet. This tutorial
walks you through the steps required to do this, using code from
\href{https://github.com/liferay/liferay-screens/tree/master/ios/Samples/Bookmark/AddBookmarkScreenlet/Advanced}{the
advanced version of the sample Add Bookmark Screenlet} as an example.
All the example code in this tutorial resides in
\href{https://github.com/liferay/liferay-screens/blob/master/ios/Samples/Bookmark/AddBookmarkScreenlet/Advanced/AddBookmarkScreenlet.swift}{this
Screenlet's Screenlet class}. Also note that this sample Screenlet has
two actions: adding a bookmark to a Liferay instance's Bookmarks
portlet, and retrieving a bookmark's title from its URL. This tutorial
only details creating a delegate for adding a bookmark.

Follow these steps to add a delegate to your Screenlet:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Define a delegate protocol that extends the
  \href{https://github.com/liferay/liferay-screens/blob/master/ios/Framework/Core/Base/BaseScreenlet.swift}{\texttt{BaseScreenletDelegate}
  class}. In this protocol, define success and failure methods so the
  conforming class can respond to the server call's success and failure,
  respectively. As parameters, these methods should take a Screenlet
  instance and the success or failure object. For example, Add Bookmark
  Screenlet's delegate protocol (\texttt{AddBookmarkScreenletDelegate})
  defines the following success and failure methods:

\begin{verbatim}
 @objc public protocol AddBookmarkScreenletDelegate: BaseScreenletDelegate {

     optional func screenlet(screenlet: AddBookmarkScreenlet,
                         onBookmarkAdded bookmark: [String: AnyObject])

     optional func screenlet(screenlet: AddBookmarkScreenlet,
                         onAddBookmarkError error: NSError)

 }
\end{verbatim}

  Both take an \texttt{AddBookmarkScreenlet} instance as their first
  argument. For their second argument, the success method contains the
  bookmark added to the server, and the failure method contains the
  \texttt{NSError} object. Note that in this example, the methods are
  optional. This means that the delegate class doesn't have to implement
  them.
\item
  In your Screenlet class, add a property for your delegate. This
  property should return \texttt{BaseScreenlet}'s \texttt{delegate}
  property as an instance of your delegate. For example, the
  \texttt{addBookmarkDelegate} property in \texttt{AddBookmarkScreenlet}
  returns the \texttt{self.delegate} property as
  \texttt{AddBookmarkScreenletDelegate}:

\begin{verbatim}
 var addBookmarkDelegate: AddBookmarkScreenletDelegate? {
     return self.delegate as? AddBookmarkScreenletDelegate
 }
\end{verbatim}
\item
  Also in your Screenlet class, invoke the appropriate delegate methods
  in your Interactor's closures. For example, the
  \texttt{interactor.onSuccess} closure in \texttt{AddBookmarkScreenlet}
  calls the delegate method that responds when the Screenlet
  successfully adds a bookmark. The \texttt{interactor.onFailure}
  closure calls the delegate method that responds when the Screenlet
  fails to add a bookmark. Note that in this example, these closures are
  in the Screenlet class's Interactor method that adds a bookmark
  (\texttt{createAddBookmarkInteractor}). Be sure to call your delegate
  methods wherever the appropriate Interactor's closures are in your
  Screenlet class:

\begin{verbatim}
 private func createAddBookmarkInteractor() -> Interactor {
     let interactor = AddBookmarkInteractor(screenlet: self,
                                        folderId: folderId,
                                        title: viewModel.title!,
                                        url: viewModel.URL!)

     // Called when the Interactor finishes successfully
     interactor.onSuccess = {
         if let bookmark = interactor.resultBookmark {
             self.addBookmarkDelegate?.screenlet?(self, onBookmarkAdded: bookmark)
         }
     }

     // Called when the Interactor finishes with an error
     interactor.onFailure = { error in
         self.addBookmarkDelegate?.screenlet?(self, onAddBookmarkError: error)
     }

     return interactor
 }
\end{verbatim}
\end{enumerate}

Great! Now you know how to add a delegate to your Screenlets.

\textbf{Related Topics}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-ios-screenlets}{Creating
iOS Screenlets}

\href{/docs/7-0/tutorials/-/knowledge_base/t/adding-screenlet-actions}{Adding
Screenlet Actions}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-ios-list-screenlets}{Creating
iOS List Screenlets}

\href{/docs/7-0/tutorials/-/knowledge_base/t/architecture-of-liferay-screens-for-ios}{Architecture
of Liferay Screens for iOS}

\section{Using and Creating Progress
Presenters}\label{using-and-creating-progress-presenters}

Many apps display a progress indicator while performing an operation.
For example, you've likely seen the spinners in iOS apps that let you
know the app is performing some kind of work. For more information, see
\href{https://developer.apple.com/ios/human-interface-guidelines/ui-controls/progress-indicators/}{the
iOS Human Interface Guidelines article on Progress Indicators}.

You can display these in Screenlets by using classes that conform the
\href{https://github.com/liferay/liferay-screens/blob/master/ios/Framework/Core/Base/ProgressPresenter.swift}{\texttt{ProgressPresenter}
protocol}. Liferay Screens includes two such classes:

\begin{itemize}
\item
  \href{https://github.com/liferay/liferay-screens/blob/master/ios/Framework/Core/Base/MBProgressHUDPresenter.swift}{\texttt{MBProgressHUDPresenter}}:
  Shows a message with a spinner in the middle of the screen. Liferay
  Screens shows this presenter by default.
\item
  \href{https://github.com/liferay/liferay-screens/blob/master/ios/Framework/Core/Base/NetworkActivityIndicatorPresenter.swift}{\texttt{NetworkActivityIndicatorPresenter}}:
  Shows the progress using the iOS network activity indicator. This
  presenter doesn't support messages.
\end{itemize}

This tutorial shows you how to use and create progress presenters, using
code from the
\href{https://github.com/liferay/liferay-screens/tree/master/ios/Samples/Bookmark/AddBookmarkScreenlet/Advanced}{advanced
version of the sample Add Bookmark Screenlet} as an example. First,
you'll learn how to use progress presenters.

\subsection{Using Progress Presenters}\label{using-progress-presenters}

\href{https://github.com/liferay/liferay-screens/blob/master/ios/Framework/Core/Base/BaseScreenletView.swift}{The
\texttt{BaseScreenletView} class} contains the default progress
presenter functionality. To show a presenter other than the default
\texttt{MBProgressHUDPresenter}, your View class must therefore override
certain \texttt{BaseScreenletView} functionality. Follow these steps to
do this:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In your View class, override the \texttt{BaseScreenletView} method
  \texttt{createProgressPresenter} to return an instance of the desired
  presenter. For example, to use
  \texttt{NetworkActivityIndicatorPresenter} in the sample Add Bookmark
  Screenlet, you must override the \texttt{createProgressPresenter}
  method in \texttt{AddBookmarkView\_default} to return a
  \texttt{NetworkActivityIndicatorPresenter} instance:

\begin{verbatim}
 override func createProgressPresenter() -> ProgressPresenter {
     return NetworkActivityIndicatorPresenter()
 }
\end{verbatim}
\item
  In your View class, override the \texttt{BaseScreenletView} property
  \texttt{progressMessages} to return the messages you want to use in
  the presenter. If the presenter doesn't display messages, then return
  an empty string. The \texttt{progressMessages} property should return
  the messages as \texttt{{[}String\ :\ ProgressMessages{]}}, where
  \texttt{String} is the Screenlet's action name.
  \href{https://github.com/liferay/liferay-screens/blob/master/ios/Framework/Core/Base/ProgressPresenter.swift}{\texttt{ProgressMessages}
  is a type alias} representing a dictionary where the progress type is
  the key, and the actual message is the value. The three possible
  progress types correspond to the Screenlet action's status:
  \texttt{Working}, \texttt{Failure}, or \texttt{Success}. The
  \texttt{progressMessages} property therefore lets the presenter
  display the appropriate message for the Screenlet action's current
  status.

  For example, the following code overrides the
  \texttt{progressMessages} property in Add Bookmark Screenlet's View
  class (\texttt{AddBookmarkView\_default}). For each Screenlet action
  (\texttt{AddBookmarkAction} and \texttt{GetTitleAction}), a message
  (\texttt{NoProgressMessage}) is assigned to the Screenlet operation's
  \texttt{Working} status. Since \texttt{NoProgressMessage} is an alias
  for an empty string, this tells the presenter to display no message
  when the Screenlet attempts to add a bookmark or get a title. Note,
  however, that the presenter still displays its progress indicator:

\begin{verbatim}
 override var progressMessages: [String : ProgressMessages] {
     return [
         AddBookmarkScreenlet.AddBookmarkAction : [.Working: NoProgressMessage],
         AddBookmarkScreenlet.GetTitleAction : [.Working: NoProgressMessage],
     ]
 }
\end{verbatim}

  To display a message, replace \texttt{NoProgressMessage} with your
  message. For example, the following code defines separate messages for
  \texttt{Working}, \texttt{Success}, and \texttt{Failure}:

\begin{verbatim}
 override var progressMessages: [String : ProgressMessages] {
     return [
         AddBookmarkScreenlet.AddBookmarkAction : [
             .Working: "Saving bookmark...",
             .Success: "Bookmark saved!",
             .Failure: "An error occurred saving the bookmark"
         ],
         AddBookmarkScreenlet.GetTitleAction : [
             .Working: "Getting site title...",
             .Failure: "An error occurred retrieving the title"
         ],
     ]
 }
\end{verbatim}
\end{enumerate}

Great! Now you know how to use progress presenters. Next, you'll learn
how to create your own.

\subsection{Creating Progress
Presenters}\label{creating-progress-presenters}

Creating your own progress presenter isn't as complicated as you might
think. Recall that a presenter in Liferay Screens is a class that
conforms the
\href{https://github.com/liferay/liferay-screens/blob/master/ios/Framework/Core/Base/ProgressPresenter.swift}{\texttt{ProgressPresenter}
protocol}. You can create your presenter by conforming this protocol
from scratch, or by extending one of Screens's existing presenters that
already conform this protocol (\texttt{MBProgressHUDPresenter} or
\texttt{NetworkActivityIndicatorPresenter}). In most cases, extending
\texttt{MBProgressHUDPresenter} is sufficient.

For example,
\href{https://github.com/liferay/liferay-screens/blob/master/ios/Samples/Bookmark/AddBookmarkScreenlet/Advanced/ProgressPresenter/AddBookmarkProgressPresenter.swift}{Add
Bookmark Screenlet's \texttt{AddBookmarkProgressPresenter}} extends
\texttt{MBProgressHUDPresenter} to display a different progress
indicator for the Screenlet's get title action. Use the following steps
to create a progress presenter that extends from an existing presenter.
As an example, these steps extend \texttt{MBProgressHUDPresenter} to add
a progress indicator for the get title button:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In your View's XIB file, add the activity indicator you want to use.
  For example, the XIB file in Add Bookmark Screenlet contains an iOS
  \texttt{UIActivityIndicatorView} over the get title button:

  \begin{figure}
  \centering
  \includegraphics{./images/screens-ios-xcode-add-bookmark-advanced-progress.png}
  \caption{The updated Add Bookmark Screenlet's XIB file contains a new
  activity indicator over the get title button.}
  \end{figure}
\item
  In your View class, create an outlet for the XIB's new activity
  indicator. For example, Add Bookmark Screenlet's View class
  (\texttt{AddBookmarkView\_default}) contains an \texttt{@IBOutlet} for
  the \texttt{UIActivityIndicatorView} from the XIB:

\begin{verbatim}
 @IBOutlet weak var activityIndicatorView: UIActivityIndicatorView?
\end{verbatim}
\end{enumerate}

Now you must create your presenter class. You'll do this here by
extending an existing presenter class. Use the following steps to do
this:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Extend the existing presenter class you want to base your presenter
  on. Your presenter class must contain properties for your presenter's
  activity indicator and any other UI components. It must also contain
  an initializer that sets these properties. For example,
  \texttt{AddBookmarkProgressPresenter} extends
  \texttt{MBProgressHUDPresenter} and contains properties for the get
  title button and \texttt{UIActivityIndicatorView}. Its initializer
  sets these properties:

\begin{verbatim}
 public class AddBookmarkProgressPresenter: MBProgressHUDPresenter {

     let button: UIButton?

     let activityIndicator: UIActivityIndicatorView?

     public init(button: UIButton?, activityIndicator: UIActivityIndicatorView?) {
         self.button = button
         self.activityIndicator = activityIndicator
         super.init()
     }
     ...
\end{verbatim}
\item
  Implement your presenter's behavior by overriding the appropriate
  methods from the presenter class that you're extending. For example,
  \texttt{AddBookmarkProgressPresenter} overrides
  \texttt{MBProgressHUDPresenter}'s \texttt{showHUDInView} and
  \texttt{hideHUDFromView} methods. The overridden
  \texttt{showHUDInView} method hides the button and starts animating
  the activity indicator. The overridden \texttt{hideHUDFromView} method
  stops this animation and restores the button:

\begin{verbatim}
 public override func showHUDInView(view: UIView, message: String?, 
     forInteractor interactor: Interactor) {
         guard interactor is GetWebTitleInteractor else {
             return super.showHUDInView(view, message: message, 
                 forInteractor: interactor)
         }

         button?.hidden = true
         activityIndicator?.startAnimating()
 }

 public override func hideHUDFromView(view: UIView?, message: String?, 
     forInteractor interactor: Interactor, withError error: NSError?) {
         guard interactor is GetWebTitleInteractor else {
             return super.hideHUDFromView(view, message: message, 
                 forInteractor: interactor, withError: error)
         }

         activityIndicator?.stopAnimating()
         button?.hidden = false
     }

 }
\end{verbatim}
\end{enumerate}

Great, that's it! Now you can use your presenter the same way you would
any other.

\subsection{Related Topics}\label{related-topics-90}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-ios-screenlets}{Creating
iOS Screenlets}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-ios-list-screenlets}{Creating
iOS List Screenlets}

\href{/docs/7-0/tutorials/-/knowledge_base/t/architecture-of-liferay-screens-for-ios}{Architecture
of Liferay Screens for iOS}

\section{Creating and Using Your Screenlet's Model
Class}\label{creating-and-using-your-screenlets-model-class}

Liferay Screens typically receives entities from a Liferay instance as
\texttt{{[}String:AnyObject{]}}, where \texttt{String} is the entity's
attribute and \texttt{AnyObject} is the attribute's value. Although you
can use these dictionary objects throughout your Screenlet, it's often
easier to create a \emph{model class} that converts each into an object
that represents the corresponding Liferay entity. This is especially
convenient for complex entities composed of many attribute-value pairs.
Note that Liferay Screens already provides several model classes for
you.
\href{https://github.com/liferay/liferay-screens/tree/master/ios/Framework/Core/Models}{Click
here} to see them.

At this point, you might be saying, ``Ugh! I have complex entities and
Screens doesn't provide a model class for them! I'm just going to give
up and watch football.'' Fret not! Although we'd never come between you
and football, creating and using your own model class is
straightforward.

Using the
\href{https://github.com/liferay/liferay-screens/tree/master/ios/Samples/Bookmark/AddBookmarkScreenlet/Advanced}{advanced
version of the sample Add Bookmark Screenlet} as an example, this
tutorial shows you how to create and use a model class in your
Screenlet. First, you'll create your model class.

\subsection{Creating Your Model Class}\label{creating-your-model-class}

Your model class must contain all the code necessary to transform each
\texttt{{[}String:AnyObject{]}} that comes back from the server into a
model object that represents the corresponding Liferay entity. This
includes a constant for holding each \texttt{{[}String:AnyObject{]}},
and initializer that sets this constant, and a public property for each
attribute value.

For example, the sample Add Bookmark Screenlet adds a bookmark to a
Liferay instance's Bookmarks portlet. Since the Mobile SDK service
method that adds the bookmark also returns it as
\texttt{{[}String:AnyObject{]}}, the Screenlet can convert it into an
object that represents bookmarks. It does so with its
\href{https://github.com/liferay/liferay-screens/blob/master/ios/Samples/Bookmark/AddBookmarkScreenlet/Advanced/Model/Bookmark.swift}{\texttt{Bookmark}
model class}. This class extends \texttt{NSObject} and sets the
\texttt{{[}String:AnyObject{]}} to the \texttt{attributes} constant via
the initializer. This class also defines computed properties that return
the attribute values for each bookmark's name and URL:

\begin{verbatim}
@objc public class Bookmark : NSObject {

    public let attributes: [String:AnyObject]

    public var name: String {
        return attributes["name"] as! String
    }

    override public var description: String {
        return attributes["description"] as! String
    }

    public var url: String {
        return attributes["url"] as! String
    }

    public init(attributes: [String:AnyObject]) {
        self.attributes = attributes
    }

}
\end{verbatim}

Next, you'll put your model class to work.

\subsection{Using Your Model Class}\label{using-your-model-class}

Now that your model class exists, you can use model objects anywhere
your Screenlet handles results. Exactly where depends on what Screenlet
components your Screenlet uses. For example, Add Bookmark Screenlet's
Connector, Interactor, delegate, and Screenlet class all handle the
Screenlet's results. The steps here therefore show you how to use model
objects in each of these components. Note, however, that your Screenlet
may lack a Connector or delegate: these components are optional.
Variations on these steps are therefore noted where applicable.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create model objects where the \texttt{{[}String:\ AnyObject{]}}
  results originate. For example, the \texttt{{[}String:\ AnyObject{]}}
  results in Add Bookmark Screenlet originate in the Connector.
  Therefore, this is where the Screenlet creates \texttt{Bookmark}
  objects. The following code in the Screenlet's Connector
  (\texttt{AddBookmarkLiferayConnector}) does this. The \texttt{if}
  statement following the service call casts the results to
  \texttt{{[}String:\ AnyObject{]}}, calls the \texttt{Bookmark}
  initializer with those results, and stores the resulting
  \texttt{Bookmark} object to the public \texttt{resultBookmarkInfo}
  variable. Note that this is only the code that makes the service call
  and creates the \texttt{Bookmark} object.
  \href{https://github.com/liferay/liferay-screens/blob/master/ios/Samples/Bookmark/AddBookmarkScreenlet/Advanced/Connector/AddBookmarkLiferayConnector.swift}{Click
  here to see the complete \texttt{AddBookmarkLiferayConnector} class}:

\begin{verbatim}
 ...
 // Public property for the results
 public var resultBookmarkInfo: Bookmark?

 ...

 override public func doRun(session session: LRSession) {
     let service = LRBookmarksEntryService_v7(session: session)

     do {
         let result = try service.addEntryWithGroupId(LiferayServerContext.groupId,
                                                      folderId: folderId,
                                                      name: title,
                                                      url: url,
                                                      description: "Added from Liferay Screens",
                                                      serviceContext: nil)

         // Creates Bookmark objects from the service call's results
         if let result = result as? [String: AnyObject] {
             resultBookmarkInfo = Bookmark(attributes: result)
             lastError = nil
         }
         ...
     }
     ...
 }
\end{verbatim}

  If your Screenlet doesn't have Connector, then your Interactor's
  \texttt{start} method makes your server call and handles its results.
  Otherwise, the process for creating a \texttt{Bookmark} object from
  \texttt{{[}String:\ AnyObject{]}} is the same.
\item
  Handle your model objects in your Screenlet's Interactor. The
  Interactor processes your Screenlet's results, so it must also handle
  your model objects. If your Screenlet doesn't use a Connector, then
  you already did this in your Interactor's \texttt{start} method as
  mentioned at the end of the previous step. If your Screenlet uses a
  Connector, however, then this happens in your Interactor's
  \texttt{completedConnector} method. For example, the
  \texttt{completedConnector} method in Add Bookmark Screenlet's
  Interactor (\texttt{AddBookmarkInteractor}) retrieves the
  \texttt{Bookmark} via the Connector's \texttt{resultBookmarkInfo}
  variable. This method then assigns the \texttt{Bookmark} to the
  Interactor's public \texttt{resultBookmark} variable. Note that this
  is only the code that handles \texttt{Bookmark} objects.
  \href{https://github.com/liferay/liferay-screens/blob/master/ios/Samples/Bookmark/AddBookmarkScreenlet/Advanced/Interactor/AddBookmarkInteractor.swift}{Click
  here to see the complete \texttt{AddBookmarkInteractor} class}:

\begin{verbatim}
 ...
 // Public property for the results
 public var resultBookmark: Bookmark?

 ...

 // The completedConnector method gets the results from the Connector
 override public func completedConnector(c: ServerConnector) { 
     if let addCon = (c as? AddBookmarkLiferayConnector), 
         bookmark = addCon.resultBookmarkInfo { 
             self.resultBookmark = bookmark 
         }
 }
\end{verbatim}
\item
  If your Screenlet uses a delegate, your delegate protocol must account
  for your model objects. Skip this step if you don't have a delegate.
  For example, Add Bookmark Screenlet's delegate
  (\texttt{AddBookmarkScreenletDelegate}) must communicate
  \texttt{Bookmark} objects. The delegate's first method does this via
  its second argument:

\begin{verbatim}
 @objc public protocol AddBookmarkScreenletDelegate: BaseScreenletDelegate {

     optional func screenlet(screenlet: AddBookmarkScreenlet,
                     onBookmarkAdded bookmark: Bookmark)

     optional func screenlet(screenlet: AddBookmarkScreenlet,
                     onAddBookmarkError error: NSError)

 }
\end{verbatim}
\item
  Get the model object from the Interactor in your Screenlet class's
  \texttt{interactor.onSuccess} closure. You can then use the model
  object however you wish. For example, the
  \texttt{interactor.onSuccess} closure in Add Bookmark Screenlet's
  Screenlet class (\texttt{AddBookmarkScreenlet}) retrieves the
  \texttt{Bookmark} from the Interactor's \texttt{resultBookmark}
  property. It then handles the \texttt{Bookmark} via the delegate. Note
  that in this example, the closure is in the Screenlet class's
  Interactor method that adds a bookmark
  (\texttt{createAddBookmarkInteractor}). Be sure to get your model
  object wherever the \texttt{interactor.onSuccess} closure is in your
  Screenlet class.
  \href{https://github.com/liferay/liferay-screens/blob/master/ios/Samples/Bookmark/AddBookmarkScreenlet/Advanced/AddBookmarkScreenlet.swift}{Click
  here to see the complete \texttt{AddBookmarkScreenlet}}:

\begin{verbatim}
 ...
 private func createAddBookmarkInteractor() -> Interactor {
     let interactor = AddBookmarkInteractor(screenlet: self,
                                        folderId: folderId,
                                        title: viewModel.title!,
                                        url: viewModel.URL!)

     // Called when the Interactor finishes successfully
     interactor.onSuccess = {
         if let bookmark = interactor.resultBookmark {
             self.addBookmarkDelegate?.screenlet?(self, onBookmarkAdded: bookmark)
         }
     }

     // Called when the Interactor finishes with an error
     interactor.onFailure = { error in
         self.addBookmarkDelegate?.screenlet?(self, onAddBookmarkError: error)
     }

     return interactor
 }
 ...
\end{verbatim}
\end{enumerate}

Awesome! Now you know how to create and use a model class in your
Screenlet.

\subsection{Related Topics}\label{related-topics-91}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-ios-screenlets}{Creating
iOS Screenlets}

\href{/docs/7-0/tutorials/-/knowledge_base/t/adding-screenlet-actions}{Adding
Screenlet Actions}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-ios-list-screenlets}{Creating
iOS List Screenlets}

\href{/docs/7-0/tutorials/-/knowledge_base/t/architecture-of-liferay-screens-for-ios}{Architecture
of Liferay Screens for iOS}

\section{Creating iOS List
Screenlets}\label{creating-ios-list-screenlets}

It's very common for mobile apps to display lists. Liferay Screens lets
you display asset lists and DDL lists in your iOS app by using
\href{/docs/7-0/reference/-/knowledge_base/r/assetlistscreenlet-for-ios}{Asset
List Screenlet} and
\href{/docs/7-0/reference/-/knowledge_base/r/ddllistscreenlet-for-ios}{DDL
List Screenlet}, respectively. Screens also includes list Screenlets for
displaying lists of other Liferay entities like web content articles,
images, and more.
\href{/docs/7-0/reference/-/knowledge_base/r/screenlets-in-liferay-screens-for-ios}{The
Screenlet reference documentation} lists all the Screenlets included
with Liferay Screens. If there's not a list Screenlet for the entity you
want to display in a list, you must create your own list Screenlet. A
list Screenlet can display any entity from a Liferay instance. For
example, you can create a list Screenlet that displays standard Liferay
entities like \texttt{User}, or custom entities from custom Liferay
apps.

This tutorial uses code from the sample Bookmark List Screenlet to show
you how to create your own list Screenlet. This Screenlet displays a
list of bookmarks from Liferay's Bookmarks portlet. You can find this
Screenlet's complete code
\href{https://github.com/liferay/liferay-screens/tree/master/ios/Samples/Bookmark/BookmarkListScreenlet}{here
in GitHub}.

Note that because this tutorial focuses on creating a list Screenlet, it
doesn't explain general Screenlet concepts and components. Before
beginning, you should therefore read the following tutorials:

\begin{itemize}
\tightlist
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/creating-ios-screenlets}{Creating
  iOS Screenlets}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/supporting-multiple-themes-in-your-screenlet}{Supporting
  Multiple Themes in Your Screenlet}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/create-and-use-a-connector-with-your-screenlet}{Create
  and Use a Connector with Your Screenlet}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/add-a-screenlet-delegate}{Add
  a Screenlet Delegate}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/creating-and-using-your-screenlets-model-class}{Creating
  and Using Your Screenlet's Model Class}
\end{itemize}

This tutorial uses the following steps to show you how to create a list
Screenlet:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Creating the Model class
\item
  Creating the Theme
\item
  Creating the Connector
\item
  Creating the Interactor
\item
  Creating the Delegate
\item
  Creating the Screenlet class
\end{enumerate}

First though, you should understand how pagination works with list
Screenlets.

\subsection{Pagination}\label{pagination-3}

To ensure that users can scroll smoothly through large lists of items,
list Screenlets support
\href{http://www.iosnomad.com/blog/2014/4/21/fluent-pagination}{fluent
pagination}. Support for this is built into the list Screenlet
framework. You'll see this as you construct your list Screenlet.

Now you're ready to begin!

\subsection{Creating the Model Class}\label{creating-the-model-class-3}

Recall that a model class transforms each
\texttt{{[}String:AnyObject{]}} entity Screens receives into a model
object that represents the corresponding Liferay entity. For
instructions on creating your model class, see the tutorial
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-and-using-your-screenlets-model-class}{Creating
and Using Your Screenlet's Model Class}. The example model class in that
tutorial is identical to Bookmark List Screenlet's.

Next, you'll create your Screenlet's Theme.

\subsection{Creating the Theme}\label{creating-the-theme}

Recall that each Screenlet needs a Theme to serve as its UI. A Theme
needs an XIB file to define the UI's components and layout. Since a list
Screenlet displays a list of entities, its XIB file must contain a Table
View. Use these steps to create your Theme's XIB file:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In Xcode, create a new XIB file and name it according to
  \href{/docs/7-0/tutorials/-/knowledge_base/t/ios-best-practices\#naming-conventions}{these
  naming conventions}. For example, the XIB for Bookmark List
  Screenlet's Default Theme is \texttt{BookmarkListView\_default.xib}.
\item
  In Interface Builder, drag and drop a View from the Object Library to
  the canvas. Then add a Table View to the View.
\item
  Resize the Table View to take up the entire View, and set the
  constraints the Table View needs to maintain this size dynamically.
  This ensures that the list fills the Screenlet's UI regardless of the
  iOS device's size or orientation.
\end{enumerate}

For example,
\href{https://github.com/liferay/liferay-screens/blob/master/ios/Samples/Bookmark/BookmarkListScreenlet/Themes/Default/BookmarkListView_default.xib}{Bookmark
List Screenlet's XIB file} uses a \texttt{UITableView} inside a parent
View to show the list of bookmarks.

Now you'll create your Theme's View class. Every Theme needs a View
class that controls its behavior. Since the XIB file uses a
\texttt{UITableView} to show a list of guestbooks, your View class must
extend
\href{https://github.com/liferay/liferay-screens/blob/master/ios/Framework/Core/Base/BaseListScreenlet/TableView/BaseListTableView.swift}{the
\texttt{BaseListTableView} class}. Liferay Screens provides this class
to serve as the base class for list Screenlets' View classes. Since
\texttt{BaseListTableView} provides most of the required functionality,
extending it lets you focus on the parts of your View class that are
unique to your Screenlet. You must also configure the XIB file to use
your View class.

Follow these steps to create your Screenlet's View class and configure
the XIB file to use it:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create your Theme's View class, and name it according to
  \href{/docs/7-0/tutorials/-/knowledge_base/t/ios-best-practices\#naming-conventions}{these
  naming conventions}. Since the XIB uses \texttt{UITableView}, your
  View class must extend \texttt{BaseListTableView}. For example, this
  is Bookmark List Screenlet's View class declaration:

\begin{verbatim}
public class BookmarkListView_default: BaseListTableView {...
\end{verbatim}
\item
  Now you must override the View class methods that fill the table
  cells' contents. There are two methods for this, depending on the cell
  type:

  \begin{itemize}
  \item
    \textbf{Normal cells:} the cells that show the entities. These cells
    typically use \texttt{UILabel}, \texttt{UIImage}, or another UI
    component to show the entity. Override the \texttt{doFillLoadedCell}
    method to fill these cells. For example, Bookmark List Screenlet's
    View class overrides \texttt{doFillLoadedCell} to set each cell's
    \texttt{textLabel} to a bookmark's name:

\begin{verbatim}
  override public func doFillLoadedCell(row row: Int, cell: UITableViewCell, 
      object: AnyObject) {

          let bookmark = object as! Bookmark

          cell.textLabel?.text = bookmark.name
  }
\end{verbatim}
  \item
    \textbf{Progress cell:} the cell at the bottom of the list that
    indicates the list is loading the next page of items. Override the
    \texttt{doFillInProgressCell} method to fill this cell. For example,
    Bookmark List Screenlet's View class overrides this method to set
    the cell's \texttt{textLabel} to the string \texttt{"Loading..."}:

\begin{verbatim}
  override public func doFillInProgressCell(row row: Int, cell: UITableViewCell) {
      cell.textLabel?.text = "Loading..."
  }
\end{verbatim}
  \end{itemize}
\item
  Return to the Theme's XIB in Interface Builder, and set the View class
  as the the parent View's custom class. For example, if you were doing
  this for Bookmark List Screenlet you'd select the Table View's parent
  View, click the Identity inspector, and enter
  \texttt{BookmarkListView\_default} as the custom class.
\item
  With the Theme's XIB still open in Interface Builder, set the parent
  View's \texttt{tableView} outlet to the Table View. To do this, select
  the parent View and click the Connections inspector. In the Outlets
  section, drag and drop from the \texttt{tableView}'s circle icon (it
  turns into a plus icon on mouseover) to the Table View in the XIB. The
  new outlet then appears in the Connections inspector.
\end{enumerate}

That's it! Now that your Theme is finished, you can create the
Connector.

\subsection{Creating the Connector}\label{creating-the-connector-2}

Recall that Connectors make a server call. To support pagination, a List
Screenlet's Connector class must extend the
\href{https://github.com/liferay/liferay-screens/blob/master/ios/Framework/Core/Base/BaseListScreenlet/PaginationLiferayConnector.swift}{\texttt{PaginationLiferayConnector}
class}. The Connector class must also contain any properties it needs to
make the server call, and an initializer that sets them. To support
pagination, the initializer must also contain the following arguments,
which you'll pass to the superclass initializer:

\begin{itemize}
\tightlist
\item
  \texttt{startRow}: The number representing the page's first row.
\item
  \texttt{endRow}: The number representing the page's last row.
\item
  \texttt{computeRowCount}: Whether to call the Connector's
  \texttt{doAddRowCountServiceCall} method (you'll learn about this
  method shortly).
\end{itemize}

For example, Bookmark List Screenlet must retrieve bookmarks from a
Bookmarks portlet folder in a specific site. The Screenlet's Connector
class must therefore have properties for the \texttt{groupId} (site ID)
and \texttt{folderId} (Bookmarks folder ID), and an initializer that
sets them. The initializer also calls the superclass initializer with
the \texttt{startRow}, \texttt{endRow}, and \texttt{computeRowCount}
arguments:

\begin{verbatim}
import UIKit
import LiferayScreens

public class BookmarkListPageLiferayConnector: PaginationLiferayConnector {

    public let groupId: Int64
    public let folderId: Int64

    //MARK: Initializer

    public init(startRow: Int, endRow: Int, computeRowCount: Bool, groupId: Int64, 
        folderId: Int64) {
        
            self.groupId = groupId
            self.folderId = folderId

            super.init(startRow: startRow, endRow: endRow, computeRowCount: computeRowCount)
    }
    ...
\end{verbatim}

Next, if you want to validate any of your Screenlet's properties,
override the \texttt{validateData} method as described in
\href{/docs/7-0/tutorials/-/knowledge_base/t/create-and-use-a-connector-with-your-screenlet\#creating-connectors}{the
tutorial on creating Connectors}. Note that Bookmark List Screenlet only
needs to validate the \texttt{folderId}:

\begin{verbatim}
override public func validateData() -> ValidationError? {
    let error = super.validateData()

    if error == nil {
        if folderId <= 0 {
            return ValidationError("Undefined folderId")
        }
    }

    return error
}
\end{verbatim}

Lastly, you must override the following two methods in the Connector
class:

\begin{itemize}
\item
  \texttt{doAddPageRowsServiceCall}: calls the Liferay Mobile SDK
  service method that retrieves a page of entities. The
  \texttt{doAddPageRowsServiceCall} method's \texttt{startRow} and
  \texttt{endRow} arguments specify the page's first and last entities,
  respectively. Make the service call as you would in any Screenlet. For
  example, the \texttt{doAddPageRowsServiceCall} method in
  \texttt{BookmarkListPageLiferayConnector} calls the service's
  \texttt{getEntriesWithGroupId} method to retrieve a page of bookmarks
  from the folder specified by \texttt{folderId}:

\begin{verbatim}
  public override func doAddPageRowsServiceCall(session session: LRBatchSession, 
      startRow: Int, endRow: Int, obc: LRJSONObjectWrapper?) {
          let service = LRBookmarksEntryService_v7(session: session)

      do {
          try service.getEntriesWithGroupId(groupId,
                                            folderId: folderId,
                                            start: Int32(startRow),
                                            end: Int32(endRow))
      }
      catch  {
          // ignore error: the service method returns nil because
          // the request is sent later, in batch
      }
  }
\end{verbatim}

  Note that you don't need to do anything in the \texttt{catch}
  statement because the request is sent later, in batch. The
  \texttt{session} type \texttt{LRBatchSession} handles this for you.
  You'll receive the request's results elsewhere, once the request
  completes.
\item
  \texttt{doAddRowCountServiceCall}: calls the Liferay Mobile SDK
  service method that retrieves the total number of entities. This
  supports pagination. Make the service call as you would in any
  Screenlet. For example, the \texttt{doAddRowCountServiceCall} in
  \texttt{BookmarkListPageLiferayConnector} calls the service's
  \texttt{getEntriesCountWithGroupId} method to retrieve the total
  number of bookmarks in the folder specified by \texttt{folderId}:

\begin{verbatim}
  override public func doAddRowCountServiceCall(session session: LRBatchSession) {
      let service = LRBookmarksEntryService_v7(session: session)

      do {
          try service.getEntriesCountWithGroupId(groupId, folderId: folderId)
      }
      catch  {
          // ignore error: the service method returns nil because
          // the request is sent later, in batch
      }
  }
\end{verbatim}
\end{itemize}

Now that you have your Connector class, you're ready to create the
Interactor.

\subsection{Creating the Interactor}\label{creating-the-interactor-3}

Recall that Interactors implement your Screenlet's actions. In list
Screenlets, loading entities is usually the only action a user can take.
The Interactor class of a list Screenlet that implements fluent
pagination must extend the
\href{https://github.com/liferay/liferay-screens/blob/master/ios/Framework/Core/Base/BaseListScreenlet/BaseListPageLoadInteractor.swift}{\texttt{BaseListPageLoadInteractor}
class}. Your Interactor class must also contain any properties the
Screenlet needs, and an initializer that sets them. This initializer
also needs arguments for the following properties, which it passes to
the superclass initializer:

\begin{itemize}
\tightlist
\item
  \texttt{screenlet}: A \texttt{BaseListScreenlet} reference. This
  ensures the Interactor always has a Screenlet reference.
\item
  \texttt{page}: The page number to retrieve.
\item
  \texttt{computeRowCount}: Whether to call the Connector's
  \texttt{doAddRowCountServiceCall} method.
\end{itemize}

For example, Bookmark List Screenlet's Interactor class contains the
same \texttt{groupId} and \texttt{folderId} properties as the Connector,
and an initializer that sets them. This initializer also passes the
\texttt{screenlet}, \texttt{page}, and \texttt{computeRowCount}
arguments to the superclass initializer:

\begin{verbatim}
public class BookmarkListPageLoadInteractor : BaseListPageLoadInteractor {

    private let groupId: Int64
    private let folderId: Int64

    init(screenlet: BaseListScreenlet,
        page: Int,
        computeRowCount: Bool,
        groupId: Int64,
        folderId: Int64) {

            self.groupId = (groupId != 0) ? groupId : LiferayServerContext.groupId
            self.folderId = folderId

            super.init(screenlet: screenlet, page: page, computeRowCount: computeRowCount)
    }
    ...
\end{verbatim}

The Interactor class must also initiate the server request by
instantiating the Connector, and convert the results into model objects.
Override the \texttt{createListPageConnector} method to create and
return an instance of your Connector. This method must first get a
reference to the Screenlet via the \texttt{screenlet} property. When
calling the Connector's initializer, use
\texttt{screenlet.firstRowForPage} to convert the page number
(\texttt{page}) to the page's start and end indices. You must also pass
the initializer any other properties it needs, like \texttt{groupId}.
For example, \texttt{BookmarkListPageLoadInteractor}'s
\texttt{createListPageConnector} method does this to create a
\texttt{BookmarkListPageLiferayConnector} instance:

\begin{verbatim}
public override func createListPageConnector() -> PaginationLiferayConnector {
    let screenlet = self.screenlet as! BaseListScreenlet

    return BookmarkListPageLiferayConnector(
        startRow: screenlet.firstRowForPage(self.page),
        endRow: screenlet.firstRowForPage(self.page + 1),
        computeRowCount: self.computeRowCount,
        groupId: groupId,
        folderId: folderId)
}
\end{verbatim}

Next, override the \texttt{convertResult} method to convert each
\texttt{{[}String:AnyObject{]}} result into a model object. The
Screenlet calls this method once for each entity retrieved from the
server. For example, \texttt{BookmarkListPageLoadInteractor}'s
\texttt{convertResult} method converts the
\texttt{{[}String:AnyObject{]}} result into a \texttt{Bookmark} object:

\begin{verbatim}
override public func convertResult(_ serverResult: [String:AnyObject]) -> AnyObject {
    return Bookmark(attributes: serverResult)
}
\end{verbatim}

You may also want to support
\href{/docs/7-0/tutorials/-/knowledge_base/t/architecture-of-offline-mode-in-liferay-screens}{offline
mode} in your Interactor. To do so, the Interactor must override the
\texttt{cacheKey} method to return a cache key unique to your Screenlet.
For example, \texttt{BookmarkListPageLoadInteractor}'s \texttt{cacheKey}
method returns a cache key that includes the Screenlet's
\texttt{groupId} and \texttt{folderId} settings:

\begin{verbatim}
override public func cacheKey(_ op: PaginationLiferayConnector) -> String {
    return "\(groupId)-\(folderId)"
}
\end{verbatim}

Great! Next, you'll create your Screenlet's delegate.

\subsection{Creating the Delegate}\label{creating-the-delegate}

Recall that a delegate is required if you want other classes to respond
to your Screenlet's actions. Create your delegate by following the first
step in
\href{/docs/7-0/tutorials/-/knowledge_base/t/add-a-screenlet-delegate}{the
tutorial on adding a Screenlet delegate}. A list Screenlet's delegate
must also define a method for responding to a list item selection. For
example, Bookmark List Screenlet's delegate needs the following methods:

\begin{itemize}
\tightlist
\item
  \texttt{screenlet(\_:onBookmarkListResponse:)}: Returns the
  \texttt{Bookmark} results when the server call succeeds.
\item
  \texttt{screenlet(\_:onBookmarkListError:)}: Returns the
  \texttt{NSError} object when the server call fails.
\item
  \texttt{screenlet(\_:onBookmarkSelected:)}: Returns the
  \texttt{Bookmark} when a user selects it in the list.
\end{itemize}

The \texttt{BookmarkListScreenletDelegate} protocol defines these
methods:

\begin{verbatim}
@objc public protocol BookmarkListScreenletDelegate : BaseScreenletDelegate {

    optional func screenlet(screenlet: BookmarkListScreenlet,
                            onBookmarkListResponse bookmarks: [Bookmark])

    optional func screenlet(screenlet: BookmarkListScreenlet,
                            onBookmarkListError error: NSError)

    optional func screenlet(screenlet: BookmarkListScreenlet,
                            onBookmarkSelected bookmark: Bookmark)

}
\end{verbatim}

Nice work! Next, you'll create the Screenlet class.

\subsection{Creating the Screenlet
Class}\label{creating-the-screenlet-class-6}

Now that your list Screenlet's other components exist, you can create
the Screenlet class. A list Screenlet's Screenlet class must extend the
\href{https://github.com/liferay/liferay-screens/blob/master/ios/Framework/Core/Base/BaseListScreenlet/BaseListScreenlet.swift}{\texttt{BaseListScreenlet}
class} and define the configurable properties the Screenlet needs. You
should define these as \texttt{IBInspectable} properties. If you want to
support offline mode, you should also add an \texttt{offlinePolicy}
property.

For example,
\href{https://github.com/liferay/liferay-screens/blob/master/ios/Samples/Bookmark/BookmarkListScreenlet/BookmarkListScreenlet.swift}{Bookmark
List Screenlet's Screenlet class} contains the \texttt{IBInspectable}
properties \texttt{groupId}, \texttt{folderId}, and
\texttt{offlinePolicy}:

\begin{verbatim}
public class BookmarkListScreenlet: BaseListScreenlet {

    @IBInspectable public var groupId: Int64 = 0
    @IBInspectable public var folderId: Int64 = 0
    @IBInspectable public var offlinePolicy: String? = CacheStrategyType.RemoteFirst.rawValue

    ...
\end{verbatim}

Next, override the \texttt{createPageLoadInteractor} method to create
and return the Interactor. If your Screenlet supports offline mode, you
should also use \texttt{offlinePolicy} to pass a
\texttt{CacheStrategyType} object to the Interactor. For example, the
\texttt{createPageLoadInteractor} method in
\texttt{BookmarkListScreenlet} creates and returns a
\texttt{BookmarkListPageLoadInteractor} instance. This method also sets
the Interactor's \texttt{cacheStrategy} property to a
\texttt{CacheStrategyType} object created with \texttt{offlinePolicy}:

\begin{verbatim}
override public func createPageLoadInteractor(
    page page: Int, 
    computeRowCount: Bool) -> BaseListPageLoadInteractor {

    let interactor = BookmarkListPageLoadInteractor(screenlet: self,
                                                    page: page,
                                                    computeRowCount: computeRowCount,
                                                    groupId: self.groupId,
                                                    folderId: self.folderId)

    interactor.cacheStrategy = CacheStrategyType(rawValue: self.offlinePolicy ?? "") ?? .RemoteFirst

    return interactor
}
\end{verbatim}

Now get a reference to your delegate. The \texttt{BaseScreenlet} class,
which \texttt{BaseListScreenlet} extends, already defines the
\texttt{delegate} property for the delegate object. Every list Screenlet
therefore has this property, and any app developer using the Screenlet
can access it. To avoid casting this property to your delegate every
time you use it, add a computed property to your Screenlet class that
does so. For example, the following \texttt{bookmarkListDelegate}
property in \texttt{BookmarkListScreenlet} casts the \texttt{delegate}
property to \texttt{BookmarkListScreenletDelegate}:

\begin{verbatim}
public var bookmarkListDelegate: BookmarkListScreenletDelegate? {
    return delegate as? BookmarkListScreenletDelegate
}
\end{verbatim}

Next, override the \texttt{BaseListScreenlet} methods that handle the
Screenlet's events. Because these events correspond to the events your
delegate methods handle, you'll call your delegate methods in these
\texttt{BaseListScreenlet} methods:

\begin{itemize}
\item
  \texttt{onLoadPageResult}: Called when the Screenlet loads a page
  successfully. Override this method to call your delegate's
  \texttt{screenlet(\_:onBookmarkListResponse:)} method. For example,
  here's \texttt{BookmarkListScreenlet}'s \texttt{onLoadPageResult}
  method:

\begin{verbatim}
  override public func onLoadPageResult(page page: Int, rows: [AnyObject], rowCount: Int) {
      super.onLoadPageResult(page: page, rows: rows, rowCount: rowCount)

      bookmarkListDelegate?.screenlet?(screenlet: self, onBookmarkListResponse: rows as! [Bookmark])
  }
\end{verbatim}
\item
  \texttt{onLoadPageError}: Called when the Screenlet fails to load a
  page. Override this method to call your delegate's
  \texttt{screenlet(\_:onBookmarkListError:)} method. For example,
  here's \texttt{BookmarkListScreenlet}'s \texttt{onLoadPageError}
  method:

\begin{verbatim}
  override public func onLoadPageError(page page: Int, error: NSError) {
      super.onLoadPageError(page: page, error: error)

      bookmarkListDelegate?.screenlet?(screenlet: self, onBookmarkListError: error)
  }
\end{verbatim}
\item
  \texttt{onSelectedRow}: Called when an item is selected in the list.
  Override this method to call your delegate's
  \texttt{screenlet(\_:onBookmarkSelected:)} method. For example, here's
  \texttt{BookmarkListScreenlet}'s \texttt{onSelectedRow} method:

\begin{verbatim}
  override public func onSelectedRow(_ row: AnyObject) {
      bookmarkListDelegate?.screenlet?(screenlet: self, onBookmarkSelected: row as! Bookmark)
  }
\end{verbatim}
\end{itemize}

Awesome! You're done! Your list Screenlet, like any other Screenlet, is
a ready-to-use component that you can add to your storyboard. You can
even
\href{/docs/7-0/tutorials/-/knowledge_base/t/packaging-ios-themes}{package
it using the same steps you use to package a Theme}, and then contribute
it to the Liferay Screens project or distribute it with CocoaPods.

\subsection{Related Topics}\label{related-topics-92}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-ios-screenlets}{Creating
iOS Screenlets}

\href{/docs/7-0/tutorials/-/knowledge_base/t/supporting-multiple-themes-in-your-screenlet}{Supporting
Multiple Themes in Your Screenlet}

\href{/docs/7-0/tutorials/-/knowledge_base/t/create-and-use-a-connector-with-your-screenlet}{Create
and Use a Connector with Your Screenlet}

\href{/docs/7-0/tutorials/-/knowledge_base/t/add-a-screenlet-delegate}{Add
a Screenlet Delegate}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-and-using-your-screenlets-model-class}{Creating
and Using Your Screenlet's Model Class}

\href{/docs/7-0/tutorials/-/knowledge_base/t/using-custom-cells-with-list-screenlets}{Using
Custom Cells with List Screenlets}

\href{/docs/7-0/tutorials/-/knowledge_base/t/sorting-your-list-screenlet}{Sorting
Your List Screenlet}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-complex-lists-in-your-list-screenlet}{Creating
Complex Lists in Your List Screenlet}

\href{/docs/7-0/tutorials/-/knowledge_base/t/architecture-of-liferay-screens-for-ios}{Architecture
of Liferay Screens for iOS}

\section{Using Custom Cells with List
Screenlets}\label{using-custom-cells-with-list-screenlets}

In most list Screenlets, including those that come with Liferay Screens,
the Default Theme uses the default cells in
\href{https://developer.apple.com/reference/uikit/uitableview}{iOS's
\texttt{UITableView}} to show the list.
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-ios-themes\#creating-the-view}{The
Theme creation steps} in the list Screenlet creation tutorial also
instruct you to use these cells. You can, however, use custom cells to
tailor the list to your needs. To do this, you must
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-ios-themes}{create
an extended Theme} from a Theme that uses \texttt{UITableView}'s default
cells. This usually means extending a list Screenlet's Default theme.
This tutorial shows you how to create such an extended Theme that
contains a custom cell for your list Screenlet. As an example, this
tutorial uses code from the sample Bookmark List Screenlet's Custom
Theme. You can refer to this Theme's finished code
\href{https://github.com/liferay/liferay-screens/tree/master/ios/Samples/Bookmark/BookmarkListScreenlet/Themes/TableView}{here
in GitHub} at any time.

Note that besides creating your custom cell, this tutorial follows the
same basic steps as the
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-ios-themes}{Theme
creation tutorial} for creating an extended Theme. For example, you must
still
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-ios-themes\#determining-your-themes-location}{determine
where to create your Theme}, and create your Theme's XIB and View class.

First, you'll create your Theme's custom cell.

\subsection{Creating Your Custom Cell}\label{creating-your-custom-cell}

Once you
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-ios-themes\#determining-your-themes-location}{decide
where to create your Theme}, you can get started. First, create your
custom cell's XIB file and its companion class. Name them according to
\href{/docs/7-0/tutorials/-/knowledge_base/t/ios-best-practices\#naming-conventions}{the
naming conventions in the best practices tutorial}. After defining your
cell's UI in the XIB, create as many outlets and actions as you need in
its companion class. Also be sure to assign this class as the XIB's
custom class in Interface Builder. Note that if you want to use
different layouts for different rows, you must create an XIB file and
companion class for each.

For example, the following screenshot shows the XIB file
\texttt{BookmarkCell\_default-custom.xib} for Bookmark List Screenlet's
custom cell. This cell must show a bookmark's name and URL, so it
contains two labels.

\begin{figure}
\centering
\includegraphics{./images/screens-ios-xcode-custom-cell.png}
\caption{The XIB file for Bookmark List Screenlet's custom cell.}
\end{figure}

This XIB's custom class, \texttt{BookmarkCell\_default\_custom},
contains an outlet for each label. The \texttt{bookmark} variable also
contains a \texttt{didSet} observer that sets the bookmark's name and
URL to the respective label:

\begin{verbatim}
import UIKit

class BookmarkCell_default_custom: UITableViewCell {

    @IBOutlet weak var nameLabel: UILabel?
    @IBOutlet weak var urlLabel: UILabel?

    var bookmark: Bookmark? {
        didSet {
            nameLabel?.text = bookmark?.name
            urlLabel?.text = bookmark?.url
        }
    }

}
\end{verbatim}

Great! Now you have your custom cell. Next, you'll create the rest of
your Theme.

\subsection{Creating Your Theme's XIB and View
Class}\label{creating-your-themes-xib-and-view-class}

Now you're ready to create your Theme's XIB file and View class. Create
your XIB by copying the parent Theme's XIB and making any changes you
need. You may not need to make any changes besides the file name and
custom class name. For example, the custom cell is the only difference
between Bookmark List Screenlet's Custom and Default Themes. These
Themes' XIB files (\texttt{BookmarkListView\_default-custom.xib} and
\texttt{BookmarkListView\_default.xib}) are therefore identical besides
their name and custom class; the size and position of their UI
components are the same.

Now create your View class by extending the parent Theme's View class.
You should also add a string constant to serve as the cell ID. In a
moment, you'll use this constant to register your custom cell. For
example, the View class in Bookmark List Screenlet's Custom Theme
(\texttt{BookmarkListView\_default\_custom}) extends the Default Theme's
View class (\texttt{BookmarkListView\_default}) and defines the string
constant \texttt{BookmarkCellId}:

\begin{verbatim}
public class BookmarkListView_default_custom: BookmarkListView_default {

    let BookmarkCellId = "bookmarkCell"
    …
\end{verbatim}

Next, override the \texttt{doRegisterCellNibs} method to register your
custom cell. In this method, create a \texttt{UINib} instance for your
cell and then register it with the \texttt{UITableView} instance
(\texttt{tableView}) inherited from
\href{https://github.com/liferay/liferay-screens/blob/master/ios/Framework/Core/Base/BaseListScreenlet/TableView/BaseListTableView.swift}{the
\texttt{BaseListTableView} class}. When registering the nib file, you
must use the string constant you created earlier as the
\texttt{forCellReuseIdentifier}. For example, here's the
\texttt{doRegisterCellNibs} method in
\texttt{BookmarkListView\_default-custom}:

\begin{verbatim}
  public override func doRegisterCellNibs() {
      let nib = UINib(nibName: "BookmarkCell_default-custom", bundle: NSBundle.mainBundle())

      tableView?.registerNib(nib, forCellReuseIdentifier: BookmarkCellId)
}
\end{verbatim}

Also in your View class, override the \texttt{doGetCellId} method to
return the cell ID for each row. All you need to do in this method is
return the string constant you created earlier. For example, the
\texttt{doGetCellId} method in \texttt{BookmarkListView\_default-custom}
returns the \texttt{BookmarkCellId} constant:

\begin{verbatim}
override public func doGetCellId(row row: Int, object: AnyObject?) -> String {
    return BookmarkCellId
}
\end{verbatim}

Now override the \texttt{doFillLoadedCell} method to fill the cell with
data. Note that this method isn't called for in-progress cells; it's
only called for cells that display data. Also note that this method's
\texttt{object} argument contains the data as \texttt{AnyObject}. You
must cast this to your desired type and then set it to the appropriate
cell variable. For example, the \texttt{doFillLoadedCell} method in
\texttt{BookmarkListView\_default-custom} casts the \texttt{object}
argument to \texttt{Bookmark} and then sets it to the cell's
\texttt{bookmark} variable:

\begin{verbatim}
override public func doFillLoadedCell(row row: Int, cell: UITableViewCell, object:AnyObject) {
    if let bookmarkCell = cell as? BookmarkCell_default_custom, bookmark = object as? Bookmark {
        bookmarkCell.bookmark = bookmark
    }
}
\end{verbatim}

The typical iOS
\href{https://developer.apple.com/library/ios/documentation/UIKit/Reference/UITableViewDelegate_Protocol/}{\texttt{UITableViewDelegate}
protocol} and
\href{https://developer.apple.com/library/ios/documentation/UIKit/Reference/UITableViewDataSource_Protocol/}{\texttt{UITableViewDataSource}
protocol} methods are also available in your View class. You can
override any of them if you need to (check first to make sure they're
not already overridden). For example,
\texttt{BookmarkListView\_default-custom} implements the following
method to use a different cell height for each row:

\begin{verbatim}
public func tableView(tableView: UITableView, heightForRowAtIndexPath indexPath: NSIndexPath) -> CGFloat {
    return 80
}
\end{verbatim}

When you finish, set your View class as your XIB file's custom class.

Awesome! You're done! Now you know how to implement your own custom
cells for use in list Screenlets.

\subsection{Related Topics}\label{related-topics-93}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-ios-list-screenlets}{Creating
iOS List Screenlets}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-ios-themes}{Creating
iOS Themes}

\href{/docs/7-0/tutorials/-/knowledge_base/t/sorting-your-list-screenlet}{Sorting
Your List Screenlet}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-complex-lists-in-your-list-screenlet}{Creating
Complex Lists in Your List Screenlet}

\href{/docs/7-0/tutorials/-/knowledge_base/t/ios-best-practices}{iOS
Best Practices}

\section{Sorting Your List Screenlet}\label{sorting-your-list-screenlet}

To sort your list Screenlet, you must point it to a \emph{comparator
class} in your portal. A comparator class implements the logic that
sorts your entities. You can create your own comparator class or use
those that already exist in your portal. Once your list is sorted, you
can split it into sections. This tutorial shows you how to sort your
list Screenlet with a comparator and create sections for your sorted
list.

\noindent\hrulefill

\textbf{Note:} To create a new comparator, you must create a class that
extends the portal's
\href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/util/OrderByComparator.html}{\texttt{OrderByComparator}
class} with your entity as a type argument. Then you must override the
methods that implement the sort. For example, the portal's
\href{https://github.com/liferay/liferay-portal/blob/7.0.x/modules/apps/collaboration/bookmarks/bookmarks-api/src/main/java/com/liferay/bookmarks/util/comparator/EntryURLComparator.java}{\texttt{EntryURLComparator}
class} sorts bookmarks in Liferay's Bookmarks portlet by URL.

\noindent\hrulefill

First, you'll learn how to use a comparator to sort your list Screenlet.

\subsection{Using a Comparator}\label{using-a-comparator}

To use a comparator, you must set the list Screenlet's
\texttt{obcClassName} property to the comparator's fully qualified class
name. Do this in Interface Builder when inserting the Screenlet in an
app, just as you would set any other Screenlet property. For example, to
set the sample Bookmark List Screenlet to sort its list of bookmarks by
URL, you must set \emph{Obc Class Name} to
\emph{com.liferay.bookmarks.util.comparator.EntryURLComparator} in
Interface Builder:

\begin{figure}
\centering
\includegraphics{./images/screens-ios-obc-ib.png}
\caption{To use a comparator, set the \emph{Obc Class Name} property in
Interface Builder to the comparator's fully qualified class name.}
\end{figure}

That's it! Note that although all list Screenlets inherit the
\texttt{obcClassName} property from
\href{https://github.com/liferay/liferay-screens/blob/develop/ios/Framework/Core/Base/BaseListScreenlet/BaseListScreenlet.swift}{the
\texttt{BaseListScreenlet} class}, the list Screenlet must also make its
service call with this property. See the
\href{/docs/7-0/reference/-/knowledge_base/r/screenlets-in-liferay-screens-for-ios}{Screenlet
reference documentation} to see which list Screenlets included with
Liferay Screens support the \texttt{obcClassName} property. Also,
Liferay DXP's comparator classes can change between versions. If you're
using one of these comparators, make sure you specify the one that
matches your Liferay DXP version.

\subsection{Create Sections for Your
List}\label{create-sections-for-your-list}

Dividing lists into sections that contain like elements is common in iOS
apps. To do this in list Screenlets, first use a comparator to sort the
list by the criteria you'll use to create the sections. Then override
the
\href{https://github.com/liferay/liferay-screens/blob/master/ios/Samples/Bookmark/BookmarkListScreenlet/Interactor/BookmarkListPageLoadInteractor.swift}{\texttt{BookmarkListPageLoadInteractor}
class's} \texttt{sectionForRowObject} method in your list Screenlet's
Interactor. This method is called for each item in the list and should
return the information necessary to place the item in a section. For
example,
\href{https://github.com/liferay/liferay-screens/blob/master/ios/Samples/Bookmark/BookmarkListScreenlet/Interactor/BookmarkListPageLoadInteractor.swift}{the
sample Bookmark List Screenlet's Interactor} overrides the
\texttt{sectionForRowObject} method to group results by hostname:

\begin{verbatim}
public override func sectionForRowObject(object: AnyObject) -> String? {
    guard let bookmark = object as? Bookmark else {
        return nil
    }

    let host = NSURL(string: bookmark.url)?.host?.lowercaseString

    return host?.stringByReplacingOccurrencesOfString("www.", withString: "")
}
\end{verbatim}

Note that this only produces predictable results when Bookmark List
Screenlet is sorted by \texttt{EntryURLComparator} as detailed in the
preceding section.

And that's all there is to it! Now you know how to sort and section your
list Screenlet's list.

\subsection{Related Topics}\label{related-topics-94}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-ios-list-screenlets}{Creating
iOS List Screenlets}

\href{/docs/7-0/tutorials/-/knowledge_base/t/using-custom-cells-with-list-screenlets}{Using
Custom Cells with List Screenlets}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-complex-lists-in-your-list-screenlet}{Creating
Complex Lists in Your List Screenlet}

\href{/docs/7-0/tutorials/-/knowledge_base/t/ios-best-practices}{iOS
Best Practices}

\section{Creating Complex Lists in Your List
Screenlet}\label{creating-complex-lists-in-your-list-screenlet}

Most list Screenlets' Themes use
\href{https://developer.apple.com/library/ios/documentation/UIKit/Reference/UITableView_Class/}{iOS's
\texttt{UITableView}} to display simple lists. Although
\texttt{UITableView} is great for this, it's not so great for complex
lists like grids or stacks. To create complex lists, you should use
\href{https://developer.apple.com/reference/uikit/uicollectionview}{iOS's
\texttt{UICollectionView}} in your list Screenlet's Theme.

This tutorial shows you how to create such a Theme, using
\href{https://github.com/liferay/liferay-screens/tree/master/ios/Samples/Bookmark/BookmarkListScreenlet/Themes/CollectionView}{the
sample Bookmark List Screenlet's Collection Theme} as an example. First,
you'll create the list's cell.

\subsection{Creating the Cell}\label{creating-the-cell}

You'll create your list's cell with
\href{link-to-custom-cells-tutorial}{the same sequence of steps} used to
create any list Screenlet's cell. Note, however, that how you perform
these steps is a bit different:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Define your cell's UI in a new XIB file. Because this cell is part of
  a Theme that uses \texttt{UICollectionView}, you can shape it however
  you want. For example, here's the
  \texttt{BookmarkCell\_default-collection.xib} file for the cell in
  Bookmark List Screenlet's Collection Theme. It's a simple square that
  displays the bookmark's URL and the URL's first letter.

  \begin{figure}
  \centering
  \includegraphics{./images/screens-ios-collectionview-cell.png}
  \caption{The XIB file for the cell in Bookmark List Screenlet's custom
  View.}
  \end{figure}
\item
  Create your XIB file's class by extending
  \texttt{UICollectionViewCell}. Create as many outlets and actions as
  you need for your UI components and write the logic required for your
  cell's UI to function. For example,
  \texttt{BookmarkCell\_default\_collection} is the XIB file's class in
  Bookmark List Screenlet's Custom Theme. This class extends
  \texttt{UICollectionViewCell} and contains outlets for the URL
  (\texttt{urlLabel}) and the URL's first letter (\texttt{centerLabel}).
  The \texttt{bookmark} variable's \texttt{didSet} observer sets the
  bookmark's name and URL to the respective label. Also note that the
  overridden \texttt{prepareForReuse} method resets the labels for
  reuse:

\begin{verbatim}
import UIKit
import LiferayScreens

public class BookmarkCell_default_collection: UICollectionViewCell {

    //MARK: Outlets

    @IBOutlet weak var centerLabel: UILabel?
    @IBOutlet weak var urlLabel: UILabel?

    //MARK: Public properties

    public var bookmark: Bookmark? {
        didSet {
            if let bookmark = bookmark, url = NSURL(string: bookmark.url),
                firstLetter = url.host?.remove("www.").characters.first {

                    self.centerLabel?.text = String(firstLetter).uppercaseString
                    self.urlLabel?.text = bookmark.url.remove("http://").remove("https://").remove("www.")
            }
        }
    }

    //MARK: UICollectionViewCell

    override public func prepareForReuse() {
        super.prepareForReuse()

        centerLabel?.text = "..."
        urlLabel?.text = "..."
    }
}
\end{verbatim}
\end{enumerate}

Now that your cell exists, you can create the rest of your Theme.

\subsection{Creating the Theme's XIB and View
Class}\label{creating-the-themes-xib-and-view-class}

You'll create the rest of your Theme with
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-ios-list-screenlets\#creating-the-view}{the
same sequence of steps} used to create any list Screenlet's Theme. Like
creating the cell, how you perform these steps is a bit different
because your Theme uses \texttt{UICollectionView} instead of
\texttt{UITableView}.

First, define your Theme's UI in a new XIB file. Add a
\texttt{UICollectionView} instead of a \texttt{UITableView} to this
file. For example, the
\href{https://github.com/liferay/liferay-screens/blob/master/ios/Samples/Bookmark/BookmarkListScreenlet/Themes/CollectionView/BookmarkListView_default-collection.xib}{\texttt{BookmarkListView\_default-collection.xib}
file} for Bookmark List Screenlet's Custom Theme contains a collection
view.

Next, create the View class. Instead of extending
\texttt{BaseListTableView}, this class must extend Screens's
\href{https://github.com/liferay/liferay-screens/blob/master/ios/Framework/Core/Base/BaseListScreenlet/CollectionView/BaseListCollectionView.swift}{\texttt{BaseListCollectionView}
class}. The \texttt{BaseListCollectionView} class implements most of the
code necessary to use \texttt{UICollectionView} in your Screenlet. By
extending it, you can focus on the code unique to your Screenlet. Your
View class should also contain a string constant to serve as the cell
ID. You'll use this constant when you register your cell. For example,
the View class in Bookmark List Screenlet's Collection Theme
(\texttt{BookmarkListView\_default\_collection}) extends
\texttt{BaseListCollectionView} and defines the string constant
\texttt{BookmarkCellId}:

\begin{verbatim}
public class BookmarkListView_default_collection : BaseListCollectionView {

    let BookmarkCellId = "bookmarkCell"
    …
\end{verbatim}

In Interface Builder, set this new class as the XIB's Custom Class.

Next, override the \texttt{doRegisterCellNibs} method to register the
cell you created in the previous section. In this method, create a
\texttt{UINib} instance for your cell and then register it with the
\texttt{UICollectionView} instance (\texttt{collectionView}) inherited
from \texttt{BaseListCollectionView}. When registering the nib file, you
must use the string constant you created earlier as the
\texttt{forCellReuseIdentifier}. For example, here's the
\texttt{doRegisterCellNibs} method in
\texttt{BookmarkListView\_default\_collection}:

\begin{verbatim}
public override func doRegisterCellNibs() {
    let cellNib = UINib(nibName: "BookmarkCell_default-collection", bundle: nil)
    collectionView?.registerNib(cellNib, forCellWithReuseIdentifier: BookmarkCellId)
}
\end{verbatim}

Also in your View class, override the \texttt{doGetCellId} method to
return the ID you registered the cell with. For example, the
\texttt{doGetCellId} method in
\texttt{BookmarkListView\_default\_collection} returns the string
constant \texttt{BookmarkCellId}:

\begin{verbatim}
public override func doGetCellId(indexPath indexPath: NSIndexPath, object: AnyObject?) -> String {
    return BookmarkCellId
}
\end{verbatim}

Next, override the \texttt{doFillLoadedCell} method to fill the cell
with data. This method's \texttt{object} argument contains the data as
\texttt{AnyObject}. You must cast this to your desired type and then set
it to the appropriate cell variable. For example, the
\texttt{doFillLoadedCell} method in
\texttt{BookmarkListView\_default\_collection} casts the \texttt{object}
argument to \texttt{Bookmark} and then sets it to the cell's
\texttt{bookmark} variable:

\begin{verbatim}
public override func doFillLoadedCell(
        indexPath indexPath: NSIndexPath,
        cell: UICollectionViewCell,
        object: AnyObject) {

    if let cell = cell as? BookmarkCell_default_collection, bookmark = object as? Bookmark {
        cell.bookmark = bookmark
    }
}
\end{verbatim}

Next, you'll create the layout.

\subsection{Creating the Layout}\label{creating-the-layout}

The layout object is a key part of \texttt{UICollectionView}. This
object controls the position of the UI elements, their size, and more.
To customize the layout object, override the \texttt{doCreateLayout}
method in your View class. For example, the \texttt{doCreateLayout}
method in Bookmark List Screenlet's View class
(\texttt{BookmarkListView\_default\_collection}) returns a
\texttt{UICollectionViewFlowLayout} for the layout object. This is a
basic layout that gives you a simple way to customize things like item
size, spacing between items, scroll direction, and more:

\begin{verbatim}
public override func doCreateLayout() -> UICollectionViewLayout {
    let layout = UICollectionViewFlowLayout()
    layout.itemSize = CGSize(width: 110, height: 110)
    layout.minimumLineSpacing = 10
    layout.minimumInteritemSpacing = 10

    return layout
}
\end{verbatim}

Great! You're done! You can now use your new Theme
\href{/docs/7-0/tutorials/-/knowledge_base/t/using-themes-in-ios-screenlets}{the
same way you would any other}.

If you want to package your Theme to contribute it to the Liferay
Screens project or distribute it with CocoaPods, see
\href{/docs/7-0/tutorials/-/knowledge_base/t/packaging-ios-themes}{the
tutorial on packaging Themes}.

\subsection{Related Topics}\label{related-topics-95}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-ios-list-screenlets}{Creating
iOS List Screenlets}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-ios-themes}{Creating
iOS Themes}

\href{/docs/7-0/tutorials/-/knowledge_base/t/sorting-your-list-screenlet}{Sorting
Your List Screenlet}

\href{/docs/7-0/tutorials/-/knowledge_base/t/using-custom-cells-with-list-screenlets}{Using
Custom Cells with List Screenlets}

\href{/docs/7-0/tutorials/-/knowledge_base/t/ios-best-practices}{iOS
Best Practices}

\section{Creating iOS Themes}\label{creating-ios-themes}

By creating your own Themes, you can customize your mobile app's design
and functionality. You can create them from scratch or use an existing
Theme as a foundation. Themes include a View class for implementing
Screenlet behavior and an XIB file for specifying the UI. The three
Liferay Screens Theme types support different levels of customization
and parent Theme inheritance. Here's what each Theme type offers:

\textbf{Child Theme:} presents the same UI components as its parent
Theme, but lets you change their appearance and position.

\textbf{Extended Theme:} inherits its parent Theme's functionality and
appearance, but lets you add to and modify both.

\textbf{Full Theme:} provides a complete standalone View for a
Screenlet. A full Theme is ideal for implementing functionality and
appearance completely different from a Screenlet's current Theme.

This tutorial explains how to create all three types. To understand
Theme concepts and components, you might want to examine the
\href{/docs/7-0/tutorials/-/knowledge_base/t/architecture-of-liferay-screens-for-ios}{architecture}
of Liferay Screens for iOS. The tutorial
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-ios-screenlets}{Creating
iOS Screenlets} can help you create any Screenlet classes your Theme
requires. Now get ready to create some Themes!

\subsection{Determining Your Theme's
Location}\label{determining-your-themes-location}

After determining the type of Theme to create, you need to decide where
to create it. If you want to reuse or redistribute it, you should create
it in an empty Cocoa Touch Framework project in Xcode. The
\href{/docs/7-0/tutorials/-/knowledge_base/t/packaging-ios-themes}{packaging}
tutorial explains how to package and publish with CocoaPods. If you're
not planning to reuse or redistribute your Theme, you can create it
directly inside your app project.

The rest of this tutorial explains how to create each type of Theme.
First, you'll learn how to create a Child Theme.

\subsection{Creating a Child Theme}\label{creating-a-child-theme}

In a Child Theme, you leverage a parent Theme's behavior and UI
components, but you can modify the appearance and position of the UI
components. Note that you can't add or remove any components and the
parent Theme must be a Full Theme. The Child Theme presents visual
changes with its own XIB file and inherits the parent's View class.

For example, the Child Theme in Figure 1 presents the same UI components
as the
\href{https://github.com/liferay/liferay-screens/tree/master/ios/Framework/Core/Auth/LoginScreenlet}{Login
Screenlet's} Default Theme, but enlarges them for viewing on devices
with larger screens.

\begin{figure}
\centering
\includegraphics{./images/screens-ios-xcode-child-theme.png}
\caption{The UI components are enlarged in the example Child Theme's XIB
file.}
\end{figure}

You can follow these steps to create a Child Theme:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  In Xcode, create a new XIB file that's named after the Screenlet's
  View class and your Theme. By convention, an XIB file for a Screenlet
  with a View class named \emph{FooScreenletView} and a Theme named
  \emph{BarTheme} must be named \texttt{FooScreenletView\_barTheme.xib}.
  You can use content from the parent Theme's XIB file as a foundation
  for your new XIB file. In your new XIB, you can change the UI
  components' visual properties (e.g., their position and size). You
  mustn't change, however, the XIB file's custom class, outlet
  connection, or \texttt{restorationIdentifier}--these must match those
  of the parent's XIB file.
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 The XIB file name serves as the Theme's Xcode name. For example, the Theme
 in Figure 1 inherits from the Login Screenlet's Default Theme, which uses
 the View class `LoginView_default`. The new child Theme is named *Large*
 because it's purpose is to enlarge the Screenlet's UI components. In Xcode,
 it's assigned the Theme Name *large*. The XIB file is named
 `LoginView_large.xib`, after the Login Screenlet's View class and the
 Theme's Xcode name.
\end{verbatim}

\noindent\hrulefill

You can optionally
\href{/docs/7-0/tutorials/-/knowledge_base/t/packaging-ios-themes}{package}
your Theme and/or start
\href{/docs/7-0/tutorials/-/knowledge_base/t/using-themes-in-ios-screenlets}{using}
it. Fantastic! Next, you'll learn how to create an Extended Theme.

\subsection{Extended Theme}\label{extended-theme}

An Extended Theme inherits another Theme's UI components and behavior,
but lets you add to or alter it by extending the parent Theme's View
class and creating a new XIB file. An Extended Theme's parent must be a
Full Theme. The
\href{https://github.com/liferay/liferay-screens/tree/master/ios/Framework/Themes/Flat7}{Flat7
Theme} is an Extended Theme.

These steps explain how to create an Extended Theme:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In Xcode, create a new XIB file named after the Screenlet's View class
  and your Theme. By convention, an XIB file for a Screenlet with a View
  class named \emph{FooScreenletView} and a Theme named \emph{BarTheme}
  must be named \texttt{FooScreenletView\_barTheme.xib}. You can use the
  XIB file of your parent Theme as a template. Build your UI changes in
  your new XIB file with Interface Builder.

  \begin{figure}
  \centering
  \includegraphics{./images/screens-ios-xcode-ext-theme.png}
  \caption{This example Extended Theme's XIB file extends the Login
  Portlet's UI and behavior with a switch that lets the user show or
  hide the password field value.}
  \end{figure}
\item
  Create a new View class that extends the parent Theme's View class.
  You should name this class after the XIB file you just created. You
  can add or override functionality of the parent Theme's View class.
\item
  Set your new View class as the custom class for your Theme's XIB file.
  If you added \texttt{@IBOutlet} or \texttt{@IBAction} actions, bind
  them to your class.
\end{enumerate}

Well done! You can optionally
\href{/docs/7-0/tutorials/-/knowledge_base/t/packaging-ios-themes}{package}
your Theme and/or start
\href{/docs/7-0/tutorials/-/knowledge_base/t/using-themes-in-ios-screenlets}{using}
it. Now you know how to create and use an Extended Theme. Next, you'll
learn how to create a Full Theme.

\subsection{Full Theme}\label{full-theme}

A Full Theme implements unique behavior and appearance for a Screenlet,
without using a parent Theme. Its View class must inherit Screens's
\href{https://github.com/liferay/liferay-screens/blob/master/ios/Framework/Core/Base/BaseScreenletView.swift}{\texttt{BaseScreenletView}}
and conform to the Screenlet's View Model protocol. It must also specify
a new UI in an XIB file. As you create a Full Theme, you can refer to
the tutorial
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-ios-screenlets}{Creating
iOS Screenlets} to learn how to create these classes.

Follow these steps to create a Full Theme:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a new XIB file and use Interface Builder to build your UI. By
  convention, an XIB file for a Screenlet with a View class named
  \emph{FooScreenletView} and a Theme named \emph{BarTheme} must be
  named \texttt{FooScreenletView\_barTheme.xib}. You can use the XIB
  file from the Screenlet's default Theme as a template.

  \begin{figure}
  \centering
  \includegraphics{./images/screens-ios-xcode-full-theme.png}
  \caption{This Full Theme for the Login Screenlet, includes a text
  field for entering the user name, uses the UDID for the password, and
  adds a \emph{Sign In} button with the same
  \texttt{restorationIdentifier} as the Default Theme.}
  \end{figure}
\item
  Create a new View class for your Theme named after the XIB file you
  just created. As a template, you can use the View class of your
  Screenlet's Default Theme. Your new View class must inherit
  \href{https://github.com/liferay/liferay-screens/blob/master/ios/Framework/Core/Base/BaseScreenletView.swift}{\texttt{BaseScreenletView}}
  and conform to the Screenlet's \texttt{*ScreenletViewModel} protocol,
  implementing the corresponding getters and setters. It should also add
  all the \texttt{@IBOutlet} properties or \texttt{@IBAction} methods
  you need to bind your UI components.
\item
  Set your Theme's new View class as your XIB file's custom class and
  bind any \texttt{@IBOutlet} and \texttt{@IBAction} actions to your
  class.
\end{enumerate}

Super! You can optionally
\href{/docs/7-0/tutorials/-/knowledge_base/t/packaging-ios-themes}{package}
your Theme and/or start
\href{/docs/7-0/tutorials/-/knowledge_base/t/using-themes-in-ios-screenlets}{using}
it. Now you know how to create a Full Theme. Note that a Full Theme can
serve as a parent to a Child and Extended Theme.

You've mastered Themes!

\subsection{Related Topics}\label{related-topics-96}

\href{/docs/7-0/tutorials/-/knowledge_base/t/packaging-ios-themes}{Packaging
iOS Themes}

\href{/docs/7-0/tutorials/-/knowledge_base/t/using-themes-in-ios-screenlets}{Using
Themes in iOS Screenlets}

\href{/docs/7-0/tutorials/-/knowledge_base/t/architecture-of-liferay-screens-for-ios}{Architecture
of Liferay Screens for iOS}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-ios-screenlets}{Creating
iOS Screenlets}

\section{Packaging iOS Themes}\label{packaging-ios-themes}

Once you've
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-ios-themes}{created
a Theme}, you can package it up to
\href{/docs/7-0/tutorials/-/knowledge_base/t/using-themes-in-ios-screenlets}{install
and use} with its Screenlet. Your Theme is a code library that you can
package using CocoaPods.

Follow the steps below to package your Theme for use with CocoaPods.
(Note that it's important that you use the same names and identifiers
described in these steps):

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create an empty \emph{Cocoa Touch Framework} Xcode project.

  \begin{figure}
  \centering
  \includegraphics{./images/screens-ios-cocoa-touch-framework.png}
  \caption{Choose \emph{Cocoa Touch Framework} when creating a project
  for your Theme.}
  \end{figure}
\item
  Name your project \texttt{LiferayScreensThemeName}, replacing
  \texttt{Name} with your Theme's name. You can specify any name, but
  it's a best practice to use your Theme's Xcode name, capitalizing its
  first letter. The entire name becomes the Theme's CocoaPods name.
\item
  Configure Liferay Screens for CocoaPods, using the steps described in
  \href{/docs/7-0/tutorials/-/knowledge_base/t/preparing-ios-projects-for-liferay-screens}{Preparing
  iOS Projects for Liferay Screens}.
\item
  Prepare your Theme's classes and resources by making sure your classes
  compile successfully in Xcode and by explicitly specifying a valid
  module for the custom class--the grayed-out \emph{Current} default
  value only suggests a module.

  \begin{figure}
  \centering
  \includegraphics{./images/screens-ios-theme-custom-module-wrong.png}
  \caption{This XIB file's custom class's module is NOT specified.}
  \end{figure}

  In the following screenshot, the setting for the custom class is
  correct:

  \begin{figure}
  \centering
  \includegraphics{./images/screens-ios-theme-custom-module-right.png}
  \caption{The XIB file is bound to the custom class name, with the
  specified module.}
  \end{figure}
\item
  In your project's root folder, add a file named
  \texttt{LiferayScreensTheme-Name.podspec} (change \texttt{Name} to
  your Theme's CocoaPods name--the value you used to replace
  \texttt{Name} in step 2). Note: you must start your the
  \texttt{.podspec} file's name and the project's name with
  \texttt{LiferayScreens}.

  Add the following content to the file:

\begin{verbatim}
Pod::Spec.new do |s|
    s.name = 'LiferayScreensThemeName'
    s.version = '1.0'
    s.summary = 'Your theme description'
    s.source = {
        :git => 'https://your_repository_url.git',
        :tag => 'v1.0'
    }

    s.platform = :ios, '8.0'
    s.requires_arc = true

    s.source_files = 'Your/Relative/Folder/**/*.{h,m,swift}'
    s.resources = 'Your/Relative/Folder/**/*.{xib,png,plist,lproj}'

    s.dependency 'LiferayScreens'
end
\end{verbatim}

  Make the following substitutions in the \texttt{.podspec} file:

  \begin{itemize}
  \tightlist
  \item
    Replace \texttt{Name} in \texttt{LiferayScreensThemeName}, with your
    Theme's CocoaPods name--the value you used to replace \texttt{Name}
    in step 2.
  \item
    Replace \texttt{your\_repository\_url} with your repository's URL.
  \item
    Replace \texttt{Your/Relative/Folder/} with the path to your source
    and resource files.
  \end{itemize}
\item
  Commit your changes and push your project's branch to your Git
  repository.
\end{enumerate}

Your Theme is now available for other developers to pull from your Git
repository. You can, alternatively, publish your Theme as a public Pod.
For instructions, see the chapter \emph{Deploying a library} in the
\href{https://guides.cocoapods.org/making/getting-setup-with-trunk.html\#deploying-a-library}{official
CocoaPods guide}.

Developers can now use your Theme by adding the following line to their
app's \texttt{Podfile}; they must, of course, change \texttt{Name} to
the Theme's CocoaPods name and \texttt{your\_repository\_url} to your
repository's URL:

\begin{verbatim}
pod 'LiferayScreensThemeName', :git => 'https://your_repository_url.git'
\end{verbatim}

Nice work! Now you know how to package and distribute Screenlet Themes
with CocoaPods.

\textbf{Related Topics}

\href{/docs/7-0/tutorials/-/knowledge_base/t/using-themes-in-ios-screenlets}{Using
Themes in iOS Screenlets}

\href{/docs/7-0/tutorials/-/knowledge_base/t/architecture-of-liferay-screens-for-ios}{Architecture
of Liferay Screens for iOS}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-ios-themes}{Creating
iOS Themes}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-ios-screenlets}{Creating
iOS Screenlets}

\href{/docs/7-0/tutorials/-/knowledge_base/t/preparing-android-projects-for-liferay-screens}{Preparing
Android Projects for Liferay Screens}

\section{Accessing the Liferay Session in
iOS}\label{accessing-the-liferay-session-in-ios}

A session is a conversation state between the client and server. It
typically consists of multiple requests and responses between the two.
To facilitate this communication, the session must have the server IP
address, and a user's login credentials. Liferay Screens uses a Liferay
Session to access and query the JSON web services provided by Liferay
Portal. When you log in using a Liferay Session, the portal returns the
user's information (name, email, user ID, etc\ldots). Screens stores
this information and the active Liferay Session in Screens's
\texttt{SessionContext} class.

The \texttt{SessionContext} class is very powerful and lets you use
Screens in many different scenarios. For example, you can use
\texttt{SessionContext} to request information with the JSON WS API
provided by Liferay, or with the Liferay Mobile SDK. You can also use
\texttt{SessionContext} to create anonymous sessions, or log in a user
without showing Login Screenlet.

This tutorial explains some common \texttt{SessionContext} use cases,
and also describes the class's most important methods.

\subsection{Getting the current
session}\label{getting-the-current-session}

The current session is established after the user successfully logs in
with Login Screenlet. Use \texttt{SessionContext.currentContext} to
retrieve the session. Note this will return \texttt{nil} if the user
didn't sign in with Login Screenlet. You can also use the
\texttt{SessionContext} property \texttt{isLoggedIn} to determine if a
session exists. This returns \texttt{false} if there's no current
session.

\subsection{Creating a Liferay
Session}\label{creating-a-liferay-session}

When working with Liferay Screens, you may wish to call the remote JSON
web services provided by the Liferay Mobile SDK. Every operation with
the Liferay Mobile SDK needs a Liferay Session to provide the server
address, user credentials, and any other required parameters. Login
Screenlet creates a session when a user successfully logs in. You can
retrieve this session with the \texttt{SessionContext} method
\texttt{createRequestSession()}. Typically, you call this method through
the \texttt{currentContext} object. For example:

\begin{verbatim}
SessionContext.currentContext?.createRequestSession()
\end{verbatim}

You can then use the session to make the Mobile SDK service call. If you
need to check first to see if a user has logged in, you can use the
\texttt{SessionContext} property \texttt{isLoggedIn}.

Great! Now you know how to retrieve an existing session in your app. But
what if you're not using Login Screenlet? There won't be an existing
session to retrieve. No sweat! You can still use \texttt{SessionContext}
to create one manually. The next section shows you how to do this.

\subsection{Creating a Session
Manually}\label{creating-a-session-manually-1}

If you don't use Login Screenlet, then \texttt{SessionContext} doesn't
have a session for you to retrieve. In this case, you must create one
manually. You can do this with the \texttt{SessionContext} method
\texttt{loginWithBasic}. The method takes a username, password, and user
attributes as parameters, and creates a session with those credentials.
The following code uses \texttt{loginWithBasic} to create a session:

\begin{verbatim}
Session session = SessionContext.loginWithBasic(username: USERNAME, password: PASSWORD, userAttributes: [:]);
\end{verbatim}

For the \texttt{userAttributes} parameter, you must provide some
attributes associated with the logged in user, such as their
\texttt{userId}. For a complete list of attributes, see the
\href{https://docs.liferay.com/portal/6.2/javadocs/com/liferay/portal/model/User.html}{user
model interface}.

Super! Now you know how to create a session manually. The next section
shows you how to implement auto-login, and save or restore a session.

\subsection{Implementing Auto-login and Saving or Restoring a
Session}\label{implementing-auto-login-and-saving-or-restoring-a-session-1}

Although Login Screenlet is awesome, your users may not want to enter
their credentials every time they open your app. It's very common for
apps to only require a single login. To implement this in your app, see
\href{https://www.youtube.com/watch?v=kEZEahTzuck}{this video}.

In short, you need to set \texttt{saveCredentials} to \texttt{true} in
Login Screenlet. The next login then uses the saved credentials. To make
sure this also works when the app restarts, you must retrieve the stored
credentials by using the \texttt{SessionContext} method
\texttt{loadStoredCredentials}. The following Swift code shows a typical
implementation of this:

\begin{verbatim}
if SessionContext.loadStoredCredentials() {
    // user auto-logged in
    // consider doing a relogin here (see next section)
}
else {
    // send user to login screen with the login screenlet
}
\end{verbatim}

Awesome! Now you know how to implement auto-login in your Liferay
Screens apps. For more information on available \texttt{SessionContext}
methods, see the
\href{/docs/7-0/tutorials/-/knowledge_base/t/accessing-the-liferay-session-in-ios\#methods}{Methods
section} at the end of this tutorial. Next, you'll learn how to
implement relogin for cases where a user's credentials change on the
server while they're logged in.

\subsection{Implementing Relogin}\label{implementing-relogin-1}

A session, whether created via Login Screenlet or auto-login, contains
basic user data that verifies the user in the Liferay instance. If that
data changes in the server, then your session is outdated, which may
cause your app to behave inconsistently. Also, if a user is deleted,
deactivated, or otherwise changes their credentials in the server, the
auto-login feature won't deny access because it doesn't perform server
transactions: it only retrieves an existing session from local storage.
This isn't an optimal situation!

For such scenarios, you can use the relogin feature. This feature is
implemented in a method that determines if the current session is still
valid. If the session is still valid, the user's data is updated with
the most recent data from the server. If the session isn't valid, the
user is logged out and must then log in again to create a new session.

To this feature, call the \texttt{SessionContext.currentContext} method
\texttt{relogin}:

\begin{verbatim}
SessionContext.currentContext?.relogin(closure)
\end{verbatim}

Note that this operation is done asynchronously in a background thread.
The \texttt{closure} argument is a function that eventually receives the
new user attributes. In case of error, the closure is called with
\texttt{nil} attributes and the user is logged out of the session. The
typical Swift code for a full relogin is as follows. Note a trailing
closure is used:

\begin{verbatim}
SessionContext.currentContext?.relogin { userAttributes in
    if userAttributes == nil {
        // couldn't retrieve the user attributes: user invalidated or password changed?
    }
    else {
        // full re-login made. Everything is updated
    }
}
\end{verbatim}

Great! Now you know how to implement relogin in your app. You've also
seen how handy \texttt{SessionContext} can be. It can do even more! The
next section lists some additional \texttt{SessionContext} methods, and
some more detail on the ones used in this tutorial.

\subsection{Methods}\label{methods-1}

\noindent\hrulefill

Method \textbar{} Return Type \textbar{} Explanation \textbar{}
\texttt{logout()} \textbar{} \texttt{void} \textbar{} Clears the stored
user attributes and session. \textbar{} \texttt{relogin(closure)}
\textbar{} \texttt{void} \textbar{} Refreshes user data from the server.
This recreates \texttt{currentContext} if successful, or calls
\texttt{logout()} on failure. When the server data is received, the
closure is called with received user's attributes. If an error occurs,
the closure is called with \texttt{nil}. \textbar{}
\texttt{loginWithBasic(username,\ password,\ userAttributes)} \textbar{}
\texttt{LRSession} \textbar{} Creates a Liferay Session using the
default server, and the supplied username, password, and user
information. \textbar{}
\texttt{loginWithOAuth(authentication,\ userAttributes)} \textbar{}
\texttt{LRSession} \textbar{} Creates a Liferay Session using the
default server and the supplied OAuth tokens. This is intended to be
used together with the
\href{https://github.com/brunofarache/liferay-ios-sdk-oauth}{Liferay iOS
OAuth library}. \textbar{} \texttt{createRequestSession()} \textbar{}
\texttt{LRSession} \textbar{} Creates a Liferay Session based on the
current session's server and user credentials. This Liferay Session is
intended to be used for only a single request (don't reuse it).
\textbar{} \texttt{createEphemeralBasicSession(username,\ password)}
\textbar{} \texttt{LRSession} \textbar{} Creates a Liferay Session based
on the provided username and password. Note that this session isn't
stored anywhere. This is the method used to create a session for
anonymous access. Anonymous access is used by the Sign Up and Forgot
Password Screenlets. \textbar{} \texttt{userAttribute(key:\ String)}
\textbar{} \texttt{AnyObject} \textbar{} Returns a \texttt{User} object
with the server attributes of the logged-in user. This includes the
user's email, user ID, name, and portrait ID. \textbar{}
\texttt{storeCredentials()} \textbar{} \texttt{Bool} \textbar{} Stores
the current session. \textbar{} \texttt{removeStoredCredentials()}
\textbar{} \texttt{Bool} \textbar{} Clears the session and user
information from storage. \textbar{} \texttt{loadStoredCredentials()}
\textbar{} \texttt{Bool} \textbar{} Loads the session and user
information from storage. They're then used, respectively, as the
current session and user. \textbar{}

\noindent\hrulefill

\subsection{Properties}\label{properties}

\noindent\hrulefill

Property \textbar{} Type \textbar{} Explanation \textbar{}
\texttt{currentContext} \textbar{} \texttt{SessionContext} \textbar{}
The current session established through Login Screenlet, or the
\texttt{loginWithBasic} or \texttt{loginWithOAuth} methods. \textbar{}
\texttt{isLoggedIn} \textbar{} \texttt{Bool} \textbar{} Returns
\texttt{true} if \texttt{SessionContext} contains a Liferay Session.
\textbar{} \texttt{basicAuthUsername} \textbar{} \texttt{String}
\textbar{} The username used to establish the current session (if
any).\textbar{} \texttt{basicAuthPassword} \textbar{} \texttt{String}
\textbar{} The password used to establish the current session (if
any).\textbar{} \texttt{userId} \textbar{} \texttt{Number} \textbar{}
The user identifier used to establish the current session (if any).
\textbar{}

\noindent\hrulefill

For more information, see the
\href{https://github.com/liferay/liferay-screens/blob/master/ios/Framework/Core/Context/SessionContext.swift}{\texttt{SessionContext}
source code in GitHub}.

\subsection{Related Topics}\label{related-topics-97}

\href{/docs/7-0/reference/-/knowledge_base/r/loginscreenlet-for-ios}{Login
Screenlet for iOS}

\href{/docs/7-0/tutorials/-/knowledge_base/t/using-screenlets-in-ios-apps}{Using
Screenlets in iOS Apps}

\section{Adding Custom Interactors to iOS
Screenlets}\label{adding-custom-interactors-to-ios-screenlets}

Interactors are Screenlet components that implement server communication
for a specific use case. For example, the Login Screenlet's interactor
calls the Liferay Mobile SDK service that authenticates a user to the
portal. Similarly, the interactor for
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-ios-screenlets}{the
Add Bookmark Screenlet} calls the Liferay Mobile SDK service that adds a
bookmark to the Bookmarks portlet.

That's all fine and well, but what if you want to customize a
Screenlet's server call? What if you want to use a different back-end
with a Screenlet? No problem! You can implement a custom interactor for
the Screenlet. You can plug in a different interactor that makes its
server call by using custom logic or network code. To do this, you must
implement the current interactor's interface and then pass it to the
Screenlet you want to override. You should do this inside your app's
code.

In this tutorial, you'll see an example interactor that overrides the
Login Screenlet to always log in the same user, without a password.

\subsection{Implementing a Custom
Interactor}\label{implementing-a-custom-interactor-1}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Implement your custom interactor. You must inherit
  \texttt{ServerConnectorInteractor}, as shown here:

\begin{verbatim}
 class LoginCustomInteractor: ServerConnectorInteractor {

     override func createConnector() -> ServerConnector? {

         ...

         return connector
     }

 }
\end{verbatim}
\item
  Implement the optional protocol that receives a
  \texttt{customInteractorForAction}, and return your own interactor:

\begin{verbatim}
 func screenlet(screenlet: BaseScreenlet, 
         customInteractorForAction: String, 
         withSender: AnyObject?) -> Interactor? {

     return LoginCustomInteractor()
 }
\end{verbatim}
\end{enumerate}

Great! Now you know how to implement custom interactors for iOS
Screenlets.

\subsection{Related Topics}\label{related-topics-98}

\href{/docs/7-0/tutorials/-/knowledge_base/t/architecture-of-liferay-screens-for-ios}{Architecture
of Liferay Screens for iOS}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-ios-screenlets}{Creating
iOS Screenlets}

\section{Rendering Web Content in Your iOS
App}\label{rendering-web-content-in-your-ios-app}

Liferay Screens provides several ways to render
\href{/docs/7-0/user/-/knowledge_base/u/creating-web-content}{web
content} in your app. For historical reasons, web content articles are
\texttt{JournalArticle} entities in Liferay. Using Web Content Display
Screenlet is a simple and powerful way to display HTML from a
\texttt{JournalArticle} in your app. To fit your needs, this Screenlet
supports several use cases. This tutorial describes them.

\subsection{Retrieving Basic Web
Content}\label{retrieving-basic-web-content-1}

The simplest use case for Web Content Display Screenlet is to retrieve a
web content article's HTML and render it in a
\href{https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIWebView_Class/}{\texttt{UIWebView}}.
To do this, provide the web content article's ID via the \emph{Article
Id} attribute in Interface Builder. The Screenlet takes care of the
rest. This includes rendering the content to fit mobile devices,
performing any required caching, and more.

To render the content \emph{exactly} as it appears on your mobile site,
however, you must provide the CSS inline or use a template. The HTML
returned isn't aware of a Liferay instance's global CSS.

You can also modify the rendered HTML with a delegate, as explained in
the
\href{/docs/7-0/reference/-/knowledge_base/r/webcontentdisplayscreenlet-for-ios}{Web
Content Display Screenlet reference documentation}.

As you can see, this is all fairly straightforward. What could go wrong?
Famous last words. A common mistake is to use the default site ID
(\texttt{groupId}) instead of the one for the site that contains your
web content articles. To continue using a default \texttt{groupId} in
your app, but use a different one for Web Content Display Screenlet,
assign the Screenlet's \emph{Group Id} property in Interface Builder.

\subsection{Using Templates}\label{using-templates-1}

Web Content Display Screenlet can also use
\href{/docs/7-0/user/-/knowledge_base/u/designing-uniform-content}{templates}
to render web content articles. For example, your Liferay instance may
have a custom template specifically designed to display content on
mobile devices. To use a template, set the template's ID as the
Screenlet's \texttt{templateId} property (\emph{Template Id} in
Interface Builder).

Recall that structured web content in Liferay can have many templates.
You can create your own template if there's not one suitable for
displaying web content in your app.

\subsection{Rendering Structured Web
Content}\label{rendering-structured-web-content}

To render
\href{/docs/7-0/user/-/knowledge_base/u/designing-uniform-content}{structured}
web content in Web Content Display Screenlet, you must create a custom
theme capable of doing so. Also, you must create a custom theme for each
structure you want to display in your app. In this case, you may find it
convenient to create each theme inside a single parent theme and use
compound naming to indicate this relationship. For example, if you have
structures in your Liferay instance called \emph{book}, \emph{employee},
and \emph{meeting}, you must create a custom theme for each. If you
create these themes as children of another custom theme called
\emph{mytheme}, you could name them \emph{mytheme.book},
\emph{mytheme.employee}, and \emph{mytheme.meeting}.

Regardless of where you create your themes or what you name them, use
the following steps to create them:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/creating-ios-themes}{Create
  a theme} to render your web content. If you've already created your
  own theme, you can skip this step.
\item
  In your theme, create a new class called
  \texttt{WebContentDisplayView\_themeName}, extending from
  \texttt{BaseScreenletView}. This class will hold the outlets and
  actions associated with the web content's UI.
\item
  Create the UI in the \texttt{WebContentDisplayView\_themeName.xib}
  file. This file should have a \texttt{UIView} that contains the
  components you need to render the web content's structure fields. For
  example, if your structured web content contains \texttt{latitude} and
  \texttt{longitude} fields, you can use a \texttt{MKMapView} component
  to render the map point.
\item
  Once your components are ready, change the root view's class to
  \texttt{WebContentDisplayView\_themeName} (the class you created in
  the first step), and create the outlets and actions you need to manage
  your UI components.
\item
  Conform the \texttt{WebContentDisplayViewModel} protocol in the
  \texttt{WebContentDisplayView\_themeName} class. This protocol
  requires you to add the \texttt{htmlContent} and
  \texttt{recordContent} properties. The \texttt{htmlContent} property
  is intended for HTML web content; this isn't your theme's use case.
  Your theme must display structured web content; use the
  \texttt{recordContent} property for this content. In this property,
  set the structure field's value as the corresponding outlet's value.
  For example:

\begin{verbatim}
 public var htmlContent: String? {
     get {
         return nil
     }
     set {
         // not used for structured Web Contents
     }
 }

 public var recordContent: DDLRecord? {
     didSet {
         // set the outlets with record's values
         set.myOutlet.myProperty = recordContent?["my_field_name"]?.currentValueAsLabel
     }
 }
\end{verbatim}
\end{enumerate}

Next, you'll learn how to display a list of web content articles in your
app.

\subsection{Displaying a List of Web Content
Articles}\label{displaying-a-list-of-web-content-articles-1}

The preceding examples show you how to use Web Content Display Screenlet
to display a single web content article's contents in your app. But what
if you want to display a list of articles instead? No problem! You can
do this by using
\href{/docs/7-0/reference/-/knowledge_base/r/web-content-list-screenlet-for-ios}{Web
Content List Screenlet}, or
\href{/docs/7-0/reference/-/knowledge_base/r/assetlistscreenlet-for-ios}{Asset
List Screenlet}.

First, you'll learn how to use Web Content List Screenlet.

\subsubsection{Using Web Content List
Screenlet}\label{using-web-content-list-screenlet}

Web Content List Screenlet lets you retrieve and display a list of web
content articles from a web content folder. Follow these steps to use
the Screenlet:

\begin{itemize}
\item
  Insert Web Content List Screenlet in your View Controller.
\item
  Configure the \emph{Group Id} and \emph{Folder Id} properties in
  Interface Builder. The folder ID is the ID of the web content folder
  you want to display articles from. To use the root folder, use
  \texttt{0} for the Folder Id.
\item
  To receive events related to the list, conform
  \texttt{WebContentListScreenletDelegate}. The events contain the
  \texttt{WebContent} objects.
\end{itemize}

For more information on the Screenlet and its supported functionality,
see the
\href{/docs/7-0/reference/-/knowledge_base/r/web-content-list-screenlet-for-ios}{Web
Content List Screenlet reference documentation}.

\subsubsection{Using Asset List
Screenlet}\label{using-asset-list-screenlet}

Asset List Screenlet is similar to Web Content Display Screenlet in that
it can display a list of items from a Liferay instance. Asset List
Screenlet, however, displays a list of assets. Since web content is an
asset, you can use Asset List Screenlet to show a list of web content
articles. Consider the following when doing this:

\begin{itemize}
\item
  In the delegate, \texttt{screenlet:onAssetListResponse} gets an array
  of \texttt{Asset} objects that represent \texttt{WebContent} objects.
  Since \texttt{WebContent} is a child of \texttt{Asset}, you can cast
  the \texttt{Asset} objects to \texttt{WebContent}. Each
  \texttt{WebContent} object has the \texttt{html}, \texttt{structure},
  or \texttt{structuredRecord} properties.
\item
  To render Asset List Screenlet with \texttt{WebContent} objects, you
  must create your own theme. Create a class in your theme that extends
  \texttt{AssetListView\_default}, and override the
  \texttt{doFillLoadedCell} method. In this method, cast the
  \texttt{object} parameter as \texttt{WebContent} and then retrieve
  field values from the web content's \texttt{structuredRecord}
  property. If you want custom cells, you can also override the
  \texttt{doRegisterCellNibs} and \texttt{doCreateCell} methods. See the
  \href{/docs/7-0/reference/-/knowledge_base/r/assetlistscreenlet-for-ios}{Asset
  List Screenlet reference documentation} for more details on
  customizing your asset list.
\end{itemize}

\subsection{Related Topics}\label{related-topics-99}

\href{/docs/7-0/tutorials/-/knowledge_base/t/using-screenlets-in-ios-apps}{Using
Screenlets in iOS Apps}

\href{/docs/7-0/tutorials/-/knowledge_base/t/using-themes-in-ios-screenlets}{Using
Themes in iOS Screenlets}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-ios-themes}{Creating
iOS Themes}

\href{/docs/7-0/reference/-/knowledge_base/r/webcontentdisplayscreenlet-for-ios}{Web
Content Display Screenlet for iOS}

\href{/docs/7-0/reference/-/knowledge_base/r/web-content-list-screenlet-for-ios}{Web
Content List Screenlet for iOS}

\href{/docs/7-0/reference/-/knowledge_base/r/assetlistscreenlet-for-ios}{Asset
List Screenlet for iOS}

\section{Rendering Web Pages in Your iOS
App}\label{rendering-web-pages-in-your-ios-app}

The
\href{/docs/7-0/tutorials/-/knowledge_base/t/rendering-web-content-in-your-ios-app}{Rendering
Web Content} tutorial shows you how to display
\href{/docs/7-0/user/-/knowledge_base/u/creating-web-content}{web
content} from a Liferay DXP site in your iOS app. Displaying content is
great, but what if you want to display an entire page? No problem!
\href{/docs/7-0/reference/-/knowledge_base/r/web-screenlet-for-ios}{Web
Screenlet} lets you display any web page. You can even customize the
page by injecting local or remote JavaScript and CSS files. When
combined with Liferay DXP's server-side customization features (e.g.,
\href{/docs/7-0/user/-/knowledge_base/u/styling-apps-with-application-display-templates}{Application
Display Templates}), Web Screenlet gives you almost limitless
possibilities for displaying web pages in your iOS apps.

In this tutorial, you'll learn how to use Web Screenlet to display web
pages in your iOS app.

\subsection{Inserting Web Screenlet in Your
App}\label{inserting-web-screenlet-in-your-app-1}

Inserting Web Screenlet in your app is the same as
\href{/docs/7-0/tutorials/-/knowledge_base/t/using-screenlets-in-ios-apps\#inserting-and-configuring-screenlets-in-ios-apps}{inserting
any Screenlet in your app}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In Interface Builder, insert a new view (\texttt{UIView}) in a new
  view controller. This new view should be nested under the view
  controller's existing view.
\item
  With the new view selected, open the Identity inspector and set the
  view's Custom Class to \texttt{WebScreenlet}.
\item
  Set any constraints that you want for the Screenlet in the scene.
\end{enumerate}

The exact steps for configuring Web Screenlet are unique to Web
Screenlet. First, you'll conform your view controller to Web Screenlet's
delegate protocol.

\subsection{Conforming to Web Screenlet's Delegate
Protocol}\label{conforming-to-web-screenlets-delegate-protocol}

To use any Screenlet, you must conform the class of the view controller
that contains it to the Screenlet's delegate protocol. Web Screenlet's
delegate protocol is \texttt{WebScreenletDelegate}. Follow these steps
to conform your view controller to \texttt{WebScreenletDelegate}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Import \texttt{LiferayScreens} and set your view controller to adopt
  the \texttt{WebScreenletDelegate} protocol:

\begin{verbatim}
import UIKit
import LiferayScreens

class ViewController: UIViewController, WebScreenletDelegate {...
\end{verbatim}
\item
  Implement the \texttt{WebScreenletDelegate} method
  \texttt{onWebLoad(\_:url:)}. This method is called when the Screenlet
  loads the page successfully. How you implement it depends on what (if
  anything) you want to happen upon page load. Its arguments are the
  \texttt{WebScreenlet} instance and the page URL. This example prints a
  message to the console indicating that the page was loaded:

\begin{verbatim}
func onWebLoad(_ screenlet: WebScreenlet, url: String) {
    // Called when the page is loaded
    print("\(url) was just loaded")
}
\end{verbatim}
\item
  Implement the \texttt{WebScreenletDelegate} method
  \texttt{screenlet(\_:onError:)}. This method is called when an error
  occurs loading the page, and therefore includes the \texttt{NSError}
  object. This lets you log or print the error. For example, this
  implementation prints a message containing the error's description:

\begin{verbatim}
func screenlet(_ screenlet: WebScreenlet, onError error: NSError) {
    print("Failed to load the page: \(error.localizedDescription)")
}
\end{verbatim}
\item
  Implement the \texttt{WebScreenletDelegate} method
  \texttt{screenlet(\_:onScriptMessageNamespace:onScriptMessage:)}. This
  method is called when
  \href{https://developer.apple.com/documentation/webkit/wkwebview}{the
  Screenlet's \texttt{WKWebView}} sends a message. This method's
  arguments include the message's namespace and the message. How you
  implement this method depends on what you want to happen when the
  message is sent. For example, you could perform a segue and include
  the message as the segue's \texttt{sender}:

\begin{verbatim}
func screenlet(_ screenlet: WebScreenlet,
    onScriptMessageNamespace namespace: String,
    onScriptMessage message: String) {

    performSegue(withIdentifier: "detail", sender: message)
}
\end{verbatim}
\item
  Get a reference to the Web Screenlet on your storyboard by using
  Interface Builder to create an outlet to it in your view controller.
  It's a best practice to name a Screenlet outlet after the Screenlet it
  references, or simply \texttt{screenlet}. Here's an example Web
  Screenlet outlet:

\begin{verbatim}
@IBOutlet weak var webScreenlet: WebScreenlet?
\end{verbatim}
\item
  In the view controller's \texttt{viewDidLoad()} method, use the Web
  Screenlet reference you just created to set the view controller as the
  Screenlet's delegate. To do this, add the following line of code just
  below the \texttt{super.viewDidLoad()} call:

\begin{verbatim}
self.webScreenlet?.delegate = self
\end{verbatim}
\end{enumerate}

Next, you'll use the same Web Screenlet reference to set the Screenlet's
parameters.

\subsection{Setting Web Screenlet's
Parameters}\label{setting-web-screenlets-parameters-1}

Web Screenlet has \texttt{WebScreenletConfiguration} and
\texttt{WebScreenletConfigurationBuilder} objects that supply the
parameters the Screenlet needs to work. These parameters include the URL
of the page to load and the location of any JavaScript or CSS files that
customize the page. You'll set most of these parameters via
\texttt{WebScreenletConfigurationBuilder}'s methods.

\noindent\hrulefill

\textbf{Note:} For a full list of
\texttt{WebScreenletConfigurationBuilder}'s methods, and a description
of each, see the table in
\href{/docs/7-0/reference/-/knowledge_base/r/web-screenlet-for-ios\#configuration}{the
Configuration section} of Web Screenlet's reference doc.

\noindent\hrulefill

To set Web Screenlet's parameters, follow these steps in the
\texttt{viewDidLoad()} method of a view controller that uses Web
Screenlet:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Use
  \texttt{WebScreenletConfigurationBuilder(\textless{}url\textgreater{})},
  where \texttt{\textless{}url\textgreater{}} is the web page's URL
  string, to create a \texttt{WebScreenletConfigurationBuilder} object.
  If the page requires Liferay DXP authentication, then the user must be
  logged in via
  \href{/docs/7-0/reference/-/knowledge_base/r/loginscreenlet-for-ios}{Login
  Screenlet} or a \texttt{SessionContext} method, and you must provide a
  relative URL to the \texttt{WebScreenletConfigurationBuilder}
  constructor. For example, if such a page's full URL is
  \texttt{http://your.liferay.instance/web/guest/blog}, then the
  constructor's argument is \texttt{/web/guest/blog}. For any other page
  that doesn't require Liferay DXP authentication, you must supply the
  full URL to the constructor.
\item
  Call the \texttt{WebScreenletConfigurationBuilder} methods to set the
  parameters that you need.
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** If the URL you supplied to the `WebScreenletConfigurationBuilder`
 constructor is to a page that doesn't require Liferay DXP authentication, then
 you must call the `WebScreenletConfigurationBuilder` method
 `set(webType: .other)`. The default `WebType` is `.liferayAuthenticated`,
 which is required to load Liferay DXP pages that require authentication. If
 you need to set `.liferayAuthenticated` manually, call
 `set(webType: .liferayAuthenticated)`.
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\item
  Call the \texttt{WebScreenletConfigurationBuilder} instance's
  \texttt{load()} method, which returns a
  \texttt{WebScreenletConfiguration} object.
\item
  Set the \texttt{WebScreenletConfiguration} object to the Web Screenlet
  instance's \texttt{configuration} property.
\item
  Call the Web Screenlet instance's \texttt{load()} method.
\end{enumerate}

Here's an example snippet of these steps in the \texttt{viewDidLoad()}
method of a view controller in which the Web Screenlet instance is
\texttt{webScreenlet}, and the \texttt{WebScreenletConfiguration} object
is \texttt{webScreenletConfiguration}:

\begin{verbatim}
override func viewDidLoad() {
    super.viewDidLoad()

    self.webScreenlet?.delegate = self

    let webScreenletConfiguration = 
        WebScreenletConfigurationBuilder(url: "/web/westeros-hybrid/companynews")
            .addCss(localFile: "blogs")
            .addJs(localFile: "blogs")
            .load()
    webScreenlet.configuration = webScreenletConfiguration
    webScreenlet.load()
}
\end{verbatim}

The relative URL \texttt{/web/westeros-hybrid/companynews} supplied to
the \texttt{WebScreenletConfigurationBuilder} constructor, and the lack
of a \texttt{set(webType:\ .other)} call, indicates that this Web
Screenlet instance loads a Liferay DXP page that requires
authentication. The \texttt{addCss} and \texttt{addJs} calls add local
CSS and JavaScript files, respectively. Both files are named
\texttt{blogs}.

Great! Now you know how to use Web Screenlet in your iOS apps.

\subsection{Related Topics}\label{related-topics-100}

\href{/docs/7-0/reference/-/knowledge_base/r/web-screenlet-for-ios}{Web
Screenlet for iOS}

\href{/docs/7-0/tutorials/-/knowledge_base/t/using-web-screenlet-with-cordova-in-your-ios-app}{Using
Web Screenlet with Cordova in Your iOS App}

\href{/docs/7-0/tutorials/-/knowledge_base/t/using-screenlets-in-ios-apps}{Using
Screenlets in iOS Apps}

\href{/docs/7-0/tutorials/-/knowledge_base/t/rendering-web-content-in-your-ios-app}{Rendering
Web Content in Your iOS App}

\section{Using Web Screenlet with Cordova in Your iOS
App}\label{using-web-screenlet-with-cordova-in-your-ios-app}

By using \href{https://cordova.apache.org/plugins/}{Cordova plugins} in
\href{/docs/7-0/tutorials/-/knowledge_base/t/rendering-web-pages-in-your-ios-app}{Web
Screenlet}, you can extend the functionality of the web page that the
Screenlet renders. This lets you tailor that page to your app's needs.
You'll get started by installing Cordova.

\subsection{Installing and Configuring Cordova
Automatically}\label{installing-and-configuring-cordova-automatically-1}

Follow these steps to automatically create an empty Android project
configured to use Cordova. Note that you must have
\href{https://git-scm.com/}{git}, \href{https://nodejs.org/en/}{Node.js
and npm}, and \href{https://cocoapods.org/}{CocoaPods} installed.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Install \texttt{screens-cli}:

\begin{verbatim}
npm install -g screens-cli
\end{verbatim}
\item
  Create the file \texttt{.plugins.screens} in the folder you want to
  create your project in. In this file, add all the Cordova plugins you
  want to use in your app. For example, you can add plugins from Cordova
  or GitHub:

\begin{verbatim}
https://github.com/apache/cordova-plugin-wkwebview-engine.git
cordova-plugin-call-number
cordova-plugin-camera
\end{verbatim}

  Note that the \texttt{WKWebView} Engine plugin is mandatory in iOS.
\item
  In the folder containing your \texttt{.plugins.screens} file, run
  \texttt{screens-cli} to create your project:

\begin{verbatim}
screens-cli ios <project-name>
\end{verbatim}

  This creates your project in the folder
  \texttt{platforms/ios/\textless{}project-name\textgreater{}}.
\item
  Run the following in
  \texttt{platforms/ios/\textless{}project-name\textgreater{}}:

\begin{verbatim}
pod install
\end{verbatim}
\item
  Open the \texttt{\textless{}project-name\textgreater{}.xcworkspace}
  file with Xcode.
\end{enumerate}

\subsection{Installing and Configuring Cordova
Manually}\label{installing-and-configuring-cordova-manually-1}

Follow these steps to install and configure Cordova:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Follow \href{https://cordova.apache.org/\#getstarted}{the Cordova
  getting started guide} to install Cordova, create a Cordova project,
  and add the iOS platform to your Cordova project.
\item
  Install the
  \href{https://www.npmjs.com/package/cordova-plugin-ionic-wkwebview-engine}{Cordova
  \texttt{WKWebView} engine}:

\begin{verbatim}
cordova plugin add cordova-plugin-wkwebview-engine
\end{verbatim}
\item
  Install any other Cordova plugins you want to use in your app. You can
  use \texttt{cordova\ plugin} to view the currently installed plugins.
\item
  Copy the following files and folders from your Cordova project to your
  iOS project's root folder:

  \begin{itemize}
  \tightlist
  \item
    \texttt{platforms/ios/\textless{}your-cordova-project\textgreater{}/config.xml}
  \item
    \texttt{platforms/ios/\textless{}your-cordova-project\textgreater{}/Plugins}
  \item
    \texttt{platforms/ios/www}
  \end{itemize}
\item
  In the \texttt{config.xml} file you just copied to your iOS project's
  root folder, add
  \texttt{\textless{}allow-navigationhref="*"\ /\textgreater{}} below
  \texttt{\textless{}access\ origin="*"\ /\textgreater{}}.
\end{enumerate}

\subsection{Using Cordova in Web
Screenlet}\label{using-cordova-in-web-screenlet-1}

Now that you've installed and configured Cordova in your iOS project,
you're ready to use it with Web Screenlet. Follow these steps to do so:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/rendering-web-pages-in-your-ios-app}{Insert
  and configure Web Screenlet in your app}.
\item
  When you set Web Screenlet's parameters via the
  \texttt{WebScreenletConfigurationBuilder} object, call the
  \texttt{enableCordova()} method. For example, this code adds a local
  JavaScript file via \texttt{addJs} and then calls
  \texttt{enableCordova()} before loading the configuration and the
  Screenlet:

\begin{verbatim}
let configuration = WebScreenletConfigurationBuilder(url: "url")
    .addJs(localFile: "call")
    .enableCordova()
    .load()

webScreenlet?.configuration = configuration
webScreenlet?.load();
\end{verbatim}
\end{enumerate}

That's it! Note, however, that you may also need to invoke Cordova from
a JavaScript file, depending on what you're doing. For example, to use
\href{https://www.npmjs.com/package/cordova-plugin-call-number}{the
Cordova plugin \texttt{cordova-plugin-call-number}} to call a number,
then you must add a JavaScript file with the following code:

\begin{verbatim}
function callNumber() {
    //This line triggers the Cordova plugin and makes a call
    window.plugins.CallNumber.callNumber(null, function(){ alert("Calling failed.") }, "900000000", true);
}

setTimeout(callNumber, 3000);
\end{verbatim}

If you run the app containing this code and wait three seconds, the
plugin activates and calls the number in the JavaScript file.

Great! Now you know how to use Web Screenlet with Cordova.

\subsection{Related Topics}\label{related-topics-101}

\href{/docs/7-0/tutorials/-/knowledge_base/t/rendering-web-pages-in-your-ios-app}{Rendering
Web Pages in Your iOS App}

\href{/docs/7-0/reference/-/knowledge_base/r/web-screenlet-for-ios}{Web
Screenlet for iOS}

\section{iOS Best Practices}\label{ios-best-practices}

When developing iOS projects with Liferay Screens, there are a few best
practices that you should follow to ensure your code is as clean and
bug-free as possible. This tutorial lists these. Note that this tutorial
doesn't cover Swift coding conventions for contributing to the Liferay
Screens project on GitHub.
\href{https://github.com/liferay/liferay-screens/blob/master/ios/swift-style-guide.md}{Click
here} to see these.

\subsection{Naming Conventions}\label{naming-conventions-1}

Using the naming conventions described here leads to consistency and a
better understanding of the Screens library. This makes working with
your Screenlets much simpler.

\subsubsection{Screenlet Folder}\label{screenlet-folder-1}

Your Screenlet folder's name should indicate your Screenlet's
functionality. For example,
\href{https://github.com/liferay/liferay-screens/tree/master/ios/Framework/Core/Auth/LoginScreenlet}{Login
Screenlet's folder is named \texttt{LoginScreenlet}}.

If you have multiple Screenlets that operate on the same entity, you can
place them inside a folder named for that entity. For example,
\href{/docs/7-0/reference/-/knowledge_base/r/asset-display-screenlet-for-ios}{Asset
Display Screenlet} and
\href{/docs/7-0/reference/-/knowledge_base/r/assetlistscreenlet-for-ios}{Asset
List Screenlet} both work with Liferay assets. They're therefore in the
Screens library's
\href{https://github.com/liferay/liferay-screens/tree/master/ios/Framework/Core/Asset}{\texttt{Asset}
folder}.

\subsubsection{Screenlets}\label{screenlets-1}

Naming Screenlets properly is very important; they're the main focus of
Liferay Screens. Your Screenlet should be named with its principal
action first, followed by \emph{Screenlet}. Its Screenlet class should
also follow this pattern. For example,
\href{/docs/7-0/reference/-/knowledge_base/r/loginscreenlet-for-ios}{Login
Screenlet's} principal action is to log users into a Liferay instance.
Its Screenlet class is \texttt{LoginScreenlet}.

\subsubsection{View Models}\label{view-models-1}

You should place View Models in your Screenlet's root folder and name
them after your Screenlet. For example,
\href{/docs/7-0/reference/-/knowledge_base/r/forgotpasswordscreenlet-for-ios}{Forgot
Password Screenlet's} View Model is in the
\href{https://github.com/liferay/liferay-screens/tree/master/ios/Framework/Core/Auth/ForgotPasswordScreenlet}{\texttt{ForgotPasswordScreenlet}
folder} and is named \texttt{ForgotPasswordViewModel}.

\subsubsection{Interactors}\label{interactors-1}

You should place your Screenlet's Interactors in a folder named
\texttt{Interactors} in your Screenlet's root folder. You should name
each Interactor with its action first, followed by \emph{Interactor}.
For example,
\href{/docs/7-0/reference/-/knowledge_base/r/rating-screenlet-for-ios}{Rating
Screenlet} has three Interactors in
\href{https://github.com/liferay/liferay-screens/tree/master/ios/Framework/Core/Rating/Interactors}{its
\texttt{Interactors} folder}:

\begin{itemize}
\tightlist
\item
  \texttt{DeleteRatingInteractor}: Deletes an asset's ratings
\item
  \texttt{LoadRatingsInteractor}: Loads an asset's ratings
\item
  \texttt{UpdateRatingInteractor}: Updates an asset's ratings
\end{itemize}

\subsubsection{Connectors}\label{connectors}

Name your Connectors with the same naming conventions as Interactors,
replacing \emph{Interactor} with \emph{Connector}. If your Connector
calls a Liferay service, precede \emph{Connector} with \emph{Liferay}.
For example,
\href{https://github.com/liferay/liferay-screens/blob/master/ios/Framework/Core/Comment/Add/Connectors/CommentAddLiferayConnector.swift}{the
Connector \texttt{CommentAddLiferayConnector}} adds comments to an asset
in a Liferay instance. A Connector that retrieves a webpage's title from
any URL would be called \texttt{GetWebsiteTitleConnector}.

\subsubsection{Themes}\label{themes-1}

Place your Screenlet's Themes in a folder named \emph{Themes} in your
Screenlet's root folder. If you're creating a group of similarly styled
Themes for multiple Screenlets, however, then you can place them in a
separate \emph{Themes} folder outside of your Screenlets' root folders.
This is what the Screens Library does for
\href{https://github.com/liferay/liferay-screens/tree/master/ios/Framework/Themes}{its
Default and Flat7 Themes}. The \texttt{Default} and \texttt{Flat7}
folders each contain similarly styled Themes for several Screenlets.
Also note that each Screenlet's Theme is in its own folder. For example,
\href{/docs/7-0/reference/-/knowledge_base/r/forgotpasswordscreenlet-for-ios}{Forgot
Password Screenlet's} Default Theme is in
\href{https://github.com/liferay/liferay-screens/tree/master/ios/Framework/Themes/Default/Auth/ForgotPasswordScreenlet}{the
folder \texttt{Themes/Default/Auth/ForgotPasswordScreenlet}}. Note that
the \texttt{Auth} folder is the Screenlet's module. Creating your
Screenlets and Themes in modules isn't required.

Recall that a Theme consists of an XIB file and a View class. Name these
after your Screenlet, but with \emph{View} instead of \emph{Screenlet}.
The filenames should also be suffixed with \texttt{\_yourThemeName}. For
example, the XIB file and View class for Forgot Password Screenlet's
Default theme are \texttt{ForgotPasswordView\_default.xib} and
\texttt{ForgotPasswordView\_default.swift}, respectively.

\subsection{Avoid Hardcoded Elements}\label{avoid-hardcoded-elements}

Using constants instead of hard coded elements is a simple way to avoid
bugs. Constants reduce the likelihood that you'll make a typo when
referring to common elements. They also gather these elements in a
single location. For example, when you
\href{/docs/7-0/tutorials/-/knowledge_base/t/adding-screenlet-actions}{add
an action to your Screenlet}, each Screenlet action used as a
\texttt{restorationIdentifier} in the View class is defined as a
constant in the Screenlet class. The Screenlet class's
\texttt{createInteractor} method then uses the constants to distinguish
between the actions. If you instead typed each action manually in both
places, a typo could break your Screenlet and would be difficult to
track down. Defining the actions in one place via constants avoids this
potentially maddening complication.

Screenlet attributes, like those listed in each Screenlet's
\href{/docs/7-0/reference/-/knowledge_base/r/screenlets-in-liferay-screens-for-ios}{reference
documentation}, are another good example of this. Although you can set
these directly in Interface Builder, it's better to set them via
constants in a \texttt{plist} file. This puts all your Screenlets'
attributes in a single location that is also subject to version control.
For instructions on setting attributes in a \texttt{plist} file,
\href{/docs/7-0/tutorials/-/knowledge_base/t/preparing-ios-projects-for-liferay-screens\#configuring-communication-with-liferay}{see
the Configuring Communication with Liferay section} of the tutorial on
preparing iOS projects for Liferay Screens.

To retrieve these values in your code, you can use the following
\texttt{LiferayServerContext} methods:

\begin{itemize}
\tightlist
\item
  \texttt{propertyForKey}: Get a property as an \texttt{AnyObject}
\item
  \texttt{numberPropertyForKey}: Get a property as an \texttt{NSNumber}.
\item
  \texttt{longPropertyForKey}: Get a property as an \texttt{Int64}.
\item
  \texttt{intPropertyForKey}: Get a property as an \texttt{Int}.
\item
  \texttt{booleanPropertyForKey}: Get a property as a \texttt{Bool}.
\item
  \texttt{datePropertyForKey}: Get a property as an \texttt{NSDate}.
\item
  \texttt{stringPropertyForKey}: Get a property as a \texttt{String}.
\end{itemize}

For example, the following code retrieves the \texttt{galleryFolderId}
value and sets it to Image Gallery Screenlet's \texttt{folderId}
attribute:

\begin{verbatim}
@IBOutlet weak var imageGalleryScreenlet: ImageGalleryScreenlet? {
    didSet {
        imageGalleryScreenlet?.delegate = self
        imageGalleryScreenlet?.presentingViewController = self

        imageGalleryScreenlet?.repositoryId = LiferayServerContext.groupId
        imageGalleryScreenlet?.folderId = LiferayServerContext.longPropertyForKey("galleryFolderId")
    }
}
\end{verbatim}

\subsection{Stay in Your Layer}\label{stay-in-your-layer-1}

When accessing variables that belong to other Screenlet components, you
should avoid those outside your current Screenlet layer. This achieves
better decoupling between the layers, which tends to reduce bugs and
simplify maintenance. For an explanation of the layers in Liferay
Screens, see
\href{/docs/7-0/tutorials/-/knowledge_base/t/architecture-of-liferay-screens-for-ios}{the
architecture tutorial}. For example, you shouldn't directly access View
variables from an Interactor. This Interactor's \texttt{start} method
gets a View instance and accesses its \texttt{title} variable:

\begin{verbatim}
public class MyInteractor: Interactor {
    override func start() -> Bool {
        if let view = self.screenlet.screenletView as? MyView {
            let title = view.title
            ...
        }
    }
}
\end{verbatim}

Instead, you should pass the variable to the Interactor's initializer.
The Interactor now contains its own \texttt{title} variable, set in its
initializer:

\begin{verbatim}
public class MyInteractor: Interactor {

    public let title: String

    //MARK: Initializer

    public init(screenlet: BaseScreenlet, title: String) {
        self.title = title
        super.init(screenlet: screenlet)
    }
}
\end{verbatim}

The Screenlet class's \texttt{createInteractor} method calls this
initializer when creating an instance of the Interactor. Also note that
the Screenlet's View Model is used to retrieve the View's
\texttt{title}. As explained in the tutorial
\href{/docs/7-0/tutorials/-/knowledge_base/t/supporting-multiple-themes-in-your-screenlet}{Supporting
Multiple Themes in Your Screenlet}, a View Model serves as an
abstraction layer for your View, which lets you use different Themes
with a Screenlet:

\begin{verbatim}
public class MyScreenlet: BaseScreenlet {
    ...
    override public func createInteractor(name name: String, sender: AnyObject?) -> Interactor? {
        let interactor = MyInteractor(self, title: viewModel.title)
        ...
    }
    ...
}
\end{verbatim}

There are, however, a few places where you can break this rule
(otherwise it wouldn't be possible for layers to interact):

\begin{itemize}
\item
  The Screenlet class's \texttt{createInteractor} method. To get the
  user's input, this method must access the View's computed properties.
\item
  The Interactor's \texttt{onSuccess} closure in the Screenlet class.
  Here, you must retrieve the Interactor's result object.
\item
  When using a Connector, the Interactor's \texttt{completedConnector}
  method. In this method, you must retrieve the Connector's result
  object.
\item
  The Screenlet class's View Model references. This is required for the
  Screenlet to communicate with the View.
\end{itemize}

\subsection{Related Topics}\label{related-topics-102}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-ios-screenlets}{Creating
iOS Screenlets}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-ios-list-screenlets}{Creating
iOS List Screenlets}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-ios-themes}{Creating
iOS Themes}

\href{/docs/7-0/tutorials/-/knowledge_base/t/supporting-multiple-themes-in-your-screenlet}{Supporting
Multiple Themes in Your Screenlet}

\href{/docs/7-0/tutorials/-/knowledge_base/t/adding-screenlet-actions}{Adding
Screenlet Actions}

\href{/docs/7-0/tutorials/-/knowledge_base/t/create-and-use-a-connector-with-your-screenlet}{Create
and Use a Connector with Your Screenlet}

\href{/docs/7-0/tutorials/-/knowledge_base/t/architecture-of-liferay-screens-for-ios}{Architecture
of Liferay Screens for iOS}

\chapter{Using Xamarin with Liferay
Screens}\label{using-xamarin-with-liferay-screens}

Liferay Screens for
\href{/docs/7-0/tutorials/-/knowledge_base/t/android-apps-with-liferay-screens}{Android}
and
\href{/docs/7-0/tutorials/-/knowledge_base/t/ios-apps-with-liferay-screens}{iOS}
lets you use \emph{Screenlets} to develop native mobile apps on each
platform. Screenlets are complete visual components that you insert in
your app to leverage Liferay DXP's content and services. As of Liferay
Screens 3.0, you can use Screenlets with
\href{https://www.xamarin.com/}{Xamarin} to develop hybrid mobile apps
for Android and iOS.

The tutorials in this section show you how to develop hybrid mobile apps
using Liferay Screens and Xamarin. You'll start by preparing your
Xamarin project for Screens. You'll then learn how to use Screenlets in
Xamarin, customize their appearance, and more.

\noindent\hrulefill

\textbf{Note:} These tutorials assume that you know how to use Xamarin.
If you need assistance with Xamarin, see
\href{https://developer.xamarin.com/}{its documentation}.

\section{Preparing Xamarin Projects for Liferay
Screens}\label{preparing-xamarin-projects-for-liferay-screens}

To use Liferay Screens with Xamarin, you must install Screens in your
Xamarin project. You must then configure your project to communicate
with your Liferay DXP instance. Note that Liferay Screens for Xamarin is
released as a
\href{https://docs.microsoft.com/en-us/nuget/what-is-nuget}{NuGet}
package hosted in
\href{https://www.nuget.org/packages/LiferayScreens}{NuGet.org}.

\noindent\hrulefill

\textbf{Note:} After installation, you must configure Liferay Screens to
communicate with your Liferay DXP instance. The last section in this
tutorial shows you how to do this.

\noindent\hrulefill

\subsection{Requirements and Example
Projects}\label{requirements-and-example-projects}

Liferay Screens for Xamarin includes the bindings necessary to use all
Screenlets included with Screens. The following software is required:

\begin{itemize}
\tightlist
\item
  Visual Studio
\item
  Android SDK 4.1 (API Level 16) or above
\item
  \href{http://www.liferay.com/downloads/liferay-portal/available-releases}{Liferay
  CE Portal 7.0/7.1, or Liferay DXP 7.0}
\item
  \href{https://www.nuget.org/packages/LiferayScreens}{Liferay Screens
  NuGet package}
\end{itemize}

Also note that if you get confused or stuck while using Screens for
Xamarin, \href{https://github.com/liferay/liferay-screens}{the official
Liferay Screens repository} contains two sample Xamarin projects that
you can reference:

\begin{itemize}
\item
  \href{https://github.com/liferay/liferay-screens/tree/develop/xamarin/Samples/Showcase-Android}{\textbf{Showcase-Android:}}
  An example app for Xamarin.Android containing all the currently
  available Screenlets.
\item
  \href{https://github.com/liferay/liferay-screens/tree/develop/xamarin/Samples/Showcase-iOS}{\textbf{Showcase-iOS:}}
  An example app for Xamarin.iOS containing all the currently available
  Screenlets.
\end{itemize}

\subsection{Securing JSON Web
Services}\label{securing-json-web-services-2}

Each Screenlet in Liferay Screens calls one or more of Liferay DXP's
JSON web services, which are enabled by default. The Screenlet reference
documentation for
\href{/docs/7-0/reference/-/knowledge_base/r/screenlets-in-liferay-screens-for-android}{Android}
and
\href{/docs/7-0/reference/-/knowledge_base/r/screenlets-in-liferay-screens-for-ios}{iOS}
lists the web services that each Screenlet calls. To use a Screenlet,
its web services must be enabled in the portal. It's possible, however,
to disable the web services needed by Screenlets you're not using. For
instructions on this, see the tutorial
\href{/docs/7-0/tutorials/-/knowledge_base/t/portal-configuration-of-json-web-services}{Configuring
JSON Web Services}. You can also use
\href{/docs/7-0/tutorials/-/knowledge_base/t/service-access-policies}{Service
Access Policies} for more fine-grained control over accessible services.

\subsection{Install Liferay Screens in Xamarin
Solutions}\label{install-liferay-screens-in-xamarin-solutions}

Follow these steps to install Liferay Screens in your Xamarin project:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open your project in Visual Studio.
\item
  Right click your project's \emph{Packages} folder and then select
  \emph{Add packages\ldots{}}.
\item
  Look for \emph{LiferayScreens} and install the latest version.
\item
  Accept the license agreements for any dependencies. These are
  necessary to use Liferay Screens in Xamarin.
\item
  Check your configuration one of these ways:

  \begin{itemize}
  \tightlist
  \item
    Rebuild and execute your project, and import a Liferay Screens path
    (e.g., \texttt{Com.Liferay.Mobile.Screens.Auth.Login}).
  \item
    In your project, select \emph{References} → \emph{From Packages} and
    look for the \texttt{LiferayScreens*} file. Open that file in the
    Assembly Browser. You should then see all the available Liferay
    Screens files.
  \end{itemize}
\end{enumerate}

Next, you'll set up communication with Liferay DXP.

\subsection{Configuring Communication with Liferay
DXP}\label{configuring-communication-with-liferay-dxp-3}

Before using Liferay Screens, you must configure your project to
communicate with your Liferay DXP instance. To do this, you must provide
your project with the following information:

\begin{itemize}
\tightlist
\item
  Your Liferay DXP instance's ID.
\item
  The ID of the Liferay DXP site your app needs to communicate with.
\item
  Your Liferay DXP instance's version.
\item
  Any other information required by specific Screenlets.
\end{itemize}

Fortunately, this is straightforward. Do the following in your Xamarin
projects:

\begin{itemize}
\item
  For Xamarin.Android, create a new file called
  \texttt{server\_context.xml} in the \texttt{Resources/values} folder.
  Add the following code to this file:

\begin{verbatim}
<?xml version="1.0" encoding="utf-8"?>
<resources>

    <!-- Change these values for your portal installation -->
    <string name="liferay_server">http://10.0.2.2:8080</string>

    <integer name="liferay_company_id">20116</integer>
    <integer name="liferay_group_id">20143</integer>

    <integer name="liferay_portal_version">70</integer>

</resources>
\end{verbatim}
\item
  For Xamarin.iOS, create a new file called
  \texttt{liferay-server-context.plist} in the \texttt{Resources}
  folder. Add the following code to this file:

\begin{verbatim}
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>server</key>
    <string>http://localhost:8080</string>
    <key>version</key>
    <integer>70</integer>
    <key>companyId</key>
    <real>20116</real>
    <key>groupId</key>
    <real>20143</real>
</dict>
</plist>
\end{verbatim}
\end{itemize}

Make sure to change these values to match those of your Liferay DXP
instance. The server address \texttt{http://10.0.2.2:8080} is suitable
for testing with Android Studio's emulator, because it corresponds to
\texttt{localhost:8080} through the emulator. If you're using the
Genymotion emulator, you should, however, use \texttt{192.168.56.1}
instead of \texttt{localhost}.

The \texttt{liferay\_company\_id} and \texttt{companyId} values are your
Liferay DXP instance's ID. You can find this in your Liferay DXP
instance at \emph{Control Panel} → \emph{Configuration} → \emph{Virtual
Instances}. The instance's ID is in the \emph{Instance ID} column.

The \texttt{liferay\_group\_id} and \texttt{groupId} values are the ID
of the site your app needs to communicate with. To find this value,
first go to the site in your Liferay DXP instance that you want your app
to communicate with. In the \emph{Site Administration} menu, select
\emph{Configuration} → \emph{Site Settings}. The site ID is listed at
the top of the \emph{General} tab.

The \texttt{liferay\_portal\_version} and \texttt{version} value
\texttt{70} tells Screens that it's communicating with a Liferay CE
Portal 7.0 or Liferay DXP 7.0 instance. Here are the supported values
and the portal versions they correspond to:

\begin{itemize}
\tightlist
\item
  \texttt{71}: Liferay CE Portal 7.1 or Liferay DXP 7.1
\item
  \texttt{70}: Liferay CE Portal 7.0 or Liferay DXP 7.0
\item
  \texttt{62}: Liferay Portal 6.2 CE/EE
\end{itemize}

You can also configure Screenlet properties in
\texttt{server\_context.xml} and \texttt{liferay-server-context.plist}.
The example \texttt{server\_context.xml} properties listed below,
\texttt{liferay\_recordset\_id} and \texttt{liferay\_recordset\_fields},
enable DDL Form Screenlet and DDL List Screenlet to interact with a
Liferay DXP instance's DDLs:

\begin{verbatim}
<!-- Change these values for your portal installation -->

<integer name="liferay_recordset_id">20935</integer>
<string name="liferay_recordset_fields">Title</string>
\end{verbatim}

For additional examples of these files, see the
\href{https://github.com/liferay/liferay-screens/blob/develop/xamarin/Samples/Showcase-Android/Resources/values/server_context.xml}{Showcase-Android}
and
\href{https://github.com/liferay/liferay-screens/blob/develop/xamarin/Samples/Showcase-iOS/Resources/liferay-server-context.plist}{Showcase-iOS}
sample projects.

Super! Your Xamarin projects are ready for Liferay Screens.

\subsection{Related Topics}\label{related-topics-103}

\href{/docs/7-0/tutorials/-/knowledge_base/t/using-screenlets-in-xamarin-apps}{Using
Screenlets in Xamarin Apps}

\href{/docs/7-0/tutorials/-/knowledge_base/t/using-views-in-xamarin-android}{Using
Views in Xamarin.Android}

\href{/docs/7-0/tutorials/-/knowledge_base/t/using-themes-in-xamarin-ios}{Using
Themes in Xamarin.iOS}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-xamarin-views-and-themes}{Creating
Xamarin Views and Themes}

\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-screens-for-xamarin-troubleshooting-and-faqs}{Liferay
Screens for Xamarin Troubleshooting and FAQs}

\section{Using Screenlets in Xamarin
Apps}\label{using-screenlets-in-xamarin-apps}

You can start using Screenlets once you've
\href{/docs/7-0/tutorials/-/knowledge_base/t/preparing-xamarin-projects-for-liferay-screens}{prepared}
your Xamarin project to use Liferay Screens. The Screenlet reference
documentation describes the available Screenlets:

\begin{itemize}
\tightlist
\item
  \href{/docs/7-0/reference/-/knowledge_base/r/screenlets-in-liferay-screens-for-android}{Screenlets
  in Liferay Screens for Android}
\item
  \href{/docs/7-0/reference/-/knowledge_base/r/screenlets-in-liferay-screens-for-ios}{Screenlets
  in Liferay Screens for iOS}
\end{itemize}

Using Screenlets is very straightforward. This tutorial shows you how to
insert and configure Screenlets in your Xamarin app. You'll be a
Screenlet master in no time!

\subsection{Xamarin.iOS}\label{xamarin.ios}

Follow these steps to insert Screenlets in your Xamarin.iOS app:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Insert a view (\texttt{UIView}) in your storyboard (in Visual Studio's
  iOS Designer or Xcode's Interface Builder). Note that if you're
  editing an XIB file, you must insert the view inside the XIB's parent
  view.
\item
  Set the view's class to the class of the Screenlet you want to use.
  For example, Login Screenlet's class is \texttt{LoginScreenlet}. If
  you're using Xamarin Designer for iOS in Visual Studio, you must also
  give the view a name so you can refer to it in your view controller's
  code.

  For example, the following video shows the first two steps for
  inserting Login Screenlet in a Xamarin Designer for iOS storyboard.
\item
  Configure the Screenlet's behavior in your app by implementing the
  Screenlet's delegate in your view controller. To configure your app to
  listen for events the Screenlet triggers, implement the Screenlet's
  delegate methods and register the view controller as the delegate.
  Make sure to annotate each delegate method with
  \texttt{{[}Export(...){]}}. This ensures the method can be called from
  Objective-C, which is required for it to work in Screens. You should
  also set any Screenlet attributes you need. Each Liferay Screenlet's
  \href{/docs/7-0/reference/-/knowledge_base/r/screenlets-in-liferay-screens-for-ios}{reference
  documentation} lists its available attributes and delegate methods.
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** In Liferay Screens for Xamarin, Screenlet delegates are prefixed
 with an `I`. For example, Login Screenlet's delegate in native code is
 `LoginScreenletDelegate`, while in Xamarin it's `ILoginScreenletDelegate`.
\end{verbatim}

\noindent\hrulefill

\begin{verbatim}
For example, here's a view controller that implements Login Screenlet's 
delegate, `ILoginScreenletDelegate`. Note that the `ViewDidLoad()` method 
sets the Screenlet's `ThemeName` attribute (`ThemeName` is available for all 
Screenlets via `BaseScreenlet` inheritance) and registers the view 
controller as the delegate. This view controller also implements the 
`OnLoginResponseUserAttributes` method, which is called upon successful 
login. Also note this method's `[Export(...)]` annotation: 

    public partial class ViewController : UIViewController, ILoginScreenletDelegate
    {
        protected ViewController(IntPtr handle) : base(handle) {}

        public override void ViewDidLoad()
        {
            base.ViewDidLoad();

            // Set the Screenlet's attributes
            this.loginScreenlet.ThemeName = "demo";

            // Registers this view controller as the delegate 
            this.loginScreenlet.Delegate = this;
        }

        ...

        // Delegate methods

        [Export("screenlet:onLoginResponseUserAttributes:")]
        public virtual void OnLoginResponseUserAttributes(BaseScreenlet screenlet, 
            NSDictionary<NSString, NSObject> attributes)
        {
            ...
        }
    }
\end{verbatim}

See
\href{https://github.com/liferay/liferay-screens/tree/develop/xamarin/Samples/Showcase-iOS/ViewController}{the
Showcase-iOS app} for more examples of view controllers that use
Liferay's Screenlets.

\subsection{Xamarin.Android}\label{xamarin.android}

Follow these steps to insert Screenlets in your Xamarin.Android app:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open your app's layout AXML file and insert the Screenlet's XML in
  your activity or fragment layout. For example, here's Login
  Screenlet's XML in an activity's \texttt{FrameLayout}:

\begin{verbatim}
<?xml version="1.0" encoding="utf-8"?>
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent">
    <com.liferay.mobile.screens.auth.login.LoginScreenlet
        android:id="@+id/login_screenlet"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        app:basicAuthMethod="email"/>
</FrameLayout>
\end{verbatim}
\item
  Set the Screenlet's attributes. If it's a Liferay Screenlet, refer to
  the
  \href{/docs/7-0/reference/-/knowledge_base/r/screenlets-in-liferay-screens-for-android}{Screenlet
  reference documentation} to learn the Screenlet's required and
  supported attributes. This screenshot shows Login Screenlet's
  attributes being set:

  \begin{figure}
  \centering
  \includegraphics{./images/screens-xamarin-android-screenlet-attributes.png}
  \caption{You can set a Screenlet's attributes via the app's layout
  AXML file.}
  \end{figure}
\item
  To configure your app to listen for events the Screenlet triggers,
  implement the Screenlet's listener interface in your activity or
  fragment class. Refer to the
  \href{/docs/7-0/reference/-/knowledge_base/r/screenlets-in-liferay-screens-for-android}{Screenlet's
  reference documentation} to learn its listener interface. Then
  register that activity or fragment as the Screenlet's listener.
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** In Liferay Screens for Xamarin, Screenlet listeners are prefixed
 with an `I`. For example, Login Screenlet's listener in native code is
 `LoginListener`, while in Xamarin it's `ILoginListener`.
\end{verbatim}

\noindent\hrulefill

\begin{verbatim}
For example, the following activity class implements Login Screenlet's 
`ILoginListener` interface, and registers itself as the Screenlet's 
listener via `loginScreenlet.Listener = this`. Note that the listener
methods `OnLoginSuccess` and `OnLoginFailure` are called when login succeeds 
and fails, respectively. In this case, these methods print simple toast 
messages: 

    [Activity]
    public class LoginActivity : Activity, ILoginListener
    {
        LoginScreenlet loginScreenlet;

        protected override void OnCreate(Bundle savedInstanceState)
        {
            base.OnCreate(savedInstanceState);
            SetContentView(Resource.Layout.LoginView);

            loginScreenlet = (LoginScreenlet) FindViewById(Resource.Id.login_screenlet);
            loginScreenlet.Listener = this;
        }

        // ILoginListener

        public void OnLoginSuccess(User p0)
        {
            Toast.MakeText(this, "Login success: " + p0.Id, ToastLength.Short).Show();
        }

        public void OnLoginFailure(Java.Lang.Exception p0)
        {
            Android.Util.Log.Debug("LoginScreenlet", $"Login failed: {p0.Message}");
        }

    }
\end{verbatim}

See
\href{https://github.com/liferay/liferay-screens/tree/develop/xamarin/Samples/Showcase-Android/Activities}{the
Showcase-Android app} for more examples of activities that use Liferay's
Screenlets.

\subsection{Related Topics}\label{related-topics-104}

\href{/docs/7-0/tutorials/-/knowledge_base/t/preparing-xamarin-projects-for-liferay-screens}{Preparing
Xamarin Projects for Liferay Screens}

\href{/docs/7-0/tutorials/-/knowledge_base/t/using-views-in-xamarin-android}{Using
Views in Xamarin.Android}

\href{/docs/7-0/tutorials/-/knowledge_base/t/using-themes-in-xamarin-ios}{Using
Themes in Xamarin.iOS}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-xamarin-views-and-themes}{Creating
Xamarin Views and Themes}

\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-screens-for-xamarin-troubleshooting-and-faqs}{Liferay
Screens for Xamarin Troubleshooting and FAQs}

\section{Using Views in
Xamarin.Android}\label{using-views-in-xamarin.android}

You can use a Liferay Screens \emph{View} to set a Screenlet's look and
feel independent of the Screenlet's core functionality. Liferay's
Screenlets come with several Views, and more are being developed by
Liferay and the community.
\href{/docs/7-0/reference/-/knowledge_base/r/screenlets-in-liferay-screens-for-android}{The
Screenlet reference documentation} lists the Views available for each
Screenlet included with Screens. This tutorial shows you how to use
Views in Xamarin.Android.

\subsection{Views and View Sets}\label{views-and-view-sets-1}

The concepts and components that comprise Views and View Sets in Liferay
Screens for Xamarin are the same as they are in Liferay Screens for
Android. For a brief description of these components, see
\href{/docs/7-0/tutorials/-/knowledge_base/t/using-views-in-android-screenlets\#views-and-view-sets}{the
section on Views and View Sets} in the general tutorial on using Views.
For a detailed description of the View layer in Liferay Screens, see the
tutorial
\href{/docs/7-0/tutorials/-/knowledge_base/t/architecture-of-liferay-screens-for-android}{Architecture
of Liferay Screens for Android}.

\subsection{Using Views}\label{using-views-1}

Follow these steps to use a View in Xamarin.Android:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Copy the layout of the View you want to use from the
  \href{https://github.com/liferay/liferay-screens}{Liferay Screens
  repository} to your app's \texttt{res/layout} folder. Alternatively,
  you can create a new layout. The following links list the View layouts
  available in each View Set:

  \begin{itemize}
  \tightlist
  \item
    \href{https://github.com/liferay/liferay-screens/tree/master/android/library/src/main/res/layout}{Default}
  \item
    \href{https://github.com/liferay/liferay-screens/tree/master/android/viewsets/material/src/main/res/layout}{Material}
  \item
    \href{https://github.com/liferay/liferay-screens/tree/master/android/viewsets/westeros/src/main/res/layout}{Westeros}
  \end{itemize}

  For example, this is Login Screenlet's Material View,
  \texttt{login\_material.xml}:

\begin{verbatim}
<com.liferay.mobile.screens.viewsets.material.auth.login.LoginView
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:liferay="http://schemas.android.com/apk/res-auto"
    android:paddingLeft="40dp"
    android:paddingRight="40dp"
    style="@style/default_screenlet">

<LinearLayout
    android:id="@+id/basic_authentication_login"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="vertical">

    <LinearLayout style="@style/material_row">

        <ImageView
            android:id="@+id/drawable_login"
            android:contentDescription="@string/user_login_icon"
            android:src="@drawable/material_email"
            style="@style/material_icon"/>

        <EditText
            android:id="@+id/liferay_login"
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            android:layout_marginTop="8dp"
            android:inputType="text"
            android:labelFor="@+id/liferay_login"/>

    </LinearLayout>

    <LinearLayout style="@style/material_row">

        <ImageView
            android:id="@+id/drawable_password"
            android:contentDescription="@string/password_icon"
            android:src="@drawable/material_https"
            style="@style/material_icon"/>

        <EditText
            android:id="@+id/liferay_password"
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            android:layout_marginTop="8dp"
            android:hint="@string/password"
            android:inputType="textPassword"/>

    </LinearLayout>

    <FrameLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_marginTop="32dp">

        <Button
            android:id="@+id/liferay_login_button"
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            android:layout_margin="10dp"
            android:text="@string/sign_in"/>

        <com.liferay.mobile.screens.base.ModalProgressBar
            android:id="@+id/liferay_progress"
            android:layout_width="wrap_content"
            android:layout_height="match_parent"
            android:layout_gravity="center_vertical|left"
            android:layout_margin="10dp"
            android:theme="@style/white_theme"
            android:visibility="invisible"
            liferay:actionViewId="@id/liferay_login_button"/>
    </FrameLayout>
</LinearLayout>

<Button
    android:id="@+id/oauth_authentication_login"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:text="@string/authorize_application"
    android:visibility="gone"/>

</com.liferay.mobile.screens.viewsets.material.auth.login.LoginView>
\end{verbatim}
\item
  When you insert the Screenlet's XML in the layout of the activity or
  fragment you want the Screenlet to appear in, set the
  \texttt{liferay:layoutId} attribute to the View's layout. For example,
  here's Login Screenlet's XML with \texttt{liferay:layoutId} set to
  \texttt{@layout/login\_material}, which specifies Login Screenlet's
  Material View from the previous step:

\begin{verbatim}
<com.liferay.mobile.screens.auth.login.LoginScreenlet
    android:id="@+id/login_screenlet"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    liferay:layoutId="@layout/login_material"
    />
\end{verbatim}
\item
  If the View you want to use is part of a View Set (e.g., the Material
  View is part of the Material View Set), your app or activity's theme
  must also inherit the theme that defines that View Set's styles. For
  example, the following code in an app's
  \texttt{Resources/values/Styles.xml} tells
  \texttt{AppTheme.NoActionBar} to use the Material View Set as its
  parent theme:

\begin{verbatim}
<resources>
    <style name="AppTheme.NoActionBar" parent="material_theme">
        <item name="colorPrimary">@color/colorPrimary</item>
        <item name="colorPrimaryDark">@color/colorPrimaryDark</item>
        <item name="colorAccent">@color/colorAccent</item>

        <item name="windowActionBar">false</item>
        <item name="windowNoTitle">true</item>
    </style>
    ...
</resources>
\end{verbatim}

  To use the Default or Westeros View Set, inherit
  \texttt{default\_theme} or \texttt{westeros\_theme}, respectively.
\end{enumerate}

Awesome! Now you know how to use Views to spruce up your Xamarin.Android
Screenlets.

\subsection{Related Topics}\label{related-topics-105}

\href{/docs/7-0/tutorials/-/knowledge_base/t/preparing-xamarin-projects-for-liferay-screens}{Preparing
Xamarin Projects for Liferay Screens}

\href{/docs/7-0/tutorials/-/knowledge_base/t/using-screenlets-in-xamarin-apps}{Using
Screenlets in Xamarin Apps}

\href{/docs/7-0/tutorials/-/knowledge_base/t/using-themes-in-xamarin-ios}{Using
Themes in Xamarin.iOS}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-xamarin-views-and-themes}{Creating
Xamarin Views and Themes}

\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-screens-for-xamarin-troubleshooting-and-faqs}{Liferay
Screens for Xamarin Troubleshooting and FAQs}

\section{Using Themes in Xamarin.iOS}\label{using-themes-in-xamarin.ios}

\emph{Themes} in Xamarin.iOS are analogous to \emph{Views} in
Xamarin.Android. Like Views, Themes let you set a Screenlet's look and
feel independent of the Screenlet's core functionality. Liferay's
Screenlets come with several Themes, and more are being developed by
Liferay and the community.
\href{/docs/7-0/reference/-/knowledge_base/r/screenlets-in-liferay-screens-for-ios}{The
Screenlet reference documentation} lists the Themes available for each
Screenlet included with Screens. This tutorial shows you how to use
Themes in Xamarin.iOS.

\subsection{Installing and Using
Themes}\label{installing-and-using-themes}

Follow these steps to install and use a Theme:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  If the Theme is packaged as a NuGet dependency, you can install it in
  your project via NuGet. To do so, right-click your project's
  \emph{Packages} folder and then select \emph{Add packages\ldots{}}.
  Then search for the Theme and install it. If the Theme isn't available
  in NuGet, you can drag and drop the Theme's folder directly into your
  project.
\item
  To use the installed Theme, set its name to the Screenlet instance's
  \texttt{ThemeName} property in your view controller that implements
  the Screenlet's delegate. All Screenlets inherit this property from
  \texttt{BaseScreenlet}. For example, this code sets Login Screenlet's
  \texttt{ThemeName} property to the Material Theme:

\begin{verbatim}
loginScreenlet.ThemeName = "material"
\end{verbatim}

  If you don't set this property or enter an invalid or missing Theme,
  the Screenlet uses its Default Theme. Each Screenlet's available
  Themes are listed in the \emph{Themes} section of the Screenlet's
  \href{/docs/7-0/reference/-/knowledge_base/r/screenlets-in-liferay-screens-for-ios}{reference
  documentation}.
\end{enumerate}

Great, that's it! Now you know how to use Themes to dress up Screenlets
in your Xamarin.iOS apps.

\subsection{Related Topics}\label{related-topics-106}

\href{/docs/7-0/tutorials/-/knowledge_base/t/preparing-xamarin-projects-for-liferay-screens}{Preparing
Xamarin Projects for Liferay Screens}

\href{/docs/7-0/tutorials/-/knowledge_base/t/using-screenlets-in-xamarin-apps}{Using
Screenlets in Xamarin Apps}

\href{/docs/7-0/tutorials/-/knowledge_base/t/using-views-in-xamarin-android}{Using
Views in Xamarin.Android}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-xamarin-views-and-themes}{Creating
Xamarin Views and Themes}

\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-screens-for-xamarin-troubleshooting-and-faqs}{Liferay
Screens for Xamarin Troubleshooting and FAQs}

\section{Creating Xamarin Views and
Themes}\label{creating-xamarin-views-and-themes}

Recall that Views in Xamarin.Android and Themes in Xamarin.iOS are
analogous components that let you customize a Screenlet's look and feel.
You can use the Views and Themes provided by Liferay Screens, or write
your own. Writing your own lets you tailor a Screenlet's UI to your
exact specifications. This tutorial shows you how to do this.

You can create Views and Themes from scratch, or use an existing one as
a foundation. Views and Themes include a View class for implementing the
Screenlet UI's behavior, a Screenlet class for notifying
listeners/delegates and invoking Interactors, and an AXML or XIB file
for defining the UI.

There are also different types of Views and Themes. These are discussed
in the tutorials on creating
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-android-views}{Views}
and
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-ios-themes}{Themes}
in native code. You should read those tutorials before creating Views in
Xamarin.Android or Themes in Xamarin.iOS.

First, you'll determine where to create your View or Theme.

\subsection{Determining the Location of Your View or
Theme}\label{determining-the-location-of-your-view-or-theme}

If you plan to reuse or redistribute your View or Theme, create it in a
new Xamarin project as a
\href{https://developer.xamarin.com/guides/cross-platform/application_fundamentals/nuget-multiplatform-libraries/}{multiplatform
library for code sharing}. Otherwise, create it in your app's project.

\subsection{Creating a Xamarin.Android
View}\label{creating-a-xamarin.android-view}

Creating Views for Xamarin.Android is very similar to doing so in native
code. You can create the following View types:

\begin{itemize}
\item
  \textbf{Themed View:} Creating a Themed View in Xamarin.Android is
  identical
  \href{/docs/7-0/tutorials/-/knowledge_base/t/creating-android-views\#themed-view}{to
  doing so in native code}. In Xamarin.Android, however, only the
  Default View Set is available to extend.
\item
  \textbf{Child View:} Creating a Child View in Xamarin.Android is
  identical
  \href{/docs/7-0/tutorials/-/knowledge_base/t/creating-android-views\#child-view}{to
  doing so in native code}.
\item
  \textbf{Extended View:} Creating an Extended View in Xamarin.Android
  differs from doing so in native code. The next section shows you how.
\end{itemize}

\subsubsection{Extended View}\label{extended-view-1}

To create an Extended View in Xamarin.Android, follow
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-android-views\#extended-view}{the
steps for creating an Extended View in native code}, but make sure your
custom View class in the second step is the appropriate C\# class. For
example, here's the View class from the native code tutorial, converted
to C\#:

\begin{verbatim}
using System;
using Android.Content;
using Android.Util;
using Com.Liferay.Mobile.Screens.Viewsets.Defaultviews.Auth.Login;

namespace ShowcaseAndroid.CustomViews
{
    public class LoginCheckPasswordView : LoginView
    {
        public LoginCheckPasswordView(Context context) : base(context) { }

        public LoginCheckPasswordView(Context context, IAttributeSet attributes) : base(context, attributes) {}

        public LoginCheckPasswordView(Context context, IAttributeSet attributes, int defaultStyle) : base(context, attributes, defaultStyle) {}

        public override void OnClick(Android.Views.View view)
        {
            // compute password strength
            if (PasswordIsStrong) {
                base.OnClick(view);
            }
            else {
                // Present user message
            }
        }
    }
}
\end{verbatim}

Awesome! Now you know how to create Extended Views in Xamarin.Android.

\subsection{Creating a Xamarin.iOS
Theme}\label{creating-a-xamarin.ios-theme}

Creating Themes for Xamarin.iOS is very similar
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-ios-themes}{to
doing so in native code}. You can create the following Theme types in
Xamarin.iOS:

\begin{itemize}
\tightlist
\item
  \textbf{Child Theme:} presents the same UI components as its parent
  Theme, but lets you change their appearance and position.
\item
  \textbf{Extended Theme:} inherits its parent Theme's functionality and
  appearance, but lets you add to and modify both.
\end{itemize}

First, you'll learn how to create a Child Theme in Xamarin.iOS.

\subsubsection{Child Theme}\label{child-theme}

Child Themes leverage a parent Theme's behavior and UI components,
letting you modify the appearance and position of those components. Note
that you can't add or remove components, and the parent Theme must be a
Full Theme. The Child Theme presents visual changes with its own XIB
file and inherits the parent's View class.

Follow these steps to create a Child Theme in Xamarin.iOS:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In Visual Studio, create a new XIB file named after the Screenlet's
  View class and your Theme. By convention, an XIB file for a Screenlet
  with a View class named \texttt{LoginView} and a Theme named
  \texttt{demo} should be named \texttt{LoginView\_demo}. You can use
  content from the parent Theme's XIB file as a foundation for your new
  XIB file. In your new XIB, you can change the UI components' visual
  properties (e.g., their position and size). You mustn't change,
  however, the XIB file's custom class, outlet connection, or
  \texttt{restorationIdentifier}. These must match those of the parent
  XIB file.
\item
  In the View Controller, set the Screenlet's \texttt{ThemeName}
  property to the Theme's name. For example, this sets Login Screenlet's
  \texttt{ThemeName} property to the \texttt{demo} Theme from the first
  step:

\begin{verbatim}
this.loginScreenlet.ThemeName = "demo";
\end{verbatim}

  This causes Liferay Screens to look for the file
  \texttt{LoginView\_demo} in all apps' bundles. If that file doesn't
  exist, Screens uses the Default Theme instead
  (\texttt{LoginView\_default}).
\end{enumerate}

You can see an example of \texttt{LoginView\_demo} in
\href{https://github.com/liferay/liferay-screens/tree/develop/xamarin/Samples/Showcase-iOS/CustomViews}{the
Showcase-iOS demo app}. Fantastic! Next, you'll learn how to create an
Extended Theme.

\subsubsection{Extended Theme}\label{extended-theme-1}

An Extended Theme inherits another Theme's UI components and behavior,
but lets you add to or alter both. For example, you can extend the
parent Theme's View class to change the parent Theme's behavior. You can
also create a new XIB file that contains new or modified UI components.
An Extended Theme's parent must be
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-ios-themes\#full-theme}{a
Full Theme}.

Follow these steps to create an Extended Theme:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In Visual Studio, create a new XIB file named after the Screenlet's
  View class and your Theme. By convention, an XIB file for a Screenlet
  with a View class named \texttt{LoginView} and a Theme named
  \texttt{demo} should be named \texttt{LoginView\_demo}. You can use
  the parent Theme's XIB file as a template. Make your Theme's UI
  changes by editing your XIB file in Visual Studio's iOS Designer or
  Xcode's Interface Builder.
\item
  Create a new View class that extends the parent Theme's View class.
  You should name this class after the XIB file you just created. You
  can add to or override functionality of the parent Theme's View class.
  Here's an example that extends the View class of Login Screenlet's
  default Theme (\texttt{LoginView\_default}). Note that it changes the
  login button's background color and disables the progress presenter:

\begin{verbatim}
using LiferayScreens;
using System;

namespace ShowcaseiOS
{
    public partial class LoginView_demo : LoginView_default
    {
        public LoginView_demo (IntPtr handle) : base (handle) { }

        public override void OnCreated()
        {
            // You can change the login button color from code
            this.LoginButton.BackgroundColor = UIKit.UIColor.DarkGray;
        }

        // If you don't want a progress presenter, create an empty one
        public override IProgressPresenter CreateProgressPresenter()
        {
            return new NoneProgressPresenter();
        }
    }
}
\end{verbatim}
\item
  Set your new View class as the custom class for your Theme's XIB file:

  \begin{figure}
  \centering
  \includegraphics{./images/screens-ios-extended-theme.png}
  \caption{Set new View class in XIB Theme file.}
  \end{figure}
\end{enumerate}

Well done! Now you know how to create an Extended Theme.

\subsection{Related Topics}\label{related-topics-107}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-android-views}{Creating
Android Views (native code)}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-ios-themes}{Creating
iOS Themes (native code)}

\href{/docs/7-0/tutorials/-/knowledge_base/t/preparing-xamarin-projects-for-liferay-screens}{Preparing
Xamarin Projects for Liferay Screens}

\href{/docs/7-0/tutorials/-/knowledge_base/t/using-screenlets-in-xamarin-apps}{Using
Screenlets in Xamarin Apps}

\href{/docs/7-0/tutorials/-/knowledge_base/t/using-views-in-xamarin-android}{Using
Views in Xamarin.Android}

\href{/docs/7-0/tutorials/-/knowledge_base/t/using-themes-in-xamarin-ios}{Using
Themes in Xamarin.iOS}

\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-screens-for-xamarin-troubleshooting-and-faqs}{Liferay
Screens for Xamarin Troubleshooting and FAQs}

\section{Liferay Screens for Xamarin Troubleshooting and
FAQs}\label{liferay-screens-for-xamarin-troubleshooting-and-faqs}

Even though Liferay developed Liferay Screens for Xamarin with great
care, you may still run into some common issues. This tutorial lists
tips and solutions for these issues, as well as answers to common
questions about Screens for Xamarin.

\subsection{General Troubleshooting}\label{general-troubleshooting-1}

Before exploring specific issues, you should first make sure that you've
installed the correct versions of Visual Studio and the Mono .NET
framework. Each Screenlet's reference documentation (available for
\href{/docs/7-0/reference/-/knowledge_base/r/screenlets-in-liferay-screens-for-android}{Android}
and
\href{/docs/7-0/reference/-/knowledge_base/r/screenlets-in-liferay-screens-for-ios}{iOS})
lists these versions.

It may also help to investigate the sample Xamarin.Android and
Xamarin.iOS apps developed by Liferay. Both are good examples of how to
use Screenlets, Views (Android), and Themes (iOS):

\begin{itemize}
\tightlist
\item
  \href{https://github.com/liferay/liferay-screens/tree/develop/xamarin/Samples/Showcase-Android}{Showcase-Android}
\item
  \href{https://github.com/liferay/liferay-screens/tree/develop/xamarin/Samples/Showcase-Android}{Showcase-iOS}
\end{itemize}

If you get stuck at any point, you can post your question on our
\href{https://www.liferay.com/community/forums/-/message_boards/category/42706063}{forum}.
We're happy to assist you!

\subsection{Common Issues}\label{common-issues-1}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Build issues:

  Running \emph{Clean} in Visual Studio may not be enough. Close Visual
  Studio, remove all the \texttt{bin} and \texttt{obj} folders that
  weren't removed by the clean, then rebuild your project.
\item
  \texttt{NSUnknownKeyException} error in Xamarin.iOS:

  This error occurs when Liferay Screens for iOS has a wrong module name
  in an XIB file. You must solve this in Xcode, removing the module name
  in the XIB file's \emph{Custom Class} assignment in Interface Builder.
\item
  \texttt{The\ selector\ is\ already\ registered} error in Xamarin.iOS:

  This error occurs because one or more methods share the same name. To
  fix this, the binding file must be updated. Please file a ticket in
  our \href{https://issues.liferay.com/browse/LMW/}{Jira} or post the
  issue on our
  \href{https://www.liferay.com/community/forums/-/message_boards/category/42706063}{forum}.
\item
  Xamarin.iOS crashes unexpectedly without any error messages in the
  console:

  Check the log file. On Mac OS, do this via the Console. On Windows,
  use the Event Viewer. In the app, you must click \emph{User Reports}
  and then look for your app's name. Note that there may be more than
  one log file.
\item
  The app doesn't call delegate methods in Xamarin.iOS:

  When you implement the delegate methods in your view controller, make
  sure to annotate them with \texttt{{[}Export(...){]}}. You must also
  set the view controller to the Screenlet instance's \texttt{Delegate}
  property. Here's an example of such a view controller that implements
  Login Screenlet's delegate, \texttt{ILoginScreenletDelegate}:

\begin{verbatim}
public partial class ViewController : UIViewController, ILoginScreenletDelegate
{
    protected ViewController(IntPtr handle) : base(handle) {}

    public override void ViewDidLoad()
    {
        base.ViewDidLoad();

        this.loginScreenlet.Delegate = this;
    }

    [Export("screenlet:onLoginResponseUserAttributes:")]
    public virtual void OnLoginResponseUserAttributes(BaseScreenlet screenlet, 
        NSDictionary<NSString, NSObject> attributes)
    {
        ...
    }

    ...
}
\end{verbatim}
\end{enumerate}

\subsection{DataType Mapping}\label{datatype-mapping}

For a better understanding of Xamarin code and example apps, see this
list to compare type mapping between platforms. You must write Xamarin
apps in C\#, which has some differences compared to native code:

\begin{itemize}
\item
  Delegate (iOS) or listener (Android) classes:

  These classes are important because they listen for a Screenlet's
  events. In Liferay Screens for Xamarin, Screenlet delegates and
  listeners are prefixed with an \texttt{I}. For example, Login
  Screenlet's delegate in native code is
  \texttt{LoginScreenletDelegate}, while in Xamarin it's
  \texttt{ILoginScreenletDelegate}. Similarly, Login Screenlet's
  listener in native code is \texttt{LoginListener}, while in Xamarin
  it's \texttt{ILoginListener}. Use a similar naming scheme when you
  define a class/interface pair where the class is a standard
  implementation of the interface.
\item
  Getter and setter methods:

  To get or set a value in native code, you use its getter and setter
  methods. In Liferay Screens for Xamarin, you should convert such
  methods to properties. If you have only one of these methods, you can
  call the method itself. For example:

\begin{verbatim}
// If you implemented a setter and a getter, call the property
loginScreenlet.Listener = this;

// Otherwise, call the method
loginScreenlet.getListener();
\end{verbatim}
\item
  Pascal case convention:

  C\# code is usually written in Pascal case. However, you should use
  Camel case for protected instance fields or parameters.
\end{itemize}

\subsection{Language Equivalents between Swift and
C}\label{language-equivalents-between-swift-and-c}

\begin{itemize}
\item
  Protocols in Swift are analogous to interfaces in C\#:

\begin{verbatim}
// Swift
protocol DoThings {
    func MyMethod() -> String
}


// C#
interface DoThings
{
    string MyMethod();
}
\end{verbatim}
\item
  Initializers in Swift are analogous to constructors in C\#:

\begin{verbatim}
// Swift
class MyClass {
    var myVar : String = ""

    init(myVar : String) {
        self.myVar = myVar
    }
}

var testing = MyClass(myVar: "Test")


// C#
class MyClass {
    protected string myVar = "";

    public MyClass() {}

    public MyClass(string myVar) {
        this.myVar = myVar;
    }
}

var testing = new MyClass(myVar: "Test");
\end{verbatim}
\end{itemize}

To learn more about language equivalents between Swift and C\#, see
\href{https://download.microsoft.com/download/4/6/9/469501F4-5F6B-4E51-897C-9A216CFB30A3/SwiftCSharpPoster.pdf}{this
quick reference}.

\subsection{Language Equivalents between Java and
C}\label{language-equivalents-between-java-and-c}

To extend or implement a class or interface, Java requires that you use
the \texttt{extends} or \texttt{implements} keywords. C\# doesn't
require this:

\begin{verbatim}
// Java
class Bird extends Vertebrate implements Actions {
    ...
}


// C#
class Bird : Vertebrate, Actions {
    ...
}
\end{verbatim}

To learn more about language equivalents between Java and C\#, see
\href{https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=1&cad=rja&uact=8&ved=0ahUKEwjbr8bgz_XXAhWMMyYKHeUPA5wQFgg7MAA&url=http\%3A\%2F\%2Fdownload.microsoft.com\%2Fdownload\%2FD\%2FE\%2FE\%2FDEE91FC0-7AA9-4F6E-9FFA-8658AA0FA080\%2FCSharp\%2520for\%2520Java\%2520Developers\%2520-\%2520Cheat\%2520Sheet.pdf&usg=AOvVaw1i0RzOcmyol7LhD59k9cUE}{the
C\# for Java developers cheat sheet}.

\subsection{FAQs}\label{faqs-1}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Do I have to use Visual Studio?

  No, but we strongly recommend it. If you wish, however, you can use
  Xamarin Studio or Visual Studio Code instead.
\item
  What's the meaning of \texttt{{[}Export(...){]}} above delegate method
  names?

  In short, this attribute makes properties and methods available in
  Objective-C.
  \href{https://developer.xamarin.com/api/type/MonoTouch.Foundation.ExportAttribute/}{Xamarin's
  documentation} explains this attribute in detail.
\end{enumerate}

\subsection{Related Topics}\label{related-topics-108}

\href{/docs/7-0/tutorials/-/knowledge_base/t/preparing-xamarin-projects-for-liferay-screens}{Preparing
Xamarin Projects for Liferay Screens}

\href{/docs/7-0/tutorials/-/knowledge_base/t/using-screenlets-in-xamarin-apps}{Using
Screenlets in Xamarin Apps}

\href{/docs/7-0/tutorials/-/knowledge_base/t/using-views-in-xamarin-android}{Using
Views in Xamarin.Android}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-xamarin-views-and-themes}{Creating
Xamarin Views and Themes}

\href{/docs/7-0/tutorials/-/knowledge_base/t/using-themes-in-xamarin-ios}{Using
Themes in Xamarin.iOS}

\chapter{Mobile SDK}\label{mobile-sdk}

Want to wield Liferay's power in your mobile apps? Thanks to Liferay's
Mobile SDK, you can do just that. The Liferay Mobile SDK provides a way
to streamline consuming Liferay core web services, Liferay utilities,
and custom app web services. It's a low-level layer that wraps Liferay
JSON web services, making them easy to call in native mobile apps. It
takes care of authentication, makes HTTP requests (synchronously or
asynchronously), parses JSON results, and handles server-side exceptions
so you can concentrate on \emph{using} the services in your app. The
Liferay Mobile SDK bridges the gap between your native app and Liferay
services. The official project
\href{https://www.liferay.com/community/liferay-projects/liferay-mobile-sdk/overview}{page}
gives you access to the SDK releases, provides the latest SDK news, and
has forums for you to engage in mobile app development discussions. The
Liferay Mobile SDK is available as separate downloads for Android and
iOS.

\begin{figure}
\centering
\includegraphics{./images/mobile-sdk-diagram.png}
\caption{Liferay's Mobile SDK enables your native app to communicate
with Liferay.}
\end{figure}

There are two different types of Mobile SDKs that you need to add to
your app's project, depending on the remote services you need to call.
Liferay's prebuilt Mobile SDK includes the classes required to construct
remote service calls in general. It also contains the classes required
to call the specific remote services of Liferay's \emph{core} portlets.
Core portlets are included with every Liferay installation (these are
also referred to as out-of-the-box or built-in portlets). However, you
need to build an additional Mobile SDK if you want to leverage your
custom portlet's remote services. Once built, this Mobile SDK contains
\emph{only} the classes required to call those services. Therefore, you
must install it in your app alongside Liferay's prebuilt Mobile SDK to
leverage your custom portlet's remote services.

Note that Liferay also provides
\href{https://www.liferay.com/products/liferay-screens}{Liferay Screens}
for constructing mobile apps that connect to Liferay. Screens uses
components called \emph{screenlets} to leverage and abstract the Mobile
SDK's low-level service calls. However, if there's not a screenlet for
your use case, or you need more control over the service call, then you
may want to use the Mobile SDK directly. You should read the Screens
tutorials in addition to the Mobile SDK tutorials here to decide which
better fits your needs.

This section's tutorials cover using the Mobile SDK in Android and iOS
app development. The following tutorials introduce these topics and are
followed by in-depth tutorials on each:

\begin{itemize}
\tightlist
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/creating-android-apps-that-use-the-mobile-sdk}{Creating
  Android Apps that Use the Mobile SDK}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/creating-ios-apps-that-use-the-mobile-sdk}{Creating
  iOS Apps that Use the Mobile SDK}
\end{itemize}

In addition, the following tutorial covers building Mobile SDKs to
support your custom portlet services:

\begin{itemize}
\tightlist
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/building-mobile-sdks}{Building
  Mobile SDKs}
\end{itemize}

Fasten your seatbelt--it's time to go mobile with Liferay's Mobile SDK!

\textbf{Related Topics:}

\href{/docs/7-0/tutorials/-/knowledge_base/t/android-apps-with-liferay-screens}{Android
Apps with Liferay Screens}

\href{/docs/7-0/tutorials/-/knowledge_base/t/ios-apps-with-liferay-screens}{iOS
Apps with Liferay Screens}

\href{/docs/7-0/tutorials/-/knowledge_base/t/building-mobile-sdks}{Building
Mobile SDKs}

\section{Creating Android Apps that Use the Mobile
SDK}\label{creating-android-apps-that-use-the-mobile-sdk}

The Liferay Mobile SDK provides a way to streamline the consumption of
Liferay DXP's core web services and utilities, as well as those of
custom apps. It wraps Liferay DXP's JSON web services, making them easy
to call in native mobile apps. It handles authentication, makes HTTP
requests (synchronously or asynchronously), parses JSON results, and
handles server-side exceptions so you can concentrate on \emph{using}
the services in your app.

The Liferay Mobile SDK comes with the Liferay Android SDK. The official
\href{https://www.liferay.com/community/liferay-projects/liferay-mobile-sdk/overview}{project
page} gives you access to the SDK releases, provides the latest SDK
news, and has forums for you to engage in mobile app development
discussions. Once you configure the Mobile SDK in your app, you can
invoke Liferay DXP services in it.

\begin{figure}
\centering
\includegraphics{./images/mobile-sdk-diagram.png}
\caption{Liferay's Mobile SDK enables your native app to communicate
with Liferay DXP.}
\end{figure}

The Android Mobile SDK app development tutorials cover these topics:

\begin{itemize}
\tightlist
\item
  Making Liferay and Custom Portlet Services Available in Your Android
  App
\item
  Invoking Liferay Services in Your Android App
\item
  Invoking Services Asynchronously from Your Android App
\item
  Sending Your Android App's Requests Using Batch Processing
\end{itemize}

A great way to start is by setting up the Mobile SDK your Android
project. This makes Liferay DXP's services available in your app.

\subsection{Related Topics}\label{related-topics-109}

\href{/docs/7-0/tutorials/-/knowledge_base/t/invoking-liferay-services-in-your-android-app}{Invoking
Liferay Services in Your Android App}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-ios-apps-that-use-the-mobile-sdk}{Creating
iOS Apps that Use the Mobile SDK}

\href{/docs/7-0/tutorials/-/knowledge_base/t/building-mobile-sdks}{Building
Mobile SDKs}

\section{Making Liferay and Custom Portlet Services Available in Your
Android
App}\label{making-liferay-and-custom-portlet-services-available-in-your-android-app}

You must install the correct Mobile SDKs in your Android project to call
the remote services you need in your app. You should first install
Liferay's prebuilt Mobile SDK. This is required for any app that
leverages Liferay. To call your custom portlet's services, you also need
to install the Mobile SDK that you built for it. For instructions on
building a Mobile SDK for your custom portlet, see the tutorial
\href{/docs/7-0/tutorials/-/knowledge_base/t/building-mobile-sdks}{Building
Mobile SDKs}.

This tutorial shows you how to install Liferay's prebuilt Mobile SDK,
and any custom built Mobile SDKs. First, you'll learn how to use Gradle
or Maven to install Liferay's prebuilt Mobile SDK. You'll then learn how
to install a Mobile SDK manually, which is required for installing any
custom built Mobile SDKs. Now go forth and fear no remote service!

\subsection{Adding the SDK to Your Gradle
Project}\label{adding-the-sdk-to-your-gradle-project}

If your Android project is using Gradle as the build system, you can add
Liferay's prebuilt Mobile SDK as a
\href{/docs/7-0/tutorials/-/knowledge_base/t/configuring-dependencies}{dependency}
to your project. All versions are available at the JCenter and Maven
Central repositories. Both repositories are listed here, but you only
need to have one in your app:

\begin{verbatim}
repositories {
  jcenter()
  mavenCentral()
}

dependencies {
  compile group: 'com.liferay.mobile', name: 'liferay-android-sdk', version: '7.0.+'
}
\end{verbatim}

If you get errors such as
\texttt{Duplicate\ files\ copied\ in\ APK\ META-INF/NOTICE} when
building with Gradle, add this to your \texttt{build.gradle} file:

\begin{verbatim}
android {
    ...
    packagingOptions {
        exclude 'META-INF/LICENSE'
        exclude 'META-INF/NOTICE'
    }
    ...
}
\end{verbatim}

That's all there is to it! When your project syncs with your Gradle
files, Liferay's prebuilt Mobile SDK downloads to your project. The
instructions for doing this with Maven are shown next.

\subsection{Adding the SDK to Your Maven
Project}\label{adding-the-sdk-to-your-maven-project}

You can also add the Liferay's prebuilt Mobile SDK as a
\href{/docs/7-0/tutorials/-/knowledge_base/t/configuring-dependencies}{dependency}
to your project using Maven. To do so, add the following code to your
\texttt{pom.xml} file:

\begin{verbatim}
<dependency>
    <groupId>com.liferay.mobile</groupId>
    <artifactId>liferay-android-sdk</artifactId>
    <version>LATEST</version>
</dependency>
\end{verbatim}

Awesome! However, what if you're not using Gradle or Maven? What if you
want to install a custom built Mobile SDK? No problem! The next section
shows you how to install a Mobile SDK manually.

\subsection{Manually Adding the SDK to Your Android
Project}\label{manually-adding-the-sdk-to-your-android-project}

Use the following steps to manually set up a Mobile SDK in your Android
project:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  To install Liferay's prebuilt Mobile SDK, first
  \href{https://github.com/liferay/liferay-mobile-sdk/releases/}{download}
  the latest version of \texttt{liferay-android-sdk-{[}version{]}.jar}.
  If you built your own Mobile SDK, find its JAR file on your machine.
  This is detailed in the
  \href{/docs/7-0/tutorials/-/knowledge_base/t/building-mobile-sdks}{Building
  Mobile SDKs} tutorial.
\item
  Copy the JAR into your Android project's \texttt{/libs} folder.
\item
  If you're manually installing Liferay's prebuilt Mobile SDK, you also
  need to download and copy these dependencies to your Android Project's
  \texttt{/libs} folder:
  \href{http://search.maven.org/remotecontent?filepath=org/apache/httpcomponents/httpclient-android/4.3.3/httpclient-android-4.3.3.jar}{\texttt{httpclient-android-4.3.3.jar}}
  and
  \href{http://search.maven.org/remotecontent?filepath=org/apache/httpcomponents/httpmime/4.3.3/httpmime-4.3.3.jar}{\texttt{httpmime-4.3.3.jar}}.
\item
  Start using it!
\end{enumerate}

Great! Now you know how to manually install a Mobile SDK in your Android
apps.

\subsection{Making Custom Portlet Services Available in Your Android
App}\label{making-custom-portlet-services-available-in-your-android-app}

If you want to invoke remote web services for your custom portlet, then
you need to generate its client libraries by building an Android Mobile
SDK yourself. Building an SDK is covered in the tutorial
\href{/docs/7-0/tutorials/-/knowledge_base/t/building-mobile-sdks}{Building
Mobile SDKs}. Once you build an SDK to a JAR file, you can install it
using the manual installation steps above (make sure to use the JAR file
you built instead of Liferay's prebuilt JAR file). Note that because
your custom built SDKs contain \emph{only} the client libraries for
calling your custom portlet services, you must install them alongside
Liferay's prebuilt SDK. Liferay's prebuilt SDK contains additional
classes that are required to construct any remote service call.

Super! Now that the remote services you need are available in your app,
you're ready to call them.

\subsection{Related Topics}\label{related-topics-110}

\href{/docs/7-0/tutorials/-/knowledge_base/t/invoking-liferay-services-in-your-android-app}{Invoking
Liferay Services in Your Android App}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-ios-apps-that-use-the-mobile-sdk}{Creating
iOS Apps that Use the Mobile SDK}

\href{/docs/7-0/tutorials/-/knowledge_base/t/building-mobile-sdks}{Building
Mobile SDKs}

\section{Invoking Liferay Services in Your Android
App}\label{invoking-liferay-services-in-your-android-app}

Once the appropriate Mobile SDKs are set up in your Android project, you
can access and invoke Liferay DXP services in your app. This tutorial
takes you through the steps you must follow to invoke these services:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Create a session.
\item
  Import the Liferay DXP services you need to call.
\item
  Create a service object and call the service methods.
\end{enumerate}

Since some service calls require special treatment, this tutorial also
shows you how to handle them. But first, you'll learn about securing
Liferay DXP's JSON web services in the portal.

\subsection{Securing JSON Web
Services}\label{securing-json-web-services-3}

The Liferay Mobile SDK calls Liferay DXP's JSON web services, which are
enabled by default. The web services you call via the Mobile SDK must
remain enabled for those calls to work. It's possible, however, to
disable the web services that you don't need to call. For instructions
on this, see the tutorial
\href{/docs/7-0/tutorials/-/knowledge_base/t/portal-configuration-of-json-web-services}{Configuring
JSON Web Services}. You can also use
\href{/docs/7-0/tutorials/-/knowledge_base/t/service-access-policies}{Service
Access Policies} for more fine-grained control over accessible services.

\subsection{Step 1: Create a Session}\label{step-1-create-a-session}

A session is a conversion state between the client and server, that
consists of multiple requests and responses between the two. You need a
session to pass requests between your app and the Mobile SDK. In most
cases, sessions need to be created with user authentication. The imports
and code required to create a session are shown here:

\begin{verbatim}
import com.liferay.mobile.android.auth.basic.BasicAuthentication;
import com.liferay.mobile.android.service.Session;
import com.liferay.mobile.android.service.SessionImpl;
...
Session session = new SessionImpl("http://10.0.2.2:8080", 
    new BasicAuthentication("test@example.com", "test"));
\end{verbatim}

The arguments to \texttt{SessionImpl} are used to create the session.
The first parameter is the URL of the Liferay instance you're connecting
to. If you're running your app on Android Studio's emulator,
\texttt{http://10.0.2.2:8080} is equivalent to
\texttt{http://localhost:8080}. Be sure to replace this with the correct
address for your server.

\noindent\hrulefill

\textbf{Warning:} Be careful when using administrator credentials on a
production Liferay instance, as you'll have permission to call any
service. Make sure not to modify data by accident. Of course, the
default administrator credentials should be disabled on a production
Liferay instance.

\noindent\hrulefill

The second parameter creates a new \texttt{BasicAuthentication} object
containing the user's credentials. Depending on the authentication
method used by your Liferay instance, you need to provide the user's
email address, screen name, or user ID. You also need to provide the
user's password. The \texttt{BasicAuthentication} object tells the
session to use Basic Authentication to authenticate each service call.
The Mobile SDK also supports OAuth authentication, as long as the OAuth
Provider portlet is deployed to your Liferay instance. To learn how to
use OAuth authentication with the Mobile SDK, see the
\href{https://github.com/brunofarache/liferay-android-sdk-oauth}{OAuth
sample app}. Also, note that the OAuth Provider portlet is only
available to customers with an active Liferay subscription.

If you're building a sign in view for your app, you can use the
\texttt{SignIn} utility class to check if the credentials given by the
user are valid.

\begin{verbatim}
import com.liferay.mobile.android.auth.SignIn;
...
SignIn.signIn(session, new JSONObjectAsyncTaskCallback() {

    @Override
    public void onSuccess(JSONObject userJSONObject) {
        System.out.println("Successful sign-in, user details: " + userJSONObject)
    }

    @Override
    public void onFailure(Exception e) {
        e.printStackTrace();
    }

});
\end{verbatim}

Note that the Mobile SDK doesn't keep a persistent connection or session
with the server. Each request is sent with the user's credentials
(except when using OAuth). However, the \texttt{SignIn} class provides a
way to return user information after a successful sign-in.

Next, you're shown how to create an unauthenticated session in the
limited cases where this is possible.

\subsubsection{Creating an Unauthenticated
Session}\label{creating-an-unauthenticated-session}

In some cases, it's possible to create a \texttt{Session} instance
without user credentials. However, most Liferay remote methods don't
accept unauthenticated remote calls. Making a call with an
unauthenticated session generates an
\texttt{Authentication\ access\ required} exception in most cases.

Unauthenticated service calls only work if the remote method in the
Liferay instance or your plugin has the \texttt{@AccessControlled}
annotation. This is shown here for the hypothetical class
\texttt{FooServiceImpl} and its method \texttt{bar}:

\begin{verbatim}
import com.liferay.portal.security.ac.AccessControlled;
...
public class FooServiceImpl extends FooServiceBaseImpl {
...
    @AccessControlled(guestAccessEnabled = true)
    public void bar() { ... }
...
\end{verbatim}

To make such a call, you need to use the constructor that accepts the
server URL only:

\begin{verbatim}
Session session = new SessionImpl("http://10.0.2.2:8080");
\end{verbatim}

Fantastic! Now that you have a session, you can use it to call Liferay's
services.

\subsection{Step 2: Import the Liferay Services You
Need}\label{step-2-import-the-liferay-services-you-need}

First, you should determine the Liferay services you need to call. You
can find the available services at
\href{http://localhost:8080/api/jsonws}{\texttt{http://localhost:8080/api/jsonws}}.
Be sure to replace \texttt{http://localhost:8080} in this URL with your
server's address.

Add the imports for the services you need to call. For example, if
you're building a blogs app, you can import \texttt{BlogsEntryService}:

\begin{verbatim}
import com.liferay.mobile.android.v62.blogsentry.BlogsEntryService;
\end{verbatim}

Note that the Liferay version (\texttt{.v62}) is used in the package
namespace. Since the Mobile SDK is built for a specific Liferay version,
service classes for different Liferay versions are separated by their
package names. In this example, the Mobile SDK classes use the
\texttt{.v62} package, which means this Mobile SDK is compatible with
Liferay 6.2. Mobile SDK classes compatible with Liferay 7.0 use the
\texttt{v7} package. This namespacing lets your app support multiple
Liferay versions.

\subsection{Step 3: Create a Service Object and Call its Service
Methods}\label{step-3-create-a-service-object-and-call-its-service-methods}

Once you have a session and the required imports, you're ready to make
the service call. This is done by creating a service object for the
service you want to call, and then calling its service methods. For
example, if you're creating a blogs app, you need to use
\texttt{BlogsEntryService} to get all the blogs entries from a site.
This is demonstrated by the following code:

\begin{verbatim}
BlogsEntryService service = new BlogsEntryService(session);

JSONArray jsonArray = service.getGroupEntries(10184, 0, 0, -1, -1);
\end{verbatim}

This fetches all blog entries from the \emph{Guest} site. In this
example, the \emph{Guest} site's \texttt{groupId} is \texttt{10184}.
Note that many service methods require \texttt{groupId} as a parameter.
You can get the user's groups by calling the \texttt{getUserSites()}
method from \texttt{GroupService}.

Service method return types can be \texttt{void}, \texttt{String},
\texttt{JSONArray}, or \texttt{JSONObject}. Primitive type wrappers can
be \texttt{Boolean}, \texttt{Integer}, \texttt{Long}, or
\texttt{Double}.

This \texttt{BlogsEntryService} call is a basic example of a synchronous
service call; the method only returns after the request finishes.
However, Android doesn't allow network communication from an app's main
UI thread. Service calls issued from the main UI thread need need to be
asynchronous. For instructions on doing this, see the tutorial
\href{/docs/7-0/tutorials/-/knowledge_base/t/invoking-services-asynchronously-from-your-android-app}{Invoking
Services Asynchronously from Your Android App}.

Great! Now you're familiar with the basics of accessing Liferay services
through the Mobile SDK. However, there are some special cases you may
run into when making service calls from your app. These are discussed in
the following sections.

\subsection{Non-Primitive Arguments}\label{non-primitive-arguments}

There are some special cases in which a service method's arguments
aren't primitives. In these cases, you should use
\texttt{JSONObjectWrapper}. For example:

\begin{verbatim}
JSONObjectWrapper wrapper = new JSONObjectWrapper(new JSONObject());
\end{verbatim}

You must pass a JSON containing the object properties and their values.
On the server side, your object is instantiated and setters for each
property are called with the values from the JSON you passed.

There are other cases in which service methods require interfaces or
abstract classes as arguments. Since it's impossible for the SDK to
guess which implementation you want to use, you must initialize
\texttt{JSONObjectWrapper} with the class name. For example:

\begin{verbatim}
JSONObjectWrapper wrapper = new JSONObjectWrapper(className, new JSONObject());
\end{verbatim}

The server looks for the class name in its classpath and instantiates
the object for you. It then calls setters, as in the previous example.
The abstract class \texttt{OrderByComparator} is a good example of this.
This is discussed next.

\subsubsection{OrderByComparator}\label{orderbycomparator}

On the server side, \texttt{OrderByComparator} is an abstract class. You
must therefore pass the name of a class that implements it. For example:

\begin{verbatim}
String className = "com.liferay.portlet.bookmarks.util.comparator.EntryNameComparator";

JSONObjectWrapper orderByComparator = new JSONObjectWrapper(className, new JSONObject());
\end{verbatim}

If the service you're calling accepts \texttt{null} for a comparator
argument, pass \texttt{null} to the service call.

You may want to set the ascending property for a comparator.
Unfortunately, as of Liferay 6.2, most Liferay
\texttt{OrderByComparator} implementations don't have a setter for this
property and it isn't possible to set from the Mobile SDK. Future
Liferay versions may address this. However, you may have a custom
\texttt{OrderByComparator} that has a setter for ascending. In this
case, you can use the following code:

\begin{verbatim}
String className = "com.example.MyOrderByComparator";

JSONObject jsonObject = new JSONObject();
jsonObject.put("ascending", true);

JSONObjectWrapper orderByComparator = new JSONObjectWrapper(className, jsonObject);
\end{verbatim}

For more examples, see the test case
\href{https://github.com/liferay/liferay-mobile-sdk/blob/master/android/src/test/java/com/liferay/mobile/android/OrderByComparatorTest.java}{\texttt{OrderByComparatorTest.java}}.

\subsubsection{ServiceContext}\label{servicecontext}

Another non-primitive argument is \texttt{ServiceContext}. It requires
special attention because most Liferay service methods require it.
However, you aren't required to pass it to the SDK; you can pass
\texttt{null} instead. The server then creates a \texttt{ServiceContext}
instance for you, using default values.

If you need to set properties for \texttt{ServiceContext}, you can do so
by adding them to a new \texttt{JSONObject} and then passing it as the
\texttt{ServiceContext} argument:

\begin{verbatim}
JSONObject jsonObject = new JSONObject();
jsonObject.put("addGroupPermissions", true);
jsonObject.put("addGuestPermissions", true);

JSONObjectWrapper serviceContext = new JSONObjectWrapper(jsonObject);
\end{verbatim}

For more examples, see the test case
\href{https://github.com/liferay/liferay-mobile-sdk/blob/master/android/src/test/java/com/liferay/mobile/android/ServiceContextTest.java}{\texttt{ServiceContextTest.java}}.

\subsubsection{Binaries}\label{binaries}

Some Liferay services require argument types such as byte arrays
(\texttt{byte{[}{]}}) and Files (\texttt{java.io.File}).

The Mobile SDK converts byte arrays to strings before sending the POST
request. For example, \texttt{"hello".getBytes("UTF-8")} becomes a JSON
array such as \texttt{"{[}104,101,108,108,111{]}"}. The Mobile SDK does
this for you so you don't have worry about it; you only need to pass the
byte array to the method.

However, you need to be careful when using such methods. This is because
you're allocating memory for the whole byte array, which may cause
memory issues if the content is large.

Other Liferay service methods require \texttt{java.io.File} as an
argument. In these cases, the Mobile SDK requires
\texttt{InputStreamBody} instead. To accomodate this, you need to create
an \texttt{InputStream} and pass it to the \texttt{InputStreamBody}
constructor, along with the file's mime type and name. For example:

\begin{verbatim}
InputStream is = context.getAssets().open("file.png");
InputStreamBody file = new InputStreamBody(is, "image/png", "file.png");
\end{verbatim}

The Mobile SDK sends a multipart form request to the Liferay instance.
On the server side, a \texttt{File} instance is created and sent to the
service method you're calling.

It's also possible to cancel or monitor service calls that upload data
to Liferay. Every service that uploads data returns an
\texttt{AsyncTask} instance. You can use it to cancel the upload if
needed. If want to listen for upload progress to create a progress bar,
you can create an \texttt{UploadProgressAsyncTaskCallback} callback and
set it to the current \texttt{Session} object. Its \texttt{onProgress}
method is called for each byte chunk sent. It passes the total number of
uploaded bytes so far. For example:

\begin{verbatim}
session.setCallback(

    new UploadProgressAsyncTaskCallback<JSONObject>() {

        (...)

        public void onProgress(int totalBytes) {
            // This method will be called for each byte chunk sent.
            // The totalBytes argument will contain the total number
            // of uploaded bytes, from 0 to the total size of the
            // request.
        }

        (...)

    }
);
\end{verbatim}

For more examples on this subject, see the \texttt{addFileEntry*}
methods in
\href{https://github.com/liferay/liferay-mobile-sdk/blob/master/android/src/test/java/com/liferay/mobile/android/DLAppServiceTest.java}{\texttt{DLAppServiceTest.java}}

As you can see, the Mobile SDK does a great deal of work for you even
when special service method arguments are required.

\subsection{Related Topics}\label{related-topics-111}

\href{/docs/7-0/tutorials/-/knowledge_base/t/invoking-services-asynchronously-from-your-android-app}{Invoking
Services Asynchronously from Your Android App}

\href{/docs/7-0/tutorials/-/knowledge_base/t/building-mobile-sdks}{Building
Mobile SDKs}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-ios-apps-that-use-the-mobile-sdk}{Creating
iOS Apps that Use the Mobile SDK}

\section{Invoking Services Asynchronously from Your Android
App}\label{invoking-services-asynchronously-from-your-android-app}

Android doesn't allow synchronous HTTP requests to be made from the main
UI thread. You can use Android's
\href{http://developer.android.com/reference/android/os/AsyncTask.html}{\texttt{AsyncTask}}
to make synchronous requests from threads other than the main UI thread.
If you don't want to use \texttt{AsyncTask}, you can make asynchronous
requests through the Mobile SDK. To do so, you need to implement and
instantiate a callback class, and then set it to the session. When the
Mobile SDK makes your service calls for that session, it then makes them
asynchronously. To make synchronous calls again, set \texttt{null} as
the session's callback.

With the following steps, this tutorial shows you how to implement
asynchronous requests in your Android app:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Implement and instantiate your callback class.
\item
  Set the callback on the session.
\item
  Call Liferay services.
\end{enumerate}

Now go ahead and get started!

\subsection{Implementing and Instantiating Your Callback
Class}\label{implementing-and-instantiating-your-callback-class}

Before implementing and instantiating your callback class, you should
add the required imports. The imports you add depend on the return type
of the service method you're calling. For example, if you need to call
the service method \texttt{getGroupEntries} to retrieve blog entries
from a site's Blogs portlet, you need to import the Mobile SDK's
\texttt{AsyncTaskCallback} and \texttt{JSONArrayAsyncTaskCallback}:

\begin{verbatim}
import com.liferay.mobile.android.task.callback.AsyncTaskCallback;
import com.liferay.mobile.android.task.callback.typed.JSONArrayAsyncTaskCallback;
\end{verbatim}

This is because the \texttt{getGroupEntries} returns a
\texttt{JSONArray}. There are multiple \texttt{AsyncTaskCallback}
implementations, one for each method return type:

\begin{itemize}
\tightlist
\item
  \texttt{JSONObjectAsyncTaskCallback}
\item
  \texttt{JSONArrayAsyncTackCallback}
\item
  \texttt{StringAsyncTaskCallback}
\item
  \texttt{BooleanAsyncTaskCallback}
\item
  \texttt{IntegerAsyncTaskCallback}
\item
  \texttt{LongAsyncTaskCallback}
\item
  \texttt{DoubleAsyncTaskCallback}
\end{itemize}

It's also possible to use a generic \texttt{AsyncTaskCallback}
implementation called \texttt{GenericAsyncTaskCallback}. To do so, you
must implement a transform method and handle JSON parsing yourself.

If you still don't want to use any of these callbacks, you can implement
\texttt{AsyncTaskCallback} directly. However, you should be careful when
doing so. You should always get the first element of the
\texttt{JSONArray} passed as a parameter to the
\texttt{onPostExecute(JSONArray\ jsonArray)} method (for example,
\texttt{jsonArray.get(0)}).

Next, implement and instantiate your callback class. When implementing
your callback class, you need to implement its \texttt{onFailure} and
\texttt{onSuccess} methods. These methods respectivley determine what
your app does when the request fails or succeeds. The
\texttt{onFailure()} method is called if an exception occurs during the
request. This could be triggered by a connection exception (e.g., a
request timeout) or a \texttt{ServerException}. If a
\texttt{ServerException} occurs, it's because something went wrong on
the server side. For example, if you pass a \texttt{groupId} that
doesn't exist, the Liferay instance complains about it, and the Mobile
SDK wraps the error message with \texttt{ServerException}.

The \texttt{onSuccess} method is called on the main UI thread after the
request finishes. Since the request is asynchronous, the service call
immediately returns a \texttt{null} object. The service delivers the
service's real return value to the callback's \texttt{onSuccess()}
method, instead.

Example code is shown here for \texttt{AsyncTaskCallback} and
\texttt{JSONArrayAsyncTaskCallback}:

\begin{verbatim}
AsyncTaskCallback callback = new JSONArrayAsyncTaskCallback() {

    public void onFailure(Exception exception) {
        // Implement exception handling code
    }

    public void onSuccess(JSONArray result) {
        // Called after request has finished successfully
    }

};
\end{verbatim}

Now that you have your callback class, you can set it to the session.

\subsection{Setting the Callback to the
Session}\label{setting-the-callback-to-the-session}

Once you've implemented and instantiated your callback class, you're
ready to set it to the session. If you haven't created a session yet, do
so now. The tutorial
\href{/docs/7-0/tutorials/-/knowledge_base/t/invoking-liferay-services-in-your-android-app}{Invoking
Liferay Services in Your Android App} shows you how to create a session.
Now you're ready to set the callback to the session. For example, this
is done here for \texttt{AsyncTaskCallback}:

\begin{verbatim}
session.setCallback(callback);
\end{verbatim}

Pretty simple! Now you're ready to make the service call.

\subsection{Making the Service Call}\label{making-the-service-call}

Last but certainly not least, make the service call. This is done the
same as calling any other service: create a service object from the
session and use it to make the service call. This is also described in
the tutorial
\href{/docs/7-0/tutorials/-/knowledge_base/t/invoking-liferay-services-in-your-android-app}{Invoking
Liferay Services in Your Android App}. An example service call that gets
all the blog entries from a site's Blogs portlet is shown here:

\begin{verbatim}
service.getGroupEntries(10184, 0, 0, -1, -1);
\end{verbatim}

The example code from the above sections is shown together here:

\begin{verbatim}
import com.liferay.mobile.android.task.callback.AsyncTaskCallback;
import com.liferay.mobile.android.task.callback.typed.JSONArrayAsyncTaskCallback;

...

AsyncTaskCallback callback = new JSONArrayAsyncTaskCallback() {

    public void onFailure(Exception exception) {
        // Implement exception handling code
    }

    public void onSuccess(JSONArray result) {
        // Called after request has finished successfully
    }

};

// create a session first
session.setCallback(callback);

// create a service object first
service.getGroupEntries(10184, 0, 0, -1, -1);
\end{verbatim}

Great! Now you know how to invoke services asynchronously from your
Android app.

\subsection{Related Topics}\label{related-topics-112}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-ios-apps-that-use-the-mobile-sdk}{Creating
iOS Apps that Use the Mobile SDK}

\href{/docs/7-0/tutorials/-/knowledge_base/t/building-mobile-sdks}{Building
Mobile SDKs}

\section{Sending Your Android App's Requests Using Batch
Processing}\label{sending-your-android-apps-requests-using-batch-processing}

The Mobile SDK also allows sending requests in batch. This can be much
more efficient than sending separate requests. For example, suppose you
want to delete ten blog entries in a site's Blogs portlet at the same
time. Instead of making a request for each deletion, you can create a
batch of calls and send them all together.

This tutorial shows you how to implement batch processing for your
Android app. It's assumed that you already know how to invoke Liferay
services from your Android app. If you don't, see the tutorial
\href{/docs/7-0/tutorials/-/knowledge_base/t/invoking-liferay-services-in-your-android-app}{Invoking
Liferay Services in Your Android App}. Now get ready to whip up a fresh
batch of service calls!

\subsection{Implementing Batch
Processing}\label{implementing-batch-processing}

Making service calls in batch only requires two extra steps over making
them one at a time:

\begin{itemize}
\tightlist
\item
  Create a batch session with \texttt{BatchSessionImpl}.
\item
  Make the batch service calls with the \texttt{invoke} method of
  \texttt{BatchSessionImpl}.
\end{itemize}

The rest of the steps are the same as making other service calls. You
still need a service object, and you still need to call its service
methods. As an example, here's a code snippet from an app that deletes a
Blogs portlet's blog entries synchronously in batch:

\begin{verbatim}
import com.liferay.mobile.android.service.BatchSessionImpl;

BatchSessionImpl batch = new BatchSessionImpl(session);
BlogsEntryService service = new BlogsEntryService(batch);

service.deleteEntry(1);
service.deleteEntry(2);
service.deleteEntry(3);

JSONArray jsonArray = batch.invoke();
\end{verbatim}

So what's going on here? After the import, \texttt{BatchSessionImpl} is
used with a pre-existing session to create a batch session. Note that
the \texttt{BatchSessionImpl} constructor takes either credentials or a
session. Passing a session to the constructor is useful when you already
have a \texttt{Session} object and want to reuse the same credentials.
After creating the service object, several \texttt{deleteEntry} service
calls are created. Since the service object is created with a batch
session, these calls aren't made immediately; they return \texttt{null}
instead. The calls aren't made until issued in batch by calling the
\texttt{invoke()} method on the batch session object. It returns a
\texttt{JSONArray} containing the results for each service call. Since
this example contains three \texttt{deleteEntry} calls, the
\texttt{jsonArray} contains three objects. The results are ordered the
same as the service calls.

Great! But what if you want to make batch calls asynchronously? No
problem! Set the callback as a \texttt{BatchAsyncTaskCallback} instance:

\begin{verbatim}
import com.liferay.mobile.android.task.callback.BatchAsyncTaskCallback;

batch.setCallback(new BatchAsyncTaskCallback() {

    public void onFailure(Exception exception) {
    }

    public void onSuccess(JSONArray results) {
        // The result is always a JSONArray 
    }

});
\end{verbatim}

This is similar to the procedure for making asynchronous calls as
described in the tutorial
\href{/docs/7-0/tutorials/-/knowledge_base/t/invoking-services-asynchronously-from-your-android-app}{Invoking
Services Asynchronously from Your Android App}. Awesome! Now you know
how to make efficient service calls in batch!

\subsection{Related Topics}\label{related-topics-113}

\href{/docs/7-0/tutorials/-/knowledge_base/t/invoking-liferay-services-in-your-android-app}{Invoking
Liferay Services in Your Android App}

\href{/docs/7-0/tutorials/-/knowledge_base/t/invoking-services-asynchronously-from-your-android-app}{Invoking
Services Asynchronously from Your Android App}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-ios-apps-that-use-the-mobile-sdk}{Creating
iOS Apps that Use the Mobile SDK}

\section{Creating iOS Apps that Use the Mobile
SDK}\label{creating-ios-apps-that-use-the-mobile-sdk}

The Liferay Mobile SDK provides a way to streamline the consumption of
Liferay DXP's core web services and utilities, as well as those of
custom apps. It wraps Liferay DXP's JSON web services, making them easy
to call in native mobile apps. It handles authentication, makes HTTP
requests (synchronously or asynchronously), parses JSON results, and
handles server-side exceptions so you can concentrate on \emph{using}
the services in your app.

The Liferay Mobile SDK comes with the Liferay iOS SDK. The official
\href{https://www.liferay.com/community/liferay-projects/liferay-mobile-sdk/overview}{project
page} gives you access to the SDK releases, provides the latest SDK
news, and has forums for you to engage in mobile app development
discussions. Once you configure the Mobile SDK in your app, you can
invoke Liferay DXP services in it.

\begin{figure}
\centering
\includegraphics{./images/mobile-sdk-diagram.png}
\caption{Liferay's Mobile SDK enables your native app to communicate
with Liferay DXP.}
\end{figure}

The iOS Mobile SDK app development tutorials cover these topics:

\begin{itemize}
\tightlist
\item
  Making Liferay and Custom Portlet Services Available in Your iOS App
\item
  Invoking Liferay Services in Your iOS App
\item
  Invoking Services Asynchronously from Your iOS App
\item
  Sending Your iOS App's Requests Using Batch Processing
\end{itemize}

A great way to start is by setting up the Mobile SDK in your iOS
project. This makes Liferay DXP's services available in your app.

\subsection{Related Topics}\label{related-topics-114}

\href{/docs/7-0/tutorials/-/knowledge_base/t/invoking-liferay-services-in-your-ios-app}{Invoking
Liferay Services in Your iOS App}

\href{/docs/7-0/tutorials/-/knowledge_base/t/building-mobile-sdks}{Building
Mobile SDKs}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-android-apps-that-use-the-mobile-sdk}{Creating
Android Apps that Use the Mobile SDK}

\section{Making Liferay and Custom Portlet Services Available in Your
iOS
App}\label{making-liferay-and-custom-portlet-services-available-in-your-ios-app}

Your iOS app is no doubt pretty great, or at least off to a great start.
Now you want it to access Liferay services. How do you accomplish this?
Use Liferay's iOS Mobile SDK, of course! You must install the correct
Mobile SDKs in your iOS project to call the remote services you need in
your app. You should first install Liferay's prebuilt Mobile SDK. This
is required for any app that leverages Liferay. To call your custom
portlet's services, you also need to install the Mobile SDK that you
built for it. For instructions on building a Mobile SDK for your custom
portlet, see the tutorial
\href{/docs/7-0/tutorials/-/knowledge_base/t/building-mobile-sdks}{Building
Mobile SDKs}.

This tutorial shows you how to install Liferay's prebuilt Mobile SDK,
and any custom built Mobile SDKs. First, you'll learn how to use
\href{https://cocoapods.org/}{CocoaPods} to install Liferay's prebuilt
Mobile SDK. You'll then learn how to install a Mobile SDK manually,
which is required for installing any custom built Mobile SDKs. Now go
forth and fear no remote service!

\subsection{Installing the SDK Using
CocoaPods}\label{installing-the-sdk-using-cocoapods}

Using CocoaPods is the simplest way to install Liferay's prebuilt Mobile
SDK. The steps for doing so are shown here:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Make sure you have \href{https://cocoapods.org/}{CocoaPods} installed.
\item
  Create a file called \texttt{Podfile} in your project. Add the
  following line in this file:

\begin{verbatim}
 pod 'Liferay-iOS-SDK'
\end{verbatim}
\item
  Run \texttt{pod\ install} from your project's directory. This
  downloads the latest version of the Liferay iOS Mobile SDK and creates
  a \texttt{.xcworkspace} file. CocoaPods also downloads all the
  necessary dependencies and configures your workspace. Note that you
  may have to run \texttt{pod\ repo\ update} before running
  \texttt{pod\ install}; this ensures you have the latest version of the
  CocoaPods repository on your machine.
\item
  Use the \texttt{.xcworkspace} file to open your project in Xcode.
\item
  If you're importing dependencies as frameworks
  (\texttt{use\_frameworks!} in your Podfile), you need to import the
  \texttt{LRMobileSDK} module:

\begin{verbatim}
 @import LRMobileSDK; // (Objective-C)
 import LRMobileSDK // (Swift)
\end{verbatim}
\end{enumerate}

For more information on how CocoaPods works, see their
\href{http://guides.cocoapods.org/using/index.html}{documentation}.
Next, you'll learn how to install a Mobile SDK manually.

\subsection{Installing an iOS SDK
Manually}\label{installing-an-ios-sdk-manually}

You can also install Mobile SDKs manually. This is required if you built
one for your custom portlet's services. You can also install install
Liferay's prebuilt Mobile SDK manually if you don't want to use
CocoaPods.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  To install Liferay's prebuilt Mobile SDK, first
  \href{https://github.com/liferay/liferay-mobile-sdk/releases}{download}
  the latest version of the Liferay iOS Mobile SDK ZIP file. If you
  built your own Mobile SDK, find its ZIP file on your machine. This is
  detailed in the
  \href{/docs/7-0/tutorials/-/knowledge_base/t/building-mobile-sdks}{Building
  Mobile SDKs} tutorial.
\item
  Unzip the file into your Xcode project.
\item
  Within Xcode, right-click on your project and click \emph{Add Files to
  `Project Name'}.
\item
  Add the \texttt{core} and \texttt{v7} folders. Note the \texttt{v7}
  folder's name can change for each Liferay version. In this example,
  the SDK is built for Liferay 7.0.
\item
  If you're manually installing Liferay's prebuilt Mobile SDK, it also
  requires
  \href{https://github.com/AFNetworking/AFNetworking/releases/tag/2.6.3}{AFNetworking
  2.6.3}. Add its source code to your project.
\end{enumerate}

Great! Now you know how to manually install a Mobile SDK in your iOS
apps.

\subsection{Understanding Liferay and iOS
Compatibility}\label{understanding-liferay-and-ios-compatibility}

Each Liferay Mobile SDK is designed to work with a specific Liferay
version. The Liferay Mobile SDK version number reflects this. The first
two digits of each Mobile SDK's version number correspond to the
compatible Liferay version. For example, a Mobile SDK version
\texttt{6.2.*} is compatible with Liferay 6.2, while a Mobile SDK
version \texttt{7.0.*} is compatible with Liferay 7.0. Any digits after
the first two correspond to the internal Liferay Mobile SDK build.

The Mobile SDK's service class names are also suffixed with the Mobile
SDK's version number. This lets your app support several Liferay
versions. For example, you can add Mobile SDK versions \texttt{6.2.0.22}
and \texttt{7.0.3} to the same project. The Mobile SDK service classes
supporting Liferay versions 6.2 and 7.0 end in \texttt{\_v62.m} and
\texttt{\_v7.m}, respectively. To find out the Liferay versions your app
connects to, use the
\texttt{{[}LRPortalVersionUtil\ getPortalVersion:...{]}} method.

The Liferay iOS Mobile SDK is compatible with iOS versions 7.0 and up.
Older iOS versions may work, but compatibility is untested.

\subsection{Making Custom Portlet Services Available in Your iOS
App}\label{making-custom-portlet-services-available-in-your-ios-app}

If you want to invoke remote web services for your custom portlet, then
you need to generate its client libraries by building an iOS Mobile SDK
yourself. Building an SDK is covered in the tutorial
\href{/docs/7-0/tutorials/-/knowledge_base/t/building-mobile-sdks}{Building
Mobile SDKs}. Once you build an SDK to a ZIP file, you can install it
using the manual installation steps above (make sure to use the ZIP file
you built instead of Liferay's prebuilt ZIP file). Note that because
your custom built SDKs contain \emph{only} the client libraries for
calling your custom portlet services, you must install them alongside
Liferay's prebuilt SDK. Liferay's prebuilt SDK contains additional
classes that are required to construct any remote service call.

\subsection{Related Topics}\label{related-topics-115}

\href{/docs/7-0/tutorials/-/knowledge_base/t/building-mobile-sdks}{Building
Mobile SDKs}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-android-apps-that-use-the-mobile-sdk}{Creating
Android Apps that Use the Mobile SDK}

\section{Invoking Liferay Services in Your iOS
App}\label{invoking-liferay-services-in-your-ios-app}

Once the appropriate Mobile SDKs are set up in your iOS project, you can
access and invoke Liferay DXP services in your app. This tutorial takes
you through the steps you must follow to invoke these services:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Create a session.
\item
  Import the Liferay DXP services you need to call.
\item
  Create a service object and call the service methods.
\end{enumerate}

Since some service calls require special treatment, this tutorial also
shows you how to handle them. Note that the code snippets in this
tutorial are written in Objective-C.

First, you'll learn about securing Liferay DXP's JSON web services in
the portal.

\subsection{Securing JSON Web
Services}\label{securing-json-web-services-4}

The Liferay Mobile SDK calls Liferay DXP's JSON web services, which are
enabled by default. The web services you call via the Mobile SDK must
remain enabled for those calls to work. It's possible, however, to
disable the web services that you don't need to call. For instructions
on this, see the tutorial
\href{/docs/7-0/tutorials/-/knowledge_base/t/portal-configuration-of-json-web-services}{Configuring
JSON Web Services}. You can also use
\href{/docs/7-0/tutorials/-/knowledge_base/t/service-access-policies}{Service
Access Policies} for more fine-grained control over accessible services.

\subsection{Step 1: Create a Session}\label{step-1-create-a-session-1}

A session is a conversion state between the client and server,
consisting of multiple requests and responses between the two. You need
a session to pass requests between your app and the Mobile SDK. In most
cases, sessions need to be created with user authentication. The imports
and code required to create a session are shown here:

\begin{verbatim}
#import "LRBasicAuthentication.h"
#import "LRSession.h"

LRSession *session = [[LRSession alloc] initWithServer:@"http://localhost:8080" 
    authentication:[[LRBasicAuthentication alloc] initWithUsername:@"test@example.com" password:@"test"]];
\end{verbatim}

The \texttt{LRSession} object is created with initializers specifying
the Liferay instance to connect to and the credentials of the user to
authenticate. The \texttt{initWithServer} parameter sets the URL of the
Liferay instance you're connecting to. In this case, the Liferay
instance is running on \texttt{http://localhost:8080}. The iOS emulator
is also running on the same machine. Next, the \texttt{authentication}
parameter takes an \texttt{LRBasicAuthentication} instance with the
credentials of the user to authenticate. Depending on the authentication
method used by your Liferay instance, you need to provide the user's
email address, screen name, or user ID to the \texttt{initWithUsername}
parameter. You also need to provide the user's password to the
\texttt{password} parameter.

Using \texttt{LRBasicAuthentication} tells the session to authenticate
each service call with Basic Authentication. The Mobile SDK also
supports OAuth authentication, as long as the
\href{https://web.liferay.com/marketplace/-/mp/application/45261909}{OAuth
Provider app} is deployed to your Liferay DXP instance. To learn how to
use OAuth authentication with the Mobile SDK, see the
\href{https://github.com/brunofarache/liferay-ios-sdk-oauth}{OAuth
sample app}. Also, note that the OAuth Provider app is only available to
customers with an active Liferay subscription.

\noindent\hrulefill

\textbf{Warning:} Be careful when using administrator credentials on a
production portal instance, as you'll have permission to call any
service. Make sure not to modify data accidentally. Of course, the
default administrator credentials should be disabled on a production
portal instance.

\noindent\hrulefill

If you're building a sign in view for your app, you can use the
\texttt{LRSignIn} utility class to check if the credentials given by the
user are valid:

\begin{verbatim}
#import "LRSignIn.h"

[session
    onSuccess:^(id result) {
        user = result;
        [monitor signal];
    }
    onFailure:^(NSError *e) {
        error = e;
        [monitor signal];
    }
];

[LRSignIn signInWithSession:session callback:session.callback error:&error];
\end{verbatim}

The Mobile SDK doesn't keep a persistent connection or session with the
server. Each request is sent with the user's credentials (except when
using OAuth). However, the \texttt{SignIn} class provides a way to
return user information after a successful sign-in.

You can persist credentials with \texttt{LRCredentialStorage}. It safely
saves the username and password in the keychain:

\begin{verbatim}
[LRCredentialStorage storeCredentialForServer:@"http://localhost:8080" 
    username:@"test@example.com" password:@"test"];
\end{verbatim}

After credentials are stored, you can retrieve them with:

\begin{verbatim}
NSURLCredential *credential = [LRCredentialStorage getCredential];
\end{verbatim}

Alternatively, you can create an \texttt{LRSession} instance directly
with:

\begin{verbatim}
LRSession *session = [LRCredentialStorage getSession];
\end{verbatim}

For more examples of this, see
\href{https://github.com/liferay/liferay-mobile-sdk/blob/ios-6.2.0.17/ios/Test/CredentialStorageTest.m}{\texttt{CredentialStorageTest.m}}.

Next, you're shown how to create an unauthenticated session in the
limited cases where this is possible.

\subsubsection{Creating an Unauthenticated
Session}\label{creating-an-unauthenticated-session-1}

In some cases, it's possible to create an \texttt{LRSession} instance
without user credentials. However, most Liferay remote methods don't
accept unauthenticated remote calls. Making a call with an
unauthenticated session generates an
\texttt{Authentication\ access\ required} exception in most cases.

Unauthenticated service calls only work if the remote method in the
Liferay instance or your plugin has the \texttt{@AccessControlled}
annotation. This is shown here for the hypothetical class
\texttt{FooServiceImpl} and its method \texttt{bar}:

\begin{verbatim}
import com.liferay.portal.security.ac.AccessControlled;
...
public class FooServiceImpl extends FooServiceBaseImpl {
...
    @AccessControlled(guestAccessEnabled = true)
    public void bar() { ... }
...
\end{verbatim}

To make such a call, you need to use the constructor that accepts the
server URL only:

\begin{verbatim}
LRSession *session = [[LRSession alloc] initWithServer:@"http://localhost:8080"];
\end{verbatim}

Fantastic! Now that you have a session, you can use it to call Liferay's
services.

\subsection{Step 2: Import the Service}\label{step-2-import-the-service}

First, you should determine the Liferay services you need to call. You
can find the available services at
\href{http://localhost:8080/api/jsonws}{\texttt{http://localhost:8080/api/jsonws}}.
Be sure to replace \texttt{http://localhost:8080} in this URL with your
server's address.

Once you determine the services you need to call, add their imports. For
example, if you're building a blogs app, you can import
\texttt{LRBlogsEntryService}:

\begin{verbatim}
#import "LRBlogsEntryService_v62.h"
\end{verbatim}

Note that the Liferay version (\texttt{\_v62}) is used in the service
class's name. This corresponds to the Liferay version it's compatible
with. In this example, \texttt{\_v62} is used, which means this Mobile
SDK class is compatible with Liferay 6.2. Mobile SDK classes compatible
with Liferay 7.0 use \texttt{\_v7} instead. Because service class names
contain the Liferay version they're compatible with, you can use several
Mobile SDKs simultaneously to support different Liferay versions in the
same app.

\subsection{Step 3: Calling the
Service}\label{step-3-calling-the-service}

Once you have a session and have imported the service class, you're
ready to make the service call. This is done by creating a service
object for the service you want to call, and then calling its service
methods. For example, if you're creating a blogs app, you need to use
\texttt{LRBlogsEntryService} to get all the blogs entries from a site.
This is demonstrated by the following code.

\begin{verbatim}
LRBlogsEntryService_v62 *service = [[LRBlogsEntryService_v62 alloc] initWithSession:session];

NSError *error;
NSArray *entries = [service getGroupEntriesWithGroupId:10184 status:0 start:-1 end:-1 error:&error];
\end{verbatim}

This fetches all blog entries from the \emph{Guest} site. In this
example, the \emph{Guest} site's \texttt{groupId} is \texttt{10184}.
Note that many service methods require \texttt{groupId} as a parameter.
You can get the user's groups by calling
\texttt{{[}LRGroupService\_v62\ getUserSites:\&error{]}}.

Service method return types can be \texttt{void}, \texttt{NSString},
\texttt{NSArray}, \texttt{NSDictionary}, \texttt{NSNumber}, and
\texttt{BOOL}.

This \texttt{LRBlogsEntryService} call is a basic example of a
synchronous service call. The method in a synchronous service call
returns only after the request is finished.

\subsection{Non-Primitive Arguments}\label{non-primitive-arguments-1}

There are some special cases in which service method arguments aren't
primitives. In these cases, you should use \texttt{LRJSONObjectWrapper}.
For example:

\begin{verbatim}
LRJSONObjectWrapper *wrapper = [[LRJSONObjectWrapper alloc] 
    initWithJSONObject:[NSDictionary dictionary]];
\end{verbatim}

You must pass a dictionary containing the object's properties and their
values. On the server side, your object is instantiated and setters for
each property are called with the values from the dictionary.

There are some other cases in which service methods require interfaces
or abstract classes as arguments. Since it's impossible for the SDK to
guess which implementation you want to use, you must initialize
\texttt{LRJSONObjectWrapper} with the class name. For example:

\begin{verbatim}
LRJSONObjectWrapper *wrapper = [[LRJSONObjectWrapper alloc] 
    initWithClassName:@"com.example.MyClass" jsonObject:[NSDictionary dictionary]];
\end{verbatim}

The server looks for the class name in its classpath and instantiates
the object for you. It then calls setters, as in the previous example.
The abstract class \texttt{OrderByComparator} is a good example of this.
This is discussed next.

\subsubsection{OrderByComparator}\label{orderbycomparator-1}

On the server side, \texttt{OrderByComparator} is an abstract class. You
must therefore pass the name of a class that implements it. For example:

\begin{verbatim}
NSString *className = @"com.liferay.portlet.bookmarks.util.comparator.EntryNameComparator";

LRJSONObjectWrapper *orderByComparator = [[LRJSONObjectWrapper alloc] initWithClassName:className jsonObject:[NSDictionary dictionary]];
\end{verbatim}

If the service you're calling accepts \texttt{null} for a comparator
argument, pass \texttt{nil} to the service call.

You may want to set the ascending property for a comparator.
Unfortunately, as of Liferay 6.2, most Liferay
\texttt{OrderByComparator} implementations don't have a setter for this
property and it isn't possible to set from the Mobile SDK. Future
Liferay versions may address this. However, you may have a custom
\texttt{OrderByComparator} that has a setter for ascending. In this
case, you can use the following code:

\begin{verbatim}
NSString *className = @"com.example.MyOrderByComparator";

NSDictionary *jsonObject = @{
    @"ascending": @(YES)
};

LRJSONObjectWrapper *orderByComparator = [[LRJSONObjectWrapper alloc] 
    initWithClassName:className jsonObject:jsonObject];
\end{verbatim}

For more examples, see the test case
\href{https://github.com/liferay/liferay-mobile-sdk/blob/ios-6.2.0.17/ios/Test/OrderByComparatorTest.m}{\texttt{OrderByComparatorTest.m}}.

\subsubsection{ServiceContext}\label{servicecontext-1}

Another non-primitive argument is \texttt{ServiceContext}. It requires
special attention because most Liferay service methods require it.
However, you aren't required to pass it to the SDK; you can pass
\texttt{nil} instead. The server then creates a \texttt{ServiceContext}
instance for you, using default values.

If you need to set properties for \texttt{ServiceContext}, you can do so
by adding them to a new \texttt{NSDictionary} and then passing it as the
\texttt{ServiceContext} argument:

\begin{verbatim}
NSDictionary *jsonObject = @{
    @"addGroupPermissions": @(YES),
    @"addGuestPermissions": @(YES)
};

LRJSONObjectWrapper *serviceContext = [[LRJSONObjectWrapper alloc] initWithJSONObject:jsonObject];
\end{verbatim}

For more examples, see the test case
\href{https://github.com/liferay/liferay-mobile-sdk/blob/ios-6.2.0.17/ios/Test/ServiceContextTest.m}{\texttt{ServiceContextTest.m}}.

\subsubsection{Binaries}\label{binaries-1}

Some Liferay services require binary argument types like \texttt{NSData}
or \texttt{LRUploadData}. The Mobile SDK converts \texttt{NSData}
instances to \texttt{NSString} before sending the POST request. For
example, \texttt{{[}@"hello"\ dataUsingEncoding:NSUTF8StringEncoding{]}}
becomes a JSON array such as \texttt{"{[}104,101,108,108,111{]}"}. The
Mobile SDK does this for you, so you don't have worry about it; you only
need to pass the \texttt{NSData} instance to the method.

However, you need to be careful when using such methods. This is because
you're allocating memory for the whole \texttt{NSData}, which may cause
memory issues if the content is large.

Other Liferay service methods require \texttt{java.io.File} as an
argument. In these cases the Mobile SDK requires \texttt{LRUploadData}
instead. Here are two examples of creating \texttt{LRUploadData}
instances:

\begin{verbatim}
LRUploadData *upload = [[LRUploadData alloc] 
    initWithData:data fileName:@"file.png" mimeType:@"image/png"];

LRUploadData *upload = [[LRUploadData alloc] 
    initWithInputStream:is length:length fileName:@"file.png" mimeType:@"image/png"];
\end{verbatim}

The first constructor accepts an \texttt{NSData} argument, while the
second accepts \texttt{NSInputStream}. As you can see, you also need to
pass the file's mime type and name. The \texttt{length} is the size in
bytes of the content being sent. The SDK sends a multipart form request
to the Liferay instance. On the server side, a \texttt{File} instance is
created and sent to the service method you're calling.

It's also possible to monitor service calls that upload data to Liferay.
If want to listen for upload progress to create a progress bar, you can
create a \texttt{LRProgressDelegate} delegate and set it to an
\texttt{LRUploadData} object. Its \texttt{onProgressBytes} method is
called for each byte chunk sent. It passes the bytes that were sent, the
total number of bytes sent so far, and the total request size. For
example:

\begin{verbatim}
@interface ProgressDelegate : NSObject <LRProgressDelegate>

@end

@implementation ProgressDelegate

- (void)onProgressBytes:(NSUInteger)bytes sent:(long long)sent
    total:(long long)total {

        // bytes contains the byte values that were sent.
        // sent will contain the total number of bytes sent.
        // total will contain the total size of the request in bytes.

}

@end
\end{verbatim}

For more examples of this, see the test case
\href{https://github.com/liferay/liferay-mobile-sdk/blob/ios-6.2.0.17/ios/Test/FileUploadTest.m}{\texttt{FileUploadTest.m}}.

\subsection{Related Topics}\label{related-topics-116}

\href{/docs/7-0/tutorials/-/knowledge_base/t/building-mobile-sdks}{Building
Mobile SDKs}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-android-apps-that-use-the-mobile-sdk}{Creating
Android Apps that Use the Mobile SDK}

\section{Invoking Services Asynchronously from Your iOS
App}\label{invoking-services-asynchronously-from-your-ios-app}

The main drawback of using synchronous requests from your app is that
each request must terminate before another can begin. If you're sending
a large number of synchronous requests, performance suffers as a
bottleneck forms while each one waits to be processed. Fortunately,
Liferay's iOS SDK allows \emph{asynchronous} HTTP requests. To do so,
you need to set a callback to the session object. If you want to make
synchronous requests again, you can set the callback to \texttt{nil}.

With the following steps, this tutorial shows you how to implement
asynchronous requests in your iOS app:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Implement your callback class.
\item
  Instantiate your callback class and set it to the session.
\item
  Call Liferay services.
\end{enumerate}

Objective-C is used in the code snippets that follow. Let the requesting
begin!

\subsection{Implementing Your Callback
Class}\label{implementing-your-callback-class}

To configure asynchronous requests, first create a class that conforms
to the \texttt{LRCallback} protocol. When implementing this callback
class, you need to implement its \texttt{onFailure} and
\texttt{onSuccess} methods. These methods respectively determine what
your app does when the request fails or succeeds. If a server side
exception or a connection error occurs during the request, the
\texttt{onFailure} method is called with an \texttt{NSError} instance
that contains information about the error. Note that the
\texttt{onSuccess} result parameter doesn't have a specific type. When
deciding what to cast it to, you need to check the type in the service
method signature.

The example code here implements a callback class for an app that
retrieves blog entries from a Blogs portlet. The service method for this
call is \texttt{getGroupEntriesWithGroupId}, which returns an
\texttt{NSArray} instance. The \texttt{onSuccess} method's result
parameter is therefore cast to this type:

\begin{verbatim}
#import "LRCallback.h"

@interface BlogsEntriesCallback : NSObject <LRCallback>

@end


#import "BlogsEntriesCallback.h"

@implementation BlogsEntriesCallback

- (void)onFailure:(NSError *)error {
    // Implement error handling code
}

- (void)onSuccess:(id)result {
    // Called after request has finished successfully
    NSArray *entries = (NSArray *)result;
}

@end
\end{verbatim}

Awesome! Now you have a callback class that you can use with the
session.

\subsection{Set the Callback to the
Session}\label{set-the-callback-to-the-session}

Next, create an instance of this callback and set it to the session. If
you haven't created a session yet, do so now. The tutorial
\href{/docs/7-0/tutorials/-/knowledge_base/t/invoking-liferay-services-in-your-ios-app}{Invoking
Liferay Services in Your iOS App} shows you how to create a session. Now
you're ready to set the callback to the session. For example, this is
done here for \texttt{BlogsEntriesCallback}:

\begin{verbatim}
BlogsEntriesCallback *callback = [[BlogsEntriesCallback alloc] init];

[session setCallback:callback];
\end{verbatim}

Pretty simple! Now you're ready to make the service call.

\subsection{Making the Service Call}\label{making-the-service-call-1}

Last but certainly not least, make the service call. This is done the
same as calling any other service: create a service object from the
session and use it to make the service call. This is also described in
the tutorial
\href{/docs/7-0/tutorials/-/knowledge_base/t/invoking-liferay-services-in-your-ios-app}{Invoking
Liferay Services in Your iOS App}. Here, an example service call that
gets all the blog entries from a site's Blogs portlet is shown:

\begin{verbatim}
[service getGroupEntriesWithGroupId:10184 status:0 start:-1 end:-1 error:&error];
\end{verbatim}

Since the request is asynchronous, \texttt{getGroupEntriesWithGroupId}
immediately returns \texttt{nil}. Once the request finishes
successfully, the \texttt{onSuccess} method of your callback is invoked
with the results on the main UI thread.

Great! Now you know how to make asynchronous requests in your iOS apps.
However, there's another way to accomplish the same thing. This is
discussed next.

\subsection{Using Blocks as Callbacks}\label{using-blocks-as-callbacks}

Instead of implementing a separate callback class, you can use an
Objective-C block as a callback. An example of this is shown here for an
asynchronous call that retrieves a user's sites. Note that this includes
all the code required to make the call:

\begin{verbatim}
LRSession *session = [[LRSession alloc] 
    initWithServer:@"http://localhost:8080" username:@"test@example.com" password:@"test"];

[session
    onSuccess:^(id result) {
        // Called after request has finished successfully
    }
    onFailure:^(NSError *e) {
        // Implement error handling code
    }
];

LRGroupService_v62 *service = [[LRGroupService_v62 alloc] initWithSession:session];

NSError *error;
[service getUserSites:&error];
\end{verbatim}

When using a block as a callback, take care not to also set an
\texttt{LRCallback} instance to the session. If you do, it gets
overridden. Otherwise, support for blocks works the same way as
described in the previous sections.

Super! Now you know two different ways to make asynchronous service
requests in your iOS apps.

\subsection{Related Topics}\label{related-topics-117}

\href{/docs/7-0/tutorials/-/knowledge_base/t/invoking-liferay-services-in-your-ios-app}{Invoking
Liferay Services in Your iOS App}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-android-apps-that-use-the-mobile-sdk}{Creating
Android Apps that Use the Mobile SDK}

\section{Sending Your iOS App's Requests Using Batch
Processing}\label{sending-your-ios-apps-requests-using-batch-processing}

The Mobile SDK also allows sending requests in batch. This can be much
more efficient than sending separate requests. For example, suppose you
want to delete ten blog entries in a site's Blogs portlet at the same
time. Instead of making a request for each deletion, you can create a
batch of calls and send them all together.

This tutorial shows you how to implement batch processing for your iOS
app. It's assumed that you already know how to invoke Liferay services
from your iOS app. If you don't, see the tutorial
\href{/docs/7-0/tutorials/-/knowledge_base/t/invoking-liferay-services-in-your-ios-app}{Invoking
Liferay Services in Your iOS App}. Objective-C is used in the code
snippets that follow. Now it's time to whip up a fresh batch of
requests!

\subsection{Implementing Batch
Processing}\label{implementing-batch-processing-1}

Making service calls in batch only requires two extra steps over making
them one at a time:

\begin{itemize}
\tightlist
\item
  Create a batch session with \texttt{LRBatchSession}.
\item
  Make the batch service calls with the \texttt{invoke} method of
  \texttt{LRBatchSession}.
\end{itemize}

The rest of the steps are the same as making other service calls. You
still need a service object, and you still need to call its service
methods. As an example, here's a code snippet from an app that deletes a
Blogs portlet's blog entries synchronously in batch:

\begin{verbatim}
#import "LRBatchSession.h"

LRBatchSession *batch = [[LRBatchSession alloc] 
    initWithServer:@"http://localhost:8080" username:@"test@example.com" password:@"test"];
LRBlogsEntryService_v62 *service = [[LRBlogsEntryService_v62 alloc] initWithSession:batch];
NSError *error;

[service deleteEntryWithEntryId:1 error:&error];
[service deleteEntryWithEntryId:2 error:&error];
[service deleteEntryWithEntryId:3 error:&error];

NSArray *entries = [batch invoke:&error];
\end{verbatim}

So what's going on here? After the import, \texttt{LRBatchSession} is
used with a Liferay instance's URL and a user's credentials to create a
batch session. You can alternatively pass a pre-existing
\texttt{session} to the constructor. This is useful when you already
have a session object and want to reuse the same credentials. Next, the
service calls are made as usual (in this case,
\texttt{deleteEntryWithEntryId}). With asynchronous calls, these methods
return \texttt{nil} right away. Finally, call
\texttt{{[}batch\ invoke:\&error{]}}. This returns an \texttt{NSArray}
containing the results for each service call (the return type for batch
calls is always \texttt{NSArray}). Since there are three
\texttt{deleteEntryWithEntryId} calls, the \texttt{entries} array
contains three objects. The order of the results matches the order of
the service calls.

If you want to make batch calls asynchronously, set the callback to the
session as usual.

\begin{verbatim}
[batch setCallback:callback];
\end{verbatim}

Great! Now you know how to utilize batch processing to speed up your
app's requests.

\subsection{Related Topics}\label{related-topics-118}

\href{/docs/7-0/tutorials/-/knowledge_base/t/invoking-liferay-services-in-your-ios-app}{Invoking
Liferay Services in Your iOS App}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-android-apps-that-use-the-mobile-sdk}{Creating
Android Apps that Use the Mobile SDK}

\section{Building Mobile SDKs}\label{building-mobile-sdks}

The Liferay Mobile SDK lets you connect your Android and iOS apps to a
Liferay DXP instance. By accessing built-in portal services through
Liferay's prebuilt Mobile SDK, your apps can access the out-of-the-box
functionality in a Liferay DXP instance. But what if you want to call
custom services that belong to a custom portlet? No problem! In this
case, you need to build your own Mobile SDK that can call these custom
portlet services.

Note that when you build a Mobile SDK for a portlet, it contains
\emph{only} the classes needed to call that portlet's remote services.
You still need to install Liferay's prebuilt Mobile SDK in your app. It
contains the framework required to construct remote service calls in
general.

The Liferay Mobile SDK project contains a Mobile SDK Builder that
generates a custom Mobile SDK for the Android and iOS platforms. The
Mobile SDK Builder does this by generating client libraries that let
your native mobile apps invoke a custom portlet's remote web services.
Think of the Mobile SDK Builder as a
\href{/docs/7-0/tutorials/-/knowledge_base/t/service-builder}{Service
Builder} on the client side.

This tutorial covers how to build a custom Mobile SDK for Android and
iOS. You'll begin by making sure the remote services are configured for
any custom portlets you have.

\subsection{Configuring Your Portlet's Remote
Services}\label{configuring-your-portlets-remote-services}

For the Mobile SDK Builder to discover a portlet's remote services, the
services must be available and accompanied by a Web Service Deployment
Descriptor (WSDD). For instructions on creating a portlet's remote
services and building its WSDD,
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-remote-services}{click
here}.

Next, you'll download the Liferay Mobile SDK's source code.

\subsection{Downloading the Liferay Mobile
SDK}\label{downloading-the-liferay-mobile-sdk}

To build a Mobile SDK for your custom portlet's services, you need to
have the \href{https://github.com/liferay/liferay-mobile-sdk}{Liferay
Mobile SDK's source code} on your local machine. This code also contains
the Mobile SDK Builder. You can get this code by cloning the Mobile SDK
project via Git, or by downloading it from GitHub. To clone the Mobile
SDK project with Git, open a terminal and navigate to the directory on
your machine in which you want to put the Mobile SDK. Then run this
command:

\begin{verbatim}
git clone git@github.com:liferay/liferay-mobile-sdk.git
\end{verbatim}

Since the Mobile SDK changes frequently, you should check out the latest
stable release for your chosen mobile platform (Android or iOS).
\href{https://github.com/liferay/liferay-mobile-sdk/releases}{Click
here} to see the list of available stable releases. Stable releases
correspond to tags in GitHub that begin with the mobile platform and end
with the Liferay Mobile SDK version. For example, the
\texttt{android-7.0.6} tag corresponds to version 7.0.6 of the Liferay
Mobile SDK for Android. To check out this tag in a new branch of the
same name, you can use this command:

\begin{verbatim}
git checkout tags/android-7.0.6 -b android-7.0.6
\end{verbatim}

Alternatively, you can download the ZIP or TAR.GZ file listed under each
tag on GitHub.

Now you're ready to build the Mobile SDK!

\subsection{Building a Liferay Mobile
SDK}\label{building-a-liferay-mobile-sdk}

After you've downloaded the Mobile SDK's source code, you must build the
module in which you'll build your custom portlet's Mobile SDK. The
Mobile SDK Builder comes with a command line wizard that helps you build
this module. To start the wizard, run the following command in the
Mobile SDK source code's root folder:

\begin{verbatim}
./gradlew createModule
\end{verbatim}

This starts the wizard with the most commonly required properties it
needs to generate code for your portlet. If you need more control over
these properties, run the same command with the \texttt{all} argument:

\begin{verbatim}
./gradlew createModule -P=all
\end{verbatim}

The wizard should look similar to this screenshot. Note that default
values are in square brackets with blue text:

\begin{figure}
\centering
\includegraphics{./images/mobile-sdk-create-module.png}
\caption{The Mobile SDK Builder's wizard lets you specify property
values for building your module.}
\end{figure}

So what properties are available, and what do they do? Fantastic
question! You can set the following properties during or after running
\texttt{createModule}. If you want or need to set these properties after
running \texttt{createModule}, you can do so in your module's
\texttt{gradle.properties} file. The values in parentheses are the keys
used in \texttt{gradle.properties}:

\begin{itemize}
\item
  \texttt{Context\ (context)}: Your portlet's web context. For example,
  if you're generating a Mobile SDK for Liferay DXP's Calendar portlet,
  which is generally deployed to the \texttt{calendar} context, then you
  should set the context value to \texttt{calendar}. If there are no
  services available at the specified context, you may have forgotten to
  generate your portlet's WSDD.
\item
  \texttt{Platforms\ (platforms)}: The platforms to build the Mobile SDK
  for. By default, you can generate code for Android and iOS
  (\texttt{android,ios}).
\item
  \texttt{Server\ URL\ (url)}: Your Liferay DXP instance's URL. To
  discover your services, the Mobile SDK Builder tries to connect to
  this instance at the specified context.
\item
  \texttt{Filter\ (filter)}: Specifies the portlet entities the Mobile
  SDK can access. A blank value specifies all portlet entity services.
  For example, the Calendar portlet's entities include
  \texttt{CalendarBooking} and \texttt{CalendarResource}. To generate a
  Mobile SDK for only the \texttt{CalendarBooking} entity, set the
  filter's value to \texttt{calendarbooking} (all lowercase).
\item
  \texttt{Module\ Version\ (version)}: The version number appended to
  your Mobile SDK's JAR (Android) and ZIP files (iOS). The sections on
  packaging your Mobile SDK explain this further.
\item
  \texttt{Package\ Name\ (packageName)}: On Android, this is the package
  your Mobile SDK's classes are written to (iOS doesn't use packages).
  Note that the Liferay DXP version is appended to the end of the
  package name. For example, if you're using Liferay Portal 7.0 or
  Liferay DXP Digital Enterprise 7.0, and specify
  \texttt{com.liferay.mobile.android} as the package name, the Mobile
  SDK Builder appends \texttt{v7} to the package name, yielding
  \texttt{com.liferay.mobile.android.v7}. This prevents collisions
  between classes with the same name, which lets you use Mobile SDKs for
  more than one portal version in the same app. You can use the
  \texttt{Portal\ Version} property to change the portal version.
\item
  \texttt{POM\ Description\ (description)}: Your POM file's description.
\end{itemize}

Note that there's also a \texttt{destination} property that can only be
set in the \texttt{gradle.properties} file. This property specifies the
destination for the generated source files. You won't generally need to
change this.

After you set the properties you need, the Mobile SDK Builder generates
your module in the folder \texttt{modules/\$\{your\_portlet\_context\}}.

Now you can build your Mobile SDK. To do this, navigate to your module
and run this command:

\begin{verbatim}
../../gradlew generate
\end{verbatim}

By default, the builder writes the source files to
\texttt{android/src/gen/java} and \texttt{ios/Source} in your module's
folder.

If you update your portlet's remote services on the server side and need
to update your Mobile SDK, simply run \texttt{../../gradlew\ generate}
again.

Awesome! Now you know how to create and regenerate a Mobile SDK for your
custom portlet's remote services. Next, you'll finish by packaging your
Mobile SDK for the Android and iOS.

\subsubsection{Packaging Your Mobile SDK for
Android}\label{packaging-your-mobile-sdk-for-android}

To package your Mobile SDK in a JAR file for use in an Android project,
run the following command from your module's folder:

\begin{verbatim}
../../gradlew jar
\end{verbatim}

This packages your Mobile SDK in the following file:

\begin{itemize}
\tightlist
\item
  \texttt{modules/\$\{your\_portlet\_context\}/build/libs/liferay-\$\{your\_portlet\_context\}-android-sdk-\$\{version\}.jar}
\end{itemize}

To call your portlet's remote services, you must first install this file
in your Android project. To do so, copy the file into your Android app's
\texttt{app/libs} folder. Note that you must also install Liferay's
prebuilt Mobile SDK in your app.
\href{/docs/7-0/tutorials/-/knowledge_base/t/making-liferay-and-custom-portlet-services-available-in-your-android-app\#adding-the-sdk-to-your-gradle-project}{Click
here} for instructions on doing this.

Also note that if you regenerate your Mobile SDK to include new
functionality, you can update your module's version in its
\texttt{gradle.properties} file. For example, if you added or changed a
service method in the Mobile SDK you initially built, you could update
it's version by setting \texttt{version=1.1} in your module's
\texttt{gradle.properties} file.

To learn how to use the Mobile SDK in your Android app, see the rest of
the
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-android-apps-that-use-the-mobile-sdk}{Android
Mobile SDK documentation}. You can also use your Mobile SDK to create
custom Screenlets in
\href{/docs/7-0/tutorials/-/knowledge_base/t/android-apps-with-liferay-screens}{Liferay
Screens}.

\subsubsection{Packaging Your Mobile SDK for
iOS}\label{packaging-your-mobile-sdk-for-ios}

To package your Mobile SDK in a ZIP file for use in an iOS project, run
the following command from your module's folder:

\begin{verbatim}
../../gradlew zip
\end{verbatim}

This packages your Mobile SDK in the following file:

\begin{itemize}
\tightlist
\item
  \texttt{modules/\$\{your\_portlet\_context\}/build/liferay-\$\{your\_portlet\_context\}-ios-sdk-\$\{version\}.zip}
\end{itemize}

To call your portlet's remote services, you must first install this file
in your Xcode project. To do so, simply unzip it and add its files to
your Xcode project.

To learn how to use the Mobile SDK in your iOS app, see the rest of the
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-ios-apps-that-use-the-mobile-sdk}{iOS
Mobile SDK documentation}. You can also use your Mobile SDK to create
custom Screenlets in
\href{/docs/7-0/tutorials/-/knowledge_base/t/ios-apps-with-liferay-screens}{Liferay
Screens}.

\subsection{Related Topics}\label{related-topics-119}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-android-apps-that-use-the-mobile-sdk}{Creating
Android Apps that Use the Mobile SDK}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-ios-apps-that-use-the-mobile-sdk}{Creating
iOS Apps that Use the Mobile SDK}

\href{/docs/7-0/tutorials/-/knowledge_base/t/android-apps-with-liferay-screens}{Android
Apps with Liferay Screens}

\href{/docs/7-0/tutorials/-/knowledge_base/t/ios-apps-with-liferay-screens}{iOS
Apps with Liferay Screens}

\chapter{Service Builder}\label{service-builder}

An application without reliable business logic or persistence isn't much
of an application at all. Unfortunately, writing your own persistence
code often takes a great deal of time. Fortunately, Liferay provides the
Liferay Service Builder to generate it for you. You might now be
thinking, ``What?! I hate code generators!'' Not to fear; you can still
write your own persistence code if you wish. And if you choose to use
Service Builder, you can edit and customize the code it generates.
Regardless of how you produce your persistence code, you can then use it
to implement your app's business logic.

This section of tutorials shows you how to use Service Builder to
generate your persistence framework and implement your business logic.
You're also shown how to use Spring in your app.

\section{What is Service Builder?}\label{what-is-service-builder-1}

Service Builder is a model-driven code generation tool built by Liferay
that allows developers to define custom object models called entities.
Service Builder generates a service layer through object-relational
mapping (ORM) technology that provides a clean separation between your
object model and code for the underlying database. This frees you to add
the necessary business logic for your application. Service Builder takes
an XML file as input and generates the necessary model, persistence, and
service layers for your application. These layers provide a clean
separation of concerns. Service Builder generates most of the common
code needed to implement create, read, update, delete, and find
operations on the database, allowing you to focus on the higher level
aspects of service design. In this section, you'll learn some of the
main benefits of using Service Builder:

\begin{itemize}
\tightlist
\item
  Integration with Liferay
\item
  Automatically generated model, persistence, and service layers
\item
  Automatically generated local and remote services
\item
  Automatically generated Hibernate and Spring configurations
\item
  Support for generating finder methods for entities and finder methods
  that account for permissions
\item
  Built-in entity caching support
\item
  Support for custom SQL queries and dynamic queries
\item
  Saved development time
\end{itemize}

Liferay uses Service Builder to generate all of its internal database
persistence code. In fact, all of Liferay's services, both local and
remote, are generated by Service Builder. Additionally, the service
\href{https://github.com/liferay/liferay-portal/tree/7.0.x/modules}{modules}
in Liferay are generated by Service Builder. Service Builder's use in
Liferay Portal demonstrates it to be a robust and reliable tool. Service
Builder is easy to use and can save developers \emph{lots} of
development time. Although the number of files Service Builder generates
can seem intimidating at first, developers only need to work with a few
files in order to make customizations to their applications and add
business logic.

\noindent\hrulefill

\textbf{Note:} You don't have to use Service Builder for Liferay
application development. It's entirely possible to develop Liferay
plugins by writing custom code for database persistence using your
persistence framework of choice. If you so choose, you can work directly
with JPA or Hibernate.

\noindent\hrulefill

One of the main ways Service Builder saves development time is by
completely eliminating the need to write and maintain database access
code. To generate a basic service layer, you only need to create a
\texttt{service.xml} file and run Service Builder. This generates a new
service \texttt{.jar} file for your project. The generated service
\texttt{.jar} file includes a model layer, a persistence layer, a
service layer, and related infrastructure. These distinct layers
represent a healthy separation of concerns. The model layer is
responsible for defining objects to represent your project's entities,
the persistence layer is responsible for saving entities to and
retrieving entities from the database, and the service layer is
responsible for exposing CRUD and related methods for your entities as
an API. The code Service Builder generates is database-agnostic, as is
Liferay itself.

Each entity generated by Service Builder contains a model implementation
class. Each entity also contains a local service implementation class, a
remote service implementation class, or both, depending on how you
configure Service Builder in your \texttt{service.xml} file.
Customizations and business logic can be implemented in these three
classes; in fact, these are the only classes generated by Service
Builder that are intended to be customized. Ensuring that all
customizations take place in only a few classes makes Service Builder
projects easy to maintain. The local service implementation class is
responsible for calling the persistence layer to retrieve and store data
entities. Local services contain the business logic and access the
persistence layer. They can be invoked by client code running in the
same Java Virtual Machine. Remote services usually have additional code
for permission checking and are meant to be accessible from anywhere
over the Internet or your local network. Service Builder automatically
generates the code necessary to allow access to the remote services. The
remote services generated by Service Builder include SOAP utilities and
can be accessed via SOAP or JSON.

Another way Service Builder saves development time is by providing
Spring and Hibernate configurations for your project. Service Builder
uses Spring dependency injection for making service implementation
classes available at runtime and uses Spring AOP for database
transaction management. Service Builder also uses the Hibernate
persistence framework for object-relational mapping. As a convenience to
developers, Service Builder hides the complexities of using these
technologies. Developers can take advantage of Dependency Injection
(DI), Aspect Oriented Programming (AOP), and Object-Relational Mapping
(ORM) in their projects without having to manually set up a Spring or
Hibernate environment or make any configurations.

Another benefit of using Service Builder is that it provides support for
generating finder methods. Finder methods retrieve entity objects from
the database based on specified parameters. You just need to specify the
kinds of finder methods to be generated in the \texttt{service.xml}
configuration file and Service Builder does the rest. The generated
finder methods allow you, for example, to retrieve a list of all
entities associated with a certain site or a list of all entities
associated with a certain site \emph{and} a certain user. Service
Builder not only provides support for generating these kinds of simple
finder methods but also for finder methods that take Liferay's
permissions into account. For example, if you are using Liferay's
permissions system to protect access to your entities, Service Builder
can generate a different kind of finder method that only returns
entities that the logged-in user has permission to view.

Service Builder also provides built-in caching support. Liferay caches
objects at three levels: \emph{entity}, \emph{finder}, and
\emph{Hibernate}. By default, Liferay uses Ehcache as an underlying
cache provider for each of these cache levels. However, this is
configurable via portal properties. All you have to do to enable entity
and finder caching for an entity in your project is to set the
\texttt{cache-enabled=true} attribute of your entity's
\texttt{\textless{}entity\textgreater{}} element in your
\texttt{service.xml} configuration file. Please refer to the
\href{/docs/7-0/deploy/-/knowledge_base/d/liferay-clustering\#modifying-the-cache-configuration-with-a-module}{Distributed
Caching} documentation for more details about Liferay caching.

Service Builder is a flexible tool. It automates many of the common
tasks associated with creating database persistence code but it doesn't
prevent you from creating custom SQL queries or custom finder methods.
Service Builder allows developers to define custom SQL queries in an XML
file and to implement custom finder methods to run the queries. This
could be useful, for example, for retrieving specific pieces of
information from multiple tables via an SQL join. Service Builder also
supports retrieving database information via dynamic query. Liferay's
dynamic query API leverages Hibernate's criteria API.

In summary, we encourage developers to use Service Builder for portlet
and plugin development because it's a proven solution used by many
Liferay plugins and by Liferay Portal itself. It generates distinct
model, persistence, and service layers, local and remote services,
Spring and Hibernate configurations, and related infrastructure without
requiring any manual intervention by developers. It also allows basic
SQL queries and finder methods to be generated and ones that filter
results, taking Liferay's permissions into account. Service Builder also
provides support for entity and query caching. Each of these features
can save lots of development time, both initial development time and
time that would have to be spent maintaining, extending, or customizing
a project. Finally, Service Builder is not a restrictive tool: it allows
custom SQL queries and finder methods to be added and it also supports
dynamic query.

Service Builder supports Liferay 7's modular application development
style. When you configure Service Builder in a Liferay 7 OSGi module,
this module functions as a \emph{service} module and its a convention to
append \texttt{service} to the module's name. Liferay includes a
\href{https://github.com/liferay/liferay-portal/tree/7.0.x/modules/util/portal-tools-service-builder}{Service
Builder plugin} and a build tool-specific plugins such as the
\href{https://github.com/liferay/liferay-portal/tree/7.0.x/modules/util/portal-tools-service-builder}{Gradle
Service Builder plugin}. The Gradle Service Builder plugins includes
Liferay's Service Builder plugin as a dependency. The
\texttt{basic-api}, \texttt{basic-service}, \texttt{basic-web} modules
in the
\href{https://github.com/liferay/liferay-blade-samples/tree/7.0/liferay-workspace/apps/service-builder/basic}{Service
Builder Blade Sample} project serve as example Service Builder projects.

\chapter{Service Builder Persistence}\label{service-builder-persistence}

Liferay's Service Builder can generate your project's persistence layer
by automating the creation of interfaces and classes. Your application's
persistence layer persists data represented by your configured entities
to a database. In fact, your local service implementation classes are
responsible for calling the persistence layer to retrieve and store your
application's data. So instead of taking the time-consuming route of
writing your own persistence layer, you can use Liferay's Service
Builder to quickly define your entities and generate the layer
instantaneously.

In this section of tutorials, you'll learn how to define an
object-relational map and generate your persistence layer from that map.
You'll also learn about the local and remote services Service Builder
generates, and how you can use them for your own application. You'll
also discuss how to use the \texttt{ServiceContext} class, model hints,
SQL queries, and Hibernate's criteria API.

\section{Defining an Object-Relational Map with Service
Builder}\label{defining-an-object-relational-map-with-service-builder}

In this tutorial, you'll learn how to define an object relational map
for your application so that it can persist data. As an example, you'll
examine the existing Liferay Bookmarks application that uses Service
Builder.

The Bookmarks application is an example portlet project that an
organization can use to bookmark assets in Liferay. The application
defines two entities, or model types, to represent an organization's
bookmarks and their folders. These entities are called \emph{bookmark
entries} and \emph{bookmark folders}. Since a bookmark must have a
folder (even if it's a root folder), the entry entity references a
folder entity as one of its attributes.

You can design your application's modules anyway you like, but for the
Bookmarks application, its Java sources reside in the
\texttt{bookmarks-api}, \texttt{bookmarks-service}, and
\texttt{bookmarks-web} modules. Notice the
\texttt{BookmarksAdminPortlet.java} and \texttt{BookmarksPortlet.java}
files in the \texttt{com.liferay.bookmarks.web.portlet} package in the
\texttt{bookmarks-web} module. These portlet classes extend Liferay's
\texttt{MVCPortlet} class. They act as the controllers in the MVC
pattern. These classes contain the business logic that invokes the
Service Builder generated bookmarks services that you'll learn how to
create in this section. The application's view layer is implemented in
the JSPs in the
\texttt{bookmarks-web/src/main/resources/META-INF/resources} folder.

You can learn how to generate a generic modular application from scratch
that includes the \texttt{*api}, \texttt{*service}, and \texttt{*web}
modules by default in the
\href{/docs/7-0/tutorials/-/knowledge_base/t/modularizing-an-existing-portlet}{Modularizing
an Existing Portlet} tutorial. This tutorial assumes you've assembled
your application's modules similarly to the linked tutorial above. Be
sure to also visit the
\href{/docs/7-0/tutorials/-/knowledge_base/t/fundamentals}{Fundamentals}
tutorial for additional info on the \texttt{*api}, \texttt{*service},
and \texttt{*web} modules.

The first step in using Service Builder is to define your model classes
and their attributes in a \texttt{service.xml} file. This file's
location typically resides in the root folder of the \texttt{*-service}
module, although you can configure your build tool to recognize it from
other directories. In Service Builder terminology, your model classes
are called entities. For example, the Bookmarks application has two
entities: \texttt{BookmarksEntry} and \texttt{BookmarksFolder}. The
requirements for each of these entities are defined in the
\texttt{bookmarks-service} module's
\href{https://github.com/liferay/liferay-portal/blob/7.0.6-ga7/modules/apps/collaboration/bookmarks/bookmarks-service/service.xml}{service.xml}
listed in the \texttt{\textless{}column\ /\textgreater{}} elements.

Once Service Builder reads the \texttt{service.xml} file, you can define
your entities. Liferay @ide@ makes it very easy to define entities in
your application's \texttt{service.xml} file. To define a custom entity,
follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create the \texttt{service.xml} file in your project's
  \texttt{*-service} module. It resides in the root folder of that
  module, if one does not already exist there.
\item
  Define global information for the service.
\item
  Define service entities.
\item
  Define the columns (attributes) for each service entity.
\item
  Define relationships between entities.
\item
  Define a default order for the entity instances to be retrieved from
  the database.
\item
  Define finder methods that retrieve objects from the database based on
  specified parameters.
\end{enumerate}

You'll examine these steps in detail next, starting with creating a
\texttt{service.xml} file.

\subsection{Step 1: Creating the service.xml
File}\label{step-1-creating-the-service.xml-file}

To define a service for your portlet project, you must create a
\texttt{service.xml} file. The DTD (Document Type Declaration) file
\url{http://www.liferay.com/dtd/liferay-service-builder_7_0_0.dtd}
specifies the format and requirements of the XML to use. You can create
your \texttt{service.xml} file manually, following the DTD, or you can
use Liferay @ide@. @ide@ helps you build the \texttt{service.xml} file
piece-by-piece, taking the guesswork out of creating XML that adheres to
the DTD.

If a default \texttt{service.xml} file already exists in your
\texttt{*-service} module folder, check to see if it has an
\texttt{\textless{}entity\ /\textgreater{}} element named \emph{Foo}. If
it has the Foo entity, remove the entire
\texttt{\textless{}entity\ name="Foo"\ ...\textgreater{}\ ...\ \textless{}/entity\textgreater{}}
element. The Liferay @ide@ project wizard creates the Foo entity as an
example. It has no practical use for you.

If you don't already have a \texttt{service.xml} file, create one in
your \texttt{*-service} module. Once it's created, open it. Liferay
@ide@ provides a Diagram mode and a Source mode to give you different
perspectives of the service information in your \texttt{service.xml}
file. Diagram mode is helpful for creating and visualizing relationships
between service entities. Source mode brings up the \texttt{service.xml}
file's raw XML content in the editor. You can switch between these modes
as you wish.

Next, you can start filling out the global information for your service.

\subsection{Step 2: Defining Global Service
Information}\label{step-2-defining-global-service-information}

A service's global information applies to all of its entities, so it's a
good place to start. In Liferay @ide@, select the \emph{Service Builder}
node in the upper left corner of the Overview mode of your
\texttt{service.xml} file. The main section of the view now shows the
Service Builder form in which you can enter your service's global
information. The fields include the service's package path, author, and
namespace options.

\begin{figure}
\centering
\includegraphics{./images/service-builder-main-form.png}
\caption{This is the Service Builder form from a fictitious Event
Listing application's \texttt{service.xml}.}
\end{figure}

The package path specifies the package in which the service and
persistence classes are generated. The package path defined above
ensures that the service classes are generated in the
\texttt{com.liferay.docs.eventlisting} package in the \texttt{*-api}
module. The persistence classes are generated in a package of the same
name in the \texttt{*-service} module. For examples, you can look in the
Bookmarks application's
\href{https://github.com/liferay/liferay-portal/tree/master/modules/apps/collaboration/bookmarks/bookmarks-api}{bookmarks-api}
and
\href{https://github.com/liferay/liferay-portal/tree/master/modules/apps/collaboration/bookmarks/bookmarks-service}{bookmarks-service}
modules to see an example of how these are automatically generated for
you. Refer to the
\href{/docs/7-0/tutorials/-/knowledge_base/t/running-service-builder-and-understanding-the-generated-code}{Running
Service Builder and Understanding the Generated Code} tutorial for a
description of the contents of these packages.

Service Builder uses the service namespace in naming the database tables
it generates for the service. For example, \emph{Event} could serve as
the namespace for an Event Listing portlet service.

\begin{verbatim}
<namespace>Event</namespace>
\end{verbatim}

Service Builder uses the namespace in the following SQL scripts it
generates in your \texttt{src/main/resources/META-INF/sql} folder:

\begin{itemize}
\tightlist
\item
  \texttt{indexes.sql}
\item
  \texttt{sequences.sql}
\item
  \texttt{tables.sql}
\end{itemize}

\noindent\hrulefill

\textbf{Note:} The folder location for holding your generated SQL
scripts is configurable. For example, if you're using Ant can configure
an argument in your \texttt{build.xml} similar to this:

\begin{verbatim}
 <arg value="service.sql.dir=${basedir}/../sql"/>
\end{verbatim}

If you're using Gradle, you can define the \texttt{sqlDir} setting in
the project's \texttt{build.gradle} file or Maven \texttt{pom.xml} file,
the same way the \texttt{databaseNameMaxLength} setting is applied in
the examples below.

\noindent\hrulefill

Liferay DXP uses these scripts to create database tables for all the
entities defined in the \texttt{service.xml} file. Service Builder
prepends the namespace to the database table names. Since the namespace
value above is \texttt{Event}, the names of the database tables created
for the entities start with \texttt{Event\_} as their prefix. The
namespace for each Service Builder project must be unique. Separate
plugins should use separate namespaces and should not use a namespace
already used by Liferay (such as \texttt{Users} or \texttt{Groups}).
Check the table names in Liferay's database if you're wondering which
namespaces are already in use.

\textbf{Warning:} Use caution when assigning namespace values. Some
databases have strong restrictions on database table and column name
lengths. The Service Builder
\href{/docs/7-1/reference/-/knowledge_base/r/service-builder-gradle-plugin\#task-properties}{Gradle}
and
\href{/docs/7-1/reference/-/knowledge_base/r/service-builder-with-maven\#available-parameters}{Maven}
plugin parameter \texttt{databaseNameMaxLength} sets the maximum length
you can use for your table and column names. Here are paraphrased
examples of setting \texttt{databaseNameMaxLength} in build files:

\textbf{Gradle \texttt{build.gradle}}

\begin{verbatim}
buildService {
    ...
    databaseNameMaxLength = 64
    ...
}
\end{verbatim}

\textbf{Maven \texttt{pom.xml}}

\begin{verbatim}
<configuration>
    ...
    <databaseNameMaxLength>64</databaseNameMaxLength>
    ...
</configuration>
\end{verbatim}

As the last piece of global information, enter your name as the
service's \emph{author} in your \texttt{service.xml} file. Service
Builder adds \texttt{@author} annotations with the specified name to all
of the generated Java classes and interfaces. Save your
\texttt{service.xml} file to preserve the information you added. Next,
you'll add entities for your service's events and locations.

\subsection{Step 3: Defining Service
Entities}\label{step-3-defining-service-entities}

Entities are the heart and soul of a service. Entities represent the map
between the model objects in Java and the fields and tables in your
database. Once your entities are defined, Service Builder handles the
mapping automatically, giving you a facility for taking Java objects and
persisting them. For the Bookmarks application, two entities are created
according to its
\href{https://github.com/liferay/liferay-portal/blob/7.0.6-ga7/modules/apps/collaboration/bookmarks/bookmarks-service/service.xml}{service.xml}
--one for bookmark entries and one for bookmark folders.

Here's a summary of the information used for the BookmarksEntry entity:

\begin{itemize}
\tightlist
\item
  \textbf{Name:} \emph{BookmarksEntry}
\item
  \textbf{Local service:} \emph{yes}
\item
  \textbf{Remote service:} \emph{yes}
\end{itemize}

And here's what was used for the BookmarksFolder entity:

\begin{itemize}
\tightlist
\item
  \textbf{Name:} \emph{BookmarksFolder}
\item
  \textbf{Local service:} \emph{yes}
\item
  \textbf{Remote service:} \emph{yes}
\end{itemize}

To create your entities using Liferay @ide@, select the \emph{Entities}
node under the Service Builder node in the outline on the left side of
the \texttt{service.xml} editor in Overview mode. In the main part of
the view, notice that the Entities table is empty. Create an entity by
clicking on the \emph{Add Entity} icon
(\includegraphics{./images/icon-add-ide.png}) to the right of the
table. Enter your entity's name and if you'd like to generate local and
remote services for that entity. Add as many entities as you need.

\begin{figure}
\centering
\includegraphics{./images/service-add-entity.png}
\caption{Adding service entities is easy with Liferay @ide@'s
\emph{Overview} mode of your \texttt{service.xml} file.}
\end{figure}

An entity's name is used to name the database table for persisting
instances of the entity. The actual name of the database table is
prefixed with the namespace; the Bookmarks example creates one database
table named \texttt{Bookmarks\_BookmarksEntry} and another named
\texttt{Bookmarks\_BookmarksFolder}.

Setting the \emph{local service} attribute to \texttt{true} instructs
Service Builder to generate local interfaces for the entity's services.
The default value for local service is \texttt{false}. Local services
can only be invoked from the Liferay server on which they're deployed.
Therefore, if your application will be deployed to Liferay, the service
will be local from your Liferay server's point of view.

Setting the \emph{remote service} attribute to \texttt{true} instructs
Service Builder to generate remote interfaces for the service. The
default value for remote service is \texttt{true}. You could build a
fully-functional application without generating remote services. In that
case, you could set local service to \texttt{true} and remote service to
\texttt{false} for your entities. If, however, you want to enable remote
access to your application's services, you should set both local service
and remote service to \texttt{true}.

\noindent\hrulefill

\textbf{Tip:} Suppose you have an existing DAO service for an entity
built using some other framework such as JPA. You can set local service
to \texttt{false} and remote service to \texttt{true} so that the
methods of your remote \texttt{-Impl} class can call the methods of your
existing DAO. This enables your entity to integrate with Liferay's
permission-checking system and provides access to the web service APIs
generated by Service Builder. This is a very handy, quite powerful, and
often used feature of Liferay.

\noindent\hrulefill

Now that you've seen how to create your application's entities, you'll
learn how to describe their attributes using entity \emph{columns}.

\subsection{Step 4: Defining the Columns (Attributes) for Each Service
Entity}\label{step-4-defining-the-columns-attributes-for-each-service-entity}

Each entity is described by its columns, which represent an entity's
attributes. These attributes map on the one side to fields in a table
and on the other side to attributes of a Java object. To add attributes
for your entity, you need to drill down to its columns in the Overview
mode outline of the \texttt{service.xml} file. From the outline, expand
the \emph{Entities} node and expand an entity node. Then select the
\emph{Columns} node. Liferay @ide@ displays a table of the entity's
columns.

Service Builder creates a database field for each column you add to the
\texttt{service.xml} file. It maps a database field type appropriate to
the Java type specified for each column, and it does this across all the
databases Liferay supports. Once Service Builder runs, it generates a
Hibernate configuration that handles the object-relational mapping.
Service Builder automatically generates getter/setter methods in the
model class for these attributes. The column's Name specifies the name
used in the getters and setters that are created for the entity's Java
field. The column's Type indicates the Java type of this field for the
entity. If a column's Primary (i.e., primary key) attribute value is set
to \texttt{true}, then the column becomes part of the primary key for
the entity. An entity's primary key is a unique identifier for the
entity. If only one column has Primary set to \texttt{true}, then that
column represents the entire primary key for the entity. This is the
case in the Event Listing example. However, it's possible to use
multiple columns as the primary key for an entity. In this case, the
combination of columns makes up a compound primary key for the entity.

\noindent\hrulefill

\textbf{Note:} Each Service Builder generated \texttt{*LocalServiceImpl}
class has a
\href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/counter/kernel/service/CounterLocalService.html}{\texttt{CounterLocalService}}
field for generating unique entity instance primary keys. For details,
see
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-local-services}{Creating
Local Services}.

\noindent\hrulefill

\noindent\hrulefill

\textbf{Note}: On deploying a \texttt{*service} module, Service Builder
automatically generates indexes for all entity primary keys.

\noindent\hrulefill

Similar to the way you used the form table for adding entities, add
attribute columns for each of your entities. Create each attribute by
clicking on the Add icon
(\includegraphics{./images/icon-add-ide.png}). Then fill in the
name of the attribute, select its type, and specify whether it is a
primary key for the entity. While your cursor is in a column's
\emph{Type} field, an option icon appears. Click this icon to select the
appropriate type for the column. Create a column for each attribute of
your entity or entities.

In addition to columns for your entity's primary key and attributes,
it's recommended to add columns for portal instance ID and site ID. They
allow your portlet to support the multi-tenancy features of Liferay, so
that each portal instance and each site in a portal instance can have
independent sets of portlet data. To hold the site's ID, add a column
called \texttt{groupId} of type \texttt{long}. To hold the portal
instance's ID, add a column called \texttt{companyId} of type
\texttt{long}. If you'd like to add these columns to your entities,
follow the table below.

\textbf{Portal and site scope columns}

\begin{longtable}[]{@{}ccc@{}}
\toprule\noalign{}
Name & Type & Primary \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{companyId} & long & no \\
\texttt{groupId} & long & no \\
\end{longtable}

You'll also want to know who owns each entity instance. To keep track of
that, add a column called \texttt{userId} of type \texttt{long}.

\textbf{User column}

\begin{longtable}[]{@{}ccc@{}}
\toprule\noalign{}
Name & Type & Primary \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{userId} & long & no \\
\end{longtable}

Lastly, you can add columns to help audit your entities. For example,
you could create a column named \texttt{createDate} of type
\texttt{Date} to note the date an entity instance was created. And add a
column named \texttt{modifiedDate} of type \texttt{Date} to track the
last time an entity instance was modified.

\textbf{Audit columns}

\begin{longtable}[]{@{}ccc@{}}
\toprule\noalign{}
Name & Type & Primary \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{userId} & long & no \\
\texttt{createDate} & Date & no \\
\texttt{modifiedDate} & Date & no \\
\end{longtable}

Great! Your entities are set with the columns that not only represent
their attributes, but also support multi-tenancy and entity auditing.
Next, you'll learn how to specify the relationship service entities.

\subsection{Step 5: Defining Relationships Between Service
Entities}\label{step-5-defining-relationships-between-service-entities}

Often you'll want to reference one type of entity in the context of
another entity. That is, you'll want to \emph{relate} the entities.
Liferay's Bookmarks application defines a relationship between an entry
and its folder.

As mentioned earlier, each bookmark must have a folder. Therefore, each
\texttt{BookmarksEntry} entity must relate to a \texttt{BookmarksFolder}
entity. Liferay @ide@'s Diagram mode for \texttt{service.xml} makes
relating entities easy. First, select Diagram mode for the
\texttt{service.xml} file. Then select the \emph{Relationship} option
under \emph{Connections} in the palette on the right side of the view.
This relationship tool helps you draw relationships between entities in
the diagram. Click your first entity and move your cursor over to the
entity you'd like to relate it with. Liferay @ide@ draws a dashed line
from your selected entity to the cursor. Click the second entity to
complete drawing the relationship. Liferay IDE turns the dashed line
into a solid line, with an arrow pointing to the second entity. Save the
\texttt{service.xml} file.

Congratulations! You've related two entities. Their relationship should
show in Diagram mode and look similar to that of the figure below.

\begin{figure}
\centering
\includegraphics{./images/service-builder-relate-entities.png}
\caption{Relating entities is a snap in Liferay @ide@'s \emph{Diagram}
mode for \texttt{service.xml}.}
\end{figure}

Switch to \emph{Source} mode in the editor for your \texttt{service.xml}
file and note that Liferay @ide@ created a column element in the first
selected entity to hold the ID of the corresponding entity instance
reference. For example:

\begin{verbatim}
<column name="folderId" type="long" />
\end{verbatim}

Now that your entity columns are in place, you can specify the default
order in which the entity instances are retrieved from the database.

\subsection{Step 6: Defining Ordering of Service Entity
Instances}\label{step-6-defining-ordering-of-service-entity-instances}

Often, you want to retrieve multiple instances of a given entity and
list them in a particular order. Liferay lets you specify the default
order of the entities in your \texttt{service.xml} file.

Suppose you want to return \texttt{BookmarksEntry} entities
alphabetically by name. It's easy to specify these default orderings
using Liferay @ide@. Switch back to \emph{Overview} mode in the editor
for your \texttt{service.xml} file. Then select the \emph{Order} node
under the entity node in the outline on the left side of the view. The
IDE displays a form for ordering the chosen entity. Check the
\emph{Specify ordering} checkbox to show the form for specifying the
ordering. Create an order column by clicking the \emph{Add} icon
(\includegraphics{./images/icon-add-ide.png}) to the right of the
table. Enter the column name (e.g., \emph{name}, \emph{date}, etc.) to
use in ordering the entity. Click the \emph{Browse icon}
(\includegraphics{./images/icon-browse-ide.png}) to the right of
the \emph{By} field and choose the \emph{asc} or \emph{desc} option.
This orders the entity in ascending or descending order.

Now that you know how to order your service entities, the last thing to
do is to define the finder methods for retrieving entity instances from
the database.

\subsection{Step 7: Defining Service Entity Finder
Methods}\label{step-7-defining-service-entity-finder-methods}

Finder methods retrieve entity objects from the database based on
specified parameters. You'll probably want to create at least one finder
method for each entity you create in your services. Service Builder
generates several methods based on each finder you create for an entity.
It creates methods to fetch, find, remove, and count entity instances
based on the finder's parameters.

For many applications, it's important to be able to find its entities
per site. You can specify these finders using Liferay @ide@'s Overview
mode of \texttt{service.xml}. Select the \emph{Finders} node under the
entity node in the Outline on the left side of the screen. The IDE
displays an empty \emph{Finders} table in the main part of the view.
Create a new finder by clicking the \emph{Add} icon
(\includegraphics{./images/icon-add-ide.png}) to the right of the
table. Give your finder a name and return type. Use the Java camel-case
naming convention when naming finders since the finder's name is used to
name the methods that Service Builder creates. The IDE creates a new
finder sub-node under the \emph{Finders} node in the outline. Next,
you'll learn how to specify the finder column for this node.

\noindent\hrulefill

\textbf{Important}: DO NOT create finders that use entity primary key as
parameters. They're unnecessary as Service Builder automatically
generates \texttt{findByPrimaryKey} and \texttt{fetchByPrimaryKey}
methods for all entity primary keys. On deploying a \texttt{*service}
module, Service Builder creates indexes for all entity primary key
columns and finder columns. Adding finders that use entity primary keys
results in attempts to create multiple indexes for the same
columns---Oracle DB, for example, reports these attempts as errors.

\noindent\hrulefill

Under the new finder node, the IDE created a \emph{Finder Columns} node.
Select the \emph{Finder Columns} node to specify the columns for your
finder's parameters. Create a new finder column by clicking the
\emph{Add} icon and specifying the column's name. Keep in mind that you
can specify multiple parameters (columns) for a finder.

\begin{figure}
\centering
\includegraphics{./images/service-builder-finders.png}
\caption{Creating Finder entities is easy with Liferay @ide@.}
\end{figure}

If you're creating site-scoped entities (entities whose data should be
unique to each site), you should follow the steps described above to
create finders by \texttt{groupId} for retrieving your entities.
Remember to save your \texttt{service.xml} file after editing it to
preserve the finders you define.

When you run Service Builder, it generates finder-related methods (e.g.,
\texttt{fetchByGroupId}, \texttt{findByGroupId},
\texttt{removeByGroupId}, \texttt{countByGroupId}) for the your entities
in the \texttt{*Persistence} and \texttt{*PersistenceImpl} classes. The
first of these classes is the interface; the second is its
implementation. For example, Liferay's Bookmarks application generates
its entity finder methods in the \texttt{-Persistence} classes found in
the
\texttt{/bookmarks-api/src/main/java/com/liferay/bookmarks/service/persistence}
folder and the \texttt{-PersistenceImpl} classes in the
\texttt{/bookmarks-service/src/main/java/com/liferay/bookmarks/service/persistence/impl}
folder.

Now you know to configure Service Builder to create finder methods for
your entity. Terrific!

Now that you've specified the service for your project, you're ready to
\emph{build} the service by running Service Builder. To learn how to run
Service Builder and to learn about the code that Service Builder
generates, please refer to the
\href{/docs/7-0/tutorials/-/knowledge_base/t/running-service-builder-and-understanding-the-generated-code}{Running
Service Builder and Understanding the Generated Code} tutorial.

\subsection{Related Topics}\label{related-topics-120}

\href{/docs/7-0/tutorials/-/knowledge_base/t/what-is-service-builder}{What
is Service Builder?}

\href{/docs/7-0/tutorials/-/knowledge_base/t/running-service-builder-and-understanding-the-generated-code}{Running
Service Builder and Understanding the Generated Code}

\section{Running Service Builder and Understanding the Generated
Code}\label{running-service-builder-and-understanding-the-generated-code}

This tutorial explains how to run Service Builder and provides an
overview of the code that Service Builder generates. If you'd like to
use Service Builder in your application but haven't yet created a
\texttt{service.xml} file, visit the
\href{/docs/7-0/tutorials/-/knowledge_base/t/defining-an-object-relational-map-with-service-builder}{Defining
an Object-Relational Map with Service Builder} tutorial and then come
back to this one.

\subsection{Running Service Builder}\label{running-service-builder}

To build a service from a \texttt{service.xml} file, you can use Liferay
@ide@ or a terminal window. In this tutorial, you'll refer to the Event
Listing example project that's referenced throughout the Liferay Service
Builder tutorials.

Now let's learn how to run Service Builder.

\subsubsection{Using Liferay @ide@}\label{using-liferay-ide-3}

From the Package Explorer, open the \texttt{service.xml} file from your
\texttt{*-service} module's root folder. By default, the file opens up
in the Service Builder Editor. Make sure you are in Overview mode. Then
click the \emph{Build Services} button
(\includegraphics{./images/icon-build-services.png}) near the
top-right corner of the view.

Make sure to click the \emph{Build Services} button and not the
\emph{Build WSDD} button
(\includegraphics{./images/icon-build-wsdd.png}) that appears
next to it. Building the WSDDs won't hurt anything, but you'll generate
files for the remote service instead of the local one. For information
about WSDDs (web service deployment descriptors), please refer to the
\href{/docs/7-0/tutorials/-/knowledge_base/t/soap-web-services}{SOAP Web
Services} tutorial.

\begin{figure}
\centering
\includegraphics{./images/service-xml-overview.png}
\caption{The \emph{Overview} mode in the editor provides a nested
outline which you can expand, a form for editing basic Service Builder
attributes, and buttons for building services or building web service
deployment descriptors.}
\end{figure}

Another simple way to run Service Builder is to right-click on your
project's name in the Package Explorer and then select \emph{Liferay} →
\emph{build-service}.

After running Service Builder, your generated files are available. More
information about the generated files appears below.

\subsubsection{Using the Terminal}\label{using-the-terminal}

Open a terminal window and navigate to your module project's root
folder, which should be located in your Liferay Workspace's
\texttt{modules} directory. To learn more about creating your module
project in a
\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-workspace}{Liferay
Workspace}, visit the
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-modules-with-blade-cli}{Creating
Modules with Blade CLI} tutorial. You can leverage the
\href{/docs/7-0/reference/-/knowledge_base/r/using-the-service-builder-template}{Service
Builder Template} to create your own predefined Service Builder project.

Liferay Workspace offers a Gradle or Maven build environment; this
tutorial shows how to use both. Liferay is tool agnostic, however, and
you can use other tools, as well.

For Gradle projects, enter the following command in your module
project's root folder to build your services:

\begin{verbatim}
gradlew buildService
\end{verbatim}

\noindent\hrulefill

\textbf{Note:} Liferay Workspaces provide the Gradle Wrapper script for
usage, if you don't have Gradle installed globally in your classpath. It
is located in the workspace's root folder, so you can call it from your
module project's root folder, if necessary (e.g.,
\texttt{../../gradlew\ buildService}).

\noindent\hrulefill

If your module project uses Maven, you can build services running the
following command from the module project's root folder:

\begin{verbatim}
mvn service-builder:build
\end{verbatim}

\textbf{Important:} The \texttt{mvn\ service-builder:build} command only
works if you're using the
\texttt{com.liferay.portal.tools.service.builder} plugin version
1.0.145+. Maven projects using an earlier version of the Service Builder
plugin should update their POM accordingly. See the
\href{/docs/7-0/tutorials/-/knowledge_base/t/using-service-builder-in-a-maven-project}{Using
Service Builder in a Maven Project} tutorial for more information on
using Maven to run Service Builder.

When the service has been successfully generated, a
\texttt{BUILD\ SUCCESSFUL} message appears in your terminal window. You
should also see that a large number of files have been generated in your
project. These files include a model layer, service layer, and
persistence layer. Don't worry about the number of generated
files--you'll never have to customize more than three of them. To review
the code that Service Builder generates for your entities, see the next
section.

\subsection{Understanding the Code Generated by Service
Builder}\label{understanding-the-code-generated-by-service-builder}

Now you'll examine the files Service Builder generated for your entity.
Note that the files listed under Local Service and Remote Service below
are only generated for an entity that has both \texttt{local-service}
and \texttt{remote-service} attributes set to \texttt{true}. Service
Builder generates services for these entities in two locations in your
project. These locations use the package path that you specified in your
\texttt{service.xml} file. For Liferay's Bookmarks application, for
example, these two locations are the following ones:

\begin{itemize}
\tightlist
\item
  \texttt{/bookmarks-api/src/main/java/com/liferay/bookmarks}
\item
  \texttt{/bookmarks-service/src/main/java/com/liferay/bookmarks}
\end{itemize}

The \texttt{bookmarks-api} module contains the API for the Bookmarks
project. All the classes and interfaces in the \texttt{*-api} module are
packaged in a \texttt{.jar} file called \texttt{PROJECT\_NAME-api.jar}
in the module's \texttt{build/libs} folder. This \texttt{.jar} file is
generated whenever you compile and deploy your module. When deploying
this JAR to Liferay, the necessary interfaces to \emph{define} the
service API are available.

The \texttt{bookmarks-service} module contains the implementation of the
interfaces defined in the \texttt{bookmarks-api} module. These
interfaces provide OSGi services for the portal instance to which your
application is deployed. Service Builder generates classes and
interfaces belonging to the persistence layer, service layer, and model
layer in the \texttt{/bookmarks-api/src/main/java/com/liferay/bookmarks}
and \texttt{/bookmarks-service/src/main/java/com/liferay/bookmarks}
packages.

Now you'll look at the classes and interfaces generated for the entities
you specified. Each entity has similar classes generated for it,
depending on what you specfied for them in the \texttt{service.xml}. You
won't have to customize more than three classes for each entity. These
customizable classes are \texttt{*LocalServiceImpl},
\texttt{*ServiceImpl}, and \texttt{*Impl}.

\begin{itemize}
\tightlist
\item
  Persistence

  \begin{itemize}
  \tightlist
  \item
    \texttt{{[}ENTITY\_NAME{]}Persistence}: Persistence interface that
    defines CRUD methods for the entity such as \texttt{create},
    \texttt{remove}, \texttt{countAll}, \texttt{find}, \texttt{findAll},
    etc.
  \item
    \texttt{{[}ENTITY\_NAME{]}PersistenceImpl}: Persistence
    implementation class that implements
    \texttt{{[}ENTITY\_NAME{]}Persistence}.
  \item
    \texttt{{[}ENTITY\_NAME{]}Util}: Persistence utility class that
    wraps \texttt{{[}ENTITY\_NAME{]}PersistenceImpl} and provides direct
    access to the database for CRUD operations. This utility should only
    be used by the service layer; in your portlet classes, use
    \texttt{{[}ENTITY\_NAME{]}LocalServiceUtil} or
    \texttt{{[}ENTITY\_NAME{]}ServiceUtil} instead.
  \end{itemize}

  \begin{figure}
  \centering
  \includegraphics{./images/service-builder-persistence-diagram.png}
  \caption{Service Builder generates these persistence classes and
  interfaces. You shouldn't (and you won't need to) customize any of
  these classes or interfaces.}
  \end{figure}
\item
  Local Service (generated for an entity only if an entity's
  \texttt{local-service} attribute is set to \texttt{true} in
  \texttt{service.xml})

  \begin{itemize}
  \tightlist
  \item
    \texttt{{[}ENTITY\_NAME{]}LocalService}: Local service interface.
  \item
    \texttt{{[}ENTITY\_NAME{]}LocalServiceImpl} (\textbf{LOCAL SERVICE
    IMPLEMENTATION}): Local service implementation. This is the only
    class in the local service that you should modify manually. You can
    add custom business logic here. For any custom methods added here,
    Service Builder adds corresponding methods to the
    \texttt{{[}ENTITY\_NAME{]}LocalService} interface the next time you
    run it.
  \item
    \texttt{{[}ENTITY\_NAME{]}LocalServiceBaseImpl}: Local service base
    implementation. This is an abstract class. Service Builder injects a
    number of instances of various service and persistence classes into
    this class. \texttt{@abstract}
  \item
    \texttt{{[}ENTITY\_NAME{]}LocalServiceUtil}: Local service utility
    class which wraps \texttt{{[}ENTITY\_NAME{]}LocalServiceImpl} and
    serves as the primary local access point to the service layer.
  \item
    \texttt{{[}ENTITY\_NAME{]}LocalServiceWrapper}: Local service
    wrapper which implements \texttt{{[}ENTITY\_NAME{]}LocalService}.
    This class is designed to be extended and it allows developers to
    customize the entity's local services.
  \end{itemize}

  \begin{figure}
  \centering
  \includegraphics{./images/service-builder-service-diagram.png}
  \caption{Service Builder generates these service classes and
  interfaces. Only EventLocalServiceImpl allows custom methods to be
  added to the service layer.}
  \end{figure}
\item
  Remote Service (generated for an entity only if an entity's
  \texttt{remote-service} attribute is \emph{not} set to \texttt{false}
  in \texttt{service.xml})

  \begin{itemize}
  \tightlist
  \item
    \texttt{{[}ENTITY\_NAME{]}Service}: Remote service interface.
  \item
    \texttt{{[}ENTITY\_NAME{]}ServiceImpl} (\textbf{REMOTE SERVICE
    IMPLEMENTATION}): Remote service implementation. This is the only
    class in the remote service that you should modify manually. Here,
    you can write code that adds additional security checks and invokes
    the local services. For any custom methods added here, Service
    Builder adds corresponding methods to the
    \texttt{{[}ENTITY\_NAME{]}Service} interface the next time you run
    it.
  \item
    \texttt{{[}ENTITY\_NAME{]}ServiceBaseImpl}: Remote service base
    implementation. This is an abstract class. \texttt{@abstract}
  \item
    \texttt{{[}ENTITY\_NAME{]}ServiceUtil}: Remote service utility class
    which wraps \texttt{{[}ENTITY\_NAME{]}ServiceImpl} and serves as the
    primary remote access point to the service layer.
  \item
    \texttt{{[}ENTITY\_NAME{]}ServiceWrapper}: Remote service wrapper
    which implements \texttt{{[}ENTITY\_NAME{]}Service}. This class is
    designed to be extended and it allows developers to customize the
    remote entity's services.
  \item
    \texttt{{[}ENTITY\_NAME{]}ServiceSoap}: SOAP utility which the
    remote \texttt{{[}ENTITY\_NAME{]}ServiceUtil} remote service utility
    can access.
  \item
    \texttt{{[}ENTITY\_NAME{]}Soap}: SOAP model, similar to
    \texttt{{[}ENTITY\_NAME{]}ModelImpl}.
    \texttt{{[}ENTITY\_NAME{]}Soap} is serializable; it does not
    implement \texttt{{[}ENTITY\_NAME{]}}.
  \end{itemize}
\item
  Model

  \begin{itemize}
  \tightlist
  \item
    \texttt{{[}ENTITY\_NAME{]}Model}: Base model interface. This
    interface and its \texttt{{[}ENTITY\_NAME{]}ModelImpl}
    implementation serve only as a container for the default property
    accessors generated by Service Builder. Any helper methods and all
    application logic should be added to
    \texttt{{[}ENTITY\_NAME{]}Impl}.
  \item
    \texttt{{[}ENTITY\_NAME{]}ModelImpl}: Base model implementation.
  \item
    \texttt{{[}ENTITY\_NAME{]}}: {[}ENTITY\_NAME{]} model interface
    which extends \texttt{{[}ENTITY\_NAME{]}Model}.
  \item
    \texttt{{[}ENTITY\_NAME{]}Impl}: (\textbf{MODEL IMPLEMENTATION})
    Model implementation. You can use this class to add helper methods
    and application logic to your model. If you don't add any helper
    methods or application logic, only the auto-generated field getters
    and setters are available. Whenever you add custom methods to this
    class, Service Builder adds corresponding methods to the
    \texttt{{[}ENTITY\_NAME{]}} interface the next time you run it.
  \item
    \texttt{{[}ENTITY\_NAME{]}Wrapper}: Wrapper, wraps
    \texttt{{[}ENTITY\_NAME{]}}.
  \end{itemize}

  \begin{figure}
  \centering
  \includegraphics{./images/service-builder-model-diagram.png}
  \caption{Service Builder generates these model classes and interfaces.
  Only \texttt{EventImpl} allows custom methods to be added to the
  service layer.}
  \end{figure}
\end{itemize}

\noindent\hrulefill

\textbf{Note:} \texttt{*Util} classes are generated for backwards
compatibility purposes only. Your module applications should avoid
calling the util classes.

\noindent\hrulefill

Each file that Service Builder generates is assembled from an associated
FreeMarker template. You can find Service Builder's FreeMarker templates
in the
\href{https://github.com/liferay/liferay-portal/tree/master/modules/util/portal-tools-service-builder/src/main/resources/com/liferay/portal/tools/service/builder/dependencies}{portal-tools-service-builder}
module. For example, if you want to find out how a
\texttt{*ServiceImpl.java} file is generated, just look at the
\href{https://github.com/liferay/liferay-portal/blob/7.0.6-ga7/modules/util/portal-tools-service-builder/src/main/resources/com/liferay/portal/tools/service/builder/dependencies/service_impl.ftl}{service\_impl.ftl}
template.

Of all the classes generated by Service Builder, only three should be
manually modified: \texttt{*LocalServiceImpl}, \texttt{*ServiceImpl} and
\texttt{*Impl}. If you manually modify the other classes, your changes
are overwritten the next time you run Service Builder. Whenever you add
methods to, remove methods from, or change a method signature of a
\texttt{*LocalServiceImpl} class, \texttt{*ServiceImpl} class, or
\texttt{*Impl} class, you should run Service Builder again to regenerate
the affected interfaces and the service JAR.

Congratulations! You've generated your application's initial model,
persistence, and service layers and you understand the generated code.

\subsection{Related Topics}\label{related-topics-121}

\href{/docs/7-0/tutorials/-/knowledge_base/t/what-is-service-builder}{What
is Service Builder}

\href{/docs/7-0/tutorials/-/knowledge_base/t/running-service-builder-and-understanding-the-generated-code}{Running
Service Builder and Understanding the Generated Code}

\href{/docs/7-0/tutorials/-/knowledge_base/t/understanding-servicecontext}{Understanding
Service Context}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-local-services}{Creating
Local Services}

\section{Iterative Development}\label{iterative-development}

During the course of development, you're likely to need to add fields to
your database. This is a normal process of iterative development: you
get an idea for a new feature, or it's suggested to you, and that
feature requires additional data in the database. It's important to
note, then, that \textbf{new fields added to \texttt{service.xml} are
not automatically added to the database.} To add the fields, you must do
one of two things:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Write an
  \href{/docs/7-0/tutorials/-/knowledge_base/t/creating-an-upgrade-process-for-your-app}{upgrade
  process} to modify the tables and preserve the data, or
\item
  Run the \texttt{cleanServiceBuilder}
  \href{/docs/7-0/reference/-/knowledge_base/r/db-support-gradle-plugin}{Gradle
  task} (also supported on Maven and Ant), which drops your tables so
  they get re-created the next time your app is deployed. See the
  \href{/docs/7-0/reference/-/knowledge_base/r/db-support-plugin}{Maven
  DB Support Plugin} reference article for instructions on how to run
  this command from a Maven project.
\end{enumerate}

Use the first option when you have a released application and you must
preserve your users' data. Use the second option when you're in the
middle of development and you're adding new columns during that process.

\subsection{Related Topics}\label{related-topics-122}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-an-upgrade-process-for-your-app}{Upgrade
Processes}

\href{/docs/7-0/reference/-/knowledge_base/r/db-support-gradle-plugin}{Gradle
DB Support Plugin}

\href{/docs/7-0/reference/-/knowledge_base/r/db-support-plugin}{Maven DB
Support Plugin}

\section{Understanding
ServiceContext}\label{understanding-servicecontext}

The \texttt{ServiceContext} class is a parameter class used for passing
contextual information for a service. Using a parameter class lets you
consolidate many different methods with different sets of optional
parameters into a single, easier-to-use method. The class also
aggregates information necessary for features used throughout Liferay's
core portlets, such as permissions, tagging, categorization, and more.

In this section, you'll examine the Service Context fields, learn how to
create and populate a Service Context, and learn to access Service
Context data. First, you'll look at the fields of the
\texttt{ServiceContext} class.

\subsection{Service Context Fields}\label{service-context-fields}

The \texttt{ServiceContext} class has many fields. The best field
descriptions are found in the Javadoc:

\href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/service/ServiceContext.html}{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/service/ServiceContext.html}.

Here, you can review a categorical listing of the fields:

\begin{itemize}
\tightlist
\item
  Actions:

  \begin{itemize}
  \tightlist
  \item
    \texttt{\_command}
  \item
    \texttt{\_workflowAction}
  \end{itemize}
\item
  Attributes:

  \begin{itemize}
  \tightlist
  \item
    \texttt{\_attributes}
  \item
    \texttt{\_expandoBridgeAttributes}
  \end{itemize}
\item
  Classification:

  \begin{itemize}
  \tightlist
  \item
    \texttt{\_assetCategoryIds}
  \item
    \texttt{\_assetTagNames}
  \end{itemize}
\item
  Exception

  \begin{itemize}
  \tightlist
  \item
    \texttt{\_failOnPortalException}
  \end{itemize}
\item
  IDs and Scope:

  \begin{itemize}
  \tightlist
  \item
    \texttt{\_companyId}
  \item
    \texttt{\_portletPreferencesIds}
  \item
    \texttt{\_plid}
  \item
    \texttt{\_scopeGroupId}
  \item
    \texttt{\_userId}
  \item
    \texttt{\_uuid}
  \end{itemize}
\item
  Language:

  \begin{itemize}
  \tightlist
  \item
    \texttt{\_languageId}
  \end{itemize}
\item
  Miscellaneous:

  \begin{itemize}
  \tightlist
  \item
    \texttt{\_headers}
  \item
    \texttt{\_signedIn}
  \end{itemize}
\item
  Permissions:

  \begin{itemize}
  \tightlist
  \item
    \texttt{\_addGroupPermissions}
  \item
    \texttt{\_addGuestPermissions}
  \item
    \texttt{\_deriveDefaultPermissions}
  \item
    \texttt{\_modelPermissions}
  \end{itemize}
\item
  Request

  \begin{itemize}
  \tightlist
  \item
    \texttt{\_request}
  \end{itemize}
\item
  Resources:

  \begin{itemize}
  \tightlist
  \item
    \texttt{\_assetEntryVisible}
  \item
    \texttt{\_assetLinkEntryIds}
  \item
    \texttt{\_assetPriority}
  \item
    \texttt{\_createDate}
  \item
    \texttt{\_formDate}
  \item
    \texttt{\_indexingEnabled}
  \item
    \texttt{\_modifiedDate}
  \item
    \texttt{\_timeZone}
  \end{itemize}
\item
  URLs, paths and addresses:

  \begin{itemize}
  \tightlist
  \item
    \texttt{\_currentURL}
  \item
    \texttt{\_layoutFullURL}
  \item
    \texttt{\_layoutURL}
  \item
    \texttt{\_pathMain}
  \item
    \texttt{\_pathFriendlyURLPrivateGroup}
  \item
    \texttt{\_pathFriendlyURLPrivateUser}
  \item
    \texttt{\_pathFriendlyURLPublic}
  \item
    \texttt{\_portalURL}
  \item
    \texttt{\_remoteAddr}
  \item
    \texttt{\_remoteHost}
  \item
    \texttt{\_userDisplayURL}
  \end{itemize}
\end{itemize}

Are you wondering how the \texttt{ServiceContext} fields get populated?
Good! You'll learn about that next.

\subsection{Creating and Populating a Service
Context}\label{creating-and-populating-a-service-context}

Although all the \texttt{ServiceContext} class fields are optional,
services that store any kind of scopeable data need to at least specify
the scope group ID. Here's a simple example of creating a
\texttt{ServiceContext} instance and passing it as a parameter to a
Liferay service API using Java:

\begin{verbatim}
ServiceContext serviceContext = new ServiceContext();
serviceContext.setScopeGroupId(myGroupId);

...

_blogsEntryService.addEntry(..., serviceContext);
\end{verbatim}

If you invoke the service from a servlet, a Struts action, or any other
front-end end class which has access to the \texttt{PortletRequest}, use
one of the \texttt{ServiceContextFactory.getInstance(...)} methods.
These methods create a \texttt{ServiceContext} object from the request
and automatically populate its fields with all the values specified in
the request. The above example looks different if you invoke the service
from a servlet:

\begin{verbatim}
ServiceContext serviceContext =
    ServiceContextFactory.getInstance(BlogsEntry.class.getName(), portletRequest);

...

_blogsEntryService.addEntry(..., serviceContext);
\end{verbatim}

You can see an example of populating a \texttt{ServiceContext} with
information from a request object in the code of the
\texttt{ServiceContextFactory.getInstance(...)} methods. The methods
demonstrate how to set parameters like \emph{scope group ID},
\emph{company ID}, \emph{language ID}, and more. They also demonstrate
how to access and populate more complex context parameters like
\emph{tags}, \emph{categories}, \emph{asset links}, \emph{headers}, and
the \emph{attributes} parameter. By calling
\texttt{ServiceContextFactory.getInstance(String\ className,\ PortletRequest\ portletRequest)},
you can assure that your Expando bridge attributes are set on the
\texttt{ServiceContext}. Expandos are the back-end implementation of
custom fields for entities in Liferay.

\subsection{Creating and Populating a Service Context in
JavaScript}\label{creating-and-populating-a-service-context-in-javascript}

Liferay's API can be invoked in languages other than Java. Some methods
of Liferay's API require or allow a \texttt{ServiceContext} parameter.
If you're invoking such a method via Liferay's JSON web services, you
might want to create and populate a \texttt{ServiceContext} object in
JavaScript. Creating a \texttt{ServiceContext} object in JavaScript is
no different from creating any other object in JavaScript.

Before examining a JSON web service invocation that uses a
\texttt{ServiceContext} object, it helps to see a simple JSON web
service example in JavaScript:

\begin{verbatim}
Liferay.Service(
    '/user/get-user-by-email-address`,
    {
        companyId: Liferay.ThemeDisplay.getCompanyId(),
        emailAddress: 'test@example.com`
    },
    function(obj) {
        console.log(obj);
    }
);
\end{verbatim}

If you run this code, the \emph{test@example.com} user (JSON object) is
logged to the JavaScript console.

The \texttt{Liferay.Service(...)} function takes three arguments:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  A string representing the service being invoked
\item
  A parameters object
\item
  A callback function
\end{enumerate}

The callback function takes the result of the service invocation as an
argument.

The Liferay JSON web services page (its URL is
\url{localhost:8080/api/jsonws} if you're running Liferay locally on
port 8080) generates example code for invoking web services. To see the
generated code for a particular service, click on the name of the
service, enter the required parameters, and click \emph{Invoke}. The
JSON result of your service invocation appears. There are multiple ways
to invoke Liferay's JSON web services: click on \emph{JavaScript
Example} to see how to invoke the web service via JavaScript, click on
\emph{curl Example} to see how to invoke the web service via curl, or
click on \emph{URL example} to see how to invoke the web service via a
URL.

\begin{figure}
\centering
\includegraphics{./images/jsonws-simple-example.png}
\caption{When you invoke a service from Liferay's JSON web services
page, you can view the result of your service invocation as well as
example code for invoking the service via JavaScript, curl, or URL.}
\end{figure}

To learn more about Liferay's JSON web services, see the
\href{/docs/7-0/tutorials/-/knowledge_base/t/registering-json-web-services}{JSON
Web Services} tutorial.

Next, you'll learn how to access information from a
\texttt{ServiceContext} object.

\subsection{Accessing Service Context
Data}\label{accessing-service-context-data}

In this section, you'll find code snippets from
\texttt{BlogsEntryLocalServiceImpl.addEntry(...,\ ServiceContext)}. This
code demonstrates how to access information from a
\texttt{ServiceContext} and provides an example of how the context
information can be used.

As mentioned above, services for scopeable entities need to get a scope
group ID from the \texttt{ServiceContext} object. This is true for the
Blogs entry service because the scope group ID provides the scope of the
Blogs entry (the entity being persisted). For the Blogs entry, the scope
group ID is used in the following way:

\begin{itemize}
\tightlist
\item
  It's used as the \texttt{groupId} for the \texttt{BlogsEntry} entity.
\item
  It's used to generate a unique URL for the blog entry.
\item
  It's used to set the scope for comments on the blog entry.
\end{itemize}

Here are the corresponding code snippets:

\begin{verbatim}
long groupId = serviceContext.getScopeGroupId();

...

entry.setGroupId(groupId);

...

entry.setUrlTitle(getUniqueUrlTitle(entryId, groupId, title));

...

// Message boards

if (PropsValues.BLOGS_ENTRY_COMMENTS_ENABLED) {
    mbMessageLocalService.addDiscussionMessage(
        userId, entry.getUserName(), groupId,
        BlogsEntry.class.getName(), entryId,
        WorkflowConstants.ACTION_PUBLISH);
}
\end{verbatim}

Can \texttt{ServiceContext} be used to access the UUID of the blog
entry? Absolutely! Can you use \texttt{ServiceContext} to set the time
the blog entry was added? You sure can. See here:

\begin{verbatim}
entry.setUuid(serviceContext.getUuid());
...
entry.setCreateDate(serviceContext.getCreateDate(now));
\end{verbatim}

Can \texttt{ServiceContext} be used in setting permissions on resources?
You bet! When adding a blog entry, you can add new permissions or apply
existing permissions for the entry, like this:

\begin{verbatim}
// Resources

if (serviceContext.isAddGroupPermissions() ||
    serviceContext.isAddGuestPermissions()) {

    addEntryResources(
        entry, serviceContext.isAddGroupPermissions(),
        serviceContext.isAddGuestPermissions());
}
else {
    addEntryResources(
        entry, serviceContext.getGroupPermissions(),
        serviceContext.getGuestPermissions());
}
\end{verbatim}

\texttt{ServiceContext} helps apply categories, tag names, and the link
entry IDs to asset entries too. Asset links are the back-end term for
related assets in Liferay.

\begin{verbatim}
// Asset

updateAsset(
    userId, entry, serviceContext.getAssetCategoryIds(),
    serviceContext.getAssetTagNames(),
    serviceContext.getAssetLinkEntryIds());
\end{verbatim}

Does \texttt{ServiceContext} also play a role in starting a workflow
instance for the blogs entry? Must you ask?

\begin{verbatim}
// Workflow

if ((trackbacks != null) && (trackbacks.length > 0)) {
    serviceContext.setAttribute("trackbacks", trackbacks);
}
else {
    serviceContext.setAttribute("trackbacks", null);
}

_workflowHandlerRegistry.startWorkflowInstance(
    user.getCompanyId(), groupId, userId, BlogsEntry.class.getName(),
    entry.getEntryId(), entry, serviceContext);
\end{verbatim}

The snippet above also demonstrates the \texttt{trackbacks} attribute, a
standard attribute for the blogs entry service. There may be cases where
you need to pass in custom attributes to your blogs entry service. Use
Expando attributes to carry custom attributes along in your
\texttt{ServiceContext}. Expando attributes are set on the added blogs
entry like this:

\begin{verbatim}
entry.setExpandoBridgeAttributes(serviceContext);
\end{verbatim}

You can see that the \texttt{ServiceContext} can be used to transfer
lots of useful information for your services. Understanding how
\texttt{ServiceContext} is used in Liferay helps you determine when and
how to use \texttt{ServiceContext} in your own Liferay application
development.

\subsection{Related Topics}\label{related-topics-123}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-local-services}{Creating
Local Services}

\href{/docs/7-0/tutorials/-/knowledge_base/t/invoking-local-services}{Invoking
Local Services}

\section{Customizing Model Entities With Model
Hints}\label{customizing-model-entities-with-model-hints}

If you've already used Service Builder to define your model entities and
have implemented business logic for creating and modifying those
entities, you might have some ideas for helping users to submit valid
model entity data. For example, suppose you're working on a calendar app
where users can select a date for a calendar event. How can you specify
that only future dates are selectable? Easy! Use portlet model hints!
Liferay Service Builder's model hints provide a single place in your
application where you can specify entity data restrictions. Model hints
are specified in a single file called \texttt{portlet-model-hints.xml}
in your project. If your project is comprised of an API module, a
service module, and a web module, as is common for 7.0 applications,
\texttt{portlet-model-hints.xml} should go in the service module. For
example, in Liferay's Bookmarks application, the
\texttt{portlet-model-hints.xml} file goes in the
\texttt{bookmarks-service/src/main/resources/META-INF/} folder. Model
hints are referred to as such because they suggest how entities should
be presented to users. Model hints let you to configure how the AlloyUI
tag library, \texttt{aui}, shows model fields. As Liferay displays form
fields in your application, it first checks the model hints you
specified and customizes the form's input fields based on these hints.
Model hints can also be used to specify the size of the database columns
used to store the entities and to specify other entity details.

\noindent\hrulefill

\textbf{Note:} Service Builder generates a number of XML configuration
files in your service module's \texttt{src/main/resources/META-INF}
folder. Service Builder uses most of these files to manage Spring and
Hibernate configurations. Don't modify the Spring or Hibernate
configuration files; your changes will be overwritten the next time
Service Builder runs. However, you can safely edit the
\texttt{portlet-model-hints.xml} file.

\noindent\hrulefill

As an example, consider
\href{https://github.com/liferay/liferay-portal/blob/7.0.6-ga7/modules/apps/collaboration/bookmarks/bookmarks-service/src/main/resources/META-INF/portlet-model-hints.xml}{the
Bookmarks app's model hints file}:

\begin{verbatim}
<?xml version="1.0"?>

<model-hints>
    <model name="com.liferay.bookmarks.model.BookmarksEntry">
        <field name="uuid" type="String" />
        <field name="entryId" type="long" />
        <field name="groupId" type="long" />
        <field name="companyId" type="long" />
        <field name="userId" type="long" />
        <field name="userName" type="String" />
        <field name="createDate" type="Date" />
        <field name="modifiedDate" type="Date" />
        <field name="resourceBlockId" type="long" />
        <field name="folderId" type="long" />
        <field name="treePath" type="String">
            <hint name="max-length">4000</hint>
        </field>
        <field name="name" type="String">
            <hint name="max-length">255</hint>
        </field>
        <field name="url" type="String">
            <hint-collection name="URL" />
            <validator name="required" />
            <validator name="url" />
        </field>
        <field name="description" type="String">
            <hint-collection name="TEXTAREA" />
        </field>
        <field name="visits" type="int" />
        <field name="priority" type="int">
            <hint name="display-width">20</hint>
        </field>
        <field name="lastPublishDate" type="Date" />
        <field name="status" type="int" />
        <field name="statusByUserId" type="long" />
        <field name="statusByUserName" type="String" />
        <field name="statusDate" type="Date" />
    </model>
    <model name="com.liferay.bookmarks.model.BookmarksFolder">
        ...
    </model>
</model-hints>
\end{verbatim}

The root-level element is \texttt{model-hints}. All the model entities
are represented by \texttt{model} sub-elements of the
\texttt{model-hints} element. Each \texttt{model} element must have a
\texttt{name} attribute specifying the fully-qualified model class name.
Each model has \texttt{field} elements representing its model entity's
columns. Lastly, each \texttt{field} element must have a name and a
type. Each \texttt{field} element's names and types correspond to the
names and types specified for each entity's columns in the service
module's \texttt{service.xml} file. Service Builder generates all these
elements for you, based on \texttt{service.xml}.

To add hints to a field, add a \texttt{hint} tag inside its
\texttt{field} tag. For example, you can add a
\texttt{display-width\ hint} to specify the pixel width used to display
the field. The default pixel width is 350. To show a \texttt{String}
field with 50 pixels, you could nest a \texttt{hint} element named
\texttt{display-width} and give it a value of \texttt{50}.

To see the effect of a hint on a field, you must run Service Builder
again and redeploy your project. Note that changing
\texttt{display-width} doesn't limit the number of characters a user can
enter into the \texttt{name} field; it only controls the field's width
in the AlloyUI input form.

To configure the maximum size of a model field's database column (i.e.,
the maximum number of characters that can be saved for the field), use
the \texttt{max-length} hint. The default \texttt{max-length} value is
75 characters. If you want the \texttt{name} field to persist up to 100
characters, add a \texttt{max-length} hint to that field:

\begin{verbatim}
<field name="name" type="String">
    <hint name="display-width">50</hint>
    <hint name="max-length">100</hint>
</field>
\end{verbatim}

Remember to run Service Builder and redeploy your project after updating
the \texttt{portlet-model-hints.xml} file.

So far, you've seen a few different hints. The following table describes
the portlet model hints available for use.

\textbf{Model Hint Values and Descriptions}

\noindent\hrulefill

\begin{verbatim}
  Name       | Value Type | Description | Default |
\end{verbatim}

\texttt{auto-escape} \textbar{} boolean \textbar{} sets whether text
values should be escaped via \texttt{HtmlUtil.escape} \textbar{} true
\textbar{} \texttt{autoSize} \textbar{} boolean \textbar{} displays the
field in a for scrollable text area \textbar{} false \textbar{}
\texttt{day-nullable} \textbar{} boolean \textbar{} allows the day to be
null in a date field \textbar{} false \textbar{} \texttt{default-value}
\textbar{} String \textbar{} sets the default value of the form field
rendered using the aui taglib \textbar{} (empty String) \textbar{}
\texttt{display-height} \textbar{} integer \textbar{} sets the display
height of the form field rendered using the aui taglib \textbar{} 15
\textbar{} \texttt{display-width} \textbar{} integer \textbar{} sets the
display width of the form field rendered using the aui taglib \textbar{}
350 \textbar{} \texttt{editor} \textbar{} boolean \textbar{} sets
whether to provide an editor for the input \textbar{} false \textbar{}
\texttt{max-length} \textbar{} integer \textbar{} sets the maximum
column size for SQL file generation \textbar{} 75 \textbar{}
\texttt{month-nullable} \textbar{} boolean \textbar{} allows the month
to be null in a date field \textbar{} false \textbar{} \texttt{secret}
\textbar{} boolean \textbar{} sets whether to hide the characters input
by the user \textbar{} false \textbar{} \texttt{show-time} \textbar{}
boolean \textbar{} sets whether to show the time along with the date
\textbar{} true \textbar{} \texttt{upper-case} \textbar{} boolean
\textbar{} converts all characters to upper case \textbar{} false
\textbar{} \texttt{year-nullable} \textbar{} boolean \textbar{} allows a
date field's year to be null \textbar{} false \textbar{}
\texttt{year-range-delta} \textbar{} integer \textbar{} specifies the
number of years to display from today's date in a date field rendered
with the aui taglib \textbar{} 5 \textbar{} \texttt{year-range-future}
\textbar{} boolean \textbar{} sets whether to include future dates
\textbar{} true \textbar{} \texttt{year-range-past} \textbar{} boolean
\textbar{} sets whether to include past dates \textbar{} true \textbar{}

\noindent\hrulefill

Note that Liferay has
\href{https://github.com/liferay/liferay-portal/blob/7.0.6-ga7/portal-impl/src/META-INF/portal-model-hints.xml}{its
own \texttt{portal-model-hints.xml} file}. This file contains many hint
examples, so you can reference it when customizing your
\texttt{portlet-model-hints.xml} file.

You can use the \texttt{default-hints} element to define a list of hints
to apply to every field of a model. For example, adding the following
element inside a model element applies a \texttt{display-width} of 300
to each field:

\begin{verbatim}
<default-hints>
    <hint name="display-width">300</hint>
</default-hints>
\end{verbatim}

You can define \texttt{hint-collection} elements inside the
\texttt{model-hints} root-level element to define a list of hints to
apply together. A hint collection must have a name. For example,
Liferay's \texttt{portal-model-hints.xml} defines the following hint
collections:

\begin{verbatim}
<hint-collection name="CLOB">
    <hint name="max-length">2000000</hint>
</hint-collection>
<hint-collection name="EDITOR">
    <hint name="editor">true</hint>
    <hint name="max-length">2000000</hint>
</hint-collection>
<hint-collection name="SEARCHABLE-DATE">
    <hint name="month-nullable">true</hint>
    <hint name="day-nullable">true</hint>
    <hint name="year-nullable">true</hint>
    <hint name="show-time">false</hint>
</hint-collection>
<hint-collection name="TEXTAREA">
    <hint name="display-height">105</hint>
    <hint name="display-width">500</hint>
    <hint name="max-length">4000</hint>
</hint-collection>
<hint-collection name="URL">
    <hint name="max-length">4000</hint>
</hint-collection>
\end{verbatim}

You can apply a hint collection to a model field by referencing the hint
collection's name. For example, if you define a \texttt{SEARCHABLE-DATE}
collection like the one above in your \texttt{model-hints} element, you
can apply it to your model's date field by using a
\texttt{hint-collection} element that references the collection by its
name:

\begin{verbatim}
<field name="date" type="Date">
    <hint-collection name="SEARCHABLE-DATE" />
</field>
\end{verbatim}

As always, remember to run Service Builder and redeploy your project
after updating your \texttt{portlet-model-hints.xml} file.

For example, suppose you want to use a couple of model hints in your
project. Start by providing users with an editor for filling in their
comment fields. To apply the same hint to multiple entities, define it
as a hint collection. Then reference the hint collection in each entity.

To define a hint collection, add a \texttt{hint-collection} element
inside the \texttt{model-hints} root element in your
\texttt{portlet-model-hints.xml} file. For example:

\begin{verbatim}
<hint-collection name="COMMENT-TEXTAREA">
    <hint name="display-height">105</hint>
    <hint name="display-width">500</hint>
    <hint name="max-length">4000</hint>
</hint-collection>
\end{verbatim}

To reference a hint collection for a specific field, add the
\texttt{hint-collection} element inside the field's \texttt{field}
element:

\begin{verbatim}
<field name="comment" type="String">
    <hint-collection name="COMMENT-TEXTAREA" />
</field>
\end{verbatim}

After defining hint collections and adding hint collection references,
rebuild your services using Service Builder, redeploy your project, and
check that the hints defined in your hint collection have taken effect.

Nice work! You've learned the art of persuasion through Liferay's model
hints. Now you can not only influence how your model's input fields are
displayed, but you can also can set its database table column sizes. You
can organize hints, insert individual hints directly into your fields,
apply a set of default hints to all of a model's fields, or define
collections of hints to apply at either of those scopes. You've picked
up the ``hints'' on how Liferay model hints specify how to display app
data!

\section{Custom SQL}\label{custom-sql}

Service Builder creates finder methods that retrieve entities by their
attributes: their column values. When you add a column as a parameter
for the finder in your \texttt{service.xml} file and run Service
Builder, it generates the finder method in your persistence layer and
adds methods to your service layer that invoke the finder. If your
queries are simple enough, consider using
\href{/docs/7-0/tutorials/-/knowledge_base/t/dynamic-query}{Dynamic
Query} to access Liferay's database. If you want to do something more
complicated like JOINs, you can write your own custom SQL queries.
You'll learn how in this tutorial.

Say you have a Guestbook application with two tables, one for guestbooks
and one for guestbook entries. The entry entity's foreign key to its
guestbook is the guestbook's ID. That is, the entry entity table,
\texttt{GB\_Entry}, tracks an entry's guestbook by its long integer ID
in the table's \texttt{guestbookId} column. If you want to find a
guestbook entry based on its name, message, and guestbook name, you must
access the \emph{name} of the entry's guestbook. Of course, with SQL you
can join the entry and guestbook tables to include the guestbook name.
Service Builder lets you do this by specifying the SQL as \emph{Liferay
custom SQL} and invoking it in your service via a \emph{custom finder
method}.

Liferay custom SQL is a Service Builder-supported method for performing
custom, complex queries against the database by invoking custom SQL from
a finder method in your persistence layer. Service Builder helps you
generate the interfaces to your finder method. It's easy to do by
following these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \hyperref[step-1-specify-your-custom-sql]{Specify your custom SQL.}
\item
  \hyperref[step-2-implement-your-finder-method]{Implement your finder
  method.}
\item
  \hyperref[step-3-access-your-finder-method-from-your-service]{Access
  your finder method from your service.}
\end{enumerate}

Next, using the Guestbook application as an example, you'll learn how to
accomplish these steps.

\subsection{Step 1: Specify Your Custom
SQL}\label{step-1-specify-your-custom-sql}

After you've tested your SQL, you must specify it in a particular file
for Liferay to access it. \texttt{CustomSQLUtil} class (from module
\href{https://repository.liferay.com/nexus/content/repositories/liferay-public-releases/com/liferay/com.liferay.portal.dao.orm.custom.sql/}{\texttt{com.liferay.portal.dao.orm.custom.sql}})
retrieves SQL from a file called \texttt{default.xml} in your service
module's \texttt{src/main/resources/META-INF/custom-sql/} folder. You
must create the \texttt{custom-sql} folder and create the
\texttt{default.xml} file in that \texttt{custom-sql} folder. The
\texttt{default.xml} file must adhere to the following format:

\begin{verbatim}
<custom-sql>
    <sql id="[fully-qualified class name + method]">
    SQL query wrapped in <![CDATA[...]]>
    No terminating semi-colon
    </sql>
</custom-sql>
\end{verbatim}

Create a \texttt{custom-sql} element for every SQL query you want in
your application, and give each query a unique ID. The recommended
convention to use for the ID value is the fully-qualified class name of
the finder followed by a dot (\texttt{.}) character and the name of the
finder method. More detail on the finder class and finder methods is
provided in Step 2.

For example, in the Guestbook application, you could use the following
ID value to specify a query:

\begin{verbatim}
com.liferay.docs.guestbook.service.persistence.\
EntryFinder.findByEntryNameEntryMessageGuestbookName
\end{verbatim}

Custom SQL must be wrapped in character data (\texttt{CDATA}) for the
\texttt{sql} element. Importantly, do not terminate the SQL with a
semi-colon. Following these rules, the \texttt{default.xml} file of the
Guestbook application specifies an SQL query that joins the
\texttt{GB\_Entry} and \texttt{GB\_Guestbook} tables:

\begin{verbatim}
<?xml version="1.0" encoding="UTF-8"?>
<custom-sql>
    <sql id="com.liferay.docs.guestbook.service.persistence.EntryFinder.findByEntryNameEntryMessageGuestbookName">
        <![CDATA[
            SELECT GB_Entry.*
            FROM GB_Entry
            INNER JOIN 
                GB_Guestbook ON GB_Entry.guestbookId = GB_Guestbook.guestbookId
            WHERE
                (GB_Entry.name LIKE ?) AND
                (GB_Entry.message LIKE ?) AND
                (GB_Guestbook.name LIKE ?)
        ]]>
    </sql>
</custom-sql>
\end{verbatim}

Now that you've specified some custom SQL, the next step is to implement
a finder method to invoke it. The method name for the finder should
match the ID you just specified for the \texttt{sql} element.

\subsection{Step 2: Implement Your Finder
Method}\label{step-2-implement-your-finder-method}

Next, implement the finder method in your persistence layer to invoke
your custom SQL query. Service Builder generates the interface for the
finder in your API module but you must create the implementation.

The first step is to create a \texttt{*FinderImpl} class in the service
persistence package. For the Guestbook application, you could create a
\texttt{EntryFinderImpl} class in the
\texttt{com.liferay.docs.guestbook.service.persistence.impl} package.
Your class should extend
\texttt{BasePersistenceImpl\textless{}Entry\textgreater{}}.

\href{/docs/7-0/tutorials/-/knowledge_base/t/running-service-builder-and-understanding-the-generated-code}{Run
Service Builder} to generate the \texttt{*Finder} interface based on the
\texttt{*FinderImpl} class. Modify your \texttt{*FinderImpl} class to
make it a component (annotated with
\href{https://docs.osgi.org/javadoc/osgi.cmpn/7.0.0/org/osgi/service/component/annotations/Component.html}{\texttt{@Component}})
that implements the \texttt{*Finder} interface you just generated:

\begin{verbatim}
@Component(service = EntryFinder.class)
public class EntryFinderImpl extends BasePersistenceImpl<Event>
    implements EntryFinder {

}
\end{verbatim}

Now you can create a finder method in your \texttt{EntryFinderImpl}
class. Add your finder method and static field to the
\texttt{*FinderImpl} class. For example, here's how you could write the
\texttt{EntryFinderImpl} class:

\begin{verbatim}
public List<Entry> findByEntryNameEntryMessageGuestbookName(
    String entryName, String entryMessage, String guestbookName,
    int begin, int end) {

    Session session = null;
    try {
        session = openSession();

        String sql = CustomSQLUtil.get(
            getClass(),
            FIND_BY_ENTRYNAME_ENTRYMESSAGE_GUESTBOOKNAME);

        SQLQuery q = session.createSQLQuery(sql);
        q.setCacheable(false);
        q.addEntity("GB_Entry", EntryImpl.class);

        QueryPos qPos = QueryPos.getInstance(q);
        qPos.add(entryName);
        qPos.add(entryMessage);
        qPos.add(guestbookName);

        return (List<Entry>) QueryUtil.list(q, getDialect(), begin, end);
    }
    catch (Exception e) {
        try {
            throw new SystemException(e);
        }
        catch (SystemException se) {
            se.printStackTrace();
        }
    }
    finally {
        closeSession(session);
    }

    return null;
}

public static final String FIND_BY_ENTRYNAME_ENTRYMESSAGE_GUESTBOOKNAME =
    EntryFinder.class.getName() +
        ".findByEntryNameEntryMessageGuestbookName";
\end{verbatim}

The custom finder method opens a new Hibernate session and uses
Liferay's
\texttt{com.liferay.portal.dao.orm.custom.sql.CustomSQLUtil.get(Class\textless{}?\textgreater{}\ clazz,\ String\ id)}
method to get the custom SQL to use for the database query. The
\texttt{FIND\_BY\_ENTRYNAME\_ENTRYMESSAGE\_GUESTBOOKNAME} static field
contains the custom SQL query's ID. The
\texttt{FIND\_BY\_EVENTNAME\_EVENTDESCRIPTON\_LOCATIONNAME} string is
based on the fully-qualified class name of the \texttt{*Finder}
interface (\texttt{EventFinder}) and the name of the finder method
(\texttt{findByEntryNameEntryMessageGuestbookName}).

Awesome! Your custom SQL is in place and your finder method is
implemented. Next, you'll call the finder method from your service.

\subsection{Step 3: Access Your Finder Method from Your
Service}\label{step-3-access-your-finder-method-from-your-service}

So far, you've created a \texttt{*FinderImpl} class, generated the
\texttt{*Finder} interface, and created a custom finder method that gets
your custom SQL. Your last step is to add a service method that calls
your finder.

When you ran Service Builder after defining your custom finder method,
the \texttt{*Finder} interface was generated (e.g.,
\texttt{GuestbookFinder}). Your portlet class, however, should not call
the \texttt{*Finder} interface: only a local or remote service
implementation (i.e., \texttt{*LocalServiceImpl} or
\texttt{*ServiceImpl}) in your service module should invoke the
\texttt{*Finder} class. This encourages a proper separation of concerns:
the portlet classes in your application's web module invoke the business
logic of the services published from your application's service module.
The services, in turn, access the data model using the persistence
layer's finder classes.

So you'll add a method in the \texttt{*LocalServiceImpl} class that
invokes the finder method implementation via the \texttt{*Finder} class.
Then you'll rebuild your application's service layer so that the portlet
classes and JSPs in your web module can access the services.

For example, for the Guestbook application, you'd add the following
method to the \texttt{EntryLocalServiceImpl} class:

\begin{verbatim}
public List<Entry> findByEntryNameGuestbookName(String entryName,
    String guestbookName) throws SystemException {

    return entryFinder.findByEntryNameGuestbookName(String entryName,
        String guestbookName);
}
\end{verbatim}

After you've added your \texttt{findBy-} method to your
\texttt{*LocalServiceImpl} class, run Service Builder to generate the
interface and make the finder method available in the
\texttt{EntryLocalService} class.

Now you can indirectly call the finder method from your portlet class or
a JSP in your web module. For example, to call the finder method in the
Guestbook application, just call
\texttt{entryLocalService.findByEntryNameEntryMessageGuestbookName(...)}!

Congratulations on developing a custom SQL query and custom finder for
your application!

\subsection{Related Topics}\label{related-topics-124}

\href{/docs/7-0/tutorials/-/knowledge_base/t/customizing-liferay-services-service-wrappers}{Customizing
Liferay Services}

\href{/docs/7-0/tutorials/-/knowledge_base/t/service-builder-web-services}{Service
Builder Web Services}

\section{Dynamic Query}\label{dynamic-query}

Liferay lets you use custom SQL queries to retrieve data from the
database. However, it's sometimes more convenient to build queries
dynamically at runtime than it is to invoke predefined SQL queries.
Liferay allows you to build queries dynamically using its DynamicQuery
API, which wraps Hibernate's Criteria API. Using Liferay's DynamicQuery
API allows you to build queries without writing a single line of SQL.
The DynamicQuery API helps you think in terms of objects and member
variables instead of in terms of tables and columns. Complex queries
constructed via Hibernate's Criteria API can be significantly easier to
understand and maintain than the equivalent custom SQL (or HQL) queries.
While you technically don't need to know SQL to construct queries via
Hibernate's Criteria API, you still need to take care to construct
efficient queries. For information on Hibernate's Criteria API, please
see
\href{http://docs.jboss.org/hibernate/orm/5.0/userguide/html_single/chapters/query/criteria/Criteria.html}{Hibernate's
manual}. In this tutorial, you'll learn how to create custom finders for
Liferay applications using Service Builder and Liferay's Dynamic Query
API.

To use Liferay's Dynamic Query API, you need to create a finder
implementation for your model entity. You can define model entities in
\texttt{service.xml} and run Service Builder to generate model,
persistence, and service layers for your application. See the
\href{/docs/7-0/tutorials/-/knowledge_base/t/running-service-builder-and-understanding-the-generated-code}{Running
Service Builder and Understanding the Generated Code} learning path for
more information on using Service Builder. This tutorial assumes that
you're creating a Liferay application that consists of a service module,
an API module, and a web module. Once you've used Service Builder to
generate model, persistence, and service layers for your application,
you can call custom finders using Liferay's Dynamic Query API by
following these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a custom \texttt{-FinderImpl} class and define a
  \texttt{findBy-} finder method in this class. Run Service Builder to
  generate the required interfaces and utility classes.
\item
  Implement your finder method using Liferay's Dynamic Query API.
\item
  Add a method to your \texttt{-LocalServiceImpl} class that invokes
  your finder method. Run Service Builder to add the required method to
  the service interface.
\end{enumerate}

Once you've taken these steps, you can access your custom finder as a
service method. Note: You can create multiple or overloaded
\texttt{findBy-} finder methods in your \texttt{-FinderImpl} class.
Next, let's examine these steps in more detail.

\subsection{Step 1: Defining a Custom Finder
Method}\label{step-1-defining-a-custom-finder-method}

To define any custom query, either by specifying custom SQL or by
defining a dynamic query, you need a finder class. Create a
\texttt{{[}Entity{]}FinderImpl} class in the generated
\texttt{{[}package\ path{]}.service.persistence.impl} package of your
service module's \texttt{src/main/java} folder. Recall that you specify
the package path in \texttt{service.xml}. Here's an example:

\begin{verbatim}
<service-builder package-path="com.liferay.docs.guestbook">
    ...
</service-builder>
\end{verbatim}

Then define a \texttt{findBy-} finder method in the class you created.
Make sure to add any required arguments to your finder method's method
signature.

For example, consider a fictitious Guestbook application. In this
application, there are two entities: guestbooks and entries. Each entry
belongs to a guestbook so the entry entity has a \texttt{guestbookId}
field as a foreign key. Suppose you need to create a custom finder to
search for guestbook entries by the entry name and the guestbook name.
In this case, you'd add a custom finder method to
\texttt{GuestbookFinderImpl} and name it something like
\texttt{findByEntryNameGuestbookName}. The full method signature would
appear as
\texttt{findByEntryNameGuestbookName(String\ entryName,\ String\ guestbookName)}.

Once you've created a finder method with the appropriate method
signature in your finder class, run Service Builder to generate the
appropriate interface in the
\texttt{{[}package\ path{]}.service.persistence} package in the
\texttt{service} folders of your API and service modules.

For example, after adding
\texttt{findByEntryNameGuestbookName(String\ entryName,\ String\ guestbookName)}
to \texttt{GuestbookFinderImpl} and running Service Builder, the
interface
\texttt{com.liferay.docs.guestbook.service.persistence.GuestbookFinder}
is generated.

Once the finder interface has been generated, make sure that the finder
class implements the interface. For example, the class declaration
should look like this:

\begin{verbatim}
public class GuestbookFinderImpl extends BasePersistenceImpl<Guestbook> implements GuestbookFinder
\end{verbatim}

Your next step is to actually define your query in your custom finder
method using the Dynamic Query API.

\subsection{Step 2: Implementing Your Custom Finder Method Using Dynamic
Query}\label{step-2-implementing-your-custom-finder-method-using-dynamic-query}

Your first step in implementing your custom finder method in your
\texttt{-FinderImpl} class is to open a new Hibernate session. Since
your \texttt{-FinderImpl} class extends
\texttt{BasePersistenceImpl\textless{}Entity\textgreater{}}, and
\texttt{BasePersistenceImpl\textless{}Entity\textgreater{}} contains a
session factory object and an
\href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/service/persistence/impl/BasePersistenceImpl.html\#openSession--}{openSession}
method, you can simply invoke the \texttt{openSession} method of your
\texttt{-FinderImpl}'s parent class to open a new Hibernate session. The
basic structure of your finder method should look like this:

\begin{verbatim}
public List<Entity> findBy-(...) {

    Session session = null;
    try {
            /*
            Try to open a new Hibernate session and create a dynamic
            query to retrieve and return the desired list of entity
            objects
            */
    }
    catch (Exception e) {
            // Exception handling
    }
    finally {
            closeSession(session);
    }

    return null;
    /*
    Return null only if there was an error returning the
    desired list of entity objects in the try block
    */

}
\end{verbatim}

For example, in the case of the Guestbook application, you could write
the following finder method to retrieve a list of Guestbook entries that
have a specific name and that also belong to a Guestbook of a specific
name:

\begin{verbatim}
public List<Event> findByEntryNameGuestbookName(String entryName, String guestbookName) {

    Session session = null;
    try {
        session = openSession();

        ClassLoader classLoader = getClass().getClassLoader();

        DynamicQuery guestbookQuery = DynamicQueryFactoryUtil.forClass(Guestbook.class, classLoader)
            .add(RestrictionsFactoryUtil.eq("name", guestbookName))
            .setProjection(ProjectionFactoryUtil.property("guestbookId"));

        Order order = OrderFactoryUtil.desc("modifiedDate");

        DynamicQuery entryQuery = DynamicQueryFactoryUtil.forClass(Entry.class, classLoader)
            .add(RestrictionsFactoryUtil.eq("name", entryName))
            .add(PropertyFactoryUtil.forName("guestbookId").in(guestbookQuery))
            .addOrder(order);

        List<Event> entries = EventLocalServiceUtil.dynamicQuery(entryQuery);

        return entries;
    }
    catch (Exception e) {
        try {
            throw new SystemException(e);
        }
        catch (SystemException se) {
            se.printStackTrace();
        }
    }
    finally {
        closeSession(session);
    }
\end{verbatim}

Notice that in Liferay, you don't create criteria objects directly from
the Hibernate session. Instead, you create dynamic query objects using
Liferay's
\href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/dao/orm/DynamicQueryFactoryUtil.html}{DynamicQueryFactoryUtil}
service. Thus, instead of

\begin{verbatim}
Criteria entryCriteria = session.createCriteria(Entry.class);
\end{verbatim}

you use

\begin{verbatim}
DynamicQuery entryQuery = DynamicQueryFactoryUtil.forClass(Entry.class, 
    classLoader);
\end{verbatim}

Most features of Hibernate's Criteria API, including restrictions,
projections, and orders, can be used on Liferay's dynamic query objects.
Restrictions in Hibernate's Criteria API roughly correspond to the
\texttt{where} clause of an SQL query: they offer a variety of ways to
limit the results returned by the query. You can use restrictions, for
example, to cause a query to return only results where a certain field
has a particular value, or a value in a certain range, or a non-null
value, etc.

Projections in Hibernate's Criteria API let you modify the kind of
results returned by a query. For example, if you don't want your query
to return a list of entity objects (the default), you can set a
projection on a query so that only a list of the values of a certain
entity field, or fields, is returned. You can also use projections on a
query to return the maximum or minimum value of an entity field, or the
sum of all the values of a field, or the average, etc. For more
information on restrictions and projections, please refer to Hibernate's
\href{http://docs.jboss.org/hibernate/orm/3.6/reference/en-US/html/querycriteria.html}{documentation}.

Orders, another feature of Hibernate's Criteria API, let you control the
order of the elements in the list returned by a query. You can choose
the property or properties to which an order should be applied and you
can choose for the properties to appear in ascending or descending order
in the list.

Like Hibernate criteria, Liferay's dynamic queries are \emph{chainable}.
This means that you can add criteria to, set projections on, and add
orders to Liferay's dynamic query objects just by appending the
appropriate method calls to the query object. For example, the following
snippet demonstrates chaining the addition of a restriction criterion
and a projection to a dynamic query object declaration:

\begin{verbatim}
DynamicQuery guestbookQuery = DynamicQueryFactoryUtil.forClass(Guestbook.class, classLoader)
    .add(RestrictionsFactoryUtil.eq("name", guestbookName))
    .setProjection(ProjectionFactoryUtil.property("guestbookId"));
\end{verbatim}

When you need to add restrictions to a dynamic query in Liferay, don't
call Hibernate's \texttt{Restrictions} class directly. Instead, use the
methods of Liferay's
\href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/dao/orm/RestrictionsFactoryUtil.html}{RestrictionsFactoryUtil}
service. You'll find the same methods in Liferay's
\texttt{RestrictionsFactoryUtil} service class that you're used to from
Hibernate's \texttt{Restrictions} class: \texttt{in}, \texttt{between},
\texttt{like}, \texttt{eq}, \texttt{ne}, \texttt{gt}, \texttt{ge},
\texttt{lt}, \texttt{le}, etc.

Thus, instead of

\begin{verbatim}
entryCriteria.add(Restrictions.eq("name", guestbookName));
\end{verbatim}

to specify that a guestbook must have a certain name, you use

\begin{verbatim}
entryQuery.add(RestrictionsFactoryUtil.eq("name", guestbookName));
\end{verbatim}

Similarly, to set projections, you create properties via Liferay's
\href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/dao/orm/PropertyFactoryUtil.html}{PropertyFactoryUtil}
service instead of through Hibernate's \texttt{Property} class. Thus,
instead of

\begin{verbatim}
entryCriteria.setProjection(Property.forName("guestbookId"));
\end{verbatim}

you use

\begin{verbatim}
entryQuery.setProjection(PropertyFactoryUtil.forName("guestbookId"));
\end{verbatim}

Notice that in the custom \texttt{findByGuestbookNameEntryName} finder
method, there are two distinct dynamic queries. The first query
retrieves a list of guestbook IDs corresponding to guestbook names that
match the \texttt{guestbookName} parameter of the finder method. The
second query retrieves a list of guestbook entries with entry names that
match the \texttt{entryName} parameter and have \texttt{guestbookId}
foreign keys belonging to the list returned by the first query.

Here's the first query:

\begin{verbatim}
DynamicQuery guestbookQuery = DynamicQueryFactoryUtil.forClass(Guestbook.class, classLoader)
    .add(RestrictionsFactoryUtil.eq("name", guestbookName))
    .setProjection(ProjectionFactoryUtil.property("guestbookId"));
\end{verbatim}

By default,
\texttt{DynamicQueryFactoryUtil.forClass(Guestbook.class,\ classLoader)}
returns a query that retrieves a list of all guestbook entities. Adding
the \texttt{.add(RestrictionsFactoryUtil.eq("name",\ guestbookName))}
restriction limits the results to only those guestbooks whose guestbook
names match the \texttt{guestbookName} parameter. The
\texttt{.setProjection(ProjectionFactoryUtil.property("guestbookId"))}
projection changes the result set from a list of guestbook entries to a
list of guestbook IDs. This is useful since guestbook IDs are much less
expensive to retrieve than full guestbook entities and the guestbook IDs
are all that the guestbook entry query requires.

Next is an order which applies to the list of entries returned by the
\texttt{findByEntryNameGuestbookName} finder method:

\begin{verbatim}
Order order = OrderFactoryUtil.desc("modifiedDate");
\end{verbatim}

When this order is applied to a query, the list of results returned by
the query are arranged in descending order of the query entity's
\texttt{modifiedDate} attribute. Thus the most recently modified
entities (guestbook entries, in our example) appear first and the least
recently modified entities appear last.

Here's the second query:

\begin{verbatim}
DynamicQuery eventQuery = DynamicQueryFactoryUtil.forClass(Entry.class, classLoader)
    .add(RestrictionsFactoryUtil.eq("name", entryName))
    .add(PropertyFactoryUtil.forName("guestbookId").in(guestbookQuery))
    .addOrder(order);

List<Event> entries = _eventLocalService.dynamicQuery(entryQuery);
\end{verbatim}

By default,
\texttt{DynamicQueryFactoryUtil.forClass(Entry.class,\ classLoader)}
returns of list of all guestbook entry entities. The
\texttt{.add(RestrictionsFactoryUtil.eq("name",\ entryName))}
restriction limits the results to only those guestbook entries whose
names match the \texttt{entryName} parameter of the finder method.
\href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/dao/orm/PropertyFactoryUtil.html}{PropertyFactoryUtil}
is a Liferay utility class with the method
\texttt{forName(String\ propertyName)}, which returns the specified
property. This property can be passed to another Liferay dynamic query.
This is exactly what happens in the following line of our example:

\begin{verbatim}
.add(PropertyFactoryUtil.forName("guestbookId").in(guestbookQuery))
\end{verbatim}

Here, the code makes sure that the guestbook IDs (foreign keys) of the
entry entities in the \texttt{entityQuery} must belong to the list of
guestbook IDs returned by the \texttt{guestbookQuery}. Declaring that an
entity property in one query must belong to the result list of another
query is a way to use Liferay's dynamic query API to create complex
queries, similar to SQL joins.

Lastly, you apply the order defined earlier to the entries returned by
the \texttt{findByEntryNameGuestbookName} finder method:

\begin{verbatim}
.addOrder(order);
\end{verbatim}

This orders the list of guestbook entities by the \texttt{modifiedDate}
attribute, from most recent to least recent.

\noindent\hrulefill

\textbf{Note:} Service Builder not only generates a
\texttt{public\ List\ \ dynamicQuery(DynamicQuery\ dynamicQuery)} method
in \texttt{-LocalServiceBaseImpl} but it also generates
\texttt{public\ List\ dynamicQuery(DynamicQuery\ dynamicQuery,\ int\ start,\ \ int\ end)}
and
\texttt{public\ List\ dynamicQuery(DynamicQuery\ dynamicQuery,\ int\ start,\ \ int\ end,\ OrderByComparator\ orderByComparator)}
methods. You can go back to step 1 and either modify your custom finder
method or create overloaded versions of your custom finder method to
take advantage of these extra methods and their parameters. The
\texttt{int\ start} and \texttt{int\ end} parameters are useful when
paginating a result list. \texttt{start} is the lower bound of the range
of model entity instances and \texttt{end} is the upper bound. The
\texttt{OrderByComparator\ orderByComparator} is the comparator by which
to order the results.

\noindent\hrulefill

To use the overloaded \texttt{dynamicQuery} methods of your
\texttt{-LocalServiceBaseImpl} class in the (optionally overloaded)
custom finders of your \texttt{-FinderImpl} class, just choose the
appropriate methods for running the dynamic queries:
\texttt{EventLocalService.dynamicQuery(eventQuery)}, or
\texttt{EventLocalService.dynamicQuery(eventQuery,\ start,\ end)} or
\texttt{EventLocalService.dynamicQuery(eventQuery,\ start,\ end,\ orderByComparator)}.

Great! You've now created a custom finder method using Liferay's Dynamic
Query API. Your last step is to add a service method that calls your
finder.

\subsection{Step 3: Accessing Your Custom Finder Method from the Service
Layer}\label{step-3-accessing-your-custom-finder-method-from-the-service-layer}

So far, you've created a \texttt{-FinderImpl} class, defined a custom
\texttt{findBy-} finder method in that class, and implemented the custom
finder method using Dynamic Query. Now how do you call your custom
finder method from the service layer?

When you ran Service Builder after defining your custom finder method,
the \texttt{-Finder} interface was generated (e.g.,
\texttt{GuestbookFinder}). Your portlet class, however, should not call
the \texttt{-Finder} interface: only a local or remote service
implementation (i.e., \texttt{-LocalServiceImpl} or
\texttt{-ServiceImpl}) in your service module should invoke the
\texttt{-Finder} class. This encourages a proper separation of concerns:
the portlet classes in your application's web module invoke the business
logic of the services published from your application's service module.
The services, in turn, access the data model using the persistence
layer's finder classes.

\noindent\hrulefill

\textbf{Note:} In previous versions of Liferay Portal, your finder
methods were accessible via \texttt{-FinderUtil} utility classes. Finder
methods are now injected into your app's local services, removing the
need to call finder utilities.

\noindent\hrulefill

So you'll add a method in the \texttt{-LocalServiceImpl} class that
invokes the finder method implementation via the \texttt{-Finder} class.
Then you'll rebuild your application's service layer so that the portlet
classes and JSPs in your web module can access the services.

For example, for the Guestbook application, you'd add the following
method to the \texttt{EntryLocalServiceImpl} class:

\begin{verbatim}
public List<Entry> findByEntryNameGuestbookName(String entryName,
    String guestbookName) throws SystemException {

    return entryFinder.findByEntryNameGuestbookName(String entryName,
        String guestbookName);
}
\end{verbatim}

After you've added your \texttt{findBy-} method to your
\texttt{-LocalServiceImpl} class, run Service Builder to generate the
interface and make the finder method available in the
\texttt{EntryLocalService} class.

Now you can indirectly call the finder method from your portlet class or
from a JSP by calling
\texttt{EntryLocalService.findByEntryNameGuestbookName(...)}!

Congratulations on following the three step process of developing a
dynamic query in a custom finder and exposing it as a service for your
portlet!

\subsection{Actionable Dynamic
Queries}\label{actionable-dynamic-queries}

Suppose you have over a million users on your portal, and you want to
perform some kind of mass update to a large portion of them. One
approach might be to use a dynamic query to retrieve the list of users
in question. Once loaded into memory, you could loop through the list
and update each user. However, with over a million users, the memory
cost of such an operation would be too great. In general, if you have
very large numbers of service builder entities, it can be too expensive
in terms of memory and speed to run a dynamic query to retrieve a list
of such entities in order to do some processing on them.

Liferay provides actionable dynamic queries to solve this kind of
situation. An actionable dynamic query does not return a list of service
builder entities like a regular dynamic query. Instead, it uses a
pagination strategy to load only small numbers of service builder
entities into memory at a time and performs some processing (i.e.,
performs an \emph{action}) on each entity. So instead of trying to use a
dynamic query to load a million users into memory and then perform some
processing on each of them, a much better strategy is to use an
actionable dynamic query to process them. This way, only small numbers
of users are loaded into memory at a time, but you still process all the
users.

When you run Service Builder, it includes actionable dynamic query
support in the generated API and service modules. For example, consider
the API module of the BLADE service builder example project.

The \texttt{FooLocalService} interface in the API module contains these
methods:

\begin{verbatim}
@Transactional(propagation = Propagation.SUPPORTS, readOnly = true)
public ActionableDynamicQuery getActionableDynamicQuery();

public DynamicQuery dynamicQuery();

@Transactional(propagation = Propagation.SUPPORTS, readOnly = true)
public ExportActionableDynamicQuery getExportActionableDynamicQuery(
    PortletDataContext portletDataContext);

@Transactional(propagation = Propagation.SUPPORTS, readOnly = true)
public IndexableActionableDynamicQuery getIndexableActionableDynamicQuery();
\end{verbatim}

The \texttt{FooLocalServiceBaseImpl} class in the service module
implements each of these methods. See
\href{https://github.com/liferay/liferay-blade-samples/blob/master/gradle/apps/service-builder/basic/basic-api/src/main/java/com/liferay/blade/samples/servicebuilder/service/FooLocalService.java\#L156-L166}{here}
and
\href{https://github.com/liferay/liferay-blade-samples/blob/master/gradle/apps/service-builder/basic/basic-service/src/main/java/com/liferay/blade/samples/servicebuilder/service/base/FooLocalServiceBaseImpl.java\#L247-L330}{here}
for details.

The implementation of \texttt{FooLocalService.dynamicQuery()} uses
\texttt{DynamicQueryFactoryUtil} to obtain new (regular) dynamic query
instance for the \texttt{Foo} entity. This is the pattern shown earlier.

You can use \texttt{FooLocalService.getActionableDynamicQuery()} to
obtain a new actionable dynamic query instance for the \texttt{Foo}
entity. Once you have the instance, you can use chaining to build up the
query using any of the techniques described above for regular dynamic
queries, such as restrictions or projections. But the point of using an
\emph{actionable} dynamic query is to specify an action to perform on
each entity that results from the query. To specify such an action, use
the
\texttt{ActionableDynamicQuery.setPerformActionMethod\textless{}PerformActionMethod\textless{}?\textgreater{}}
method. Once the query has been defined and an action has been
specified, use the \texttt{ActionableDynamicQuery.performActions} to
perform the action on each entity that results from the query.

Here's an example from a test for Liferay DXP's Bookmarks application:

\begin{verbatim}
ActionableDynamicQuery actionableDynamicQuery = BookmarksEntryLocalServiceUtil.getActionableDynamicQuery();

actionableDynamicQuery.setPerformActionMethod(new ActionableDynamicQuery.PerformActionMethod<BookmarksEntry>() {
        @Override
        public void performAction(BookmarksEntry bookmarksEntry) {
            Assert.assertNotNull(bookmarksEntry);

            count.increment();
        }
    });

actionableDynamicQuery.performActions();
\end{verbatim}

You can see the full context
\href{https://github.com/liferay/liferay-portal/blob/7.0.6-ga7/modules/apps/collaboration/bookmarks/bookmarks-test/src/testIntegration/java/com/liferay/bookmarks/service/persistence/test/BookmarksEntryPersistenceTest.java\#L494-L512}{here}.

Consider the \texttt{FooLocalService} from the BLADE service builder API
project again. For most of your actionable dynamic query use cases, the
actionable query returned by
\texttt{FooLocalService.getActionableDynamicQuery} will suffice. This
actionable dynamic query is an instance of the concrete class
\texttt{DefaultActionableDynamicQuery}. However, in addition to
\texttt{FooLocalService.getActionableDynamicQuery}, there are two
additional methods related to actionable dynamic queries:
\texttt{FooLocalService.getExportActionableDynamicQuery} and
\texttt{FooLocalService.getIndexableActionableDynamicQuery}. These
methods return instances of concrete classes (either
\texttt{IndexableActionableDynamicQuery} or
\texttt{ExportActionableDynamicQuery}) that extend
\texttt{DefaultActionableDynamicQuery}.
\texttt{IndexableActionableDynamicQuery} contains methods designed to
facilitate processing that involves search indexing and
\texttt{ExportActionableDynamicQuery} contains methods designed to
facilitate processing that involves export / import functionality.

To see examples of configuring indexer and export actionable dynamic
queries, see the Bookmarks application
\href{https://github.com/liferay/liferay-portal/blob/7.0.6-ga7/modules/apps/collaboration/bookmarks/bookmarks-service/src/main/java/com/liferay/bookmarks/service/base/BookmarksEntryLocalServiceBaseImpl.java\#L291-L302}{here}
and
\href{https://github.com/liferay/liferay-portal/blob/7.0.6-ga7/modules/apps/collaboration/bookmarks/bookmarks-service/src/main/java/com/liferay/bookmarks/service/base/BookmarksEntryLocalServiceBaseImpl.java\#L313-L336}{here}.
To see an example invocation of an indexable actionable dynamic query,
see the \texttt{reindexEntries} method of the Bookmarks application's
indexer
\href{https://github.com/liferay/liferay-portal/blob/7.0.6-ga7/modules/apps/collaboration/bookmarks/bookmarks-service/src/main/java/com/liferay/bookmarks/search/BookmarksEntryIndexer.java\#L155-L210}{here}.

\subsection{Related Topics}\label{related-topics-125}

\href{/docs/7-0/tutorials/-/knowledge_base/t/service-builder-web-services}{Service
Builder Web Services}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-local-services}{Creating
Local Service}

\href{/docs/7-0/tutorials/-/knowledge_base/t/invoking-local-services}{Invoking
Local Services}

\section{Configuring
service.properties}\label{configuring-service.properties}

In this tutorial, you'll learn how to use and edit the
\texttt{service.properties} file. You'll also learn about the properties
included in this file and how to set them to fit your needs.

Service Builder generates a \texttt{service.properties} file in your
\texttt{*-service} module's \texttt{src/main/resources} folder. Liferay
DXP uses the properties in this file to alter your service's database
schema. You should not modify this file, but rather make any necessary
overrides in a \texttt{service-ext.properties} file in that same folder.

Here are some of the properties included in the
\texttt{service.properties} file:

\begin{itemize}
\tightlist
\item
  \texttt{build.namespace}: This is the namespace you defined in your
  \texttt{service.xml}. Liferay distinguishes different plugins from
  each other using their namespaces.
\item
  \texttt{build.number}: Liferay distinguishes different builds of your
  plugin. Each time a distinct build of your plugin is deployed to
  Liferay, Liferay increments this number.
\item
  \texttt{build.date}: This is the time of the latest build of your
  plugin.
\item
  \texttt{include-and-override}: The default value of this property
  defines \texttt{service-ext.properties} as an override file for
  \texttt{service.properties}.
\end{itemize}

\noindent\hrulefill

\textbf{Note:} The \texttt{build.auto.upgrade} property is available for
WAR-style Service Builder applications. This property determines whether
or not Liferay should automatically apply changes to the database model
when a new version of the plugin is deployed. This is \texttt{true} by
default. This property is not necessary for module-style applications.

It's sometimes useful to override the \texttt{build.auto.upgrade}
property in legacy projects from \texttt{service.properties}. Setting
\texttt{build.auto.upgrade=false} in your
\texttt{service-ext.properties} file prevents Liferay from trying
automatically to apply any changes to the database model when a new
version of the plugin is deployed. This is needed in projects to
manually manage the changes to the database (recommended) or in which
the SQL schema has intentionally been modified manually after generation
by Service Builder.

\noindent\hrulefill

Awesome! You now have all the tools necessary to set up your own
\texttt{service-ext.properties} file.

\subsection{Related Topics}\label{related-topics-126}

\href{/docs/7-0/tutorials/-/knowledge_base/t/what-is-service-builder}{What
is Service Builder?}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-local-services}{Creating
Local Services}

\section{Connecting Service Builder to External Data
Sources}\label{connecting-service-builder-to-external-data-sources}

Sometimes you want to use a data source other than Liferay DXP's. To do
this, the data source must be defined in \texttt{portal-ext.properties}
or configured as a JNDI data source on Liferay DXP's app server. This
tutorial shows how to connect
\href{/docs/7-0/tutorials/-/knowledge_base/t/service-builder}{Service
Builder} to a data source.

\noindent\hrulefill

\textbf{Note}: All entities defined in a Service Builder module's
\texttt{service.xml} file are bound to the same data source. Binding
different entities to different data sources requires defining the
entities in separate Service Builder modules and configuring each of the
modules to use a different data source.

\noindent\hrulefill

Here are the steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  If Liferay DXP's application server defines the data source using
  JNDI, skip this step. Otherwise, specify the data source in a
  \texttt{portal-ext.properties} file. Distinguish it from Liferay DXP's
  default data source by giving it a prefix other than
  \texttt{jdbc.default.}. This example uses prefix \texttt{jdbc.ext.}:

\begin{verbatim}
jdbc.ext.driverClassName=org.mariadb.jdbc.Driver
jdbc.ext.password=userpassword
jdbc.ext.url=jdbc:mariadb://localhost/external?useUnicode=true&characterEncoding=UTF-8&useFastDateParsing=false
jdbc.ext.username=yourusername
\end{verbatim}
\item
  Create a Spring bean that points to the data source. To do this,
  create an \texttt{ext-spring.xml} file in your Service Builder
  module's \texttt{src/main/resources/META-INF/spring} folder or in your
  traditional portlet's \texttt{WEB-INF/src/META-INF} folder. Define the
  following elements:

  \begin{itemize}
  \tightlist
  \item
    A data source factory Spring bean for the data source. It's
    different based on the type:

    \begin{itemize}
    \item
      \textbf{JNDI}: Specify an arbitrary property prefix and prepend
      the prefix to a JNDI name property key. Here's an example:

\begin{verbatim}
<bean class="com.liferay.portal.dao.jdbc.spring.DataSourceFactoryBean"
    id="liferayDataSourceFactory">
    <property name="propertyPrefix" value="custom." />
    <property name="properties">
        <props>
            <prop key="custom.jndi.name">jdbc/externalDataSource</prop>
        </props>
    </property>
</bean>
\end{verbatim}
    \item
      \textbf{Portal Properties}: Specify a property prefix that matches
      the prefix (e.g., \texttt{jdbc.ext.}) you used in
      \texttt{portal-ext.properties}.

\begin{verbatim}
<bean class="com.liferay.portal.dao.jdbc.spring.DataSourceFactoryBean"
    id="liferayDataSourceFactory">
    <property name="propertyPrefix" value="jdbc.ext." />
</bean>
\end{verbatim}
    \end{itemize}
  \item
    A Liferay DXP data source bean that refers to the data source
    factory Spring bean.
  \item
    An alias for the Liferay DXP data source bean.
  \end{itemize}

  Here's an example \texttt{ext-spring.xml} that points to a JNDI data
  source:

\begin{verbatim}
<?xml version="1.0"?>

<beans default-destroy-method="destroy" default-init-method="afterPropertiesSet"
   xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">

   <!-- To define an external data source, the liferayDataSource Spring bean 
       must be overridden. Other default Spring beans like liferaySessionFactory 
       and liferayTransactionManager may optionally be overridden. 

       liferayDataSourceFactory refers to the data source configured on the
       application server. -->
   <bean class="com.liferay.portal.dao.jdbc.spring.DataSourceFactoryBean"
       id="liferayDataSourceFactory">
       <property name="propertyPrefix" value="custom." />
       <property name="properties">
           <props>
               <prop key="custom.jndi.name">jdbc/externalDataSource</prop>
           </props>
       </property>
   </bean>

   <!-- The data source bean refers to the factory to access the data source.
   -->
   <bean
       class="org.springframework.jdbc.datasource.LazyConnectionDataSourceProxy"
       id="liferayDataSource">
       <property name="targetDataSource" ref="liferayDataSourceFactory" />
   </bean>

   <!-- In service.xml, we associated our entity with the extDataSource. To 
       associate the extDataSource with our overridden liferayDataSource, we define 
       this alias. -->
   <alias alias="extDataSource" name="liferayDataSource" />
</beans>
\end{verbatim}

  The \texttt{liferayDataSourceFactory} above refers to a JNDI data
  source named \texttt{jdbc/externalDataSource}. If the data source was
  specified via data source properties in a
  \texttt{portal-ext.properties} file, the bean would require only a
  \texttt{propertyPrefix} property that matches the data source property
  prefix.

  The data source bean \texttt{liferayDataSource} is overridden with one
  that refers to the \texttt{liferayDataSourceFactory} bean. The
  override affects this bundle (module or
  \href{/docs/7-0/tutorials/-/knowledge_base/t/using-the-wab-generator}{Web
  Application Bundle}) only.

  The alias \texttt{extDataSource} refers to the
  \texttt{liferayDataSource} data source bean.
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note**: To use an external data source in multiple Service Builder
 bundles, you must override the `liferayDataSource` bean in each bundle.
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\item
  In your Service Builder module's \texttt{service.xml} file, set your
  entity's data source to the \texttt{liferayDataSource} alias you
  specified in your \texttt{ext-spring.xml} file. Here's an example:

\begin{verbatim}
<?xml version="1.0"?>
<!DOCTYPE service-builder PUBLIC "-//Liferay//DTD Service Builder 7.0.0//EN"
    "http://www.liferay.com/dtd/liferay-service-builder_7_0_0.dtd">

<service-builder package-path="com.liferay.example" >
    <namespace>TestDB</namespace>
    <entity local-service="true" name="Foo" table="testdata" data-source="extDataSource"
            remote-service="false" uuid="false">
           <column name="id" db-name="id" primary="true" type="long" />
           <column name="foo" db-name="foo" type="String" />
           <column name="bar" db-name="bar" type="long" />
    </entity>
</service-builder>
\end{verbatim}

  Note the example's \texttt{\textless{}entity\textgreater{}} tag
  attributes:

  \begin{itemize}
  \tightlist
  \item
    \texttt{data-source}: The \texttt{liferayDataSource} alias
    \texttt{ext-spring.xml} specifies.
  \item
    \texttt{table}: Your entity's database table.
  \end{itemize}

  Also note that your entity's \texttt{\textless{}column\textgreater{}}s
  must have a \texttt{db-name} attribute set to the column name.
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/running-service-builder-and-understanding-the-generated-code}{Run
  Service Builder}.
\end{enumerate}

Now your Service Builder services use the data source. You can
\href{/docs/7-0/tutorials/-/knowledge_base/t/business-logic-with-service-builder}{use
the services in your business logic} as you always have regardless of
the underlying data source.

\subsection{Related Topics}\label{related-topics-127}

\href{/docs/7-0/tutorials/-/knowledge_base/t/connecting-to-data-sources-using-jndi}{Connecting
to JNDI Data Sources}

\href{/docs/7-0/tutorials/-/knowledge_base/t/service-builder}{Service
Builder}

\href{/docs/7-0/tutorials/-/knowledge_base/t/running-service-builder-and-understanding-the-generated-code}{Running
Service Builder and Understanding the Generated Code}

\href{/docs/7-0/tutorials/-/knowledge_base/t/business-logic-with-service-builder}{Business
Logic with Service Builder}

\chapter{Business Logic with Service
Builder}\label{business-logic-with-service-builder}

Once you've defined your application's entities and ran Service Builder
to generate your service and persistence layers, you can begin adding
business logic. Each entity generated by Service Builder contains a
model implementation, local service implementation, and optionally a
remote service implementation class. Your application's business logic
can be implemented in these classes. The generated service layer
contains default methods for CRUD operations, but often times it's
necessary to implement additional methods. Once you've added your
business logic, running Service Builder again regenerates your
application's interfaces and makes your new logic available for
invocation.

In this section of tutorials, you'll learn about creating and invoking
your application's local services, finding and invoking Liferay's
services, and customizing Liferay services.

\section{Creating Local Services}\label{creating-local-services}

The heart of your service is its \texttt{*LocalServiceImpl} class. This
class is your entity's local service extension point. Local services can
be invoked within your application or by other Liferay applications
running on the same Liferay instance as your application. Remote
services differ from local services in that remote services can be
invoked from any application that can access your Liferay instance
(e.g., over the Internet) and has permission to do so. All of your
application's core business logic for working with your entity model (or
models) should be added as methods of your \texttt{*LocalServiceImpl}
class. Before adding any custom service methods, however, you should
review the initial service classes that Service Builder generated during
its initial run.

\textbf{Best Practice:} If your application needs both local and remote
services, determine the service methods that your application needs for
working with your entity model. Add these service methods to
\texttt{*LocalServiceImpl}. Then create corresponding remote services
methods in \texttt{*ServiceImpl}. Add permission checks to the remote
service methods and make the remote service methods invoke the local
service methods. The remote service methods can have the same names as
the local service methods that they call. Within your application, only
call the remote services. This ensures that your service methods are
secured and that you don't have to duplicate permissions code.

Note that Service Builder creates a \texttt{*LocalService} class which
is the interface for the local service. It contains the signatures of
every method in \texttt{*LocalServiceBaseImpl} and
\texttt{*LocalServiceImpl}. \texttt{*LocalServiceBaseImpl} contains some
automatically generated methods that provide functionality that's common
to all local services. Since the \texttt{*LocalService} class is
generated, you should never modify it. If you do, your changes will be
overwritten the next time you run Service Builder. All custom code
should be placed in \texttt{*LocalServiceImpl}, where it will not be
overwritten.

For example, the Bookmarks application's
\href{https://github.com/liferay/liferay-portal/blob/7.0.6-ga7/modules/apps/collaboration/bookmarks/bookmarks-service/src/main/java/com/liferay/bookmarks/service/impl/BookmarksEntryLocalServiceImpl.java}{BookmarksEntryLocalServiceImpl}
class demonstrates the kinds of service methods that applications
commonly need for working with an entity model. Click on the class's
link to view some of its local service methods.

In order to add an entity to the database, you need an ID for the
entity. Liferay provides a counter service which you call to obtain a
unique ID for each new entity. It's possible to use the
\texttt{increment} method of Liferay's
\href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/counter/kernel/service/CounterLocalService.html}{\texttt{CounterLocalService}}
class, but Service Builder already makes a \texttt{CounterLocalService}
instance available to your app's \texttt{*LocalServiceBaseImpl}. The
\texttt{CounterLocalService} instance is injected into a module as an
OSGi service:

\begin{verbatim}
@ServiceReference(type=com.liferay.counter.kernel.service.CounterLocalService.class)
protected com.liferay.counter.kernel.service.CounterLocalService counterLocalService;
\end{verbatim}

If you're creating local services in Liferay's core, the
\texttt{CounterLocalService} instance is injected as a Spring bean:

\begin{verbatim}
@BeanReference(type=com.liferay.counter.kernel.service.CounterLocalService.class)
protected com.liferay.counter.kernel.service.CounterLocalService counterLocalService;
\end{verbatim}

Since your \texttt{*LocalServiceImpl} class extends
\texttt{*LocalServiceBaseImpl}, you can access this
\texttt{CounterLocalService} instance. See your app's
\texttt{*LocalServiceBaseImpl} for a list of all the Spring beans/OSGi
services you have available for use.

You can use either the injected class's \texttt{increment} method or you
can call Liferay's
\href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/counter/kernel/service/CounterLocalService.html}{\texttt{CounterLocalService}}'s
\texttt{increment} method directly. For example, a bookmarks entry is
assigned a unique ID like this:

\begin{verbatim}
long entryId = counterLocalService.increment();
\end{verbatim}

The Bookmarks application uses the generated \texttt{entryId} as the ID
for the new \texttt{BookmarksEntry}:

\begin{verbatim}
BookmarksEntry entry = bookmarksEntryPersistence.create(entryId);
\end{verbatim}

\texttt{bookmarksEntryPersistence} is one of the OSGi services injected
into \texttt{EventLocalServiceBaseImpl} by Service Builder.

Next, the Bookmarks application sets the attribute fields that were
specified for the BookmarksEntry entity in the \texttt{service.xml}.
These attributes include the \texttt{groupId}, \texttt{userId},
\texttt{name}, \texttt{url}, \texttt{serviceContext}, etc. Lastly, a
Bookmarks folder ID must be associated to the entry.

It's also important to assign values to the audit fields. In the
Bookmarks application, the group of the entity is set first. An entity's
group determines its scope. In this example, the group is the site. The
company and user are specified after the group is set. The company
represents the portal instance and the user is the user who created the
bookmark. The Bookmarks application sets the \texttt{createDate} and
\texttt{modifiedDate} of the Event to the current time. After that, the
generated \texttt{addEntry} method of
\texttt{BookmarksEntryLocalServiceBaseImpl} is called to add the
bookmark to the database. Lastly, the bookmark is added as a resource so
that permissions can be applied to it later. To view the
\texttt{addEntry} method in its entirety, see the
\href{https://github.com/liferay/liferay-portal/blob/7.0.6-ga7/modules/apps/collaboration/bookmarks/bookmarks-service/src/main/java/com/liferay/bookmarks/service/impl/BookmarksEntryLocalServiceImpl.java}{BookmarksEntryLocalServiceImpl}
class.

The Bookmarks application creates local services for BookmarksFolder
entities as well as for BookmarksEntry entities. Take a look at the
custom service methods available in the
\href{https://github.com/liferay/liferay-portal/blob/7.0.6-ga7/modules/apps/collaboration/bookmarks/bookmarks-service/src/main/java/com/liferay/bookmarks/service/impl/BookmarksFolderLocalServiceImpl.java}{BookmarksFolderLocalServiceImpl}
class for a better understanding of services available for bookmark
folders.

Before you can use any custom methods that you added to your
\texttt{*LocalServiceImpl} class, you must run Service Builder again.
Running Service Builder again adds the method signatures of your custom
service methods to your \texttt{*LocalService} interface and updates
your \texttt{*LocalServiceUtil} class. For more information on running
Service Builder see the
\href{/docs/7-0/tutorials/-/knowledge_base/t/running-service-builder-and-understanding-the-generated-code}{Running
Service Builder and Understanding the Generated Code} tutorial.

Service Builder looks through your \texttt{*LocalServiceImpl} class and
automatically copies the signatures of each method into the
corresponding \texttt{*LocalService} interface. After running Service
Builder, you can test that your services are working as intended by
invoking one of the methods that Service Builder added to your
\texttt{*LocalService} class. For example, if you were developing the
Bookmarks application, you could make the following service invocation
to make sure that your service was working as intended:

\begin{verbatim}
BookmarksEntryLocalService.addBookmarksEntry(bookmarksEntry);
\end{verbatim}

In addition to all of the Java classes and interfaces, Service Builder
also generates a \texttt{service.properties} file. To learn about the
\texttt{service.properties} file and how to configure it, please refer
to the
\href{/docs/7-0/tutorials/-/knowledge_base/t/configuring-service-properties}{Configuring
service.properties} tutorial. To learn how to invoke local services,
please refer to the
\href{/docs/7-0/tutorials/-/knowledge_base/t/invoking-local-services}{Invoking
Local Services} tutorial.

\subsection{Related Topics}\label{related-topics-128}

\href{/docs/7-0/tutorials/-/knowledge_base/t/running-service-builder-and-understanding-the-generated-code}{Running
Service Builder and Understanding the Generated Code}

\href{/docs/7-0/tutorials/-/knowledge_base/t/invoking-local-services}{Invoking
Local Services}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-remote-services}{Creating
Remote Services}

\section{Invoking Local Services}\label{invoking-local-services}

In this tutorial, you'll learn about the differences between local and
remote services, and when you should invoke local services rather than
their remote service counterparts.

Once Service Builder has generated your module project's services, you
can call them from anywhere in your application. When invoking a local
service, you should call one of the service methods of a
\texttt{*LocalService} class. You should never call the service methods
of an \texttt{*Impl} class directly. Local services in your project are
generated automatically when using Service Builder. To do this, set the
\texttt{local-service} attribute to \texttt{true} for an entity in the
\texttt{service.xml} file. Service Builder generates methods that call
existing services, but you can create new methods in the
\texttt{*LocalServiceImpl} class that can be generated into new exposed
methods in your module's services (\texttt{*LocalService},
\texttt{*LocalServiceUtil}, etc.).

Many of Liferay's module applications use their generated remote
services for important calls in their controller layer, for example,
because they offer conveniences like configured permissions checking.
Remote services perform a permission check and then invoke the
corresponding local service. However, there are many services you'd like
to expose only to your local project, and do not want other applications
to have access to.

In the Bookmarks application, for example, the
\href{https://github.com/liferay/liferay-portal/blob/7.0.6-ga7/modules/apps/collaboration/bookmarks/bookmarks-api/src/main/java/com/liferay/bookmarks/service/BookmarksEntryLocalService.java}{BookmarksEntryLocalService}
interface provides the \texttt{openEntry} method, which opens a bookmark
for viewing. The remote service interface
\href{https://github.com/liferay/liferay-portal/blob/7.0.6-ga7/modules/apps/collaboration/bookmarks/bookmarks-api/src/main/java/com/liferay/bookmarks/service/BookmarksEntryService.java}{BookmarksEntryService},
however, does not provide this method. Why could this be?

There are many services that you don't want to expose to other
applications in Liferay. In the example mentioned above, Bookmarks are
configured to only open locally, meaning that other apps do not have
access to open and view a bookmark entry. This should only be done by
the Bookmarks application. Therefore, in certain cases, you'll need to
invoke local services instead of remote services. For more information
on invoking remote services, see the
\href{/docs/7-0/tutorials/-/knowledge_base/t/invoking-remote-services}{Invoking
Remote Services} tutorial.

To see how you could call a local service from a portlet action class,
you'll examine the
\href{https://github.com/liferay/liferay-portal/blob/7.0.6-ga7/modules/apps/foundation/users-admin/users-admin-web/src/main/java/com/liferay/users/admin/web/portlet/action/EditOrganizationMVCActionCommand.java}{EditOrganizationMVCActionCommand}
class. Notice that this class has a private instance variable called
\texttt{\_dlAppLocalService}. The \texttt{\_dlAppLocalService} instance
variable of type \texttt{DLAppLocalService} gets an instance of
\texttt{DLAppLocalService} at runtime via dependency injection. The
instance variable is set like this:

\begin{verbatim}
@Reference(unbind = "-")
protected void setDLAppLocalService(DLAppLocalService dlAppLocalService) {
    _dlAppLocalService = dlAppLocalService;
}
\end{verbatim}

This tutorial demonstrated how you can call the local services generated
by Service Builder in your project. To learn how to call Liferay
services, see the
\href{/docs/7-0/tutorials/-/knowledge_base/t/service-security-layers}{Service
Security Layers} and
\href{/docs/7-0/tutorials/-/knowledge_base/t/finding-and-invoking-liferay-services}{Finding
and Invoking Liferay Services} tutorials.

\subsection{Related Topics}\label{related-topics-129}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-local-services}{Creating
Local Services}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-remote-services}{Creating
Remote Services}

\href{/docs/7-0/tutorials/-/knowledge_base/t/invoking-remote-services}{Invoking
Remote Services}

\section{Finding and Invoking Liferay
Services}\label{finding-and-invoking-liferay-services}

In this tutorial, you'll learn how to search for portal services and
portlet services. You can find Liferay's services by searching for them
in the Javadocs:
\href{@platform-ref@/7.0-latest/javadocs/}{@platform-ref@/7.0-latest/javadocs/}.

First, you'll learn how to find a portal service using Liferay's
Javadocs.

\subsection{Finding Liferay Portal
Services}\label{finding-liferay-portal-services}

Searching for Liferay Portal services is easy and intuitive. The first
two options, \texttt{portal-impl} and \texttt{portal-kernel}, are the
most popular options when searching for Liferay's Javadocs. In summary,
the \texttt{portal-kernel} directory provides interfaces and utils, and
the \texttt{portal-impl} directory provides service implementations that
implement those interfaces. The remaining options are miscellaneous util
and test classes that are used in Liferay DXP.

Liferay's Javadocs are easy to browse and well-organized. Here's how to
find the \emph{Organization} services, for example:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In your browser, open up the Javadocs:
  \href{@platform-ref@/7.0-latest/javadocs/}{@platform-ref@/7.0-latest/javadocs/}
  You're offered several options, which were discussed earlier. Select
  \emph{portal-kernel}.
\item
  Under \emph{Portal Kernel}, click on the link for the
  \texttt{com.liferay.portal.kernel.service} package, since the services
  for the Organization entity belong to the \emph{Portal} scope.
\item
  Find and click on the \texttt{*LocalService} class (in this case,
  \texttt{OrganizationLocalService}) in the \emph{Class Summary} table
  or the \emph{Classes} list at the bottom of the page.
\end{enumerate}

That was easy! What if you want to find module services?

\subsection{Finding Liferay Module
Services}\label{finding-liferay-module-services}

Searching for Liferay module services is also easy. The Javadocs for
modules are hosted on Liferay's Nexus repository, and can be viewed by
downloading and extracting the module's \texttt{*javadoc.jar} file. You
can learn move about how a module's Java API is organized by reading the
\href{/docs/7-0/reference/-/knowledge_base/r/development-reference\#java-apis}{Java
APIs} section.

Here's an example of how to find services for a bookmarks entry:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Navigate to Liferay's
  \href{https://repository.liferay.com/nexus/content/repositories/liferay-public-releases/com/liferay/}{Nexus
  repository} and select \texttt{com.liferay.bookmarks.api}. Then select
  the appropriate version.
\item
  Select the
  \texttt{com.liferay.bookmarks.api-{[}VERSION{]}-javadoc.jar} link,
  which downloads that JAR file. Extract the JAR file, once downloaded.
\item
  Open the extracted contents and select the \texttt{index.html} file.
\item
  Select the \texttt{com.liferay.bookmarks.service} package from the
  main view, and then select the \texttt{BookmarksEntryLocalService}
  class in the \emph{Class Summary} table or the \emph{Classes} list.
\end{enumerate}

Awesome! You've successfully located the bookmark entry's services.

Another easy way to search for services in module projects is by
importing them into your IDE. For Liferay @ide@, you can right-click in
the Package Explorer and navigate to \emph{Import} → \emph{Liferay
Module Project(s)}. Then browse for your module, select the build type,
and click \emph{Finish}. Now you can peruse your module services from
Liferay @ide@.

Now you're ready to invoke Liferay services.

\subsection{Invoking Liferay Services
Locally}\label{invoking-liferay-services-locally}

Every Liferay service provides a local interface to clients running in
the same JVM as Liferay Portal. Many local services (e.g.,
\texttt{*LocalService} classes) are called by remote services (e.g.,
\texttt{*Service} classes). The remote classes mask the complexity of
the local service implementations and include permission checks. The
core Liferay services that are provided as part of Liferay Portal were
generated by the same Service Builder tool that you can use in your
applications. You can invoke a remote Liferay service by calling the
appropriate \texttt{*LocalService} or \texttt{*Service} class. The
following code found in the \texttt{journal-content-web} module
demonstrates how to retrieve the portal instance's group by calling
Liferay's \texttt{GroupLocalService}:

\begin{verbatim}
Group group = _groupLocalService.getCompanyGroup(companyId);
\end{verbatim}

By Liferay convention, the \texttt{\_groupLocalService} instance
variable is created and set for usage in the class it's called from:

\begin{verbatim}
private GroupLocalService _groupLocalService;

@Reference(unbind = "-")
protected void setGroupLocalService(GroupLocalService groupLocalService) {
    _groupLocalService = groupLocalService;
}
\end{verbatim}

The \texttt{@Reference(unbind="-")} annotation retrieves a reference to
a service of type \texttt{GroupLocalService}, and ignores how this
service has been published and who published it.

Besides the services Service Builder made available for your
application, you can also access any service published within the OSGi
Registry. This means the following services are available:

\begin{itemize}
\tightlist
\item
  Beans defined in Liferay's core
\item
  Beans created in other module app contexts
\item
  Services declared using Declarative Service
\item
  Services registered using the OSGi low level API
\end{itemize}

Some types of portlets don't have access to the OSGi Registry using
Declarative Services (e.g., Spring MVC and JSF). You can call OSGi
services in these portlets by using
\href{/docs/7-0/tutorials/-/knowledge_base/t/service-trackers}{Service
Trackers}.

You'll learn more about referencing OSGi services next.

\subsection{Referencing OSGi Services}\label{referencing-osgi-services}

All the services created within your Service Builder application are
wired using an internal Spring Application Context. This uses AOP
proxies to give your services the ability to deal with transactions,
indexing, and security.

In many cases, however, you'll need to reference an external service
(i.e., something that is not defined within your Spring Application
Context). Liferay has included the ability to reference OSGi services
from your Spring beans using the \texttt{@ServiceReference} annotation.

You'll step through a simple example next.

Suppose you're building an application with a simple entity defined in
your \texttt{service.xml} file. The application needs to send an SMS
every time a new entity is created, and the \texttt{SMSService} is
provided by a module installed in the system.

How would you get a reference from the \texttt{-LocalServiceImpl}
(Spring bean) to an \emph{external} service? You can do this by using
the \texttt{@ServiceReference} annotation:

\begin{verbatim}
@ServiceReference
private SMSService _smsService;
\end{verbatim}

Using this annotation lets you retrieve a reference to an OSGi service
from a regular Spring bean. This provides some nice benefits. If the
\texttt{SMSService} is not available, the whole Spring context is not
created until the service is available. Likewise, if the
\texttt{SMSService} suddenly disappears, the whole Spring Application
Context is destroyed. This makes our Spring apps much more robust and
versatile.

Fortunately, Service Builder generates this kind of code every time you
have a reference to an entity which is not defined in your
\texttt{service.xml} file. For example, imagine that your entity has a
reference provided in your \texttt{service.xml} file, to the Group
entity:

\begin{verbatim}
<reference entity="Group" package-path="com.liferay.portal" />
\end{verbatim}

The generated code for this entity would look like the following:

\begin{verbatim}
@ServiceReference(type = com.liferay.portal.kernel.service.GroupLocalService.class)
protected com.liferay.portal.kernel.service.GroupLocalService groupLocalService;
\end{verbatim}

Great! You know how to find Liferay's core and module services, and can
invoke them from your application. You also learned about referencing
OSGi services.

\subsection{Related Topics}\label{related-topics-130}

\href{/docs/7-0/tutorials/-/knowledge_base/t/invoking-local-services}{Invoking
Local Services}

\href{/docs/7-0/tutorials/-/knowledge_base/t/invoking-remote-services}{Invoking
Remote Services}

\href{/docs/7-0/tutorials/-/knowledge_base/t/json-web-services-invoker}{JSON
Web Services Invoker}

\href{/docs/7-0/tutorials/-/knowledge_base/t/service-trackers}{Service
Trackers}

\chapter{Data Access}\label{data-access}

Liferay DXP's data can be retrieved using its APIs. It's important,
however, to understand how data is used amid all of Liferay DXP's
constructs. At a basic level, all the data is represented by an object
model. This is retrieved from the database and automatically mapped from
SQL to the model by
\href{/docs/7-0/tutorials/-/knowledge_base/t/service-builder}{Service
Builder}. Using
\href{/docs/7-0/tutorials/-/knowledge_base/t/model-listeners}{Model
Listeners}, you can listen for events on these models and take action
when they are stored or retrieved.

All data in Liferay DXP is
\href{/docs/7-0/tutorials/-/knowledge_base/t/data-scopes}{scoped} to a
context: a site, a page, or global. When storing data in your
application, you should therefore take advantage of scope so your
application integrates well with the system and users can add your
application in whatever scope they need it.

Read on to learn how to do both of these things.

\section{Data Scopes}\label{data-scopes}

Apps in Liferay DXP can restrict their data to specific scopes. Scopes
provide a context for the application's data. For example, a site-scoped
app can display its data across a single site. For a detailed
explanation of scopes, see the user guide article
\href{/docs/7-0/user/-/knowledge_base/u/application-scope}{Application
Scope}. To give your applications scope, you must manually add support
for it. This tutorial shows you how.

\subsection{Scoping Your Entities}\label{scoping-your-entities}

In your service layer, your entities must have a \texttt{companyId}
attribute of type \texttt{long} to enable scoping by portal instance and
a \texttt{groupId} attribute of type \texttt{long} to enable scoping by
site. Using
\href{/docs/7-0/tutorials/-/knowledge_base/t/what-is-service-builder}{Service
Builder} is the simplest way to do this. For instructions on this, see
the tutorial series
\href{/docs/7-0/tutorials/-/knowledge_base/t/service-builder-persistence}{Service
Builder Persistence} and
\href{/docs/7-0/tutorials/-/knowledge_base/t/business-logic-with-service-builder}{Business
Logic with Service Builder}.

\subsection{Enabling Scoping}\label{enabling-scoping}

To enable scoping in your app, set the property
\texttt{"com.liferay.portlet.scopeable=true"} in your portlet class's
\texttt{@Component} annotation. For example, this property is set to
\texttt{true} in the \texttt{@Component} annotation of
\href{https://github.com/liferay/liferay-portal/blob/7.0.x/modules/apps/web-experience/journal/journal-content-web/src/main/java/com/liferay/journal/content/web/internal/portlet/JournalContentPortlet.java}{Web
Content Display Portlet's portlet class}:

\begin{verbatim}
@Component(
    immediate = true,
    property = {
        ...
        "com.liferay.portlet.scopeable=true",
        ...,
    },
    service = Portlet.class
)
public class JournalContentPortlet extends MVCPortlet {...
\end{verbatim}

That's it! You can now access your app's scope in your code. The next
section shows you how.

\subsection{Accessing Your App's Scope}\label{accessing-your-apps-scope}

Users can typically set an app's scope to a page, a site, or the entire
portal. To handle your app's data, you must access it in its current
scope. Liferay DXP gives you techniques to do this. Your app's scope is
available:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Via the \texttt{scopeGroupId} variable that is injected in your JSPs
  whenever you use the
  \texttt{\textless{}liferay-theme:defineObjects\ /\textgreater{}} tag.
  This variable contains your app's current scope. For example,
  Liferay's Bookmarks app uses \texttt{scopeGroupId}
  \href{https://github.com/liferay/liferay-portal/blob/7.0.x/modules/apps/collaboration/bookmarks/bookmarks-web/src/main/resources/META-INF/resources/bookmarks/view.jsp}{in
  its \texttt{view.jsp}} to retrieve the bookmarks and total number of
  bookmarks in the current scope:

\begin{verbatim}
 ...
 total = BookmarksEntryServiceUtil.getGroupEntriesCount(scopeGroupId, groupEntriesUserId);

 bookmarksSearchContainer.setTotal(total);
 bookmarksSearchContainer.setResults(BookmarksEntryServiceUtil.getGroupEntries(scopeGroupId, groupEntriesUserId, bookmarksSearchContainer.getStart(), bookmarksSearchContainer.getEnd()));
 ...
\end{verbatim}
\item
  By calling the \texttt{getScopeGroupId()} method on the request's
  \href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/theme/ThemeDisplay.html}{\texttt{ThemeDisplay}
  instance}. This method returns your app's current scope. For example,
  the
  \href{https://github.com/liferay/liferay-portal/blob/7.0.x/modules/apps/collaboration/blogs/blogs-web/src/main/java/com/liferay/blogs/web/internal/portlet/action/EditEntryMVCActionCommand.java}{\texttt{EditEntryMVCActionCommand}
  class} in Liferay's Blogs app does this in its \texttt{subscribe} and
  \texttt{unsubscribe} methods:

\begin{verbatim}
 protected void subscribe(ActionRequest actionRequest) throws Exception {
     ThemeDisplay themeDisplay = (ThemeDisplay)actionRequest.getAttribute(
         WebKeys.THEME_DISPLAY);

     _blogsEntryService.subscribe(themeDisplay.getScopeGroupId());
 }

 protected void unsubscribe(ActionRequest actionRequest) throws Exception {
     ThemeDisplay themeDisplay = (ThemeDisplay)actionRequest.getAttribute(
         WebKeys.THEME_DISPLAY);

     _blogsEntryService.unsubscribe(themeDisplay.getScopeGroupId());
 }
\end{verbatim}

  If you know your app always needs the portal instance ID, use
  \texttt{themeDisplay.getCompanyId()}.
\item
  By calling the \texttt{getScopeGroupId()} method on a
  \texttt{ServiceContext} object. You can find more information on this,
  and an example, in the tutorial
  \href{/docs/7-0/tutorials/-/knowledge_base/t/understanding-servicecontext}{Understanding
  \texttt{ServiceContext}}. If you know your app always needs the portal
  instance ID, use the \texttt{getCompanyId()} method on a
  \texttt{ServiceContext} object.
\end{enumerate}

Awesome! Now you know how to get your app's scope. Next, you'll learn
about a special use case: getting the site scope for entities that
belong to a different app.

\subsection{Accessing the Site Scope Across
Apps}\label{accessing-the-site-scope-across-apps}

There may be times when you need to access a different app's site-scoped
data, even though your app may be scoped to a page or the portal. For
example, web content articles can be created in the page, site, or
portal scope.
\href{/docs/7-0/user/-/knowledge_base/u/designing-uniform-content}{Structures
and Templates} for such articles, however, can only exist in the site
scope. If you use the above techniques to retrieve the app's current
scope, you won't always get the site scope required for Structures and
Templates. You might get the page or portal scope instead, if that's how
the user configured your app. What a pickle! Never fear, the
\texttt{ThemeDisplay} method \texttt{getSiteGroupId()} is here! This
method always gets the site scope, no matter your app's current scope.
For example,
\href{https://github.com/liferay/liferay-portal/blob/7.0.x/modules/apps/web-experience/journal/journal-web/src/main/resources/META-INF/resources/edit_feed.jsp\#L40}{the
Web Content app's \texttt{edit\_feed.jsp}} uses this method to get the
site ID needed to retrieve Structures:

\begin{verbatim}
...

ddmStructure = DDMStructureLocalServiceUtil.fetchStructure(themeDisplay.getSiteGroupId(), 
    PortalUtil.getClassNameId(JournalArticle.class), ddmStructureKey, true);

...
\end{verbatim}

Great! Now you know how to scope your apps, access their scope, and even
get the site scope of entities that belong to other apps. Now that's
minty-fresh breath!

\subsection{Related Topics}\label{related-topics-131}

\href{/docs/7-0/user/-/knowledge_base/u/application-scope}{Application
Scope}

\href{/docs/7-0/tutorials/-/knowledge_base/t/what-is-service-builder}{What
is Service Builder?}

\href{/docs/7-0/tutorials/-/knowledge_base/t/service-builder-persistence}{Service
Builder Persistence}

\href{/docs/7-0/tutorials/-/knowledge_base/t/business-logic-with-service-builder}{Business
Logic with Service Builder}

\chapter{Web Services}\label{web-services}

Generating and invoking web services is a central part of the Liferay
development experience. After all, what good is it if you can't generate
remote services for an app you're developing, or call Liferay's built-in
remote services? It's no good at all! Liferay without web services would
be like a luxury car without wheels. Fortunately, Liferay comes with
full set of JSON and SOAP web services that you can invoke until your
heart's content. Liferay also provides Service Builder to generate local
and remote services for your apps.

The tutorials that follow show you how to work with web services in
Liferay. You'll learn how to use Service Builder to generate remote
services for your apps. You'll also learn how to invoke those services,
and any other Liferay web services.

\chapter{Service Builder Web
Services}\label{service-builder-web-services}

Liferay's Service Builder can generate local and remote services for
your Liferay apps.
\href{/docs/7-0/tutorials/-/knowledge_base/t/what-is-service-builder}{The
section of tutorials on Service Builder} gives a general introduction to
Service Builder, as well as instructions on generating your app's local
services. But what if you want to use Service Builder to generate your
app's remote services? And how should you invoke remote services
generated by Service Builder? No sweat! That's exactly what the
tutorials here cover. This section shows you how to use Service Builder
to create JSON and SOAP web services, and how to invoke those services.
Because Liferay's own developers use Service Builder to generate JSON
and SOAP web services, knowing how to invoke these services is
especially important. This section includes the following tutorials:

\begin{itemize}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/creating-remote-services}{Creating
  Remote Services}: Use Service Builder to generate your app's JSON and
  SOAP web services.
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/invoking-remote-services}{Invoking
  Remote Services}: Learn the basics of invoking JSON and SOAP web
  services in Liferay.
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/service-security-layers}{Service
  Security Layers}: Learn how Liferay secures web services, and how to
  invoke them with proper authentication.
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/registering-json-web-services}{Registering
  JSON Web Services}: Learn some of the details behind how Service
  Builder generates JSON web services, and how you can tailor this
  process to your needs.
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/invoking-json-web-services}{Invoking
  JSON Web Services}: Learn how to invoke Liferay's JSON web services
  API via URL. This includes information on passing URL parameters,
  troubleshooting, and more.
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/json-web-services-invoker}{JSON
  Web Services Invoker}: Learn how to use Liferay's JSON Web Services
  Invoker to optimize your JSON web service calls.
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/json-web-services-invocation-examples}{JSON
  Web Services Invocation Examples}: See examples of how to invoke
  Liferay's JSON web services via JavaScript, URL, and cURL.
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/portal-configuration-of-json-web-services}{Configuring
  JSON Web Services}: Learn which properties you can use to control how
  JSON web services behave in your Liferay instance.
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/soap-web-services}{SOAP
  Web Services}: Learn how SOAP web services work in Liferay.
\end{itemize}

\section{Creating Remote Services}\label{creating-remote-services}

Many default Liferay DXP services are available as web services.
Liferay DXP exposes its web services via JSON and SOAP web services. If
you're running the portal locally on port 8080, visit the following URL
to browse Liferay DXP's default JSON web services:

\begin{verbatim}
http://localhost:8080/api/jsonws/
\end{verbatim}

To browse Liferay DXP's default SOAP web services, visit this URL:

\begin{verbatim}
http://localhost:8080/api/axis
\end{verbatim}

These web services APIs can be accessed by many different kinds of
clients, including non-portlet and even non-Java clients. You can use
Service Builder to generate similar remote services for your projects'
custom entities. When you run Service Builder with the
\texttt{remote-service} attribute set to \texttt{true} for an entity,
all the classes, interfaces, and files required to support both SOAP and
JSON web services are generated for that entity. Service Builder
generates methods that call existing services, but it's up to you to
implement the methods that are exposed remotely. In this tutorial,
you'll learn how to generate remote services for your application. When
you're done, your application's remote service methods can be called
remotely via JSON and SOAP web services.

\subsection{Using Service Builder to Generate Remote
Services}\label{using-service-builder-to-generate-remote-services}

Remember that you should implement your application's local service
methods in \texttt{*LocalServiceImpl}. You should implement your
application's remote service methods in \texttt{*ServiceImpl}.

\noindent\hrulefill

\textbf{Best Practice:} If your application needs both local and remote
services, determine the service methods that your application needs for
working with your entity model. Add these service methods to
\texttt{*LocalServiceImpl}. Then create corresponding remote services
methods in \texttt{*ServiceImpl}. Add permission checks to the remote
service methods and make the remote service methods invoke the local
service methods. The remote service methods can have the same names as
the local service methods that they call. Within your application, only
call the remote services. This ensures that your service methods are
secured and that you don't have to duplicate permissions code.

\noindent\hrulefill

As an example, consider Liferay DXP's Blogs app. Articles are
represented by the \texttt{JournalArticle} entity. This entity is
declared in the \texttt{journal-service} module's
\href{https://github.com/liferay/liferay-portal/blob/7.0.6-ga7/modules/apps/web-experience/journal/journal-service/service.xml}{\texttt{service.xml}
file} with the \texttt{remote-service} attribute set to \texttt{true}.
Service Builder therefore generates
\href{https://github.com/liferay/liferay-portal/blob/7.0.6-ga7/modules/apps/web-experience/journal/journal-service/src/main/java/com/liferay/journal/service/impl/JournalArticleServiceImpl.java}{the
remote service class \texttt{JournalArticleServiceImpl}} to hold the
remote service method implementations. If you were developing this app
from scratch, this class would initially be empty; you must use it to
implement the entity's remote service methods. Also, note that the
remote service method implementations in
\texttt{JournalArticleServiceImpl} follow best practice by checking
permissions and calling the corresponding local service method. For
example, each \texttt{addArticle} method in
\texttt{JournalArticleServiceImpl} checks permissions via
\href{https://github.com/liferay/liferay-portal/blob/7.0.6-ga7/modules/apps/web-experience/journal/journal-service/src/main/java/com/liferay/journal/service/permission/JournalFolderPermission.java}{the
custom permissions class \texttt{JournalFolderPermission}} and then
calls the local service's matching \texttt{addArticle} method:

\begin{verbatim}
@Override
public JournalArticle addArticle(...)
    throws PortalException {

    JournalFolderPermission.check(
        getPermissionChecker(), groupId, folderId, ActionKeys.ADD_ARTICLE);

    return journalArticleLocalService.addArticle(...);
}
\end{verbatim}

You'll also need to develop custom permissions classes for each entity
you need to perform permissions checks on. Also note that the local
service is called via the \texttt{journalArticleLocalService} field.
This is a Spring bean of type \texttt{JournalArticleLocalServiceImpl}
that's injected into \texttt{JournalArticleServiceImpl} by Service
Builder. See
\href{https://github.com/liferay/liferay-portal/blob/7.0.6-ga7/modules/apps/web-experience/journal/journal-service/src/main/java/com/liferay/journal/service/base/JournalArticleServiceBaseImpl.java}{the
class \texttt{JournalArticleServiceBaseImpl}} for a complete list of
Spring beans available in \texttt{JournalArticleServiceImpl}.

After you've finished adding remote service methods to your
\texttt{*ServiceImpl} class, save it and run Service Builder again.
After running Service Builder, deploy your project and check the Liferay
DXP JSON web services URL \url{http://localhost:8080/api/jsonws/} to
make sure that your remote services appear when you select your
application's context path.

Nice work! You've successfully used Service Builder to generate your
app's remote services. To make these services available via SOAP,
however, you must build and deploy your app's Web Service Deployment
Descriptor (WSDD). The next section shows you how to do this. If you
don't need to generate SOAP web services, you can move on to the
tutorial
\href{/docs/7-0/tutorials/-/knowledge_base/t/invoking-remote-services}{Invoking
Remote Services}.

\subsection{Generating Your App's WSDD}\label{generating-your-apps-wsdd}

Liferay DXP uses Apache Axis to make SOAP web services available. Since
Axis requires a WSDD to make an app's remote services available via
SOAP, you must build and deploy a WSDD for your app. To create your
WSDD, you must install Liferay's WSDD Builder Gradle plugin in your
app's project. How you do this, however, depends on what kind of project
you have. For multi-module projects like a Service Builder project in a
Liferay Workspace, you'll install the plugin via the workspace's
\texttt{settings.gradle} file. This applies the WSDD Builder plugin to
every module in the workspace that uses Service Builder (typically the
\texttt{*-api} and \texttt{*-service} modules). If you have a standalone
\texttt{*-service} module that uses Service Builder, however, you'll
install the WSDD Builder plugin in the module's \texttt{build.gradle}
file.

The next section shows you how to install the WSDD builder in a
multi-module project. If you have a standalone module project, skip
ahead to the section \emph{Installing the WSDD Builder Plugin in a
Standalone Module Project}.

\subsubsection{Installing the WSDD Builder Plugin in a Multi-module
Project}\label{installing-the-wsdd-builder-plugin-in-a-multi-module-project}

To install the WSDD Builder plugin in a multi-module project like a
Service Builder project in a Liferay Workspace, do the following in the
workspace's \texttt{settings.gradle} file:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add the \texttt{ServiceBuilderPlugin} and \texttt{WSDDBuilderPlugin}
  imports to the top of the file:

\begin{verbatim}
 import com.liferay.gradle.plugins.service.builder.ServiceBuilderPlugin
 import com.liferay.gradle.plugins.wsdd.builder.WSDDBuilderPlugin
\end{verbatim}
\item
  In the \texttt{repositories} block, add the Liferay CDN repository via
  Maven:

\begin{verbatim}
 repositories {
     maven {
         url "https://repository-cdn.liferay.com/nexus/content/groups/public"
     }
 }
\end{verbatim}

  This repository hosts the WSDD Builder library, its transitive
  dependencies, and other Liferay libraries. Note that if you created
  your Service Builder project with the \texttt{service-builder}
  template in Blade CLI or Liferay @ide@, then your
  \texttt{settings.gradle} file should already contain this.
\item
  Add this code to the end of the file:

\begin{verbatim}
 gradle.beforeProject {
     project ->

     project.plugins.withType(ServiceBuilderPlugin) {
         project.apply plugin: WSDDBuilderPlugin
     }
 }
\end{verbatim}

  This is the code that applies the WSDD Builder plugin in every module
  in the Liferay Workspace that uses Service Builder. Your
  \texttt{settings.gradle} file should now look something like this:

\begin{verbatim}
 import com.liferay.gradle.plugins.service.builder.ServiceBuilderPlugin
 import com.liferay.gradle.plugins.wsdd.builder.WSDDBuilderPlugin

 buildscript {
     dependencies {
         classpath group: "com.liferay", name: "com.liferay.gradle.plugins.workspace", version: "1.2.0"
     }

     repositories {
         maven {
             url "https://repository-cdn.liferay.com/nexus/content/groups/public"
         }
     }
 }

 apply plugin: "com.liferay.workspace"

 gradle.beforeProject {
     project ->

     project.plugins.withType(ServiceBuilderPlugin) {
         project.apply plugin: WSDDBuilderPlugin
     }
 }
\end{verbatim}
\item
  Refresh the Liferay Workspace's Gradle project. Close and restart
  Liferay @ide@ if you're using it.
\end{enumerate}

Now that you've installed the WSDD Builder plugin, you're ready to build
and deploy the WSDD. For instructions on this, proceed to the section
\emph{Building and Deploying the WSDD}.

\subsubsection{Installing the WSDD Builder Plugin in a Standalone Module
Project}\label{installing-the-wsdd-builder-plugin-in-a-standalone-module-project}

To install the WSDD Builder plugin in a standalone \texttt{*-service}
module that uses Service Builder, do the following in the module's
\texttt{build.gradle} file:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Add the plugin as a dependency in your \texttt{buildscript}.
\item
  Add the Liferay CDN repository via Maven.
\item
  Apply the plugin to your project.
\end{enumerate}

For example, the following part of an example \texttt{build.gradle} file
in a standalone \texttt{*-service} module includes the WSDD Builder
plugin and applies it to the project:

\begin{verbatim}
buildscript {
    dependencies {
        classpath group: "com.liferay", name: "com.liferay.gradle.plugins.wsdd.builder", version: "1.0.9"
    }

    repositories {
        maven {
            url "https://repository-cdn.liferay.com/nexus/content/groups/public"
        }
    }
}

apply plugin: "com.liferay.portal.tools.wsdd.builder"
\end{verbatim}

Now you're ready to build and deploy the WSDD. The next section shows
you how to do this.

\subsection{Building and Deploying the
WSDD}\label{building-and-deploying-the-wsdd}

To build the WSDD, you must run the \texttt{buildWSDD} Gradle task in
your \texttt{*-service} module. Exactly how you do this depends on your
development tools:

\begin{itemize}
\tightlist
\item
  \textbf{Liferay @ide@:} From the Liferay Workspace perspective's
  \emph{Gradle Tasks} pane (typically on the right), open your
  \texttt{*-service} module's \emph{build} folder and double-click
  \emph{buildWSDD}.
\item
  \textbf{Command Line:} Navigate to your \texttt{*-service} module and
  run \texttt{../../../gradlew\ buildWSDD}. Note that the exact location
  of the Gradle wrapper (\texttt{gradlew}) may vary. For Liferay
  Workspace projects, it's typically in the root workspace folder.
\end{itemize}

So what should you do if \texttt{buildWSDD} fails? A common cause of
\texttt{buildWSDD} failures is failing to satisfy the dependencies
needed by the WSDD Builder for your \texttt{*-service} module. Note that
these dependencies vary depending on your project's code--there's no
standard set. That said, the following are often required for portlet
development:

\begin{verbatim}
compileOnly group: "javax.portlet", name: "portlet-api", version: "2.0"
compileOnly group: "javax.servlet", name: "javax.servlet-api", version: "3.0.1"
compileOnly group: "com.liferay", name: "com.liferay.registry.api", version: "1.0.0"
\end{verbatim}

\href{/docs/7-0/tutorials/-/knowledge_base/t/configuring-dependencies}{Click
here} for more information on finding and configuring dependencies for
your apps.

In your \texttt{*-service} project's \texttt{build/libs} folder, the
\texttt{buildWSDD} task generated a
\texttt{*-service-wsdd-{[}version{]}.jar} file that contains your WSDD.
Deploy this JAR to your Liferay DXP instance. Your SOAP web services are
then available at a URL that uses the following pattern:

\begin{verbatim}
yourportaladdress/o/your.apps.service.module.context/api/axis
\end{verbatim}

For example, if an app called \emph{Foo} consists of the modules
\texttt{foo-api}, \texttt{foo-service}, and \texttt{foo-web}, then the
app's service module context is \texttt{foo-service}. If this app is
deployed to a local Liferay DXP instance running at
\texttt{http://localhost:8080}, you could access its SOAP services at:

\begin{verbatim}
http://localhost:8080/o/foo-service/api/axis
\end{verbatim}

If you don't know an app's \texttt{*-service} module context, you can
find it by searching for the app in the App Manager of the Liferay DXP
instance in which the app is running. For example, the following
screenshot shows the Foo app's modules in the App Manager. The name of
the \texttt{*-service} module in the App Manager, \texttt{foo-service},
is also its context. Also note that the app's WSDD module is grayed out
and listed as Resolved instead of Active. This is normal. WSDD modules
are OSGi fragments, which can't be activated. They still work as
intended, though.

\begin{figure}
\centering
\includegraphics{./images/app-manager-remote-services.png}
\caption{To find your app's modules, including its WSDD module, search
for your app in the App Manager. The \texttt{*-service} module's name in
the App Manager is also the module's context.}
\end{figure}

Next, you'll learn how to build the WSDD module for Liferay DXP's
built-in apps that don't include a WSDD by default. If you don't need to
do this, you can move on to the tutorial
\href{/docs/7-0/tutorials/-/knowledge_base/t/invoking-remote-services}{Invoking
Remote Services}.

\subsection{Building the WSDD for Built-in Liferay DXP
Apps}\label{building-the-wsdd-for-built-in-liferay-dxp-apps}

Liferay DXP doesn't provide WSDD modules for built-in apps that exist
outside of the portal context. This means that by default you can't
access SOAP web services for apps like Bookmarks or Blogs. To make SOAP
web services available for such an app, you must build and deploy its
WSDD from the
\href{https://github.com/liferay/liferay-portal}{\texttt{liferay-portal}
GitHub repository}. The apps are in the
\texttt{liferay-portal/modules/apps} folder. Note that to build WSDDs
for these apps, you must first download the \texttt{liferay-portal}
source code to your machine. You'll run the WSDD build from your local
\texttt{liferay-portal} copy.

When you build an app's WSDD, make sure to use \texttt{gradlew} in
\texttt{liferay-portal} instead of the \texttt{gradle} on your machine.
After building, you can find the WSDD JAR in the \texttt{tools/sdk/dist}
folder of your local \texttt{liferay-portal} copy. Otherwise, building
an app's WSDD is the same as in the preceding section.

For example, to build the WSDD for the Bookmarks app, first navigate to
the
\texttt{liferay-portal/modules/apps/collaboration/bookmarks/bookmarks-service}
folder in your terminal. Then run the following command:

\begin{verbatim}
../../../../../gradlew buildWSDD
\end{verbatim}

Next, deploy the
\texttt{liferay-portal/tools/sdk/dist/com.liferay.bookmarks.service-wsdd-{[}version{]}.jar}
to your Liferay DXP instance. If your instance is running locally on
\texttt{localhost:8080}, you should then be able to view the Bookmarks
app's SOAP services at
\url{http://localhost:8080/o/com.liferay.bookmarks.service/api/axis}.

Fantastic! Once you've created remote web services, you'll want to know
how to invoke them. To learn how, see the tutorial
\href{/docs/7-0/tutorials/-/knowledge_base/t/invoking-remote-services}{Invoking
Remote Services}.

\subsection{Related Topics}\label{related-topics-132}

\href{/docs/7-0/tutorials/-/knowledge_base/t/invoking-remote-services}{Invoking
Remote Services}

\href{/docs/7-0/tutorials/-/knowledge_base/t/invoking-json-web-services}{Invoking
JSON Web Services}

\href{/docs/7-0/tutorials/-/knowledge_base/t/json-web-services-invoker}{JSON
Web Services Invoker}

\href{/docs/7-0/tutorials/-/knowledge_base/t/json-web-services-invocation-examples}{JSON
Web Services Invocation Examples}

\href{/docs/7-0/tutorials/-/knowledge_base/t/what-is-service-builder}{What
is Service Builder?}

\section{Invoking Remote Services}\label{invoking-remote-services}

You can invoke the remote services of any installed Liferay application
the same way that you invoke your local services. Doing so could be
described as ``invoking remote services locally.'' One reason to invoke
a remote service instead of the corresponding local service might be to
take advantage of the remote service's permission checks. Consider the
following common scenario:

\begin{itemize}
\tightlist
\item
  Both a local service implementation and a remote service
  implementation have been created for a particular service.
\item
  The remote service performs a permission check and then invokes the
  corresponding local service.
\end{itemize}

In the above scenario, it's a best practice to invoke the remote service
instead of the local service. Doing so ensures that you don't need to
duplicate permission checking code. This is the practice followed by the
services in
\href{https://github.com/liferay/liferay-portal/tree/master/modules/apps/web-experience/journal/journal-service/src/main/java/com/liferay/journal/service/impl}{Liferay's
Blogs app}.

Of course, the main reason for creating remote services is to invoke
them remotely. Service Builder can expose your project's remote web
services both via a JSON API and via SOAP. By default, running Service
Builder with \texttt{remote-service} set to \texttt{true} for your
entities generates a JSON web services API for your project. You can
access your project's JSON-based RESTful services via a convenient web
interface.

\subsection{Invoking Liferay Services
Remotely}\label{invoking-liferay-services-remotely}

Many default Liferay services are available as web services. Liferay
exposes its web services via SOAP and JSON web services. If you're
running Liferay locally on port 8080, visit the following URL to browse
Liferay's default SOAP web services:

\begin{verbatim}
http://localhost:8080/api/axis
\end{verbatim}

To browse Liferay's default JSON web services, visit this URL:

\begin{verbatim}
http://localhost:8080/api/jsonws/
\end{verbatim}

By default, the context path is set to \texttt{/} which means that core
Liferay services are listed. By default, the
\emph{http://localhost:8080/api/jsonws/} page shows the JSON web
services in the \texttt{portal} context. You can select a different
context in the \emph{Context Name} selector menu. For example, selecting
\texttt{journal} in \emph{Context Name} shows you the JSON web services
in Liferay's Web Content app (this app's entities all begin with
\texttt{Journal*}). You can also access a context's JSON web services
via a direct URL. For example, the URL for the Web Content app's JSON
web services is
\url{http://localhost:8080/api/jsonws?contextName=journal}.

\noindent\hrulefill

\textbf{Important:} To invoke Liferay services remotely, your Liferay
instance must be configured to allow remote web service access. Please
see the
\href{/docs/7-0/tutorials/-/knowledge_base/t/service-security-layers}{Understanding
Liferay's Service Security Model} tutorial for details.

\noindent\hrulefill

Each entity's available service methods are listed in the left column of
the JSON web services page. To view details about a service method,
click it. The full package path to the service's \texttt{*Impl} class is
displayed along with the method's parameters, return type, and possible
exceptions. You can also invoke the service from this page. For example,
in the \texttt{portal} context click the \texttt{AnnouncementsEntry}
entity's \texttt{get-entry} method. This brings up that service method's
details page, where you can also invoke the service:

\begin{figure}
\centering
\includegraphics{./images/jsonws-details.png}
\caption{The JSON web services page for an entity's remote service
method also lets you invoke that service.}
\end{figure}

The only parameter required to invoke the \texttt{get-entry} method is
an \texttt{entryId}. To invoke this web service, you could enter an
announcement entry's ID in the \texttt{entryId} field and then click
\emph{Invoke}. Liferay returns feedback from each invocation that
indicates, for example, whether the service invocation succeeded or
failed. Invoking remote services in this manner is a great way to test
your app's remote services.

Service Builder can also make your project's web services available via
SOAP using Apache Axis. After you've built your \texttt{*-service}
project's WSDD (web service deployment descriptor) and deployed your
project's modules, its services are available on your Liferay server.
You can view your Liferay instance's and app's SOAP services in a
browser as described in the tutorial
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-remote-services}{Creating
Remote Services}.

When viewing your SOAP services in a browser, Liferay lists the services
available for all your entities and provides links to their WSDL
documents. For example, clicking on the WSDL link for the User service
takes you to the following URL:

\begin{verbatim}
http://localhost:8080/api/axis/Portal_UserService?wsdl
\end{verbatim}

This WSDL document lists the entity's SOAP web services. Once the web
service's WSDL is available, any SOAP web service client can access it.
To see examples of SOAP web service client implementations, see the
tutorial
\href{/docs/7-0/tutorials/-/knowledge_base/t/soap-web-services}{SOAP Web
Services}.

Liferay web services are designed to be invoked by client applications.
Liferay's web services APIs can be accessed by many different kinds of
clients, including non-portlet and even non-Java clients. For
information on how to develop client applications that can access
Liferay's JSON web services, please see the
\href{/docs/7-0/tutorials/-/knowledge_base/t/invoking-json-web-services}{Invoking
JSON Web Services} tutorial. For information on how to develop client
applications that access Liferay's SOAP web services, please see the
\href{/docs/7-0/tutorials/-/knowledge_base/t/soap-web-services}{SOAP Web
Services} tutorial. To learn how to create remote web services for your
own application, please refer to the
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-remote-services}{Creating
Remote Services} tutorial.

For more information on Liferay services, see the Liferay Portal CE
Javadocs at
\href{@platform-ref@/7.0-latest/javadocs/}{@platform-ref@/7.0-latest/javadocs/}.

\subsection{Related Topics}\label{related-topics-133}

\href{/docs/7-0/tutorials/-/knowledge_base/t/invoking-json-web-services}{Invoking
JSON Web Services}

\href{/docs/7-0/tutorials/-/knowledge_base/t/json-web-services-invoker}{JSON
Web Services Invoker}

\href{/docs/7-0/tutorials/-/knowledge_base/t/json-web-services-invocation-examples}{JSON
Web Services Invocation Examples}

\href{/docs/7-0/tutorials/-/knowledge_base/t/soap-web-services}{SOAP Web
Services}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-remote-services}{Creating
Remote Services}

\section{Service Security Layers}\label{service-security-layers}

Liferay's remote services are secured by default. They sit behind a
layer of security that allows only local connections. To invoke Liferay
services from a remote client, you must take deliberate steps to enable
such access. Liferay's core web services require user authentication and
verification. Regardless of whether you call the remote service from the
same machine or via a web service, Liferay's standard security model
performs its function. The user invoking a web service must have the
proper permissions (as defined by Liferay's permissions system) for the
remote service invocation to complete successfully. This tutorial
explains these processes.

The first layer of security that a client encounters when calling a
remote service is called \emph{invoker IP filtering}. Imagine that you
have have a batch job that runs on another machine in your network. This
job polls a shared folder on your network and uses Liferay's web
services to upload documents to your Liferay site's \emph{Documents and
Media} app on a regular basis. To get your batch job through the IP
filter, you must grant web service access to the machine the batch job
is running on. For example, if your batch job uses Liferay's SOAP web
services to upload the documents, you must add the IP address of the
machine where the batch job runs to the
\texttt{axis.servlet.hosts.allowed} property. A typical entry might look
like this:

\begin{verbatim}
axis.servlet.hosts.allowed=192.168.100.100, 127.0.0.1, [SERVER_IP]
\end{verbatim}

If the IP address of the machine where the batch job runs is listed as
an authorized host for the service, the machine is allowed to connect to
Liferay's web services, pass in the appropriate user credentials, and
upload the documents.

\noindent\hrulefill

\textbf{Note:} The \texttt{portal.properties} file resides on the
Liferay instance's host machine and is controlled by the instance
administrator. Instance administrators can configure security settings
for the Axis Servlet, the Liferay Tunnel Servlet, the Spring Remoting
Servlet, the JSON Servlet, the JSON Web Service Servlet, and the WebDAV
Servlet. The \texttt{portal.properties} file (online version is
available at
\href{@platform-ref@/7.0-latest/propertiesdoc/portal.properties.html}{@platform-ref@/7.0-latest/propertiesdoc/portal.properties.html})
describes these properties.

\noindent\hrulefill

Next, if you invoke the remote service via web services (e.g., JSON WS,
old JSON, Axis, REST, etc.), a two step process of authentication and
authentication verification takes place. Each call to a Liferay web
service must be accompanied by a user authentication token:
\texttt{p\_auth}. It's up to the web service caller to produce the token
(e.g., through Liferay's utilities or through some third-party
software). Liferay verifies that there is a Liferay user matching the
token. If the credentials are invalid, the web service invocation is
aborted. Otherwise, processing enters Liferay's user permission layer.

Liferay's user permission layer is the last Liferay security layer
triggered when services are invoked remotely. It's used for every object
in the Liferay instance, regardless of whether a local or remote service
is involved. The user ID associated with a web service invocation must
possess the proper permission to operate on the objects it's trying to
access. A remote exception is thrown if the user ID doesn't possess the
required permissions. An instance administrator can grant users access
to these resources. For example, suppose you created a Documents and
Media Library folder called \emph{Documents} in a site, created a role
called \emph{Document Uploaders}, and granted this role the rights to
add documents to your new folder. If your batch job accesses Liferay's
web services to upload documents into the folder, you must call the web
service using a user ID of a member of this role (or using the user ID
of a user with individual rights to add documents to this folder, such
as an instance administrator). If you don't, Liferay denies you access
to the web service.

When invoking remote Liferay services from a non-browser client, you can
specify the user credentials using HTTP basic authentication. For
security reasons, you must be logged in and supply a valid
\texttt{p\_auth} authentication token to invoke a Liferay web service
via a browser. Since you should never pass credentials over the network
unencrypted, we recommend using HTTPS whenever accessing Liferay
services on an untrusted network. Most HTTP clients (e.g.,
\href{http://curl.haxx.se/}{cURL}) let you specify the basic
authentication credentials in the URL--this is very handy for testing.

\noindent\hrulefill

\textbf{Important:} To invoke a Liferay web service via your browser,
you must be logged in to Liferay. You must also supply an authentication
token (the \texttt{p\_auth} parameter). If you navigate to your Liferay
instance's JSON web services API page ( \url{localhost:8080/api/jsonws},
by default) and click on a remote service method, you'll see the
\texttt{p\_auth} token for your browser session. This token is
automatically supplied when you invoke a Liferay web service via the
JSON web services API page or via JavaScript using
\texttt{Liferay.Service(...)}.

\noindent\hrulefill

Use the following syntax to call the Axis web service using credentials.

\begin{verbatim}
http://" + emailAddressOrScreenNameOrUserIdAsString + ":" + password + "@[server.com]:\
[port]/api/axis/" + serviceName
\end{verbatim}

The \texttt{emailAddressOrScreenNameOrUserIdAsString} should be the
user's email address, screen name, or user ID. The Liferay instance's
authentication type setting determines which one to use. A user can find
his or her ID by logging in as the user and accessing \emph{My Account}
→ \emph{Account Settings} from the User Menu. On this interface, the
user ID appears below the user's profile picture and above the birthday
field.

Suppose that your Liferay instance is set to authenticate by user ID,
and that there's a user with an ID of \texttt{2} and a password of
\texttt{test}. You can access Liferay's remote Organization service with
the following URL:

\begin{verbatim}
http://2:test@localhost:8080/api/axis/Portal_OrganizationService
\end{verbatim}

Note that if an email address appears in the URL path, it must be
URL-encoded (e.g.~\texttt{test@example.com} becomes
\texttt{test\%40liferay.com}).

Suppose that your Liferay instance is now set to authenticate by email
address. To call the same web service for the same user, change the URL
to this:

\begin{verbatim}
http://test%40liferay.com:test@localhost:8080/api/axis/Portal_OrganizationService
\end{verbatim}

As mentioned, the authentication type specified for your Liferay
instance dictates the authentication type you'll use to access your web
service. The instance administrator can set the instance's
authentication type to email address, screen name, or user ID.

You can set the authentication type via the Control Panel or via the
\texttt{portal-ext.properties} file. To set the authentication type via
the Control Panel, navigate to \emph{Control Panel} →
\emph{Configuration} → \emph{Instance Settings}, and select the
\emph{General} tab under \emph{Authentication}. Choose your
authentication type in the \emph{How do users authenticate?} menu. To
set the authentication type via properties file, add the following lines
to your Liferay instance's \texttt{portal-ext.properties} file and
uncomment the line for the appropriate authentication type:

\begin{verbatim}
#company.security.auth.type=emailAddress
#company.security.auth.type=screenName
#company.security.auth.type=userId
\end{verbatim}

You should also review your Liferay instance's password policies, since
they'll be enforced on your administrative user as well. If the instance
enforces password policies on its users (e.g., requires them to change
their passwords on a periodic basis), an administrative user accessing
Liferay's web services in a batch job will have his or her password
expire too.

To prevent a password from expiring, an instance administrator can add a
new password policy that doesn't enforce password expiration, and then
add a specific administrative user to the policy. Then your batch job
can run as many times as you need it to, without your administrative
user's password expiring.

To summarize, accessing Liferay remotely requires you to pass the
following layers of security checks:

\begin{itemize}
\tightlist
\item
  \emph{IP permission layer}: The IP address must be pre-configured in
  the server's portal properties.
\item
  \emph{Authentication/verification layer (web services only)}: Liferay
  verifies that the caller's authorization token can be associated with
  an instance user.\\
\item
  \emph{User permission layer}: The user needs permission to access the
  related resources.
\end{itemize}

If you'd like to develop client applications that can invoke Liferay's
web services, make sure that your Liferay instance's web service
security settings have been configured to allow access.

\textbf{Related Topics}

\href{/docs/7-0/tutorials/-/knowledge_base/t/portal-configuration-of-json-web-services}{Configuring
JSON Web Services}

\href{/docs/7-0/tutorials/-/knowledge_base/t/invoking-remote-services}{Invoking
Remote Services}

\href{/docs/7-0/tutorials/-/knowledge_base/t/invoking-json-web-services}{Invoking
JSON Web Services}

\href{/docs/7-0/tutorials/-/knowledge_base/t/json-web-services-invoker}{JSON
Web Services Invoker}

\href{/docs/7-0/tutorials/-/knowledge_base/t/json-web-services-invocation-examples}{JSON
Web Services Invocation Examples}

\href{/docs/7-0/tutorials/-/knowledge_base/t/soap-web-services}{SOAP Web
Services}

\section{Registering JSON Web
Services}\label{registering-json-web-services}

Liferay's developers use a tool called \emph{Service Builder} to build
services. When you build services with Service Builder, all
remote-enabled services (i.e., \texttt{service.xml} entities with the
property \texttt{remote-service="true"}) are exposed as JSON web
services. When each \texttt{*Service.java} interface is created for a
remote-enabled service, the \texttt{@JSONWebService} annotation is added
to that interface at the class level. All of the public methods of that
interface become registered and available as JSON web services.

The \texttt{*Service.java} interface source file should never be
modified by the user. If you need more control over its methods (e.g.,
if you need to hide some methods while exposing others), you can
configure the \texttt{*ServiceImpl} class. When the service
implementation class (\texttt{*ServiceImpl}) is annotated with the
\texttt{@JSONWebService} annotation, the service interface is ignored
and the service implementation class is used for configuration in its
place. In other words, \texttt{@JSONWebService} annotations in the
service implementation override any JSON web service configuration in
the service interface.

That's it! Liferay scans all OSGi bundles registered with the
\texttt{@Component} annotation or in a \texttt{*BundleActivator} class
for remote services. Each class that uses the \texttt{@JSONWebService}
annotation is examined and its methods become exposed via the JSON web
services API. As explained previously, the \texttt{*ServiceImpl}
configuration overrides the \texttt{*Service} interface configuration
during registration.

\noindent\hrulefill

\textbf{Note:} Liferay's developers use \emph{Service Builder} to expose
their services via JSON automatically. If you haven't used Service
Builder before, please see the
\href{/docs/7-0/tutorials/-/knowledge_base/t/what-is-service-builder}{Service
Builder section of tutorials}.

\noindent\hrulefill

Next, you'll see how you can register your application's remote services
as JSON web services. Keep in mind that Liferay uses this same
mechanism. This is why Liferay's remote services are exposed as JSON web
services out-of-the-box.

\subsection{Registering an App's JSON Web
Services}\label{registering-an-apps-json-web-services}

As an example, say you have an app named \texttt{SupraSurf} that has
some services, and you decide to expose them as remote services. After
enabling the \texttt{remote-service} attribute on its \texttt{SurfBoard}
entity, you rebuild the services. Service Builder regenerates the
\texttt{SurfBoardService} interface, adding the \texttt{@JSONWebService}
annotation to it. This annotation tells Liferay that the interface's
public methods are to be exposed as JSON web services, making them a
part of the app's JSON API. Start up your Liferay instance if it isn't
running, and then deploy your app to Liferay.

To get some feedback from your Liferay instance on registering your
application's services, configure the instance to log the application's
informational messages (i.e., its \texttt{INFO\ ...} messages). See the
tutorials on Liferay's logging system for details.

To test Liferay's JSON web service registration process, add a simple
method to your app's services. Edit your \texttt{*ServiceImpl} class and
add the following method:

\begin{verbatim}
public String helloWorld(String worldName) {
    return "Hello world: " + worldName;
}
\end{verbatim}

Rebuild the services and re-deploy your app's modules. You can now
invoke this service method via JSON. For instructions on doing this, see
the JSON invocation tutorials listed in
\href{/docs/7-0/tutorials/-/knowledge_base/t/service-builder-web-services}{this
section of tutorials}.

This same mechanism registers Liferay's own services. They're
conveniently enabled by default, so you don't have to configure them.

Next, you'll learn how to form a mapped URL for the remote service so
you can access it.

\subsection{Mapping and Naming
Conventions}\label{mapping-and-naming-conventions}

You can form the mapped URL of an exposed service by following the
naming convention below:

\begin{verbatim}
http://[server]:[port]/api/jsonws/[context-path].[service-class-name]/[service-method-name]
\end{verbatim}

Look at the last three bracketed items more closely:

\begin{itemize}
\item
  \texttt{context-name} is the app's context name (e.g.,
  \texttt{suprasurf} in the previous example). Its value is specified
  via the \texttt{json.web.service.context.path} property in the
  \texttt{@OSGiBeanProperties} annotation. For example, for Liferay web
  content articles, Liferay's \texttt{JournalArticleService} class
  includes the following annotation (among others):

\begin{verbatim}
  @OSGiBeanProperties(property =  {
      "json.web.service.context.name=journal", "json.web.service.context.path=JournalArticle"}, service = JournalArticleService.class)
\end{verbatim}
\item
  \texttt{service-class-name} is generated from the service's class name
  in lower case, minus its \texttt{Service} or \texttt{ServiceImpl}
  suffix. For example, specify \texttt{surfboard} as the
  \texttt{app-context-name} for the \texttt{SurfBoardService} class.
\item
  \texttt{service-method-name} is generated from the service's method
  name by converting its camel case to lower case and using dashes
  (\texttt{-}) to separate words.
\end{itemize}

The following example demonstrates these naming conventions by mapping a
service method's URL using the naming conventions both on a custom
service and on a Liferay service.

For the custom service method, the URL looks like:

\begin{verbatim}
http://localhost:8080/api/jsonws/suprasurf.surfboard/hello-world
\end{verbatim}

Note the context name part of the URL. For Liferay, it's similar. Here's
a Liferay service method:

\begin{verbatim}
@JSONWebService
public interface UserService {
    public com.liferay.portal.model.User getUserById(long userId) {...}
\end{verbatim}

Here's that Liferay service method's URL:

\begin{verbatim}
http://localhost:8080/api/jsonws/user/get-user-by-id
\end{verbatim}

Each service method is bound to one HTTP method type. Any method with a
name starting with \texttt{get}, \texttt{is}, or \texttt{has} is assumed
to be a read-only method and is mapped as a \emph{GET HTTP} method by
default. All other methods are mapped as \emph{POST HTTP} methods.

Recall that you can see a list of your Liferay instance's JSON web
services at \url{http://localhost:8080/api/jsonws}. When you select a
method on this page, the part of its HTTP method URL that follows
\texttt{http://{[}server{]}:{[}port{]}/api/jsonws} is listed at the top
of the screen.

Conveniently, remote service requests can leverage the authentication
credentials associated with the user's current Liferay session. Next,
you'll learn how to prevent a method from being exposed as a service.

\subsection{Ignoring a Method}\label{ignoring-a-method}

To keep a method from being exposed as a service, annotate the method
with the following option:

\begin{verbatim}
@JSONWebService(mode = JSONWebServiceMode.IGNORE)
\end{verbatim}

Methods with this annotation don't become part of the JSON Web Service
API. Next, you'll learn how to define custom HTTP method and URL names.

\subsection{HTTP Method and URL Names}\label{http-method-and-url-names}

At the method level, you can define custom HTTP method names and URL
names. Just use an annotation like this one:

\begin{verbatim}
@JSONWebService(value = "add-board-wow", method = "PUT")
public boolean addBoard(
\end{verbatim}

In this example, the application's service method \texttt{addBoard} is
mapped to URL method name \texttt{add-board-wow}. Its complete URL is
now
\texttt{http://localhost:8080/api/jsonws/suprasurf.surfboard/add-board-wow}
and can be accessed using the HTTP PUT method.

If the URL method name in a JSON web service annotation starts with a
slash character (\texttt{/}), only the method name is used to form the
service URL; the class name is ignored:

\begin{verbatim}
@JSONWebService("/add-something-very-specific")
public boolean addBoard(
\end{verbatim}

Similarly, you can change the class name part of the URL, by setting the
value in a class-level annotation:

\begin{verbatim}
@JSONWebService("sbs")
public class SurfBoardServiceImpl extends SurfBoardServiceBaseImpl {
\end{verbatim}

This maps all of the service's methods to a URL class name \texttt{sbs}
instead of the default class name \texttt{surfboard}.

Next, you'll learn a different approach to exposing your methods via
manual registration.

\subsection{Manual Registration Mode}\label{manual-registration-mode}

Up to now, it's assumed that you want to expose most of your service
methods, while hiding some specific methods (the \emph{blacklist}
approach). Sometimes, however, you want the opposite: to explicitly
specify only the methods you want to expose (the \emph{whitelist}
approach). This is possible by specifying \emph{manual mode} on the
class-level annotation. Then it's up to you to annotate only those
methods you want to expose. For example:

\begin{verbatim}
@JSONWebService(mode = JSONWebServiceMode.MANUAL)
public class SurfBoardServiceImpl extends SurfBoardServiceBaseImpl{
    ...
    @JSONWebService
    public boolean addBoard(
\end{verbatim}

Now only the \texttt{addBoard} method and any other method annotated
with \texttt{@JSONWebService} are part of the JSON Web Service API; all
of this service's other methods are excluded from the API.

\subsection{Related Topics}\label{related-topics-134}

\href{/docs/7-0/tutorials/-/knowledge_base/t/invoking-json-web-services}{Invoking
JSON Web Services}

\href{/docs/7-0/tutorials/-/knowledge_base/t/json-web-services-invoker}{JSON
Web Services Invoker}

\href{/docs/7-0/tutorials/-/knowledge_base/t/json-web-services-invocation-examples}{JSON
Web Services Invocation Examples}

\section{Invoking JSON Web Services}\label{invoking-json-web-services}

If you know the URL and are connected to the internet, invoke Liferay's
JSON web service API in any language you want or directly with the URL
or \href{http://curl.haxx.se/}{cURL}. Additionally, Liferay provides a
handy JSON web services page that allows you to browse and invoke
service methods.

If you're running Liferay locally on port 8080, you can find the JSON
web services page at \url{http://localhost:8080/api/jsonws}. You can use
this page to generate example code for invoking web services. When you
invoke a service on this page as described in the tutorial
\href{/docs/7-0/tutorials/-/knowledge_base/t/invoking-remote-services}{Invoking
Remote Services}, the JSON result of your service invocation appears.
Click on the \emph{JavaScript Example}, \emph{curl Example}, or
\emph{URL Example} tabs to see different ways of invoking the web
service.

\begin{figure}
\centering
\includegraphics{./images/jsonws-simple-example.png}
\caption{When you invoke a service from Liferay's JSON web services
page, you can view the result of your service invocation as well as
example code for invoking the service via JavaScript, curl, or URL.}
\end{figure}

This tutorial explains general techniques for working with JSON web
services and includes details about invoking them via URL. For examples
of invoking Liferay's JSON web services via JavaScript, URL, and cURL,
see the
\href{/docs/7-0/tutorials/-/knowledge_base/t/json-web-services-invocation-examples}{JSON
Web Services Invocation Examples} tutorial.

There are multiple ways to invoke a JSON web service since there are
different ways to supply parameters. In this tutorial, you'll learn how
to include parameters in web service invocations. First, you must
understand how your invocation is matched to a method, especially in the
case of overloaded service methods.

The general rule is that you provide the service method's name and
\emph{all} the service method's parameters--even if you only provide
\texttt{null} values. It's important to provide all parameters, but it
doesn't matter \emph{how} you do it (e.g., as part of the URL line, as
request parameters, etc.). The order of the parameters doesn't matter
either.

\noindent\hrulefill

\textbf{Note:} An authentication related token (\texttt{p\_auth}) must
accompany each Liferay web service invocation. For details, see the
\href{/docs/7-0/tutorials/-/knowledge_base/t/service-security-layers}{Service
Security Layers} tutorial. Also, see the note in the following section
to learn how to find the \texttt{p\_auth} token value that corresponds
to your Liferay session.

\noindent\hrulefill

Exceptions abound in life, and there's an exception to the rule that
\emph{all} parameters are required. When using numeric \emph{hints} to
match methods, not all of the parameters are required. You'll learn to
use hints next.

\subsection{Using Hints When Invoking a Service via
URL}\label{using-hints-when-invoking-a-service-via-url}

Adding numeric hints lets you specify how many method arguments a
service has. If you don't specify an argument for a parameter, it's
automatically passed in as \texttt{null}. Syntactically, you can add
hints as numbers separated by a dot in the method name. Here's an
example:

\begin{verbatim}
/foo/get-bar.2/param1/123/-param2
\end{verbatim}

Here, the \texttt{.2} is a numeric hint specifying that only service
methods with two arguments are matched; others will be ignored for
matching.

There's an important distinction to make between matching with hints and
matching without hints. When a hint is specified, you don't have to
specify all of the parameters. Any missing arguments are treated as
\texttt{null}. The previous example may be called like this:

\begin{verbatim}
/foo/get-bar.2/param1/123
\end{verbatim}

In this example, \texttt{param2} will automatically be set to
\texttt{null}.

Here's a real Liferay example:

\begin{verbatim}
http://localhost:8080/api/jsonws/bookmarks.bookmarksfolder/add-folder.4/parent-folder-id/0/name/News?p_auth=[value]
\end{verbatim}

In this example, the hint number is \texttt{4} because there are four
parameters: \texttt{parentFolderId}, \texttt{name},
\texttt{description}, and \texttt{p\_auth}. Since the
\texttt{description} parameter is omitted, its value is assumed to be
\texttt{null}. If you try to invoke this web service with another hint
number such as \texttt{3} or \texttt{5}, you'll get an exception since
there is no \texttt{bookmarks/add-folder} method that takes that number
of parameters. The authentication parameter \texttt{p\_auth} is
associated with your Liferay session. See below for more information.

\noindent\hrulefill

\textbf{Important:} When invoking a Liferay web service by entering a
URL into your browser, you must be logged into Liferay with an account
that has permission to invoke the web service. You must also supply an
authentication token as a URL parameter. This authentication token is
associated with your browser session and is called \texttt{p\_auth}.
Using this authentication token helps prevent CSRF attacks.

\noindent\hrulefill

Here are two easy ways to find the \texttt{p\_auth} token:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Go to Liferay's JSON web services page and click on any service
  method. The value of the \texttt{p\_auth} token appears under the
  Execute heading.
\item
  If you're working from a JavaScript context and have access to the
  \texttt{Liferay} object, invoking \texttt{Liferay.authToken} provides
  the value of the \texttt{p\_auth} parameter.
\end{enumerate}

For example, if your \texttt{p\_auth} parameter's value is
\texttt{n35K1pb2}, you could invoke the preceding URL examples like
this:

\begin{verbatim}
http://localhost:8080/api/jsonws/bookmarks.bookmarksfolder/add-folder.4/parent-folder-id/0/name/News?p_auth=n35K1pb2
\end{verbatim}

For simplicity, the remainder of this tutorial omits the
\texttt{p\_auth} parameter from the example URLs for invoking web
services. Remember that you must include it if you want to invoke
services from your browser!

Next, you'll learn how to pass parameters as part of the URL path.

\subsection{Passing Parameters as Part of a URL
Path}\label{passing-parameters-as-part-of-a-url-path}

To pass method parameters as part of the URL path, specify them in
name-value pairs after the service URL. Parameter names must be formed
from method argument names by converting them from camel case to names
that use all lower case, dash-separated words. For example, this returns
all top-level bookmark folders from the specified site:

\begin{verbatim}
http://localhost:8080/api/jsonws/bookmarks.bookmarksfolder/get-folders/group-id/20181/parent-folder-id/0
\end{verbatim}

You can pass parameters in any order; it's not necessary to follow the
order in which the arguments are specified in the method signatures.

When a method name is overloaded, the \emph{best match} will be used.
The method that contains the least number of undefined arguments is
chosen and invoked for you.

You can also pass parameters in a URL query. The next section shows you
how to do this.

\subsection{Passing Parameters as a URL
Query}\label{passing-parameters-as-a-url-query}

To pass in parameters as request parameters, specify them as-is (camel
case) and set them equal to their argument value. For example:

\begin{verbatim}
http://localhost:8080/api/jsonws/bookmarks.bookmarksfolder/add-folder?parentFolderId=0&name=News&description=news
\end{verbatim}

As with passing parameters as part of a URL path, the parameter order is
not important and the best match rule applies for overloaded methods.

Now you know a few different ways to pass parameters. It's also possible
to pass URL parameters in a mixed way. For example, some can be part of
the URL path while others can be specified as request parameters.

Parameter values are sent as strings using the HTTP protocol. Before a
matching Java service method is invoked, each parameter value is
converted from a \texttt{String} to its target Java type. Liferay uses a
third party open source library to convert each object to its
appropriate common type. Although it's possible to add or change the
conversion for certain types, this tutorial only covers the standard
conversion process.

Conversion for common types (e.g., \texttt{long}, \texttt{String},
\texttt{boolean}) is straightforward. Dates can be given in
milliseconds. Locales can be passed as locale names (e.g.~\texttt{en}
and \texttt{en\_US}). To pass in an array of numbers, send a string of
comma-separated numbers (e.g.~the string \texttt{4,8,15,16,23,42} can be
converted to \texttt{long{[}{]}} type). You get the picture!

In addition to the common types, arguments can be of type \texttt{List}
or \texttt{Map}. To pass a \texttt{List} argument, send a JSON array. To
pass a \texttt{Map} argument, send a JSON object. These types of
conversions are performed in two steps:

\begin{itemize}
\tightlist
\item
  \emph{Step 1--JSON deserialization}: JSON arrays are converted into
  \texttt{List\textless{}String\textgreater{}}, and JSON objects are
  converted to \texttt{Map\textless{}String,\ String\textgreater{}}. For
  security reasons, it's forbidden to instantiate any type within JSON
  deserialization.
\item
  \emph{Step 2--Generification}: Each \texttt{String} element of the
  \texttt{List} and \texttt{Map} is converted to its target type (the
  argument's generic Java type specified in the method signature). This
  step is only executed if the Java argument type uses generics.
\end{itemize}

As an example, consider the conversion of a \texttt{String} array
\texttt{{[}en,fr{]}} as JSON web service parameters for a
\texttt{List\textless{}Locale\textgreater{}} Java method argument type:

\begin{itemize}
\item
  \emph{Step 1--JSON deserialization}: The JSON array is deserialized to
  a \texttt{List\textless{}String\textgreater{}} containing
  \texttt{String}s \texttt{en} and \texttt{fr}.
\item
  \emph{Step 2--Generification}: Each \texttt{String} is converted to
  the \texttt{Locale} (the generic type), resulting in the
  \texttt{List\textless{}Locale\textgreater{}} Java argument type.
\end{itemize}

Next, you'll learn how to specify an argument as \texttt{null}.

\subsection{Sending Null Values}\label{sending-null-values}

To pass a \texttt{null} value for an argument, prefix the parameter name
with a dash. Here's an example:

\begin{verbatim}
http://localhost:8080/api/jsonws/bookmarks.bookmarksfolder/add-folder/parent-folder-id/0/name/News/-description
\end{verbatim}

Here's the equivalent example using URL query parameters instead of URL
path parameters:

\begin{verbatim}
http://localhost:8080/api/jsonws/bookmarks.bookmarksfolder/add-folder?parentFolderId=0&name=News&-description
\end{verbatim}

The \texttt{description} parameter is interpreted as \texttt{null}. Note
that this parameter doesn't have to be last in the URL.

Null parameters don't have specified values. When a null parameter is
passed as a request parameter, its value is ignored and \texttt{null} is
used instead:

\begin{verbatim}
<input type="hidden" name="-description" value=""/>
\end{verbatim}

When using JSON-RPC (see the JSON-RPC section below), you can send null
values explicitly, even without a prefix. Here's an example:

\begin{verbatim}
"description":null
\end{verbatim}

Next, you'll learn about encoding parameters.

\subsection{Encoding Parameters}\label{encoding-parameters}

There's a difference between URL encoding and query (i.e., request
parameters) encoding. The difference lies in how the space character is
encoded. When the space character is part of the URL path, it's encoded
as \texttt{\%20}; when it's part of the query it's encoded as a plus
sign (\texttt{+}).

All these encoding rules apply to ASCII and international (non-ASCII)
characters. Since Liferay works in UTF-8 mode, parameter values must be
encoded as UTF-8 values. Liferay doesn't decode request URLs and request
parameter values to UTF-8 itself; it relies on the web server layer.
When accessing services through JSON-RPC, encoding parameters to UTF-8
isn't enough--you need to send the encoding type in a Content-Type
header (e.g. \texttt{Content-Type\ :\ "text/plain;\ charset=utf-8"}).

For example, suppose you want to pass the value ``Супер'' (``Super'' in
Cyrillic) to a JSON web service method. This name first has to be
converted to UTF-8 (resulting in an array of 10 bytes) and then encoded
for URLs or request parameters. The resulting value is the string
\texttt{\%D0\%A1\%D1\%83\%D0\%BF\%D0\%B5\%D1\%80} that can be passed to
your service method. When received, this value is first translated to an
array of 10 bytes (URL decoded), and then converted to a UTF-8 string of
the 5 original characters.

Next, you'll learn how to send files as arguments.

\subsection{Sending Files as
Arguments}\label{sending-files-as-arguments}

Files can be uploaded using multi-part forms and requests. Here's an
example:

\begin{verbatim}
<form
 action="http://localhost:8080/api/jsonws/dlapp/add-file-entry"
 method="POST"
 enctype="multipart/form-data">
    <input type="hidden" name="repositoryId" value="10172"/>
    <input type="hidden" name="folderId" value="0"/>
    <input type="hidden" name="title" value="test.jpg"/>
    <input type="hidden" name="description" value="File upload example"/>
    <input type="hidden" name="changeLog" value="v1"/>
    <input type="file" name="file"/>
    <input type="submit" value="addFileEntry(file)"/>
</form>
\end{verbatim}

This is a common upload form that invokes the \texttt{DLAppService}
class's \texttt{addFileEntry} method.

Now you'll learn how to invoke JSON web services using JSON-RPC.

\subsection{JSON-RPC}\label{json-rpc}

You can invoke JSON Web Service using
\href{http://json-rpc.org}{JSON-RPC}. Most of the JSON-RPC 2.0
specification is supported in Liferay JSON web services. One important
limitation is that parameters must be passed in as \emph{named}
parameters. Positional parameters aren't supported, as there are too
many overloaded methods for convenient use of positional parameters.

Here's an example of invoking a JSON web service using JSON-RPC:

\begin{verbatim}
POST http://localhost:8080/api/jsonws/dlapp
{
    "method":"get-folders",
    "params":{"repositoryId":10172, "parentFolderId":0},
    "id":123,
    "jsonrpc":"2.0"
}
\end{verbatim}

Next, you'll learn about parameters that are made available to secure
JSON web services by default.

\subsection{Default Parameters}\label{default-parameters}

When accessing secure JSON web services (i.e., services for which the
user must be authenticated), some parameters are made available to the
web services by default. All of Liferay's web services are secured by
default. Unless you want to change the available parameters' values to
something other than their defaults, you don't have to specify them
explicitly.

Here are the available default parameters:

\begin{itemize}
\tightlist
\item
  \texttt{userId}: The primary key of the authenticated user
\item
  \texttt{user}: The full user object
\item
  \texttt{companyId}: The primary key of the user's company
\item
  \texttt{serviceContext}: The empty service context object
\end{itemize}

Next, you'll learn about object parameters.

\subsection{Object Parameters}\label{object-parameters}

Most services accept simple parameters like numbers and strings.
However, sometimes you might need to provide an object (a non-simple
type) as a service parameter.

To create an instance of an object parameter, prefix the parameter with
a plus sign, \texttt{+} and don't assign it any other parameter value.
This is similar to specifying a null parameter by prefixing the
parameter with a dash symbol, \texttt{-}.

Here's an example:

\begin{verbatim}
/jsonws/foo/get-bar/zap-id/10172/start/0/end/1/+foo
\end{verbatim}

To create an instance of an object parameter as a request parameter,
make sure you encode the \texttt{+} symbol:

\begin{verbatim}
/jsonws/foo/get-bar?zapId=10172&start=0&end=1&%2Bfoo
\end{verbatim}

Here's an alternative syntax:

\begin{verbatim}
<input type="hidden" name="+foo" value=""/>
\end{verbatim}

If a parameter is an abstract class or an interface, it can't be
instantiated as such. Instead, a concrete implementation class must be
specified to create the argument value. You can do this by specifying
the \texttt{+} prefix before the parameter name, followed by specifying
the concrete implementation class. Here's an example:

\begin{verbatim}
/jsonws/foo/get-bar/zap-id/10172/start/0/end/1/+foo:com.liferay.impl.FooBean
\end{verbatim}

Here's another way of doing it:

\begin{verbatim}
<input type="hidden" name="+foo:com.liferay.impl.FooBean" value=""/>
\end{verbatim}

The examples above specify that a \texttt{com.liferay.impl.FooBean}
object, presumed to implement the class of the parameter named
\texttt{foo}, is created.

You can also set a concrete implementation as a value. Here's an
example:

\begin{verbatim}
<input type="hidden" name="+foo" value="com.liferay.impl.FooBean"/>
\end{verbatim}

In JSON-RPC, here's what it looks like:

\begin{verbatim}
"+foo" : "com.liferay.impl.FooBean"
\end{verbatim}

All the preceding examples specify a concrete implementation for the
\texttt{foo} service method parameter.

Once you pass in an object parameter, you might want to populate the
object. Find out how next.

\subsection{Inner Parameters}\label{inner-parameters}

When you pass in an object parameter, you'll often need to populate its
inner parameters (i.e., fields). Consider a default parameter
\texttt{serviceContext} of type \texttt{ServiceContext}. To make an
appropriate call to JSONWS, you might need to set the
\texttt{serviceContext} parameter's \texttt{addGroupPermissions} and
\texttt{scopeGroupId} fields.

You can pass inner parameters by using dot notation to specify them.
Just append the name of the parameter with a dot (i.e., a period,
\texttt{.}), followed by the inner parameter's name. For the
\texttt{ServiceContext} inner parameters mentioned previously, you'll
specify \texttt{serviceContext.addGroupPermissions} and
\texttt{serviceContext.scopeGroupId}. These are recognized as inner
parameters and their values are injected into existing parameters before
the API service method is executed.

Inner parameters aren't counted as regular parameters for matching
methods and are ignored during matching.

\noindent\hrulefill

\textbf{Tip:} Use inner parameters with object parameters to set inner
contents of created object parameter instances!

\noindent\hrulefill

Next, let's see what values are returned when a JSON web service is
invoked.

\subsection{Returned Values}\label{returned-values}

No matter how a JSON web service is invoked, it returns a JSON string
that represents the service method result. Returned objects are
\emph{loosely} serialized to a JSON string and returned to the caller.

Now you'll look at some values returned from service calls. You'll
create a \texttt{UserGroup} as in the SOAP web service client examples.
To make it easy, you'll use the test form provided with the JSON web
service in our browser.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Sign in to a local Liferay instance as an administrator and then point
  your browser to the JSON web service method that adds a
  \texttt{BookmarksFolder}:

\begin{verbatim}
http://localhost:8080/api/jsonws?contextName=bookmarks&signature=%2Fbookmarks.bookmarksfolder%2Fadd-folder-4-parentFolderId-name-description-serviceContext
\end{verbatim}

  Alternatively, navigate to it by starting at
  \texttt{http://localhost:8080/api/jsonws} and then scrolling down to
  the section for \emph{BookmarksFolder}. Then click \emph{add-folder}.
\item
  In the \texttt{parentFolderId} field, enter \texttt{0}. Top-level
  bookmarks folders have a \texttt{parentFolderId} value of \texttt{0}.
  Set the name to an arbitrary value like \emph{News}. Set the
  description to something like \emph{Created via JSON WS}.
\item
  Click \emph{Invoke} and you'll get a result similar to the following:

\begin{verbatim}
{
  "companyId": "20202",
  "createDate": 1459969296960,
  "description": "Created via JSON WS",
  "folderId": "31001",
  "groupId": "20233",
  "lastPublishDate": null,
  "modifiedDate": 1459969297005,
  "name": "News",
  "parentFolderId": "0",
  "resourceBlockId": "1",
  "status": 0,
  "statusByUserId": "0",
  "statusByUserName": "",
  "statusDate": null,
  "treePath": "/31001/",
  "userId": "20250",
  "userName": "Joe Bloggs",
  "uuid": "0682170c-f9d7-f295-aa67-26ceea37a6e5"
}
\end{verbatim}
\end{enumerate}

The returned \texttt{String} represents the \texttt{BookmarksFolder}
object you just created, serialized into a JSON string. To find out more
about JSON strings, go to \href{http://www.json.org/}{json.org}.

\subsection{Common JSON Web Service
Errors}\label{common-json-web-service-errors}

While working with JSON web services, you may encounter errors. Some
common errors are listed here:

\begin{itemize}
\item
  \emph{Authenticated access required}

  If you see this error, it means you don't have permission to invoke
  the remote service. Double-check that you're signed in as a user with
  the appropriate permissions. If necessary, sign in as an administrator
  to invoke the remote service.
\item
  \emph{Missing value for parameter}

  If you see this error, you didn't pass a parameter value along with
  the parameter name in your URL path. The parameter value must follow
  the parameter name, like in this example:

\begin{verbatim}
/api/jsonws/user/get-user-by-id/userId
\end{verbatim}

  The path above specifies a parameter named \texttt{userId}, but
  doesn't specify the parameter's value. You can resolve this error by
  providing the parameter value after the parameter name:

\begin{verbatim}
/api/jsonws/user/get-user-by-id/userId/173
\end{verbatim}
\item
  \emph{No JSON web service action associated}

  This is error means no service method could be matched with the
  provided data (method name and argument names). This can be due to
  various reasons. For example, arguments may be misspelled, the method
  name may be formatted incorrectly, and so on. Since JSON web services
  reflect the underlying Java API, any changes in the respective Java
  API are automatically propagated to the JSON web services. For
  example, if a new argument is added to a method or an existing
  argument is removed from a method, the parameter data must match that
  of the new method signature.
\item
  \emph{Unmatched argument type}

  This error appears when you try to instantiate a method argument using
  an incompatible argument type.
\end{itemize}

\subsection{Related Topics}\label{related-topics-135}

\href{/docs/7-0/tutorials/-/knowledge_base/t/json-web-services-invoker}{JSON
Web Services Invoker}

\href{/docs/7-0/tutorials/-/knowledge_base/t/json-web-services-invocation-examples}{JSON
Web Services Invocation Examples}

\href{/docs/7-0/tutorials/-/knowledge_base/t/service-security-layers}{Service
Security Layers}

\href{/docs/7-0/tutorials/-/knowledge_base/t/invoking-remote-services}{Invoking
Remote Services}

\section{JSON Web Services Invoker}\label{json-web-services-invoker}

To use JSON web services, you send a request that defines a service
method and parameters, and you receive the result as a JSON object. As
straightforward as this seems, it can be improved. In this tutorial,
you'll learn how to use JSON web services more efficiently and
pragmatically.

Consider the following example. You're working with two related objects:
a \texttt{User} and its corresponding \texttt{Contact}. With simple JSON
web service calls, you first call the user service to get the user
object, and then you use that object's contact ID to call the contact
service. You end up sending two HTTP requests to get two JSON objects
that aren't even bound together. There's no contact information in the
user object (i.e.~no \texttt{user.contact}). This approach is suboptimal
with respect to performance (sending two HTTP calls) and usability
(manually managing the relationship between two objects). It'd be nicer
if you had a tool to address these inefficiencies. Fortunately, the JSON
Web Service Invoker does just that!

Liferay's JSON Web Service Invoker helps optimize your JSON Web Services
use. In the following sections, you'll learn how.

\subsection{Simple Invoker Calls}\label{simple-invoker-calls}

The Invoker is accessible from the following fixed address:

\begin{verbatim}
http://[address]:[port]/api/jsonws/invoke
\end{verbatim}

It only accepts a \texttt{cmd} request parameter--this is the Invoker's
command. If the command request parameter is missing, the request body
is used as the command. So you can specify the command by either using
the request parameter \texttt{cmd} or the request body.

The Invoker command is a plain JSON map that describes how JSON web
services are called and how the results are managed. Here's an example
of how to call a simple service using the Invoker:

\begin{verbatim}
{
    "/user/get-user-by-id": {
        "userId": 123,
        "param1": null
    }
}
\end{verbatim}

The service call is defined as a JSON map. The key specifies the service
URL (i.e.~the service method to be invoked) and the key's value
specifies a map of service parameter names (i.e.~\texttt{userId} and
\texttt{param1}) and their values. In the example above, the retrieved
user is returned as a JSON object. Since the command is a JSON string,
null values can be specified either by explicitly using the
\texttt{null} keyword or by placing a dash before the parameter name and
leaving the value empty
(e.g.~\texttt{"-param1":\ \textquotesingle{}\textquotesingle{}}).

The example Invoker calls functions exactly the same way as the
following standard JSON Web Service call:

\begin{verbatim}
/user/get-user-by-id?userId=123&-param1
\end{verbatim}

Next, suppose that you're running Liferay locally on port \texttt{8080}.
Consider the following example of a real Liferay JSON web service
invoker call. Suppose that you're signed in to Liferay as the default
admin user whose email address is \texttt{test@example.com} and whose
user ID is \texttt{20127}. And suppose that the value of your
\texttt{p\_auth} authentication token is \texttt{htXjvt5d}. You can then
invoke the following URL to obtain a JSON representation of your user
object:

\begin{verbatim}
http://localhost:8080/api/jsonws/invoke?cmd={%22/user/get-user-by-id%22:{%22userId%22:20172}}&p_auth=htXjvt5d
\end{verbatim}

This URL uses the following JSON map. Note that it's supplied in the URL
by using the \texttt{cmd} URL parameter:

\begin{verbatim}
{
    "/user/get-user-by-id": {
        "userId": 20172
    }
}
\end{verbatim}

Note in the URL that the double quotes are URL-encoded. Also, if you're
not sure what your user ID is, you can find it in the User Menu under
\emph{My Account} → \emph{Account Settings}. If you're not sure what the
value of your \texttt{p\_auth} authentication token is, navigate to
\href{http://localhost:8080/api/jsonws}{Liferay's JSON web services API
page} and click on any method in the list. The value of your
\texttt{p\_auth} token appears under the Execute heading along with any
other parameters of the selected API method.

You can use JSON syntax for supplying values for objects and arrays that
you need to supply as parameters. To supply a value for an object, use
curly brackets: \texttt{\{} and \texttt{\}}. To supply a value for an
array, use square brackets: \texttt{{[}} and \texttt{{]}}. Suppose as
before that you're signed in to Liferay as an admin user and that the
value of your \texttt{p\_auth} authentication token is
\texttt{htXjvt5d}. Furthermore, suppose that two vocabularies have been
created with vocabulary IDs of \texttt{20783} and \texttt{20784}. Here's
a Liferay JSON web service invoker example that demonstrates how to pass
an array as a parameter:

\begin{verbatim}
http://localhost:8080/api/jsonws/invoke?cmd={%22/assetvocabulary/get-vocabularies%22:{%22vocabularyIds%22:[20783,20784]}}&p_auth=htXjvt5d
\end{verbatim}

This URL uses the following JSON map:

\begin{verbatim}
{
    "/assetvocabulary/get-vocabularies": {
        "vocabularyIds": [20783,20784]
    }
}
\end{verbatim}

As before, the double quotes in the URL are URL-encoded. Also, the
\texttt{vocabularyIds} parameter is an array, so its value is supplied
as a JSON array.

Finally, here's one more Liferay JSON web service invoker example that
demonstrates how to pass an object containing an array as a parameter:

\begin{verbatim}
http://localhost:8080/api/jsonws/invoke?cmd={%22/user/add-user%22:{%22companyId%22:20127,%22autoPassword%22:false,%22password1%22:%22test%22,%22password2%22:%22test%22,%22autoScreenName%22:false,%22screenName%22:%22joe.bloggs%22,%22emailAddress%22:%22joe.bloggs@example.com%22,%22facebookId%22:0,%22openId%22:%22%22,%22locale%22:%22en_US%22,%22firstName%22:%22Joe%22,%22middleName%22:%22T%22,%22lastName%22:%22Bloggs%22,%22prefixId%22:0,%22suffixId%22:0,%22male%22:true,%22birthdayMonth%22:1,%22birthdayDay%22:1,%22birthdayYear%22:1970,%22jobTitle%22:%22Tester%22,%22groupIds%22:null,%22organizationIds%22:null,%22roleIds%22:null,%22userGroupIds%22:null,%22sendEmail%22:false,%22serviceContext%22:{%22assetTagNames%22:[%22test%22]}}}&p_auth=htXjvt5d
\end{verbatim}

This URL uses the following JSON map:

\begin{verbatim}
{
    "/user/add-user": {
        "companyId": 20127,
        "autoPassword": false,
        "password1": "test",
        "password2": "test",
        "autoScreenName": false,
        "screenName": "joe.bloggs",
        "emailAddress": "joe.bloggs@example.com",
        "facebookId": 0,
        "openId": "",
        "locale": "en_US",
        "firstName": "Joe",
        "middleName": "T",
        "lastName": "Bloggs",
        "prefixId": 0,
        "suffixId": 0,
        "male": true,
        "birthdayMonth": 1,
        "birthdayDay": 1,
        "birthdayYear": 1970,
        "jobTitle": "Tester",
        "groupIds": null,
        "organizationIds": null,
        "roleIds": null,
        "userGroupIds": null,
        "sendEmail": false,
        "serviceContext": {"assetTagNames":["test"]}
    }
}
\end{verbatim}

The \texttt{serviceContext} is the object containing an array in this
example. It contains the array \texttt{assetTagNames}.

Of course, the JSON Web Service Invoker handles calls to plugin methods
as well:

\begin{verbatim}
{
    "/suprasurf/hello-world": {
        "worldName": "Mavericks"
    }
}
\end{verbatim}

The code above calls the (fictitious) SupraSurf application's remote
service.

You can use variables to reference objects returned from service calls.
Variable names must start with a dollar sign, \texttt{\$}. In the
previous example, the service call returned a user object you can assign
to a variable:

\begin{verbatim}
{
    "$user = /user/get-user-by-id": {
        "userId": 123,
    }
}
\end{verbatim}

The \texttt{\$user} variable holds the returned user object. You can
reference the user's contact ID using the syntax
\texttt{\$user.contactId}.

Next, see how you can use nested service calls to join information from
two related objects.

\subsection{Nesting Service Calls}\label{nesting-service-calls}

With nested service calls, you can bind information from related objects
together in a JSON object. You can call other services within the same
HTTP request and nest returned objects in a convenient way. Here's a
nested service call in action:

\begin{verbatim}
{
    "$user = /user/get-user-by-id": {
        "userId": 123,
        "$contact = /contact/get-contact-by-id": {
            "@contactId": "$user.contactId"
        }
    }
}
\end{verbatim}

This command defines two service calls: the contact object returned from
the second service call is nested in (i.e.~injected into) the user
object, as a property named \texttt{contact}. Now you can bind the user
and his or her contact information together!

Now you'll see what the Invoker does in the background when using a
single HTTP request to make the preceding nested service call:

\begin{itemize}
\tightlist
\item
  First, the Invoker calls the Java service mapped to
  \texttt{/user/get-user-by-id}, passing in a value for the
  \texttt{userId} parameter.
\item
  Next, the resulting user object is assigned to the variable
  \texttt{\$user}.
\item
  The nested service calls are invoked.
\item
  The Invoker calls the Java service mapped to
  \texttt{/contact/get-contact-by-id} by using the \texttt{contactId}
  parameter, with the \texttt{\$user.contactId} value from the object
  \texttt{\$user}.
\item
  The resulting contact object is assigned to the variable
  \texttt{\$contact}.
\item
  Lastly, the Invoker injects the contact object referenced by
  \texttt{\$contact} into the user object's property named
  \texttt{contact}.
\end{itemize}

\noindent\hrulefill

\textbf{Note:} You must flag parameters that take values from existing
variables. To flag a parameter, insert the \texttt{@} prefix before the
parameter name.

\noindent\hrulefill

Next, you'll learn about filtering object properties so that only the
properties you need are returned when you invoke a service.

\subsection{Filtering Results}\label{filtering-results}

Many of Liferay's model objects are rich with properties. If you only
need a handful of an object's properties for your business logic, making
a web service invocation that returns all of an object's properties is a
waste of network bandwidth. With the JSON Web Service Invoker, you can
define a whitelist of properties: only the specific properties you
request in the object are returned from your web service call. Here's
how you whitelist the properties you need:

\begin{verbatim}
{
    "$user[firstName,emailAddress] = /user/get-user-by-id": {
        "userId": 123,
        "$contact = /contact/get-contact-by-id": {
            "@contactId": "$user.contactId"
        }
    }
}
\end{verbatim}

In this example, the returned user object has only the
\texttt{firstName} and \texttt{emailAddress} properties (it still has
the \texttt{contact} property, too). To specify whitelist properties,
you simply place the properties in square brackets (e.g.,
\texttt{{[}whiteList{]}}) immediately following the name of your
variable.

Next, you'll learn about making calls in batch.

\subsection{Making Batch Calls}\label{making-batch-calls}

When nesting service calls, the intent is to invoke multiple services
with a single HTTP request. Using a single request for multiple service
calls is helpful for gathering related information from the service call
results, but it can also be advantageous to use a single request to
invoke multiple unrelated service calls. The Invoker lets you batch
service calls together to improve performance. It's simple: just pass in
a JSON array of commands using the following format:

\begin{verbatim}
[
    {/* first command */},
    {/* second command */}
]
\end{verbatim}

The result is a JSON array populated with results from each command. The
commands are collectively invoked in a single HTTP request, one after
another.

Great! Now you know how to use Liferay's JSON Web Service Invoker to
simplify your JSON calls to Liferay.

\subsection{Related Topics}\label{related-topics-136}

\href{/docs/7-0/tutorials/-/knowledge_base/t/invoking-remote-services}{Invoking
Remote Services}

\href{/docs/7-0/tutorials/-/knowledge_base/t/invoking-json-web-services}{Invoking
JSON Web Services}

\href{/docs/7-0/tutorials/-/knowledge_base/t/json-web-services-invocation-examples}{JSON
Web Services Invocation Examples}

\section{JSON Web Services Invocation
Examples}\label{json-web-services-invocation-examples}

This tutorial provides examples of invoking Liferay's JSON web services
via JavaScript, URL, and \href{http://curl.haxx.se/}{cURL}. To
illustrate the differences between these, the same two use cases
(getting a user and adding a user) are shown in each example. This
tutorial also includes an example of using JavaScript to invoke
Liferay's JSON web services from a portlet.

\subsection{Loading AlloyUI}\label{loading-alloyui}

Liferay web pages use the AlloyUI JavaScript framework. Among the
JavaScript objects created for each Liferay page is a \texttt{Liferay}
object. This object includes a \texttt{Service} function that you can
use to invoke Liferay's API. To invoke Liferay web services via
\texttt{Liferay.Service(...)}, your JavaScript context must include the
AlloyUI JavaScript framework. Liferay uses AlloyUI 3.0. If you're
working in a JSP, you can load the AlloyUI taglib and wrap your
JavaScript code in an \texttt{\textless{}aui:script\textgreater{}} tag.
Here's the required import:

\begin{verbatim}
<%@ taglib uri="http://alloy.liferay.com/tld/aui" prefix="aui" %>
\end{verbatim}

By default, the \texttt{\textless{}aui:script\textgreater{}} tag
includes the base AUI module. To load specific AUI modules, specify them
via the \texttt{use} attribute. For example, to use the AUI
\texttt{node} and \texttt{event} modules, wrap your code like this:

\begin{verbatim}
<aui:script use="node, event">
    // Liferay service invocation here
</aui:script>
\end{verbatim}

If you're not working in a JSP, you won't have access to taglibs. In
this case, create an AUI context manually. For example, use the
following HTML fragment to load the AUI seed and CSS files:

\begin{verbatim}
<script src="http://cdn.alloyui.com/3.0.0/aui/aui-min.js"></script>
<link href="http://cdn.alloyui.com/3.0.0/aui-css/css/bootstrap.min.css" rel="stylesheet"></link>
\end{verbatim}

Then you can create an AUI context like this:

\begin{verbatim}
AUI().use('aui-base', function(A){
    // Liferay service invocation here
});
\end{verbatim}

Now you're ready to invoke Liferay's JSON web services.

\subsection{Get User JSON Web Service Invocation via
JavaScript}\label{get-user-json-web-service-invocation-via-javascript}

First, examine the following JSON web service invocation, written in
JavaScript:

\begin{verbatim}
Liferay.Service(
    '/user/get-user-by-email-address',
    {
        companyId: Liferay.ThemeDisplay.getCompanyId(),
        emailAddress: 'test@example.com`
    },
    function(obj) {
        console.log(obj);
    }
);
\end{verbatim}

If you run this code, the test@example.com user (JSON object) is logged
to the JavaScript console.

The \texttt{Liferay.Service(...)} function takes three arguments:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  A string representing the service to invoke
\item
  A parameters object
\item
  A callback function
\end{enumerate}

The callback function takes the result of the service invocation as an
argument.

\subsection{Add User JSON Web Service Invocation via
JavaScript}\label{add-user-json-web-service-invocation-via-javascript}

Here's an example JSON web service invocation, also written in
JavaScript, that adds a new user. It requires many more parameters than
the one for retrieving a user!

\begin{verbatim}
Liferay.Service(
    '/user/add-user',
    {
        companyId: Liferay.ThemeDisplay.getCompanyId(),
        autoPassword: false,
        password1: 'test',
        password2: 'test',
        autoScreenName: false,
        screenName: 'joe.bloggs',
        emailAddress: 'joe.bloggs@example.com',
        facebookId: 0,
        openId: '',
        locale: 'en_US',
        firstName: 'Joe',
        middleName: 'T',
        lastName: 'Bloggs',
        prefixId: 0,
        suffixId: 0,
        male: true,
        birthdayMonth: 1,
        birthdayDay: 1,
        birthdayYear: 1970,
        jobTitle: 'Tester',
        groupIds: null,
        organizationIds: null,
        roleIds: null,
        userGroupIds: null,
        sendEmail: false,
        serviceContext: {assetTagNames: ['test']}
    },
    function(obj) {
        console.log(obj);
    }
);
\end{verbatim}

The \texttt{serviceContext} object assigns the \texttt{test} tag to the
newly created user. Note that you can use JSON syntax to supply values
for objects and arrays. For example, to supply a value for the
\texttt{serviceContext} object, you use curly brackets: \texttt{\{} and
\texttt{\}}. To supply a value for the \texttt{assetTagNames} array, you
use square brackets: \texttt{{[}} and \texttt{{]}}. Thus, the line
\texttt{serviceContext:\ \{assetTagNames:\ {[}\textquotesingle{}test\textquotesingle{}{]}\}}
indicates that \texttt{serviceContext} is an object containing an array
named \texttt{assetTagNames}, which contains the string \texttt{test}.

\subsection{Invoking JSON Web Services via JavaScript in a
Application}\label{invoking-json-web-services-via-javascript-in-a-application}

You can adapt the example from the previous section for use in a Liferay
app. For example, the JSP page below creates a form that lets the user
specify a first name, middle name, last name, screen name, and email
address. When the user clicks the \emph{Add User} button, the app uses
these values to create a new user.

\begin{verbatim}
<%@ taglib uri="http://alloy.liferay.com/tld/aui" prefix="aui" %>
<%@ taglib uri="http://java.sun.com/portlet_2_0" prefix="portlet" %>

<portlet:defineObjects />

<portlet:renderURL var="successURL">
    <portlet:param name="mvcPath" value="/success.jsp"/>
</portlet:renderURL>

<portlet:renderURL var="failureURL">
    <portlet:param name="mvcPath" value="/failure.jsp"/>
</portlet:renderURL>

<aui:form method="GET" name="<portlet:namespace />fm">
    <aui:fieldset>
        <aui:input label="First Name" name="first-name"></aui:input>
        <aui:input label="Middle Name" name="middle-name"></aui:input>
        <aui:input label="Last Name" name="last-name"></aui:input>
        <aui:input label="Screen Name" name="screen-name"></aui:input>
        <aui:input label="Email Address" name="email-address"></aui:input>
    </aui:fieldset>

        <p>Click the button below to add a new user by invoking Liferay's JSON web services.</p>

        <aui:button-row>
            <aui:button id="add-user" value="Add User">
            </aui:button>
        </aui:button-row>
</aui:form>

<aui:script use="node, event">
var addUserButton = A.one('#add-user');

var firstNameNode = A.one('#<portlet:namespace />first-name');
var middleNameNode = A.one('#<portlet:namespace />middle-name');
var lastNameNode = A.one('#<portlet:namespace />last-name');
var screenNameNode = A.one('#<portlet:namespace />screen-name');
var emailAddressNode = A.one('#<portlet:namespace />email-address');

addUserButton.on('click', function(event) {
        var firstName = firstNameNode.get('value');
        var middleName = middleNameNode.get('value');
        var lastName = lastNameNode.get('value');
        var screenName = screenNameNode.get('value');
        var emailAddress = emailAddressNode.get('value');

    var user = Liferay.Service(
        '/user/add-user',
        {
            companyId: Liferay.ThemeDisplay.getCompanyId(),
            autoPassword: false,
            password1: 'test',
            password2: 'test',
            autoScreenName: false,
            screenName: screenName,
            emailAddress: emailAddress,
            facebookId: 0,
            openId: '',
            locale: 'en_US',
            firstName: firstName,
            middleName: middleName,
            lastName: lastName,
            prefixId: 0,
            suffixId: 0,
            male: true,
            birthdayMonth: 1,
            birthdayDay: 1,
            birthdayYear: 1970,
            jobTitle: 'Tester',
            groupIds: null,
            organizationIds: null,
            roleIds: null,
            userGroupIds: null,
            sendEmail: false,
            serviceContext: {assetTagNames: ['test']}
        },
        function(obj) {
            console.log(obj);

            if (obj.hasOwnProperty('createDate')) {
                window.open('<%= successURL %>', '_self');
            }
            else {
                window.open('<%= failureURL %>', '_self');
            }
        }
    );
});
</aui:script>
\end{verbatim}

In this example, it's assumed that the JSP page is part of a web module
with a portlet class that extends Liferay's \texttt{MVCPortlet} class.
This is required since the code uses the \texttt{mvcPath} URL parameter.
It's also assumed that the JSP code is in a file named
\texttt{view.jsp}, and that there are also \texttt{success.jsp} and
\texttt{failure.jsp} files in the same directory.

\subsection{Get User JSON Web Service Invocation via
URL}\label{get-user-json-web-service-invocation-via-url}

Here's a simple JSON web service invocation via URL that returns the
user with the specified email address:

\begin{verbatim}
http://localhost:8080/api/jsonws/user/get-user-by-email-address/company-id/20154/email-address/test%40liferay.com?p_auth=[value]
\end{verbatim}

This web service invocation returns the test@example.com user. After
invoking a service via Liferay's JSONWS API page, the URL provided when
you click on the \emph{URL Example} tab omits the \texttt{p\_auth} URL
query parameter. It's assumed that you'll add this parameter yourself.
Remember that you must be logged in as a user with the required
permission to invoke a web service. To find the \texttt{p\_auth} token
that corresponds to your session, see the
\href{/docs/7-0/tutorials/-/knowledge_base/t/invoking-json-web-services}{Invoking
JSON Web Services} tutorial.

If you read that tutorial, you know that you can supply parameters as
either URL path parameters or URL query parameters. In the preceding
example, the company ID and email address are supplied as URL path
parameters. Here's an equivalent example using URL query parameters:

\begin{verbatim}
http://localhost:8080/api/jsonws/user/get-user-by-email-address?companyId=20154&emailAddress=test@example.com&p_auth=[value]
\end{verbatim}

Next, you'll consider an example that requires many more parameters!

\subsection{Add User JSON Web Service Invocation via
URL}\label{add-user-json-web-service-invocation-via-url}

Here's an example JSON web service invocation via URL that adds a new
user with the specified attributes:

\begin{verbatim}
http://localhost:8080/api/jsonws/user/add-user/company-id/20154/auto-password/false/password1/test/password2/test/auto-screen-name/false/screen-name/joe.bloggs/email-address/joe.bloggs%40liferay.com/facebook-id/0/-open-id/locale/en_US/first-name/Joe/middle-name/T/last-name/Bloggs/prefix-id/0/suffix-id/0/male/true/birthday-month/1/birthday-day/1/birthday-year/1970/job-title/Tester/-group-ids/-organization-ids/-role-ids/-user-group-ids/send-email/false?p_auth=[value]
\end{verbatim}

And here's the same example using URL query parameters instead of URL
path parameters:

\begin{verbatim}
http://localhost:8080/api/jsonws/user/add-user?companyId=20154&autoPassword=false&password1=test&password2=test&autoScreenName=false&screenName=joe.bloggs&emailAddress=joe.bloggs@example.com&facebookId=0&-openId&locale=en_US&firstName=Joe&middleName=T&lastName=Bloggs&prefixId=0&suffixId=0&male=true&birthdayMonth=1&birthdayDay=1&birthdayYear=1970&jobTitle=Tester&-groupIds&-organizationIds&-roleIds&-userGroupIds&sendEmail=false&p_auth=[value]
\end{verbatim}

\subsection{Get User JSON Web Service Invocation via
cURL}\label{get-user-json-web-service-invocation-via-curl}

Here's an example JSON web service invocation via the cURL tool that
returns the user with the specified email address:

\begin{verbatim}
curl http://localhost:8080/api/jsonws/user/get-user-by-email-address \
  -u test@example.com:test \
  -d companyId=20154 \
  -d emailAddress='test@example.com'
\end{verbatim}

Note that cURL is a command line tool. You can execute this command from
a terminal or command prompt.

\subsection{Add User JSON Web Service Invocation via
cURL}\label{add-user-json-web-service-invocation-via-curl}

Here's an example JSON web service invocation via the cURL tool that
adds the user with the specified attributes:

\begin{verbatim}
curl http://localhost:8080/api/jsonws/user/add-user \
  -u test@example.com:test \
  -d companyId=20154 \
  -d autoPassword=false \
  -d password1='test' \
  -d password2='test' \
  -d autoScreenName=false \
  -d screenName='joe.bloggs' \
  -d emailAddress='joe.bloggs@example.com' \
  -d facebookId=0 \
  -d openId='0' \
  -d locale=en_US \
  -d firstName='Joe' \
  -d middleName='T' \
  -d lastName='Bloggs' \
  -d prefixId=0 \
  -d suffixId=0 \
  -d male=true \
  -d birthdayMonth=1 \
  -d birthdayDay=1 \
  -d birthdayYear=1970 \
  -d jobTitle='Tester' \
  -d groupIds= \
  -d organizationIds= \
  -d roleIds= \
  -d userGroupIds= \
  -d sendEmail=false
\end{verbatim}

Great! Now you've seen how to invoke Liferay's JSON web services from
JavaScript, URL, and cURL.

\subsection{Related Topics}\label{related-topics-137}

\href{/docs/7-0/tutorials/-/knowledge_base/t/invoking-json-web-services}{Invoking
JSON Web Services}

\href{/docs/7-0/tutorials/-/knowledge_base/t/json-web-services-invoker}{JSON
Web Services Invoker}

\href{/docs/7-0/tutorials/-/knowledge_base/t/invoking-remote-services}{Invoking
Remote Services}

\section{Configuring JSON Web
Services}\label{configuring-json-web-services}

JSON web services are enabled in Liferay by default. If you need to
disable them, specify this portal property setting in a
\texttt{portal-ext.properties} file:

\begin{verbatim}
json.web.service.enabled=false
\end{verbatim}

This tutorial presents other such properties that you can use to
fine-tune exactly how JSON web services work in your Liferay instance.
You can find these, and other properties, in
\href{@platform-ref@/7.0-latest/propertiesdoc/portal.properties.html}{the
portal properties reference documentation}. As with the preceding
property, you should set portal properties in a
\texttt{portal-ext.properties} file.

First, you'll learn about setting whether JSON web services are
discoverable via the API page.

\subsection{Discoverability}\label{discoverability}

By default, JSON web services are discoverable via the API page at
\texttt{http://{[}address{]}:{[}port{]}/api/jsonws}. To disable this,
set the following property:

\begin{verbatim}
jsonws.web.service.api.discoverable=false
\end{verbatim}

Next, you'll learn how to disable HTTP methods.

\subsection{Disabling HTTP Methods}\label{disabling-http-methods}

When strict HTTP method mode is enabled, you can filter web service
access based on HTTP methods used by the services. For example, you can
set your Liferay instance's JSON web services to work in read-only mode
by disabling HTTP methods other than \texttt{GET}. For example:

\begin{verbatim}
jsonws.web.service.invalid.http.methods=DELETE,POST,PUT
\end{verbatim}

With this setting, all requests that use \texttt{DELETE}, \texttt{POST},
or \texttt{PUT} HTTP methods are ignored.

Next, you'll learn how to restrict public access to exposed JSON APIs.

\subsection{Strict HTTP Methods}\label{strict-http-methods}

All JSON web services are mapped to either \texttt{GET} or \texttt{POST}
HTTP methods. If a service method name starts with \texttt{get},
\texttt{is} or \texttt{has}, the service is assumed to be read-only and
is bound to the \texttt{GET} method. Otherwise, it's bound to
\texttt{POST}.

By default, Liferay doesn't check \texttt{HTTP} methods when invoking a
service call; it works in non-strict http method mode, where services
may be invoked using any HTTP method. If you need the strict mode, you
can set it as follows:

\begin{verbatim}
jsonws.web.service.strict.http.method=true
\end{verbatim}

When using strict mode, you must use the correct HTTP methods to calll
service methods. When strict HTTP mode is enabled, you still might need
to disable HTTP methods. You'll learn how next.

\subsection{Controlling Public Access}\label{controlling-public-access}

Each service method knows whether a given user has permission to invoke
the chosen action. If you're concerned about security, you can restrict
access to exposed JSON APIs by explicitly permitting or restricting
certain JSON web service paths.

The property \texttt{jsonws.web.service.paths.includes} denotes patterns
for JSON web service action paths that are allowed. Set a blank pattern
to allow any service action path.

The property \texttt{jsonws.web.service.paths.excludes} denotes patterns
for JSON web service action paths that aren't allowed even if they match
one of the patterns set in \texttt{jsonws.web.service.paths.includes}.

Note that these properties support wildcards. For example, if you set
\texttt{jsonws.web.service.paths.includes=get*,has*,is*}, Liferay makes
all read-only JSON methods publicly accessible. All other JSON methods
are secured. To disable access to all exposed methods, you can leave the
right side of the \texttt{=} symbol empty. To enable access to all
exposed methods, specify \texttt{*}. Remember that if a path matches
both the \texttt{jsonws.web.service.paths.includes} and
\texttt{jsonws.web.service.paths.excludes} properties, the
\texttt{jsonws.web.service.paths.excludes} property takes precedence.

\subsection{Related Topics}\label{related-topics-138}

\href{/docs/7-0/tutorials/-/knowledge_base/t/registering-json-web-services}{Registering
JSON Web Services}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-remote-services}{Creating
Remote Services}

\href{/docs/7-0/tutorials/-/knowledge_base/t/invoking-remote-services}{Invoking
Remote Services}

\section{SOAP Web Services}\label{soap-web-services}

You can access Liferay's web services via Simple Object Access Protocol
(SOAP) over HTTP. The packaging protocol is SOAP, and the transport
protocol is HTTP.

\noindent\hrulefill

\textbf{Note:} An authentication token must accompany each Liferay web
service invocation. For details, see the tutorial on
\href{/docs/7-0/tutorials/-/knowledge_base/t/service-security-layers}{Service
Security Layers}.

\noindent\hrulefill

As an example, consider some example SOAP web service clients for
Liferay's \texttt{Company}, \texttt{User}, and \texttt{UserGroup}
services that perform these tasks:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  List each user group the user with the screenname \emph{test} belongs
  to.
\item
  Add a new user group named \emph{MyGroup}.
\item
  Add your Liferay instance's administrative user to the new user group.
  For demonstration purposes, you'll use an administrative user whose
  email address is \texttt{test@example.com}.
\end{enumerate}

You'll use these SOAP related classes:

\begin{verbatim}
import com.liferay.portal.kernel.model.CompanySoap;
import com.liferay.portal.kernel.model.CompanySoap;
import com.liferay.portal.kernel.model.UserGroupSoap;
import com.liferay.portal.kernel.model.UserGroupSoap;
import com.liferay.portal.service.http.CompanyServiceSoap;
import com.liferay.portal.service.http.CompanyServiceSoapServiceLocator;
import com.liferay.portal.service.http.UserGroupServiceSoap;
import com.liferay.portal.service.http.UserGroupServiceSoapServiceLocator;
import com.liferay.portal.service.http.UserServiceSoap;
import com.liferay.portal.service.http.UserServiceSoapServiceLocator;
\end{verbatim}

Can you see the naming convention for SOAP related classes? These
classes have\\
either \texttt{-ServiceSoapServiceLocator}, \texttt{-ServiceSoap}, or
\texttt{-Soap} as suffixes. The \texttt{-ServiceSoapServiceLocator}
class finds the \texttt{-ServiceSoap} class via the service's URL you
provide. The \texttt{-ServiceSoap} class is the interface to the
services specified in the Web Services Definition Language (WSDL) file
for each service. The \texttt{-Soap} classes are the serializable
implementations of the models.

So how do you determine the URLs for these services? This is a most
excellent question! You can see a list of the services deployed on your
Liferay instance by opening your browser to the following URL:

\begin{verbatim}
http://[host]:[port]/api/axis
\end{verbatim}

Note that this URL only lists services in the portal context. To learn
how to find services in other contexts in your Liferay instance, see the
SOAP sections in the tutorial
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-remote-services}{Creating
Remote Services}.

Regardless of the context you're viewing SOAP services in, each web
service is listed with its name, operations, and a link to its WSDL
file. For example, here's the list of secure web services listed for
\texttt{UserGroup}:

\begin{itemize}
\tightlist
\item
  \texttt{Portal\_UserGroupService} (wsdl)

  \begin{itemize}
  \tightlist
  \item
    \texttt{addGroupUserGroups}
  \item
    \texttt{addTeamUserGroups}
  \item
    \texttt{addUserGroup}
  \item
    \texttt{deleteUserGroup}
  \item
    \texttt{fetchUserGroup}
  \item
    \texttt{getUserGroup}
  \item
    \texttt{getUserGroups}
  \item
    \texttt{getUserUserGroups}
  \item
    \texttt{unsetGroupUserGroups}
  \item
    \texttt{unsetTeamUserGroups}
  \item
    \texttt{updateUserGroup}
  \end{itemize}
\end{itemize}

Note that some of these methods are overloaded.

Liferay uses Service Builder to automatically generate JSON and SOAP web
service interfaces. If you haven't used Service Builder before, see its
\href{/docs/7-0/tutorials/-/knowledge_base/t/what-is-service-builder}{introductory
tutorial}.

The WSDL file is written in XML and provides a model for describing and
locating the web service. Here's a WSDL excerpt of the
\texttt{addUserGroup} operation of \texttt{UserGroup}:

\begin{verbatim}
<wsdl:operation name="addUserGroup" parameterOrder="name description">
    <wsdl:input message="intf:addUserGroupRequest" name="addUserGroupRequest"/>
    <wsdl:output message="intf:addUserGroupResponse" name="addUserGroupResponse"/>
</wsdl:operation>
\end{verbatim}

To use the service, you pass in the WSDL URL along with your login
credentials to the SOAP service locator for your service. The next
section shows you an example of this.

\subsection{SOAP Java Client}\label{soap-java-client}

Now you'll learn how to invoke Liferay's SOAP web services. As an
example, you'll do this by setting up a Java web services client in
Eclipse. You can use Eclipse's Web Service Client wizard to either
create a new web service client project or add a client to an existing
project. You must add a new web service client to your project for each
service that you want to consume in your client code. For this example,
you'll build a web service client to invoke Liferay's \texttt{Company},
\texttt{User}, and \texttt{UserGroup} services.

To create a new web service client project in Eclipse, click \emph{File}
→ \emph{New} → \emph{Other\ldots{}}, then expand the \emph{Web Services}
category. Select \emph{Web Service Client}.

For each client you create, you're prompted to enter the service
definition (WSDL) for the desired service. Since your example web
service client needs Liferay's \texttt{Company}, \texttt{User}, and
\texttt{UserGroup} services, enter the following WSDLs:

\begin{verbatim}
http://localhost:8080/api/axis/Portal_CompanyService?wsdl

http://localhost:8080/api/axis/Portal_UserService?wsdl

http://localhost:8080/api/axis/Portal_UserGroupService?wsdl
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/api-web-svc-wsdl.png}
\caption{Service Definition}
\end{figure}

When you specify a WSDL, Eclipse automatically adds the auxiliary files
and libraries required to consume that web service. After you've created
your web service client project using one of the above WSDLs, you need
to create additional clients in the project using the remaining WSDLs.
To create an additional client in an existing project, right-click on
the project and select \emph{New} → \emph{Other} → \emph{Web Service
Client}. Click \emph{Next}, enter the WSDL, and complete the wizard.

The following code locates and invokes operations to create a new user
group named \texttt{MyUserGroup} and add a user with the screen name
\emph{test} to it. Create a \texttt{LiferaySoapClient.java} file in your
web service client project and add this code to it. If you create this
class in a package other than the one that's specified in this code,
replace the package with your package. To run the client from Eclipse,
make sure that your Liferay server is running, right-click the
\texttt{LiferaySoapClient.java} class, and select \emph{Run as Java
application}. Check your console to check that your service calls
succeeded.

\begin{verbatim}
package com.liferay.test;

import java.net.URL;

import com.liferay.portal.kernel.model.CompanySoap;
import com.liferay.portal.kernel.model.UserGroupSoap;
import com.liferay.portal.service.http.CompanyServiceSoap;
import com.liferay.portal.service.http.CompanyServiceSoapServiceLocator;
import com.liferay.portal.service.http.UserGroupServiceSoap;
import com.liferay.portal.service.http.UserGroupServiceSoapServiceLocator;
import com.liferay.portal.service.http.UserServiceSoap;
import com.liferay.portal.service.http.UserServiceSoapServiceLocator;

public class LiferaySoapClient {

    public static void main(String[] args) {

        try {
            String remoteUser = "test";
            String password = "test";
            String virtualHost = "localhost";

            String groupName = "MyUserGroup";

            String serviceCompanyName = "Portal_CompanyService";
            String serviceUserName = "Portal_UserService";
            String serviceUserGroupName = "Portal_UserGroupService";

            long userId = 0;

            // Locate the Company
            CompanyServiceSoapServiceLocator locatorCompany =
                new CompanyServiceSoapServiceLocator();

            CompanyServiceSoap soapCompany =
                locatorCompany.getPortal_CompanyService(
                    _getURL(remoteUser, password, serviceCompanyName,
                            true));

            CompanySoap companySoap =
                soapCompany.getCompanyByVirtualHost(virtualHost);

            // Locate the User service
            UserServiceSoapServiceLocator locatorUser =
                new UserServiceSoapServiceLocator();
            UserServiceSoap userSoap = locatorUser.getPortal_UserService(
                _getURL(remoteUser, password, serviceUserName, true));

            // Get the ID of the remote user
            userId = userSoap.getUserIdByScreenName(
                companySoap.getCompanyId(), remoteUser);
            System.out.println("userId for user named " + remoteUser +
                    " is " + userId);

            // Locate the UserGroup service
            UserGroupServiceSoapServiceLocator locator =
                new UserGroupServiceSoapServiceLocator();
            UserGroupServiceSoap usergroupsoap =
                locator.getPortal_UserGroupService(
                    _getURL(remoteUser, password, serviceUserGroupName,
                            true));

            // Get the user's user groups
            UserGroupSoap[] usergroups = usergroupsoap.getUserUserGroups(
                    userId);

            System.out.println("User groups for userId " + userId + " ...");
            for (int i = 0; i < usergroups.length; i++) {
                System.out.println("\t" + usergroups[i].getName());
            }

            // Adds the user group if it does not already exist
            String groupDesc = "My new user group";
            UserGroupSoap newUserGroup = null;

            boolean userGroupAlreadyExists = false;
            try {
                newUserGroup = usergroupsoap.getUserGroup(groupName);
                if (newUserGroup != null) {
                    System.out.println("User with userId " + userId +
                            " is already a member of UserGroup " +
                                    newUserGroup.getName());
                    userGroupAlreadyExists = true;
                }
            } catch (Exception e) {
                // Print cause, but continue
                System.out.println(e.getLocalizedMessage());
            }

            if (!userGroupAlreadyExists) {
                newUserGroup = usergroupsoap.addUserGroup(
                        groupName, groupDesc);
                System.out.println("Added user group named " + groupName);

                long users[] = {userId};
                userSoap.addUserGroupUsers(newUserGroup.getUserGroupId(),
                        users);
            }

            // Get the user's user groups
            usergroups = usergroupsoap.getUserUserGroups(userId);

            System.out.println("User groups for userId " + userId + " ...");
            for (int i = 0; i < usergroups.length; i++) {
                System.out.println("\t" + usergroups[i].getName());
            }
        }
        catch (Exception e) {
            e.getLocalizedMessage();
        }
    }

        private static URL _getURL(String remoteUser, String password,
                        String serviceName, boolean authenticate)
                        throws Exception {

                // Unauthenticated url
                String url = "http://localhost:8080/api/axis/" + serviceName;

                // Authenticated url
                if (authenticate) {
                        url = "http://" + remoteUser + ":" + password
                                        + "@localhost:8080/api/axis/"
                                        + serviceName;
                }

                return new URL(url);
        }

}
\end{verbatim}

Running this client should produce output like this:

\begin{verbatim}
userId for user named test is 10196
User groups for user 10196 ...
java.rmi.RemoteException: No UserGroup exists with the key {companyId=10154,
name=MyUserGroup}
Added user group named
Added user to user group named MyUserGroup
User groups for user 10196 ...
    MyUserGroup
\end{verbatim}

The output tells you the user had no groups, but was added to the user
group \texttt{MyUserGroup}.

You might be thinking, ``But an error was thrown! Something is wrong!''
Yes, an error is thrown (\texttt{java.rmi.RemoteException:}), but you
can sit here as cool as an ice cream sandwich all the same. The
exception is thrown because the \texttt{UserGroup} check is invoked
before the \texttt{UserGroup} is created. Because the very next line of
the output says \texttt{Added\ user\ group\ named...}, you're okay. The
SOAP web service invocations worked!

Here are a few things to note about this example:

\begin{itemize}
\tightlist
\item
  Authentication is done using HTTP Basic Authentication, which isn't
  appropriate for a production environment since the password is
  unencrypted. It's simply used for convenience in this example. In
  production, you should use SSL. Refer to Liferay's
  \href{@platform-ref@/7.0-latest/propertiesdoc/portal.properties.html}{\texttt{portal.properties}}
  file and look up the \texttt{company.security.auth.requires.https} and
  \texttt{web.server.protocol} properties for more information.
\item
  The screen name and password are passed in the URL as credentials.
\item
  The name of the service (e.g.~\texttt{Portal\_UserGroupService}) is
  specified at the end of the URL. Remember that the service name can be
  found in the web service listing.
\end{itemize}

The operations \texttt{getCompanyByVirtualHost()},
\texttt{getUserIdByScreenName()}, \texttt{getUserUserGroups()},
\texttt{addUserGroup()} and \texttt{addUserGroupUsers()} are specified
for the \texttt{-ServiceSOAP} classes \texttt{CompanyServiceSoap},
\texttt{UserServiceSoap} and \texttt{UserGroupServiceSoap} in the WSDL
files. Information on parameter types, parameter order, request type,
response type, and return type are conveniently specified in the WSDL
for each Liferay web service. It's all there for you!

Next, you'll learn how to implement a web service client in PHP.

\subsection{SOAP PHP Client}\label{soap-php-client}

You can write your client in any language that supports web services
invocation. The following example code invokes the same operations as
before, but uses PHP and a PHP SOAP client instead of Java:

\begin{verbatim}
<?php
    $userGroupName = "MyUserGroup2";
    $userName = "test";
    $clientOptions = array('login' => $userName, 'password' => 'test');

    // Add user group
    $userGroupClient = new 
        SoapClient(
            "http://localhost:8080/api/axis/Portal_UserGroupService?wsdl", 
            $clientOptions);
    $userGroup = $userGroupClient->addUserGroup($userGroupName,
        "This user group was created by the PHP client! ");
    print ("User group ID is $userGroup->userGroupId ");

    // Add user to user group
    $companyClient = new SoapClient(
        "http://localhost:8080/api/axis/Portal_CompanyService?wsdl",
        $clientOptions);
    $company = $companyClient->getCompanyByVirtualHost("localhost");
    $userClient = new SoapClient(
        "http://localhost:8080/api/axis/Portal_UserService?wsdl",
        $clientOptions);
    $userId = $userClient->getUserIdByScreenName($company->companyId,
        $userName);
    print ("User ID for $userName is $userId ");
    $users = array($userId);
    $userClient->addUserGroupUsers($userGroup->userGroupId, $users);

    // Print the user groups to which the user belongs
    $userGroups = $userGroupClient->getUserUserGroups($userId);
    print ("User groups for user $userId ... ");
    foreach($userGroups as $ug)
        print ("$ug->name, $ug->userGroupId ")
?>
\end{verbatim}

Remember, you can implement a web service client in any language that
supports SOAP web services.

\subsection{Related Topics}\label{related-topics-139}

\href{/docs/7-0/tutorials/-/knowledge_base/t/service-security-layers}{Service
Security Layers}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-remote-services}{Creating
Remote Services}

\href{/docs/7-0/tutorials/-/knowledge_base/t/invoking-remote-services}{Invoking
Remote Services}

\href{/docs/7-0/tutorials/-/knowledge_base/t/what-is-service-builder}{What
is Service Builder?}

\section{JAX-WS and JAX-RS}\label{jax-ws-and-jax-rs}

Liferay supports
\href{https://en.wikipedia.org/wiki/Java_API_for_XML_Web_Services}{JAX-WS}
and
\href{https://en.wikipedia.org/wiki/Java_API_for_RESTful_Web_Services}{JAX-RS}
via the \href{http://cxf.apache.org/}{Apache CXF} implementation. Apps
can publish JAX web services to the CXF endpoints defined in your
Liferay instance. CXF endpoints are effectively context paths the JAX
web services are deployed to and accessible from. To publish any kind of
JAX web service, one or more CXF endpoints must be defined in your
Liferay instance. To access JAX web services, an \emph{extender} must
also be configured in your Liferay instance. Extenders specify where the
services are deployed and whether they are augmented with handlers,
providers, and so on. There are two types of extenders:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{SOAP Extenders:} Required to publish JAX-WS web services. Each
  SOAP extender can deploy the services to one or more CXF endpoints and
  can use a set of
  \href{https://jax-ws.java.net/articles/handlers_introduction.html}{JAX-WS
  handlers} to augment the services.
\item
  \textbf{REST Extenders:} Required to publish JAX-RS web services. REST
  extenders for JAX-RS services are analogous to SOAP extenders for
  JAX-WS services. To create JAX-RS services that can work across
  different JAX-RS implementations, you must provide an implementation
  of \texttt{javax.ws.rs.core.Application} to the OSGi framework. You
  can do this by registering an instance of this implementation as an
  OSGi service via \texttt{BundleContext} or the Declarative Services
  \texttt{@Component} annotation. The JAX-RS application encompasses the
  services that represent JAX-RS endpoints and the services that
  represent JAX-RS providers. By specifying OSGi filters in a REST
  extender, you can also dynamically add endpoints or JAX-RS providers
  to a JAX-RS application.
\end{enumerate}

SOAP extenders and REST extenders are subsystems that track the services
the app developer registers in OSGi (those matching the provided
\href{https://osgi.org/javadoc/r6/core/org/osgi/framework/Filter.html}{OSGi
filters}), and deploy them under the specified CXF endpoints. For
example, if you create the CXF endpoints \texttt{/soap} and
\texttt{/rest}, you could later create a REST extender for
\texttt{/rest} that publishes REST applications, and a SOAP extender for
\texttt{/soap} that publishes SOAP services. Of course, this is only a
rough example: you can fine tune things to your liking.

CXF endpoints and both types of extenders can be created
programmatically or with Liferay's Control Panel. This tutorial shows
you how to do both, and then shows you how to publish JAX-WS and JAX-RS
web services. The following topics are covered:

\begin{itemize}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/jax-ws-and-jax-rs\#configuring-endpoints-and-extenders-with-the-control-panel}{Configuring
  Endpoints and Extenders with the Control Panel}

  \begin{itemize}
  \item
    \href{/docs/7-0/tutorials/-/knowledge_base/t/jax-ws-and-jax-rs\#cxf-endpoints}{CXF
    Endpoints}
  \item
    \href{/docs/7-0/tutorials/-/knowledge_base/t/jax-ws-and-jax-rs\#soap-extenders}{SOAP
    Extenders}
  \item
    \href{/docs/7-0/tutorials/-/knowledge_base/t/jax-ws-and-jax-rs\#rest-extenders}{REST
    Extenders}
  \end{itemize}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/jax-ws-and-jax-rs\#configuring-endpoints-and-extenders-programmatically}{Configuring
  Endpoints and Extenders Programmatically}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/jax-ws-and-jax-rs\#publishing-jax-ws-web-services}{Publishing
  JAX-WS Web Services}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/jax-ws-and-jax-rs\#publishing-jax-rs-web-services}{Publishing
  JAX-RS Web Services}
\end{itemize}

\subsection{Configuring Endpoints and Extenders with the Control
Panel}\label{configuring-endpoints-and-extenders-with-the-control-panel}

Liferay's Control Panel lets administrators configure endpoints and
extenders for JAX web services. Note that you must be an administrator
in your Liferay instance to access the settings here. First, you'll
learn how to create CXF endpoints.

\subsubsection{CXF Endpoints}\label{cxf-endpoints}

To configure a CXF endpoint with the Control Panel, first go to
\emph{Control Panel} → \emph{Configuration} → \emph{System Settings} →
\emph{Foundation}. Then select \emph{CXF Endpoints} from the table. If
there are any existing CXF endpoints, they're shown here. To add a new
one, select the \emph{Add} button
(\includegraphics{./images/icon-add.png}) in the lower right-hand
corner. The form that appears lets you configure a new CXF endpoint by
filling out these fields:

\begin{itemize}
\item
  \textbf{Context path:} The path the JAX web services are deployed to
  on the Liferay server. For example, if you define the context path
  \texttt{/web-services}, any services deployed there are available at
  \texttt{http://your-server:your-port/o/web-services}.
\item
  \textbf{\texttt{AuthVerifier} properties:} Any properties defined here
  are passed as-is to the \texttt{AuthVerifier} filter. See the
  \href{/docs/7-0/deploy/-/knowledge_base/d/authentication-verifiers}{\texttt{AuthVerifier}
  documentation} for more details.
\item
  \textbf{Required extensions:} CXF normally loads its default extension
  classes, but in some cases you can override them to replace the
  default behavior. In most cases, you can leave this field blank:
  overriding extensions isn't common. By specifying custom extensions
  here via
  \href{https://osgi.org/javadoc/r6/core/org/osgi/framework/Filter.html}{OSGi
  filters}, Liferay waits until those extensions are registered in the
  OSGi framework before creating the CXF servlet and passing the
  extensions to the servlet.
\end{itemize}

\begin{figure}
\centering
\includegraphics{./images/cxf-endpoint-form.png}
\caption{Fill out this form to create a CXF endpoint.}
\end{figure}

Next, you'll learn how to use the Control Panel to create SOAP extenders
for JAX-WS web services.

\subsubsection{SOAP Extenders}\label{soap-extenders}

For an app to deploy JAX-WS web services, you must configure a SOAP
extender. To configure a SOAP extender with the Control Panel, first go
to \emph{Control Panel} → \emph{Configuration} → \emph{System Settings}
→ \emph{Foundation}. Then select \emph{SOAP Extenders} from the table.
If there are any existing SOAP extenders, they're shown here. To add a
new one, select the \emph{Add} button
(\includegraphics{./images/icon-add.png}) in the lower right-hand
corner. The form that appears lets you configure a new SOAP extender by
filling out these fields:

\begin{itemize}
\item
  \textbf{Context paths:} Specify at least one CXF endpoint here. This
  is where the services affected by this extender are deployed. In the
  preceding CXF endpoint example, this would be \texttt{/web-services}.
  Note that you can specify more than one CXF endpoint here.
\item
  \textbf{jax.ws.handler.filters:} Here you can specify a set of
  \href{https://osgi.org/javadoc/r6/core/org/osgi/framework/Filter.html}{OSGi
  filters} that select certain services registered in the OSGi
  framework. The selected services should implement JAX-WS handlers and
  augment the JAX-WS services specified in the
  \emph{jax.ws.service.filters} property. These JAX-WS handlers apply to
  each service selected in this extender.
\item
  \textbf{jax.ws.service.filters:} Here you can specify a set of OSGi
  filters that select the services registered in the OSGi framework that
  will be deployed to the CXF endpoints. These OSGi services must be
  \href{https://docs.oracle.com/javaee/7/tutorial/jaxws001.htm}{proper
  JAX-WS services}.
\item
  \textbf{soap.descriptor.builder:} Leave this option empty to use
  JAX-WS annotations to describe the SOAP service. To use a different
  way to describe the SOAP service, you can provide an OSGi filter here
  that selects an implementation of
  \texttt{com.liferay.portal.remote.soap.extender.SoapDescriptorBuilder}.
\end{itemize}

\begin{figure}
\centering
\includegraphics{./images/soap-extenders-form.png}
\caption{Fill out this form to create a SOAP extender.}
\end{figure}

Next, you'll learn how to use the Control Panel to create REST extenders
for JAX-RS web services.

\subsubsection{REST Extenders}\label{rest-extenders}

To configure a REST extender with the Control Panel, first go to
\emph{Control Panel} → \emph{Configuration} → \emph{System Settings} →
\emph{Foundation}. Then select \emph{REST Extender} from the table. If
there are any existing REST extenders, they're shown here. To add a new
one, select the \emph{Add} button
(\includegraphics{./images/icon-add.png}) in the lower right-hand
corner. The form that appears lets you configure a new REST extender by
filling out these fields:

\begin{itemize}
\item
  \textbf{Context paths:} Specify at least one CXF endpoint here. This
  is where the services affected by this extender are deployed. In the
  preceding CXF endpoint example, this would be \texttt{/web-services}.
  Note that you can specify more than one CXF endpoint here. This works
  the same way as the \emph{Context paths} setting in SOAP Extenders.
\item
  \textbf{jax.rs.application.filters:} Here you can specify a set of
  OSGi filters that select services that implement
  \texttt{javax.ws.rs.core.Application}. These JAX-RS applications are
  deployed to the CXF endpoints specified in the \emph{Context paths}
  property.
\item
  \textbf{jsx.rs.provider.filters:} Here you can specify a set of OSGi
  filters that select services registered in the OSGi framework. The
  selected services should implement any of the interfaces supported by
  JAX-RS for providers. These JAX-RS providers are added to the JAX-RS
  application as if they had been returned by the
  \texttt{getSingletons()} method of
  \texttt{javax.ws.rs.core.Application}. The following links list some
  of the supported JAX-RS providers:

  \begin{itemize}
  \tightlist
  \item
    \href{https://jersey.java.net/documentation/latest/message-body-workers.html}{JAX-RS
    Entity Providers}
  \item
    \href{https://jersey.java.net/documentation/latest/filters-and-interceptors.html}{Filters
    and Interceptors}
  \end{itemize}
\item
  \textbf{jax.rs.service.filters:} Here you can specify a set of OSGi
  filters that selects services registered in the OSGi framework that
  are valid JAX-RS endpoints. These endpoints are added to the JAX-RS
  application as if they had been returned by the
  \texttt{getSingletons()} method of
  \texttt{javax.ws.rs.core.Application}.
\end{itemize}

\begin{figure}
\centering
\includegraphics{./images/rest-extender-form.png}
\caption{Fill out this form to create a REST extender.}
\end{figure}

Next, you'll learn how to configure endpoints and extenders
programmatically.

\subsection{Configuring Endpoints and Extenders
Programmatically}\label{configuring-endpoints-and-extenders-programmatically}

To configure endpoints or extenders programmatically, you must use
Liferay's configurator extender. The configurator extender provides a
way for OSGi modules to deploy default configuration values. Modules
that use the configurator extender must provide a
\texttt{ConfigurationPath} header that points to the configuration
files' location inside the module. For example, the following
configuration sets the \texttt{ConfigurationPath} to
\texttt{src/main/resources/configuration}:

\begin{verbatim}
Bundle-Name: Liferay Export Import Service JAX-WS
Bundle-SymbolicName: com.liferay.exportimport.service.jaxws
Bundle-Version: 1.0.0
Liferay-Configuration-Path: /configuration
Include-Resource: configuration=src/main/resources/configuration
Liferay-Releng-Module-Group-Description:
Liferay-Releng-Module-Group-Title: Data Management
\end{verbatim}

\noindent\hrulefill

\textbf{Note:} If you're using any version before Liferay CE GA4 or
Liferay DXP Fixpack 22, the \texttt{Liferay-Configuration-Path}
directive above is \texttt{Configuration-Path}. As of
\href{https://issues.liferay.com/browse/LPS-62571}{LPS-62571},
Liferay-specific Bnd instructions are prefixed with \texttt{Liferay} to
avoid conflicts.

\noindent\hrulefill

There are two different configuration types in
\href{https://osgi.org/javadoc/r4v42/org/osgi/service/cm/ConfigurationAdmin.html}{OSGi's
\texttt{ConfigurationAdmin}}: single, and factory. Factory
configurations can have several configuration instances per factory
name. Liferay DXP uses factory configurations. You must provide a
factory configuration's default values in a \texttt{*.properties} file.
In this properties file, use a suffix on the end of the PID (persistent
identifier) and then provide your settings. For example, the following
code uses the \texttt{-staging} suffix on the PID and creates a CXF
endpoint at the context path \texttt{/staging-ws}:

\begin{verbatim}
com.liferay.portal.remote.cxf.common.configuration.CXFEndpointPublisherConfiguration-staging.properties:

contextPath=/staging-ws
\end{verbatim}

As another example, the following code uses the suffix
\texttt{-stagingjaxws} on the PID and creates a SOAP extender at the
context path \texttt{/staging-ws}. This code also includes settings for
the configuration fields \texttt{jaxWsHandlerFilterStrings} and
\texttt{jaxWsServiceFilterStrings}:

\begin{verbatim}
com.liferay.portal.remote.soap.extender.configuration.SoapExtenderConfiguration-stagingjaxws.properties:

contextPaths=/staging-ws
jaxWsHandlerFilterStrings=(staging.jax.ws.handler=true)
jaxWsServiceFilterStrings=(staging.jax.ws.service=true)
\end{verbatim}

You must then use these configuration fields in the configuration class.
For example, the \texttt{SoapExtenderConfiguration} interface below
contains the configuration fields \texttt{contextPaths},
\texttt{jaxWsHandlerFilterStrings}, and
\texttt{jaxWsServiceFilterStrings}:

\begin{verbatim}
@ExtendedObjectClassDefinition(
    category = "foundation", factoryInstanceLabelAttribute = "contextPaths"
)
@Meta.OCD(
    factory = true,
    id = "com.liferay.portal.remote.soap.extender.configuration.SoapExtenderConfiguration",
    localization = "content/Language", name = "soap.extender.configuration.name"
)
public interface SoapExtenderConfiguration {

    @Meta.AD(required = false)
    public String[] contextPaths();

    @Meta.AD(name = "jax.ws.handler.filters", required = false)
    public String[] jaxWsHandlerFilterStrings();

    @Meta.AD(name = "jax.ws.service.filters", required = false)
    public String[] jaxWsServiceFilterStrings();

    @Meta.AD(name = "soap.descriptor.builder", required = false)
    public String soapDescriptorBuilderFilter();

}
\end{verbatim}

You can use similar techniques to create REST extenders. For example,
see
\href{https://github.com/liferay/liferay-portal/blob/7.0.x/modules/apps/foundation/portal-remote/portal-remote-rest-extender/src/main/java/com/liferay/portal/remote/rest/extender/configuration/RestExtenderConfiguration.java}{the
\texttt{RestExtenderConfiguration} interface} in Liferay's source code.

Next, you'll learn how to publish JAX-WS web services.

\subsection{Publishing JAX-WS Web
Services}\label{publishing-jax-ws-web-services}

To publish JAX-WS web services via SOAP in a 7.0 module, annotate the
class and its methods with standard JAX-WS annotations, and then
register it as a service in the OSGi framework. For example, the
following class uses the \texttt{@WebService} annotation for the class
and \texttt{@WebMethod} annotations for its methods. You must also set
the \texttt{jaxws} property to \texttt{true} in the OSGi
\texttt{@Component} annotation:

\begin{verbatim}
import javax.jws.WebMethod;
import javax.jws.WebService;

import org.osgi.service.component.annotations.Component;

@Component(
    immediate = true, property = "jaxws=true", service = Calculator.class
)
@WebService
public class Calculator {

    @WebMethod
    public int divide(int a, int b) {
        return a / b;
    }

    @WebMethod
    public int multiply(int a, int b) {
        return a * b;
    }

    @WebMethod
    public int subtract(int a, int b) {
        return a - b;
    }

    @WebMethod
    public int sum(int a, int b) {
        return a + b;
    }

}
\end{verbatim}

You should also make sure that you include \texttt{org.osgi.core} and
\texttt{org.osgi.service.component.annotations} as dependencies to your
project.

Next, you'll learn how to publish JAX-RS web services.

\subsection{Publishing JAX-RS Web
Services}\label{publishing-jax-rs-web-services}

You can publish JAX-RS web services in a Liferay module the same way you
would outside of Liferay. You must also, however, register the class in
the OSGi framework. Note that the services must match the OSGi filters
provided in the respective extenders. This is how the instances that
become services are selected. There's no classpath scanning or other
automatic mechanism at work here: it's the developer's responsibility to
register the services in the OSGi framework.

The following example registers an OSGi component that publishes a
JAX-RS web service at \texttt{/application-path/hello}. Get requests to
this web service return a simple \emph{``Hello!''}:

\begin{verbatim}
import org.osgi.service.component.annotations.Component;

import javax.ws.rs.ApplicationPath;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.Application;
import java.util.Collections;
import java.util.Set;

@Component(immediate = true, service = Application.class)
@ApplicationPath("/application-path")
public class RestEndpoint extends Application {

    public Set<Object> getSingletons() {
        return Collections.<Object>singleton(this);
    }

    @GET
    @Path("/hello")
    @Produces("text/text")
    public String sayHello() {
        return "Hello!";
    }
}
\end{verbatim}

Nice work! Now you know how JAX-WS and JAX-RS works in Liferay.

\subsection{Related Topics}\label{related-topics-140}

\href{/docs/7-0/tutorials/-/knowledge_base/t/service-builder-web-services}{Service
Builder Web Services}

\section{Liferay WebSocket
Whiteboard}\label{liferay-websocket-whiteboard}

Modern web apps exchange large amounts of data with clients. The
WebSockets specification lets this exchange occur over a full-duplex
connection that remains open, therefore enabling real-time
communication. This approach is more efficient than techniques like long
polling, which open two connections to emulate a full-duplex connection.
\href{https://www.websocket.org/aboutwebsocket.html}{Click here} for
more information on WebSockets.

Since WebSockets are ubiquitous throughout the web and in all modern
browsers, you need a way to register new WebSocket endpoints in Liferay
DXP. The \emph{Liferay WebSocket Whiteboard} lets you define new
WebSocket endpoints as regular OSGi services. This tutorial shows you
how to do this. Onward!

\subsection{Configuring a Non-Liferay OSGi
Container}\label{configuring-a-non-liferay-osgi-container}

There may be instances where you want to use a Liferay OSGi module in a
non-Liferay OSGi container, and need to define a WebSocket endpoint. To
do this, you must register a \texttt{javax.servlet.ServletContext}
service with the property \texttt{websocket.active} set to
\texttt{true}:

\begin{verbatim}
Dictionary<String, Object> servletContextProps = new Hashtable<String, Object>();
servletContextProps.put("websocket.active", Boolean.TRUE);

bundleContext.registerService(ServletContext.class, servletContext, servletContextProps);
\end{verbatim}

You must also configure the \texttt{javax.websocket-api}'s
\texttt{ServiceLoader}. You can do this by creating your own module as a
\texttt{javax.websocket-api} fragment. Here's an example of a manifest
for such a module:

\begin{verbatim}
Fragment-Host: javax.websocket-api

Require-Capability:\
    osgi.serviceloader;\

filter:='(osgi.serviceloader=javax.websocket.server.ServerEndpointConfig$Configurator)';\
        cardinality:=multiple,\
    osgi.extender;\
        filter:='(osgi.extender=osgi.serviceloader.processor)'
\end{verbatim}

Next, you'll learn how to define a new WebSocket server endpoint in a
Liferay OSGi container.

\subsection{Configuring a Liferay OSGi
Container}\label{configuring-a-liferay-osgi-container}

Defining a new WebSocket server endpoint in Liferay DXP is
straightforward. Follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  If you're running Liferay Portal 7.0.2 GA3 or Liferay Digital
  Enterprise 7.0 Fix Pack 7 or earlier, add the following property to
  your \texttt{portal-ext.properties} file. Otherwise, you can skip this
  and move on to the next step.

\begin{verbatim}
 module.framework.system.packages.extra=\
     com.ibm.crypto.provider,\
     com.ibm.db2.jcc,\
     com.microsoft.sqlserver.jdbc,\
     com.mysql.jdbc,\
     com.p6spy.engine.spy,\
     com.sun.security.auth.module,\
     com.sybase.jdbc4.jdbc,\
     oracle.jdbc,\
     org.postgresql,\
     org.apache.naming.java,\
     org.hsqldb.jdbc,\
     org.mariadb.jdbc,\
     sun.misc,\
     sun.net.util,\
     sun.security.provider,\
     javax.websocket;version="1.1.0",\
     javax.websocket.server;version="1.1.0"
\end{verbatim}
\item
  Deploy the Liferay WebSocket Whiteboard module
  (\texttt{com.liferay.websocket.whiteboard}) to your Liferay DXP
  instance. You can download this module from JCenter or Maven Central
  by clicking the respective link:

  \begin{itemize}
  \tightlist
  \item
    \href{https://bintray.com/bintray/jcenter/com.liferay\%3Acom.liferay.websocket.whiteboard}{JCenter}
  \item
    \href{https://search.maven.org/\#search\%7Cga\%7C1\%7Cliferay.websocket.whiteboard}{Maven
    Central}
  \end{itemize}
\item
  In your module's build file, add a dependency to the Liferay WebSocket
  Whiteboard:

\begin{verbatim}
 com.liferay:com.liferay.websocket.whiteboard:1.0.1
\end{verbatim}
\item
  In your module, define a WebSocket server endpoint as you normally
  would. Note, however, that Liferay DXP doesn't currently support the
  annotation-driven approach; only the interface-driven approach is
  supported. To create a WebSocket server endpoint, register an OSGi
  Service for \texttt{javax.websocket.Endpoint.class} with the following
  properties:

  \begin{itemize}
  \tightlist
  \item
    \texttt{org.osgi.http.websocket.endpoint.path}: the WebSocket's path
    (required)
  \item
    \texttt{org.osgi.http.websocket.endpoint.decoders}: the WebSocket's
    decoders (optional)
  \item
    \texttt{org.osgi.http.websocket.endpoint.encoders}: the WebSocket's
    encoders (optional)
  \item
    \texttt{org.osgi.http.websocket.endpoint.subprotocols}: the
    WebSocket's subprotocols (optional)
  \end{itemize}
\end{enumerate}

For example, the following steps show you how to define a WebSocket
endpoint in a portlet. For the purposes of this example, the portlet
also contains a client that communicates with the endpoint. This example
portlet, Echo Portlet, uses WebSocket functionality to echo a simple
message the client sends to the server.

\begin{figure}
\centering
\includegraphics{./images/websocket-echo-portlet.png}
\caption{The example Echo portlet sends and receives a simple message
via a WebSocket endpoint.}
\end{figure}

Although the following steps show only code snippets, you can
\href{https://github.com/cgoncas/liferay-websocket-echo}{click here} to
see the complete example code.

Use these steps to define a WebSocket endpoint:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add the WebSocket dependency to your module's build file. For example,
  here's the dependency in a \texttt{build.gradle} file:

\begin{verbatim}
 javax.websocket:javax.websocket-api:1.1
\end{verbatim}
\item
  Create the WebSocket endpoint. Note that the \texttt{@Component}
  annotation contains the required property
  \texttt{org.osgi.http.websocket.endpoint.path}, which defines the
  endpoint \texttt{/o/echo}. Also note that
  \texttt{service\ =\ Endpoint.class} in the \texttt{@Component}
  annotation registers this class as an \texttt{Endpoint} service in
  Liferay DXP's OSGi framework. Otherwise, there's nothing special about
  the \texttt{EchoWebSocketEndpoint} class's code; it resembles that of
  any other WebSocket endpoint:

\begin{verbatim}
 @Component(
     immediate = true,
     property = {"org.osgi.http.websocket.endpoint.path=/o/echo"},
     service = Endpoint.class
 )
 public class EchoWebSocketEndpoint extends Endpoint {

     @Override
     public void onOpen(final Session session, EndpointConfig endpointConfig) {
         session.addMessageHandler(
             new MessageHandler.Whole<String>() {
             @Override
             public void onMessage(String text) {
                 try {
                     RemoteEndpoint.Basic remoteEndpoint =
                         session.getBasicRemote();
                     remoteEndpoint.sendText(text);
                 }
                 catch (IOException ioe) {
                     throw new RuntimeException(ioe);
                 }
             }
         });
     }
 }
\end{verbatim}
\item
  Write your client code. In this example, the Echo portlet's
  \texttt{view.jsp} defines a WebSocket client. Again, there's nothing
  special about this code; it resembles that of other WebSocket clients:

\begin{verbatim}
 <%@ include file="/init.jsp" %>

 <div id="content">
     <div id="left_col">
         <strong>Websocket URL:</strong>
         <br />
         <input id="urlInputText" type="text" readonly />
         </br>
         </br>

         <button onClick="initWebSocket();">Connect</button>
         <button onClick="stopWebSocket();">Disconnect</button>
         <button onClick="checkSocket();">State</button>
         <br />
         <br />
         <strong>Message:</strong>
         <br />
         <input id="inputText" onkeydown="if(event.keyCode==13)sendMessage();" type="text" />
          <button onClick="sendMessage();">Send</button>
      </div>

      <div id="right_col">
          <strong>Log:</strong>
          <br />
          <textarea id="debugTextArea" style="width:400px;height:200px;" readonly></textarea>
      </div>
 </div>

 <script type="text/javascript">
     var debugTextArea = document.getElementById("debugTextArea");

     var wsUri = "ws://localhost:8080/o/echo";

     urlInputText.value=wsUri;

     resizeUrlInputText(urlInputText.value);

     function resizeUrlInputText(message) {
         urlInputText.size=message.length;
     }

     function debug(message) {
         debugTextArea.value += message + "\n\n";
         debugTextArea.scrollTop = debugTextArea.scrollHeight;
     }

     function sendMessage() {
         var msg = document.getElementById("inputText").value;
         if ( websocket != null ) {
             document.getElementById("inputText").value = "";
             websocket.send(msg);
             debug("Message sent: " + msg);
             console.log( "string sent :", '"'+msg+'"' );
         }
         else {
             debug("Can't sent message, the connection is not open");
         }
     }

     var websocket = null;

     function initWebSocket() {
         try {
             if (typeof MozWebSocket == 'function')
                 WebSocket = MozWebSocket;
             if ( websocket && websocket.readyState == 1 )
                 websocket.close();
             websocket = new WebSocket( wsUri );
             websocket.onopen = function(evt) {
                 debug("CONNECTED");
             };
             websocket.onclose = function(evt) {
                 debug("DISCONNECTED");
             };
             websocket.onmessage = function(evt) {
                 console.log( "Message received: ", evt.data );
                 debug( "Message received: " + evt.data );
             };
             websocket.onerror = function(evt) {
                 debug('ERROR: ' + evt.data);
             };
         }
         catch (exception) {
             debug('ERROR: ' + exception);
         }
     }

     function stopWebSocket() {
         if (websocket) {
             websocket.close();
         }
     }

     function checkSocket() {
         if (websocket != null) {
             var stateStr;
             switch (websocket.readyState) {
                 case 0: {
                     stateStr = "CONNECTING";
                     break;
                 }
                 case 1: {
                     stateStr = "OPEN";
                 break;
             }
             case 2: {
                 stateStr = "CLOSING";
                 break;
             }
             case 3: {
                 stateStr = "CLOSED";
                 break;
             }
             default: {
                 stateStr = "UNKNOW";
                 break;
             }
         }
         debug("WebSocket state = " + websocket.readyState + " ( " + stateStr + " )");
         } else {
             debug("WebSocket is null");
         }
     }
 </script>
\end{verbatim}
\end{enumerate}

That's it! Now you know how to create WebSocket endpoints in Liferay
DXP.

\subsection{Related Topics}\label{related-topics-141}

\href{/docs/7-0/tutorials/-/knowledge_base/t/jax-ws-and-jax-rs}{JAX-WS
and JAX-RS}

\href{/docs/7-0/tutorials/-/knowledge_base/t/service-builder-web-services}{Service
Builder Web Services}

\chapter{Asset Framework}\label{asset-framework}

Liferay's asset framework is a system that allows you to add core
Liferay features to your application. For example, if you've built an
event management application that displays a list of upcoming events,
you can use the asset framework to let users add tags, categories, or
comments to make entries more self-descriptive.

Tags, categories, and comments are just a few of the features in
Liferay's asset framework. You'll also find it easy to use: you'll be
infusing your application with these features in no time.

As background, the term \emph{asset} refers to any type of content in
the portal. This could be text, a file, a URL, an image, documents, blog
entries, bookmarks, wiki pages, or anything you create in your
applications.

The asset framework tutorials assume that you've used Liferay's Service
Builder to generate your persistence layer, that you've implemented
permissions on the entities that you're persisting, and that you've
enabled them for search and indexing. You can learn more about Liferay's
Service Builder and how to use it in the
\href{/docs/7-0/tutorials/-/knowledge_base/t/service-builder}{Service
Builder} tutorial section.

If you've yet to do any of those things, you can see how each is done in
respective tutorials
\href{/docs/7-0/tutorials/-/knowledge_base/t/generating-the-back-end}{Generating
the Back-end},
\href{/docs/7-0/tutorials/-/knowledge_base/t/using-resources-and-permissions}{Using
Resources and Permissions}, and
\href{/docs/7-0/tutorials/-/knowledge_base/t/leveraging-search}{Leveraging
Search}. Lastly, the Learning Path
\href{/docs/7-0/tutorials/-/knowledge_base/t/assets-integrating-with-liferays-framework}{Assets:
Integrating with Liferay's Framework} takes you through the fundamentals
of enabling an example application's custom entities to use the asset
framework. If you haven't traveled through that Learning Path, we
recommend you do so before continuing with the tutorials in this
section.

The tutorials that follow in this section explore the details of
leveraging the asset framework's various features. Here are some
features that you'll give your users as you implement them in your app:

\begin{itemize}
\tightlist
\item
  Extensively render your assets.
\item
  Associate tags to custom content types. Users can create and assign
  new tags or use existing tags.
\item
  Associate categories to custom content types.
\item
  Manage tags from the Control Panel. Administrators can even merge
  tags.
\item
  Manage categories from the Control Panel. This includes the ability to
  create category hierarchies.
\item
  Relate assets to one another.
\end{itemize}

At this point, you might be saying, ``Liferay's asset framework sounds
great, but how do I leverage all of its awesome features?'' Excellent
question, and perfect timing!

Before diving head first into the tutorials, you must implement a way to
let the framework know whenever any of your custom content entries is
added, updated, or deleted. The next tutorial covers that. From that
point onward, each tutorial shows you how to leverage a particular asset
framework feature in your UI. It's time to start your asset framework
training!

\section{Related Topics}\label{related-topics-142}

\href{/docs/7-0/tutorials/-/knowledge_base/t/what-is-service-builder}{What
is Service Builder}

\href{/docs/7-0/tutorials/-/knowledge_base/t/service-builder-persistence}{Service
Builder Persistence}

\href{/docs/7-0/tutorials/-/knowledge_base/t/configuration}{Configuration}

\section{Adding, Updating, and Deleting Assets for Custom
Entities}\label{adding-updating-and-deleting-assets-for-custom-entities}

To use Liferay's asset framework with an entity, you must inform the
asset framework about each entity instance you create, modify, and
delete. In this sense, it's similar to informing Liferay's permissions
framework about a new resource. All you have to do is invoke a method of
the asset framework that associates an \texttt{AssetEntry} with the
entity so Liferay can keep track of the entity as an asset. When it's
time to update the entity, you update the asset at the same time. To see
how to asset-enable entities in a working example portlet, visit the
tutorial
\href{/docs/7-0/tutorials/-/knowledge_base/t/assets-integrating-with-liferays-framework}{Assets:
Integrating with Liferay's Framework}.

To leverage assets, you must also implement indexers for your portlet's
entities. Liferay's asset framework uses indexers to manage assets. For
instructions on creating an indexer in a working example portlet, see
the tutorial
\href{/docs/7-0/tutorials/-/knowledge_base/t/enabling-search-and-indexing-for-guestbooks}{Enabling
Search and Indexing}.

This tutorial shows you how to enable assets for your custom entities
and implement indexes for them. It's time to get started!

\subsection{Preparing Your Project for the Asset
Framework}\label{preparing-your-project-for-the-asset-framework}

In your project's \texttt{service.xml} file, add an asset entry entity
reference for your custom entity. Add the following \texttt{reference}
tag before your custom entity's closing
\texttt{\textless{}/entity\textgreater{}} tag.

\begin{verbatim}
<reference package-path="com.liferay.portlet.asset" entity="AssetEntry" />
\end{verbatim}

Then
\href{/docs/7-0/tutorials/-/knowledge_base/t/running-service-builder-and-understanding-the-generated-code}{run}
Service Builder.

Now you're ready to implement adding and updating assets!

\subsection{Adding and Updating
Assets}\label{adding-and-updating-assets}

Your \texttt{-LocalServiceImpl} Java class inherits from its parent base
class an \texttt{AssetEntryLocalService} instance; it's assigned to the
variable \texttt{assetEntryLocalService}. To add your custom entity as a
Liferay asset, you must invoke the \texttt{assetEntryLocalService}'s
\texttt{updateEntry} method.

Here's what the
\href{@platform-ref@/7.0-latest/javadocs/portal-impl/com/liferay/portlet/asset/service/impl/AssetEntryLocalServiceImpl.html\#updateEntry-long-long-java.util.Date-java.util.Date-java.lang.String-long-java.lang.String-long-long:A-java.lang.String:A-boolean-boolean-java.util.Date-java.util.Date-java.util.Date-java.util.Date-java.lang.String-java.lang.String-java.lang.String-java.lang.String-java.lang.String-java.lang.String-int-int-java.lang.Double-}{\texttt{updateEntry}}
method's signature looks like:

\begin{verbatim}
AssetEntry updateEntry(
    long userId, long groupId, Date createDate, Date modifiedDate,
    String className, long classPK, String classUuid, long classTypeId,
    long[] categoryIds, String[] tagNames, boolean listable,
    boolean visible, Date startDate, Date endDate, Date publishDate,
    Date expirationDate, String mimeType, String title,
    String description, String summary, String url, String layoutUuid,
    int height, int width, Double priority)
throws PortalException
\end{verbatim}

Here are descriptions of each of the \texttt{updateEntry} method's
parameters:

\begin{itemize}
\tightlist
\item
  \texttt{userId}: identifies the user updating the content.
\item
  \texttt{groupId}: identifies the scope of the created content. If your
  content doesn't support scopes (extremely rare), pass \texttt{0} as
  the value.
\item
  \texttt{createDate}: the date the entity was created.
\item
  \texttt{modifiedDate}: the date of this change to the entity.
\item
  \texttt{className}: identifies the entity's class. The recommended
  convention is to use the name of the Java class that represents your
  content type. For example, you can pass in the value returned from
  \texttt{{[}YourClassName{]}.class.getName()}.
\item
  \texttt{classPK}: identifies the specific entity instance,
  distinguishing it from other instances of the same type. It's usually
  the primary key of the table where the entity is stored.
\item
  \texttt{classUuid}: serves as a secondary identifier that's guaranteed
  to be universally unique. It correlates entity instances across
  scopes. It's especially useful if your content is exported and
  imported across separate portals.
\item
  \texttt{classTypeId}: identifies the particular variation of this
  class, if it has any variations. Otherwise, use \texttt{0}.
\item
  \texttt{categoryIds}: represent the categories selected for the
  entity. The asset framework stores them for you.
\item
  \texttt{tagNames}: represent the tags selected for the entity. The
  asset framework stores them for you.
\item
  \texttt{listable}: specifies whether the entity can be shown in
  dynamic lists of content (such as asset publisher configured
  dynamically).
\item
  \texttt{visible}: specifies whether the entity is approved.
\item
  \texttt{startDate}: the entity's publish date. You can use it to
  specify when an Asset Publisher should show the entity's content.
\item
  \texttt{endDate}: the date the entity is taken down. You can use it to
  specify when an Asset Publisher should stop showing the entity's
  content.
\item
  \texttt{publishDate}: the date the entity will start to be shown.
\item
  \texttt{expirationDate}: the date the entity will no longer be shown.
\item
  \texttt{mimetype}: the Multi-Purpose Internet Mail Extensions type,
  such as
  \href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/util/ContentTypes.html\#TEXT_HTML}{ContentTypes.TEXT\_HTML},
  used for the content.
\item
  \texttt{title}: the entity's name.
\item
  \texttt{description}: a \texttt{String}-based textual description of
  the entity.
\item
  \texttt{summary}: a shortened or truncated sample of the entity's
  content.
\item
  \texttt{url}: a URL to optionally associate with the entity.
\item
  \texttt{layoutUuid}: the universally unique ID of the layout of the
  entry's default display page.
\item
  \texttt{height}: this can be set to \texttt{0}.
\item
  \texttt{width}: this can be set to \texttt{0}.
\item
  \texttt{priority}: specifies how the entity is ranked among peer
  entity instances. Low numbers take priority over higher numbers.
\end{itemize}

The following code from Liferay's Wiki application's
\href{https://github.com/liferay/liferay-portal/blob/7.0.6-ga7/modules/apps/collaboration/wiki/wiki-service/src/main/java/com/liferay/wiki/service/impl/WikiPageLocalServiceImpl.java}{WikiPageLocalServiceImpl}
Java class demonstrates invoking the \texttt{updateEntry} method on the
wiki page entity called \texttt{WikiPage}. In your \texttt{add-} method,
you could invoke \texttt{updateEntry} after adding your entity's
resources. Likewise, in your \texttt{update-} method, you could invoke
\texttt{updateEntry} after calling the \texttt{super.update-} method.
The code below is called in the \texttt{WikiPageLocalServiceImpl}
class's \texttt{updateStatus(...)} method.

\begin{verbatim}
AssetEntry assetEntry = assetEntryLocalService.updateEntry(
    userId, page.getGroupId(), page.getCreateDate(),
    page.getModifiedDate(), WikiPage.class.getName(),
    page.getResourcePrimKey(), page.getUuid(), 0,
    assetCategoryIds, assetTagNames, true, true, null, null,
    page.getCreateDate(), null, ContentTypes.TEXT_HTML,
    page.getTitle(), null, null, null, null, 0, 0, null);

Indexer<JournalArticle> indexer = IndexerRegistryUtil.nullSafeGetIndexer(
    WikiPage.class);

indexer.reindex(page);
\end{verbatim}

Immediately after invoking the \texttt{updateEntry} method, you must
update the respective asset and index the entity instance. The above
code calls the indexer to index (or re-index, if updating) the entity.
It's that easy to update assets and indexes.

\noindent\hrulefill

\textbf{Tip:} The current user's ID and the scope group ID are commonly
made available in service context parameters. If the service context you
use contains them, then you can access them in calls like these:

long userId = serviceContext.getUserId(); long groupId =
serviceContext.getScopeGroupId();

\noindent\hrulefill

Next, you'll learn what's needed to properly delete an entity that's
associated with an asset.

\subsection{Deleting Assets}\label{deleting-assets}

When deleting your entities, you should delete the associated assets and
indexes at the same time. This cleans up stored asset and index
information, which keeps the Asset Publisher from showing information
for the entities you've deleted.

In your \texttt{-LocalServiceImpl} Java class, open your
\texttt{delete-} method. After the code that deletes the entity's
resource, you must delete the entity instance's asset entry and index.

Here's some code which deletes an asset entry and an index associated
with a portlet's entity.

\begin{verbatim}
assetEntryLocalService.deleteEntry(
    ENTITY.class.getName(), ENTITY.getInsultId());

Indexer indexer = IndexerRegistryUtil.nullSafeGetIndexer(ENTITY.class);
indexer.delete(ENTITY);
\end{verbatim}

In your \texttt{-LocalServiceImpl} class, you can write similar code.
Replace the \emph{ENTITY} class name and variable with your entity's
name.

\noindent\hrulefill

\textbf{Important:} In order for Liferay's Asset Publisher application
to show your entity, the entity must have an Asset Renderer. To learn
how to implement an Asset Renderer for your custom entity, refer to the
\href{/docs/7-0/tutorials/-/knowledge_base/t/rendering-an-asset}{Rendering
an Asset} tutorial. Note also that an Asset Renderer is how you show a
user the components of your entity in the Asset Publisher. On deploying
your portlet with asset, indexer, and asset rendering implementations in
place, an Asset Publisher can show your custom entities!

\noindent\hrulefill

\begin{figure}
\centering
\includegraphics{./images/basic-asset-in-asset-publisher.png}
\caption{It can be useful to show custom entities, like this wiki page
entity, in a JSP or in an Asset Publisher.}
\end{figure}

Great! Now you know how to add, update, and delete assets in your apps!

\subsection{Related Topics}\label{related-topics-143}

\href{/docs/7-0/tutorials/-/knowledge_base/t/relating-assets}{Relating
Assets}

\href{/docs/7-0/tutorials/-/knowledge_base/t/what-is-service-builder}{What
is Service Builder?}

\section{Implementing Asset Categorization and
Tagging}\label{implementing-asset-categorization-and-tagging}

In this tutorial, you'll allow content authors the ability to specify
tags and categories for their entities in the UI. Liferay provides a set
of JSP tags for showing category and tag inputs in your UI. Before
beginning, your entities should be
\href{/docs/7-0/tutorials/-/knowledge_base/t/adding-updating-and-deleting-assets-for-custom-entities}{asset-enabled}
and you should have asset renderers enabled for them.

\begin{figure}
\centering
\includegraphics{./images/asset-fw-categories-and-tags-options.png}
\caption{Adding category and tag input options lets authors aggregate
and label custom entities.}
\end{figure}

Now it's time to get started!

You can use the following tags in the JSPs you provide for
adding/editing custom entities. Here's what the tags look like in the
\href{https://github.com/liferay/liferay-portal/blob/7.0.6-ga7/modules/apps/collaboration/blogs/blogs-web/src/main/resources/META-INF/resources/blogs/edit_entry.jsp}{edit\_entry.jsp}
for the Blogs portlet:

\begin{verbatim}
<liferay-ui:asset-categories-error />
<liferay-ui:asset-tags-error />
...
<aui:fieldset-group markupView="lexicon">
    ...
    <aui:fieldset collapsed="<%= true %>" collapsible="<%= true %>" label="categorization">
        <aui:input name="categories" type="assetCategories" />

        <aui:input name="tags" type="assetTags" />
    </aui:fieldset>
    ...
</aui:fieldset-group>
\end{verbatim}

These category and tag \texttt{aui:input} tags generate form controls
that let users browse/select a categories for the entity, browse/select
tags, and/or create new tags to associate with the entity.

The \texttt{liferay-ui:asset-categories-error} and
\texttt{liferay-ui:asset-tags-error} tags show messages for errors
occurring during the asset category or tag input process. The
\texttt{aui:fieldset} tag uses a container that lets users hide or show
the category and tag input options.

For styling purposes, the \texttt{aui:fieldset-group} tag is given the
\texttt{lexicon} markdup view.

Once the tags and categories have been entered, you'll want to show them
along with the content of the asset. Here's how to display the tags and
categories:

\begin{verbatim}
<p><liferay-ui:message key="categories" />:</p>

<div class="entry-categories">
    <liferay-ui:asset-categories-summary
        className="<%= BlogsEntry.class.getName() %>"
        classPK="<%= entry.getEntryId() %>"
        portletURL="<%= renderResponse.createRenderURL() %>"
    />
</div>

...

<div class="entry-tags">
    <p><liferay-ui:message key="tags" />:</p>

    <liferay-ui:asset-tags-summary
        className="<%= BlogsEntry.class.getName() %>"
        classPK="<%= entry.getEntryId() %>"
        portletURL="<%= renderResponse.createRenderURL() %>"
    />
</div>
\end{verbatim}

You'll notice the \texttt{portletURL} parameter is used for both tags
and categories, which supports navigation amongst the two. Each tag that
uses this parameter becomes a link containing the \texttt{portletURL}
\emph{and} \texttt{tag} or \texttt{categoryId} parameter value. To
implement this, you need to implement the look-up functionality in your
portlet code. Do this by reading the values of those two parameters and
using \texttt{AssetEntryService} to query the database for entries based
on the specified tag or category.

Deploy your changes and add/edit a custom entity in your UI. Your form
shows the categorization and tag input options in a panel that the user
can hide/show.

Great! Now you know how to make category and tag input options available
to your app's content authors.

\subsection{Related Topics}\label{related-topics-144}

\href{/docs/7-0/tutorials/-/knowledge_base/t/relating-assets}{Relating
Assets}

\href{/docs/7-0/tutorials/-/knowledge_base/t/adding-updating-and-deleting-assets-for-custom-entities}{Adding,
Updating, and Deleting Assets for Custom Entities}

\href{/docs/7-0/tutorials/-/knowledge_base/t/what-is-service-builder}{What
is Service Builder?}

\section{Relating Assets}\label{relating-assets}

The ability to relate assets is one of the most powerful features of
Liferay's asset framework. By relating assets, you can connect
individual pieces of content across your site or portal. This helps your
users discover related content, particularly when there's an abundance
of other available content. For example, assets related to a web content
article appear alongside that entry in the Asset Publisher application.

\begin{figure}
\centering
\includegraphics{./images/asset-related-content-asset-publisher.png}
\caption{You and your users can find it helpful to relate assets to
entities, such as this blogs entry.}
\end{figure}

This tutorial shows you how to provide a way for authors to relate
content. This tutorial assumes that you've
\href{/docs/7-0/tutorials/-/knowledge_base/t/adding-updating-and-deleting-assets-for-custom-entities}{asset
enabled} your appliation. If you've already done this, go ahead and
begin relating your assets!

\subsection{Relating Assets in the Service
Layer}\label{relating-assets-in-the-service-layer}

First, you must make some modifications to your portlet's service layer.
You must implement persisting your entity's asset relationships. In your
portlet's \texttt{service.xml}, put the following line of code below any
finder method elements and then
\href{/docs/7-0/tutorials/-/knowledge_base/t/running-service-builder-and-understanding-the-generated-code}{run}
Service Builder:

\begin{verbatim}
<reference package-path="com.liferay.portlet.asset" entity="AssetLink" />
\end{verbatim}

Next, you need to modify the \texttt{add-}, \texttt{delete-}, and
\texttt{update-} methods in your \texttt{-LocalServiceImpl} to persist
the asset relationships. You'll use your \texttt{-LocalServiceImpl}'s
\texttt{assetLinkLocalService} instance variable to execute persistence
actions.

For example, consider the Wiki application. When you update wiki assets
and statuses, both methods utilize the \texttt{updateLinks} via your
instance variable \texttt{assetLinkLocalService}. Here's the
\texttt{updateLinks} invocation in the Wiki application's
\texttt{WikiPageLocalServiceImpl.updateStatus(...)} method:

\begin{verbatim}
assetLinkLocalService.updateLinks(
    userId, assetEntry.getEntryId(), assetLinkEntryIds,
    AssetLinkConstants.TYPE_RELATED);
\end{verbatim}

To call the \texttt{updateLinks} method, you need to pass in the current
user's ID, the asset entry's ID, the ID's of the asset link entries, and
the link type. You should invoke this method after creating the asset
entry. You can assign to an \texttt{AssetEntry} variable (e.g., one
called \texttt{assetEntry}) the value returned from invoking
\texttt{assetEntryLocalService.updateEntry}. That way you can get the
asset entry's ID for updating its asset links. Lastly, in order to
specify the link type parameter, make sure to import
\texttt{com.liferay.portlet.asset.model.AssetLinkConstants}.

In your \texttt{-LocalServiceImpl} class' \texttt{delete-} method, you
must delete the asset's relationships before deleting the asset. For
example, you could delete your existing asset link relationships by
using the following code:

\begin{verbatim}
AssetEntry assetEntry = assetEntryLocalService.fetchEntry(
    ENTITY.class.getName(), ENTITYId);

assetLinkLocalService.deleteLinks(assetEntry.getEntryId());
\end{verbatim}

Make sure to replace the \emph{ENTITY} place holders for your custom
\texttt{-delete} method.

Super! Now your portlet's service layer can handle related assets. Even
so, there's still nothing in your portlet's UI that lets your users
relate assets. You'll take care of that in the next step.

\subsection{Relating Assets in the UI}\label{relating-assets-in-the-ui}

You typically implement the UI for linking assets in the JSP that you
provide users the ability to create and edit your entity, This way only
content creators can relate other assets to the entity. Related assets
are implemented in the JSP by using the Liferay UI tag
\texttt{liferay-ui:input-asset-links} inside of a collapsible panel.
This code is placed inside the \texttt{aui:fieldset} tags of the JSP.
The panel and \texttt{liferay-ui:input-asset-links} tag are shown below
for the Blogs application:

\begin{verbatim}
<aui:fieldset collapsed="<%= true %>" collapsible="<%= true %>" label="related-assets">
    <liferay-ui:input-asset-links
        className="<%= BlogsEntry.class.getName() %>"
        classPK="<%= entryId %>"
    />
\end{verbatim}

Your content authors are able to relate assets once you add this code
and redeploy your portlet.

The following screenshot shows the Related Assets menu for an
appliation. Note that it is contained in a collapsible panel titled
Related Assets.

\begin{figure}
\centering
\includegraphics{./images/related-assets-select-menu.png}
\caption{Your portlet's entity is now available in the Related Assets
\emph{Select} menu.}
\end{figure}

Even though you've provided a way for authors to assign related assets,
the Related Assets menu shows your entity's fully qualified class name,
instead of a more concise name. To replace the long fully qualified
class name shown in the menu with a simplified name for your entity, add
a language key that uses the fully qualified class name as the key's
name and the new simplified name as the key's value. Put the language
key in file \texttt{docroot/WEB-INF/src/content/Language.properties} in
your portlet. You can refer to the
\href{/docs/7-0/tutorials/-/knowledge_base/t/overriding-language-keys}{Overriding
Language Keys} tutorial for more documentation on using language
properties.

Upon redeploying your portlet, the value you assigned to the fully
qualified class name in your \texttt{Language.properties} file shows in
the Related Assets menu:

Awesome! Now content creators and editors can relate the assets of your
application. The next thing you need to do is reveal any such related
assets to the rest of your application's users. After all, you don't
want to give everyone edit access just so they can view related assets!

\subsection{Showing Related Assets}\label{showing-related-assets}

You can show related assets in your application's view of that entity
or, if you've implemented asset rendering for your custom entity, you
can show related assets in the full content view of your entity for
users to view in an Asset Publisher portlet.

This section shows you how to access an entity's asset entry in your
entity's view JSP and how to display links to its related assets. When
you finish, users can click on the entity instances in your portlet to
view any related assets.

In your entity's view JSP you can use \texttt{ParamUtil} to get the ID
of the entity from the render request. Then you can create an entity
object using your \texttt{-LocalServiceUtil} class. You can use an
entity instance object to get the \texttt{AssetEntry} object associated
with it.

\begin{verbatim}
<%
long insultId = ParamUtil.getLong(renderRequest, "insultId");
Insult ins = InsultLocalServiceUtil.getInsult(insultId);
AssetEntry assetEntry = AssetEntryLocalServiceUtil.getEntry(Insult.class.getName(), ins.getInsultId());
%>
\end{verbatim}

To show the entity's related assets, you can use the
\texttt{liferay-ui:asset-links} tag. For this tag, you should retrieve
the entity's class name and the variable holding your instance object,
so you can return its ID. The example code below uses the example entity
class \texttt{Insult} and an instance object variable called
\texttt{ins}:

\begin{verbatim}
<liferay-ui:asset-links
    assetEntryId="<%=(assetEntry != null) ? assetEntry.getEntryId() : 0%>"
    className="<%=Insult.class.getName()%>"
    classPK="<%=ins.getInsultId()%>" />
\end{verbatim}

Go ahead and use a the \texttt{liferay-ui:asset-links} tag in your JSP.
Great! Now you have the JSP that lets your users view related assets.

If you've already connected your portlet's view to the view JSP for your
entity, you've completed the tutorial. You can otherwise follow the
remainder of this tutorial to learn how to implement that connection.

\subsection{Creating a URL to Your New
JSP}\label{creating-a-url-to-your-new-jsp}

Now that you've implemented showing off this asset feature, you must
connect your application's main view JSP to your entity's view JSP. If
your main view JSP uses a search container to list your entity
instances, you can insert a \texttt{portlet:renderURL} tag just after
the \texttt{liferay-ui:search-container-row} tag. For example, your
\texttt{view.jsp} could look like this:

\begin{verbatim}
<liferay-ui:search-container-row
    className="com.sample.portlet.insults.model.Insult"
    keyProperty="insultId"
    modelVar="insult" escapedModel="<%= true %>"
>

<portlet:renderURL windowState="maximized" var="rowURL">
    <portlet:param name="mvcPath" value="/html/insult/view_insult.jsp" />
    <portlet:param name="insultId" value="<%= String.valueOf(insult.getInsultId()) %>" />
</portlet:renderURL>
\end{verbatim}

Next, add to the first search container column an \texttt{href}
attribute with the value of the URL you just created in the
\texttt{portlet:renderURL} tag. For example, the value of \texttt{href}
that corresponds with the render URL created above is
\texttt{"\textless{}\%=rowURL\ \%\textgreater{}"}. Your
\texttt{search-container-column-text} tag can look similar to this tag:

\begin{verbatim}
<liferay-ui:search-container-column-text
    name="Insult"
    value="<%= insult.getInsultString() %>"
    href="<%=rowURL %>"
/>
\end{verbatim}

Now, redeploy your portlet and refresh the page so that your portlet's
view JSP reloads. Each entity listed is a link. Click on one to view
your entity's JSP that you made in the previous step of this tutorial.

Related assets, if you've created any yet, should be visible near the
bottom of the page.

Excellent! Now you know how to implement related assets in your apps.
Another thing you might want to do is investigate permissioning in the
UI. For more information on this, see the tutorial
\href{/docs/7-0/tutorials/-/knowledge_base/t/permissions-in-jsps\#checking-permissions-in-the-ui}{Checking
Permissions in the UI}.

\subsection{Related Topics}\label{related-topics-145}

\href{/docs/7-0/tutorials/-/knowledge_base/t/adding-updating-and-deleting-assets-for-custom-entities}{Adding,
Updating, and Deleting Assets for Custom Entities}

\href{/docs/7-0/tutorials/-/knowledge_base/t/what-is-service-builder}{What
is Service Builder?}

\href{/docs/7-0/user/-/knowledge_base/u/defining-content-relationships}{Defining
Content Relationships}

\section{Implementing Asset Priority}\label{implementing-asset-priority}

The \href{/docs/7-0/user/-/knowledge_base/u/publishing-assets}{Asset
Publisher} lets you order assets by priority. For this to work, however,
users must be able to set the asset's priority when creating or editing
the asset. For example, when creating or editing web content, users can
assign a priority in the Metadata section's Priority field.

\begin{figure}
\centering
\includegraphics{./images/web-content-categorization.png}
\caption{The Priority field lets users set an asset's priority.}
\end{figure}

This field isn't enabled by default for your custom assets. You must
manually add support for it. Fortunately, this is very straightforward.
This tutorial shows you how. Onwards!

\subsection{Add the Priority Field to Your
JSP}\label{add-the-priority-field-to-your-jsp}

In the JSP for adding and editing your asset, add the following input
field that lets users set the asset's priority. This example also
validates the input to make sure the value the user sets is a number
higher than zero:

\begin{verbatim}
<aui:input label="priority" name="assetPriority" type="text" value="<%= priority %>">
    <aui:validator name="number" />

    <aui:validator name="min">[0]</aui:validator>
</aui:input>
\end{verbatim}

That's it for the view layer! Now when users create or edit your custom
asset, they can enter its priority. Next, you'll learn how to use that
value in your service layer.

\subsection{Using the Priority Value in Your Service
Layer}\label{using-the-priority-value-in-your-service-layer}

To make the priority value functional, you must retrieve it from the
view and add it to the asset in your database. The priority value is
automatically available in your service layer via the
\texttt{ServiceContext} variable \texttt{serviceContext}. Retrieve it
with \texttt{serviceContext.getAssetPriority()}, and then pass it as the
last argument to the \texttt{assetEntryLocalService.updateEntry} call in
your \texttt{-LocalServiceImpl}. You can see an example of this in
\href{https://github.com/liferay/liferay-portal/blob/7.0.6-ga7/portal-impl/src/com/liferay/portlet/blogs/service/impl/BlogsEntryLocalServiceImpl.java}{the
\texttt{BlogsEntryLocalServiceImpl} class} of Liferay DXP's Blogs app.
The \texttt{updateAsset} method takes a \texttt{priority} argument,
which it passes as the last argument to its
\texttt{assetEntryLocalService.updateEntry} call:

\begin{verbatim}
@Override
public void updateAsset(
        long userId, BlogsEntry entry, long[] assetCategoryIds,
        String[] assetTagNames, long[] assetLinkEntryIds, Double priority)
    throws PortalException {

    ...

    AssetEntry assetEntry = assetEntryLocalService.updateEntry(
        userId, entry.getGroupId(), entry.getCreateDate(),
        entry.getModifiedDate(), BlogsEntry.class.getName(),
        entry.getEntryId(), entry.getUuid(), 0, assetCategoryIds,
        assetTagNames, true, visible, null, null, null, null,
        ContentTypes.TEXT_HTML, entry.getTitle(), entry.getDescription(),
        summary, null, null, 0, 0, priority);

    ...
}
\end{verbatim}

The \texttt{BlogsEntryLocalServiceImpl} class calls this
\texttt{updateAsset} method when adding or updating a blog entry. Note
that \texttt{serviceContext.getAssetPriority()} retrieves the priority:

\begin{verbatim}
updateAsset(
        userId, entry, serviceContext.getAssetCategoryIds(),
        serviceContext.getAssetTagNames(),
        serviceContext.getAssetLinkEntryIds(),
        serviceContext.getAssetPriority());
\end{verbatim}

Sweet! Now you know how to enable priorities for your app's assets.

\subsection{Related Topics}\label{related-topics-146}

\href{/docs/7-0/tutorials/-/knowledge_base/t/adding-updating-and-deleting-assets-for-custom-entities}{Adding,
Updating, and Deleting Assets For Custom Entities}

\href{/docs/7-0/tutorials/-/knowledge_base/t/implementing-asset-categorization-and-tagging}{Implementing
Asset Categorization and Tagging}

\href{/docs/7-0/tutorials/-/knowledge_base/t/relating-assets}{Relating
Assets}

\href{/docs/7-0/tutorials/-/knowledge_base/t/rendering-an-asset}{Rendering
an Asset}

\href{/docs/7-0/user/-/knowledge_base/u/publishing-assets}{Publishing
Assets}

\section{Rendering an Asset}\label{rendering-an-asset}

There are several options you have for rendering an asset in Liferay
DXP. Before setting up the rendering process for your asset, make sure
it's added to the asset framework by following the
\href{/docs/7-0/tutorials/-/knowledge_base/t/adding-updating-and-deleting-assets-for-custom-entities}{Adding,
Updating, and Deleting Assets} tutorial. Once you have your asset added
to the framework, Liferay DXP can render the asset by default using the
Asset Publisher application. The default rendering process Liferay DXP
provides, however, only displays the asset's title and description text.
Any further rendering of your asset requires additional coding. For
instance, you might want these additional things:

\begin{itemize}
\tightlist
\item
  An edit feature for modifying an asset.
\item
  Viewing an asset in its original context (e.g., a blog in the Blogs
  application; a post in the Message Boards application).
\item
  Embedding images, videos, and audio.
\item
  Restricting access to users who do not have permissions to interact
  with the asset.
\item
  Allowing users to comment on the asset.
\end{itemize}

Liferay lets you dictate your asset's rendering capabilities by
providing the \emph{Asset Renderer} framework. Implementing an asset
renderer for an existing asset is easy because Liferay offers interfaces
and factories to help get your custom asset rendering implemented fast.
There are two things you must do to get your asset renderer functioning
properly for your asset:

\begin{itemize}
\tightlist
\item
  Create an asset renderer for your custom asset.
\item
  Create an asset renderer factory to create an instance of the asset
  renderer for each asset entity.
\end{itemize}

\begin{figure}
\centering
\includegraphics{./images/asset-renderer-diagram.png}
\caption{The asset renderer factory creates an asset renderer for each
asset instance.}
\end{figure}

You'll learn how to create an asset renderer and an asset renderer
factory by studying a Liferay asset that already uses both by default:
Blogs. The Blogs application offers many different ways to access and
render a blogs asset. You'll learn how a blogs asset provides an edit
feature, comment section, original context viewing (i.e., viewing an
asset from the Blogs application), workflow, etc. You'll also learn how
it uses JSP templates to display various blog views. The Blogs
application is an extensive example of how an asset renderer can be
customized to fit your needs.

If you want to create an asset and make it do more than display its
title and description, read on to learn more!

\subsection{Prerequisites for Asset Enabling and
Application}\label{prerequisites-for-asset-enabling-and-application}

To asset-enable your application, you need two things:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  The application must store asset data. Applications that store a data
  model meet this requirement.
\item
  The application must contain at least one non-instanceable portlet.
  \texttt{Edit} links for the asset cannot be generated without a
  non-instanceable portlet.
\end{enumerate}

Some applications may consist of only one non-instanceable portlet,
while others may consist of a both instanceable and non-instanceable
portlets. If your application does not currently include a
non-instanceable portlet, adding a configuration interface through a
panel app will both enhance the usability of the application, and meet
the requirement for adding a non-instanceable component to the
application. See our tutorial on
\href{/knowledge_base/7-0/customizing-the-product-menu\#adding-custom-panel-apps}{Adding
Custom Panel Apps} to learn how to add one.

Now that you have all that taken care of, you can move on to creating an
Asset Renderer.

\subsection{Creating an Asset
Renderer}\label{creating-an-asset-renderer}

An asset renderer lets you provide your own HTML for your asset. The
\texttt{AssetRenderer} interface requires that you choose a templating
technology (JSP, FreeMarker, Soy, etc.) to display an asset's HTML. For
this tutorial, you'll use JSP templates to render an asset's HTML.
You'll learn how to associate your JSP templates with an asset renderer,
along with configuring several other options.

To learn how an asset renderer is created, you'll create the
pre-existing
\href{https://github.com/liferay/liferay-portal/blob/7.0.6-ga7/modules/apps/collaboration/blogs/blogs-web/src/main/java/com/liferay/blogs/web/asset/BlogsEntryAssetRenderer.java}{BlogsEntryAssetRenderer}
class, which configures the asset renderer framework for the Blogs
application.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a new package in your existing project for your asset-related
  classes. For instance, the \texttt{BlogsEntryAssetRenderer} class
  resides in the \texttt{com.liferay.blogs.web} module's
  \texttt{com.liferay.blogs.web.asset} package.
\item
  Create your \texttt{-AssetEntry} class for your application in the new
  \texttt{-.asset} package and have it implement the
  \href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/asset/kernel/model/AssetEntry.html}{AssetEntry}
  interface. Consider the \texttt{BlogsEntryAssetRenderer} class as an
  example:

\begin{verbatim}
public class BlogsEntryAssetRenderer
    extends BaseJSPAssetRenderer<BlogsEntry> implements TrashRenderer {
\end{verbatim}

  The \texttt{BlogsEntryAssetRenderer} class extends the
  \href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/asset/kernel/model/BaseJSPAssetRenderer.html}{BaseJSPAssetRenderer},
  which is an extension class intended for those who plan on using JSP
  templates to generate their asset's HTML. The
  \texttt{BaseJSPAssetRenderer} class implements the
  \texttt{AssetRenderer} interface. You'll notice the asset renderer is
  also implementing the
  \href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/trash/TrashRenderer.html}{TrashRenderer}
  interface. This is a common practice for many Liferay DXP
  applications, which enables its assets to use Liferay DXP's Recycle
  Bin.
\item
  Define the asset renderer class's constructor, which typically sets
  the asset object to use in the asset renderer class.

\begin{verbatim}
public BlogsEntryAssetRenderer(
    BlogsEntry entry, ResourceBundleLoader resourceBundleLoader) {

    _entry = entry;
    _resourceBundleLoader = resourceBundleLoader;
}
\end{verbatim}

  The \texttt{BlogsEntryAssetRenderer} also sets the resource bundle
  loader, which loads the language keys for a module. You can learn more
  about the resource bundle loader in the
  \href{/docs/7-0/tutorials/-/knowledge_base/t/overriding-language-keys}{Overriding
  Language Keys} tutorial.

  Also, make sure to define the \texttt{\_entry} and
  \texttt{\_resourceBundleLoader} fields in the class:

\begin{verbatim}
private final BlogsEntry _entry;
private final ResourceBundleLoader _resourceBundleLoader;
\end{verbatim}
\item
  Now that your class declaration and constructor are defined for the
  blogs asset renderer, you must begin connecting your asset renderer to
  your asset. The following getter methods accomplish this:

\begin{verbatim}
@Override
public BlogsEntry getAssetObject() {
    return _entry;
}

@Override
public String getClassName() {
    return BlogsEntry.class.getName();
}

@Override
public long getClassPK() {
    return _entry.getEntryId();
}

@Override
public long getGroupId() {
    return _entry.getGroupId();
}

@Override
public String getType() {
    return BlogsEntryAssetRendererFactory.TYPE;
}

@Override
public String getUuid() {
    return _entry.getUuid();
}
\end{verbatim}

  These methods are pretty self-explanatory, but there are a couple
  things to point out. The \texttt{getAssetObject()} method sets the
  \texttt{BlogsEntry} that was set in the constructor as your asset to
  track. Likewise, the \texttt{getType()} method references the blogs
  asset renderer factory for the type of asset your asset renderer
  renders. Of course, the asset renderer type is \texttt{blog}, which
  you'll set in the factory later.
\item
  Your asset renderer must link to the portlet that owns the entity. In
  the case of a blogs asset, its portlet ID should be linked to the
  Blogs application.

\begin{verbatim}
@Override
public String getPortletId() {
    AssetRendererFactory<BlogsEntry> assetRendererFactory =
        getAssetRendererFactory();

    return assetRendererFactory.getPortletId();
}
\end{verbatim}

  The \texttt{getPortletId()} method instantiates an asset renderer
  factory for a \texttt{BlogsEntry} and retrieves the portlet ID for the
  portlet used to display blogs entries.
\item
  If you're interested in enabling workflow for your asset, add the
  following method similar to what was done for the Blogs application:

\begin{verbatim}
@Override
public int getStatus() {
    return _entry.getStatus();
}
\end{verbatim}

  This method retrieves the workflow status for the asset.
\item
  Another popular feature many developers want for their asset is to
  comment on it. This is enabled for the Blogs application with the
  following method:

\begin{verbatim}
@Override
public String getDiscussionPath() {
    if (PropsValues.BLOGS_ENTRY_COMMENTS_ENABLED) {
        return "edit_entry_discussion";
    }
    else {
        return null;
    }
}
\end{verbatim}

  A comments section is an available option if it returns a non-null
  value. A JSP template defining a comments section is not required. For
  the comments section to display for your asset, you must enable it in
  the Asset Publisher's \emph{Options}
  (\includegraphics{./images/icon-app-options.png}) →
  \emph{Configuration} → \emph{Setup} → \emph{Display Settings} section.
\item
  At a minimum, you should create a title and summary for your asset.
  Here's how the \texttt{BlogsEntryAssetRenderer} does it:

\begin{verbatim}
@Override
public String getSummary(
    PortletRequest portletRequest, PortletResponse portletResponse) {

    int abstractLength = AssetUtil.ASSET_ENTRY_ABSTRACT_LENGTH;

    if (portletRequest != null) {
        abstractLength = GetterUtil.getInteger(
            portletRequest.getAttribute(
                WebKeys.ASSET_ENTRY_ABSTRACT_LENGTH),
            AssetUtil.ASSET_ENTRY_ABSTRACT_LENGTH);
    }

    String summary = _entry.getDescription();

    if (Validator.isNull(summary)) {
        summary = HtmlUtil.stripHtml(
            StringUtil.shorten(_entry.getContent(), abstractLength));
    }

    return summary;
}

@Override
public String getTitle(Locale locale) {
    ResourceBundle resourceBundle =
        _resourceBundleLoader.loadResourceBundle(
            LanguageUtil.getLanguageId(locale));

    return BlogsEntryUtil.getDisplayTitle(resourceBundle, _entry);
}
\end{verbatim}

  These two methods return information about your asset in a generic
  way, so the asset publisher can display it. Anything appropriate for
  your asset can be the title or the summary.

  The \texttt{getSummary(...)} method for Blogs returns the abstract
  description for a blog asset. If the abstract description does not
  exist, the content of the blog is used as an abstract. You'll learn
  more about abstracts and other content specifications later.

  The \texttt{getTitle(...)} method for Blogs uses the resource bundle
  loader you configured in the constructor to load your module's
  resource bundle and return the display title for your asset.
\item
  If you want to provide a unique URL for your asset, you can specify a
  URL title. A URL title is the URL used to access your asset directly
  (e.g., localhost:8080/-/this-is-my-blog-asset). You can do this by
  providing the following method:

\begin{verbatim}
@Override
public String getUrlTitle() {
    return _entry.getUrlTitle();
}
\end{verbatim}
\item
  Insert the \texttt{isPrintable()} method, which enables the Asset
  Publisher's printing capability for your asset.

\begin{verbatim}
@Override
public boolean isPrintable() {
    return true;
}
\end{verbatim}

  This displays a Print icon when your asset is displayed in the Asset
  Publisher. For the icon to appear, you must enable it in the Asset
  Publisher's \emph{Options}
  (\includegraphics{./images/icon-app-options.png}) →
  \emph{Configuration} → \emph{Setup} → \emph{Display Settings} section.

  \begin{figure}
  \centering
  \includegraphics{./images/asset-publisher-printing.png}
  \caption{Enable printing in the Asset Publisher to display the Print
  icon for your asset.}
  \end{figure}
\item
  If your asset is protected by permissions, you should set permissions
  for the asset. You can do this via the asset renderer as well. See the
  logic below for an example used in the
  \texttt{BlogsEntryAssetRenderer} class:

\begin{verbatim}
@Override
public long getUserId() {
    return _entry.getUserId();
}

@Override
public String getUserName() {
    return _entry.getUserName();
}

public boolean hasDeletePermission(PermissionChecker permissionChecker) {
    return BlogsEntryPermission.contains(
        permissionChecker, _entry, ActionKeys.DELETE);
}

@Override
public boolean hasEditPermission(PermissionChecker permissionChecker) {
    return BlogsEntryPermission.contains(
        permissionChecker, _entry, ActionKeys.UPDATE);
}

@Override
public boolean hasViewPermission(PermissionChecker permissionChecker) {
    return BlogsEntryPermission.contains(
        permissionChecker, _entry, ActionKeys.VIEW);
}
\end{verbatim}

  Before you can check if a user has permission to view your asset, you
  must distinguish the user. The \texttt{getUserId()} and
  \texttt{getUserName()} retrieves the entry's user ID and username,
  respectively. Then there are three boolean permission methods, which
  check if the user can view, edit, or delete your blogs entry. These
  permissions are for specific entity instances. Global permissions for
  blog entries are implemented in the factory, which you'll do later.
\end{enumerate}

Awesome! You've learned how to set up the blogs asset renderer to

\begin{itemize}
\tightlist
\item
  connect to an asset
\item
  connect to the asset's portlet
\item
  use workflow management
\item
  use a comments section
\item
  retrieve the asset's title and summary
\item
  generate the asset's unique URL
\item
  display a print icon
\item
  set up permissioning for the asset
\end{itemize}

You may recall that a major cog in asset renderer development generating
HTML using a templating technology. The \texttt{BlogsEntryAssetRenderer}
is configured to use JSP templates to generate HTML for the Asset
Publisher. You'll learn more about how to do this next.

\subsubsection{Configuring JSP Templates for an Asset
Renderer}\label{configuring-jsp-templates-for-an-asset-renderer}

An asset can be displayed in several different ways in the Asset
Publisher, by default. There are three templates to implement provided
by the \texttt{AssetRenderer} interface:

\begin{itemize}
\tightlist
\item
  \texttt{abstract}
\item
  \texttt{full\_content}
\item
  \texttt{preview}
\end{itemize}

Besides these supported templates, you can also create JSPs for buttons
you'd like to provide for direct access and manipulation of the asset.
For example,

\begin{itemize}
\tightlist
\item
  Edit
\item
  View
\item
  View in Context
\end{itemize}

The \texttt{BlogsEntryAssetRenderer} customizes the
\texttt{AssetRenderer}'s provided JSP templates and adds a few other
features using JSPs. You'll inspect how the blogs asset renderer is put
together to satisfy JSP template development requirements.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add the \texttt{getJspPath(...)} method to your asset renderer. This
  method should return the path to your JSP, which is rendered inside
  the Asset Publisher. This is how the \texttt{BlogsEntryAssetRenderer}
  uses this method:

\begin{verbatim}
@Override
public String getJspPath(HttpServletRequest request, String template) {
    if (template.equals(TEMPLATE_ABSTRACT) ||
        template.equals(TEMPLATE_FULL_CONTENT)) {

        return "/blogs/asset/" + template + ".jsp";
    }
    else {
        return null;
    }
}
\end{verbatim}

  Blogs assets provide \texttt{abstract.jsp} and
  \texttt{full\_content.jsp} templates. This means that a blogs asset
  can render a blog's abstract description or the blog's full content in
  the Asset Publisher. Those templates are located in the
  \texttt{com.liferay.blogs.web} module's
  \texttt{src/main/resources/META-INF/resources/blogs/asset} folder. You
  could create a similar folder for your JSP templates used for this
  method. The other template provided by the \texttt{AssetRenderer}
  interface, \texttt{preview.jsp}, is not customized by the blogs asset
  renderer, so its default template is implemented.

  You must create a link to display the full content of the asset.
  You'll do this later.
\item
  Now that you've added the path to your JSP, you must include that JSP.
  Since the \texttt{BlogsEntryAssetRenderer} class extends the
  \texttt{BaseJSPAssetRenderer}, it already has an \texttt{include(...)}
  method to render a specific JSP. You must override this method to set
  an attribute in the request to use in the blog's views:

\begin{verbatim}
@Override
public boolean include(
        HttpServletRequest request, HttpServletResponse response,
        String template)
    throws Exception {

    request.setAttribute(WebKeys.BLOGS_ENTRY, _entry);

    return super.include(request, response, template);
}
\end{verbatim}

  The attribute includes the blogs entry object. Adding the blog object
  this way is not mandatory; you could obtain the blog entry directly
  from the view. Using the \texttt{include(...)} method, however,
  follows the best practice for MVC portlets.

  \begin{figure}
  \centering
  \includegraphics{./images/blogs-asset-views.png}
  \caption{The abstract and full content views are rendererd differently
  for blogs.}
  \end{figure}
\end{enumerate}

Terrific! You've learned how to apply JSPs supported by the Asset
Publisher for your asset. That's not all you can do with JSP templates,
however! The asset renderer framework provides several other methods
that let you render convenient buttons for your asset.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Blogs assets provide an Edit button
  (\includegraphics{./images/icon-edit.png}) that lets you edit the
  asset. This is provided by adding the following method to the
  \texttt{BlogsEntryAssetRenderer} class:

\begin{verbatim}
@Override
public PortletURL getURLEdit(
        LiferayPortletRequest liferayPortletRequest,
        LiferayPortletResponse liferayPortletResponse)
    throws Exception {

    Group group = GroupLocalServiceUtil.fetchGroup(_entry.getGroupId());

    PortletURL portletURL = PortalUtil.getControlPanelPortletURL(
        liferayPortletRequest, group, BlogsPortletKeys.BLOGS, 0, 0,
        PortletRequest.RENDER_PHASE);

    portletURL.setParameter("mvcRenderCommandName", "/blogs/edit_entry");
    portletURL.setParameter("entryId", String.valueOf(_entry.getEntryId()));

    return portletURL;
}
\end{verbatim}

  The Asset Publisher loads the blogs asset using the Blogs application.
  Then the \texttt{edit\_entry.jsp} template generates the HTML for an
  editing UI. Once the necessary edits are made to the asset, it can be
  saved from the Asset Publisher. Pretty cool, right?
\item
  You can specify how to view your asset by providing methods similar to
  the methods outlined below in the \texttt{BlogsEntryAssetRenderer}
  class:

\begin{verbatim}
@Override
public String getURLView(
        LiferayPortletResponse liferayPortletResponse,
        WindowState windowState)
    throws Exception {

    AssetRendererFactory<BlogsEntry> assetRendererFactory =
        getAssetRendererFactory();

    PortletURL portletURL = assetRendererFactory.getURLView(
        liferayPortletResponse, windowState);

    portletURL.setParameter("mvcRenderCommandName", "/blogs/view_entry");
    portletURL.setParameter("entryId", String.valueOf(_entry.getEntryId()));
    portletURL.setWindowState(windowState);

    return portletURL.toString();
}

@Override
public String getURLViewInContext(
    LiferayPortletRequest liferayPortletRequest,
    LiferayPortletResponse liferayPortletResponse,
    String noSuchEntryRedirect) {

    return getURLViewInContext(
        liferayPortletRequest, noSuchEntryRedirect, "/blogs/find_entry",
        "entryId", _entry.getEntryId());
}
\end{verbatim}

  The \texttt{getURLView(...)} method generates a URL that displays the
  full content of the asset in the Asset Publisher. This is assigned to
  the clickable asset name. The \texttt{getURLViewInContext(...)} method
  provides a similar URL assigned to the asset name, but the URL
  redirects to the original context of the asset (e.g., viewing a blogs
  asset in the Blogs application). Deciding which view to render in
  Liferay DXP is configurable by navigating to the Asset Publisher's
  \emph{Options} (\includegraphics{./images/icon-app-options.png}) →
  \emph{Configuration} → \emph{Setup} → \emph{Display Settings} section
  and choosing between \emph{Show Full Content} and \emph{View in
  Context} for the Asset Link Behavior drop-down menu.
\end{enumerate}

The Blogs application provides \texttt{abstract} and
\texttt{full\_content} JSP templates that override the ones provided by
the \texttt{AssetRenderer} interface. The third template,
\texttt{preview}, could also be customized. You can view the default
\texttt{preview.jsp} template rendered in the \emph{Add}
(\includegraphics{./images/icon-control-menu-add.png}) →
\emph{Content} menu.

\begin{figure}
\centering
\includegraphics{./images/preview-template-asset-renderer.png}
\caption{The \texttt{preview} template displays a preview of the asset
in the Content section of the Add menu.}
\end{figure}

You've learned all about implementing the \texttt{AssetRenderer}'s
provided templates and customizing them to fit your needs. Next, you'll
put your asset renderer into action by creating a factory.

\subsection{Creating a Factory for the Asset
Renderer}\label{creating-a-factory-for-the-asset-renderer}

You've successfully created an asset renderer, but you must create a
factory class to generate asset renderers for each asset instance. For
example, the blogs asset renderer factory instantiates
\texttt{BlogsEntryAssetRenderer} for each blogs asset displayed in an
Asset Publisher.

You'll continue the blogs asset renderer example by creating the blogs
asset renderer factory.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create an \texttt{-AssetRenderFactory} class in the same folder as its
  asset renderer class. For blogs, the
  \href{https://github.com/liferay/liferay-portal/blob/7.0.6-ga7/modules/apps/collaboration/blogs/blogs-web/src/main/java/com/liferay/blogs/web/asset/BlogsEntryAssetRendererFactory.java}{BlogsEntryAssetRendererFactory}
  class resides in the \texttt{com.liferay.blogs.web} module's
  \texttt{com.liferay.blogs.web.asset} package. The factory class should
  extend the \texttt{BaseAssetRendererFactory} class and the asset type
  should be specified as its parameter. You can see how this was done in
  the \texttt{BlogsEntryAssetRendererFactory} class below

\begin{verbatim}
public class BlogsEntryAssetRendererFactory
    extends BaseAssetRendererFactory<BlogsEntry> {
\end{verbatim}
\item
  Create an \texttt{@Component} annotation section above the class
  declaration. This annotation is responsible for registering the
  factory instance for the asset.

\begin{verbatim}
@Component(
    immediate = true,
    property = {"javax.portlet.name=" + BlogsPortletKeys.BLOGS},
    service = AssetRendererFactory.class
)
public class BlogsEntryAssetRendererFactory
    extends BaseAssetRendererFactory<BlogsEntry> {
\end{verbatim}

  There are a few annotation elements you should set:

  \begin{itemize}
  \tightlist
  \item
    The \texttt{immediate} element directs the factory to start in
    Liferay DXP when its module starts.
  \item
    The \texttt{property} element sets the portlet that is associated
    with the asset. The Blogs portlet is specified, since this is the
    Blogs asset renderer factory.
  \item
    The \texttt{service} element should point to the
    \texttt{AssetRendererFactory.class} interface.
  \end{itemize}
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** In previous versions of Liferay DXP, you had to register the asset
 renderer factory in a portlet's `liferay-portlet.xml` file. The registration
 process is now completed automatically by OSGi using the `@Component`
 annotation.
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\item
  Create a constructor for the factory class that presets private
  attributes of the factory.

\begin{verbatim}
public BlogsEntryAssetRendererFactory() {
    setClassName(BlogsEntry.class.getName());
    setCategorizable(true);
    setLinkable(true);
    setPortletId(BlogsPortletKeys.BLOGS);
    setSearchable(true);
    setSelectable(true);
}
\end{verbatim}

  \begin{itemize}
  \tightlist
  \item
    \emph{linkable}: other assets can select blogs assets as their
    related assets.
  \item
    \emph{categorizable}: blogs can be used to delimit the scope of a
    vocabulary from the Categories Administration.
  \item
    \emph{searchable}: blogs can be found when searching for assets.
  \item
    \emph{selectable}: blogs can be selected when choosing assets to
    display in the Asset Publisher.
  \end{itemize}

  Setting the class name and portlet ID links the asset renderer factory
  to the entity.
\item
  Create the asset renderer for your asset. This is done by calling its
  constructor.

\begin{verbatim}
@Override
public AssetRenderer<BlogsEntry> getAssetRenderer(long classPK, int type)
    throws PortalException {

    BlogsEntry entry = _blogsEntryLocalService.getEntry(classPK);

    BlogsEntryAssetRenderer blogsEntryAssetRenderer =
        new BlogsEntryAssetRenderer(entry, _resourceBundleLoader);

    blogsEntryAssetRenderer.setAssetRendererType(type);
    blogsEntryAssetRenderer.setServletContext(_servletContext);

    return blogsEntryAssetRenderer;
}
\end{verbatim}

  For blogs, the asset is retrieved by calling the Blogs application's
  local service. Then the asset renderer is instantiated using the blogs
  asset and resource bundle loader. Next, the type and servlet context
  is set for the asset renderer. Finally, the configured asset renderer
  is returned.

  There are a few variables in the \texttt{getAssetRenderer(...)} method
  you must create. You'll set those variables and learn what they're
  doing next.

  \begin{enumerate}
  \def\labelenumii{\alph{enumii}.}
  \item
    You must get the entry by calling the Blogs application's local
    service. You can instantiate this service by creating a private
    field and setting it using a setter method:

    @Reference(unbind = ``-'') protected void setBlogsEntryLocalService(
    BlogsEntryLocalService blogsEntryLocalService) \{

\begin{verbatim}
 _blogsEntryLocalService = blogsEntryLocalService;
\end{verbatim}

    \}

    private BlogsEntryLocalService \_blogsEntryLocalService;
  \end{enumerate}

  The setter method is annotated with the \texttt{@Reference} tag. Visit
  the
  \href{/docs/7-0/tutorials/-/knowledge_base/t/finding-and-invoking-liferay-services\#invoking-liferay-services-locally}{Invoking
  Liferay Services Locally} section of the \emph{Finding and Invoking
  Liferay Services} tutorial for more information.

  \begin{enumerate}
  \def\labelenumii{\alph{enumii}.}
  \setcounter{enumii}{1}
  \item
    You must specify the resource bundle loader since it was specified
    in the \texttt{BlogsEntryAssetRenderer}'s constructor:

    @Reference( target =
    ``(bundle.symbolic.name=com.liferay.blogs.web)'', unbind = ``-'' )
    public void setResourceBundleLoader( ResourceBundleLoader
    resourceBundleLoader) \{

\begin{verbatim}
 _resourceBundleLoader = resourceBundleLoader;
\end{verbatim}

    \}

    private ResourceBundleLoader \_resourceBundleLoader;
  \end{enumerate}

  Make sure the \texttt{osgi.web.symbolicname} in the \texttt{target}
  property of the \texttt{@Reference} annotation is set to the same
  value as the \texttt{Bundle-SymbolicName} defined in the
  \texttt{bnd.bnd} file of the module the factory resides in.

  \begin{enumerate}
  \def\labelenumii{\alph{enumii}.}
  \setcounter{enumii}{2}
  \item
    The asset renderer \texttt{type} integer is set for the asset
    renderer, but why an integer? Liferay DXP needs to differentiate
    when it should display the latest \emph{approved} version of the
    asset, or the latest version, even if it's unapproved (e.g.,
    unapproved versions would be displayed for reviewers of the asset in
    a workflow). For these situations, the asset renderer factory should
    receive either

    \begin{itemize}
    \tightlist
    \item
      \texttt{0} for the latest version of the asset
    \item
      \texttt{1} for the latest approved version of the asset
    \end{itemize}
  \item
    Since the Blogs application provides its own JSPs, it must pass a
    reference of the servlet context to the asset renderer. This is
    always required when using custom JSPs in an asset renderer:

    @Reference( target =
    ``(osgi.web.symbolicname=com.liferay.blogs.web)'', unbind = ``-'' )
    public void setServletContext(ServletContext servletContext) \{
    \_servletContext = servletContext; \}

    private ServletContext \_servletContext;
  \end{enumerate}
\item
  Set the type of asset that the asset factory associates with and
  provide a getter method to retrieve that type. Also, provide another
  getter to retrieve the blogs entry class name, which is required:

\begin{verbatim}
public static final String TYPE = "blog";

@Override
public String getType() {
    return TYPE;
}

@Override
public String getClassName() {
    return BlogsEntry.class.getName();
}
\end{verbatim}
\item
  Set the Lexicon icon for the asset:

\begin{verbatim}
@Override
public String getIconCssClass() {
    return "blogs";
}
\end{verbatim}

  You can find a list of all available Lexicon icons at
  \url{https://liferay.github.io/clay/content/icons-lexicon/}.
\item
  Add methods that generate URLs to add and view the asset.

\begin{verbatim}
@Override
public PortletURL getURLAdd(
    LiferayPortletRequest liferayPortletRequest,
    LiferayPortletResponse liferayPortletResponse, long classTypeId) {

    PortletURL portletURL = PortalUtil.getControlPanelPortletURL(
        liferayPortletRequest, getGroup(liferayPortletRequest),
        BlogsPortletKeys.BLOGS, 0, 0, PortletRequest.RENDER_PHASE);

    portletURL.setParameter("mvcRenderCommandName", "/blogs/edit_entry");

    return portletURL;
}

@Override
public PortletURL getURLView(
    LiferayPortletResponse liferayPortletResponse,
    WindowState windowState) {

    LiferayPortletURL liferayPortletURL =
        liferayPortletResponse.createLiferayPortletURL(
            BlogsPortletKeys.BLOGS, PortletRequest.RENDER_PHASE);

    try {
        liferayPortletURL.setWindowState(windowState);
    }
    catch (WindowStateException wse) {
    }

    return liferayPortletURL;
}
\end{verbatim}

  If you're paying close attention, you may have noticed the
  \texttt{getURLView(...)} method was also implemented in the
  \texttt{BlogsEntryAssetRenderer} class. The asset renderer's
  \texttt{getURLView(...)} method creates a URL for the specific asset
  instance, whereas the factory uses the method to create a generic URL
  that only points to the application managing the assets (e.g., Blogs
  application).
\item
  Set the global permissions for all blogs assets:

\begin{verbatim}
@Override
public boolean hasAddPermission(
        PermissionChecker permissionChecker, long groupId, long classTypeId)
    throws Exception {

    return BlogsPermission.contains(
        permissionChecker, groupId, ActionKeys.ADD_ENTRY);
}

@Override
public boolean hasPermission(
        PermissionChecker permissionChecker, long classPK, String actionId)
    throws Exception {

    return BlogsEntryPermission.contains(
        permissionChecker, classPK, actionId);
}
\end{verbatim}
\end{enumerate}

Great! You've finished creating the Blogs application's asset renderer
factory! Now you have the knowledge to implement an asset renderer and
produce an asset renderer for each asset instance using a factory!

\chapter{Liferay's Workflow
Framework}\label{liferays-workflow-framework}

Enabling your application's entities to support workflow is so easy, you
could do it in your sleep (but don't try). Workflow enabled entities
require a few things:

\begin{itemize}
\item
  A workflow handler class to interact with Liferay's workflow back end
  and the entity's service layer.
\item
  Some extra fields in their database table that help keep track of
  their status.

  In most Liferay applications,
  \href{/docs/6-2/tutorials/-/knowledge_base/t/service-builder}{Service
  Builder} will be used to create those fields.
\item
  Updates to the service layer.

  The service layer needs code to populate the new fields when entities
  are added to the database.

  The service layer needs to send the entity through Liferay's workflow,
  and it needs to handle the workflow status of the entity when it's
  returned by the workflow.

  The service layer needs getters that return entities of the desired
  workflow status (usually \emph{approved}).
\item
  The View layer should account for the workflow status of displayed
  entities.
\end{itemize}

The code for most Liferay applications spans multiple modules, so where
should you implement the workflow handler? It should go in the module
with your service implementations. It's nice to keep your back end code
separate from your view layer and controller (in the MVC pattern).

\section{Creating a Workflow Handler}\label{creating-a-workflow-handler}

First create a Component class. It should extend
\texttt{BaseWorkflowHandler\textless{}T\textgreater{}}, an abstract
class that provides a default implementation of the
\texttt{WorkflowHandler\textless{}T\textgreater{}} service. Pass the
interface for your model as the type parameter for the class.

\begin{verbatim}
FooEntity WorkflowHandler extends BaseWorkflowHandler<FooEntity>
\end{verbatim}

Since you're publishing a service to be consumed in the OSGi runtime,
your workflow handler class needs to be registered. If you're using
Declarative Services, make it a Component class, using the
\texttt{@Component} annotation.

\begin{verbatim}
@Component(
    property = {"model.class.name=com.my.app.package.model.FooEntity"},
    service = WorkflowHandler.class
)
\end{verbatim}

It needs one property, to set \texttt{model.class.name} to the fully
qualified class name of the class you passed as the type parameter. It
also needs to declare the type of service being implemented
(\texttt{WorkflowHandler.class}).

What methods do you need to override in your workflow handler? Just
three:

\begin{verbatim}
@Override
public String getClassName() {

@Override
public String getType(Locale locale) {

@Override
public FooEntity updateStatus(int status, Map<String, Serializable> workflowContext) {
\end{verbatim}

The first two are pretty boilerplate. Most of the heavy lifting is being
done in the \texttt{updateStatus} method. It returns a call to a local
service method of the same name, so the status returned from the
workflow back end can be persisted to the entity table in the database.

The \texttt{updateStatus} method should take a user ID, the primary key
for the class (for example, \texttt{fooEntityId}), the workflow status,
the service context, and the workflow context. The status and the
workflow context can be obtained from the workflow back end. You'll need
to define the rest of the parameters, which can be obtained from the
workflow context.

\begin{verbatim}
@Override
public FooEntity updateStatus(
        int status, Map<String, Serializable> workflowContext)
    throws PortalException {

    long userId = GetterUtil.getLong(
        (String)workflowContext.get(WorkflowConstants.CONTEXT_USER_ID));
    long classPK = GetterUtil.getLong(
        (String)workflowContext.get(
            WorkflowConstants.CONTEXT_ENTRY_CLASS_PK));

    ServiceContext serviceContext = (ServiceContext)workflowContext.get(
        "serviceContext");

    return _fooEntityLocalService.updateStatus(
        userId, classPK, status, serviceContext, workflowContext);
}
\end{verbatim}

Now your entity can be handled by Liferay's workflow framework. Next,
update the service methods to account for workflow status, and add a new
method to update the status of an entity in the database.

\section{Updating the Service Layer}\label{updating-the-service-layer-1}

Make sure your entity database table has \texttt{status},
\texttt{statusByUserId}, \texttt{statusByUserName}, and
\texttt{statusDate} fields. If you're using service builder, add this to
your \texttt{service.xml} if you haven't already:

\begin{verbatim}
<column name="status" type="int" />
<column name="statusByUserId" type="long" />
<column name="statusByUserName" type="String" />
<column name="statusDate" type="Date" />
\end{verbatim}

Wherever you're setting the other database fields in your persistence
code, set the workflow status as a draft and set the other fields.

\begin{verbatim}
fooEntity.setStatus(WorkflowConstants.STATUS_DRAFT);
fooEntity.setStatusByUserId(userId);
fooEntity.setStatusByUserName(user.getFullName());
fooEntity.setStatusDate(serviceContext.getModifiedDate(null));
\end{verbatim}

With Service Builder driven Liferay applications, this will be in the
local service implementation class (\texttt{-LocalServiceImpl}).

Whenever an entity is added to the database you need to detect whether
workflow is installed and active. If not, you need to automatically mark
the entity as approved so it appears in the UI. If it is, you want to
leave it in draft status and send it to the workflow back end where it
can be properly handled. Thankfully, this whole process is easily done
with a single call to
\texttt{WorkflowHandlerRegistryUtil.startWorkflowInstance}. There are
several methods of this name which take a different parameter set, so
inspect the \texttt{WorkflowHandlerRegistryUtil}
\href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/workflow/WorkflowHandlerRegistryUtil.html}{class}
and decide which is right for your case.

\begin{verbatim}
WorkflowHandlerRegistryUtil.startWorkflowInstance(fooEntity.getCompanyId(),
        fooEntity.getGroupId(), fooEntity.getUserId(), FooEntity.class.getName(),
        fooEntity.getPrimaryKey(), fooEntity, serviceContext);
\end{verbatim}

Once you've set the database fields for workflow status and started the
workflow instance, implement the \texttt{updateStatus} method that you
need to call in the workflow handler. The workflow handler gets the
entity's status from the workflow back end and passes it to your service
layer, which persists the updated entity to the database.

\begin{verbatim}
fooEntity.setStatus(status);
fooEntity.setStatusByUserId(user.getUserId());
fooEntity.setStatusByUserName(user.getFullName());
fooEntity.setStatusDate(serviceContext.getModifiedDate(now));

fooEntityPersistence.update(fooEntity);
\end{verbatim}

After setting the workflow fields for the entity, think about the
specifics of your situation and whether any additional logic should be
added to this method. For instance, if your entities are Liferay Assets
already, you'll want to change the visibility of the asset depending on
its workflow status. You don't want the Asset Publisher displaying
entities that haven't yet been approved in the workflow process.

\begin{verbatim}
if (status == WorkflowConstants.STATUS_APPROVED) {

    assetEntryLocalService.updateEntry(
        FooEntity.class.getName(), fooEntityId, fooEntity.getDisplayDate(),
        null, true, true);
}

else {

    assetEntryLocalService.updateVisible(
        fooEntity.class.getName(), entryId, false);
}
\end{verbatim}

If approved, the asset is updated, with the publication date, a
\texttt{listable} boolean, and a \texttt{visible} boolean being updated
to reflect the current state of the asset. If the workflow status is
anything other than approved, its visibility is set to \texttt{false}.

For an example of a fully implemented \texttt{updateStatus} method, see
the
\texttt{com.liferay.portlet.blogs.service.impl.BlogsEntryLocalServiceImpl}
class in \texttt{portal-impl}.

Before leaving the service layer, add a call to
\texttt{deleteWorkflowInstanceLinks} in the \texttt{deleteEntity}
method. Here's what it looks like:

\begin{verbatim}
workflowInstanceLinkLocalService.deleteWorkflowInstanceLinks(
    fooEntity.getCompanyId(), fooEntity.getGroupId(),
    FooEntity.class.getName(), fooEntity.getFooEntityId());
\end{verbatim}

When you send an entity to the workflow framework via the
\texttt{startWorkflowInstance} call, it creates an entry in the
\texttt{workflowinstancelink} database table. This \texttt{delete} call
ensures there are no orphaned entries in the
\texttt{workflowinstancelinks} table.

Note, to get the \texttt{WorkflowInstanceLocalService} injected into
your \texttt{*LocalServiceBaseImpl} so you can call its methods in the
\texttt{LocalServiceImpl}, add this to your entity declaration in
\texttt{service.xml}:

\begin{verbatim}
    <reference entity="WorkflowInstanceLink" package-path="com.liferay.portal" />
\end{verbatim}

Save your work and run Service Builder. Once you've accounted for
workflow status in your service layer, there's only one thing left to
do: update the user interface.

\section{Workflow Status and the View
Layer}\label{workflow-status-and-the-view-layer}

If you have an application with database entities, you're likely
displaying them. If you're sending entities through a workflow process,
you only want to display approved entities to your end users.

This often involves the following steps:

\begin{itemize}
\item
  Create a \emph{finder} for your entities that accounts for the
  \texttt{status} field in your database table.
\item
  Expose the finder in a \emph{getter} method of your service layer.
\item
  Update the view layer to use the new getter for displaying entities
  (e.g., in a Search Container).
\end{itemize}

If you're using Service Builder, define your finder in your
application's \texttt{service.xml} and let Service Builder generate it
for you.

\begin{verbatim}
<finder name="G_S" return-type="Collection">
    <finder-column name="groupId"></finder-column>
    <finder-column name="status"></finder-column>
</finder>
\end{verbatim}

Then make sure you have a getter in your service layer that uses the new
finder.

\begin{verbatim}
public List<FooEntity> getFooEntities(long groupId, int status)
       throws SystemException {
    return fooEntityPersistence.findByG_S(groupId,
         WorkflowConstants.STATUS_APPROVED);
}
\end{verbatim}

Now all you need to do is update your JSP to use the appropriate getter.

\begin{verbatim}
<liferay-ui:search-container-results
    results="<%=FooEntityLocalServiceUtil.getFooEntities(scopeGroupId,
              fooEntityId(), Workflowconstants.STATUS_APPROVED, searchContainer.getStart(),
              searchContainer.getEnd())%>"
    ...
\end{verbatim}

In an \emph{administrative} type application (in other words, one that's
displayed in the Site Menu's \emph{Content} section) you might want to
display all the entities, with their current workflow status (for
example, include workflow status as a column in the search container).
To do so, use the \texttt{\textless{}aui:worklfow-status\textgreater{}}
tag.

\begin{verbatim}
    <aui:workflow-status markupView="lexicon" showIcon="<%= false %>" showLabel="<%= false %>" status="<%= fooEntity.getStatus() %>" />
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/workflow-status-list-view.png}
\caption{You can display the workflow status of your entities. This is
useful in administrative applications.}
\end{figure}

You only needed one new class, one new method in the service layer, and
some updates to your view, and workflow is fully implemented and ready
to use in your Liferay application.

\chapter{Export/Import and Staging}\label{exportimport-and-staging}

Liferay DXP's Export/Import and Staging features give users the power to
plan page publication and manage content. The Export/Import feature lets
users export content from the Portal and import external content into
the Portal. Providing the export feature in your application allows
users the flexibility of exporting content they've created in your
application to other places, such as another portal instance, or to save
the content for a later use. Import does the opposite: it brings the
data from a LAR file into your portal.

For instance, suppose you're managing an online education course using
Liferay DXP. Because of the nature of an online course, the site's data
(grades, assignments, etc.) is purged every semester to make way for new
incoming students. In a scenario like this, there is a need frequently
to store a complete record of all data given during a course. The
institution offering the course must usually keep records of the
course's data for a minimum number of years. To abide by these
requirements, having a gradebook application with an export/import
feature would allow you to clear the application's data for a new
semester, but save the previous class's work. You could export the
students' grades as a LAR file and save it outside the course's site. If
the grades ever needed to be accessed again, you could import the LAR
and view the student records.

The Export/Import feature adds another dimension to your application by
letting you produce reusable content and import content from other
places. To learn more about using the Export/Import feature, visit the
\href{/docs/7-0/user/-/knowledge_base/u/exporting-importing-app-data}{Exporting/Importing
App Data} section of the User Guide.

Staging lets you change your site behind the scenes without affecting
the live site, and then you can publish all the changes in one fell
swoop. Keep in mind that Staging leverages the Export/Import framework,
which is an essential part of the publishing process. If you include
staging support in your application, your users can stage its content
until it's ready.

For example, if you have an application that provides information
intended only during a specific holiday, supporting the Staging
environment lets users save your application's assets specific for that
holiday. They'll reside in the Staging environment until they're ready
for publishing. To learn more about Staging, visit the
\href{/docs/7-0/user/-/knowledge_base/u/staging-content-for-publication}{Staging
Content for Publication} section.

Besides configuring these features for your application, Liferay also
provides an API that allows developers to write custom code, extending
Liferay's default functionality.

In this section of tutorials, you'll learn how to implement Staging and
the Export/Import framework. The main areas of Staging code to focus on
are outlined below:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \texttt{StagedModel} Interface: The \texttt{StagedModel} is the
  cornerstone of Staging. All content that must be handled in Staging
  should implement this interface; it provides the behavior contract for
  the entities Staging uses during the Staging process.
\item
  \texttt{StagedModelDataHandler}: These data handlers are responsible
  for handling one specific entity class. For example, the
  \texttt{BookmarksEntryStagedModelDataHandler} handles the
  \texttt{BookmarksEntry} during Staging: exporting data, serializing
  content, finding existing entries, etc.
\item
  \texttt{PortletDataHandler}: These data handlers are responsible for
  handling aspects of the portlet's configuration and publication during
  Staging.
\item
  \texttt{ExportActionableDynamicQuery}: This framework is useful when
  developing Staging support. Its purpose is to query data from the
  database and process it during publication. It's automatically
  generated if your entity contains the right fields so there's no need
  to worry about configuring it.
\item
  \texttt{ExportImportContentProcessor} and
  \texttt{ExportImportPortletPreferencesProcessor}: Advanced frameworks
  only needed in special cases. The
  \texttt{ExportImportContentProcessor} lets you process your content
  during a publication process. The
  \texttt{ExportImportPortletPreferencesProcessor} lets you process your
  portlet preferences (application's configuration) during a publication
  process.
\end{enumerate}

\section{Decision to Implement
Staging}\label{decision-to-implement-staging}

Liferay DXP's Staging feature is an advanced publication tool that lets
you create or modify your site before releasing it to the public. Most
of Liferay DXP's included applications (e.g., Web Content and Bookmarks)
support Staging. Implementing Staging in your own application can be
beneficial, but how do you know if it's the right move?

Not every application needs to support Staging and Export/Import. The
most important question to consider during the decision process is

\emph{What part of your application are you primarily focused on using
Staging for?}

When Staging is enabled in Liferay DXP, all pages and applications are
staged automatically. Liferay DXP's architecture separates the
application and its configuration from the actual content, meaning that
content can exist without any application to display it and vice versa.
Although Staging and the Export/Import framework supports all
applications and their configurations by default, not all applications'
content is supported by Staging.

Implementing Staging for your application means you're defining the
logic for how the Staging framework should process, serialize, and
de-serialize your app's content, and how to insert it into a database.

Therefore, if you want to track your application's content, you should
implement Staging in your application. Here are a few other scenarios
where you should implement Staging in your application:

\begin{itemize}
\tightlist
\item
  You're using remote staging. When publishing to a remote live site,
  your content must be transferred to a different Liferay DXP
  installation. Therefore, Staging must be able to recognize the content
  to facilitate the transfer.
\item
  You want a space where you can freely edit and test your content
  before publishing it to a live audience.
\item
  Your content is being referenced from another content type that
  supports Staging.
\item
  You want to process your portlet's preferences during publication
  (i.e., you might want to publish some content with it or complete
  extra steps).
\item
  You want to process the content during publication (e.g., writing
  validation for your content during the import process).
\end{itemize}

If none of these options are beneficial for you, implementing Staging in
your application is unnecessary.

When content supports Staging and Staging is enabled, it is created in a
Staging group and is only published to a live site when that site is
published. When content is \textbf{not} supported by Staging, it is
never added to a Staging group and is not reviewable during the Staging
publication process; it's added and removed from the live site only.

From a technical standpoint, publishing an entity or content follows the
process below:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  The entity's possible references are discovered and processed.
\item
  The entity's fields are processed.
\item
  The entity is serialized into a LAR file.
\item
  The LAR is transferred to the live site (local or remote live).
\item
  After de-serialization, the entity's fields are processed.
\item
  The entity is added to the database.
\end{enumerate}

Awesome! You should now have a good idea about whether you should
implement Staging for your application.

\section{Understanding Staged Models}\label{understanding-staged-models}

To track an entity of an application with the Staging framework, you
must implement the
\href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/model/StagedModel.html}{StagedModel}
interface in the app's model classes. It provides the behavior contract
for entities during the Staging process. For example, the Bookmarks
application manages
\href{@app-ref@/collaboration/latest/javadocs/com/liferay/bookmarks/model/BookmarksEntry.html}{BookmarksEntry}s
and
\href{@app-ref@/collaboration/latest/javadocs/com/liferay/bookmarks/model/BookmarksFolder.html}{BookmarksFolder}s,
and both implement the \texttt{StagedModel} interface. Once you've
configured your staged models, you can create staged model data
handlers, which supply information about a staged model (entity) and its
referenced content to the Export/Import and Staging frameworks. See the
\href{/docs/7-0/tutorials/-/knowledge_base/t/understanding-data-handlers}{Understanding
Data Handlers} tutorial for more information.

There are two ways to create staged models for your application's
entities:

\begin{itemize}
\tightlist
\item
  Using Service Builder to generate the required Staging implementations
  (\href{/docs/7-0/tutorials/-/knowledge_base/t/generating-staged-models-using-service-builder}{tutorial}).
\item
  Implementing the required Staging interfaces manually
  (\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-staged-models-manually}{tutorial}).
\end{itemize}

You can follow step-by-step procedures for creating staged models for
your entities by visiting their respective tutorials.

Using Service Builder to generate your staged models is the easiest way
to create staged models for your app. You define the necessary columns
in your \texttt{service.xml} file and set the \texttt{uuid} attribute to
\texttt{true}. Then you run Service Builder, which generates the
required code for your new staged models.

Implementing the necessary staged model logic \emph{manually} should be
done if you \textbf{don't} want to extend your model with special
attributes only required to generate Staging logic (i.e., not needed by
your business logic). In this case, you should adapt your business logic
to meet the Staging framework's needs. You'll learn more about this
later.

You'll explore the provided staged model interfaces next.

\subsection{Staged Model Interfaces}\label{staged-model-interfaces}

The \texttt{StagedModel} interface must be implemented by your app's
model classes, but this is typically done through inheritance by
implementing one of the interfaces that extend the base interface:

\begin{itemize}
\tightlist
\item
  \href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/model/StagedAuditedModel.html}{StagedAuditedModel}
\item
  \href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/model/StagedGroupedModel.html}{StagedGroupedModel}
\end{itemize}

You must implement these when you want to use certain features of the
Staging framework like automatic group mapping or entity level
\emph{Last Publish Date} handling. So how do you choose which is right
for you?

The \texttt{StagedAuditedModel} interface provides all the audit fields
to the model that implements it. You can check the
\href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/model/AuditedModel.html}{AuditedModel}
interface for the specific audit fields provided. The
\texttt{StagedAuditedModel} interface is intended for models that
function independent from the group concept (sometimes referred to as
company models). If your model is a group model, you should not
implement the \texttt{StagedAuditedModel} interface.

The \texttt{StagedGroupedModel} interface must be implemented for group
models. For example, if your application requires the \texttt{groupId}
column, your model is a group model. If your model satisfies both the
\texttt{StagedGroupModel} and \texttt{StagedAuditedModel} requirements,
it should implement the \texttt{StagedGroupedModel}. Your model should
only implement the \texttt{StagedAuditedModel} if it doesn't fulfill the
grouped model needs, but does fulfill the audited model needs. If your
model does not fulfill either the \texttt{StagedAuditedModel} or
\texttt{StagedGroupedModel} requirements, you should implement the base
\texttt{StagedModel} interface.

As an example for extending your model class, you can visit the
\href{@app-ref@/collaboration/latest/javadocs/com/liferay/bookmarks/model/BookmarksEntryModel.html}{BookmarksEntryModel}
class, which extends the \texttt{StagedGroupedModel} interface; this is
done because bookmark entries are group models.

\begin{verbatim}
public interface BookmarksEntryModel extends BaseModel<BookmarksEntry>,
    ShardedModel, StagedGroupedModel, TrashedModel, WorkflowedModel {
\end{verbatim}

Now that you have a better understanding about staged model interfaces,
you'll dive into the attributes used in Staging and why they're
important.

\subsection{Important Attributes in
Staging}\label{important-attributes-in-staging}

If you'd like to generate your staged models using
\href{/docs/7-0/tutorials/-/knowledge_base/t/service-builder}{Service
Builder}, you must define the proper attributes in your project's
\texttt{service.xml} file. If you'd like more detail on how this is
done, see the
\href{/docs/7-0/tutorials/-/knowledge_base/t/generating-staged-models-using-service-builder}{Generating
Staged Models using Service Builder} tutorial. You'll learn some general
information about this process next.

One of the most important attributes used by the Staging framework is
the UUID (Universally Unique Identifier). This attribute must be set to
\texttt{true} in your \texttt{service.xml} file for Service Builder to
recognize your model as an eligible staged model. The UUID is used to
differentiate entities between environments. Because the UUID always
remains the same, it's unique across multiple systems. Why is this so
important?

Suppose you're using
\href{/docs/7-0/user/-/knowledge_base/u/enabling-remote-live-staging}{remote
staging} and you create a new entity on your local staging site and
publish it to your remote live site. What happens when you go back to
modify the entity on your local site and want to publish those changes?
Without a UUID, the Staging framework has no way to know the local and
remote entities are the same. To publish entities properly, the Staging
framework needs entities uniquely identified across systems to recognize
the original entity on the remote site and update it. The UUID provides
that.

In addition to the UUID, there are several columns that must be defined
in your \texttt{service.xml} file for Service Builder to define your
model as a staged model:

\begin{itemize}
\tightlist
\item
  \texttt{companyId}
\item
  \texttt{createDate}
\item
  \texttt{modifiedDate}
\end{itemize}

If you want a staged grouped model, also include the \texttt{groupId}
and \texttt{lastPublishDate} columns. If you want a staged audited
model, include the \texttt{userId} and \texttt{userName} columns.

Next, you'll learn how to build staged models from scratch.

\subsection{Adapting Your Business Logic to Build Staged
Models}\label{adapting-your-business-logic-to-build-staged-models}

What if you don't want to extend your model with special attributes that
may not be needed in your business logic? In this case, you should adapt
your business logic to meet the Staging framework's needs. Liferay
provides the
\href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/model/adapter/builder/ModelAdapterBuilder.html}{ModelAdapterBuilder}
framework, which lets you adapt your model classes to staged models.

As an example, assume you have an app that is fully developed and you
want to configure it to work with Staging. Your app, however, does not
require a UUID for any of its entities, and therefore, does not provide
them. Instead of configuring your app to handle UUIDs just for the sake
of generating staged models, you can leverage the Model Adapter Builder
to build your staged models.

Another example for building staged models from scratch is for
applications that use REST services to access their attributes instead
of the database. Since this kind of app is developed to pull its
attributes from a remote system, it would be more convenient to build
your staged models yourself instead of relying on Service Builder, which
is database driven.

To adapt your model classes to staged models, follow the steps outlined
below:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a \texttt{Staged{[}Entity{]}} interface, which extends the
  model specific interface (e.g., \texttt{{[}Entity{]}}) and the
  appropriate staged model interface (e.g., \texttt{StagedModel}). This
  class serves as the Staged Model Adapter.
\item
  Create a \texttt{Staged{[}Entity{]}Impl} class that implements the
  \texttt{Staged{[}Entity{]}} interface and provides necessary logic for
  your entity model to be recognized as a staged model.
\item
  Create a \texttt{Staged{[}Entity{]}ModelAdapterBuilder} class that
  implements
  \texttt{ModelAdapterBuilder\textless{}{[}Entity{]},\ Staged{[}Entity{]}\textgreater{}}.
  This class adapts the original model to the newly created Staged Model
  Adapter.
\item
  Adapt your existing model and call one of the provided APIs to export
  or import the entity automatically.
\end{enumerate}

\begin{figure}
\centering
\includegraphics{./images/staged-model-adapter-diagram.png}
\caption{The Staged Model Adapter class extends your entity and staged
model interfaces.}
\end{figure}

\begin{figure}
\centering
\includegraphics{./images/model-adapter-builder-diagram.png}
\caption{The Model Adapter Builder gets an instance of the model and
outputs a staged model.}
\end{figure}

To step through the process for leveraging the Model Adapter Builder for
an existing app, visit the
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-staged-models-manually}{Creating
Staged Models Manually} tutorial.

\section{Generating Staged Models Using Service
Builder}\label{generating-staged-models-using-service-builder}

{This document has been updated and ported to Liferay Learn and is no
longer maintained here.}

A Staged model is an essential building block to implementing the
Staging and Export/Import frameworks in your application. Instead of
having to create staged models for your app manually, you can leverage
\href{/docs/7-0/tutorials/-/knowledge_base/t/service-builder}{Service
Builder} to generate the necessary staged model logic for you. Before
diving into this tutorial, make sure you've read the
\href{/docs/7-0/tutorials/-/knowledge_base/t/understanding-staged-models}{Understanding
Staged Models} tutorial for information on how staged models work. Also,
if your app doesn't use Liferay's Service Builder, you must configure it
in your project. If you need help doing this, follow the
\href{/docs/7-0/tutorials/-/knowledge_base/t/defining-an-object-relational-map-with-service-builder}{Defining
an Object-Relational Map with Service Builder} tutorial.

This tutorial assumes you have a Service Builder project with
\texttt{*api} and \texttt{*service} modules. If you want to follow along
with this tutorial, download the staged-model-example Service Builder
project. This is a bare-bones project that you can test to observe the
Staging-related changes generated by running Service Builder. This
tutorial assumes your project is built with Gradle. The example
project's \texttt{service.xml} file contains the following
configuration:

\begin{verbatim}
<service-builder package-path="com.liferay.docs">
    <namespace>FOO</namespace>
    <entity local-service="true" name="Foo" remote-service="true" uuid="true">

        <!-- PK fields -->

        <column name="fooId" primary="true" type="long" />

        <!-- Group instance -->

        <column name="groupId" type="long" />

        <!-- Audit fields -->

        <column name="companyId" type="long" />
        <column name="createDate" type="Date" />
        <column name="modifiedDate" type="Date" />

        ...
        ...

    </entity>
</service-builder>
\end{verbatim}

For simplicity, you'll track the Service Builder-generated changes
applied to an entity model file to observe how staged models are
assigned to your entity. Keep in mind the specific
\href{/docs/7-0/tutorials/-/knowledge_base/t/understanding-staged-models\#important-attributes-in-staging}{staged
attributes} necessary for each staged model. Depending on the attributes
defined in your \texttt{service.xml} file, Service Builder assigns your
entity model to a specific staged model type.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Navigate to your project's \texttt{*service} module at the command
  line. Run Service Builder (e.g., \texttt{gradlew\ buildService}) to
  generate your project's models based on the current
  \texttt{service.xml} configuration.
\item
  Open your project's \texttt{{[}Entity{]}Model.java} interface and
  observe the inherited interfaces.

\begin{verbatim}
public interface FooModel extends BaseModel<Foo>, ShardedModel, StagedModel {
\end{verbatim}

  Your model was generated as a staged model! This is because the UUID
  is set to \texttt{true} and the \texttt{companyId},
  \texttt{createDate}, and \texttt{modifiedDate} columns are defined.
  There is much more logic generated for your app behind the scenes, but
  this shows that Service Builder deemed your entity eligible for the
  Staging and Export/Import frameworks.
\item
  Add the \texttt{userId} and \texttt{userName} columns to your
  \texttt{service.xml} file:

\begin{verbatim}
    <column name="userId" type="long" />
    <column name="userName" type="String" />
\end{verbatim}
\item
  Rerun Service Builder and observe your \texttt{{[}Entity{]}Model.java}
  interface again:

\begin{verbatim}
public interface FooModel extends BaseModel<Foo>, GroupedModel, ShardedModel,
    StagedAuditedModel {
\end{verbatim}

  Your model is now a staged audited model!
\item
  Add the \texttt{lastPublishDate} column to your \texttt{service.xml}
  file:

\begin{verbatim}
<column name="lastPublishDate" type="Date" />
\end{verbatim}
\item
  Rerun Service Builder and observe your \texttt{{[}Entity{]}Model.java}
  interface again:

\begin{verbatim}
public interface FooModel extends BaseModel<Foo>, ShardedModel,
    StagedGroupedModel {
\end{verbatim}

  Your model is now a staged grouped model! The \texttt{groupId} column
  is also required to extend the \texttt{StagedGroupedModel} interface,
  but it was already defined in the original \texttt{service.xml} file.
\end{enumerate}

Fantastic! You've witnessed firsthand how easy it is to generate staged
models using Service Builder.

\section{Creating Staged Models
Manually}\label{creating-staged-models-manually}

There are times when using
\href{/docs/7-0/tutorials/-/knowledge_base/t/understanding-staged-models\#important-attributes-in-staging}{Service
Builder to generate your staged models} is not practical. In these
cases, you should create your staged models manually. Make sure to read
the
\href{/docs/7-0/tutorials/-/knowledge_base/t/understanding-staged-models\#adapting-your-business-logic-to-build-staged-models}{Adapting
Your Business Logic to Build Staged Models} section to determine if
creating staged models manually is beneficial for your use case.

In this tutorial, you'll explore how the Asset Link framework (a Liferay
DXP framework used for
\href{/docs/7-0/user/-/knowledge_base/u/defining-content-relationships}{relating
assets}) manually creates staged models. This framework is separate from
Staging and is referenced solely as an example for how to leverage the
\href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/model/adapter/builder/ModelAdapterBuilder.html}{ModelAdapterBuilder}
framework, which lets you adapt your model classes to staged models.

Asset links do not provide UUIDs by default; however, they still need to
be tracked in the Staging and Export/Import frameworks. Therefore, they
require staged models. Since they don't provide a UUID, Service Builder
cannot generate staged models for asset links. The Asset Link framework
has to create staged models differently using the Model Adapter Builder.
The naming convention for this interface typically follows the
\texttt{Staged{[}Entity{]}} syntax. The Asset Link framework uses a
generic entity called \texttt{AssetLink}.

Follow the steps below to leverage the Model Adapter Builder in your
app.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a new interface that extends one of the
  \href{/docs/7-0/tutorials/-/knowledge_base/t/understanding-staged-models\#staged-model-interfaces}{staged
  model interfaces} and your model specific interface. For example,

\begin{verbatim}
public interface StagedAssetLink extends AssetLink, StagedModel {

}
\end{verbatim}

  This interface should define methods required for your model to
  qualify as a staged model. For asset links, methods for retrieving
  entry UUIDs (among others) are defined:

\begin{verbatim}
public String getEntry1Uuid();

public String getEntry2Uuid();
\end{verbatim}

  These will be implemented by a new implementation class later.
\item
  Create an implementation class that implements your new
  \texttt{Staged{[}Entity{]}}. For example, the Asset Link framework
  does this:

\begin{verbatim}
public class StagedAssetLinkImpl implements StagedAssetLink {

}
\end{verbatim}

  This class provides necessary logic for your entity model to be
  recognized as a staged model. Below is a subset of logic in the
  example \texttt{StagedAssetLinkImpl} class used to populate UUIDs for
  asset link entries:

\begin{verbatim}
public StagedAssetLinkImpl(AssetLink assetLink) {
     _assetLink = assetLink;

    ...

     populateUuid();
}

@Override
public String getEntry1Uuid() {
    if (Validator.isNotNull(_entry1Uuid)) {
        return _entry1Uuid;
    }

    populateEntry1Attributes();

    return _entry1Uuid;
}

@Override
public String getEntry2Uuid() {
    if (Validator.isNotNull(_entry2Uuid)) {
        return _entry2Uuid;
    }

    populateEntry2Attributes();

    return _entry2Uuid;
}

protected void populateEntry1Attributes() {

    ...

    AssetEntry entry1 = AssetEntryLocalServiceUtil.fetchAssetEntry(
        _assetLink.getEntryId1());

    ...

    _entry1Uuid = entry1.getClassUuid();
}

protected void populateEntry2Attributes() {

    ...

    AssetEntry entry2 = AssetEntryLocalServiceUtil.fetchAssetEntry(
        _assetLink.getEntryId2());

    ...

    _entry2Uuid = entry2.getClassUuid();
}

protected void populateUuid() {

    ...

    String entry1Uuid = getEntry1Uuid();
    String entry2Uuid = getEntry2Uuid();

    ...

    _uuid = entry1Uuid + StringPool.POUND + entry2Uuid;
        }
}

private AssetLink _assetLink;
private String _entry1Uuid;
private String _entry2Uuid;
private String _uuid;
\end{verbatim}

  This logic retrieves asset link entries and populates UUIDs for them
  usable by the Staging and Export/Import frameworks. With the newly
  generated UUIDs, asset link model classes can be converted to staged
  models.
\item
  Create a Model Adapter Builder class and implement the
  \href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/model/adapter/builder/ModelAdapterBuilder.html}{ModelAdapterBuilder}
  interface. You should define the entity type and your Staged Model
  Adapter class when implementing the interface:

\begin{verbatim}
public class StagedAssetLinkModelAdapterBuilder
    implements ModelAdapterBuilder<AssetLink, StagedAssetLink> {

    @Override
    public StagedAssetLink build(AssetLink assetLink) {
        return new StagedAssetLinkImpl(assetLink);
    }

}
\end{verbatim}

  For the \texttt{StagedAssetLinkModelAdapterBuilder}, the entity type
  is \texttt{AssetLink} and the Staged Model Adapter is
  \texttt{StagedAssetLink}. Your app should follow a similar design. The
  Model Adapter Builder outputs a new instance of the
  \texttt{Staged{[}Entity{]}Impl} object.
\item
  Now you need to adapt your existing business logic to call the
  provided APIs. You can call the
  \href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/model/adapter/ModelAdapterUtil.html}{ModelAdapterUtil}
  class to create an instance of your Staged Model Adapter. See how the
  Asset Link framework does this below:

\begin{verbatim}
StagedAssetLink stagedAssetLink = ModelAdapterUtil.adapt(
    assetLink, AssetLink.class, StagedAssetLink.class);
\end{verbatim}

  Once you've created
  \href{/docs/7-0/tutorials/-/knowledge_base/t/data-handlers}{Staged
  Model Data Handlers}, you can begin exporting/importing your now
  Staging-compatible entities:

\begin{verbatim}
StagedModelDataHandlerUtil.exportStagedModel(
    portletDataContext, stagedAssetLink);
\end{verbatim}

  Visit the
  \href{/docs/7-0/tutorials/-/knowledge_base/t/understanding-data-handlers}{Understanding
  Data Handlers} tutorial if you're unfamiliar with how data handlers
  work.
\end{enumerate}

Awesome! You've successfully adapted your business logic to build staged
models!

\section{Understanding Data Handlers}\label{understanding-data-handlers}

A common requirement for many data driven applications is to import and
export data. This \emph{could} be accomplished by accessing your
database directly and running SQL queries to export/import data;
however, this has several drawbacks:

\begin{itemize}
\tightlist
\item
  Working with different database vendors might require customized SQL
  scripts.
\item
  Access to the database may be tightly controlled, restricting the
  ability to export/import on demand.
\item
  You'd have to come up with your own means of storing and parsing the
  data.
\end{itemize}

Liferay provides a more convenient and reliable way to export/import
your data without accessing the database.

\subsection{Liferay Archive (LAR) File}\label{liferay-archive-lar-file}

An easier way to export/import your application's data is to use a
Liferay ARchive (LAR) file. Liferay provides the LAR feature to address
the need to export/import data in a database agnostic manner. So what
exactly is a LAR file?

A LAR file is a compressed file (ZIP archive) Liferay DXP uses to
export/import data. LAR files can be created for single portlets, pages,
or sets of pages. Portlets that are LAR-capable provide an interface to
let you control how their data are imported/exported. There are several
Liferay DXP use cases that require the use of LAR files:

\begin{itemize}
\tightlist
\item
  Backing up and restoring portlet-specific data without requiring a
  full database backup.
\item
  Cloning sites.
\item
  Specifying a template to be used for users' public or private pages.
\item
  Using Local Live or Remote Live staging.
\end{itemize}

Liferay provides the data handler framework so developers don't have to
create/modify a LAR file manually. \textbf{It is strongly recommended
never to modify a LAR file.} You should always use Liferay's provided
data handler APIs to construct it.

Knowing how a LAR file is constructed, however, is beneficial to
understand the overall purpose of your application's data handlers.
Next, you'll explore a LAR file's anatomy.

\subsubsection{LAR File Anatomy}\label{lar-file-anatomy}

What is a LAR file? You know the general concept for \emph{why} it's
used, but you may want to know what lives inside to make your
export/import processes work. With a fundamental understanding for how a
LAR file is constructed, you can better understand what your data
handlers generate behind the scenes.

Below is the structure of a simple LAR file. It illustrates the
exportation of a single Bookmarks entry and the portlet's configuration:

\begin{itemize}
\tightlist
\item
  \texttt{Bookmarks\_Admin-201701091904.portlet.lar}

  \begin{itemize}
  \tightlist
  \item
    \texttt{group}

    \begin{itemize}
    \tightlist
    \item
      \texttt{20143}

      \begin{itemize}
      \tightlist
      \item
        \texttt{com.liferay.bookmarks.model.BookmarksEntry}

        \begin{itemize}
        \tightlist
        \item
          \texttt{35005.xml}
        \end{itemize}
      \item
        \texttt{portlet}

        \begin{itemize}
        \tightlist
        \item
          \texttt{com\_liferay\_bookmarks\_web\_portlet\_BookmarksAdminPortlet}

          \begin{itemize}
          \tightlist
          \item
            \texttt{20137}

            \begin{itemize}
            \tightlist
            \item
              \texttt{portlet.xml}
            \end{itemize}
          \item
            \texttt{20143}

            \begin{itemize}
            \tightlist
            \item
              \texttt{portlet-data.xml}
            \end{itemize}
          \end{itemize}
        \end{itemize}
      \end{itemize}
    \end{itemize}
  \item
    \texttt{manifest.xml}
  \end{itemize}
\end{itemize}

You can tell from the LAR's generated name what information is contained
in the LAR: the Bookmarks Admin app's data. The \texttt{manifest.xml}
file sits at the root of the LAR file. It provides essential information
about the export process. The \texttt{manifest.xml} for the sample
Bookmarks LAR is pretty bare since it's not exporting much content, but
this file can become large when exporting pages of content. There are
four main parts (tags) to a \texttt{manifest.xml} file.

\begin{itemize}
\tightlist
\item
  \texttt{header}: contains information about the LAR file, current
  process, and site you're exporting (if necessary). For example, it can
  include locales, build information, export date, company ID, group ID,
  layouts, themes, etc.
\item
  \texttt{missing-references}: lists entities that must be validated
  during import. For example, suppose you're exporting a web content
  article that references an image (e.g., an embedded image residing in
  the document library). If the image was not selected for export, the
  image must already exist in the site where the article is imported.
  Therefore, the image would be flagged as a missing reference in the
  LAR file. If the missing reference does not exist in the site when the
  LAR is imported, the import process fails. If your import fails, the
  Import UI shows you the missing references that weren't validated.
\item
  \texttt{portlets}: defines the portlets (i.e., portlet data) exported
  in the LAR. Each portlet definition has basic information on the
  exported portlet and points to the generated \texttt{portlet.xml} for
  more specialized portlet information.
\item
  \texttt{manifest-summary}: contains information on what has been
  exported. The Staging and Export frameworks export or publish some
  entities even though they weren't marked for it, because the process
  respects data integrity. This section holds information for all the
  entities that have been processed. The entities defining a non-zero
  \texttt{addition-count} attribute are displayed in the Export/Import
  UI.
\end{itemize}

The \texttt{manifest.xml} file also defines layout information if you've
exported pages in your LAR. For example, your manifest could have
\texttt{LayoutSet}, \texttt{Layout}, and \texttt{LayoutFriendlyURL} tags
specifying staged models and their various references in an exported
page.

Now that you've learned about the LAR's \texttt{manifest.xml} and how
it's used to store high-level data about your export process, you can
dive deeper into the LAR file's \texttt{group} folder. The
\texttt{group} folder has two main parts:

\begin{itemize}
\tightlist
\item
  Entities
\item
  Portlets
\end{itemize}

If you look at the anatomy of the sample Bookmarks LAR, you'll notice
that \texttt{group/{[}groupId{]}} folder holds a folder named after the
entity you're exporting (e.g.,
\texttt{com.liferay.bookmarks.model.BookmarksEntry}) and a
\texttt{portlet} folder holding a folder named after the portlet from
which you're exporting (e.g.,
\texttt{com\_liferay\_bookmarks\_web\_portlet\_BookmarksAdminPortlet}).
For each entity/portlet you export, there are subsequent folders holding
data about them. Entities and portlets can also be stored in a
\texttt{company} folder. Although the majority of entities belong to a
group, some exist outside of a group scope (e.g., users).

If you open the
\texttt{/group/20143/com.liferay.bookmarks.model.BookmarksEntry/35005.xml}
file, you'll find serialized data about the entity, which is similar to
what is stored in the database.

The \texttt{portlet} folder holds all the portlets you exported. Each
portlet has its own folder that holds various XML files with data
describing the exported content. There are three main XML files that can
be generated for a single portlet:

\begin{itemize}
\tightlist
\item
  \texttt{portlet.xml}: provides essential information about the
  portlet, similar to a manifest file. For example, this can include the
  portlet ID, high-level entity information stored in the portlet (e.g.,
  web content articles in a web content portlet), permissioning, etc.
\item
  \texttt{portlet-data.xml}: describes specific entity data stored in
  the portlet. For example, for the web content portlet, articles stored
  in the portlet are defined in \texttt{staged-model} tags and are
  linked to their serialized entity XML files.
\item
  \texttt{portlet-preferences.xml}: defines the settings of the portlet.
  For example, this can include portlet preferences like the portlet
  owner, default user, article IDs, etc.
\end{itemize}

Note that when you import a LAR, it only includes the portlet data. You
have to deploy the portlet to be able to use it.

You now know how exported entities, portlets, and pages are defined in a
LAR file. For a summarized outline of what you've learned about LAR file
construction, see the diagram below.

\begin{figure}
\centering
\includegraphics{./images/lar-diagram.png}
\caption{Entities, Portlets, and Pages are defined in a LAR in different
places.}
\end{figure}

Excellent! You now have a fundamental understanding for how a LAR file
is generated and how it's structured.

Next, you'll learn about data handler fundamentals and the prerequisites
required to implement them.

\subsection{Data Handler Fundamentals}\label{data-handler-fundamentals}

To leverage the Export/Import framework's ability to export/import a LAR
file, you can implement Data Handlers in your application. There are two
types of data handlers: \emph{Portlet Data Handlers} and \emph{Staged
Model Data Handlers}.

A Portlet Data Handler imports/exports portlet specific data to a LAR
file. These classes only have the role of querying and coordinating
between staged model data handlers. For example, the Bookmarks
application's portlet data handler tracks system events dealing with
Bookmarks entities. It also configures the Export/Import UI options for
the Bookmarks application.

To track each entity of an application for staging, you should create
staged models by implementing the
\href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/model/StagedModel.html}{StagedModel}
interface. Staged models are the parent interface of an entity in the
Staging framework. For example, the Bookmarks application manages
\href{@app-ref@/collaboration/latest/javadocs/com/liferay/bookmarks/model/BookmarksEntry.html}{BookmarksEntry}s
and
\href{@app-ref@/collaboration/latest/javadocs/com/liferay/bookmarks/model/BookmarksFolder.html}{BookmarksFolder}s,
and both implement the \texttt{StagedModel} interface.

A Staged Model Data Handler supplies information about a staged model
(entity) to the Export/Import framework, defining a display name for the
UI, deleting an entity, etc. It's also responsible for exporting
referenced content. For example, if a Bookmarks entry resides in a
Bookmarks folder, the \texttt{BookmarksEntry} staged model data handler
invokes the export of the \texttt{BookmarksFolder}.

\begin{figure}
\centering
\includegraphics{./images/data-handler-diagram.png}
\caption{The Data Handler framework uses portlet data handlers and
staged model data handlers to track and export/import portlet and staged
model information, respectively.}
\end{figure}

You're not required to implement a staged model data handler for every
entity in your application, but they're necessary for any entity you
want to export/import or have the staging framework track.

Before implementing data handlers, make sure your application is ready
for the Export/Import and Staging frameworks by running Service Builder
in your application. Using Service Builder to create staged models is
not required, but is recommended since it generates many requirements
for you. To ensure Service Builder recognizes your entity as a staged
model, you must set the \texttt{uuid} attribute to \texttt{true} in your
\texttt{service.xml} file and have the following columns declared:

\begin{itemize}
\tightlist
\item
  \texttt{companyId}
\item
  \texttt{groupId}
\item
  \texttt{userId}
\item
  \texttt{userName}
\item
  \texttt{createDate}
\item
  \texttt{modifiedDate}
\end{itemize}

You can learn how to create a \texttt{service.xml} file for your
application by visiting the
\href{/docs/7-0/tutorials/-/knowledge_base/t/defining-an-object-relational-map-with-service-builder}{Defining
an Object-Relational Map with Service Builder} tutorial.

To learn how to develop data handlers for your app, visit the
\href{/docs/7-0/tutorials/-/knowledge_base/t/data-handlers}{Developing
Data Handlers} tutorial.

\section{Developing Data Handlers}\label{developing-data-handlers}

To leverage the Export/Import framework's ability to export/import a LAR
file, you can implement Data Handlers in your application. There are two
types of data handlers you can implement: \emph{Portlet Data Handlers}
and \emph{Staged Model Data Handlers}. For more information on the
fundamentals behind Liferay's data handlers and how a LAR file is
constructed, see the
\href{/docs/7-0/tutorials/-/knowledge_base/t/understanding-data-handlers}{Understanding
Data Handlers} tutorial. You also must ensure your application is
properly configured to use data handlers; this is also covered in the
linked tutorial.

To learn how to implement data handlers for your custom application,
you'll examine how the Bookmarks application does it. First you'll start
with its portlet data handler implementation.

\subsection{Portlet Data Handlers}\label{portlet-data-handlers}

The following steps create the \texttt{BookmarksPortletDataHandler}
class used for the Bookmarks application.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a new package in your existing Service Builder project for your
  data handler classes. For instance, the Bookmarks application's data
  handler classes reside in the \texttt{com.liferay.bookmarks.service}
  module's
  \texttt{com.liferay.bookmarks.internal.exportimport.data.handler}
  package.
\item
  Create your \texttt{-PortletDataHandler} class for your application in
  the new \texttt{-exportimport.data.handler} package and have it
  implement the
  \href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/exportimport/kernel/lar/PortletDataHandler.html}{PortletDataHandler}
  interface by extending the
  \href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/exportimport/kernel/lar/BasePortletDataHandler.html}{BasePortletDataHandler}
  class. See the \texttt{BookmarksPortletDataHandler} class as an
  example:

\begin{verbatim}
public class BookmarksPortletDataHandler extends BasePortletDataHandler {
\end{verbatim}
\item
  Create an \texttt{@Component} annotation section above the class
  declaration. This annotation registers this class as a portlet data
  handler in the OSGi service registry.

\begin{verbatim}
@Component(
    immediate = true,
    property = {
        "javax.portlet.name=" + BookmarksPortletKeys.BOOKMARKS,
        "javax.portlet.name=" + BookmarksPortletKeys.BOOKMARKS_ADMIN
    },
    service = PortletDataHandler.class
)
\end{verbatim}

  There are a few annotation attributes you should set:

  \begin{itemize}
  \tightlist
  \item
    The \texttt{immediate} element directs the container to activate the
    component immediately once its provided module has started.
  \item
    The \texttt{property} element sets various properties for the
    component service. You must associate the portlets you wish to
    handle with this service so they function properly in the
    export/import environment. For example, since the Bookmarks data
    handler is used for two portlets, they're both configured using the
    \texttt{javax.portlet.name} property.
  \item
    The \texttt{service} element should point to the
    \texttt{PortletDataHandler.class} interface.
  \end{itemize}
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** In previous versions of Liferay DXP, you had to register the portlet
 data handler in a portlet's `liferay-portlet.xml` file. The registration
 process is now completed automatically by OSGi using the `@Component`
 annotation.
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{3}
\item
  Set what the portlet data handler controls and the portlet's
  Export/Import UI by adding an \texttt{activate} method:

\begin{verbatim}
@Activate
protected void activate() {
    setDataPortletPreferences("rootFolderId");
    setDeletionSystemEventStagedModelTypes(
        new StagedModelType(BookmarksEntry.class),
        new StagedModelType(BookmarksFolder.class));
    setExportControls(
        new PortletDataHandlerBoolean(
            NAMESPACE, "entries", true, false, null,
            BookmarksEntry.class.getName()));
    setImportControls(getExportControls());
}
\end{verbatim}

  This method is called during initialization of the component by using
  the
  \href{https://osgi.org/javadoc/r6/residential/org/osgi/service/component/annotations/Activate.html}{@Activate}
  annotation. This method is invoked after dependencies are set and
  before services are registered.

  The four \texttt{set} methods called in the
  \texttt{BookmarksPortletDataHandler}'s \texttt{activate} method are
  described below:

  \begin{itemize}
  \tightlist
  \item
    \texttt{setDataPortletPreferences}: sets portlet preferences the
    Bookmarks application should handle.
  \item
    \texttt{setDeletionSystemEventStagedModelTypes}: sets the staged
    model deletions that the portlet data handler should track. For the
    Bookmarks application, Bookmark entries and folders are tracked.
  \item
    \texttt{setExportControls}: adds fine grained controls over export
    behavior that are rendered in the Export UI. For the Bookmarks
    application, a checkbox is added to select Bookmarks content
    (entries) to export.
  \item
    \texttt{setImportControls}: adds fine grained controls over import
    behavior that are rendered in the Import UI. For the Bookmarks
    application, a checkbox is added to select Bookmarks content
    (entries) to import.
  \end{itemize}

  \begin{figure}
  \centering
  \includegraphics{./images/export-import-controls.png}
  \caption{You can select the content types you'd like to export/import
  in the UI.}
  \end{figure}

  For more information on these methods, visit the
  \href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/exportimport/kernel/lar/PortletDataHandler.html}{PortletDataHandler}
  API.
\item
  For the Bookmarks portlet data handler to reference its entry and
  folder staged models successfully, you must set them in your class:

\begin{verbatim}
@Reference(unbind = "-")
protected void setBookmarksEntryLocalService(
    BookmarksEntryLocalService bookmarksEntryLocalService) {

    _bookmarksEntryLocalService = bookmarksEntryLocalService;
}

@Reference(unbind = "-")
protected void setBookmarksFolderLocalService(
    BookmarksFolderLocalService bookmarksFolderLocalService) {

    _bookmarksFolderLocalService = bookmarksFolderLocalService;
}

private BookmarksEntryLocalService _bookmarksEntryLocalService;
private BookmarksFolderLocalService _bookmarksFolderLocalService;
\end{verbatim}

  The \texttt{set} methods must be annotated with the
  \href{https://osgi.org/javadoc/r6/residential/org/osgi/service/component/annotations/Reference.html}{@Reference}
  annotation. Visit the
  \href{/docs/7-0/tutorials/-/knowledge_base/t/finding-and-invoking-liferay-services\#invoking-liferay-services-locally}{Invoking
  Liferay Services Locally} section of the \emph{Finding and Invoking
  Liferay Services} tutorial for more information on using the `Liferay
  DXPproduct@.

  \textbf{Important:} Liferay DXP's official Bookmarks app does not use
  local services in its portlet data handler; instead, it uses the
  \texttt{StagedModelRepository} framework. This is not recommended for
  custom applications, however; it's only intended for internal Liferay
  applications at this time. Because of this, the code in this tutorial
  has been modified to highlight the recommended way for custom apps.
\item
  You must create a namespace for your entities so the Export/Import
  framework can identify your application's entities from other entities
  in Liferay DXP. The Bookmarks application's namespace declaration
  looks like this:

\begin{verbatim}
public static final String NAMESPACE = "bookmarks";
\end{verbatim}

  You'll see how this namespace is used later.
\item
  Your portlet data handler should retrieve the data related to its
  staged model entities so it can properly export/import it. Add this
  functionality by inserting the following methods:

\begin{verbatim}
@Override
protected String doExportData(
        final PortletDataContext portletDataContext, String portletId,
        PortletPreferences portletPreferences)
    throws Exception {

    Element rootElement = addExportDataRootElement(portletDataContext);

    if (!portletDataContext.getBooleanParameter(NAMESPACE, "entries")) {
        return getExportDataRootElementString(rootElement);
    }

    portletDataContext.addPortletPermissions(
        BookmarksResourcePermissionChecker.RESOURCE_NAME);

    rootElement.addAttribute(
        "group-id", String.valueOf(portletDataContext.getScopeGroupId()));

    ExportActionableDynamicQuery folderActionableDynamicQuery =
        _bookmarksFolderLocalService.
            getExportActionableDynamicQuery(portletDataContext);

    folderActionableDynamicQuery.performActions();

    ActionableDynamicQuery entryActionableDynamicQuery =
        _bookmarksEntryLocalService.
            getExportActionableDynamicQuery(portletDataContext);

    entryActionableDynamicQuery.performActions();

    return getExportDataRootElementString(rootElement);
}

@Override
protected PortletPreferences doImportData(
        PortletDataContext portletDataContext, String portletId,
        PortletPreferences portletPreferences, String data)
    throws Exception {

    if (!portletDataContext.getBooleanParameter(NAMESPACE, "entries")) {
        return null;
    }

    portletDataContext.importPortletPermissions(
        BookmarksResourcePermissionChecker.RESOURCE_NAME);

    Element foldersElement = portletDataContext.getImportDataGroupElement(
        BookmarksFolder.class);

    List<Element> folderElements = foldersElement.elements();

    for (Element folderElement : folderElements) {
        StagedModelDataHandlerUtil.importStagedModel(
            portletDataContext, folderElement);
    }

    Element entriesElement = portletDataContext.getImportDataGroupElement(
        BookmarksEntry.class);

    List<Element> entryElements = entriesElement.elements();

    for (Element entryElement : entryElements) {
        StagedModelDataHandlerUtil.importStagedModel(
            portletDataContext, entryElement);
    }

    return null;
}
\end{verbatim}

  The \texttt{doExportData} method first checks if anything should be
  exported. The \texttt{portletDataContext.getBooleanParameter(...)}
  method checks if the user selected Bookmarks entries for export.
  Later, the \texttt{ExportImportActionableDynamicQuery} framework runs
  a query against bookmarks folders and entries to find ones which
  should be exported to the LAR file.

  The \texttt{-ActionableDynamicQuery} classes are automatically
  generated by Service Builder and are available in your application's
  local service. It queries the database searching for certain
  Staging-specific parameters (e.g., \texttt{createDate} and
  \texttt{modifiedDate}), and based on those parameters, finds a list of
  exportable records from the staged model data handler.

  The \texttt{doImportData} queries for Bookmark entry and folder data
  in the imported LAR file that should be added to the database. This is
  done by extracting XML elements from the LAR file by using utility
  methods from the
  \href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/exportimport/kernel/lar/StagedModelDataHandlerUtil.html}{StagedModelDataHandlerUtil}
  class. The extracted elements tell Liferay DXP what data to import
  from the LAR file.
\item
  Add a method that deletes the portlet's data. The Staging framework
  has an option called \emph{Delete Portlet Data Before Importing} that
  lets the user delete portlet data before importing any new data. The
  \texttt{doDeleteData(...)} method is called to execute this deletion
  operation.

\begin{verbatim}
@Override
protected PortletPreferences doDeleteData(
        PortletDataContext portletDataContext, String portletId,
        PortletPreferences portletPreferences)
    throws Exception {

    if (portletDataContext.addPrimaryKey(
            BookmarksPortletDataHandler.class, "deleteData")) {

        return portletPreferences;
    }

    _bookmarksEntryLocalService.deleteEntries(
        portletDataContext.getScopeGroupId(),
        BookmarksFolderConstants.DEFAULT_PARENT_FOLDER_ID);

    _bookmarksFolderLocalService.deleteFolders(
        portletDataContext.getScopeGroupId());

    return portletPreferences;
}
\end{verbatim}

  This method can also return a modified version of the portlet
  preferences if it contains references to data that no longer exists.
\item
  Add a method that counts the number of affected entities based on the
  current export or staging process:

\begin{verbatim}
@Override
protected void doPrepareManifestSummary(
        PortletDataContext portletDataContext,
        PortletPreferences portletPreferences)
    throws Exception {

    ActionableDynamicQuery entryExportActionableDynamicQuery =
        _bookmarksEntryLocalService.
            getExportActionableDynamicQuery(portletDataContext);

    entryExportActionableDynamicQuery.performCount();

    ActionableDynamicQuery folderExportActionableDynamicQuery =
        _bookmarksFolderLocalService.
            getExportActionableDynamicQuery(portletDataContext);

    folderExportActionableDynamicQuery.performCount();
}
\end{verbatim}

  This number is displayed in the Export and Staging UI. Note that since
  the Staging framework traverses the entity graph during export, the
  built-in components provide an approximate value in some cases.

  \begin{figure}
  \centering
  \includegraphics{./images/manifest-summary-count.png}
  \caption{The number of modified Bookmarks entities are displayed in
  the Export UI.}
  \end{figure}
\item
  Set the XML schema version for the XML files included in your exported
  LAR file:

\begin{verbatim}
public static final String SCHEMA_VERSION = "1.0.0";

@Override
public String getSchemaVersion() {
    return SCHEMA_VERSION;
}
\end{verbatim}
\end{enumerate}

Awesome! You've set up your portlet data handler and your application
can now support the Export/Import framework and display a UI for it. The
next step for supporting data handlers in your app is to implement
staged model data handlers for your staged models. You'll do this next.

\subsection{Staged Model Data
Handlers}\label{staged-model-data-handlers}

Now that your application has a portlet data handler and staged models,
you'll create the staged model data handlers. The Bookmarks application
has two staged models: entries and folders. Creating data handlers for
these two entities is similar, so you'll examine how this is done for
Bookmark entries.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a \texttt{-StagedModelDataHandler} class in the same folder as
  its portlet data handler class. For Bookmarks, the
  \texttt{BookmarksEntryStagedDataHandler} class resides in the
  \texttt{com.liferay.bookmarks.service} module's
  \texttt{com.liferay.bookmarks.internal.exportimport.data.handler}
  package. The staged model data handler class should extend the
  \href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/exportimport/kernel/lar/BaseStagedModelDataHandler.html}{BaseStagedModelDataHandler}
  class and the entity type should be specified as its parameter. You
  can see how this was done for the
  \texttt{BookmarksEntryStagedModelDataHandler} class below:

\begin{verbatim}
public class BookmarksEntryStagedModelDataHandler
    extends BaseStagedModelDataHandler<BookmarksEntry> {
\end{verbatim}
\item
  Create an \texttt{@Component} annotation section above the class
  declaration. This annotation is responsible for registering the class
  as a staged model data handler similar to the portlet data handler.

\begin{verbatim}
@Component(immediate = true, service = StagedModelDataHandler.class)
\end{verbatim}

  The \texttt{immediate} element directs the container to activate the
  component immediately once its provided module has started. The
  \texttt{service} element should point to the
  \texttt{StagedModelDataHandler.class} interface.
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** In previous versions of Liferay DXP, you had to register the staged
 model data handler in a portlet's `liferay-portlet.xml` file. The
 registration process is now completed automatically by OSGi using the
 `@Component` annotation.
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\item
  Create a getter and setter method for the local service of the staged
  model for which you want to provide a data handler:

\begin{verbatim}
@Override
protected BookmarksEntryLocalService getBookmarksEntryLocalService() {
    return _bookmarksEntryLocalService;
}

@Reference(unbind = "-")
protected void setBookmarksEntryLocalService(
    BookmarksEntryLocalService bookmarksEntryLocalService) {

    _bookmarksEntryLocalService = bookmarksEntryLocalService;
}

private BookmarksEntryLocalService _bookmarksEntryLocalService;
\end{verbatim}

  These methods are used to link this data handler with the staged model
  for bookmark entries.

  \textbf{Important:} Liferay DXP's official Bookmarks app does not use
  local services in its staged model data handlers; instead, it uses the
  \texttt{StagedModelRepository} framework. This is not recommended for
  custom applications, however; it's only intended for internal Liferay
  applications at this time. Because of this, the code in this tutorial
  has been modified to highlight the recommended way for custom apps.
\item
  You must provide the class names of the models the data handler
  tracks. You can do this by overriding the
  \href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/exportimport/kernel/lar/StagedModelDataHandler.html}{StagedModelDataHandler}'s
  \texttt{getClassnames()} method:

\begin{verbatim}
public static final String[] CLASS_NAMES = {BookmarksEntry.class.getName()};

@Override
public String[] getClassNames() {
    return CLASS_NAMES;
}
\end{verbatim}

  As a best practice, you should have one staged model data handler per
  staged model. It's possible to use multiple class types, but this is
  not recommended.
\item
  Add a method that retrieves the staged model's display name:

\begin{verbatim}
@Override
public String getDisplayName(BookmarksEntry entry) {
    return entry.getName();
}
\end{verbatim}

  The display name is presented with the progress bar during the
  export/import process.

  \begin{figure}
  \centering
  \includegraphics{./images/staged-model-display-name.png}
  \caption{Your staged model data handler provides the display name in
  the Export/Import UI.}
  \end{figure}
\item
  A staged model data handler should ensure everything required for its
  operation is also exported. For example, in the Bookmarks application,
  an entry requires its folder to keep the folder structure intact.
  Therefore, the folder should be exported first followed by the entry.

  Add methods that import and export your staged model and its
  references.

\begin{verbatim}
@Override
protected void doExportStagedModel(
        PortletDataContext portletDataContext, BookmarksEntry entry)
    throws Exception {

    if (entry.getFolderId() !=
            BookmarksFolderConstants.DEFAULT_PARENT_FOLDER_ID) {

        StagedModelDataHandlerUtil.exportReferenceStagedModel(
            portletDataContext, entry, entry.getFolder(),
            PortletDataContext.REFERENCE_TYPE_PARENT);
    }

    Element entryElement = portletDataContext.getExportDataElement(entry);

    portletDataContext.addClassedModel(
        entryElement, ExportImportPathUtil.getModelPath(entry), entry);
}

@Override
protected void doImportStagedModel(
        PortletDataContext portletDataContext, BookmarksEntry entry)
    throws Exception {

    Map<Long, Long> folderIds =
        (Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(
            BookmarksFolder.class);

    long folderId = MapUtil.getLong(
        folderIds, entry.getFolderId(), entry.getFolderId());

    ServiceContext serviceContext =
        portletDataContext.createServiceContext(entry);

    BookmarksEntry importedEntry = null;

    if (portletDataContext.isDataStrategyMirror()) {

        BookmarksEntry existingEntry =
            _bookmarksEntryLocalService. fetchBookmarksEntryByUuidAndGroupId(
                entry.getUuid(), portletDataContext.getScopeGroupId());

        if (existingEntry == null) {

            serviceContext.setUuid(entry.getUuid());
            importedEntry = _bookmarksEntryLocalService.addEntry(                   
              userId, portletDataContext.getScopeGroupId(), folderId, entry.getName(), entry.getUrl(), entry.getDescription(), serviceContext);
        }
        else {
            importedEntry = _bookmarksEntryLocalService.updateEntry(
                userId, existingEntry.getEntryId(), portletDataContext.getScopeGroupId(), folderId, entry.getName(), entry.getUrl(), entry.getDescription(),    serviceContext);
        }
    }
    else {
        importedEntry = _bookmarksEntryLocalService.addEntry(userId, portletDataContext.getScopeGroupId(), folderId,entry.getName(), entry.getUrl(), entry.getDescription(),    serviceContext);
    }

    portletDataContext.importClassedModel(entry, importedEntry);
}
\end{verbatim}

  The \texttt{doExportStagedModel} method retrieves the Bookmark entry's
  data element from the
  \href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/exportimport/kernel/lar/PortletDataContext.html}{PortletDataContext}
  and then adds the class model characterized by that data element to
  the \texttt{PortletDataContext}. The \texttt{PortletDataContext} is
  used to populate the LAR file with your application's data during the
  export process. Note that once an entity has been exported, subsequent
  calls to the export method won't actually repeat the export process
  multiple times, ensuring optimal performance.

  An important feature of the import process is that all exported
  reference elements in the Bookmarks example are automatically imported
  when needed. The \texttt{doImportStagedModel} method does not need to
  import the reference elements manually; it must only find the new
  assigned ID for the folder before importing the entry.

  The \texttt{PortletDataContext} keeps this information and a slew of
  other data up-to-date during the import process. The old ID and new ID
  mapping can be reached by using the
  \texttt{portletDataContext.getNewPrimaryKeysMap()} method as shown in
  the example. The method proceeds with checking the import mode (e.g.,
  \emph{Copy As New} or \emph{Mirror}) and depending on the process
  configuration and existing environment, the entry is either added or
  updated.
\item
  When importing a LAR that specifies a missing reference, the import
  process expects the reference to be available and must validate that
  it's there. You must add a method that maps the missing reference ID
  from the export to the existing ID during import.

  For example, suppose you export a \texttt{FileEntry} as a missing
  reference with an ID of \texttt{1}. When importing that information,
  the LAR only provides the ID but not the entry itself. Therefore,
  during the import process, the Data Handler framework searches for the
  entry to replace, but the entry to replace has a different ID of
  \texttt{2}. You must provide a method that maps these two IDs so the
  import process can recognize the missing reference.

\begin{verbatim}
@Override
protected void doImportMissingReference(
        PortletDataContext portletDataContext, String uuid, long groupId,
        long entryId)
    throws Exception {

    BookmarksEntry existingEntry = fetchMissingReference(uuid, groupId);

    if (existingEntry == null) {
        return;
    }

    Map<Long, Long> entryIds =
        (Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(
            BookmarksEntry.class);

    entryIds.put(entryId, existingEntry.getEntryId());
}
\end{verbatim}

  This method maps the existing staged model to the old ID in the
  reference element. When a reference is exported as missing, the Data
  Handler framework calls this method during the import process and
  updates the new primary key map in the portlet data context.
\end{enumerate}

Fantastic! You've created a data handler for your staged model. The
Export/Import framework can now track your entity's behavior and data.

With the ability to track entity data, your application is available
during the Export/Import and Staging processes.

\section{Initiating New Processes with ExportImportConfiguration
Objects}\label{initiating-new-processes-with-exportimportconfiguration-objects}

Liferay DXP's Staging and Export/Import features are the building blocks
for creating, managing, and publishing a site. These features can be
accessed in your Portal's \emph{Publishing Tools} menu. You can also,
however, start these processes programatically. This lets you provide
new interfaces or mimic the functionality of these features in your own
application.

Providing the ability to stage your application's assets makes using
your application much more site administrator-friendly. Your new assets
no longer have to be saved somewhere off-site until they're ready to be
published. You can publish them to a staging environment, test their
usability, and save them to a page. Once the time is right for
publishing, you can publish your application's assets to the live site
with one mouse click. The export/import feature offers similar
conveniences: if you want to export your application's assets to use in
another place or you need to clear its data but save a copy you can
implement the export feature. Implementing the import feature lets you
bring your assets/data back into your application.

To initiate a export/import or staging process, you must pass in an
\texttt{ExportImportConfiguration} object. This object encapsulates many
parameters and settings that are required while the export/import is
running. Having one single object with all your necessary data makes
executing these frameworks quick and easy.

When you want to implement, for example, export, you must call services
offered by the \texttt{ExportImportService} interface. All the methods
in this interface require an \texttt{ExportImportConfiguration} object.
Liferay DXP provides a way to generate these configuration objects, so
you can easily pass them in your service methods.

It's also important to know that \texttt{ExportImportConfiguration} is a
Portal entity, similar to \texttt{User} or \texttt{Group}. This means
that the \texttt{ExportImportConfiguration} framework offers local and
remote services, models, persistence classes, and more.

In this tutorial, you'll learn about the
\texttt{ExportImportConfiguration} framework and how you can take
advantage of provided services and factories to create these controller
obects. Once they're created, you can easily impment whatever
import/export functionality you need.

Your first step is to create an \texttt{ExportImportConfiguration}
object and use it to initiate your custom export/import or staging
process.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Use the Export Import Configuration factory classes to build your
  \texttt{ExportImportConfiguration} object. Below is a common way to do
  it:

\begin{verbatim}
Map<String, Serializable> exportLayoutSettingsMap =
    ExportImportConfigurationSettingsMapFactory.
        buildExportLayoutSettingsMap(...);

ExportImportConfiguration exportImportConfiguration =
    exportImportConfigurationLocalService.
        addDraftExportImportConfiguration(
            user.getUserId(),
            ExportImportConfigurationConstants.TYPE_EXPORT_LAYOUT,
            exportLayoutSettingsMap);
\end{verbatim}

  This example uses the
  \href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/exportimport/kernel/configuration/ExportImportConfigurationSettingsMapFactory.html}{ExportImportConfigurationSettingsMapFactory}
  to create a layout export settings map. Then this map is used as a
  parameter to create an \texttt{ExportImportConfiguration} by calling
  an \emph{add} method in the entity's local service interface. The
  \href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/exportimport/kernel/service/ExportImportConfigurationLocalService.html}{ExportImportConfigurationLocalService}
  provides several useful methods to create and modify your custom
  \texttt{ExportImportConfiguration}.

  The \texttt{ExportImportConfigurationSettingsMapFactory} provides many
  \texttt{build} methods to create settings maps for various scenarios,
  like importing, exporting, and publishing layouts and portlets. For
  examples of this particular scenario, you can reference
  \href{@platform-ref@/7.0-latest/javadocs/portal-impl/com/liferay/portal/service/impl/UserGroupLocalServiceImpl.html\#exportLayouts-long-java.util.Map-}{UserGroupLocalServiceImpl.exportLayouts(\ldots)}
  and
  \href{@platform-ref@/7.0-latest/javadocs/portal-impl/com/liferay/portal/service/impl/GroupLocalServiceImpl.html\#addDefaultGuestPublicLayoutsByLAR-com.liferay.portal.kernel.model.Group-java.io.File-}{GroupLocalServiceImpl.addDefaultGuestPublicLayoutsByLAR(\ldots)}.

  There are two other important factories provided by this framework
  that are useful during the creation of
  \texttt{ExportImportConfiguration} objects:

  \begin{itemize}
  \tightlist
  \item
    \href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/exportimport/kernel/configuration/ExportImportConfigurationFactory.html}{ExportImportConfigurationFactory}:
    This factory is used to build \texttt{ExportImportConfiguration}
    objects used for default local/remote publishing.
  \item
    \href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/exportimport/kernel/configuration/ExportImportConfigurationParameterMapFactory.html}{ExportImportConfigurationParameterMapFactory}:
    This factory is used to build parameter maps, which are required
    during export/import and publishing.
  \end{itemize}
\item
  Call the appropriate service to initiate the export/import or staging
  process. There are two important service interfaces that you can use
  in the cases of exporting, importing, and staging:
  \href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/exportimport/kernel/service/ExportImportLocalService.html}{ExportImportLocalService}
  and
  \href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/exportimport/kernel/service/StagingLocalService.html}{StagingLocalService}.
  In the previous step's example code snippet, you created an
  \texttt{ExportImportConfiguration} object intended for exporting
  layouts. Here's how to initiate that process:

\begin{verbatim}
files[0] = exportImportLocalService.exportLayoutsAsFile(
    exportImportConfiguration);
\end{verbatim}

  By calling this interface's method, you're exporting layouts from
  Portal into a \texttt{java.io.File} array. Notice that your
  \texttt{ExportImportConfiguration} object is the only needed parameter
  in the method. Your configuration object holds all the required
  parameters and settings necessary to export your layouts from Portal.
  Although this example code resides in Liferay DXP, you could easily
  use this framework from your own plugin or module.
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** If you're not calling the export/import or staging service methods
 from an OSGi module, you should not use the interface. The Liferay
 OSGi container automatically handles interface referencing, which is why
 using the interface is permitted for modules. If you're calling
 export/import or staging service methods outside of a module, you should use
 their service Util classes (e.g., `ExportImportLocalServiceUtil`).
\end{verbatim}

\noindent\hrulefill

It's that easy! To start your own export/import or staging process, you
must create an \texttt{ExportImportConfiguration} object using a
combination of the three provided \texttt{ExportImportConfiguration}
factories. Once you have your configuration object, provide it as a
parameter in one of the many service methods available to you by the
Export/Import or Staging interfaces to begin your desired process.

\section{Using the Export/Import Lifecycle Listener
Framework}\label{using-the-exportimport-lifecycle-listener-framework}

The \texttt{ExportImportLifecycleListener} framework allows developers
to write code that listens for certain staging or export/import events
during the publication process. The staging and export/import processes
have many behind-the-scenes events that you cannot listen to by default.
Some of these, like export successes and import failures, may be events
on which you'd want to take some action. You also have the ability to
listen for processes comprised of many events and implement custom code
when these processes are initiated. Here is a short list of events you
can listen for:

\begin{itemize}
\tightlist
\item
  Staging has started
\item
  A portlet export has failed
\item
  An entity export has succeeded
\end{itemize}

The concept of listening for export/import and staging events sounds
cool, but you may be curious as to why listening for certain events is
useful. Listening for events can help you know more about your
application's state. Suppose you'd like a detailed log of when certain
events occur during an import process. You could configure a listener to
listen for certain import events you're interested in and print
information about those events to your console when they occur.

Liferay DXP uses this framework by default in several cases. For
instance, Liferay clears the cache when a web content import process
finishes. To accomplish this, the lifecycle listener framework listens
for an event that specifies that a web content import process has
completed. Once that event occurs, there is an event listener that
automatically clears the cache. You could implement this sort of
functionality yourself for any Portal event. You can listen for a
specific event and then complete an action based on when that event
occurs. For a list of events you can listen for during Export/Import and
Staging processes, see
\href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/exportimport/kernel/lifecycle/ExportImportLifecycleConstants.html}{ExportImportLifecycleConstants}.

Some definitions are in order:

\textbf{Events} are particular actions that occur during processing.

\textbf{Processes} are longer running groups of events.

In this tutorial, you'll learn how to use the
\texttt{ExportImportLifecycleListener} framework to listen for
processes/events during the staging and export/import lifecycles.

\subsection{Listening to Lifecycle
Events}\label{listening-to-lifecycle-events}

To begin creating your lifecycle listener, you must create a module.
Follow the steps below:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/starting-module-development\#creating-a-module}{Create
  an OSGi module}.
\item
  Create a unique package name in the module's \texttt{src} directory
  and create a new Java class in that package. To follow naming
  conventions, begin the class name with the entity or action name
  you're processing, followed by \emph{ExportImportLifecycleListener}
  (e.g., \texttt{LoggerExportImportLifecycleListener}).
\item
  You must extend one of the two Base classes provided with the
  Export/Import Lifecycle Listener framework:
  \href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/exportimport/kernel/lifecycle/BaseExportImportLifecycleListener.html}{BaseExportImportLifecycleListener}
  or
  \href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/exportimport/kernel/lifecycle/BaseProcessExportImportLifecycleListener.html}{BaseProcessExportImportLifecycleListener}.
  To choose, you'll need to consider what parts of a lifecycle you want
  to listen for.

  Extend the \texttt{BaseExportImportLifecycleListener} class if you
  want to listen for specific \emph{events} during a lifecycle. For
  example, you may want to write custom code if a layout export fails.

  Extend the \texttt{BaseProcessExportImportLifecycleListener} class if
  you want to listen for \emph{processes} during a lifecycle. For
  example, you may want to write custom code if a site publication
  fails. Keep in mind that a process usually consists of many individual
  events. Methods provided by this base class are only run once when the
  desired process action occurs.
\item
  Directly above the class's declaration, insert the following
  annotation:

\begin{verbatim}
@Component(immediate = true, 
            service = ExportImportLifecycleListener.class)
\end{verbatim}

  This annotation declares the implementation class of the component and
  specifies that the portal should start the module immediately.
\item
  Specify the methods you want to implement in your class.
\end{enumerate}

Once you've successfully created your export/import lifecycle listener
module, generate the module's JAR file and copy it to your Portal's
\texttt{osgi/modules} directory. Once your module is installed and
activated in your Portal's service registry, your lifecycle listener is
ready for use in your Portal instance.

If you're still thirsting for more information on this framework, you're
in luck! Here's an example, using the
\href{@app-ref@/web-experience/latest/javadocs/com/liferay/exportimport/lifecycle/LoggerExportImportLifecycleListener.html}{LoggerExportImportLifecycleListener}.
This listener extends the \texttt{BaseExportImportLifecycleListener}, so
you should immediately know that it deals with lifecycle events.

The first method \texttt{isParallel()} determines whether your listener
should run in parallel with the import/export process, or if the calling
method should stop, execute the listener, and return to where the event
was fired after the listener has finished. The next method is the
\texttt{onExportImportLifecycleEvent(...)} method, which consumes the
lifecycle event and passes it through the base class's method (as long
as Debug mode is not enabled).

Each remaining method is called to print logging information for the
user. For example, when a layout export starts, succeeds, or fails,
logging information directly related to that event is printed. In
summary, the \texttt{LoggerExportImportLifecycleListener} uses the
lifecycle listener framework to print messages to the log when an
export/import event occurs. Other good examples of event lifecycle
listeners are
\href{@app-ref@/web-experience/latest/javadocs/com/liferay/exportimport/lifecycle/CacheExportImportLifecycleListener.html}{CacheExportImportLifecycleListener}
and
\href{https://github.com/liferay/liferay-portal/blob/7.0.6-ga7/modules/apps/web-experience/journal/journal-service/src/main/java/com/liferay/journal/internal/exportimport/lifecycle/JournalCacheExportImportLifecycleListener.java}{JournalCacheExportImportLifecycleListener}.

For an example of a lifecycle listener extending the
\texttt{BaseProcessExportImportLifecycleListener} class, inspect the
\href{@app-ref@/web-experience/latest/javadocs/com/liferay/exportimport/lifecycle/ExportImportProcessCallbackLifecycleListener.html}{ExportImportProcessCallbackLifecycleListener}
class. Instead of listening for lifecycle events, this class only
listens for process actions.

Terrific! You learned about the Export/Import Lifecycle Listener
framework, and you've learned how to create your own listener for
events/processes that occur during export/import of your portal's
content.

\chapter{Configuration}\label{configuration}

Many applications provide users a way of setting preferences for their
use. In Liferay DXP, this could be as simple as setting a location for a
weather display or as complex as settings for a mail or a time sheet
application.

The Portlet standard defines an API for portlet preferences that can be
used for this sort of thing, but it's limited and for that reason isn't
used much. Instead, many developers have tended to create their own
methods for configuring their applications.

But that isn't necessary anymore: now there's a configuration API that's
easy to use and full-featured. It's used throughout Liferay DXP's
applications, and because we like it, we think you'll like it too.

The following tutorials show you how to use it.

\section{Making Your Applications
Configurable}\label{making-your-applications-configurable}

This tutorial explains how to make your applications configurable. It
starts with basic configuration and then covers some advanced use cases.

Note that the methods described here are not mandatory. You can make
your applications configurable using any other mechanism that you're
already familiar with. We have found, however, that the method described
below provides the greatest benefit with the least amount of effort.

\noindent\hrulefill

\textbf{Note:} To quickly see a working application configuration,
deploy the \texttt{configuration-action}
\href{https://github.com/liferay/liferay-blade-samples/tree/7.0/gradle/apps/configuration-action}{Blade
sample} and navigate to System Settings (\emph{Control Panel} →
\emph{Configuration} → \emph{System Settings}). In the Other category,
click the \emph{Message display configuration} entry.

Add the \emph{Blade Message Portlet} to a page to test your
configuration choices.

\noindent\hrulefill

\subsection{Fundamentals}\label{fundamentals-1}

While you don't need to know much to make your applications
configurable, understanding a few key concepts helps you achieve a
higher degree of configurability with little effort.

\begin{itemize}
\item
  Typed Configuration: The method described here uses \emph{typed}
  configuration. This means that the application configuration isn't
  just a list of key-value pairs. The values can have types, like
  \texttt{Integer}, a list of \texttt{Strings}, a URL, etc. It's even
  possible to use your own custom types, although that's beyond the
  scope of this tutorial. Typed configurations are easier to use than
  untyped configurations, and they prevent many programmatic errors.
  Related to this, the configuration options should be programmatically
  explicit, so that developers can use autocomplete in modern IDEs to
  find out all of the configuration options of a given application or
  one of its components.
\item
  Modularity: In Liferay DXP, applications are \emph{modular} and built
  as a collection of lightweight components. A \emph{component} is just
  a class that has the \texttt{@Component} annotation, often along with
  a set of properties to provide metadata. The configuration mechanisms
  described here leverage the concept of components.
\item
  Configuration Scope: If your application must support different
  configurations at different scopes, the APIs described below handle
  most of the burden for you. It's still important, however, for you to
  understand the term \emph{configuration scope}. Here are the most
  common configuration scopes that Liferay applications can have:

  \begin{enumerate}
  \def\labelenumi{\arabic{enumi}.}
  \item
    \textbf{System:} configuration that is unique for the complete
    installation of the application.
  \item
    \textbf{Virtual Instance:} configuration that can vary per virtual
    instance.
  \item
    \textbf{Site:} configuration that can vary per Liferay site.
  \item
    \textbf{Portlet Instance:} applicable for applications that are
    placed on a page (i.e., portlets). Each placement (instance) of the
    application on the page can have a different configuration.
  \end{enumerate}
\end{itemize}

Enough with the conceptual stuff. You're ready to get started with some
code. If you already had a portlet or service that was configurable
using the traditional mechanisms of Liferay Portal 6.2 and before, refer
to the
\href{/docs/7-0/tutorials/-/knowledge_base/t/transitioning-from-portlet-preferences-to-the-configuration-api}{Transitioning
from Portlet Preferences to the Configuration API} tutorial.

\subsection{Making Your Application
Configurable}\label{making-your-application-configurable}

There's a minimal amount of code you need to write to make your
application configurable the Liferay DXP way. First, you'll learn how to
create a configuration at the system scope.

First create a Java interface to represent the configuration and its
default values. Using a Java interface allows for an advanced type
system for each configuration option. Here is an example of such an
interface:

\begin{verbatim}
@Meta.OCD(id = "com.liferay.docs.exampleconfig.ExampleConfiguration")
public interface ExampleConfiguration {

    @Meta.AD(
        deflt = "blue",
        required = false
    )
    public String favoriteColor();

    @Meta.AD(
       deflt = "red|green|blue",
       required = false
    )
    public String[] validColors();

    @Meta.AD(required = false)
    public int itemsPerPage();

}
\end{verbatim}

As you can see, you are using two Java annotations to provide some
metadata about the configuration. Here is what they do:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{Meta.OCD} Registers this class as a configuration with a
  specific id. \textbf{The ID must be the fully qualified configuration
  class name.}
\item
  \textbf{Meta.AD} Specifies the default value of a configuration field
  as well as whether it's required or not. Note that if you set a field
  as required and don't specify a default value, the system
  administrator must specify a value in order for your application to
  work properly. Use the \texttt{deflt} property to specify a default
  value.
\end{enumerate}

The fully-qualified class name of the \texttt{Meta} class referred to
above is \texttt{aQute.bnd.annotation.metatype.Meta}. For more
information about this class and the \texttt{Meta.OCD} and
\texttt{Meta.AD} annotations, please refer to this bnd documentation:
\url{http://bnd.bndtools.org/chapters/210-metatype.html}. In order to
use the \texttt{Meta.OCD} and \texttt{Meta.AD} annotations in your
modules, you must
\href{/docs/7-0/tutorials/-/knowledge_base/t/configuring-dependencies}{specify
a dependency} on the bnd library. We recommend using bnd version 3.
Here's an example of how to include this dependency in a Gradle project:

\begin{verbatim}
dependencies {
    compile group: "biz.aQute.bnd", name: "biz.aQute.bndlib", version: "3.1.0"
}
\end{verbatim}

\noindent\hrulefill

\textbf{Note:} The annotations \texttt{@Meta.OCD} and \texttt{@Meta.AD}
are part of the bnd library but have also been included as part of the
OSGi standard version R6 with the names \texttt{@ObjectClassDefinition}
and \texttt{@AttributeDefinition}. However, Liferay still uses the bnd
annotations since the standard annotations are not available at runtime,
which is necessary for some of the Liferay specific features described
below. For the basic usage (the one described in this section) the
standard annotations can be used safely.

\noindent\hrulefill

Add the following line to your project's \texttt{bnd.bnd} file:

\begin{verbatim}
-metatype: *
\end{verbatim}

This line lets bnd use your configuration interface to generate an XML
configuration file. With this information, Liferay already knows a lot
about your application's configuration options. In fact, it knows enough
to generate a user interface automatically. Cool, isn't it?

\begin{figure}
\centering
\includegraphics{./images/example-configuration-system-settings.png}
\caption{Navigate to the Control Panel and then click on
\emph{Configuration} → \emph{System Settings}. Then click on
\emph{Other}, find the \emph{Example configuration} link, and click on
it.}
\end{figure}

Even if you agree that this is pretty cool, you might be wondering how
to read the configuration from your application's code. It's actually
quite easy. Here's a simple example:

\begin{verbatim}
@Component(configurationPid = "com.liferay.docs.exampleconfig.ExampleConfiguration")
public class MyAppManager {

    public String getFavoriteColor(Map colors) {
       return colors.get(_configuration.favoriteColor());
    }

    @Activate
    @Modified
    protected void activate(Map<String, Object> properties) {
        _configuration = ConfigurableUtil.createConfigurable(
        ExampleConfiguration.class, properties);
    }

    private volatile ExampleConfiguration _configuration;

}
\end{verbatim}

Here are the most relevant aspects of this example:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  This class is a component, specified with the \texttt{@Component}
  annotation.
\item
  This component uses the configuration with the ID
  \texttt{com.liferay.docs.exampleconfig.ExampleConfiguration}. As a
  result, this method is invoked when the application starts (due to the
  \texttt{@Activate} annotation) and whenever the configuration is
  modified (due to the \texttt{@Modified} annotation).
\item
  The \texttt{activate()} method uses the method
  \texttt{ConfigurableUtil.createConfigurable()} to convert a map of
  properties with the configuration to our typed class, which is easier
  to handle.
\item
  The configuration is stored in a \texttt{volatile} field. Don't forget
  to make it \texttt{volatile} or you'll run into weird problems.
\end{enumerate}

\noindent\hrulefill

\textbf{Note:} The bnd library also provides a class called
\texttt{aQute.bnd.annotation.metatype.Configurable} with a
\texttt{createConfigurable()} method. You can use that instead of
Liferay's
\texttt{com.liferay.portal.configuration.metatype.bnd.util.ConfigurableUtil}
without any problems. Liferay's developers created the
\texttt{ConfigurableUtil} class to improve the performance of bnd's
implementation, and it's used in internal code. Feel free to use
whichever method you prefer.

\noindent\hrulefill

That's it. With very few lines of code, you have a configurable
application that dynamically changes its configuration, has an
auto-generated UI, and uses a simple API to access the configuration.

\subsection{Accessing Your Configuration in a JSP Portlet
Application}\label{accessing-your-configuration-in-a-jsp-portlet-application}

In Liferay DXP it's very common to read a configuration from a portlet
class. If the portlet is a JSP portlet, the configuration object can be
added to the request object so that configurations can be read from the
JSPs that comprise the application's view layer. In this section, you'll
see an example of reading a configuration from a portlet class, adding
it to the request, and reading from the view layer. The import
statements are included in the code snippets so that you can see the
fully qualified class names of all the classes that are used.

\noindent\hrulefill

\textbf{Note:} There's shortcut method for obtaining a portlet instance
configuration. The method described in this section takes a
straightforward approach that does not use this shortcut. See the
\hyperref[accessing-the-portlet-instance-configuration-through-the-portletdisplay]{Accessing
the Portlet Instance Configuration Through the PortletDisplay} section
below to learn about the shorter method.

\noindent\hrulefill

\begin{verbatim}
package com.liferay.docs.exampleconfig;

import java.io.IOException;
import java.util.Map;

import javax.portlet.Portlet;
import javax.portlet.PortletException;
import javax.portlet.RenderRequest;
import javax.portlet.RenderResponse;

import org.osgi.service.component.annotations.Activate;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Modified;

import com.liferay.portal.kernel.portlet.bridges.mvc.MVCPortlet;

import com.liferay.portal.configuration.metatype.bnd.util.ConfigurableUtil;

@Component(
    configurationPid = "com.liferay.docs.exampleconfig.ExampleConfiguration",
    immediate = true,
    property = {
        "com.liferay.portlet.display-category=category.sample",
        "com.liferay.portlet.instanceable=true",
        "javax.portlet.security-role-ref=power-user,user",
        "javax.portlet.init-param.template-path=/",
        "javax.portlet.init-param.view-template=/view.jsp",
        "javax.portlet.resource-bundle=content.Language"
    },
    service = Portlet.class
)
public class ExampleConfigPortlet extends MVCPortlet {

    @Override
    public void doView(RenderRequest renderRequest,
        RenderResponse renderResponse) throws IOException, PortletException {

        renderRequest.setAttribute(
            ExampleConfiguration.class.getName(), _configuration);

        super.doView(renderRequest, renderResponse);
    }


    public String getFavoriteColor(Map colors) {
        return (String) colors.get(_configuration.favoriteColor());
    }

    @Activate
    @Modified
    protected void activate(Map<String, Object> properties) {
        _configuration = ConfigurableUtil.createConfigurable(
        ExampleConfiguration.class, properties);
    }

    private volatile ExampleConfiguration _configuration;

}
\end{verbatim}

The main difference between this example and the first one is that this
class is a portlet class and it sets the configuration object as a
request attribute in its \texttt{doView()} method. To read configuration
values from a JSP, first add these imports to your \texttt{init.jsp}
file:

\begin{verbatim}
<%@ page import="com.liferay.docs.exampleconfig.ExampleConfiguration" %>
<%@ page import="com.liferay.portal.kernel.util.GetterUtil" %>
\end{verbatim}

In a JSP portlet application, your full \texttt{init.jsp} file should at
least have contents like this:

\begin{verbatim}
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %>
<%@ taglib uri="http://java.sun.com/portlet_2_0" prefix="portlet" %>

<%@ taglib uri="http://liferay.com/tld/aui" prefix="aui" %>
<%@ taglib uri="http://liferay.com/tld/portlet" prefix="liferay-portlet" %>
<%@ taglib uri="http://liferay.com/tld/theme" prefix="liferay-theme" %>
<%@ taglib uri="http://liferay.com/tld/ui" prefix="liferay-ui" %>

<%@ page import="com.liferay.docs.exampleconfig.ExampleConfiguration" %>
<%@ page import="com.liferay.portal.kernel.util.GetterUtil" %>

<portlet:defineObjects />
<liferay-theme:defineObjects />
\end{verbatim}

It's a Liferay convention that all JSP imports in your application
should go in an \texttt{init.jsp} file. All of your application's other
JSPs import \texttt{init.jsp}. This convention ensures that you only
have to manage JSP dependencies in a single file.

Next, obtain the configuration object from request object and read the
desired configuration value from it. Here's an example \texttt{view.jsp}
file that does this:

\begin{verbatim}
<%@ include file="/init.jsp" %>

<p>
    <b>Hello from the Example Configuration portlet!</b>
</p>

<%
ExampleConfiguration configuration = (ExampleConfiguration) GetterUtil.getObject(
    renderRequest.getAttribute(ExampleConfiguration.class.getName()));

String favoriteColor = configuration.favoriteColor();
%>

<p>Favorite color: <span style="color: <%= favoriteColor %>;"><%= favoriteColor %></span></p
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/example-configuration-portlet.png}
\caption{Here, the Example Configuration portlet's \texttt{view.jsp} is
rendered. This JSP reads the value of the \texttt{favoriteColor}
configuration and displays it.}
\end{figure}

The example code here would make the application display a message like
this:

\begin{verbatim}
Favorite color: blue
\end{verbatim}

The word `blue' should be written in blue text. Note that `blue' is
displayed by default since you specified it as the default in your
\texttt{ExampleConfiguration} interface. If you go to \emph{System} →
\emph{System Settings} → \emph{Other} and click on the \emph{Example
configuration} link, you can find the \texttt{Favorite\ color} setting
and change its value. Your application's JSP will reflect this update
when you refresh the page.

\subsection{Categorizing the
Configuration}\label{categorizing-the-configuration}

Because it's easy to make any application or service configurable, there
are already lots of configuration options in Liferay DXP by default. If
you've deployed custom applications and services to your portal, there
will be even more. To make it easier for portal administrators to find
the right configuration options, Liferay provides a mechanism for
developers to specify a category in which the configuration will be
shown in the auto-generated System Settings UI in the Control Panel.

Here's how the System Settings UI looks:

\begin{figure}
\centering
\includegraphics{./images/system-settings-ui.png}
\caption{Navigate to the Control Panel, click on \emph{Configuration}
and then \emph{System Settings}. You'll find five categories of
configurations, including Other. Click on any configuration to access a
form through which the configuration values can be updated.}
\end{figure}

By default, the following configuration categories are defined:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Web Experience
\item
  Collaboration
\item
  Forms and Workflow
\item
  Foundation
\item
  Other
\end{enumerate}

You can use any other category and it will be injected in alphabetical
order after Platform. Other will always be shown last. In order to
specify a category, you must use the
\texttt{@ExtendedObjectClassDefinition} annotation as in the following
example:

\begin{verbatim}
@ExtendedObjectClassDefinition(category = "platform")
@Meta.OCD(
    factory = true,
    id = "com.liferay.portal.ldap.configuration.SystemLDAPConfiguration",
    localization = "content/Language"
)
\end{verbatim}

The fully qualified class name of the
\texttt{@ExtendedObjectClassDefinition} class is
\texttt{com.liferay.portal.configuration.metatype.annotations.ExtendedObjectClassDefinition}.

Note: Currently, the infrastructure used by System Settings relies on
the \texttt{configurationPid} being the same as the class name of the
interface. If they don't match, it will not be able to provide any
information provided through \texttt{ExtendedObjectClassConfiguration}.

The \texttt{@ExtendedObjectClassDefinition} annotation is distributed
through the \texttt{com.liferay.portal.configuration.metatype} module,
which you can
\href{/docs/7-0/tutorials/-/knowledge_base/t/configuring-dependencies}{configure
as a dependency}.

\subsection{Supporting Different Configurations per Virtual Instance,
Site, or Portlet
Instance}\label{supporting-different-configurations-per-virtual-instance-site-or-portlet-instance}

When an application is deployed to Liferay, it's common to need
different configurations depending on the scope. That means having
different configurations for a given application per virtual instance
(a.k.a. Company), site (a.k.a. Group), or portlet instance. Liferay DXP
provides an easy way to achieve this with little effort through a new
framework called the Configuration API that is based on the standard
OSGi Configuration Admin API shown in the previous section.

\subsubsection{Using the Configuration
Provider}\label{using-the-configuration-provider}

When using the Configuration Provider, instead of receiving the
configuration directly, the class that wants to access it will need to
receive a \texttt{ConfigurationProvider} from which to obtain the
configuration. Additionally, you need to ``register'' your class.

Note: \texttt{ConfigurationProvider} is part of Liferay's kernel API so
you don't need to add a new dependency to use it. However, its
implementation is distributed as a module called
\texttt{portal-configuration-module-configuration}, so you will need to
make sure it is installed in order to use it.

Before using the \texttt{ConfigurationProvider}, register the
configuration class by writing a class that implements
\texttt{ConfigurationBeanDeclaration}. This class only has one method
that returns the class of the interface you created in the previous
section. By doing this, the system is able to keep track of any
configuration changes as they happen. This makes requests for the
configuration very fast.

Declare the configuration interface by creating a
\texttt{ConfigurationBeanDeclaration} class:

\begin{verbatim}
@Component
public class RSSPortletInstanceConfigurationBeanDeclaration
    implements ConfigurationBeanDeclaration {

    @Override
    public Class getConfigurationBeanClass() {
        return RSSPortletInstanceConfiguration.class;
    }

}
\end{verbatim}

Once you have created your \texttt{ConfigurationBeanDeclaration}, you
can use a \texttt{ConfigurationProvider}. Here's how you can obtain a
reference to it:

\begin{itemize}
\item
  For components:

\begin{verbatim}
  @Reference
  protected void setConfigurationProvider(ConfigurationProvider configurationProvider) {
      _configurationProvider = configurationProvider;
  }
\end{verbatim}
\item
  For Service Builder services:

\begin{verbatim}
  @ServiceReference(type = ConfigurationProvider.class)
  protected ConfigurationProvider configurationProvider;
\end{verbatim}
\item
  For Spring beans: It is possible to use the same mechanism as for
  Service Builder services (\texttt{@ServiceReference}). Check the
  documentation on
  \href{/docs/7-0/tutorials/-/knowledge_base/t/finding-and-invoking-liferay-services\#referencing-osgi-services}{how
  to integrate Spring beans with OSGi services} for more details.
\end{itemize}

Later, the configuration can be obtained using one of the following
methods of the provider:

\begin{itemize}
\item
  \texttt{getCompanyConfiguration()}: Used when you want to support
  different configurations per virtual instance. In this case, the
  configuration is usually entered by an admin through Control Panel →
  Configuration → Instance Settings. Since this UI is not automatically
  generated (yet) you will need to extend the UI with your own form.
\item
  \texttt{getGroupConfiguration()}: Used when you want to support
  different configurations per site (or, if desired, per page scope).
  Usually this configuration is specified by an admin through the
  Configuration menu option in an app accessing through the site
  administration menu. That UI is developed as a portlet configuration
  view.
\item
  \texttt{getPortletInstanceConfiguration()}: Used to obtain the
  configuration for an specific portlet instance. Most often you should
  not be using this directly and use the convenience method in
  \texttt{PortletDisplay} instead as shown below.
\item
  \texttt{getSystemConfiguration}: Used to obtain the configuration for
  the system scope. These settings are specified by an admin via the
  System Settings application or with an OSGi configuration file.
\end{itemize}

Here are a couple real world examples from Liferay's source code:

\begin{verbatim}
JournalGroupServiceConfiguration configuration =
    configurationProvider.getGroupConfiguration(
        JournalGroupServiceConfiguration.class, groupId);

MentionsGroupServiceConfiguration configuration =
  _configurationProvider.getCompanyConfiguration(
     MentionsGroupServiceConfiguration.class, entry.getCompanyId());
\end{verbatim}

Next, you'll learn how to access a portlet's configuration from outside
of an OSGi component.

\subsubsection{Accessing the Portlet Instance Configuration Through the
PortletDisplay}\label{accessing-the-portlet-instance-configuration-through-the-portletdisplay}

Often it's necessary to access a portlet's settings from its JSPs or
from Java classes that are not OSGi components. To make it easier to
read the settings in these cases, a new method has been added to
\texttt{PortletDisplay} (available as a request object). Here is an
example of how to use it:

\begin{verbatim}
RSSPortletInstanceConfiguration rssPortletInstanceConfiguration =
    portletDisplay.getPortletInstanceConfiguration(
        RSSPortletInstanceConfiguration.class);
\end{verbatim}

As you can see, it knows how to find the values and returns a typed bean
containing them just by passing the configuration class.

\subsection{Specifying the Scope of the
Configuration}\label{specifying-the-scope-of-the-configuration}

The \texttt{ExtendedObjectClassDefinition} annotation allows you to
specify the scope of the configuration. This should match how the
configuration object is retrieved through the provider (your choice).
The valid options are:

\begin{itemize}
\tightlist
\item
  \texttt{Scope.GROUP}: for site scope
\item
  \texttt{Scope.COMPANY}: For virtual instance scope
\item
  \texttt{Scope.SYSTEM}: for system scope
\end{itemize}

Here is an example:

\begin{verbatim}
@ExtendedObjectClassDefinition(
    category = "productivity", scope = ExtendedObjectClassDefinition.Scope.GROUP
)
@Meta.OCD(
    id = "com.liferay.dynamic.data.lists.form.web.configuration.DDLFormWebConfiguration",
    localization = "content/Language", name = "%ddl.form.web.configuration.name"
)
public interface DDLFormWebConfiguration {
...
}
\end{verbatim}

In Liferay DXP version 7.0, the scope property isn't used for anything
other than making it appear in System Settings so that an administrator
can change its value. In future releases, may have more purposes.

\subsection{Summary}\label{summary}

In this tutorial, you've learned how to make your applications
configurable. Creating a simple configuration interface allows Liferay
to auto-generate a configuration UI that's accessible via System
Settings in the Control Panel. You've also learned how to categorize
your configurations within System Settings, how read configuration
settings in your application at runtime, how to support different
configurations at different scopes, and how to reuse the same
configuration class for different scenarios.

\section{Implementing Configuration
Actions}\label{implementing-configuration-actions}

When developing an application, it's important to think about the
different configuration options that your application should support.
It's also important to think about how users should be able to access
your application's configuration interface. Liferay DXP supports a
flexible mechanism for configuring applications. You can read about it
in the
\href{/docs/7-0/tutorials/-/knowledge_base/t/making-your-applications-configurable}{Making
Your Applications Configurable} tutorial. In this tutorial, you'll learn
to implement a configuration action. The configuration action is invoked
when a user clicks on the gear icon and selects \emph{Configuration}.

\begin{figure}
\centering
\includegraphics{./images/gear-configuration.png}
\caption{When a user clicks the gear icon and selects
\emph{Configuration}, the application's configuration action is
invoked.}
\end{figure}

Liferay applications support a default configuration action. If you
click on the gear icon of an application that has not been customized
and then select \emph{Configuration}, you'll find two standard tabs:
Permissions and Sharing. These tabs provide standard options for
configuring who can access your application and how you can make your
application more widely available. If you follow the instructions in
this tutorial, you'll learn how to create a Setup tab that allows custom
configuration fields to be manipulated. To implement a configuration
action, follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Create an interface to represent your configuration
\item
  Implement your application class and add a reference to your
  configuration in your application class
\item
  Implement your configuration action class and add a reference to your
  configuration in your configuration action class
\item
  Implement the user interface for configuring your application
\end{enumerate}

\noindent\hrulefill

\textbf{Note:} To quickly see a working configuration action, deploy the
\texttt{configuration-action}
\href{https://github.com/liferay/liferay-blade-samples/tree/7.0/gradle/apps/configuration-action}{Blade
sample} and add the \emph{Blade Message Portlet} to a page. Click the
\emph{Options} button
(\includegraphics{./images/icon-app-options.png}) and select
\emph{Configuration}. Change the configuration options and save them to
see them in action.

\noindent\hrulefill

Let's get started.

\subsection{Creating a Configuration
Interface}\label{creating-a-configuration-interface}

As explained in the
\href{/docs/7-0/tutorials/-/knowledge_base/t/making-your-applications-configurable}{Making
Your Applications Configurable} tutorial, if you want to make your
application configurable, you should create a Java interface to
represent the configuration. Decorate your interface with the
\texttt{@Meta.OCD} annotation and specify a unique ID using the
annotation's \texttt{id} attribute. A common pattern is to use the fully
qualified class name of the interface for the ID since fully qualified
class names are unique. Create public methods to represent configuration
fields and decorate the methods with the \texttt{@Meta.AD} annotation.
The return type of the method specifies the type of the field. To
specify a field's default value, use the annotation's \texttt{deflt}
attribute. To specify that a field is optional, set
\texttt{required=false}. For more information about the
\texttt{Meta.OCD} and \texttt{Meta.AD} annotations, please see the
\href{http://www.aqute.biz/Bnd/MetaType}{bnd} documentation. Here's a
simple example:

\begin{verbatim}
package com.liferay.docs.exampleconfig.configuration;

import aQute.bnd.annotation.metatype.Meta;

@Meta.OCD(id = "com.liferay.docs.exampleconfig.configuration.ExampleConfiguration")
public interface ExampleConfiguration {

    @Meta.AD(required = false)
    public String favoriteColor();

}
\end{verbatim}

Add the following line to your project's \texttt{bnd.bnd} file:

\begin{verbatim}
-metatype: *
\end{verbatim}

This line lets bnd use your configuration interface to generate an XML
configuration file. This lets Liferay DXP auto-generate a UI for your
configuration in the System Settings area of the Control Panel. However,
it's sometimes preferable for users to be able to access your
configuration directly from the portlet without having to go to the
Control Panel. In this tutorial, you'll learn how to facilitate this.

This sample configuration contains a single string field called
\texttt{favoriteColor}.

\subsection{Referencing Your Configuration From Your Application
Class}\label{referencing-your-configuration-from-your-application-class}

As was also explained in the
\href{/docs/7-0/tutorials/-/knowledge_base/t/making-your-applications-configurable}{Making
Your Applications Configurable} tutorial, if you want a reference to the
configuration in your application class, you need to declare the
configuration as a \texttt{volatile} member variable, decorate your
application class with the \texttt{@Component} annotation, specify the
appropriate \texttt{configurationPid} in the \texttt{@Component}
annotation, add an appropriately annotated \texttt{activate} method that
instantiates the configuration variable, and add a public getter method
for each configuration field. Here's a simple example that makes the
sample configuration discussed earlier available to a portlet class:

\begin{verbatim}
package com.liferay.docs.exampleconfig.portlet;

import java.io.IOException;
import java.util.Map;

import javax.portlet.Portlet;
import javax.portlet.PortletException;
import javax.portlet.RenderRequest;
import javax.portlet.RenderResponse;

import org.osgi.service.component.annotations.Activate;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Modified;

import com.liferay.docs.exampleconfig.configuration.ExampleConfiguration;
import com.liferay.portal.configuration.metatype.bnd.util.ConfigurableUtil;
import com.liferay.portal.kernel.portlet.bridges.mvc.MVCPortlet;

@Component(
    configurationPid =
    "com.liferay.docs.exampleconfig.configuration.ExampleConfiguration",
    immediate = true,
    property = {
        "com.liferay.portlet.display-category=category.sample",
        "com.liferay.portlet.instanceable=true",
        "javax.portlet.security-role-ref=power-user,user",
        "javax.portlet.init-param.template-path=/",
        "javax.portlet.init-param.view-template=/view.jsp",
        "javax.portlet.resource-bundle=content.Language"
    },
    service = Portlet.class
)
public class ExampleConfigPortlet extends MVCPortlet {
        
        @Override
        public void doView(RenderRequest renderRequest,
                RenderResponse renderResponse) throws IOException, PortletException {

                renderRequest.setAttribute(
                        ExampleConfiguration.class.getName(),
                        _exampleConfiguration);

                super.doView(renderRequest, renderResponse);
        }
        
        public String getFavoriteColor(Map labels) {
                return (String) labels.get(_exampleConfiguration.favoriteColor());
        }

        @Activate
        @Modified
        protected void activate(Map<Object, Object> properties) {
                _exampleConfiguration = ConfigurableUtil.createConfigurable(
                        ExampleConfiguration.class, properties);
        }

        private volatile ExampleConfiguration _exampleConfiguration;

}
\end{verbatim}

In this example, overriding the \texttt{doView} method is not strictly
necessary. However, it's useful since adding the configuration to the
request object before calling \texttt{super.doView} makes the
configuration able to be read from the request by the application's
JSPs.

\subsection{Implementing a Configuration
Action}\label{implementing-a-configuration-action}

To implement a configuration action, you should create a class that
extends Liferay DXP's \texttt{DefaultConfigurationAction} class. Then
you need to add a reference to your configuration the same way that you
added such a reference to your application class. Declare the
configuration as a \texttt{volatile} member variable, decorate your
configuration action class with the \texttt{@Component} annotation,
specify the appropriate \texttt{configurationPid} in the
\texttt{@Component} annotation, add an appropriately annotated
\texttt{activate} method that instantiates the configuration variable,
and add a public getter method for each configuration field.

Next, you should specify
\texttt{configurationPolicy\ =\ ConfigurationPolicy.OPTIONAL} in your
class's \texttt{@Component} annotation. An optional configuration policy
means that the component is created regardless of whether or not the
configuration was set. You also need to specify the portlet to which
your configuration action class applies. To do so, make the following
specification in your class's \texttt{@Component} annotation:

\begin{verbatim}
property = {
    "javax.portlet.name=com_liferay_docs_exampleconfig_portlet_ExampleConfigPortlet"
},
\end{verbatim}

Your component should be registered as a configuration action class so
you should specify \texttt{service\ =\ ConfigurationAction.class} in
your class's \texttt{@Component} annotation.

Next, you should override the \texttt{processAction} method so that it
reads a URL parameter from the action request, sets the value as a
portlet preference, and invokes the \texttt{processAction} method of the
\texttt{SettingsConfigurationAction} ancestor class. Finally, you should
override the \texttt{include} method so that it sets the configuration
as an attribute of the HTTP servlet request and then invokes the
\texttt{include} method of the
\texttt{BaseJSPSettingsConfigurationAction} class. Here's an example:

\begin{verbatim}
package com.liferay.docs.exampleconfig.action;

import java.util.Map;

import javax.portlet.ActionRequest;
import javax.portlet.ActionResponse;
import javax.portlet.PortletConfig;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.osgi.service.component.annotations.Activate;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.ConfigurationPolicy;
import org.osgi.service.component.annotations.Modified;

import com.liferay.docs.exampleconfig.configuration.ExampleConfiguration;
import com.liferay.portal.configuration.metatype.bnd.util.ConfigurableUtil;
import com.liferay.portal.kernel.portlet.ConfigurationAction;
import com.liferay.portal.kernel.portlet.DefaultConfigurationAction;
import com.liferay.portal.kernel.util.ParamUtil;

@Component(
    configurationPid = "com.liferay.docs.exampleconfig.configuration.ExampleConfiguration",
    configurationPolicy = ConfigurationPolicy.OPTIONAL,
    immediate = true,
    property = {
        "javax.portlet.name=com_liferay_docs_exampleconfig_portlet_ExampleConfigPortlet"
    },
    service = ConfigurationAction.class
)
public class ExampleConfigurationAction extends DefaultConfigurationAction {

    @Override
    public void processAction(
            PortletConfig portletConfig, ActionRequest actionRequest,
            ActionResponse actionResponse)
        throws Exception {

        String favoriteColor = ParamUtil.getString(actionRequest, "favoriteColor");
        setPreference(actionRequest, "favoriteColor", favoriteColor);

        super.processAction(portletConfig, actionRequest, actionResponse);
    }

    @Override
    public void include(
        PortletConfig portletConfig, HttpServletRequest httpServletRequest,
        HttpServletResponse httpServletResponse) throws Exception {

        httpServletRequest.setAttribute(
            ExampleConfiguration.class.getName(),
            _exampleConfiguration);

        super.include(portletConfig, httpServletRequest, httpServletResponse);
    }

    @Activate
    @Modified
    protected void activate(Map<Object, Object> properties) {
        _exampleConfiguration = ConfigurableUtil.createConfigurable(
            ExampleConfiguration.class, properties);
    }

    private volatile ExampleConfiguration _exampleConfiguration;

}
\end{verbatim}

Now that your configuration action class has been created, you're ready
to create a user interface for selecting configuration options and
submitting the selections.

\subsection{Implementing the User Interface For Configuring Your
Application}\label{implementing-the-user-interface-for-configuring-your-application}

When creating a JSP-based user interface, it's convenient to create an
\texttt{init.jsp} page for your application. The \texttt{init.jsp} page
should contain all of the imports, tag library declarations, and other
page components are required by your other JSPs. Each of your other
pages should import \texttt{init.jsp} so that you don't need to
duplicate code. Liferay DXP follows this convention.

Here's an example \texttt{init.jsp} file:

\begin{verbatim}
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %>
<%@ taglib uri="http://java.sun.com/portlet_2_0" prefix="portlet" %>

<%@ taglib uri="http://liferay.com/tld/aui" prefix="aui" %>
<%@ taglib uri="http://liferay.com/tld/portlet" prefix="liferay-portlet" %>
<%@ taglib uri="http://liferay.com/tld/theme" prefix="liferay-theme" %>
<%@ taglib uri="http://liferay.com/tld/ui" prefix="liferay-ui" %>

<%@ page import="com.liferay.docs.exampleconfig.configuration.ExampleConfiguration" %>
<%@ page import="com.liferay.portal.kernel.util.StringPool" %>
<%@ page import="com.liferay.portal.kernel.util.Validator" %>

<portlet:defineObjects />

<liferay-theme:defineObjects />

<%
    ExampleConfiguration exampleConfiguration =
        (ExampleConfiguration)
        renderRequest.getAttribute(ExampleConfiguration.class.getName());

    String favoriteColor = StringPool.BLANK;
    
    if (Validator.isNotNull(exampleConfiguration)) {
        favoriteColor =
            portletPreferences.getValue(
                "favoriteColor", exampleConfiguration.favoriteColor());
    }
%>
\end{verbatim}

This JSP not only declares some tag libraries and imports some classes.
It uses the \texttt{\textless{}portlet:defineObjects\ /\textgreater{}}
and \texttt{\textless{}liferay-theme:defineObjects\ /\textgreater{}}
tags to make certain variables available on the page. The scriptlet at
the end of the file uses one of these variables, \texttt{renderRequest},
to get the configuration which was stored in the \texttt{renderRequest}
by your portlet's \texttt{doView} method. Finally, the value of a
specific field (\texttt{favoriteColor}) is read from the configuration.

The default view of your application is provided by your application's
\texttt{view.jsp}. Your \texttt{view.jsp} should import your
\texttt{init.jsp} so that the same tag libraries, imports, and variables
are available on the page. Here's an example \texttt{view.jsp} file:

\begin{verbatim}
<%@ include file="/init.jsp" %>

<p>
    <liferay-ui:message key="com_liferay_docs_exampleconfig_portlet_ExampleConfigPortlet.caption"/>
</p>

<%
    boolean noConfig = Validator.isNull(favoriteColor);
%>

<c:choose>
    <c:when test="<%= noConfig %>">
        <p>
            Please select use the portlet configuration to select a favorite color.
        </p>
    </c:when>

    <c:otherwise>
        <p style="color: <%= favoriteColor %>">
            Favorite color: <%= favoriteColor %>!
        </p>
    </c:otherwise>
</c:choose>
\end{verbatim}

This JSP simply checks whether or not the \texttt{favoriteColor}
variable is empty. If it's empty, a message is displayed that tells the
user that they need to select a favorite color in the portlet's
configuration. If the \texttt{favoriteColor} variable is not empty, the
name of the selected color is displayed in the selected color. Note: The
value of the
\texttt{com\_liferay\_docs\_exampleconfig\_portlet\_ExampleConfigPortlet.caption}
language key must be specified in your application's
\texttt{Language.properties} file. The default location for this file is
in the \texttt{content} package.

The configuration user interface of your application is provided by your
application's \texttt{configuration.jsp} file. This interface is
displayed on the Setup tab when a user clicks on your application's gear
icon and then selects \emph{Configuration}. As previously discussed,
your \texttt{configuration.jsp} should import your \texttt{init.jsp}
file. Here's an example \texttt{configuration.jsp} file:

\begin{verbatim}
<%@ include file="/init.jsp" %>

<%@ page import="com.liferay.portal.kernel.util.Constants" %>

<liferay-portlet:actionURL portletConfiguration="<%= true %>"
    var="configurationActionURL" />

<liferay-portlet:renderURL portletConfiguration="<%= true %>"
    var="configurationRenderURL" />

<aui:form action="<%= configurationActionURL %>" method="post" name="fm">

    <aui:input name="<%= Constants.CMD %>" type="hidden"
        value="<%= Constants.UPDATE %>" />

    <aui:input name="redirect" type="hidden"
        value="<%= configurationRenderURL %>" />

    <aui:fieldset>

        <aui:select name="favoriteColor" label="Favorite Color"
            value="<%= favoriteColor %>">
            <aui:option value="indigo">Indigo</aui:option>
            <aui:option value="blue">Blue</aui:option>
            <aui:option value="green">Green</aui:option>
            <aui:option value="yellow">Yellow</aui:option>
            <aui:option value="orange">Orange</aui:option>
            <aui:option value="red">Red</aui:option>
        </aui:select>

    </aui:fieldset>
    <aui:button-row>
        <aui:button type="submit"></aui:button>
    </aui:button-row>
</aui:form>
\end{verbatim}

This JSP uses the
\texttt{\textless{}liferay-portlet:actionURL\ /\textgreater{}} and
\texttt{\textless{}liferay-portlet:renderURL\ /\textgreater{}} tags to
construct two URLs in the variables \texttt{configurationActionURL} and
\texttt{configurationRenderURL}. The JSP presents a simple form that
allows the user to select a favorite color. When the user submits the
form, the \texttt{configurationActionURL} is invoked and the
application's \texttt{processAction} method is invoked with the
\texttt{favoriteColor} included as a request parameter:

\begin{verbatim}
<aui:form action="<%= configurationActionURL %>" method="post" name="fm">
\end{verbatim}

If the request fails, the user is redirected to the configuration page:

\begin{verbatim}
<aui:input name="redirect" type="hidden"
    value="<%= configurationRenderURL %>" />
\end{verbatim}

It's a best practice to supply a URL parameter named \texttt{cmd}
(\texttt{Constants.CMD} equals \texttt{cmd}) whose value indicates the
purpose of the request. In this example, the value of the \texttt{cmd}
parameter is \texttt{update} (\texttt{Constants.CMD} equals
\texttt{update}):

\begin{verbatim}
<aui:input name="<%= Constants.CMD %>" type="hidden"
    value="<%= Constants.UPDATE %>" />
\end{verbatim}

Many core applications read the value of the \texttt{cmd} parameter and
perform some processing depending on its value.

If you're developing an application using the example code from this
tutorial, deploy the application to Liferay DXP, add it to a page, and
click on the \emph{Options} button
(\includegraphics{./images/icon-app-options.png}), then select
\emph{Configuration}. Select a favorite color and click \emph{Save}. To
confirm that your selection was saved as a portlet configuration
setting, look for the application to display a message like this:

\begin{verbatim}
Favorite color: blue!
\end{verbatim}

Excellent! Now you know how to create application configurations and how
to create a mechanism to allow users to edit the configuration.

\section{Transitioning from Portlet Preferences to the Configuration
API}\label{transitioning-from-portlet-preferences-to-the-configuration-api}

This tutorial describes how to take an existing portlet developed for
Liferay Portal 6.2 or prior, which uses portlet preferences to allow
administrators to configure the portlet, and convert it to use the new
Configuration API.

For more information on the Configuration API and the recommended ways
to develop configurable applications for 7.0, please see the
\href{/docs/7-0/tutorials/-/knowledge_base/t/making-your-applications-configurable}{Making
your applications configurable} tutorial.

Before you start, it's important to understand the benefits of making
this change. That will allow you to decide whether to go ahead with the
change or not, since previous configuration mechanisms of Liferay Portal
6.2 and prior still work in 7.0.

The main benefits are:

\begin{itemize}
\item
  Ability to modify the default portlet preferences through the new
  System Settings UI. Previously the default configuration of a portlet
  could only be set by modifying the portlet.xml file, which was not
  easy to extend.
\item
  In the future Liferay will support modifying the default values for
  any portlet using this API for each company or site. If you use the
  new API you won't need to make any change to benefit from this.
\item
  You can now use the PortletPreferences API to allow users to have
  their own personal preferences for the portlet, which was the original
  intention of this API.
\item
  Have full programmatic control of the scope of the configuration
  (Portlet Instance or Group), instead of leaving it to the
  liferay-portlet.xml file.
\item
  It becomes easier to read the configuration of the portlet from any
  class or JSP just by knowing its name. The configuration is also
  presented as a typed object which reduces the possibility of error
  reading a property name or type.
\end{itemize}

One final thing to note is that using the new Configuration API
preserves all existing configurations of the portlet, since it uses the
same persistence storage (the PortletPreferences table). That means that
you can deploy a new version of the portlet to a running system and the
existing portlets that may have been added to its pages and configured
will not need to be reconfigured.

If your existing (Liferay Portal 6.2 or prior) application uses portlet
preferences and you have decided to convert it to use the new
Configuration API, follow these steps to update your application:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Identify the existing preferences of the portlet configuration.

  For example, you could check the \texttt{configuration.jsp} (where you
  will find DOM elements with the name \texttt{preferences-\/-XXX-\/-},
  where \texttt{XXX} is the name of the preference).
\item
  Determine the scope of the portlet configuration. The traditional way
  of specifying it is through \texttt{liferay-portlet.xml}. Look at the
  elements \texttt{preferences-company-wide},
  \texttt{preferences-unique-per-layout} and
  \texttt{preferences-owned-by-group} to determine the right scope. The
  following table maps out the scopes:
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 liferay-portlet.xml                                                     | Scope            |
-------------------------------------------------------------------------|------------------|
 preferences-company-wide=true                                           | Company          |
 preferences-owned-by-group=true AND preferences-unique-per-layout=false | Group            |
 preferences-owned-by-group=true AND preferences-unique-per-layout=true  | Portlet Instance |
\end{verbatim}

\noindent\hrulefill

\begin{verbatim}
Related to this, we make the following recommendations for the scope of the
configuration of a portlet:

* For any portlet that can be added to a page it should be Portlet Instance. 

* For any portlet that is accessible through the product menu and is used to
administer the site it should be Group.
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\item
  Create a Java interface that will represent the configuration, with
  one method per existing preference.

  By Liferay's convention, the suggested names for these interfaces are
  \texttt{{[}Portlet\ Name{]}PortletInstanceConfiguration} for the
  portlet scoped ones or
  \texttt{{[}Portlet\ Name{]}GroupServiceConfiguration} for the group
  scoped ones. However you can choose different conventions.

  This interface will use two annotations (\texttt{@Meta.OCD} and
  \texttt{@ExtendedObjectClassDefinition}) to declare that it represents
  a configuration and to specify the desired scope. The \texttt{id}
  specified in the \texttt{@Meta.OCD} annotation must be the fully
  qualified class name of the interface.

  For example,

\begin{verbatim}
 @ExtendedObjectClassDefinition(
     category = "[category]",
     scope = ExtendedObjectClassDefinition.Scope.GROUP
 )
 @Meta.OCD(
     id = "[package].[PortletName]GroupServiceConfiguration",
 )
 public interface [PortletName]GroupServiceConfiguration {
     @Meta.AD(deflt = "", required = false)
     public String displayStyle();

     @Meta.AD(deflt = "0", required = false)
     public long displayStyleGroupId(long defaultDisplayStyleGroupId);
 }
\end{verbatim}
\item
  In the code above replace {[}category{]} with a category name of your
  choice. Out of the box Liferay uses: wem, forms, collaboration and
  foundation. If your portlet fits in any of those go ahead and use
  them. If you pick any other name it will be added, but you will need
  to provide a translation as well.
\item
  If you want to specify the name of the configuration as it will appear
  in System Settings (and optionally translate it to several languages)
  add the attributes name and localization (to specify the location of a
  resource bundle file) to the @Meta.OCD annotation:

\begin{verbatim}
 @Meta.OCD(
     localization = "content/Language",
     name = "[PortletName].group.service.configuration.name"
     id = "[package].[PortletName]GroupServiceConfiguration",
 )
\end{verbatim}
\item
  Create one class that implements the Configuration Bean Declaration
  interface to let the Configuration framework know about the
  Configuration class.

\begin{verbatim}
 @Component
 public class [PortletName]GroupServiceConfigurationBeanDeclaration
         implements ConfigurationBeanDeclaration {

     @Override
     public class getConfigurationBeanClass() {
         return [[PortletName]GroupServiceConfiguration.class;
     }

 }
\end{verbatim}
\item
  Change the configuration JSP to retrieve the configuration using the
  Configuration API. If the scope is ``Portlet Instance'' the
  configuration can be retrieved from \texttt{portletDisplay}:

\begin{verbatim}
 [PortletName]PortletInstanceConfiguration portletInstanceConfiguration = 
     portletDisplay.getPortletInstanceConfiguration(
         [PortletName]PortletInstanceConfiguration.class);
\end{verbatim}

  Once the configuration object is obtained, the individual preferences
  can now be changed from this:

\begin{verbatim}
 String displayStyle = portletPreferences.getValue("displayStyle", defaultValue);
\end{verbatim}

  \ldots{} to this \ldots{}

\begin{verbatim}
 String displayStyle = v.displayStyle();
\end{verbatim}
\item
  Finally it is usually necessary to read the configuration from Java
  classes or other JSPs. In cases where the \texttt{portletDisplay} is
  not available, or when the scope is ``Group'' or ``Company'', the
  \texttt{PortletProvider} class offers methods to obtain the
  configuration. The best way to access the \texttt{PortletProvider}
  depends on who is making the invocation:

  Within an OSGi Component a reference to the
  \texttt{ConfigurationProvider} can be obtained and used as follows:

\begin{verbatim}
     @Component(service = Foo)
         public class Foo {

             protected void methodWhichNeedsConfiguration() {
                 _configurationProvider.getGroupConfiguration(
                     [PortletName]GroupServiceConfiguration.class, groupId);
             }

             @Reference
             private ConfigurationProvider _configurationProvider;
         }
\end{verbatim}

  Within a service created with Service Builder the code is very
  similar:

\begin{verbatim}
         public class FooServiceImpl {

             protected void methodWhichNeedsConfiguration() {
                 _configurationProvider.getGroupConfiguration(
                     [PortletName]GroupServiceConfiguration.class, groupId);
             }

             @Reference
             private ConfigurationProvider _configurationProvider;
         }
\end{verbatim}

  For all other cases it is preferred to get the configuration injected
  or passed as a parameter. As a last resort it is possible to use
  \texttt{ConfigurationProviderUtil} to obtain the configuration,
  although this method might have issues in highly dynamic environments:

\begin{verbatim}
         [PortletName]GroupServiceConfiguration groupConfiguration 
                 ConfigurationProviderUtil.getGroupConfiguration(
                     [PortletName]GroupServiceConfiguration.class, groupId);
\end{verbatim}
\end{enumerate}

\chapter{Social}\label{social}

Liferay DXP's social framework lets users provide feedback on content,
share that content with others across social networks, and subscribe to
notifications on content, so they can stay up to date on the latest and
greatest that you have to share.

The tutorials that follow show you how to take advantage of Liferay
DXP's social framework to enable these features in your own app.

\section{Applying Social Bookmarks}\label{applying-social-bookmarks}

When you enable social bookmarks, icons for sharing on Twitter,
Facebook, and Google Plus appear below your app's content. Liferay DXP's
taglibs provide the markup you need to add this feature to your app.

\begin{figure}
\centering
\includegraphics{./images/social-bookmarks-icons.png}
\caption{Social bookmarks are enabled in the built-in Blogs portlet}
\end{figure}

Follow these steps to add social bookmarks to your app:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Make sure your entity is
  \href{/docs/7-0/tutorials/-/knowledge_base/t/adding-updating-and-deleting-assets-for-custom-entities}{asset
  enabled}.
\item
  Choose a view in which to show the social bookmarks. For example, you
  can display them in one of your portlet's views, or if you've
  implemented
  \href{/docs/7-0/tutorials/-/knowledge_base/t/rendering-an-asset}{asset
  rendering} you can display them in the full content view in the Asset
  Publisher portlet.
\item
  In your JSP, include the \texttt{liferay-ui}taglib declaration:

\begin{verbatim}
<%@ taglib prefix="liferay-ui" uri="http://liferay.com/tld/ui" %>
\end{verbatim}
\item
  Use \texttt{ParamUtil} to get the entity's ID from the render request.
  Then use your \texttt{-LocalServiceUtil} class to create an entity
  object:

\begin{verbatim}
<%
long entryId = ParamUtil.getLong(renderRequest, "entryId");
entry = EntryLocalServiceUtil.getEntry(entryId);
%>
\end{verbatim}
\item
  Use the
  \href{@platform-ref@/7.0-latest/taglibs/util-taglib/liferay-ui/social-bookmarks.html}{\texttt{liferay-ui:social-bookmarks}
  tag} to add the social bookmarks component. The \texttt{target}
  attribute refers to the HTML target. Pass the content's URL in the
  \texttt{url} attribute, using \texttt{PortalUtil} to retrieve the URL.
  The URL and \texttt{title} you provide is sent to the social network
  and becomes part of the link you create there:

\begin{verbatim}
<liferay-ui:social-bookmarks
    contentId="<%= String.valueOf(assetEntry.getEntryId()) %>"
    displayStyle="menu"
    target="_blank"
    title="<%= String.valueOf(entry.getName()) %>"
    url="<%= PortalUtil.getCanonicalURL((PortalUtil.getCurrentURL(request)), 
        themeDisplay, layout) %>" 
/>
\end{verbatim}

  Pay special attention to the \texttt{displayStyle} attribute. This
  attribute sets the social bookmarks' appearance. Setting
  \texttt{displayStyle} to \texttt{menu}, as in this example, hides the
  share buttons in a clutter-free menu (see above screenshot).

  Setting \texttt{displayStyle} to \texttt{simple} displays the share
  buttons in a simple row without share stats.

  \begin{figure}
  \centering
  \includegraphics{./images/social-bookmarks-icons-simple.png}
  \caption{Here are the share buttons with \texttt{displayStyle} set to
  \texttt{simple}.}
  \end{figure}

  Setting \texttt{displayStyle} to \texttt{vertical} displays the share
  buttons in a column, with share stats above each (share stats show the
  number of times the asset has been shared on the corresponding social
  network).

  \begin{figure}
  \centering
  \includegraphics{./images/social-bookmarks-icons-vertical.png}
  \caption{Here are the share buttons with \texttt{displayStyle} set to
  \texttt{vertical}.}
  \end{figure}

  Setting \texttt{displayStyle} to \texttt{horizontal} displays the
  share buttons in a row with share stats to the right of each.

  \begin{figure}
  \centering
  \includegraphics{./images/social-bookmarks-icons-horizontal.png}
  \caption{Here are the share buttons with \texttt{displayStyle} set to
  \texttt{horizontal}.}
  \end{figure}
\end{enumerate}

The social bookmarks UI component now shows in your entity's view.

\begin{figure}
\centering
\includegraphics{./images/social-guestbook-social-bookmarks.png}
\caption{The new JSP lets users share app content to social networks.}
\end{figure}

\noindent\hrulefill

\textbf{Note:} You can install the Social Bookmarks app from the
Marketplace (available for
\href{https://web.liferay.com/marketplace/-/mp/application/15194315}{CE}
and
\href{https://web.liferay.com/marketplace/-/mp/application/15188453}{DXP})
to let your users share your app's content across more social networks.
For more information, see the article
\href{/docs/7-0/user/-/knowledge_base/u/integrating-with-facebook-twitter-and-more\#using-social-bookmarks}{Integrating
with Facebook, Twitter, and More}.

\noindent\hrulefill

Great! Now you know how to let users share content in your asset enabled
apps.

\subsection{Related Topics}\label{related-topics-147}

\href{/docs/7-0/tutorials/-/knowledge_base/t/adding-updating-and-deleting-assets-for-custom-entities}{Adding,
Updating, and Deleting Assets for Custom Entities}

\href{/docs/7-0/tutorials/-/knowledge_base/t/adding-permissions-to-resources}{Adding
Permissions to Resources}

\href{/docs/7-0/tutorials/-/knowledge_base/t/rendering-an-asset}{Rendering
an Asset}

\href{/docs/7-0/tutorials/-/knowledge_base/t/using-the-liferay-ui-taglib}{Using
the Liferay UI Taglib}

\section{Adding Comments to your App}\label{adding-comments-to-your-app}

Users adding comments to your content makes your site come alive.
Instead of you statically giving users information, now the flow goes
both ways. Liferay DXP's asset framework makes it easy to add a comment
system to your app.

\begin{figure}
\centering
\includegraphics{./images/social-comments-enabled.png}
\caption{Your JSP lets users comment on content in your portlet.}
\end{figure}

This tutorial shows you how to add the comment feature for your
application's content.

Follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Make sure your entity is
  \href{/docs/7-0/tutorials/-/knowledge_base/t/adding-updating-and-deleting-assets-for-custom-entities}{asset
  enabled}.
\item
  Choose a read-only view of the entity for the comments. You can
  display the comments component in your portlet's view, or if you've
  implemented
  \href{/docs/7-0/tutorials/-/knowledge_base/t/rendering-an-asset}{asset
  rendering}, you can display it in the full content view in the Asset
  Publisher portlet.
\item
  Include the Liferay-UI taglib and Portlet taglib declarations in your
  JSP:

\begin{verbatim}
<%@ taglib prefix="liferay-ui" uri="http://liferay.com/tld/ui" %>      
<%@ taglib prefix="portlet" uri="http://java.sun.com/portlet_2_0" %>
\end{verbatim}
\item
  Use \texttt{ParamUtil} to get the entity's ID from the render request.
  Then create an entity object using the \texttt{-LocalServiceUtil}
  class. Below is an example configuration:

\begin{verbatim}
<%
long entryId = ParamUtil.getLong(renderRequest, "entryId");
entry = EntryLocalServiceUtil.getEntry(entryId);
%>
\end{verbatim}
\item
  Create a collapsible panel for the comments using the
  \texttt{liferay-ui:panel-container} and \texttt{liferay-ui:panel}
  tags. This makes the discussion area hide-able. Below is an example
  configuration:

\begin{verbatim}
<liferay-ui:panel-container extended="<%=false%>"
  id="guestbookCollaborationPanelContainer" persistState="<%=true%>">
  <liferay-ui:panel collapsible="<%=true%>" extended="<%=true%>"
    id="guestbookCollaborationPanel" persistState="<%=true%>"
    title="Collaboration">
\end{verbatim}
\item
  Next, create a URL for the discussion using the
  \texttt{portlet:actionURL} tag:

\begin{verbatim}
<portlet:actionURL name="invokeTaglibDiscussion" var="discussionURL" />
\end{verbatim}
\item
  Finally, add the discussion with the \texttt{liferay-ui:discussion}
  tag. Pass the current URL using the \texttt{redirect} attribute, so
  the user can return to the JSP after making a comment. You can use
  \texttt{PortalUtil.getCurrentURL((renderRequest))} to get the current
  URL from the \texttt{request} object. Below is an example
  configuration:

\begin{verbatim}
    <liferay-ui:discussion className="<%=Entry.class.getName()%>"
      classPK="<%=entry.getEntryId()%>"
      formAction="<%=discussionURL%>" formName="fm2"
      ratingsEnabled="<%=true%>" redirect="<%=currentURL%>"
      userId="<%=entry.getUserId()%>" />

  </liferay-ui:panel>
</liferay-ui:panel-container>
\end{verbatim}
\end{enumerate}

If you haven't already connected your portlet's view to the JSP for your
entity, you can refer
\href{/docs/7-0/tutorials/-/knowledge_base/t/relating-assets\#creating-a-url-to-your-new-jsp}{here}
to see how to connect a portlet's main view JSP to an entity's view JSP.

Great! Now you know how to let users comment on content in your asset
enabled portlets.

\subsection{Related Topics}\label{related-topics-148}

\href{/docs/7-0/tutorials/-/knowledge_base/t/adding-updating-and-deleting-assets-for-custom-entities}{Adding,
Updating, and Deleting Assets for Custom Entities}

\href{/docs/7-0/tutorials/-/knowledge_base/t/adding-permissions-to-resources}{Adding
Permissions to Resources}

\href{/docs/7-0/tutorials/-/knowledge_base/t/rendering-an-asset}{Rendering
an Asset}

\href{/docs/7-0/tutorials/-/knowledge_base/t/applying-social-bookmarks}{Applying
Social Bookmarks}

\section{Rating Assets}\label{rating-assets}

Liferay DXP's asset framework supports a system for rating content in
apps. This feature appears in many core apps, such as the Blogs portlet.
Ratings give your users a voice, and you can benefit from their
feedback. Thanks to Liferay DXP's taglibs, you can enable ratings for
your app in only a few lines of code.

\begin{figure}
\centering
\includegraphics{./images/social-ratings-thumbs.png}
\caption{Ratings let users quickly provide feedback on content.}
\end{figure}

Follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Make sure your entity is
  \href{/docs/7-0/tutorials/-/knowledge_base/t/adding-updating-and-deleting-assets-for-custom-entities}{asset
  enabled}.
\item
  Choose a read-only view of the entity for the ratings. You can display
  them in one of your portlet's views, or if you've implemented
  \href{/docs/7-0/tutorials/-/knowledge_base/t/rendering-an-asset}{asset
  rendering} you can display them in the full content view in the Asset
  Publisher portlet.
\item
  In the JSP, include the \texttt{liferay-ui}taglib declaration:

\begin{verbatim}
<%@ taglib prefix="liferay-ui" uri="http://liferay.com/tld/ui" %>
\end{verbatim}
\item
  Use \texttt{ParamUtil} to get the entity's ID from the render request.
  Then use the \texttt{-LocalServiceUtil} class to create an entity
  object:

\begin{verbatim}
<%
long entryId = ParamUtil.getLong(renderRequest, "entryId");
entry = EntryLocalServiceUtil.getEntry(entryId);
%>
\end{verbatim}
\item
  Use the \texttt{liferay-ui:ratings} tag to add the ratings component:

\begin{verbatim}
<liferay-ui:ratings className="<%=Entry.class.getName()%>"
    classPK="<%=entry.getEntryId()%>" type="stars" />
\end{verbatim}

  The \texttt{type} attribute specifies the type of rating system to
  display:

  \begin{itemize}
  \tightlist
  \item
    \emph{like}: a likes rating system
  \item
    \emph{stars}: a five star rating system
  \item
    \emph{thumbs}: a thumbs-up or thumbs-down rating system, as shown in
    the figure above
  \end{itemize}

  Although the ratings type is specified here, you can make the type
  configurable for administrators by
  \href{/docs/7-0/tutorials/-/knowledge_base/t/ratings}{Implementing
  Ratings Type Selection and Value Type Transformation} in your app.
\end{enumerate}

Great! Now you know how to let users rate content in your asset-enabled
portlets.

\subsection{Related Topics}\label{related-topics-149}

\href{/docs/7-0/tutorials/-/knowledge_base/t/adding-comments-to-your-app}{Adding
Comments to Your App}

\href{/docs/7-0/tutorials/-/knowledge_base/t/applying-social-bookmarks}{Applying
Social Bookmarks}

\section{Implementing Ratings Type Selection and Value
Transformation}\label{implementing-ratings-type-selection-and-value-transformation}

Liferay DXP has three different mechanisms for rating content: Stars,
Thumbs Up/Down, and Likes. Prior to 7.0, there was no way for
administrators to select a ratings type as it was hard-coded. Now,
portal and site admins can select the ratings type for portlet entities
through the Control Panel and Site Administration. Portal admins can
select default values for the ratings type while site admins can
override values for their sites. All Liferay portlets take advantage of
this feature, and so can custom portlets.

A custom portlet that uses ratings must define its ratings type through
an OSGi component that implements the \texttt{PortletRatingsDefinition}
interface. This class declares the usage of ratings (specifying the
portlet and the entity) and the default ratings type (that can be
overridden by portal and site admins). Developers can include their
portlet entities in this section by defining the ratings type for the
entities using OSGi modules.

The ratings values are stored in the database as normalized values to be
able to easily switch among different ratings types. When the
administrators change the ratings type for an entity, Liferay does a
best match of the previous ratings values to values for the new ratings
type. For example, when changing from Thumbs Up/Down to Likes, Portal
considers all the Thumbs Up values as if they are Likes and omits all
Thumbs Down values. Also, when changing from Stars to Thumbs Up/Down
Portal considers ratings with 3, 4, or 5 Stars as Thumbs Up and ratings
with 1 or 2 Stars as Thumbs Down.

However, there are some cases where this may not be enough or where you
want to apply different or complex criteria to determine the new ratings
values. Liferay provides a mechanism to allow developers to transform
the ratings values as needed when admins change the ratings type. Keep
in mind, this is not an interpretation of the data, this is modification
of the stored ratings values. Third party developers can define their
own transformations by creating an OSGi component that implements the
\texttt{RatingsDataTransformer} interface. The highest OSGi ranking
implementation is used.

Liferay by default doesn't provide any \texttt{RatingsDataTransformer}
implementation; the ratings values always remain the same while Liferay
interprets existing values for the selected ratings type.

\subsection{Specifying an Entity's Ratings
Type}\label{specifying-an-entitys-ratings-type}

Ratings type definitions needs to implement the
\texttt{PortletRatingsDefinition} interface. The implementation of
method \texttt{getDefaultRatingsType} returns the entity's default
ratings type. Note, it can be overridden by portal and site admins. The
implementation of method \texttt{getPortletId} returns the portlet ID of
the main portlet that uses the entity.

Implementations of \texttt{PortletRatingsDefinition} need to be
registered in OSGi to be used by the portal. You do this in the
implementation by specifying the OSGi annotation \texttt{@Component}
with an attribute \texttt{model.class.name} set to the name or names of
the classes to use the ratings definition.

Here is an example of a \texttt{PortletRatingsDefition} implementation
for the Blogs portlet that defines the \texttt{blogsEntry} ratings data:

\begin{verbatim}
@Component(
    property = {
        "model.class.name=com.liferay.portlet.blogs.model.BlogsEntry"
    }
)
public class BlogsPortletRatingsDefinition implements PortletRatingsDefinition {

    @Override
    public RatingsType getDefaultRatingsType() {
        return RatingsType.THUMBS;
    }

    @Override
    public String getPortletId() {
        return PortletKeys.BLOGS;
    }

}
\end{verbatim}

Next, let's examine how to transform values between ratings types.

\subsection{Transforming Ratings Values Between Ratings
Types}\label{transforming-ratings-values-between-ratings-types}

If the site admin or portal admin changes the ratings type and there are
existing ratings values in the database, Liferay doesn't modify any of
them. It interprets the values using the selected ratings type according
to the following mechanism:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  When changing from Stars to \ldots{}

  \begin{itemize}
  \tightlist
  \item
    \textbf{Like:} 1 or 2 Stars aren't considered. 3, 4, or 5 Stars is
    considered a Like.
  \item
    \textbf{Thumbs Up/Down:} 1 or 2 Stars are considered a Thumbs Down.
    3, 4, or 5 Stars is considered a Thumbs Up.
  \end{itemize}
\item
  When changing from Thumbs Up/Down to \ldots{}

  \begin{itemize}
  \tightlist
  \item
    \textbf{Like:} A Like is considered a Thumbs Up.
  \item
    \textbf{Stars:} A Thumbs Down is considered 1 Star. A Thumbs Up is
    considered 5 Stars.
  \end{itemize}
\item
  When changing from Like to \ldots{}

  \begin{itemize}
  \tightlist
  \item
    \textbf{Stars:} A Like is considered 5 Stars.
  \item
    \textbf{Thumbs Up/Down:} A Like is considered a Thumbs Up.
  \end{itemize}
\end{enumerate}

There may be cases where this interpretation is insufficient for you or
where a different criteria or algorithm needs to be applied. For these
cases, Liferay provides a mechanism to allow transforming the existing
ratings values. Keep in mind that this modifies the values stored in the
database. Since these changes may not be reversible, you must be
careful. Developers will need to create an OSGi component that
implements the \texttt{RatingsDataTransformer} interface.

The implementation of method \texttt{transformRatingsData} performs the
data transformation. In order to obtain a fine-grained behaviour, the
framework provides the methods \texttt{fromRatingsType} and
\texttt{toRatingsType}. The developer can implement them to transform
data as needed, and perform different transformations for different
circumstances.

This is an example of a \texttt{RatingsDataTransformer} that resets the
score from the ratings type when passing from \texttt{LIKE} to
\texttt{STARS}. In this particular case, changes are not reversible.

\begin{verbatim}
@Component
public class DummieRatingsDataTransformer implements RatingsDataTransformer {
    @Override
    public ActionableDynamicQuery.PerformActionMethod transformRatingsData(
            final RatingsType fromRatingsType, final RatingsType toRatingsType)
        throws PortalException {

        return new ActionableDynamicQuery.PerformActionMethod() {

            @Override
            public void performAction(Object object)
                throws PortalException {

                if (fromRatingsType.getValue().equals(RatingsType.LIKE) &&
                    toRatingsType.getValue().equals(RatingsType.STARS)) {

                    RatingsEntry ratingsEntry = (RatingsEntry) object;

                    ratingsEntry.setScore(0);

                    RatingsEntryLocalServiceUtil.updateRatingsEntry(
                        ratingsEntry);
                }
            }
        };
    }

}
\end{verbatim}

Once you've implemented ratings type selection and value type
transformation for your app's entities, you can configure the default
ratings type values through the Control Panel by going to
\emph{Configuration} → \emph{Instance Settings} and selecting the
\emph{Social} tab. To override the default values for a site, go to Site
Administration → \emph{Configuration} → \emph{Site Settings} and select
the \emph{Social} tab.

In this tutorial, you have learned how to set a ratings type for an
entity and how to implement a ratings data transformer. Liferay salutes
you with a Thumbs Up!

\subsection{Related Topics}\label{related-topics-150}

\href{/docs/7-0/tutorials/-/knowledge_base/t/rating-assets}{Rating
Assets}

\href{/docs/7-0/tutorials/-/knowledge_base/t/adding-comments-to-your-app}{Adding
Comments to Your App}

\section{Flagging Inappropriate Asset
Content}\label{flagging-inappropriate-asset-content}

In a perfect world, people would post nice, kind, and decent content.
They would reply to comments with constructive feedback and never lash
out at one another. Unfortunately, sometimes people have a bad day and
decide to take their frustration out on Joe Bloggs in the form of an
inappropriate post. No worries though, Liferay DXP's asset framework
supports a system for flagging content in apps. Letting users flag
inappropriate content takes much of the work off site administrators.

\begin{figure}
\centering
\includegraphics{./images/social-flags.png}
\caption{Flags for letting users mark objectionable content are enabled
in the Message Boards portlet.}
\end{figure}

This tutorial shows you how to enable flagging of content in a portlet.

Follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Make sure your entity is
  \href{/docs/7-0/tutorials/-/knowledge_base/t/adding-updating-and-deleting-assets-for-custom-entities}{asset
  enabled}.
\item
  Choose a read-only view of the entity for the flags. You can display
  them in one of your portlet's views, or if you've implemented
  \href{/docs/7-0/tutorials/-/knowledge_base/t/rendering-an-asset}{asset
  rendering}, you can display them in the full content view in the Asset
  Publisher portlet.
\item
  In the JSP, include the \texttt{liferay-flags} taglib declaration:

\begin{verbatim}
<%@ taglib prefix="liferay-flags" uri="http://liferay.com/tld/flags" %>
\end{verbatim}
\item
  Use the \texttt{-LocalServiceUtil} class to get the entity:

\begin{verbatim}
<%
long entryId = ParamUtil.getLong(renderRequest, "entryId");
entry = EntryLocalServiceUtil.getEntry(entryId);
%>
\end{verbatim}
\item
  Use the
  \href{@app-ref@/collaboration/latest/taglibdocs/liferay-flags/flags.html}{\texttt{liferay-flags:flags}
  tag} to add the flags component:

\begin{verbatim}
<liferay-flags:flags
    className="<%= Entry.class.getName() %>"
    classPK="<%= entry.getEntryId() %>"
    contentTitle="<%= title %>"
    message="flag-this-content"
    reportedUserId="<%= reportedUserId %>"
/>
\end{verbatim}

  The \texttt{reportedUserId} attribute specifies the user who flagged
  the asset.
\end{enumerate}

Great! Now you know how to let users flag content in your asset-enabled
portlets.

\subsection{Related Topics}\label{related-topics-151}

\href{/docs/7-0/tutorials/-/knowledge_base/t/adding-comments-to-your-app}{Adding
Comments to Your App}

\href{/docs/7-0/tutorials/-/knowledge_base/t/applying-social-bookmarks}{Applying
Social Bookmarks}

\chapter{Item Selector}\label{item-selector}

People's tasks often involve making choices: which shirt to wear, what
to eat for breakfast, or what profile picture to use. The power of
choice is a terrific privilege, but the means by which a person makes
his/her selection can make an experience good or bad. Here are some
factors that influence the experience:

\begin{itemize}
\tightlist
\item
  Item organization
\item
  Consistency
\item
  UI intuitiveness
\end{itemize}

Liferay DXP's Item Selector provides all these things. It is a UI
component that enables users to select entities in a consistent
easy-to-use manner. Many Liferay portlets, such as Documents and Media,
Web Content, Blogs and more, use Item Selectors for selecting things
such as images, videos, audio files, documents, and pages.

\begin{figure}
\centering
\includegraphics{./images/item-selector-dialog-02.png}
\caption{Item Selectors let users browse and select different kinds of
entities.}
\end{figure}

The Item Selector API provides a framework for developers to use and
extend Item Selectors. They can add Item Selectors to their apps,
customize Liferay DXP's Item Selectors, and create Item Selectors to
select any kind of entity.

\emph{Selection views} are the framework's key components. In an Item
Selector, selection views show entities of particular types from
different sources.

For example, an Item Selector configured to show images might show
selection views from the following sources:

\begin{itemize}
\tightlist
\item
  Documents and Media
\item
  Third-party image provider
\item
  Drag-and-drop interface
\end{itemize}

Here are some different Item Selector use cases:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Enabling your application to select Liferay DXP entities such as
  sites, pages, or documents from Documents and Media.
\item
  Customizing a selection experience by adding a new selection view for
  an entity (e.g., a view of images from an external image repository).
\item
  Creating new selectable entities for other applications to use in
  their Item Selectors.
\end{enumerate}

This group of tutorials demonstrates how to satisfy these use cases.

\section{Selecting Entities Using the Item
Selector}\label{selecting-entities-using-the-item-selector}

The Item Selector allows users to select entities, such as images,
videos, documents, and sites.

\begin{figure}
\centering
\includegraphics{./images/item-selector-dialog-01.png}
\caption{The Item Selector makes selecting entities a breeze.}
\end{figure}

Here's what's required to use an Item Selector:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{Determine Item Criteria}
\item
  \textbf{Get an Item Selector for the Criteria}
\item
  \textbf{Use an Item Selector Dialog}
\end{enumerate}

\subsection{Determining Item Selector
Criteria}\label{determining-item-selector-criteria}

The first step is determining entity types to select from the Item
Selector and the data you expect from them. What kind of entity do you
want to select? Do you want to select a user, an image, a video, or
something else?

Once you know the entities you want, you need \emph{criterion} classes
to represent them in the Item Selector. Criterion classes must implement
the
\href{@app-ref@/collaboration/latest/javadocs/com/liferay/item/selector/ItemSelectorCriterion.html}{\texttt{ItemSelectorCriterion}
interface}. The
\href{/docs/7-0/reference/-/knowledge_base/r/item-selector-criterion-and-return-types}{Item
Selector Criterion and Return Types} reference lists criterion classes
Liferay's apps and app suites provide.

If there's no criterion class for your entity, you can create your own
\href{@app-ref@/collaboration/latest/javadocs/com/liferay/item/selector/ItemSelectorCriterion.html}{\texttt{ItemSelectorCriterion}
class} (tutorial coming soon).

Then determine the type of information (return type) you expect from the
entities when users select them. Do you expect a URL? A Universally
Unique Identifier (UUID)? A primary key? Each return type must be
represented by an implementation of the
\href{@app-ref@/collaboration/latest/javadocs/com/liferay/item/selector/ItemSelectorReturnType.html}{\texttt{ItemSelectorReturnType}
class}. The
\href{/docs/7-0/reference/-/knowledge_base/r/item-selector-criterion-and-return-types}{Item
Selector Criterion and Return Types} reference also lists return type
classes Liferay's apps and app suites provide.

If there's no return type class that meets your needs, you can implement
your own
\href{@app-ref@/collaboration/latest/javadocs/com/liferay/item/selector/ItemSelectorReturnType.html}{\texttt{ItemSelectorReturnType}
class} (tutorial coming soon).

\noindent\hrulefill

\textbf{Note}: Each criterion must have at least one
\texttt{ItemSelectorReturnType} (return type) associated with it.

\noindent\hrulefill

For example, if you want to allow users to select an image and want the
image's URL returned, you could use the
\texttt{ImageItemSelectorCriterion} criterion class and the
\texttt{URLItemSelectorReturnType} return type.

The criterion and return types are collectively referred to as the Item
Selector's \emph{criteria}. The Item Selector uses it to decide which
selection views (tabs of items) to show.

Once you've defined your criteria, you can get an Item Selector to use
with it.

\subsection{Getting an Item Selector for the
Criteria}\label{getting-an-item-selector-for-the-criteria}

In order to use an Item Selector with your criteria, you must get an
Item Selector URL based on the criteria. The URL is needed to open the
Item Selector dialog in your UI. In Java, you build the criteria and
pass it in a call to get the Item Selector's URL.

First, get an Item Selector OSGi Service Component using Declarative
Services.

\begin{verbatim}
import com.liferay.item.selector.ItemSelector;
import org.osgi.service.component.annotations.Reference;

@Reference
private ItemSelector _itemSelector
\end{verbatim}

The component annotations are available in the
\href{http://mvnrepository.com/artifact/org.osgi/org.osgi.service.component.annotations}{\texttt{org.osgi.service.component.annotations}
module}.

To get a URL to the Item Selector, you must call its
\href{@app-ref@/collaboration/latest/javadocs/com/liferay/item/selector/ItemSelector.html\#getItemSelectorURL-com.liferay.portal.kernel.portlet.RequestBackedPortletURLFactory-java.lang.String-com.liferay.item.selector.ItemSelectorCriterion...-}{\texttt{getItemSelectorURL}
method} using the following parameters:

\begin{itemize}
\tightlist
\item
  \texttt{RequestBackedPortletURLFactory}: Factory that creates portlet
  URLs.
\item
  \texttt{ItemSelectedEventName}: Unique arbitrary JavaScript event name
  that is triggered by the Item Selector when the element is selected.
\item
  \texttt{ItemSelectorCriterion}: Criterion (or an array of criterion
  objects) that specifies the type of elements to make available in the
  Item Selector.
\end{itemize}

The following code demonstrates getting a URL to an Item Selector
configured with criteria for images:

\begin{verbatim}
RequestBackedPortletURLFactory requestBackedPortletURLFactory =
    RequestBackedPortletURLFactoryUtil.create(request);

List<ItemSelectorReturnType> desiredItemSelectorReturnTypes =
    new ArrayList<>();
desiredItemSelectorReturnTypes.add(new URLItemSelectorReturnType());

ImageItemSelectorCriterion imageItemSelectorCriterion =
    new ImageItemSelectorCriterion();

imageItemSelectorCriterion.setDesiredItemSelectorReturnTypes(
    desiredItemSelectorReturnTypes);

PortletURL itemSelectorURL = _itemSelector.getItemSelectorURL(
    requestBackedPortletURLFactory, "sampleTestSelectItem",
    imageItemSelectorCriterion);
\end{verbatim}

First it gets a factory to create the URL by invoking the
\texttt{RequestBackedPortletURLFactoryUtil.create} method, passing it
the current request object. The request can be an
\texttt{HttpServletRequest} or \texttt{PortletRequest}.

Then it creates a list of return types expected for the image entity and
a criterion for images. The return types list consists of a URL return
type \texttt{URLItemSelectorReturnType}. The list is passed to the
criterion's \texttt{setDesiredItemSelectorReturnTypes} method.

Lastly the method \texttt{getItemSelectorURL} is called to return a URL
based on the criteria. The method requires a URL factory, an arbitrary
event name, and a series of criterion (one, in this case).

\noindent\hrulefill

\textbf{Note}: You can invoke the URL object's \texttt{toString} method
to get its value.

\noindent\hrulefill

An Item Selector can be configured to use any number of criterion. The
criterion can use any number of return types.

The Item Selector's criterion order determines the selection view order.
For example, if you pass the item selector criteria in this order:
\texttt{ImageItemSelectorCriterion},
\texttt{VideoItemSelectorCriterion}, the Item Selector displays the
image selection views first and then the ones for videos. If you reverse
the order, it shows the video selection views first and the image
selection views second.

Return type order is also significant. A view uses the first return type
it supports from each criterion's return type list.

Now that you've got a URL to the Item Selector you've configured, you
can start using the Item Selector in your UI.

\subsection{Using the Item Selector
Dialog}\label{using-the-item-selector-dialog}

To open the Item Selector in your UI, you must use the
\texttt{LiferayItemSelectorDialog} JavaScript component from
\href{http://alloyui.com/}{AlloyUI's}
\texttt{liferay-item-selector-dialog} module. The component listens for
the item selected event that you specified for the Item Selector URL.
The event returns the selected element's information according to its
return type.

Here are the steps for using the Item Selector dialog in a JSP:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Declare the AUI tag library.

\begin{verbatim}
<%@ taglib prefix="aui" uri="http://liferay.com/tld/aui" %>
\end{verbatim}
\item
  Add the \texttt{\textless{}aui:script\textgreater{}} tag and configure
  it to use the \texttt{liferay-item-selector-dialog} module:

\begin{verbatim}
<aui:script use="liferay-item-selector-dialog">

</aui:script>
\end{verbatim}
\item
  Attach an event handler to the UI element you want to use to open the
  Item Selector dialog.

  For example, the configuration below creates a \emph{Choose} button
  with the ID \texttt{chooseImage} with a click event and function
  attached.

\begin{verbatim}
<aui:button name="chooseImage" value="Choose" />

<aui:script use="liferay-item-selector-dialog">

    $('#<portlet:namespace />chooseImage').on(
    'click',
      function(event) {
        <!-- function logic goes here -->
      }
    );

</aui:script>
\end{verbatim}
\item
  Inside the function, you must create a new instance of the
  \texttt{LiferayItemSelectorDialog} AlloyUI Component and configure it
  to use the Item Selector. Here's what you need to do in the function:

  \begin{itemize}
  \tightlist
  \item
    Set the function's \texttt{eventName} attribute to the item selected
    event name you specified in your Java code (the code that gets the
    Item Selector URL).
  \item
    For the \texttt{on} attribute, implement a function that operates on
    the selected item change. The example code below demonstrates this.
  \item
    Set the function's \texttt{title} attribute. This becomes the
    dialog's title.
  \item
    Set the function's \texttt{url} attribute to the Item Selector URL
    you obtained earlier.
  \item
    Call the dialog's \texttt{open} method.
  \end{itemize}
\end{enumerate}

The example code below and steps that follow show how to configure an
Item Selector dialog to work with selected items.

\begin{verbatim}
<aui:button name="chooseImage" value="Choose" />

<%
String itemSelectorURL = GetterUtil.getString(request.getAttribute("itemSelectorURL"));
%>

<aui:script use="liferay-item-selector-dialog">

    $('#<portlet:namespace />chooseImage').on(
        'click', 
        function(event) {
            var itemSelectorDialog = new A.LiferayItemSelectorDialog(  
                {
                    eventName: 'ItemSelectedEventName',
                    on: {
                            selectedItemChange: function(event) {
                                var selectedItem = event.newVal;

                                if (selectedItem) {
                                    var itemValue = JSON.parse(
                                    selectedItem.value
                                    );
                                    itemSrc = itemValue.url;

                                    <!-- use item as needed -->
                                }
                            }
                    },
                    title: '<liferay-ui:message key="select-image" />',
                    url: '<%= itemSelectorURL.toString() %>'
                }
            );
            itemSelectorDialog.open();
        }
    );
</aui:script>
\end{verbatim}

Here's what the code does:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  This line creates a new instance of the Liferay Item Selector dialog:

\begin{verbatim}
var itemSelectorDialog = new A.LiferayItemSelectorDialog(...)
\end{verbatim}
\item
  The constructor sets the \texttt{eventName} attribute. This makes the
  dialog listen for the item selected event. The event name is the same
  as the one specified for the Item Selector URL generated earlier in
  the Java code.
\item
  When the user selects a new item, the \texttt{selectedItemChange}
  function fires, setting its variables for the newly selected item. The
  information available to parse depends on the return type(s) that were
  set.
\item
  As the comment indicates, the developer adds logic for using the
  selected element here.
\item
  The \texttt{LiferayItemSelectorDialog}'s \texttt{title} attribute sets
  the dialog's title.
\item
  The Item Selector URL retrieved previously in the Java code becomes
  the \texttt{url} attribute's value.
\item
  The \texttt{open} method opens the Item Selector dialog.
\end{enumerate}

When the user clicks the \emph{Choose} button, a new dialog opens,
rendering the Item Selector with the views that support the criterion
and return type(s) that were set.

Adding an Item Selector to your app is as easy as what's been
demonstrated! It involves specifying criteria for the selectable items,
applying them to an Item Selector, and configuring an Item Selector
dialog to operate on the selected item. Using Item Selector API, you can
give app users the power of choice!

\subsection{Related Articles}\label{related-articles-3}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-custom-item-selector-views}{Creating
Custom Item Selector Views}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-custom-item-selector-entities}{Creating
Custom Item Selector Entities}

\href{/docs/7-0/tutorials/-/knowledge_base/t/front-end-taglibs}{Front-End
Taglibs}

\section{Creating Custom Item Selector
Entities}\label{creating-custom-item-selector-entities}

Does your app require users to select an item that the Item Selector
isn't configured for? No problem. You can create a new entity.

This tutorial explains how to create a new entity for the Item Selector.

\subsection{Creating Item Selector
Criterion}\label{creating-item-selector-criterion}

First, you must create a new criterion for your entity. Follow these
steps to create an Item Selector criterion:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a class that extends the
  \href{@app-ref@/collaboration/latest/javadocs/com/liferay/item/selector/BaseItemSelectorCriterion.html}{\texttt{BaseItemSelectorCriterion}
  class}.

  The example below creates a class called
  \texttt{TaskItemSelectorCriterion}:

\begin{verbatim}
public class TasksItemSelectorCriterion extends 
BaseItemSelectorCriterion {

}
\end{verbatim}

  This class specifies what kind of entity the user is selecting and
  what information the Item Selector should return. The methods
  inherited from the \texttt{BaseItemSelectorCriterion} class provide
  the logic for obtaining this information:

\begin{verbatim}
public abstract class BaseItemSelectorCriterion
        implements ItemSelectorCriterion {

        @Override
        public List<ItemSelectorReturnType> getDesiredItemSelectorReturnTypes() {
                return _desiredItemSelectorReturnTypes;
        }

        @Override
        public void setDesiredItemSelectorReturnTypes(
                List<ItemSelectorReturnType> desiredItemSelectorReturnTypes) {

                _desiredItemSelectorReturnTypes = desiredItemSelectorReturnTypes;
        }

        private List<ItemSelectorReturnType> _desiredItemSelectorReturnTypes;

}
\end{verbatim}

  Note that you can use this class to pass information to the view if
  needed. For example, the
  \href{@app-ref@/web-experience/latest/javadocs/com/liferay/journal/item/selector/criterion/JournalItemSelectorCriterion.html}{\texttt{JournalItemSelectorCriterion}
  class} passes information about the primary key so the view can use
  it:

\begin{verbatim}
public class JournalItemSelectorCriterion extends 
BaseItemSelectorCriterion {

        public JournalItemSelectorCriterion() {
        }

        public JournalItemSelectorCriterion(long resourcePrimKey) {
                _resourcePrimKey = resourcePrimKey;
        }

        public long getResourcePrimKey() {
                return _resourcePrimKey;
        }

        public void setResourcePrimKey(long resourcePrimKey) {
                _resourcePrimKey = resourcePrimKey;
        }

        private long _resourcePrimKey;

}
\end{verbatim}
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** Criterion fields should be serializable and should expose a
 public empty constructor (as shown above).
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\item
  Create an OSGi component class that implements the
  \href{@app-ref@/collaboration/latest/javadocs/com/liferay/item/selector/BaseItemSelectorCriterionHandler.html}{\texttt{BaseItemSelectorCriterionHandler}
  class}. Each criterion requires a criterion handler, which is
  responsible for obtaining the proper selection view.

  The example below creates a criterion handler for the
  \texttt{TaskItemSelectorCriterion} class:

\begin{verbatim}
@Component(service = ItemSelectorCriterionHandler.class)
public class TaskItemSelectorCriterionHandler extends 
BaseItemSelectorCriterionHandler<TaskItemSelectorCriterion> {

    public Class <TaskItemSelectorCriterion> 
    getItemSelectorCriterionClass() {
        return TasksItemSelectorCriterionHandler.class;
    }

    @Activate
    @Override
    protected void activate(BundleContext bundleContext) {
            super.activate(bundleContext);
    }

}
\end{verbatim}

  The \texttt{@Activate} and \texttt{@Override} tokens are required to
  activate this OSGi component.
\end{enumerate}

Depending on the needs of your app, you may not need to create a return
type. If your entity returns information that is already defined by an
existing return type, you can use that return type instead.

You can view the default available criteria in the
\href{/docs/7-0/reference/-/knowledge_base/r/item-selector-criterion-and-return-types}{Item
Selector Criterion and Return Types} reference.

If, however, your entity returns information that is not covered by an
existing return type, you'll need to create a new return type next.

\subsection{Creating Item Selector Return
Types}\label{creating-item-selector-return-types}

To create a return type, you must create a class that implements the
\href{@app-ref@/collaboration/latest/javadocs/com/liferay/item/selector/ItemSelectorReturnType.html}{\texttt{ItemSelectorReturnType}
class}.

The example below creates a new return type called
\texttt{TaskItemSelectorReturnType}:

\begin{verbatim}
/**
* This return type should return the task ID and the user who
* created the task as a string.
*
* @author Joe Bloggs
*/
public class TaskItemSelectorReturnType implements ItemSelectorReturnType{

}
\end{verbatim}

The \texttt{*ItemSelectorReturnType} class is used as an identifier by
the Item Selector and does not return any information itself. You should
determine the information you expect returned (an ID, a URL, a more
complex object, etc.), and create a return type to handle that
information. The return type class is an API that connects the return
type to the Item Selector views. \textbf{Whenever the return type is
used, the view must ensure that the proper information is returned.}
It's recommended that you specify the information that the return type
returns, as well as the format, as Javadoc (as shown in the
\texttt{TaskItemSelectorReturnType} example above).

So far, you've created an API that you can use to create a selection
view for your new entity. The entity's criterion and return type classes
are used by your application to create the Item Selector URL. You can
follow the
\href{/docs/7-0/tutorials/-/knowledge_base/t/selecting-entities-using-the-item-selector}{Selecting
Entities using the Item Selector} tutorial to learn how to obtain the
Item Selector URL.

\textbf{The selection view is responsible for returning the proper
entity information specified by the return type.} Currently there isn't
a selection view to select your entity. Follow the
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-custom-item-selector-views}{Creating
Custom Item Selector Views} tutorial to learn how to create your new
view.

Now you know how to create an entity for the Item Selector!

\subsection{Related Topics}\label{related-topics-152}

\href{/docs/7-0/tutorials/-/knowledge_base/t/selecting-entities-using-the-item-selector}{Selecting
Entities using the Item Selector}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-custom-item-selector-views}{Creating
Custom Item Selector Views}

\section{Creating Custom Item Selector
Views}\label{creating-custom-item-selector-views}

Have you found you need to create a new selection view for your app? No
problem. Item Selector views are determined by the type of entity the
user is selecting. The Item Selector can render multiple views for the
same entity type. For example, when a user requires an image from the
Item Selector, the selection views shown below are rendered:

\begin{figure}
\centering
\includegraphics{./images/item-selector-tabs.png}
\caption{An entity type can have multiple selection views.}
\end{figure}

Each tab: \emph{Blog Images}, \emph{Documents and Media}, \emph{URL},
and \emph{Upload Image}, is a selection view for the Item Selector, each
one represented by an \texttt{*ItemSelectorCriterion} class. The tabs in
figure 1 are represented by the following
\texttt{*ItemSelectorCriterion}:

\begin{itemize}
\tightlist
\item
  \href{@app-ref@/collaboration/latest/javadocs/com/liferay/blogs/item/selector/criterion/BlogsItemSelectorCriterion.html}{\texttt{BlogsItemSelectorCriterion}
  class}: Blog Images View
\item
  \href{@app-ref@/collaboration/latest/javadocs/com/liferay/item/selector/criteria/image/criterion/ImageItemSelectorCriterion.html}{\texttt{ImageItemSelectorCriterion}
  class}: Documents and Media View
\item
  \href{@app-ref@/collaboration/latest/javadocs/com/liferay/item/selector/criteria/url/criterion/URLItemSelectorCriterion.html}{\texttt{URLItemSelectorCriterion}
  class}: URL View
\item
  \href{@app-ref@/collaboration/latest/javadocs/com/liferay/item/selector/criteria/upload/criterion/UploadItemSelectorCriterion.html}{\texttt{UploadItemSelectorCriterion}
  class}: Upload Image View
\end{itemize}

The default selection views may provide everything you need for your
application. If, however, your application requires a custom selection
view, for instance to link to an external image provider, you can follow
the steps outlined in this tutorial.

This tutorial covers how to create new selection views for the Item
Selector.

Get started by configuring the module for your view next.

\subsection{Configuring the Module}\label{configuring-the-module}

Follow these steps to prepare your module:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add these dependencies to your module's \texttt{build.gradle}:

\begin{verbatim}
dependencies {
        compileOnly group: "com.liferay", name: "com.liferay.item.selector.api", version: "2.0.0"
        compileOnly group: "com.liferay", name: "com.liferay.item.selector.criteria.api", version: "2.0.0"
        compileOnly group: "com.liferay.portal", name: "com.liferay.portal.impl", version: "2.0.0"
        compileOnly group: "com.liferay.portal", name: "com.liferay.portal.kernel", version: "2.0.0"
        compileOnly group: "com.liferay.portal", name: "com.liferay.util.taglib", version: "2.0.0"
        compileOnly group: "javax.portlet", name: "portlet-api", version: "2.0"
        compileOnly group: "javax.servlet", name: "javax.servlet-api", version: "3.0.1"
        compileOnly group: "org.osgi", name: "org.osgi.service.component.annotations", version: "1.3.0"
}
\end{verbatim}
\item
  Add your module's information to the \texttt{bnd.bnd} file. For
  example, the configuration below adds the information for a module
  called \texttt{My\ Custom\ \ \ \ \ \ View}.

\begin{verbatim}
Bundle-Name: My Custom View
Bundle-SymbolicName: com.liferay.docs.my.custom.view
Bundle-Version: 1.0.0
\end{verbatim}
\item
  Add a \texttt{Web-ContextPath} to your \texttt{bnd.bnd} to point to
  the resources for your module. For example:

\begin{verbatim}
Include-Resource:\
        META-INF/resources=src/main/resources/META-INF/resources
Web-ContextPath: /my-custom-view
\end{verbatim}

  If you don't have a \texttt{Web-ContextPath} your module won't know
  where your resources are. The \texttt{Include-Resource} header points
  to the relative path for the module's resources.
\end{enumerate}

Now that your module is configured, you can create the view next.

\subsection{Implementing the View}\label{implementing-the-view}

To create a new view you must first know what kind of entities you want
to select in the new view: images, videos, users, etc. The kind of
entities you choose determines the specific
\texttt{ItemSelectorCriterion} you need to use. For example if you were
selecting images, you must use the \texttt{ImageItemSelectorCriterion}.

Next, you need to know the type of information the entity can return
when it's selected. For example, if the entity returns its URL, you
would use \texttt{URLItemSelectorReturnType} for the return type.

For a full list of the available criterion and returns types that
Liferay's apps and app suite's provide see the
\href{/docs/7-0/reference/-/knowledge_base/r/item-selector-criterion-and-return-types}{Item
Selector Criterion and Return Types} reference.

Once you've determined the kinds of entities you wish to select, follow
these steps to create your selection view:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create an Item Selector View Component class:

\begin{verbatim}
@Component(
    property = {"item.selector.view.order:Integer=200"},
    service = ItemSelectorView.class
)
\end{verbatim}

  Note that the OSGi component is registered with the property
  \texttt{item.selector.view.order}. The Item Selector view order (the
  order of the rendered tab views) is prioritized according to these
  settings:

  \begin{itemize}
  \item
    The criteria order specified in the
    \href{@app-ref@/collaboration/latest/javadocs/com/liferay/item/selector/ItemSelector.html\#getItemSelectorURL-com.liferay.portal.kernel.portlet.RequestBackedPortletURLFactory-java.lang.String-com.liferay.item.selector.ItemSelectorCriterion...-}{\texttt{getItemSelectorURL}
    method} of the application.
  \item
    The \texttt{item.selector.view.order} property's value for multiple
    views with the same criteria. The lower the value is, the more
    priority it has, and the sooner it will appear in the order.
  \end{itemize}
\item
  Implement the
  \href{@app-ref@/collaboration/latest/javadocs/com/liferay/item/selector/ItemSelectorView.html}{\texttt{ItemSelectorView}
  interface} using the \emph{criterion} the view requires. For example,
  the configuration below uses the
  \href{@app-ref@/collaboration/latest/javadocs/com/liferay/item/selector/criteria/image/criterion/ImageItemSelectorCriterion.html}{\texttt{ImageItemSelectorCriterion}
  class} to implement the view:

\begin{verbatim}
public class SampleItemSelectorView
    implements ItemSelectorView<ImageItemSelectorCriterion> {

    @Override
    public Class<ImageItemSelectorCriterion> getItemSelectorCriterionClass() 
    {
        return ImageItemSelectorCriterion.class;
    }

    @Override            
    public ServletContext getServletContext() {
        return _servletContext;
    }

    @Override            
    public List<ItemSelectorReturnType> getSupportedItemSelectorReturnTypes() {
        return _supportedItemSelectorReturnTypes;
    }

}
\end{verbatim}

  The implementation above also sets up some methods you'll use in the
  steps that follow. The
  \href{@app-ref@/collaboration/latest/javadocs/com/liferay/item/selector/ItemSelectorView.html\#getSupportedItemSelectorReturnTypes--}{\texttt{getSupportedItemSelectorReturnTypes}
  method} returns a list of \emph{ItemSelectorReturnType}s. You'll
  populate this list in a later step to specify the return types the
  selection view supports.
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** If you want your new selection view to be available only when
 selecting the entity for something specific such as a blog entry, replace
 the `*ItemSelectorCriterion` in your `*ItemSelectorView` class with the
 `*ItemSelectorCriterion` class you wish to use, such as the
 [`BlogsItemSelectorCriterion` class](@app-ref@/collaboration/latest/javadocs/com/liferay/blogs/item/selector/criterion/BlogsItemSelectorCriterion.html).
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\item
  Configure the title, search options, and visibility settings for the
  selection view:

  An example configuration is shown below for a selection view called
  \texttt{Sample\ Selector}:

\begin{verbatim}
@Override
public String getTitle(Locale locale) {
    return "Sample Selector";
}

@Override
public boolean isShowSearch() {
    return false;
}

@Override
public boolean isVisible(ThemeDisplay themeDisplay) {
    return true;
}
\end{verbatim}

  The following methods are demonstrated above:

  \begin{itemize}
  \item
    \href{@app-ref@/collaboration/latest/javadocs/com/liferay/item/selector/ItemSelectorView.html\#getTitle-java.util.Locale-}{\texttt{getTitle}
    method}: returns the localized title of the tab to display in the
    Item Selector dialog.
  \item
    \href{@app-ref@/collaboration/latest/javadocs/com/liferay/item/selector/ItemSelectorView.html\#isShowSearch--}{\texttt{isShowSearch()}
    method}: returns whether the Item Selector view should show the
    search field.
  \end{itemize}
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** To implement search, return `true` for this method. The
 `renderHTML` method, covered in the next section, indicates whether a user
 performed a search based on the value of the `search` parameter. Then the
 keywords the user searched can be obtained as follows:
 
     String keywords = ParamUtil.getString(request, "keywords");
\end{verbatim}

\noindent\hrulefill

\begin{verbatim}
- [`isVisible()` method](@app-ref@/collaboration/latest/javadocs/com/liferay/item/selector/ItemSelectorView.html#isVisible-com.liferay.portal.kernel.theme.ThemeDisplay-):
returns whether the Item Selector view is visible. In most cases, you'll 
want to set this to `true`. You can use this method to add conditional logic 
to disable the view.
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{3}
\item
  Next, set the render settings for your view, using the
  \href{@app-ref@/collaboration/latest/javadocs/com/liferay/item/selector/ItemSelectorView.html\#renderHTML-javax.servlet.ServletRequest-javax.servlet.ServletResponse-T-javax.portlet.PortletURL-java.lang.String-boolean-}{\texttt{renderHTML}
  method}. The example below points to a JSP file to render the view:

\begin{verbatim}
@Override
public void renderHTML(
    ServletRequest request, ServletResponse response,
    ImageItemSelectorCriterion itemSelectorCriterion,
    PortletURL portletURL, String itemSelectedEventName,
    boolean search
)
throws IOException, ServletException {

    request.setAttribute(_ITEM_SELECTED_EVENT_NAME,
    itemSelectedEventName);

    ServletContext servletContext = getServletContext();

    RequestDispatcher requestDispatcher =
    servletContext.getRequestDispatcher("/sample.jsp");

    requestDispatcher.include(request, response);
}
\end{verbatim}

  The \texttt{renderHTML} methods passes the
  \texttt{*ItemSelectorCriterion} required to display the selection
  view. Next, the \texttt{portletURL}, used to invoke the Item Selector,
  is passed. Then the \texttt{itemSelectedEventName} is passed. This is
  the event name that the caller listens for. When an element is
  selected, the view fires a JavaScript event with this name. Finally, a
  search boolean is passed, specifying when the view should render
  search results. When the user performs a search, this boolean should
  be set to \texttt{true}.

  Note that the \texttt{itemSelectedEventName} is passed as a request
  attribute, so it can be used in the view markup.

  The view markup is specified this way:

\begin{verbatim}
RequestDispatcher requestDispatcher =
        servletContext.getRequestDispatcher("/sample.jsp");
\end{verbatim}

  Although the example uses JSPs, you can use another language such as
  FreeMarker to render the markup.
\item
  Use the \texttt{@Reference} annotation to reference your module's
  class for the \texttt{setServletContext} method.

  Below is an example configuration:

\begin{verbatim}
@Reference(
    target =
    "(osgi.web.symbolicname=com.liferay.item.selector.sample.web)",
    unbind = "-"
)
\end{verbatim}

  public void setServletContext(ServletContext servletContext) \{
  \_servletContext = servletContext; \}

  The \texttt{target} parameter is used to specify the available
  services for the servlet context. In this case, it specifies the
  \texttt{com.liferay.selector.sample.web} class as the default value,
  using the \texttt{osgi.web.symbolicname} property. Finally, the
  \texttt{unbind\ =\ \_} parameter specifies that there is no unbind
  method for this module. A method is defined to set the servlet context
  as well.
\item
  Finally, populate the \texttt{\_supportedItemSelectorReturnTypes} list
  specified in step 2 with the return types that this view supports.

  The example below adds the
  \href{@app-ref@/collaboration/latest/javadocs/com/liferay/item/selector/criteria/URLItemSelectorReturnType.html}{\texttt{URLItemSelectorReturnType}
  class} and
  \href{@app-ref@/collaboration/latest/javadocs/com/liferay/item/selector/criteria/FileEntryItemSelectorReturnType.html}{\texttt{FileEntryItemSelectorReturnType}
  class} to the list of supported return types, but you could use more
  return types if the view could return them. More return types means
  that the view is more reusable:

\begin{verbatim}
private static final List<ItemSelectorReturnType>
    _supportedItemSelectorReturnTypes =
    Collections.unmodifiableList(
        ListUtil.fromArray(
            new ItemSelectorReturnType[] {
                new FileEntryItemSelectorReturnType(),
                new URLItemSelectorReturnType()
            }));

 private ServletContext _servletContext;
\end{verbatim}

  The servlet context variable is declared at the bottom of the file.
\end{enumerate}

As a complete example, below is the full code for the
\href{https://github.com/liferay/liferay-portal/blob/586f66c629b559e79c744559751ecb960218fe0b/modules/apps/collaboration/item-selector/item-selector-web/src/test/java/com/liferay/item/selector/web/internal/FlickrItemSelectorView.java}{\texttt{FlickrItemSelectorView}
class}:

\begin{verbatim}
public class FlickrItemSelectorView
        implements ItemSelectorView<FlickrItemSelectorCriterion> {

        @Override
        public Class<FlickrItemSelectorCriterion> getItemSelectorCriterionClass() {
                return FlickrItemSelectorCriterion.class;
        }

        @Override
        public List<ItemSelectorReturnType> getSupportedItemSelectorReturnTypes() {
                return _supportedItemSelectorReturnTypes;
        }

        @Override
        public String getTitle(Locale locale) {
                return FlickrItemSelectorView.class.getName();
        }

        @Override
        public boolean isShowSearch() {
                return false;
        }

        @Override
        public boolean isVisible(ThemeDisplay themeDisplay) {
                return true;
        }

        @Override
        public void renderHTML(
                        ServletRequest request, ServletResponse response,
                        FlickrItemSelectorCriterion flickrItemSelectorCriterion,
                        PortletURL portletURL, String itemSelectedEventName, 
                        boolean search)
                throws IOException {

                PrintWriter printWriter = response.getWriter();

                printWriter.print(
                        "<html>" + FlickrItemSelectorView.class.getName() + 
                        "</html>");
        }

        private static final List<ItemSelectorReturnType>
                _supportedItemSelectorReturnTypes = 
                Collections.unmodifiableList(
                        ListUtil.fromArray(
                                new ItemSelectorReturnType[] {
                                        new TestURLItemSelectorReturnType()
                                }));

}
\end{verbatim}

The diagram below illustrates how the Item Selector's API works
(right-click to view larger image):

\begin{figure}
\centering
\includegraphics{./images/item-selector-architecture.png}
\caption{Item Selector views are determined by the desired return types
of the criterion, the supported return types of the view, and the
criterion supported by the view.}
\end{figure}

Once you've implemented your Item Selector view, you must create the
view markup.

\subsection{Writing your View Markup}\label{writing-your-view-markup}

You've implemented your view, specifying the criteria and return types,
along with important configuration information, such as how to render
the view. All that's left is to write the markup for your selection
view.

Naturally, the markup for your selection view will vary greatly
depending on the requirements of your app. You can use taglibs, AUI
components, or even pure HTML and JavaScript if you prefer, to write
your view. Regardless of the approach you choose to create your view,
the view must do two key things:

\begin{itemize}
\tightlist
\item
  Render the entities for the user to select
\item
  Contain JavaScript logic that passes the information specified by the
  Item Selector return type via a JavaScript event when an entity is
  selected.
\end{itemize}

If you're following the example in the last section, the JavaScript
event name has been passed as a request attribute in the
\texttt{renderHTML} method of the \texttt{*ItemSelectorView} class, so
it can be used in the view markup as follows:

\begin{verbatim}
Liferay.fire(
        `<%= {ITEM_SELECTED_EVENT_NAME} %>',
        
        {
            data:{
                the-data-your-client-needs-according-to-the-return-type
            }
        }
);
\end{verbatim}

Below is the complete
\href{https://github.com/liferay/liferay-portal/blob/7.0.x/modules/apps/web-experience/layout/layout-item-selector-web/src/main/resources/META-INF/resources/layouts.jsp}{\texttt{Layouts.jsp}
view markup} for the
\href{https://github.com/liferay/liferay-portal/tree/7.0.x/modules/apps/web-experience/layout/layout-item-selector-web}{\texttt{com.liferay.layout.item.selector.web}
module}:

Some Java imports are defined first:

\begin{verbatim}
<%
LayoutItemSelectorViewDisplayContext layoutItemSelectorViewDisplayContext = 
(LayoutItemSelectorViewDisplayContext)request.getAttribute(
BaseLayoutsItemSelectorView.LAYOUT_ITEM_SELECTOR_VIEW_DISPLAY_CONTEXT);

LayoutItemSelectorCriterion layoutItemSelectorCriterion = 
layoutItemSelectorViewDisplayContext.getLayoutItemSelectorCriterion();

Portlet portlet = PortletLocalServiceUtil.getPortletById(
company.getCompanyId(), portletDisplay.getId());
%>
\end{verbatim}

Note that the \texttt{LayoutItemSelectorViewDisplayContext} is an
optional class that contains additional information about the criteria
and view, but it isn't required.

The snippet below imports a CSS file for styling and places it in the
\texttt{\textless{}head\textgreater{}} of the page:

\begin{verbatim}
<liferay-util:html-top>
        <link href="<%= PortalUtil.getStaticResourceURL(
        request, application.getContextPath() + "/css/main.css", 
        portlet.getTimestamp()) 
        %>" rel="stylesheet" type="text/css" />
</liferay-util:html-top>
\end{verbatim}

You can learn more about using the \texttt{liferay-util} taglibs in the
\href{/docs/7-0/tutorials/-/knowledge_base/t/using-the-liferay-util-taglib}{Using
the Liferay Util Taglib} tutorial.

This snippet creates the UI to display the layout entities. It uses the
\href{@platform-ref@/7.0-latest/taglibs/modules/apps/web-experience/layout/com.liferay.layout.taglib/liferay-layout/layouts-tree.html}{\texttt{liferay-layout:layouts-tree}
taglib} along with the \href{https://liferay.github.io/clay/}{Lexicon}
design language to create
\href{https://liferay.github.io/clay/content/cards/}{cards}:

\begin{verbatim}
<div class="container-fluid-1280 layouts-selector">
        <div class="card-horizontal main-content-card">
                <div class="card-row card-row-padded">
                        <liferay-layout:layouts-tree
                                checkContentDisplayPage="<%= layoutItemSelectorCriterion.isCheckDisplayPage() %>"
                                draggableTree="<%= false %>"
                                expandFirstNode="<%= true %>"
                                groupId="<%= scopeGroupId %>"
                                portletURL="<%= layoutItemSelectorViewDisplayContext.getEditLayoutURL() %>"
                                privateLayout="<%= layoutItemSelectorViewDisplayContext.isPrivateLayout() %>"
                                rootNodeName="<%= layoutItemSelectorViewDisplayContext.getRootNodeName() %>"
                                saveState="<%= false %>"
                                selectedLayoutIds="<%= layoutItemSelectorViewDisplayContext.getSelectedLayoutIds() %>"
                                selPlid="<%= layoutItemSelectorViewDisplayContext.getSelPlid() %>"
                                treeId="treeContainer"
                        />
                </div>
        </div>
</div>
\end{verbatim}

The configuration above renders the UI shown in the figure below:

\begin{figure}
\centering
\includegraphics{./images/layouts-item-selector-view.png}
\caption{The Layouts Item Selector view uses Lexicon and Liferay Layout
taglibs to create the UI.}
\end{figure}

This portion of the \texttt{aui:script} returns the path for the page:

\begin{verbatim}
<aui:script use="aui-base">
        var LString = A.Lang.String;

        var getChosenPagePath = function(node) {
                var buffer = [];

                if (A.instanceOf(node, A.TreeNode)) {
                        var labelText = LString.escapeHTML(node.get('labelEl').text());

                        buffer.push(labelText);

                        node.eachParent(
                                function(treeNode) {
                                        var labelEl = treeNode.get('labelEl');

                                        if (labelEl) {
                                                labelText = LString.escapeHTML(labelEl.text());

                                                buffer.unshift(labelText);
                                        }
                                }
                        );
                }

                return buffer.join(' > ');
        };
\end{verbatim}

The snippet below passes the return type data when the layout(entity) is
selected. In particular, take note of the \texttt{url} and \texttt{uuid}
variables, which retrieve the URL or UUID for the layout:

\begin{verbatim}
        var setSelectedPage = function(event) {
                var disabled = true;

                var messageText = '<%= UnicodeLanguageUtil.get(request, "there-is-no-selected-page") %>';

                var lastSelectedNode = event.newVal;

                var labelEl = lastSelectedNode.get('labelEl');

                var link = labelEl.one('a');

                var url = link.attr('data-url');
                var uuid = link.attr('data-uuid');

                var data = {};

                if (link && url) {
                        disabled = false;

                        data.layoutpath = getChosenPagePath(lastSelectedNode);
\end{verbatim}

This checks if the return type information is a URL or a UUID; then it
sets the value for the JSON object's \texttt{data} attribute
accordingly:

\begin{verbatim}
                        <c:choose>
                                <c:when test="<%= Objects.equals(layoutItemSelectorViewDisplayContext.getItemSelectorReturnTypeName(), URLItemSelectorReturnType.class.getName()) %>">
                                        data.value = url;
                                </c:when>
                                <c:when test="<%= Objects.equals(layoutItemSelectorViewDisplayContext.getItemSelectorReturnTypeName(), UUIDItemSelectorReturnType.class.getName()) %>">
                                        data.value = uuid;
                                </c:when>
                        </c:choose>
                }

                <c:if test="<%= Validator.isNotNull(layoutItemSelectorViewDisplayContext.getCkEditorFuncNum()) %>">
                        data.ckeditorfuncnum: <%= layoutItemSelectorViewDisplayContext.getCkEditorFuncNum() %>;
                </c:if>
\end{verbatim}

The \texttt{data-url} and \texttt{data-uuid} attributes are in the HTML
markup for the Layouts Item Selector. The HTML markup for an instance of
the Layouts Item Selector is shown below:

\begin{figure}
\centering
\includegraphics{./images/layouts-item-selector-html.png}
\caption{The URL and UUID can be seen in the \texttt{data-url} and
\texttt{data-uuid} attributes of the Layout Item Selector's HTML
markup.}
\end{figure}

The last line adds the \texttt{CKEditorFuncNum} for the editor to the
JSON object's \texttt{data} attribute.

The JavaScript trigger event, specified in the Item Selector return
type, is fired, passing the data JSON object with the required return
type information:

\begin{verbatim}
                Liferay.Util.getOpener().Liferay.fire(
                        '<%= layoutItemSelectorViewDisplayContext.getItemSelectedEventName() %>',
                        {
                                data: data
                        }
                );
        };
\end{verbatim}

Finally, the layout is set to the selected page:

\begin{verbatim}
        var container = A.one('#<portlet:namespace />treeContainerOutput');

        if (container) {
                container.swallowEvent('click', true);

                var tree = container.getData('tree-view');

                tree.after('lastSelectedChange', setSelectedPage);
        }
</aui:script>
\end{verbatim}

Your new selection view is automatically rendered by the Item Selector
in every portlet that uses the criterion and return types you defined,
without modifying anything in those portlets.

Now you know how to create custom views for the Item Selector!

\subsection{Related Topics}\label{related-topics-153}

\href{/docs/7-0/tutorials/-/knowledge_base/t/selecting-entities-using-the-item-selector}{Selecting
Entities Using the Item Selector}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-custom-item-selector-entities}{Creating
Custom Item Selector Entities}

\chapter{Adaptive Media}\label{adaptive-media}

The Adaptive Media app on
\href{https://web.liferay.com/marketplace}{Liferay Marketplace} lets
administrators tailor the quality of images in Liferay DXP to the device
viewing those images. For information on using this app, see
\href{/docs/7-0/user/-/knowledge_base/u/adapting-your-media-across-multiple-devices}{the
Adaptive Media user guide}.

But what if you want to leverage Adaptive Media in your own app? Then
you're in the right place! The tutorials in this section explain how to
use adapted images in your app. You'll also learn how to change Adaptive
Media's image processing.

Onwards!

\section{Displaying Adapted Images in Your
App}\label{displaying-adapted-images-in-your-app}

To display
\href{/docs/7-0/user/-/knowledge_base/u/adapting-your-media-across-multiple-devices}{adapted
images} in your apps, Adaptive Media offers a convenient taglib in
\href{https://github.com/liferay/com-liferay-adaptive-media/tree/master/adaptive-media-image-taglib}{the
module \texttt{com.liferay.adaptive.media.image.taglib}}. This taglib
only has one mandatory attribute: \texttt{fileVersion}. This attribute
indicates the file version of the adapted image that you want to
display. You can also add as many attributes as needed, such as
\texttt{class}, \texttt{style}, \texttt{data-sample}, and so on. Any
attributes you add are then added to the adapted images in the markup
the taglib renders.

This tutorial uses
\href{https://github.com/sergiogonzalez/adaptive-media-samples}{the
Adaptive Media Samples app} to show you how to use this taglib. When
added to a page, this app displays all the adapted images from the
current site's Documents and Media app, provided that
\href{/docs/7-0/user/-/knowledge_base/u/adding-image-resolutions}{Adaptive
Media image resolutions} and Documents and Media images exist.

Follow these steps to use the taglib:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Include the module taglib dependency in your project. If you're using
  Gradle, for example, you must add the following line in your project's
  \texttt{build.gradle} file:

\begin{verbatim}
provided group: "com.liferay", name: "com.liferay.adaptive.media.image.taglib", version: "1.0.0"
\end{verbatim}

  For example,
  \href{https://github.com/sergiogonzalez/adaptive-media-samples/blob/master/adaptive-media-sample-web/build.gradle}{the
  Adaptive Media Samples app's \texttt{build.gradle} file} contains this
  taglib.
\item
  Declare the taglib in your JSP:

\begin{verbatim}
<%@ taglib uri="http://liferay.com/tld/adaptive-media-image" prefix="liferay-adaptive-media" %>
\end{verbatim}

  For example,
  \href{https://github.com/sergiogonzalez/adaptive-media-samples/blob/master/adaptive-media-sample-web/src/main/resources/META-INF/resources/init.jsp}{the
  Adaptive Media Samples app's \texttt{init.jsp}} declares all the
  taglibs the app needs.
\item
  Use the taglib wherever you want the adapted image to appear in your
  app's JSP files:

\begin{verbatim}
<liferay-adaptive-media:img class="img-fluid" fileVersion="<%= fileEntry.getFileVersion() %>" />
\end{verbatim}

  For example,
  \href{https://github.com/sergiogonzalez/adaptive-media-samples/blob/master/adaptive-media-sample-web/src/main/resources/META-INF/resources/view.jsp}{the
  Adaptive Media Samples app's \texttt{view.jsp}} uses the taglib to
  display the adapted images in a grid with the \texttt{col-md-6}
  \href{/docs/7-0/tutorials/-/knowledge_base/t/creating-layout-templates-manually\#column-container}{column
  container class}. Looking at the markup the app generates, you can see
  that it uses the \texttt{\textless{}picture\textgreater{}} tag as
  described in the article
  \href{/docs/7-0/user/-/knowledge_base/u/creating-content-with-adaptive-media-images}{Creating
  Content with Adapted Images}.

  \begin{figure}
  \centering
  \includegraphics{./images/adaptive-media-sample.png}
  \caption{The Adaptive Media Samples app shows all the site's adapted
  images.}
  \end{figure}
\end{enumerate}

Well done! Now you know how to display adapted images in your app.

\subsection{Related Topics}\label{related-topics-154}

\href{/docs/7-0/tutorials/-/knowledge_base/t/finding-adapted-images}{Finding
Adapted Images}

\href{/docs/7-0/tutorials/-/knowledge_base/t/changing-adaptive-medias-image-scaling}{Changing
Adaptive Media's Image Processing}

\href{/docs/7-0/user/-/knowledge_base/u/adapting-your-media-across-multiple-devices}{Adapting
Your Media Across Multiple Devices}

\section{Finding Adapted Images}\label{finding-adapted-images}

In most cases, you can rely on the Adaptive Media taglib to
\href{/docs/7-0/tutorials/-/knowledge_base/t/displaying-adapted-images-in-your-app}{display
adapted images in your app}. This taglib uses the file version you give
it to query Adaptive Media's finder API and display the adapted image
appropriate for the device making the request. If you need more control,
however, you can write your own query with the API instead of using the
taglib. For example, if you have an app that needs a specific image in a
specific dimension, it's best to query Adaptive Media's finder API
directly. You can then display the image however you like (e.g., with an
HTML \texttt{\textless{}img\textgreater{}} tag).

Adaptive Media's finder API lets you write queries that get adapted
images based on certain search criteria and filters. For example, you
can get adapted images that match a file version or resolution, or are
ordered by an attribute like image width. You can even get adapted
images that match approximate attribute values (\emph{fuzzy}
attributes).

This tutorial shows you how to call Adaptive Media's API to get adapted
images in your app. First, you'll learn how to construct such API calls.

\subsection{Calling Adaptive Media's
API}\label{calling-adaptive-medias-api}

The entry point to Adaptive Media's API is
\href{https://github.com/liferay/com-liferay-adaptive-media/blob/master/adaptive-media-image-api/src/main/java/com/liferay/adaptive/media/image/finder/AMImageFinder.java}{the
\texttt{AMImageFinder} interface}. To use it, you must first inject the
OSGi component in your class, which must also be an OSGi component, as
follows:

\begin{verbatim}
@Reference
private AMImageFinder _amImageFinder;
\end{verbatim}

This makes an \texttt{AMImageFinder} instance available. It has one
method, \texttt{getAdaptiveMediaStream}, that returns a stream of
\texttt{AdaptiveMedia} objects. This method takes a \texttt{Function}
that creates an \texttt{AMQuery} (the query for adapted images) via
\texttt{AMImageQueryBuilder}, which can search adapted images based on
different attributes (e.g., width, height, order, etc.). The
\texttt{AMImageQueryBuilder} methods you call depend on the exact query
you want to construct.

For example, here's a general \texttt{getAdaptiveMediaStream} call:

\begin{verbatim}
Stream<AdaptiveMedia<AMImageProcessor>> adaptiveMediaStream =
    _amImageFinder.getAdaptiveMediaStream(
        amImageQueryBuilder -> amImageQueryBuilder.methodToCall(arg).done());
\end{verbatim}

The argument to \texttt{getAdaptiveMediaStream} is a lambda expression
that returns an \texttt{AMQuery} constructed via
\texttt{AMImageQueryBuilder}. Note that \texttt{methodToCall(arg)} is a
placeholder for the \texttt{AMImageQueryBuilder} method you want to call
and its argument. The exact call depends on the criteria you want to use
to select adapted images. The \texttt{done()} call that follows this,
however, isn't a placeholder--it creates and returns the
\texttt{AMQuery} regardless of which \texttt{AMImageQueryBuilder}
methods you call.

For more information on creating \texttt{AMQuery} instances, see
\href{https://github.com/liferay/com-liferay-adaptive-media/blob/master/adaptive-media-image-api/src/main/java/com/liferay/adaptive/media/image/finder/AMImageQueryBuilder.java}{the
Javadoc for \texttt{AMImageQueryBuilder}}.

Next, you'll see specific examples of constructing calls that get
adapted images.

\subsection{Getting Adapted Images for a Specific File
Version}\label{getting-adapted-images-for-a-specific-file-version}

To get adapted images for a specific file version, you must call the
\texttt{AMImageQueryBuilder} method \texttt{forFileVersion} with a
\href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/repository/model/FileVersion.html}{\texttt{FileVersion}
object} as an argument:

\begin{verbatim}
Stream<AdaptiveMedia<AMImageProcessor>> adaptiveMediaStream =
    _amImageFinder.getAdaptiveMediaStream(
        amImageQueryBuilder -> amImageQueryBuilder.forFileVersion(fileVersion).done());
\end{verbatim}

To get the adapted images for the latest approved file version, use the
\texttt{forFileEntry} method with a
\href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/repository/model/FileVersion.html}{\texttt{FileEntry}
object}:

\begin{verbatim}
Stream<AdaptiveMedia<AMImageProcessor>> adaptiveMediaStream =
    _amImageFinder.getAdaptiveMediaStream(
        amImageQueryBuilder -> amImageQueryBuilder.forFileEntry(fileEntry).done());
\end{verbatim}

Note that these calls only return the adapted images for
\href{/docs/7-0/user/-/knowledge_base/u/managing-image-resolutions}{enabled
image resolutions}. Adapted images for disabled resolutions aren't
included in the stream. To retrieve all adapted images regardless of any
image resolution's status, you must also call the
\texttt{withConfigurationStatus} method with the constant
\texttt{AMImageQueryBuilder.ConfigurationStatus.ANY}:

\begin{verbatim}
Stream<AdaptiveMedia<AMImageProcessor>> adaptiveMediaStream =
    _amImageFinder.getAdaptiveMediaStream(
        amImageQueryBuilder -> amImageQueryBuilder.forFileVersion(fileVersion)
            .withConfigurationStatus(AMImageQueryBuilder.ConfigurationStatus.ANY).done());
\end{verbatim}

To get adapted images for a specific file version when the image
resolution is disabled, make the same call but instead use the constant
\texttt{AMImageQueryBuilder.ConfigurationStatus.DISABLED}:

\begin{verbatim}
Stream<AdaptiveMedia<AMImageProcessor>> adaptiveMediaStream =
    _amImageFinder.getAdaptiveMediaStream(
        amImageQueryBuilder -> amImageQueryBuilder.forFileVersion(fileVersion)
            .withConfigurationStatus(AMImageQueryBuilder.ConfigurationStatus.DISABLED).done());
\end{verbatim}

Next, you'll learn how to get adapted images for a specific image
resolution.

\subsection{Getting the Adapted Images for a Specific Image
Resolution}\label{getting-the-adapted-images-for-a-specific-image-resolution}

By providing an image resolution's UUID to \texttt{AMImageFinder}, you
can get that resolution's adapted images. This UUID is defined when
\href{/docs/7-0/user/-/knowledge_base/u/adding-image-resolutions}{adding
the resolution} in the Adaptive Media app. To get a resolution's adapted
images, you must pass that resolution's UUID to the
\texttt{forConfiguration} method.

For example, this code gets the adapted images that match a file
version, and belong to an image resolution with the UUID
\texttt{hd-resolution}. It returns the adapted images regardless of
whether the resolution is enabled or disabled:

\begin{verbatim}
Stream<AdaptiveMedia<AMImageProcessor>> adaptiveMediaStream =
    _amImageFinder.getAdaptiveMediaStream(
        amImageQueryBuilder -> amImageQueryBuilder.forFileVersion(fileVersion)
            .forConfiguration("hd-resolution").done());
\end{verbatim}

Next, you'll learn how to return adapted images in a specific order.

\subsection{Getting Adapted Images in a Specific
Order}\label{getting-adapted-images-in-a-specific-order}

It's also possible to define the order in which
\texttt{getAdaptiveMediaStream} returns adapted images. To do this, call
the \texttt{orderBy} method with your sort criteria just before calling
the \texttt{done()} method. The \texttt{orderBy} method takes two
arguments: the first specifies the image attribute to sort by (e.g.,
width/height), while the second specifies the sort order (e.g.,
ascending/descending).

For example, this code gets all the adapted images regardless of whether
the image resolution is enabled, and puts them in ascending order by the
image width:

\begin{verbatim}
Stream<AdaptiveMedia<AMImageProcessor>> adaptiveMediaStream =
    _amImageFinderImpl.getAdaptiveMediaStream(
        amImageQueryBuilder -> amImageQueryBuilder.forFileVersion(_fileVersion)
            .withConfigurationStatus(AMImageQueryBuilder.ConfigurationStatus.ANY)
            .orderBy(AMImageAttribute.AM_IMAGE_ATTRIBUTE_WIDTH, AMImageQueryBuilder.SortOrder.ASC)
            .done());
\end{verbatim}

The \texttt{orderBy} arguments
\texttt{AMImageAttribute.AM\_IMAGE\_ATTRIBUTE\_WIDTH} and
\texttt{AMImageQueryBuilder.SortOrder.ASC} specify the image width and
ascending sort, respectively. You can alternatively use
\texttt{AMImageAttribute.AM\_IMAGE\_ATTRIBUTE\_HEIGHT} to sort by image
height, and \texttt{AMImageQueryBuilder.SortOrder.DESC} to perform a
descending sort.

Next, you'll learn how to specify approximate attribute values when
getting adapted images.

\subsection{Getting Adapted Images with Fuzzy
Attributes}\label{getting-adapted-images-with-fuzzy-attributes}

Adaptive Media also lets you get adapted images that match \emph{fuzzy
attributes} (approximate attribute values). For example, fuzzy
attributes let you ask for adapted images whose height is around 200px,
or whose size is around 100kb. The API returns a stream with elements
ordered by how close they are to the specified attribute. For example,
imagine that there are four image resolutions that have adapted images
with the heights 150px, 350px, 600px, and 900px. Searching for adapted
images whose height is approximately 400px returns this order in the
stream: 350px, 600px, 150px, 900px.

So how close, exactly, is \emph{close}? It depends on the attribute. In
the case of width, height, and length, a numeric comparison orders the
images. In the case of content type, file name, or UUID, the comparison
is more tricky because these attributes are strings and thus delegated
to
\href{https://docs.oracle.com/javase/8/docs/api/java/lang/String.html\#compareTo-java.lang.String-}{the
Java \texttt{String.compareTo} method}.

To specify a fuzzy attribute, call the \texttt{with} method with your
search criteria just before calling the \texttt{done()} method. The
\texttt{with} method takes two arguments: the image attribute, and that
attribute's approximate value. For example, this code gets adapted
images whose height
(\texttt{AMImageAttribute.AM\_IMAGE\_ATTRIBUTE\_HEIGHT}) is
approximately 400px:

\begin{verbatim}
Stream<AdaptiveMedia<AMImageProcessor>> adaptiveMediaStream =
    _amImageFinderImpl.getAdaptiveMediaStream(
        amImageQueryBuilder -> amImageQueryBuilder.forFileVersion(_fileVersion)
            .with(AMImageAttribute.AM_IMAGE_ATTRIBUTE_HEIGHT, 400).done());
\end{verbatim}

To search for image width instead, use
\texttt{AMImageAttribute.AM\_IMAGE\_ATTRIBUTE\_WIDTH} as the first
argument to the \texttt{width} method.

\subsection{Using the Adaptive Media
Stream}\label{using-the-adaptive-media-stream}

Once you have the \texttt{AdaptiveMedia} stream, you can get the
information you need from it. For example, this code prints the URI for
each adapted image:

\begin{verbatim}
adaptiveMediaStream.forEach(
    adaptiveMedia -> {
        System.out.println(adaptiveMedia.getURI());
    }
);
\end{verbatim}

You can also get other values and attributes from the
\texttt{AdaptiveMedia} stream. Here are a few examples:

\begin{verbatim}
// Get the InputStream 
adaptiveMedia.getInputStream()

// Get the content length
adaptiveMedia.getValueOptional(AMAttribute.getContentLengthAMAttribute())

// Get the image height
adaptiveMedia.getValueOptional(AMImageAttribute.AM_IMAGE_ATTRIBUTE_HEIGHT)
\end{verbatim}

Awesome! Now you know how to find and use adapted images.

\subsection{Related Topics}\label{related-topics-155}

\href{/docs/7-0/tutorials/-/knowledge_base/t/displaying-adapted-images-in-your-app}{Displaying
Adapted Images in Your App}

\href{/docs/7-0/tutorials/-/knowledge_base/t/changing-adaptive-medias-image-scaling}{Changing
Adaptive Media's Image Processing}

\href{/docs/7-0/user/-/knowledge_base/u/adapting-your-media-across-multiple-devices}{Adapting
Your Media Across Multiple Devices}

\section{Changing Adaptive Media's Image
Scaling}\label{changing-adaptive-medias-image-scaling}

As described in
\href{/docs/7-0/user/-/knowledge_base/u/adapting-your-media-across-multiple-devices}{the
Adaptive Media user guide}, Adaptive Media scales images to match the
image resolutions defined by the Liferay DXP administrator. The default
scaling is usually suitable, but you can also customize it to your
needs. Before doing so, however, you should understand how this scaling
works.

\subsection{Understanding Image Scaling in Adaptive
Media}\label{understanding-image-scaling-in-adaptive-media}

Adaptive Media contains an extension point that lets you replace the way
it scales images.
\href{https://github.com/liferay/liferay-portal/blob/7.0.x/modules/apps/adaptive-media/adaptive-media-image-api/src/main/java/com/liferay/adaptive/media/image/scaler/AMImageScaler.java}{The
\texttt{AMImageScaler} interface} defines Adaptive Media's image scaling
logic. Out of the box, Adaptive Media provides two implementations of
this interface:

\begin{itemize}
\item
  \href{https://github.com/liferay/liferay-portal/blob/7.0.x/modules/apps/adaptive-media/adaptive-media-image-impl/src/main/java/com/liferay/adaptive/media/image/internal/scaler/AMDefaultImageScaler.java}{\texttt{AMDefaultImageScaler}}:
  The default image scaler. It's always enabled and uses
  \texttt{java.awt} for its image processing and scaling.
\item
  \href{https://github.com/liferay/liferay-portal/blob/7.0.x/modules/apps/adaptive-media/adaptive-media-image-impl/src/main/java/com/liferay/adaptive/media/image/internal/scaler/AMGIFImageScaler.java}{\texttt{AMGIFImageScaler}}:
  A scaler that works only with GIF images. It depends on the
  installation of the external tool
  \href{https://www.lcdf.org/gifsicle/}{gifsicle} in the Liferay DXP
  instance. This scaler must be enabled in \emph{Control Panel} →
  \emph{System Settings}.
\end{itemize}

You must register image scalers in Liferay DXP's OSGi container using
the \texttt{AMImageScaler} interface. Each scaler must also set the
\texttt{mime.type} property to the MIME type it handles. For example, if
you set a scaler's MIME type to \texttt{image/jpeg}, then that scaler
can only handle \texttt{image/jpeg} images. If you specify the special
MIME type \texttt{*}, the scaler can process any image. Note that
\href{https://github.com/liferay/liferay-portal/blob/7.0.x/modules/apps/adaptive-media/adaptive-media-image-impl/src/main/java/com/liferay/adaptive/media/image/internal/scaler/AMDefaultImageScaler.java}{the
\texttt{AMDefaultImageScaler}} is registered using \texttt{mime.type=*},
while
\href{https://github.com/liferay/liferay-portal/blob/7.0.x/modules/apps/adaptive-media/adaptive-media-image-impl/src/main/java/com/liferay/adaptive/media/image/internal/scaler/AMGIFImageScaler.java}{the
\texttt{AMGIFImageScaler}} is registered using
\texttt{mime.type=image/gif}. Both scalers, like all scalers, implement
\texttt{AMImageScaler}.

You can add as many image scalers as you need, even for the same MIME
type. Even so, Adaptive Media uses only one scaler per image, using this
process to determine the best one:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Select only the image scalers registered with the same MIME type as
  the image.
\item
  Select the enabled scalers from those selected in the first step
  (\href{https://github.com/liferay/liferay-portal/blob/7.0.x/modules/apps/adaptive-media/adaptive-media-image-api/src/main/java/com/liferay/adaptive/media/image/scaler/AMImageScaler.java}{the
  \texttt{AMImageScaler}} method \texttt{isEnabled()} returns
  \texttt{true} for enabled scalers).
\item
  Of the scalers selected in the second step, select the scaler with the
  highest \texttt{service.ranking}.
\end{enumerate}

If these steps return no results, they're repeated, but the first step
uses the special MIME type \texttt{*}. Also note that if an image scaler
is registered for specific MIME types and has a higher
\texttt{service.ranking}, it's more likely to be chosen than if it's
registered for the special MIME type \texttt{*} or has a lower
\texttt{service.ranking}.

\subsection{Creating an Image Scaler}\label{creating-an-image-scaler}

Now that you know how Adaptive Media scales images, you'll learn how to
customize this scaling. As an example, you'll see a sample image scaler
that customizes the scaling of PNG images.

Follow these steps to create a custom image scaler:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Create your scaler class to implement \texttt{AMImageScaler}. You must
  also annotate your scaler class with \texttt{@Component}, setting
  \texttt{mime.type} properties for each of the scaler's MIME types, and
  registering an \texttt{AMImageScaler} service. If there's more than
  one scaler for the same MIME type, you must also set the
  \texttt{@Component} annotation's \texttt{service.ranking} property.
  For your scaler to take precedence over other scalers of the same MIME
  type, its service ranking property must be higher than that of the
  other scalers. If \texttt{service.ranking} isn't set, it defaults to
  \texttt{0}.
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** The `service.ranking` property isn't set for the image scalers
 included with Adaptive Media (`AMDefaultImageScaler` and
 `AMGIFImageScaler`). Their service ranking therefore defaults to `0`. To
 replace either scaler, you must set your scaler to the same MIME type and
 give it a service ranking higher than `0`.
\end{verbatim}

\noindent\hrulefill

\begin{verbatim}
For example, this sample image scaler scales PNG and x-PNG images, and has a
service ranking of `100`:

    @Component(
        immediate = true,
        property = {"mime.type=image/png", "mime.type=image/x-png", "service.ranking:Integer=100"},
        service = {AMImageScaler.class}
    )
    public class SampleAMPNGImageScaler implements AMImageScaler {...

This requires these imports:

    import com.liferay.adaptive.media.image.scaler.AMImageScaler;
    import org.osgi.service.component.annotations.Component;
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\item
  Implement the \texttt{isEnabled()} method to return \texttt{true} when
  you want to enable the scaler. In many cases, you always want the
  scaler enabled, so you can simply return \texttt{true} in this method.
  This is the case with the example \texttt{SampleAMPNGImageScaler}:

\begin{verbatim}
@Override
public boolean isEnabled() {
    return true;
}
\end{verbatim}

  This method gets more interesting when the scaler depends on other
  tools or features. For example, the \texttt{isEnabled()} method in
  \texttt{AMGIFImageScaler} determines whether gifsicle is enabled. This
  scaler must only be enabled when the tool it depends on, gifsicle, is
  also enabled:

\begin{verbatim}
@Override
public boolean isEnabled() {
    return _amImageConfiguration.gifsicleEnabled();
}
\end{verbatim}
\item
  Implement the \texttt{scaleImage} method. This method contains the
  scaler's business logic, and must return an
  \texttt{AMImageScaledImage} instance. For example, the example
  \texttt{scaleImage} implementation in \texttt{SampleAMPNGImageScaler}
  uses \texttt{AMImageConfigurationEntry} to get the maximum height and
  width values for the scaled image, and \texttt{FileVersion} to get the
  image to scale. The scaling is done with the help of a private inner
  class, assuming that the methods \texttt{\_scalePNG},
  \texttt{\_getScalePNGHeight}, \texttt{\_getScalePNGWidth}, and
  \texttt{\_getScalePNGSize} implement the actual scaling:

\begin{verbatim}
@Override
public AMImageScaledImage scaleImage(FileVersion fileVersion,
    AMImageConfigurationEntry amImageConfigurationEntry) {

    Map<String, String> properties = amImageConfigurationEntry.getProperties();

    int maxHeight = GetterUtil.getInteger(properties.get("max-height"));
    int maxWidth = GetterUtil.getInteger(properties.get("max-width"));

    try {
        InputStream inputStream =
            _scalePNG(fileVersion.getContentStream(false), maxHeight, maxWidth);

        int height = _getScalePNGHeight();
        int width = _getScalePNGWidth();
        long size = _getScalePNGSize();

        return new AMImageScaledImageImpl(inputStream, height, width, size);
    }
    catch (PortalException pe) {
        throw new AMRuntimeException.IOException(pe);
    }
}

private class AMImageScaledImageImpl implements AMImageScaledImage {

    @Override
    public int getHeight() {
        return _height;
    }

    @Override
    public InputStream getInputStream() {
        return _inputStream;
    }

    @Override
    public long getSize() {
        return _size;
    }

    @Override
    public int getWidth() {
        return _width;
    }

    private AMImageScaledImageImpl(InputStream inputStream, int height,
        int width, long size) {

        _inputStream = inputStream;
        _height = height;
        _width = width;
        _size = size;
    }

    private final int _height;
    private final InputStream _inputStream;
    private final long _size;
    private final int _width;

}
\end{verbatim}

  This requires these imports:

\begin{verbatim}
import com.liferay.adaptive.media.exception.AMRuntimeException;
import com.liferay.adaptive.media.image.configuration.AMImageConfigurationEntry;
import com.liferay.adaptive.media.image.scaler.AMImageScaledImage;
import com.liferay.portal.kernel.exception.PortalException;
import com.liferay.portal.kernel.repository.model.FileVersion;
import com.liferay.portal.kernel.util.GetterUtil;
import java.io.InputStream;
import java.util.Map;
\end{verbatim}
\end{enumerate}

Great! Now you know how to write your own image scalers.

\subsection{Related Topics}\label{related-topics-156}

\href{/docs/7-0/tutorials/-/knowledge_base/t/displaying-adapted-images-in-your-app}{Displaying
Adapted Images in Your App}

\href{/docs/7-0/tutorials/-/knowledge_base/t/finding-adapted-images}{Finding
Adapted Images}

\href{/docs/7-0/user/-/knowledge_base/u/adapting-your-media-across-multiple-devices}{Adapting
Your Media Across Multiple Devices}

\chapter{Liferay Forms}\label{liferay-forms}

Many modern websites rely on forms for their functionality. Liferay's
Forms application is maturing rapidly, offering
\href{/docs/7-0/user/-/knowledge_base/u/collecting-information-from-users}{rich
out-of-the-box functionality}. Many use cases, from the simplest to the
most complex, can be met using the Forms application as it is. However,
why not make the application behave exactly as you'd like it to? Just
because something is good, doesn't mean it's perfect for your specific
use case. Liferay's Forms solution can be adapted to your specific
needs. You can even develop forms using its API.

In this section, learn to extend the Forms application's functionality
and leverage its APIs.

\begin{itemize}
\tightlist
\item
  Build your own field types for Liferay's Forms application.

  \begin{itemize}
  \tightlist
  \item
    Create field types that look just like the built-in field types
    (both their source code and their UI appearance).
  \item
    Add custom configuration options to your form field types.
  \end{itemize}
\item
  Use annotations to leverage the Dynamic Data Mapping (DDM) API and
  build reusable forms quickly.

  \begin{itemize}
  \tightlist
  \item
    Create forms using annotations.
  \item
    Create fields and reusable fieldsets using annotations.
  \item
    Configure form rules using annotations.
  \end{itemize}
\end{itemize}

\chapter{Form Field Types}\label{form-field-types}

The Forms application contains many highly configurable field types
out-of-the-box. Most use cases will be met with one of the existing
field types.

\begin{figure}
\centering
\includegraphics{./images/forms-field-types.png}
\caption{The Forms application has useful out-of-the-box field types,
but you can add your own if you need to.}
\end{figure}

If you're reading this, however, your use case probably wasn't met with
the default field types. For example, perhaps you need a color picker
field. You could create a select field that lists the color options, but
some users don't know that \emph{gamboge} is the color of spicy mustard
(maybe a little darker), and anyway, seeing colors is much more
interesting than listing them. Another example is a dedicated
\emph{time} field. You can use a text field and add a tip to tell users
something like \emph{enter the time in the format \texttt{hour:minute}},
but some users will still enter something indecipherable, like
\emph{8:88}. Instead, add a \emph{time} field to Liferay DXP's Forms
application. You can think of other uses where it's best to break free
of the mold of existing field types and create your own that serve your
needs best. Keep reading to find out how.

In these tutorials, learn to

\begin{itemize}
\tightlist
\item
  create a module that adds a \emph{Time} form field type with a
  timepicker
\item
  add custom configuration options to your field types
\end{itemize}

\noindent\hrulefill

\textbf{Example project:} The source code for the example \emph{time}
project developed in these tutorials can be downloaded for your
convenience. Click
\href{https://portal.liferay.dev/documents/113763090/114000186/Field+Type+Module+Source.zip}{here}
to begin downloading the source code zip file.

\noindent\hrulefill

Before getting started, learn what Liferay DXP's field types consist of.

\section{Anatomy of a Field Type
Module}\label{anatomy-of-a-field-type-module}

The \texttt{dynamic-data-mapping-type-*} modules in Liferay DXP's source
code (inside the \emph{Forms and Workflow} application suite) are good
templates to follow when developing your own field types. For example,
look at the directory structure of the
\texttt{dynamic-data-mapping-type-paragraph} module (version 2.0.7) in
the Forms and Workflow application suite:

\begin{verbatim}
bnd.bnd
build.gradle
src
└── main
    ├── java
    │   └── com
    │       └── liferay
    │           └── dynamic
    │               └── data
    │                   └── mapping
    │                       └── type
    │                           └── paragraph
    │                               └── internal
    │                                   ├── ParagraphDDMFormFieldRenderer.java
    │                                   ├── ParagraphDDMFormFieldType.java
    │                                   └── ParagraphDDMFormFieldTypeSettings.java
    └── resources
        ├── content
        │   ├── Language.properties
        │   └── Language_xx_XX.properties
        │   └── ...
        └── META-INF
            └── resources
                ├── config.js
                ├── paragraph_field.js
                ├── paragraph.soy
                └── paragraph.soy.js
\end{verbatim}

Custom field type modules are nearly identical in structure to those
included in Liferay DXP, as presented above. You won't need a
\texttt{*TypeSettings} class in your initial module (see the tutorial on
adding settings to your form field types to learn more about
\texttt{*TypeSettings}), and the \texttt{*.soy.js} is generated from the
\texttt{*.soy} file at compile time. These are the Java classes and
resources you'll need to create:

\begin{itemize}
\tightlist
\item
  \texttt{*DDMFormFieldRenderer.java}: Controls the rendering of the
  template. Sets the language, declares the namespace, and loads the
  template resources on activation of the Component. Extending the
  abstract class that implements the \texttt{DDMFormFieldRenderer} makes
  your work here easier.
\item
  \texttt{*DDMFormFieldType.java}: Define the form field type in the
  backend. If you extend the abstract class that implements the
  interface, you automatically include the default form configuration
  options for your form field type. In that case, override the
  interface's \texttt{getName} method and you're done. To see the
  default configuration options your form field type will inherit, look
  at the \texttt{DefaultDDMFormFieldTypeSettings} class in the
  \texttt{dynamic-data-mapping-form-field-type} module.
\item
  \texttt{config.js}: Autogenerated if you use Blade CLI,
  \texttt{config.js} defines the dependencies of all declared JavaScript
  components.
\item
  \texttt{{[}name-of-field-type{]}\_field.js}: The JavaScript file that
  models your field.
\item
  \texttt{{[}name-of-field-type{]}.soy}: The template that defines the
  appearance of the field.
\item
  \texttt{Language\_xx.properties}: Define any terms that need to be
  \href{/docs/7-0/tutorials/-/knowledge_base/t/localizing-your-application}{translated
  into different languages}.
\end{itemize}

In addition to the Java classes, Soy templates, and JavaScript files,
Liferay DXP applications contain a \texttt{bnd.bnd} file to manage the
module's metadata, and a \texttt{build.gradle} file to manage its
dependencies and build properties. This example follows those patterns.

\section{Creating Form Field Types}\label{creating-form-field-types}

Liferay's Forms application does not contain a dedicated time field
out-of-the-box. For ease of use and to ensure proper data is collected,
you can develop a time field and learn how Liferay DXP's field types
work at the same time.

There are several steps involved in creating a form field type:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Specify the OSGi metadata
\item
  Configure your build script and dependencies
\item
  Create a \texttt{DDMFormFieldType} component
\item
  Implement a \texttt{DDMFormFieldType}
\item
  Render the field type
\end{enumerate}

\noindent\hrulefill

\textbf{Note:} To avoid manually creating your own project, use
\href{/docs/7-0/tutorials/-/knowledge_base/t/blade-cli}{BladeCLI}. If
you have Blade CLI on your machine, there's a template for creating form
fields you can leverage using the following command syntax:

\begin{verbatim}
 blade create -t form-field [ADDITIONAL OPTIONS] [PROJECT NAME]
\end{verbatim}

See the
\href{/docs/7-0/tutorials/-/knowledge_base/t/blade-cli}{BladeCLI}
documentation for more information, such as the answer to yuor question,
What are those additional options?''

Using Blade CLI, you get a project skeleton with much of the boilerplate
filled in, and you can focus on coding without delay.

\noindent\hrulefill

Start by setting up the project's metadata.

\subsection{Specifying OSGi Metadata}\label{specifying-osgi-metadata-2}

First specify the necessary OSGi metadata in a \texttt{bnd.bnd} file
(see \href{https://bnd.bndtools.org/chapters/800-headers.html}{here} for
more information). Here's what it would look like for a module in a
folder called \texttt{dynamic-data-mapping-type-time}:

\begin{verbatim}
Bundle-Name: Liferay Dynamic Data Mapping Type Time
Bundle-SymbolicName: com.liferay.dynamic.data.mapping.type.time
Bundle-Version: 1.0.0
Liferay-JS-Config: /META-INF/resources/config.js
Web-ContextPath: /dynamic-data-mapping-type-time
\end{verbatim}

First name the bundle with a reader-friendly \texttt{Bundle-Name} and a
unique \texttt{Bundle-SymbolicName} (it's common to use the root package
of your module's Java classes), then set the version. Point to the
JavaScript configuration file (\texttt{config.js}) that defines
JavaScript modules added by your module (you'll get to that later), and
set the Web Context Path so your module's resources are made available
upon module activation.

Next add your dependencies to a \texttt{build.gradle} file.

\subsection{Specifying Dependencies}\label{specifying-dependencies}

If you're using Gradle to manage your dependencies (as Liferay DXP
modules do), add this to your \texttt{build.gradle} file:

\begin{verbatim}
buildscript {
    dependencies {
        classpath group: "com.liferay", name: "com.liferay.gradle.plugins", version: "3.0.23"
    }

    repositories {
        mavenLocal()

        maven {
            url "https://repository-cdn.liferay.com/nexus/content/groups/public"
        }
    }
}

apply plugin: "com.liferay.plugin"

dependencies {
    compile group: "com.liferay", name: "com.liferay.dynamic.data.mapping.api", version: "3.2.0"
    compile group: "com.liferay", name: "com.liferay.dynamic.data.mapping.form.field.type", version: "2.0.5"
    compile group: "com.liferay.portal", name: "com.liferay.portal.kernel", version: "2.0.0"
    compileOnly group: "com.liferay.portal", name: "com.liferay.portal.kernel", version: "2.0.0"
    compileOnly group: "org.osgi", name: "org.osgi.compendium", version: "5.0.0"
}

repositories {
    mavenLocal()

    maven {
        url "https://repository-cdn.liferay.com/nexus/content/groups/public"
    }
}

classes {
    dependsOn buildSoy
}

transpileJS {
    soySrcIncludes = ""
    srcIncludes = "**/*.es.js"
}

wrapSoyAlloyTemplate {
    enabled = true
    moduleName = "liferay-ddm-form-field-time-template"
    namespace = "ddm"
}
\end{verbatim}

Along with the regular Java \texttt{dependencies}, there's some
JavaScript dependency configuration you need to include here. It's all
boilerplate and can be copied directly into your module's
\texttt{build.gradle} if you follow the conventions presented here.

Next craft the OSGi Component that marks your class as an implementation
of \texttt{DDMFormFieldType}.

\subsection{Creating a DDMFormFieldType
Component}\label{creating-a-ddmformfieldtype-component}

If you're creating a \emph{Time} field type, define the Component at the
top of your \texttt{*DDMFormFieldType} class like this:

\begin{verbatim}
@Component(
  immediate = true,
  property = {
    "ddm.form.field.type.display.order:Integer=8",
    "ddm.form.field.type.icon=star-o",
    "ddm.form.field.type.js.class.name=Liferay.DDM.Field.Time",
    "ddm.form.field.type.js.module=liferay-ddm-form-field-time",
    "ddm.form.field.type.label=time-field-type-label",
    "ddm.form.field.type.name=time"
  },
  service = DDMFormFieldType.class
)
\end{verbatim}

Define the field type's properties (\texttt{property=...}) and declare
that you're implementing the \texttt{DDMFormFieldType} service
(\texttt{service=...}).

\texttt{DDMFormFieldType} Components can have several properties:

\begin{description}
\tightlist
\item[\texttt{ddm.form.field.type.display.order}]
Integer that defines the field type's position in the \emph{Choose a
Field Type} dialog of the form builder.
\item[\texttt{ddm.form.field.type.icon}]
The icon to be used for the field type. Choosing one of the
\href{https://lexicondesign.io/docs/patterns/icons.html}{Lexicon icons}
makes your form field blends in with the existing form field types.
\item[\texttt{ddm.form.field.type.js.class.name}]
The field type's JavaScript class name--the JavaScript file is used to
define the field type's behavior.
\item[\texttt{ddm.form.field.type.js.module}]
The name of the JavaScript module--provided to the Form engine so the
module can be loaded when needed.
\item[\texttt{ddm.form.field.type.label}]
The field type's label. Its localized value appears in the \emph{Choose
a Field Type} dialog.
\item[\texttt{ddm.form.field.type.name}]
The field type's name must be unique. Each Component in a field type
module references the field type name, and it's used by OSGi service
trackers to filter the field's capabilities (for example, rendering and
validation).
\end{description}

Next code the \texttt{*DDMFormFieldType} class.

\subsection{Implementing
DDMFormFieldType}\label{implementing-ddmformfieldtype}

Implementing the field type in Java is made easier because of
\texttt{BaseDDMFormFieldType}, an abstract class you can leverage in
your code.

After extending \texttt{BaseDDMFormFieldType}, override the
\texttt{getName} method by specifying the name of your new field type:

\begin{verbatim}
public class TimeDDMFormFieldType extends BaseDDMFormFieldType {
    @Override
    public String getName() {
        return "time";
    }
}
\end{verbatim}

That's all there is to defining the field type. Next determine how your
field type is rendered.

\subsection{Rendering Field Types}\label{rendering-field-types}

Before you get to the frontend coding necessary to render your field
type, there's another Component to define and a Java class to code.

The Component only has one property, \texttt{ddm.form.field.type.name},
and then you declare that you're adding a \texttt{DDMFormFieldRenderer}
implementation to the OSGi framework:

\begin{verbatim}
@Component(
    immediate = true, 
    property = "ddm.form.field.type.name=time",
    service = DDMFormFieldRenderer.class
)
\end{verbatim}

There's another abstract class to leverage, this time
\texttt{BaseDDMFormFieldRenderer}. It gives you a default implementation
of the \texttt{render} method, the only required method for implementing
the API. The form engine calls the render method for every form field
type present in a form, and returns the plain HMTL of the rendered field
type. The abstract implementation also includes some utility methods.
Here's what the time field's \texttt{DDMFormFieldRenderer} looks like:

\begin{verbatim}
public class TimeDDMFormFieldRenderer extends BaseDDMFormFieldRenderer {

    @Override
    public String getTemplateLanguage() {
        return TemplateConstants.LANG_TYPE_SOY;
    }

    @Override
    public String getTemplateNamespace() {
        return "ddm.time";
    }

    @Override
    public TemplateResource getTemplateResource() {
        return _templateResource;
    }

    @Activate
    protected void activate(Map<String, Object> properties) {
        _templateResource = getTemplateResource("/META-INF/resources/time.soy");
    }

    private TemplateResource _templateResource;

}
\end{verbatim}

Here you're setting the templating language (Soy closure templates), the
template namespace (\texttt{ddm.time}), and pointing to the location of
the templates within your module (\texttt{/META-INF/resource/time.soy}).

\noindent\hrulefill

\textbf{Note:}
\href{https://developers.google.com/closure/templates/}{Closure
templates} are a templating system for building UI elements. Liferay DXP
developers chose to build the Forms UI with closure templates because
they enable a smooth, responsive repainting of the UI as a user enters
data. With closure templates there's no need to reload the entire page
from the server side when the UI is updated by the user: only the
relevant portion of the page is updated from the server. This makes for
a smooth user experience.

\noindent\hrulefill

Now it's time to write the template you referenced in the renderer:
\texttt{time.soy} in the case of the time field type.

Create

\begin{verbatim}
src/main/resources/META-INF/resources/time.soy
\end{verbatim}

and populate it with these contents:

\begin{verbatim}
{namespace ddm}

/**
 * Prints the DDM form time field.
 *
 * @param label
 * @param name
 * @param readOnly
 * @param required
 * @param showLabel
 * @param tip
 * @param value
 */
{template .time autoescape="deprecated-contextual"}
    <div class="form-group liferay-ddm-form-field-time" data-fieldname="{$name}">
        {if $showLabel}
            <label class="control-label">
                {$label}

                {if $required}
                    <span class="icon-asterisk text-warning"></span>
                {/if}
            </label>

            {if $tip}
                <p class="liferay-ddm-form-field-tip">{$tip}</p>
            {/if}
        {/if}

        <input class="field form-control" id="{$name}" name="{$name}" {if $readOnly}readonly{/if} type="text" value="{$value}">
    </div>
{/template}
\end{verbatim}

There are three important things to do in the template:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Define the template namespace. The template namespace allows you to
  define multiple templates for your field type by adding the namespace
  as a prefix.

\begin{verbatim}
{namespace ddm}
\end{verbatim}
\item
  Describe the template parameters. The template above uses some of the
  parameters as flags to display or hide some parts of the HTML (for
  example, the \texttt{\$required} parameter). If you extend
  \texttt{BaseDDMFormFieldRenderer}, all the listed parameters are
  passed by default.

\begin{verbatim}
/**
 * Prints the DDM form time field.
 *
 * @param label
 * @param name
 * @param readOnly
 * @param required
 * @param showLabel
 * @param tip
 * @param value
 */
\end{verbatim}
\item
  Write the template logic (everything encapsulated by the
  \texttt{\{template\}...\{/template\}} block). In the above example the
  template does these things:

  \begin{itemize}
  \tightlist
  \item
    Checks whether to show the label of the field, and if so, adds it.
  \item
    Checks if the field is required, and adds \texttt{icon-asterisk} if
    it is.
  \item
    Checks if a tip is provided, and displays it.
  \item
    Provides the markup for the time field in the
    \texttt{\textless{}input\textgreater{}} tag. In this case a text
    input field is defined.
  \end{itemize}
\end{enumerate}

Once you have your template defined, write the JavaScript file modeling
your field. Call it \texttt{time\_field.js} and give it these contents:

\begin{verbatim}
AUI.add('liferay-ddm-form-field-time', function(A) {
    var TimeField = A.Component.create({
        ATTRS : {
            type : {
                value : 'time'
            }
        },

        EXTENDS : Liferay.DDM.Renderer.Field,
        NAME : 'liferay-ddm-form-field-time',

        prototype : {}
    });

    Liferay.namespace('DDM.Field').Time = TimeField;
}, '', {
    requires : [ 'liferay-ddm-form-renderer-field' ]
});
\end{verbatim}

The JavaScript above creates a component called \texttt{TimeField}. The
component extends \texttt{Liferay.DDM.Renderer.Field}, which gives you
automatic injection of the default field parameters.

All that's left to do is create the \texttt{config.js} file:

\begin{verbatim}
;
(function() {
    AUI().applyConfig({
        groups : {
            'field-time' : {
                base : MODULE_PATH + '/',
                combine : Liferay.AUI.getCombine(),
                modules : {
                    'liferay-ddm-form-field-time' : {
                        condition : {
                            trigger : 'liferay-ddm-form-renderer'
                        },
                        path : 'time_field.js',
                        requires : [ 'liferay-ddm-form-renderer-field' ]
                    },
                    'liferay-ddm-form-field-time-template' : {
                        condition : {
                            trigger : 'liferay-ddm-form-renderer'
                        },
                        path : 'time.soy.js',
                        requires : [ 'soyutils' ]
                    }
                },
                root : MODULE_PATH + '/'
            }
        }
    });
})();
\end{verbatim}

This file is entirely boilerplate, and you'll never need anything
different if you follow the conventions described above. In fact, if you
use Blade CLI to generate a field type module, you won't need to modify
anything in this file. So what is the \texttt{config.js} file for? It's
a JavaScript file that defines the dependencies of the declared
JavaScript components (\texttt{requires...}), and where the files are
located (\texttt{path...}). The \texttt{config.js} is used by the Alloy
loader when it satisfies dependencies for each JavaScript component. For
more information about the Alloy loader see the
\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-amd-module-loader}{tutorial
on its usage}.

{[}\includegraphics{./images/forms-time-field-type.png}

If you build and deploy your new field type module, you'll see that you
get exactly what you described in the \texttt{time.soy} file: a single
text input field. Of course, that's not what you want! You need a time
picker.

\subsection{Adding Behavior to the
Field}\label{adding-behavior-to-the-field}

If you want to do more than simply provide a text input field, define
the behavior in the \texttt{time\_field.js} file. To add an AlloyUI
timepicker, first specify that your component requires the
\texttt{aui-timepicker} in the \texttt{requires...} block:

\begin{verbatim}
{
    requires: ['aui-timepicker','liferay-ddm-form-renderer-field']
}
\end{verbatim}

Since you're now changing the default rendering of the field, overwrite
the base \texttt{render} logic and instantiate the time picker. This
occurs in the \texttt{prototype} block:

\begin{verbatim}
prototype: {
    render: function() {

        var instance = this;

        TimeField.superclass.render.apply(instance, arguments);

        instance._timePicker = new A.TimePicker(
            {
                trigger: instance.getInputSelector(),
                popover: {
                    zIndex: 1
                }
            }
        );
    }
\end{verbatim}

Invoke the original render method--it prints markup required by the
Alloy time picker. Then instantiate the time picker, passing the field
type input as a \texttt{trigger}. See the
\href{http://alloyui.com/tutorials/timepicker/}{Alloy documentation for
more information}.

Now when the field is rendered, there's a real time picker.

\begin{figure}
\centering
\includegraphics{./images/forms-timepicker.png}
\caption{The Alloy UI Timepicker in action.}
\end{figure}

Now you know how to create a new field type and define its behavior.
Currently, the field type only contains the default settings it inherits
from its superclasses. If that's not sufficient, create additional
settings for your field type. See the next tutorial (not yet written) to
learn how.

\section{Adding Settings to Form Field
Types}\label{adding-settings-to-form-field-types}

Once you develop a
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-form-field-types}{Form
Field Type}, you might need to add settings to it. For example, your
time field might need to be configured to accept different time formats.
Here you'll learn how to add settings to form field types by adding a
\emph{mask} and a \emph{placeholder} to the Time field type created in
the previous tutorial.

\noindent\hrulefill

\textbf{Note:} To learn more about using masks with the AUI Timepicker,
go \href{http://alloyui.com/tutorials/timepicker/}{here}. The mask just
sets the format the timepicker uses to display the time choices. Use the
\href{http://pubs.opengroup.org/onlinepubs/007908799/xsh/strftime.html}{strftime
format} to pick the mask you want.

\noindent\hrulefill

To add settings to form field types, you'll use these steps:

\begin{itemize}
\tightlist
\item
  Write an interface that extends the default field type configuration,
  \texttt{DefaultDDMFormFieldTypesettings}.
\item
  Update the \texttt{*FormFieldRenderer} so it makes the new
  configuration options available to the JavaScript component and/or the
  Soy template for rendering.
\item
  Update the JavaScript component (defined in \texttt{time\_field.js} in
  our example) to configure the new settings and their default values.
\item
  Update the Soy template to include any settings that need to be
  rendered in a form (the placeholder, in our example).
\end{itemize}

Get started by crafting the interface that controls what settings your
field has.

\subsection{Extending the Default Type
Settings}\label{extending-the-default-type-settings}

To add type settings, you need a \texttt{*TypeSettings} class that
extends \texttt{DefaultDDMFormFieldTypeSettings}. Since this example
works with a Time field type, call it
\texttt{TimeDDMFormFieldTypeSettings}.

This class sets up the \emph{Add {[}Field Type{]}} configuration form.

\begin{figure}
\centering
\includegraphics{./images/forms-text-settings.png}
\caption{Like your custom field types, the text field type's settings
are configured in a Java interface.}
\end{figure}

Here's what it looks like:

\begin{verbatim}
package com.liferay.docs.ddm.time;

import ...

@DDMForm
@DDMFormLayout(
    paginationMode = com.liferay.dynamic.data.mapping.model.DDMFormLayout.TABBED_MODE,
    value = {
        @DDMFormLayoutPage(
            title = "basic",
            value = {
                @DDMFormLayoutRow(
                    {
                        @DDMFormLayoutColumn(
                            size = 12,
                            value = {"label", "required", "tip", "mask", "placeholder"}
                        )
                    }
                )
            }
        ),
        @DDMFormLayoutPage(
            title = "properties",
            value = {
                @DDMFormLayoutRow(
                    {
                        @DDMFormLayoutColumn(
                            size = 12,
                            value = {
                                "predefinedValue", "visibilityExpression",
                                "fieldNamespace", "indexType", "localizable",
                                "readOnly", "dataType", "type", "name",
                                "showLabel", "repeatable"
                            }
                        )
                    }
                )
            }
        )
    }
)
public interface TimeDDMFormFieldTypeSettings
    extends DefaultDDMFormFieldTypeSettings {

    @DDMFormField(label = "%mask", predefinedValue="%I:%M %p")
    public String mask();

    @DDMFormField(label = "%placeholder")
    public String placeholder();

}
\end{verbatim}

Would you look at that! Most of the work you need to do is in the
class's annotations.

In this class you're setting up a dynamic form with all the settings
your form field type needs. The form layout presented here gives your
form the look and feel of a native form field type. See the note below
for more information on the DDM annotations used in this form.

One thing to note is that all the default settings must be present in
your settings form. Note the list of settings present for each tab (each
\texttt{@DDMFormLayoutPage}) above. If you need to make one of the
default settings unusable in the settings form for your field type,
configure a \emph{hide rule} for the field. Form field rules are
configured using the \texttt{@DDMFormFieldRule} annotation. More
information on configuring form rules will be written soon.

Your interface is extending the \texttt{DefaultDDMFormfieldTypeSettings}
class. That's why the default settings are available to use in the class
annotation, without setting them up in the class, as was necessary for
the mask and placeholder.

\noindent\hrulefill

\textbf{DDM Annotations:} The \texttt{@DDMForm} annotation on this class
allows the form engine to convert the interface definition into a
dynamic form. This makes it really intuitive to lay out your settings
form.

For now, here are brief explanations for the annotations used in the
above example:

\begin{description}
\tightlist
\item[\texttt{@DDMForm}]
Instantiates a new \texttt{DDMForm}. Creates a dynamic form from the
annotation.
\item[\texttt{@DDMFormLayout}]
Takes two variables: \texttt{paginationMode} and \texttt{value}. The
pagination mode is a String that controls how the layout pages are
displayed. The \texttt{pagionationMode} can be \texttt{TABBED\_MODE},
\texttt{SINGLE\_PAGE\_MODE}, \texttt{SETTINGS\_MODE}, or
\texttt{WIZARD\_MODE}. Under \texttt{value}, specify any
\texttt{@DDMFormLayoutPage}s that you want to use.
\item[\texttt{@DDMFormLayoutPage}]
The sections of the type settings form. Takes two variables:
\texttt{title} and \texttt{value}, where title is a String value that
names the section of the form and value is one or more
\texttt{@DDMFormLayoutRow}s.
\end{description}

\textbf{Note:} The title of the layout pages are \texttt{basic} and
\texttt{properties} for all of Liferay DXP's field types: in future
versions of the Forms application, the localized value of the key you
specify here will be the heading for the form section (the layout page
is a section of the form). In the current version of Liferay DXP (at the
time of this writing, DE DXP SP1 and CE 7.0 GA3), these are not
displayed. To remain consistent with the Forms application's default
fields, it's best to follow the standard approach and use \texttt{basic}
and \texttt{properties}.

\begin{description}
\tightlist
\item[\texttt{@DDMFormLayoutRow}]
Use this to lay out the number of columns you want in the row. Most
settings forms have just one row and one column.
\item[\texttt{@DDMFormLayoutColumn}]
Use this to lay out the columns your settings form needs. Most settings
forms have one row and one column. Each column accepts two argument,
\texttt{size} and \texttt{value}.
\item[\texttt{@DDMFormField}]
Use this annotation to add new fields to the settings form. In this
example, the \texttt{mask} and \texttt{placeholder} settings are
configured with this annotation.
\end{description}

\noindent\hrulefill

Once your \texttt{*TypeSettings} class is finished, move on to update
the \texttt{*Renderer} class for your form field type.

\subsection{Updating the Renderer
Class}\label{updating-the-renderer-class}

To send the new configuration settings to the Soy template so they can
be displayed to the end user, you need to modify the
\texttt{*DDMFormFieldRenderer}.

Add this method to \texttt{TimeDDMFormFieldRenderer}:

\begin{verbatim}
@Override
protected void populateOptionalContext(
    Template template, DDMFormField ddmFormField,
    DDMFormFieldRenderingContext ddmFormFieldRenderingContext) {

    template.put(
        "placeholder", (String)ddmFormField.getProperty("placeholder"));

    template.put(
        "mask", (String)ddmFormField.getProperty("mask"));  

    }
\end{verbatim}

The \texttt{populateOptionalContext} method takes three parameters: The
template object, the \texttt{DDMFormField}, and the
\texttt{DDMFormFieldRenderingContext}. The \texttt{DDMFormField}
represents the definition of the field type instance: you can use this
object to access the configurations set for the field type (the mask and
placeholder settings in our case). The
\texttt{DDMFormFieldRenderingContext} object contains extra information
about the form such as the user's locale, the HTTP request and response
objects, the portlet namespace, and more (all of its included properties
can be found
\href{https://docs.liferay.com/ce/apps/forms-and-workflow/latest/javadocs/com/liferay/dynamic/data/mapping/render/DDMFormFieldRenderingContext.html}{here}.

You're putting the new settings into the template object, which is just
an extension of a Map that takes a String and an Object (in this case
the Object is the property configured in the \texttt{@DDMFormField} in
your \texttt{*TypeSettings} class, retrieved by the name of the field:
\texttt{placeholder} and \texttt{mask}, respectively.

Now the JavaScript component and the Soy template can access the new
settings. Next, update the JavaScript Component so it handles these
properties and can use them, whether passing them to the template
context (similar to the \texttt{*Renderer}, only this time for
client-side rendering), or using them to configure the behavior of the
JavaScript component itself.

\noindent\hrulefill

\textbf{Note:} Remember that the Soy template can be used for server
side or client side rendering. By defining the settings you're adding in
both the Java Renderer and the JavaScript Renderer, you're allowing for
the best possible user experience. For example, if a form builder is in
the form builder, configuring a form field type, the configuration they
enter can be directly passed to the template, and become visible in the
UI, almost instantly. However, when the user clicks into a form field
initially to begin editing, the rendering occurs from the server side.

\noindent\hrulefill

Next configure the JavaScript component to include the new settings.

\subsection{Adding Settings to the JavaScript
Component}\label{adding-settings-to-the-javascript-component}

The JavaScript component needs to know about the new settings. First
configure them as attributes of the component:

\begin{verbatim}
ATTRS: {
    mask: {
        value: '%I:%M %p'
    },
    placeholder: {
        value: ''
    },
    type: {
        value: 'time'
    }
},
\end{verbatim}

The mask setting has a default value of \texttt{\%I:\%M\ \%p}, and the
placeholder is blank. Now that the new settings are declared as
attributes of the component, make the JavaScript component pass the
placeholder configuration to the Soy template on the client side. Just
like in the Java renderer, pass the placeholder configuration to the
template context. In this case, override the
\texttt{getTemplateContext()} method to pass in the placeholder
configuration. Add this to the \texttt{prototype} section of the
JavaScript component definition:

\begin{verbatim}
getTemplateContext: function() {
    var instance = this;

return A.merge(
    TimeField.superclass.getTemplateContext.apply(instance, arguments),
        {
        placeholder: instance.get('placeholder')
        }
    );
},
\end{verbatim}

Then in the component's render method, add the mask as an
\href{http://alloyui.com/api/classes/A.TimePicker.html\#attr_mask}{attribute
of the AUI Timepicker} using
\texttt{mask:\ instance.get(\textquotesingle{}mask\textquotesingle{})}.

\begin{verbatim}
       render: function() {
        var instance = this;

        TimeField.superclass.render.apply(instance, arguments);

        instance._timePicker = new A.TimePicker(
            {
                trigger: instance.getInputSelector(),
                mask: instance.get('mask'),
                popover: {
                    zIndex: 1
                }
            }
        );
    }
\end{verbatim}

Now the field type JavaScript component is configured to include the
settings. All you have left to do is to update the Soy template so the
placeholder can be rendered in the form with the time field.

\subsection{Updating the Soy Template}\label{updating-the-soy-template}

After all that, adding the placeholder setting to your Soy template's
logic is simple.

The whole template is included below, but the only additions are in the
commented section (adds the placeholder to the list of parameters--the
\texttt{?} indicates that the placeholder is not required), and then in
the \texttt{\textless{}input\textgreater{}} tag, where you use the
parameter value to configure the placeholder HTML property with the
proper value.

\begin{verbatim}
{namespace ddm}

/**
 * Prints the DDM form time field.
 *
 * @param label
 * @param name
 * @param? placeholder
 * @param readOnly
 * @param required
 * @param showLabel
 * @param tip
 * @param value
 */
{template .time autoescape="deprecated-contextual"}
    <div class="form-group liferay-ddm-form-field-time" data-fieldname="{$name}">
        {if $showLabel}
            <label class="control-label">
                {$label}

                {if $required}
                    <span class="icon-asterisk text-warning"></span>
                {/if}
            </label>

            {if $tip}
                <p class="liferay-ddm-form-field-tip">{$tip}</p>
            {/if}
        {/if}

        <input class="field form-control" id="{$name}" name="{$name}" placeholder="{$placeholder}" {if $readOnly}readonly{/if} type="text" value="{$value}">
    </div>
{/template}
\end{verbatim}

Why isn't the mask parameter added to the Soy template? The mask is not
needed in the template because it's only used in the JavaScript for
configuring the behavior of the timepicker. You don't need the dynamic
rendering of the soy template to take the mask setting and configure it
in the form. The maskv set by the form builder is captured in the
rendering of the timepicker itself.

Now when you build the project and deploy your time field, you have a
fully developed \emph{time} form field type, complete with the proper
JavaScript behavior and with additional settings.

\chapter{Search}\label{search}

Liferay stores its information in a database. If you need to search for
data, why not search the database directly? Why add the complexity of a
search engine? Database table merges are expensive! Documents in a
search index often contain searchable fields from multiple tables in the
database.

Searching with a search engine provides access to features such as
relevance and scoring. Database searches do not support features like
fuzzy searching or any type of relevancy. Moreover, when searching with
a search engine, you can apply algorithms such as ``More Like This'' to
obtain similar content. Search engines also support geolocation,
faceting of search results, and multi-lingual searching.

\section{Basic Search Concepts}\label{basic-search-concepts}

\textbf{Indexing}: During indexing, a document is sent to the search
engine. This document contains a collection of fields of various types
(string, etc). The search engine processes each field within the
document. For each field, the search engine determines whether it needs
to simply store the field or if it needs to undertake special analysis
(index time analysis). Index time analysis can be configured for each
field (see Mapping Definitions).

For fields requiring analysis, the search engine first tokenizes the
value to obtain individual words or tokens. Following tokenization, the
search engine passes each token through a series of analyzers. Analyzers
perform different functions. Some remove common words or stop words
(e.g., ``the'', ``and'', ``or'') while others perform operations like
lowercasing all characters.

\textbf{Searching}: Searching involves sending a search query and
obtaining results (a.k.a. hits) from the search engine. The search query
may be comprised of both queries and filters (more on this later). Each
query or filter specifies a field to search within and the value to
match against. Upon receiving the search query, the search engine
iterates through each field within the nested queries and filters.
During this process, the engine may perform special analysis prior to
executing the query (search time analysis). Search time analysis can be
configured for each field (see Mapping Definitions).

\subsection{Mapping Definitions}\label{mapping-definitions}

Most search engines can be semi-intelligent in automatically deciphering
how to process documents passed to them. However, there are many
instances where it's desirable to explicitly configure how a field
should be processed.

Mappings allow users to control how a search engine processes a given
field. For instance, for all field names that end in ``es\_ES'', we want
to process the field values as Spanish, removing any common Spanish
words like ``si''.

In Elasticsearch and Solr, the two supported search engines for Liferay
Portal, we define mappings using \texttt{liferay-type-mappings.json} and
\texttt{schema.xml}, respectively.

The Elasticsearch mapping JSON file can be seen here:
\url{https://github.com/liferay/liferay-portal/blob/7.0.6-ga7/modules/apps/foundation/portal-search/portal-search-elasticsearch/src/main/resources/META-INF/mappings/liferay-type-mappings.json}

The Solr \texttt{schema.xml} can be seen here:
\url{https://github.com/liferay/liferay-portal/blob/7.0.6-ga7/modules/apps/portal-search-solr/portal-search-solr/src/main/resources/META-INF/resources/schema.xml}

These are default mapping files that are shipped with the product. You
can further customize these mappings to fit your needs. For example, you
might want to use a special analyzer for a custom inventory number
field.

\subsection{Liferay Search
Infrastructure}\label{liferay-search-infrastructure}

Search engines already provide native APIs. Why does Liferay provide
search infrastructure to wrap search engines? Liferay's search
infrastructure ensures that documents are indexed with fields Liferay
needs:

\texttt{entryClassName}, \texttt{entryClassPK}, \texttt{assetTagNames},
\texttt{assetCategories}, \texttt{companyId}, \texttt{groupId}, staging
status, etc.

Liferay's search infrastructure ensures that the proper set of filters
are added to search queries to scope results. Liferay's search
infrastructure also provides capabilities like permission checking and
creating hit summaries for display.

\section{Liferay Search API}\label{liferay-search-api}

Liferay Portal's Search API allows users to build a search query,
execute it, and obtain search hits that match the query.

\subsection{Queries and Filters}\label{queries-and-filters}

Elasticsearch and Solr do not make API level distinctions between
queries and filters. However, Liferay's API explicitly provides two sets
of APIs, one for queries and one for filters.

A \emph{filter} asks a yes or no question for every document. A
\emph{query} asks the same yes or no question AND how well (score) a
document matches the specified criteria. For instance, a filter might
ask is the status field equal to staging or live. A query might ask if
the document's content field field contains the words ``Liferay'',
``Content'', ``Management'', and how relevant the content of the
document is to the search terms.

With respect to performance, filters are much faster since the documents
that match a filter can be easily cached. Queries not only match
documents but also calculate scores. Liferay uses filters and queries
together so that filters can reduce the number of matched documents
before the query examines them for scoring.

Liferay's Search API supports the following types of queries:

Full text queries:

\begin{itemize}
\tightlist
\item
  MatchQuery: Full text matching, scored by relevance.
\item
  MultiMatchQuery: MatchQuery over several fields.
\item
  StringQuery: Uses Lucene query syntax
\end{itemize}

Term queries:

\begin{itemize}
\tightlist
\item
  TermQuery: Exact matching on keyword fields and indexed terms
\item
  TermRangeQuery: TermQuery with a range
\item
  WildcardQuery: Wildcard (* and ?) matching on keyword fields and
  indexed terms
\item
  FuzzyQuery: Scrambles characters in input before matching
\end{itemize}

Compound queries:

\begin{itemize}
\tightlist
\item
  BooleanQuery: Allows a combo of several query types. Individual
  queries are added as clauses with SHOULD \textbar{} MUST \textbar{}
  MUST\_NOT.
\item
  DisMaxQuery
\end{itemize}

Other queries:

\begin{itemize}
\tightlist
\item
  MoreLikeThisQuery
\item
  MatchAllQuery: Matches all documents
\end{itemize}

Liferay's Search API supports the following types of filters:

Term filters:

\begin{itemize}
\tightlist
\item
  TermFilter
\item
  TermsFilter
\item
  PrefixFilter
\item
  ExistsFilter
\item
  MissingFilter
\item
  RangeTermFilter
\end{itemize}

Compound filters:

\begin{itemize}
\tightlist
\item
  BooleanFilter
\end{itemize}

Geo filters: (Geolocation filters help filter documents based on the
latitude and longitude fields)

\begin{itemize}
\tightlist
\item
  GeoDistanceFilter
\item
  GeoDistanceRangeFilter
\item
  GeoBoundingBoxFilter
\item
  GeoPolygonFilter
\end{itemize}

Other filters:

\begin{itemize}
\tightlist
\item
  QueryFilter: Turns any query into a filter. E.g., can a BooleanQuery
  into a BooleanFilter
\item
  MatchAllFilter: Matches all documents
\end{itemize}

\subsection{Aggregations}\label{aggregations}

Aggregations help summarize search results. Individual aggregations can
be used to create more complex aggregations. Facets are a type of
aggregation. In addition to facets, Liferay also provides group by and
statistics aggregations.

Facets:

\begin{itemize}
\tightlist
\item
  Date Range Facet
\item
  Modified Date Facet
\item
  MultiValue Facet
\item
  Range Facet
\item
  Scope Facet
\item
  Simple Facet
\end{itemize}

Statistics:

Stats provides general statistics for a desired field within the
returned search results:

\begin{itemize}
\tightlist
\item
  count
\item
  max
\item
  mean
\item
  min
\item
  missing
\item
  standard deviation
\item
  sum
\item
  sum of squares
\end{itemize}

GroupBy:

GroupBy is a powerful feature that allows you to group search results
based on a particular field. For example, suppose you wish to group the
search results based on the asset type (e.g., web content article,
document, blog post, etc.). To do so, you would create a search query
that contains a GroupBy aggregation with the field ``entryClassName''.

Other attributes you can specify:

\begin{itemize}
\tightlist
\item
  The maximum number of results in each group
\item
  Special sorting for the grouped results
\end{itemize}

\subsection{Indexers}\label{indexers}

There is an Indexer for each asset in the portal (e.g.,
DLFileEntryIndexer). This allows each asset to control what fields are
indexed and what filters are applied to the search query.

Generally, when you create an asset that requires indexing, you would
implement a new Indexer by extending
\texttt{com.liferay.portal.kernel.search.BaseIndexer\textless{}T\textgreater{}}.

For more information, consult the Javadocs for
\texttt{com.liferay.portal.kernel.search.Indexer\textless{}T\textgreater{}}
and
\texttt{com.liferay.portal.kernel.search.BaseIndexer\textless{}T\textgreater{}}:
\href{@platform-ref@/7.0-latest/javadocs}{@platform-ref@/7.0-latest/javadocs}

\subsection{IndexerPostProcessor}\label{indexerpostprocessor}

The IndexerPostProcessor allows developers to customize

\begin{itemize}
\tightlist
\item
  Search queries before they are sent to the search engine
\item
  Documents before they are sent to the search engine
\item
  Summaries for results before they are returned to the end users
\end{itemize}

This is the preferred way to customize existing Indexers.

Follow these steps to add a new IndexerPostProcessor:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Implement the interface
  \texttt{com.liferay.portal.kernel.search.IndexerPostProcessor}.
\item
  Publish it to the OSGi registry with the property
  \texttt{indexer.class.name}
\end{enumerate}

\texttt{postProcessContextQueryBooleanFilter} allows the developer to
customize the filters created by the
\texttt{Indexer.getFacetBooleanFilter}. These filters are generally
applied to the fields:

\begin{itemize}
\tightlist
\item
  entryClassName
\item
  relatedClassName
\item
  relatedEntryClassNames
\item
  permissions related fields (e.g., roleId, groupId, etc.).
\end{itemize}

\texttt{postProcessFullQuery} allows the developer to customize the
overall search query which includes

\begin{itemize}
\tightlist
\item
  Filters for any default facets, including those for

  \begin{itemize}
  \tightlist
  \item
    asset category ids
  \item
    asset tag names
  \item
    entry class names
  \item
    folderIds
  \item
    groupIds
  \item
    layoutUUIDs
  \item
    userId
  \end{itemize}
\item
  The keyword search queries. By default, this includes searches for the
  fields

  \begin{itemize}
  \tightlist
  \item
    description
  \item
    title
  \item
    userName
  \item
    keyword
  \item
    searchable Expando fields
  \item
    localized fields for assetCategoryTitles
  \end{itemize}
\end{itemize}

\subsection{HitsProcessor}\label{hitsprocessor}

\texttt{com.liferay.portal.kernel.search.HitsProcessor} allows
developers to preprocess the results from the search engine before they
are returned to the user. This allows for features like

\begin{itemize}
\tightlist
\item
  spell checking
\item
  suggesting related queries
\item
  indexing search queries that have returned high quality search results
\end{itemize}

HitsProcessors are stored in a HitsProcessorRegistry and sorted by their
\texttt{sort.order}. Essentially, we have a chain of responsibility held
by the HitsProcessorRegistry.

By default, the HitsProcessor order is:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \texttt{CollatedSpellCheckHitsProcessor}

  \begin{itemize}
  \tightlist
  \item
    Performs a spell check if the minimum score for search results is
    less than a given threshold
  \item
    Number of results defined in portal.properties
    (index.search.collated.spell.check.result.scores.threshold)
  \end{itemize}
\item
  \texttt{AlternateKeywordQueryHitsProcessor}

  \begin{itemize}
  \tightlist
  \item
    Automatically issue a query using the suggested keywords from the
    \texttt{CollatedSpellCheckHitsProcessor}.
  \end{itemize}
\item
  \texttt{QueryIndexingHitsProcessor}

  \begin{itemize}
  \tightlist
  \item
    If query indexing is enabled
    (\texttt{index.search.query.indexing.enabled} in
    \texttt{portal.properties}), then index the search query if the
    number of hits has exceeded a configured quantity
    (\texttt{index.search.query.indexing.threshold} in
    \texttt{portal.properties}).
  \end{itemize}
\item
  \texttt{QuerySuggestionHitsProcessor}

  \begin{itemize}
  \tightlist
  \item
    If number of results returned has not met a given threshold
    (\texttt{index.search.query.suggestion.scores.threshold} in
    \texttt{portal.properties}), then suggest other potential queries
    that previous searches have yielded more results
    (\texttt{index.search.query.suggest.max} in
    \texttt{portal.properties}).
  \end{itemize}
\end{enumerate}

\subsection{Suggestions}\label{suggestions}

Suggestions are a powerful feature where the search engine can suggest
``similar'' results for a given query. For instance, suppose you have a
blog entry with the title ``Liferay Portal Content Management'' and you
would like to find other content with similar titles.

\texttt{com.liferay.portal.kernel.search.IndexSearcher} provides methods
to access suggestion capabilities. It implements
\texttt{com.liferay.portal.kernel.search.suggest.QuerySuggester}.

The QuerySuggester provides facilities for

\begin{itemize}
\tightlist
\item
  Spell Checking
\item
  Related search queries
\item
  General Suggester requests
\end{itemize}

\subsubsection{Spell Checking}\label{spell-checking}

For Elasticsearch, spell checking heavily relies on the suggester API: -
Dictionary words are analyzed by their language specific analyzer and
indexed. - \texttt{TermSuggester} is used to provide suggestions for
words based on specific \texttt{StringDistance} algorithms.

Solr's implementation of \texttt{Suggester} is less flexible and
sophisticated. Solr's spell checking algorithm is based strictly on
NGrams and does not handle Asian languages very well.

Note that using the search engine's spell checking functionality doesn't
guarantee returned results. Instead, spell checking seeks to ensure that
the query is correct.

\subsubsection{Similar Search Queries}\label{similar-search-queries}

Like spell checking, similar search queries has a more robust
implementation in Elasticsearch. The Elasticsearch implementation uses
phrase suggesters on indexed keyword search queries.

Solr's similar search queries implementation is again based on tokenized
NGrams.

\subsubsection{Other Suggesters}\label{other-suggesters}

You can also send custom Suggester requests and get SuggesterResults
back from the search engine by calling
\texttt{QuerySuggester.suggest(SearchContext,\ Suggester)}.

\section{Search Adapter API}\label{search-adapter-api}

Search adapters convert Liferay Portal's API to the underlying search
engine's API. This pluggable architecture allows customers to more
easily integrate with other search engines. Liferay ships with two
adapters: an Elasticsearch adapter and a Solr adapter.

The search adapter API has 2 primary interfaces:

\begin{itemize}
\tightlist
\item
  \texttt{IndexSearcher}: invoked for all search operations
\item
  \texttt{IndexWriter}: used when adding, updating, or deleting
  documents from the search engine.
\end{itemize}

\section{Transactional Search}\label{transactional-search}

Search engines do not operate within a traditional JTA/JTS transaction.
In place of ``real'' transactions, Liferay buffers indexing operations
(delete, update) until either the surrounding transaction has been
committed or we have exceeded the max buffer size. The buffered indexer
requests are abandoned in the event of transaction rollback. This gives
us some semblance of transactional control, except in scenarios where we
have large batches of commits (e.g., exceeds \texttt{maxBufferSize}).

When \texttt{maxBufferSize} has been exceeded, the search infrastructure
executes buffered indexer requests to free up space in the buffer.

Buffered \texttt{IndexerRequests} always execute in FIFO order. There is
no collation of \texttt{IndexerRequests} in the buffer.

You can activate / deactivate and set the buffer size by configuring
\texttt{com.liferay.portal.search.configuration.IndexerRegistryConfiguration}.
By default, the buffering is activated and the max buffer size is 200.

For a list of buffered methods, see
\texttt{com.liferay.portal.kernel.search.Indexer}. All methods annotated
with \texttt{@Bufferable} are subject to potential buffering.

\section{Customizing Liferay Search}\label{customizing-liferay-search}

There are several extension points available for users to customize. The
most obvious is the ability to add a new search engine adapter.

\subsection{Adding a new Search Engine
Adapter}\label{adding-a-new-search-engine-adapter}

To add a new search engine adapter, developers must create the following
components and publish them to Liferay's OSGi registry:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Implement a new IndexSearcher that should convert the Liferay Search
  objects to the underlying search engine's dialects:

  \begin{itemize}
  \tightlist
  \item
    QueryTranslator: Translates Liferay Queries to the native search
    engine's queries.
  \item
    FilterTranslator: Translates Liferay filters into native search
    engine's filters.
  \item
    GroupByTranslator: Translates the GroupBy aggregation to the search
    engine's group by top hits aggregation.
  \item
    StatsTranslator: Translates Stats request to the appropriate search
    engine's statistics aggregation.
  \item
    SuggesterTranslator: Translates suggestion requests to the
    appropriate search engine's suggester API.
  \end{itemize}
\item
  Implement a new IndexWriter that should

  \begin{itemize}
  \tightlist
  \item
    Convert the Liferay Document to a format understood by the
    underlying search engine's Document Format.
  \item
    Use the search engine's API to update, add, and delete documents.
  \end{itemize}
\item
  Implement a new SearchEngineConfigurator that should extend
  \texttt{AbstractSearchEngineConfigurator} to perform proper wiring.
\item
  Implement a new SearchEngine that

  \begin{itemize}
  \tightlist
  \item
    Should extend from \texttt{BaseSearchEngine} to perform any search
    engine specific initialization.
  \item
    Should be published to Liferay's OSGi registry along with the
    property \texttt{search.engine.id={[}searchEngineId{]}}.
  \end{itemize}
\end{enumerate}

\subsection{Customizing
IndexerRequestBufferOverflowHandler}\label{customizing-indexerrequestbufferoverflowhandler}

\texttt{IndexerRequestBufferOverflowHandler} controls how the search
infrastructure handles situations where buffered indexer requests has
exceeded the configured maximum buffer size.

To customize, implement an \texttt{IndexerRequestBufferOverflowHandler}
and publish it to Liferay's OSGi registry.

\subsection{Customizing
HitsProcessors}\label{customizing-hitsprocessors}

\texttt{com.liferay.portal.kernel.hits.HitsProcessor} objects are held
in a \texttt{com.liferay.portal.kernel.hits.HitsProcessorRegistry}. To
add a new HitsProcessor, simply implement the interface and publish to
the OSGi registry with the property \texttt{sort.order}.

\chapter{Application Security}\label{application-security}

Nothing has received more attention on the web in recent years than
security. Liferay has a robust security model for you to use in your
applications, and it supports a wide variety of security features. In
this section, you can learn about these features:

\begin{itemize}
\tightlist
\item
  Resources, Roles, and Permissions
\item
  Custom SSO Providers
\item
  Authentication Pipelines
\item
  Service Access Policies
\item
  Authentication Verifiers
\end{itemize}

\section{Adding Permissions to
Resources}\label{adding-permissions-to-resources}

Public bulletin boards are great. Anyone can inform others of just about
anything. On the other hand, \emph{anyone} can post just about
\emph{anything} on the bulletin board. Some of this content might not be
relevant to the community. Other content might be inappropriate. Thus,
you sometimes need a way to restrict who can post or access content.

Fortunately, no matter what your portlet does, access to it and to its
content can be controlled with permissions. Read on to learn about
Liferay's permissions system and how to add permissions to your
application.

\subsection{Liferay's Permission
System}\label{liferays-permission-system}

Liferay's permission system uses a flexible mechanism that defines the
actions that a given user can perform within the context of Liferay or a
specific application. Liferay developers break down the operations that
can be performed in Liferay or in a certain application into distinct
\emph{actions}. The act of granting the ability to perform an action to
a specific role is the act of granting a \emph{permission}. In Liferay,
permissions are not granted to directly to users. Instead, permissions
are granted to roles. Roles, in turn, can be assigned to specific users,
sites, organizations, or user groups.

Developers need to define the different types of operations that are
required to suit the business logic of their applications. They don't
need to worry about which users will receive which permissions. Once the
actions have been determined and configured, portal administrators can
grant permissions to perform those actions to users, sites,
organizations, or user groups by assigning roles. Administrators can use
the portal's administration tools to grant permissions to roles or they
can use the permissions UIs of individual portlets.

In this tutorial, you'll learn how to use Liferay's permissions system
to provide Liferay administrators the same level of control over
permissions that they have over the out-of-the-box Liferay applications.

Before proceeding, make sure you understand these critical terms:

\textbf{Action}: An operation that can be performed by a Liferay user.
For example, actions that be performed on the Bookmarks application
include \texttt{ADD\_TO\_PAGE}, \texttt{CONFIGURATION}, and
\texttt{VIEW}. Actions that can be performed with respect to Bookmarks
entry entity include \texttt{ADD\_ENTRY}, \texttt{DELETE},
\texttt{PERMISSIONS}, \texttt{UPDATE}, and \texttt{VIEW}.

\textbf{Resource}: A generic representation of any application or entity
in the portal on which an action can be performed. Resources are used
for permission checking. For example, resources within a Liferay
instance could include the RSS application with instance ID
\texttt{hF5f}, a globally scoped Wiki page, a Bookmarks entry of the
site X, and a Message Boards post with the ID \texttt{5052}.

\textbf{Permission}: An action that can be performed on a resource. In
Liferay's database, resources and actions are saved in pairs. (Each
entry in the \texttt{ResourceAction} table contains both the name of a
portlet or entity and the name of an action.) For example, the
\texttt{VIEW} action with respect to \emph{viewing the Bookmarks
application} is associated with the
\texttt{com\_liferay\_bookmarks\_web\_portlet\_BookmarksPortlet} portlet
ID. The \texttt{VIEW} actions with respect to \emph{viewing a Bookmarks
Folder} or \emph{viewing a Bookmarks entry} are associated with the
\texttt{com.liferay.bookmarks.model.BookmarksFolder} and
\texttt{com.liferay.bookmarks.model.BookmarksEntry} entities,
respectively.

There are two kinds of resources in Liferay: \emph{portlet resources}
and \emph{model resources}. Portlet resources represent portlet
applications. The names of portlet resources typically correspond to the
IDs of the portlets themselves. For example, the fully qualified name of
the Bookmarks portlet class is
\texttt{com.liferay.bookmarks.web.portlet.BookmarksPortlet}. Its ID is
defined in the \texttt{BookmarksPortletKeys} class like this:

\begin{verbatim}
public static final String BOOKMARKS =
    "com_liferay_bookmarks_web_portlet_BookmarksPortlet";
\end{verbatim}

This \texttt{BOOKMARKS} string is used when declaring portlet resources
in \texttt{default.xml} files, as discussed below.

There are two kinds of resources in Liferay: \emph{portlet resources}
and \emph{model resources}. Portlet resources represent portlets. The
names of portlet resources are the portlet IDs from the portlets'
\texttt{portlet.xml} files (or in the case of core portlets, Liferay's
\texttt{portlet-custom.xml}). Model resources refer to entities within
Liferay. The names of model resources are the fully qualified class
names of the entities they represent. In the XML displayed below,
permission implementations are first defined for the \emph{portlet}
resource and then for the \emph{model} resources.

Model resources represent entities within Liferay, such as bookmarks
folders or bookmarks entries. The names of model resources are the fully
qualified class names of the entities they represent. In the
\texttt{default.xml} files displayed below, permission implementations
are first defined for the \emph{portlet} resource and then for the
\emph{model} resources.

\noindent\hrulefill

\textbf{Note:} For each resource, there are four scopes to which the
permissions can be applied: company, group, group-template, or
individual. See the Javadoc of
\href{@platform-ref@/7.0-latest/javadocs/portal-impl/}{ResourcePermissionImpl}
for more information.

\noindent\hrulefill

You can add permissions to your custom portlets using four easy steps
(also known as \emph{DRAC}):

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Define all resources and their permissions.
\item
  Register all defined resources in the permissions system. This is also
  known as \emph{adding resources}.
\item
  Associate the necessary permissions with resources.
\item
  Check permission before returning resources.
\end{enumerate}

\subsection{Define All Resources and
Permissions}\label{define-all-resources-and-permissions}

Here you'll learn the first step, in which you define your resources and
their actions. The Bookmarks application is used here to demonstrate how
to define portlet resources and model resources. Open the
\texttt{default.xml} file in \texttt{bookmarks-web} module of the
Bookmarks application:
\href{https://github.com/liferay/liferay-portal/blob/7.0.x/modules/apps/collaboration/bookmarks/bookmarks-web/src/main/resources/resource-actions/default.xml}{default.xml}.
There, you'll see the following mapping of resources to actions:

\begin{verbatim}
<?xml version="1.0"?>
<!DOCTYPE resource-action-mapping PUBLIC "-//Liferay//DTD Resource Action Mapping 7.0.0//EN" "http://www.liferay.com/dtd/liferay-resource-action-mapping_7_0_0.dtd">

<resource-action-mapping>
    <portlet-resource>
        <portlet-name>com_liferay_bookmarks_web_portlet_BookmarksAdminPortlet</portlet-name>
        <permissions>
            <supports>
                <action-key>ACCESS_IN_CONTROL_PANEL</action-key>
                <action-key>CONFIGURATION</action-key>
                <action-key>VIEW</action-key>
            </supports>
            <site-member-defaults>
                <action-key>VIEW</action-key>
            </site-member-defaults>
            <guest-defaults>
                <action-key>VIEW</action-key>
            </guest-defaults>
            <guest-unsupported>
                <action-key>ACCESS_IN_CONTROL_PANEL</action-key>
                <action-key>CONFIGURATION</action-key>
            </guest-unsupported>
        </permissions>
    </portlet-resource>
    <portlet-resource>
        <portlet-name>com_liferay_bookmarks_web_portlet_BookmarksPortlet</portlet-name>
        <permissions>
            <supports>
                <action-key>ADD_TO_PAGE</action-key>
                <action-key>CONFIGURATION</action-key>
                <action-key>VIEW</action-key>
            </supports>
            <site-member-defaults>
                <action-key>VIEW</action-key>
            </site-member-defaults>
            <guest-defaults>
                <action-key>VIEW</action-key>
            </guest-defaults>
            <guest-unsupported>
                <action-key>CONFIGURATION</action-key>
            </guest-unsupported>
        </permissions>
    </portlet-resource>
</resource-action-mapping>
\end{verbatim}

This \texttt{default.xml} defines portlet resources. The bookmarks
service module also contains a
\href{https://github.com/liferay/liferay-portal/blob/7.0.x/modules/apps/collaboration/bookmarks/bookmarks-service/src/main/resources/META-INF/resource-actions/default.xml}{default.xml}
file:

\begin{verbatim}
<?xml version="1.0"?>
<!DOCTYPE resource-action-mapping PUBLIC "-//Liferay//DTD Resource Action Mapping 7.0.0//EN" "http://www.liferay.com/dtd/liferay-resource-action-mapping_7_0_0.dtd">

<resource-action-mapping>
    <model-resource>
        <model-name>com.liferay.bookmarks</model-name>
        <portlet-ref>
            <portlet-name>com_liferay_bookmarks_web_portlet_BookmarksPortlet</portlet-name>
            <portlet-name>com_liferay_bookmarks_web_portlet_BookmarksAdminPortlet</portlet-name>
        </portlet-ref>
        <root>true</root>
        <weight>1</weight>
        <permissions>
            <supports>
                <action-key>ADD_ENTRY</action-key>
                <action-key>ADD_FOLDER</action-key>
                <action-key>PERMISSIONS</action-key>
                <action-key>SUBSCRIBE</action-key>
                <action-key>VIEW</action-key>
            </supports>
            <site-member-defaults>
                <action-key>ADD_ENTRY</action-key>
                <action-key>SUBSCRIBE</action-key>
                <action-key>VIEW</action-key>
            </site-member-defaults>
            <guest-defaults>
                <action-key>VIEW</action-key>
            </guest-defaults>
            <guest-unsupported>
                <action-key>ADD_ENTRY</action-key>
                <action-key>ADD_FOLDER</action-key>
                <action-key>PERMISSIONS</action-key>
                <action-key>SUBSCRIBE</action-key>
            </guest-unsupported>
        </permissions>
    </model-resource>
    <model-resource>
        <model-name>com.liferay.bookmarks.model.BookmarksFolder</model-name>
        <portlet-ref>
            <portlet-name>com_liferay_bookmarks_web_portlet_BookmarksPortlet</portlet-name>
            <portlet-name>com_liferay_bookmarks_web_portlet_BookmarksAdminPortlet</portlet-name>
        </portlet-ref>
        <weight>2</weight>
        <permissions>
            <supports>
                <action-key>ACCESS</action-key>
                <action-key>ADD_ENTRY</action-key>
                <action-key>ADD_SUBFOLDER</action-key>
                <action-key>DELETE</action-key>
                <action-key>PERMISSIONS</action-key>
                <action-key>SUBSCRIBE</action-key>
                <action-key>UPDATE</action-key>
                <action-key>VIEW</action-key>
            </supports>
            <site-member-defaults>
                <action-key>ADD_ENTRY</action-key>
                <action-key>SUBSCRIBE</action-key>
                <action-key>VIEW</action-key>
            </site-member-defaults>
            <guest-defaults>
                <action-key>VIEW</action-key>
            </guest-defaults>
            <guest-unsupported>
                <action-key>ADD_ENTRY</action-key>
                <action-key>ADD_SUBFOLDER</action-key>
                <action-key>UPDATE</action-key>
            </guest-unsupported>
        </permissions>
    </model-resource>
    <model-resource>
        <model-name>com.liferay.bookmarks.model.BookmarksEntry</model-name>
        <portlet-ref>
            <portlet-name>com_liferay_bookmarks_web_portlet_BookmarksPortlet</portlet-name>
            <portlet-name>com_liferay_bookmarks_web_portlet_BookmarksAdminPortlet</portlet-name>
        </portlet-ref>
        <weight>3</weight>
        <permissions>
            <supports>
                <action-key>DELETE</action-key>
                <action-key>PERMISSIONS</action-key>
                <action-key>SUBSCRIBE</action-key>
                <action-key>UPDATE</action-key>
                <action-key>VIEW</action-key>
            </supports>
            <site-member-defaults>
                <action-key>SUBSCRIBE</action-key>
                <action-key>VIEW</action-key>
            </site-member-defaults>
            <guest-defaults>
                <action-key>VIEW</action-key>
            </guest-defaults>
            <guest-unsupported>
                <action-key>SUBSCRIBE</action-key>
                <action-key>UPDATE</action-key>
            </guest-unsupported>
        </permissions>
    </model-resource>
</resource-action-mapping>
\end{verbatim}

This \texttt{default.xml} file defines model resources.

The \texttt{\textless{}portlet-resource\textgreater{}} tag is used to
define actions that can be taken with respect to the portlet window. For
the Bookmarks application, such actions include these:

\begin{itemize}
\tightlist
\item
  \texttt{ADD\_TO\_PAGE}: \emph{Add} the application to a page
\item
  \texttt{CONFIGURATION}: \emph{Access} the application's Configuration
  window
\item
  \texttt{VIEW}: \emph{View} the application
\end{itemize}

All the supported actions are defined in the
\texttt{\textless{}supports\textgreater{}} tag, a sub-tag of the
\texttt{\textless{}permissions\textgreater{}} tag (which is itself a
sub-tag of the \texttt{\textless{}portlet-resource\textgreater{}} tag:

\begin{verbatim}
<supports>
    <action-key>ADD_TO_PAGE</action-key>
    <action-key>CONFIGURATION</action-key>
    <action-key>VIEW</action-key>
</supports>
\end{verbatim}

The default permissions for site members are defined in the
\texttt{\textless{}site-member-defaults\textgreater{}} tag. In the case
of the Bookmarks application, site members can view any Bookmarks
application in the site:

\begin{verbatim}
<site-member-defaults>
    <action-key>VIEW</action-key>
</site-member-defaults>
\end{verbatim}

Similarly, the default permissions for guests are defined in the
\texttt{\textless{}guest-defaults\textgreater{}} tag. Guests can also
view any Bookmarks application in the site:

\begin{verbatim}
<guest-defaults>
    <action-key>VIEW</action-key>
</guest-defaults>
\end{verbatim}

The \texttt{\textless{}guest-unsupported\textgreater{}} tag specifies
permissions forbidden to guests. By default, guests cannot access the
Bookmarks application in the Control Panel nor can they access the
Bookmarks's configuration window:

\begin{verbatim}
<guest-unsupported>
    <action-key>ACCESS_IN_CONTROL_PANEL</action-key>
    <action-key>CONFIGURATION</action-key>
</guest-unsupported>
\end{verbatim}

With respect to model resources, guests are forbidden from adding
bookmarks entries and bookmarks folders. Guests are also not permitted
to edit permissions or subscribe. Remember, these are just default
permissions that can be changed by administrators. See the following
entry in the first \texttt{\textless{}model-resource\textgreater{}} tag:

\begin{verbatim}
<guest-unsupported>
    <action-key>ADD_ENTRY</action-key>
    <action-key>ADD_FOLDER</action-key>
    <action-key>PERMISSIONS</action-key>
    <action-key>SUBSCRIBE</action-key>
</guest-unsupported>
\end{verbatim}

The \texttt{\textless{}model-resource\textgreater{}} tag is used to
define actions that can be performed with respect to models, also known
as entities. There are two kinds of actions in Liferay: \emph{top-level
actions} and \emph{resource actions}. Top-level actions are not applied
to a particular resource. For example, the action of adding a new entity
is not applied to a particular resource, so it's considered a top-level
action. The first \texttt{\textless{}model-resource\textgreater{}} tag
defines adding bookmark entry and bookmark folder resources as top-level
actions:

\begin{verbatim}
<supports>
    <action-key>ADD_ENTRY</action-key>
    <action-key>ADD_FOLDER</action-key>
</supports>
\end{verbatim}

The second and third \texttt{\textless{}model-resource\textgreater{}}
tags define resource actions that can be applied to the
\texttt{BookmarksFolder} and \texttt{BookmarksEntry} entities,
respectively. For example, the permissions for the following actions are
defined with respect to the resource associated with the
\texttt{BookmarksEntry} entity:

\begin{verbatim}
<supports>
    <action-key>DELETE</action-key>
    <action-key>PERMISSIONS</action-key>
    <action-key>SUBSCRIBE</action-key>
    <action-key>UPDATE</action-key>
    <action-key>VIEW</action-key>
</supports>
\end{verbatim}

Similarly, the permissions for the following actions are defined with
respect to the resource associated with the \texttt{BookmarksFolder}
entity:

\begin{verbatim}
<supports>
    <action-key>ACCESS</action-key>
    <action-key>ADD_ENTRY</action-key>
    <action-key>ADD_SUBFOLDER</action-key>
    <action-key>DELETE</action-key>
    <action-key>PERMISSIONS</action-key>
    <action-key>SUBSCRIBE</action-key>
    <action-key>UPDATE</action-key>
    <action-key>VIEW</action-key>
</supports>
\end{verbatim}

In each \texttt{\textless{}model-resource\textgreater{}} tag, notice
that the model name must be defined. The
\texttt{\textless{}model-name\textgreater{}} must be either the
fully-qualified name of a package or of an entity class. For example,
\texttt{com.liferay.bookmarks} is the name of a package and
\texttt{com.liferay.bookmarks.model.BookmarksEntry} is the name of an
entity class. Using a package is the recommended convention for
permissions that refer to top-level actions:

\begin{verbatim}
<model-name>com.liferay.bookmarks</model-name>
\end{verbatim}

The \texttt{ADD\_ENTRY} and \texttt{ADD\_FOLDER} permissions are defined
this way since they're top-level actions. For resource actions, the
entity class is specified:

\begin{verbatim}
<model-name>com.liferay.bookmarks.model.BookmarksEntry</model-name>
\end{verbatim}

The \texttt{\textless{}portlet-ref\textgreater{}} element comes next and
contains a \texttt{\textless{}portlet-name\textgreater{}} sub-tag.

\begin{verbatim}
<portlet-ref>
    <portlet-name>com_liferay_bookmarks_web_portlet_BookmarksPortlet</portlet-name>
    <portlet-name>com_liferay_bookmarks_web_portlet_BookmarksAdminPortlet</portlet-name>
</portlet-ref>
\end{verbatim}

The value of \texttt{\textless{}portlet-name\textgreater{}} references
the name of the portlet to which the model resource belongs. It's
possible for a model resource to belong to multiple portlets referenced
with multiple \texttt{\textless{}portlet-name\textgreater{}} elements.
This is the case here since both the Bookmarks application and the
Bookmarks Admin application can be used to perform actions on bookmark
entries.

The \texttt{\textless{}supports\textgreater{}},
\texttt{\textless{}site-member-defaults\textgreater{}},
\texttt{\textless{}guest-defaults\textgreater{}}, and
\texttt{\textless{}guest-unsupported\textgreater{}} tags work the same
way in the \texttt{\textless{}model-resource\textgreater{}} tag as they
do in the \texttt{\textless{}portlet-resource\textgreater{}} tag. The
\texttt{\textless{}supports\textgreater{}} tag lets you specify a list
of supported actions that require permission to perform. The
\texttt{\textless{}site-member-defaults\textgreater{}} tag and the
\texttt{\textless{}guest-defaults\textgreater{}} tags define default
permissions for site members and guests, respectively. And the
\texttt{\textless{}guest-unsupported\textgreater{}} tag specifies
permissions forbidden to guests.

After defining resource permissions for your portlet, you need to point
Liferay to the \texttt{default.xml} file that contains your definitions.
In Liferay's core, there are multiple permissions XML definition files
for various core Liferay portlets in the
\texttt{portal/portal-impl/src/resource-actions} directory. The
\texttt{default.xml} file in that folder contains pointers to the
definition files of the various applications. This excerpt from
Liferay's \texttt{default.xml} references the resource permission
definition files for all built-in Liferay portlets:

\begin{verbatim}
<?xml version="1.0"?>
<!DOCTYPE resource-action-mapping PUBLIC "-//Liferay//DTD Resource Action Mapping 7.0.0//EN" "http://www.liferay.com/dtd/liferay-resource-action-mapping_7_0_0.dtd">

<resource-action-mapping>
    <resource file="resource-actions/portal.xml" />
    <resource file="resource-actions/announcements.xml" />
    <resource file="resource-actions/asset.xml" />
    <resource file="resource-actions/blogs.xml" />
    ...
</resource-action-mapping>
\end{verbatim}

Your application's permissions XML file should be named
\texttt{default.xml} and should be placed in a directory in your
module's classpath. \texttt{src/resource-actions} is the standard
location. Once your project's \texttt{default.xml} file has been
created, you should create a properties file named
\texttt{portlet.properties} that contains a reference to your
permissions XML file. In your \texttt{portlet.properties} file, create a
property named \texttt{resource.actions.configs} with the relative path
to your portlet's resource-action mapping file
(e.g.~\texttt{default.xml}) as its value. Here's what this property
specification might look like:

\begin{verbatim}
resource.actions.configs=resource-actions/default.xml
\end{verbatim}

Your permissions XML file must contain a root
\texttt{resource-action-mapping} element. Check out a copy of the
Liferay source code from the
\href{https://github.com/liferay/liferay-portal}{Liferay Portal
repository} to see how resources and permissions are defined for core
Liferay portlets. Start by looking at the definition files found in the
\texttt{portal-impl/src/resource-actions} directory. For a simple
example of defining permissions in the context of a portlet plugin,
check out the \href{https://github.com/liferay/liferay-plugins}{Liferay
Plugins repository} and examine the portlet
\texttt{sample-permissions-portlet}.

\chapter{Authentication Pipelines}\label{authentication-pipelines}

The authentication process in Liferay DXP is a pipeline through which
users can be validated by one or several systems. Liferay DXP's
flexibility and extensibility makes it possible for you to make it
authenticate users to anything you wish, rather than be limited by what
it supports out of the box.

Here's how authentication works under most circumstances:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Users provide their credentials to the Login Portlet to begin an
  authenticated session in a browser.
\item
  Alternatively, credentials are provided to Liferay DXP's API
  endpoints, where they are sent in an HTTP BASIC Auth header.
\item
  Alternatively, credentials can be provided by another system. These
  are managed by \texttt{AutoLogin} components.
\item
  Credentials are checked by default against the database, but they can
  be delegated to other systems instead of or in addition to it. This is
  called an \emph{Authentication Pipeline}. You can add
  \texttt{Authenticator}s to the pipeline to support any system.
\item
  You can also customize Liferay DXP's Login Portlet to support whatever
  user interface any of these systems need. This gives you full
  flexibility over the entire authentication process.
\end{enumerate}

You can also support an authentication mechanism and/or accept
credentials from a system that Liferay DXP doesn't yet support. If you
don't like the user interface for signing in, you can replace it with
your own.

This set of tutorials guides you through these customizations. You'll
discover three kinds of customizations:

\begin{itemize}
\item
  Auto Login: the easiest of the three, this lets you authenticate to
  Liferay DXP using credentials provided in the HTTP header from another
  system.
\item
  Authentication Pipelines: if you need to check credentials against
  other systems instead of or in addition to Liferay DXP's database, you
  can create a pipeline.
\item
  Custom Login Portlet: if you want to change the user's sign-in
  experience completely, you can implement your own Login portlet.
\end{itemize}

Read on to discover how to customize your users' sign-in experience.

\section{Auto Login}\label{auto-login}

While Liferay DXP supports a wide variety of
\href{/docs/7-0/deploy/-/knowledge_base/d/liferay-portal-security}{authentication
mechanisms}, you may use a home-grown system or some other product to
authenticate users. To do so, you can write an Auto Login component to
support your authentication system.

Auto Login components can check if the request contains something (a
cookie, an attribute) that can be associated with a user in any way. If
the component can make that association, it can authenticate that user
to Liferay DXP.

\subsection{Creating an Auto Login
Component}\label{creating-an-auto-login-component}

Create a
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-modules-with-liferay-ide\#creating-component-classes}{Declarative
Services component}. The component should implement the
\texttt{com.liferay.portal.kernel.security.auto.login.AutoLogin}
interface. Here's an example template:

\begin{verbatim}
import com.liferay.portal.kernel.security.auto.login.AutoLogin;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.osgi.service.component.annotations.Component;

@Component(immediate = true)
public class MyAutoLogin implements Autologin {

    public String[] handleException(
            HttpServletRequest request, HttpServletResponse response,
            Exception e)
        throws AutoLoginException {

        /* This method is no longer used in the interface and can be 
      left empty */

    }

    public String[] login(
            HttpServletRequest request, HttpServletResponse response)
        throws AutoLoginException {

        /* Your Code Goes Here */

    }

}
\end{verbatim}

As you can see, you have access to the \texttt{HttpServletRequest} and
the \texttt{HttpServletResponse} objects. If your sign-on solution
places anything here that identifies a user, such as a cookie, an
attribute, or a parameter, you can retrieve it and take whatever action
you need to retrieve the user information and authenticate that user to
Liferay DXP.

For example, say that there's a request attribute that contains the
encrypted value of a user key in Liferay DXP. This can only be there if
the user has authenticated with a third party system that knew the value
of the user key, encrypted it, and added it as a request attribute. You
could write code that reads the value, decrypts it using the same
pre-shared key, and uses the value to look up and authenticate the user.

The \texttt{login} method is where this all happens. This method must
return a \texttt{String} array with three items in this order:

\begin{itemize}
\tightlist
\item
  The user ID
\item
  The user password
\item
  A boolean flag that's \texttt{true} if the password is encrypted and
  \texttt{false} if it's not (\texttt{Boolean.TRUE.toString()} or
  \texttt{Boolean.FALSE.toString()}).
\end{itemize}

Sending redirects is an optional \texttt{AutoLogin} feature. Since
\texttt{AutoLogin}s are part of the servlet filter chain, you have two
options. Both are implemented by setting attributes in the request. Here
are the attributes:

\begin{itemize}
\item
  \texttt{AutoLogin.AUTO\_LOGIN\_REDIRECT}: This key causes
  \texttt{AutoLoginFilter} to stop the filter chain's execution and
  redirect immediately to the location specified in the attribute's
  value.
\item
  \texttt{AutoLogin.AUTO\_LOGIN\_REDIRECT\_AND\_CONTINUE}: This key
  causes \texttt{AutoLoginFilter} to set the redirect and continue
  executing the remaining filters in the chain.
\end{itemize}

Auto Login components are useful ways of providing an authentication
mechanism to a system that Liferay DXP doesn't yet support. You can
write them fairly quickly to provide the integration you need.

\subsection{Related Topics}\label{related-topics-157}

\href{/docs/7-0/tutorials/-/knowledge_base/t/password-based-authentication-pipelines}{Password-Based
Authentication Pipelines}

\href{/docs/7-0/tutorials/-/knowledge_base/t/writing-a-custom-login-portlet}{Writing
a Custom Login Portlet}

\section{Password-Based Authentication
Pipelines}\label{password-based-authentication-pipelines}

By default, once a user submits credentials to Liferay DXP, those
credentials are checked against Liferay DXP's database, though you can
also delegate authentication to an LDAP server. To use some other system
in your environment instead of or in addition to checking credentials
against Liferay DXP's database, you can write an \texttt{Authenticator}
and insert it as a step in Liferay DXP's authentication pipeline.

Because the \texttt{Authenticator} is checked by the Login Portlet, you
can't use this approach if the user must be redirected to the external
system or needs a token to authenticate. In those cases, you should use
an \href{/docs/7-0/tutorials/-/knowledge_base/t/auto-login}{Auto Login}
or an
\href{/docs/7-0/deploy/-/knowledge_base/d/authentication-verifiers}{Auth
Verifier}.

\texttt{Authenticator}s let you do these things:

\begin{itemize}
\tightlist
\item
  Log into Liferay DXP with a username and password maintained in an
  external system
\item
  Make secondary user authentication checks
\item
  Perform additional processing when user authentication fails
\end{itemize}

Read on to learn how to create an \texttt{Authenticator}.

\subsection{Anatomy of an
Authenticator}\label{anatomy-of-an-authenticator}

\texttt{Authenticator}s are implemented for various steps in the
authentication pipeline. Here are the steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \texttt{auth.pipeline.pre}: Comes before default authentication to the
  Liferay DXP database. In this step, you can instruct Liferay DXP to
  skip credential validation against the Liferay DXP database.
  Implemented by \texttt{Authenticator}.
\item
  Default (optional) authentication to the Liferay DXP database.
\item
  \texttt{auth.pipeline.post}: Further (secondary, tertiary)
  authentication checks. Implemented by \texttt{Authenticator}.
\item
  \texttt{auth.failure}: Perform additional processing after
  authentication fails. Implemented by \texttt{AuthFailure}.
\end{enumerate}

To create an \texttt{Authenticator}, create a module and add a component
that implements the interface:

\begin{verbatim}
@Component(
    immediate = true, property = {"key=auth.pipeline.post"},
    service = Authenticator.class
)
public class MyCustomAuth implements Authenticator {

    public int authenticateByEmailAddress(
            long companyId, String emailAddress, String password,
            Map<String, String[]> headerMap, Map<String, String[]> parameterMap)
        throws AuthException {

return Authenticator.SUCCESS;
}

    public int authenticateByScreenName(
            long companyId, String screenName, String password,
            Map<String, String[]> headerMap, Map<String, String[]> parameterMap)
        throws AuthException {

return Authenticator.SUCCESS;
    }

    public int authenticateByUserId(
            long companyId, long userId, String password,
            Map<String, String[]> headerMap, Map<String, String[]> parameterMap)
        throws AuthException {

return Authenticator.SUCCESS;
    }
}
\end{verbatim}

This example has been stripped down so you can see its structure. First,
note the \texttt{@Component} annotation's contents:

\begin{itemize}
\tightlist
\item
  \texttt{immediate\ =\ true}: sets the component to start immediately
\item
  \texttt{key=auth.pipeline.post}: sets the \texttt{Authenticator} to
  run in the \texttt{auth.pipeline.post} phase. To run the
  \texttt{auth.pipeline.pre} phase, substitute
  \texttt{auth.pipeline.pre}.
\item
  \texttt{service\ =\ Authenticator.class}: implements the
  \texttt{Authenticator} service. All \texttt{Authenticator}s must do
  this.
\end{itemize}

The three methods below the annotation run based on how you've
configured authentication: by email address (the default), by screen
name, or by user ID. All the methods throw an \texttt{AuthException} in
case the \texttt{Authenticator} is unable to perform its task--perhaps
if the system it's authenticating against is unavailable or if some
dependency can't be found. The methods in this barebones example return
success in all cases. If you deploy its module, it has no effect.
Naturally, you'll want to provide more functionality. Next is an example
that shows you how to do that.

\subsection{Creating an Authenticator}\label{creating-an-authenticator}

This example is an \texttt{Authenticator} that only allows users whose
email addresses end with \emph{@liferay.com} or \emph{@example.com}. You
can implement this using one module that does everything. If you think
other modules might be able to use the functionality that validates the
email addresses, you might create two modules: one to implement the
\texttt{Authenticator} and one to validate email addresses. This example
shows the two module approach.

To create an \texttt{Authenticator}, create a module for your
implementation. The most appropriate Blade template for this is the
\href{/docs/7-0/reference/-/knowledge_base/r/using-the-service-template}{service
template}. Once you have the module, creating the \texttt{Activator} is
straightforward:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add the \texttt{@Component} annotation to bind your \texttt{Activator}
  to the appropriate authentication pipeline phase.
\item
  Implement the \texttt{Authenticator} interface and provide the
  functionality you need.
\item
  Deploy your module. If you're using
  \href{/docs/7-0/tutorials/-/knowledge_base/t/blade-cli}{Blade CLI}, do
  this via \texttt{blade\ deploy}.
\end{enumerate}

For this example, you'll do this twice: once for the email address
validator module and once for the \texttt{Authenticator} itself. The
\texttt{Authenticator} project contains the interface for the validator,
and the validator project contains the implementation. Here's what the
\texttt{Authenticator} module structure looks like:

\begin{figure}
\centering
\includegraphics{./images/auth-pipeline-authenticator-project.png}
\caption{The Authenticator module contains the validator's interface and
the authenticator.}
\end{figure}

Since the \texttt{Authenticator} is the most relevant, examine it first:

\begin{verbatim}
package com.liferay.docs.emailaddressauthenticator;

import java.util.Map;

import com.liferay.docs.emailaddressauthenticator.validator.EmailAddressValidator;
import com.liferay.portal.kernel.log.Log;
import com.liferay.portal.kernel.log.LogFactoryUtil;
import com.liferay.portal.kernel.security.auth.AuthException;
import com.liferay.portal.kernel.security.auth.Authenticator;
import com.liferay.portal.kernel.service.UserLocalService;

import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Reference;
import org.osgi.service.component.annotations.ReferenceCardinality;
import org.osgi.service.component.annotations.ReferencePolicy;

@Component(
    immediate = true,
    property = {"key=auth.pipeline.post"},
    service = Authenticator.class
)
public class EmailAddressAuthenticator implements Authenticator {

    @Override
    public int authenticateByEmailAddress(long companyId, String emailAddress,
            String password, Map<String, String[]> headerMap,
            Map<String, String[]> parameterMap) throws AuthException {
        
        return validateDomain(emailAddress);
    }

    @Override
    public int authenticateByScreenName(long companyId, String screenName,
            String password, Map<String, String[]> headerMap,
            Map<String, String[]> parameterMap) throws AuthException {
        
        String emailAddress = 
            _userLocalService.fetchUserByScreenName(companyId, screenName).getEmailAddress();
        
        return validateDomain(emailAddress);
    }

    @Override
    public int authenticateByUserId(long companyId, long userId,
            String password, Map<String, String[]> headerMap,
            Map<String, String[]> parameterMap) throws AuthException {
        
        String emailAddress = 
            _userLocalService.fetchUserById(userId).getEmailAddress();
        
        return validateDomain(emailAddress);
    }
    
    private int validateDomain(String emailAddress) throws AuthException {
        
        if (_emailValidator == null) {
            
            String msg = "Email address validator is unavailable, cannot authenticate user";            
            _log.error(msg);
            
            throw new AuthException(msg);
        }
        
        if (_emailValidator.isValidEmailAddress(emailAddress)) {        
            return Authenticator.SUCCESS;
        }
        return Authenticator.FAILURE;
    }
    
    @Reference
    private volatile UserLocalService _userLocalService;
    
    @Reference(
        policy = ReferencePolicy.DYNAMIC,
        cardinality = ReferenceCardinality.OPTIONAL
    )
    private volatile EmailAddressValidator _emailValidator;
    
    private static final Log _log = LogFactoryUtil.getLog(EmailAddressAuthenticator.class);
}
\end{verbatim}

This time, rather than stubs, the three authentication methods contain
functionality. The \texttt{authenticateByEmailAddress} method directly
checks the email address provided by the Login Portlet. The other two
methods, \texttt{authenticateByScreenName} and
\texttt{authenticateByUserId} call Liferay DXP's
\texttt{UserLocalService} to look up the user's email address before
checking it. This service is injected by the OSGi container because of
the \texttt{@Reference} annotation. Note that the validator is also
injected in this same manner, though it's configured not to fail if the
implementation can't be found. This allows this module to start
regardless of its dependency on the validator implementation. In this
case, this is safe because the error is handled by throwing an
\texttt{AuthException} and logging the error.

Why would you want to do it this way? To err gracefully. Because this is
an \texttt{auth.pipeline.post} \texttt{Authenticator}, you presumably
have other \texttt{Authenticator}s checking credentials before this one.
If this one isn't working, you want to inform administrators with an
error message rather than catastrophically failing and preventing users
from logging in.

The only other Java code in this module is the Interface for the
validator:

\begin{verbatim}
package com.liferay.docs.emailaddressauthenticator.validator;

import aQute.bnd.annotation.ProviderType;

@ProviderType
public interface EmailAddressValidator {

    public boolean isValidEmailAddress(String emailAddress);
}
\end{verbatim}

This defines a single method for checking the email address.

Next, you'll address the validator module.

\begin{figure}
\centering
\includegraphics{./images/auth-pipeline-validator-project.png}
\caption{The validator project implements the Validator Interface and
depends on the authenticator module.}
\end{figure}

This module contains only one class. It implements the Validator
interface:

\begin{verbatim}
package com.liferay.docs.emailaddressvalidator.impl;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;
import org.osgi.service.component.annotations.Component;
import com.liferay.docs.emailaddressauthenticator.validator.EmailAddressValidator;

@Component(
    immediate = true,
    property = {
    },
    service = EmailAddressValidator.class
)
public class EmailAddressValidatorImpl implements EmailAddressValidator {

    @Override
    public boolean isValidEmailAddress(String emailAddress) {

        if (_validEmailDomains.contains(
            emailAddress.substring(emailAddress.indexOf('@')))) {

            return true;
        }
        return false;
    }

    private Set<String> _validEmailDomains = 
        new HashSet<String>(Arrays.asList(new String[] {"@liferay.com", "@example.com"}));
}
\end{verbatim}

This code checks to make sure that the email address is from the
\emph{@liferay.com} or \emph{@example.com} domains. The only other
interesting part of this module is the Gradle build script, because it
defines a compile-only dependency between the two projects. This is
divided into two files: a \texttt{settings.gradle} and a
\texttt{build.gradle}.

The \texttt{settings.gradle} file defines the location of the project
(the \texttt{Authenticator}) the validator depends on:

\begin{verbatim}
include ':emailAddressAuthenticator'
project(':emailAddressAuthenticator').projectDir = new File(settingsDir, '../com.liferay.docs.emailAddressAuthenticator')
\end{verbatim}

Since this project contains the interface, it must be on the classpath
at compile time, which is when \texttt{build.gradle} is running:

\begin{verbatim}
buildscript {
    dependencies {
        classpath group: "com.liferay", name: "com.liferay.gradle.plugins", version: "3.0.23"
    }

    repositories {
        mavenLocal()

        maven {
            url "https://repository-cdn.liferay.com/nexus/content/groups/public"
        }
    }
}

apply plugin: "com.liferay.plugin"

dependencies {
    compileOnly group: "com.liferay.portal", name: "com.liferay.portal.kernel", version: "2.0.0"
    compileOnly group: "org.osgi", name: "org.osgi.compendium", version: "5.0.0"

    compileOnly project(":emailAddressAuthenticator")
}

repositories {
    mavenLocal()

    maven {
        url "https://repository-cdn.liferay.com/nexus/content/groups/public"
    }
}
\end{verbatim}

Note the line in the dependencies section that refers to the
\texttt{Authenticator} project defined in \texttt{settings.gradle}.

When these projects are deployed, the \texttt{Authenticator} you defined
runs, enforcing logins for the two domains specified in the validator.

If you want to examine these projects further, you can download them
\href{https://portal.liferay.dev/documents/113763090/114000186/auth-pipelines-authenticator.zip}{in
this ZIP file}.

\subsection{Related Topics}\label{related-topics-158}

\href{/docs/7-0/tutorials/-/knowledge_base/t/auto-login}{Auto Login}

\href{/docs/7-0/tutorials/-/knowledge_base/t/writing-a-custom-login-portlet}{Writing
a Custom Login Portlet}

\section{Writing a Custom Login
Portlet}\label{writing-a-custom-login-portlet}

If you need to customize your users' authentication experience
completely, you can write your own Login Portlet. The mechanics of this
on the macro level are no different from writing any other portlet, so
if you need to familiarize yourself with that, please see the
\href{/docs/7-0/tutorials/-/knowledge_base/t/portlets}{portlets section
of tutorials}.

This tutorial shows only the relevant parts of a
\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-mvc-portlet}{Liferay
MVC Portlet} that authenticates the user. You'll learn how to call
Liferay DXP's
\href{/docs/7-0/tutorials/-/knowledge_base/t/authentication-pipelines}{authentication
pipeline} and then redirect the user to a location of your choice.

\subsection{Authenticating to Liferay
DXP}\label{authenticating-to-liferay-dxp}

You can use the example project
\href{https://portal.liferay.dev/documents/113763090/114000186/MyCustomLoginPortlet.zip}{in
this ZIP file} as a starting point for your own.

It has only one view, which is used for logging in or showing the user
who is already logged in:

\begin{verbatim}
<%@ include file="/init.jsp" %>

<p>
    <b><liferay-ui:message key="myloginportlet_MyLogin.caption"/></b>
</p>

<c:choose>
    <c:when test="<%= themeDisplay.isSignedIn() %>">

        <%
        String signedInAs = HtmlUtil.escape(user.getFullName());

        if (themeDisplay.isShowMyAccountIcon() && (themeDisplay.getURLMyAccount() != null)) {
            String myAccountURL = String.valueOf(themeDisplay.getURLMyAccount());

            signedInAs = "<a class=\"signed-in\" href=\"" + HtmlUtil.escape(myAccountURL) + "\">" + signedInAs + "</a>";
        }
        %>

        <liferay-ui:message arguments="<%= signedInAs %>" key="you-are-signed-in-as-x" translateArguments="<%= false %>" />
    </c:when>
    <c:otherwise>
    
        <%
        String redirect = ParamUtil.getString(request, "redirect");
        %>
    
        <portlet:actionURL name="/login/login" var="loginURL">
            <portlet:param name="mvcRenderCommandName" value="/login/login" />
        </portlet:actionURL>
        
        <aui:form action="<%= loginURL %>" autocomplete='on' cssClass="sign-in-form" method="post" name="loginForm">
        
            <aui:input name="saveLastPath" type="hidden" value="<%= false %>" />
            <aui:input name="redirect" type="hidden" value="<%= redirect %>" />
                    
            <aui:input autoFocus="true" cssClass="clearable" label="email-address" name="login" showRequiredLabel="<%= false %>" type="text" value="">
                <aui:validator name="required" />
            </aui:input>

            <aui:input name="password" showRequiredLabel="<%= false %>" type="password">
                <aui:validator name="required" />
            </aui:input>
            
            <aui:button-row>
                <aui:button cssClass="btn-lg" type="submit" value="sign-in" />
            </aui:button-row>
                
        </aui:form>
    </c:otherwise>
</c:choose>
\end{verbatim}

Note that in the form, authentication by email address (Liferay DXP's
default setting) is hard-coded, as this is an example project. The
current page is sent as a hidden field on the form so the portlet can
redirect the user to it, but you can of course set this to any value you
want.

The portlet handles all processing of this form using a single
\href{/docs/7-0/tutorials/-/knowledge_base/t/mvc-action-command}{Action
Command} (imports left out for brevity):

\begin{verbatim}
@Component(
    property = {
        "javax.portlet.name=MyLoginPortlet",
        "mvc.command.name=/login/login"
    },
    service = MVCActionCommand.class
)
public class MyLoginMVCActionCommand extends BaseMVCActionCommand {

    @Override
    protected void doProcessAction(ActionRequest actionRequest,
            ActionResponse actionResponse) throws Exception {

        ThemeDisplay themeDisplay = (ThemeDisplay)actionRequest.getAttribute(
            WebKeys.THEME_DISPLAY);
        
        HttpServletRequest request = PortalUtil.getOriginalServletRequest(
            PortalUtil.getHttpServletRequest(actionRequest));
        
        HttpServletResponse response = PortalUtil.getHttpServletResponse(
            actionResponse);

        String login = ParamUtil.getString(actionRequest, "login");
        String password = actionRequest.getParameter("password");
        boolean rememberMe = ParamUtil.getBoolean(actionRequest, "rememberMe");
        String authType = CompanyConstants.AUTH_TYPE_EA;
        
        AuthenticatedSessionManagerUtil.login(
            request, response, login, password, rememberMe, authType);
        
        actionResponse.sendRedirect(themeDisplay.getPathMain());
    }

}
\end{verbatim}

The only tricky/unusual code here is the need to grab the
\texttt{HttpServletRequest} and the \texttt{HttpServletResponse}. This
is necessary to call Liferay DXP's API for authentication. At the end of
the Action Command, the portlet sends a redirect that sends the user to
the same page. You can of course make this any page you want.

Implementing your own login portlet gives you complete control over the
authentication process.

\subsection{Related Topics}\label{related-topics-159}

\href{/docs/7-0/tutorials/-/knowledge_base/t/password-based-authentication-pipelines}{Password-Based
Authentication Pipelines}

\href{/docs/7-0/tutorials/-/knowledge_base/t/auto-login}{Auto Login}

\section{Service Access Policies}\label{service-access-policies}

Service access policies are a layer of web service security on top of
Liferay DXP's remote services. Together with the permissions layer,
service access policies limit remote service access by remote client
applications. This forms an additional security layer that protects user
data from unauthorized access and modification.

To connect to a Liferay DXP instance, remote clients must authenticate
with credentials in that instance. This grants the remote client the
permissions assigned to those credentials in the Liferay DXP
installation. Service access policies are a layer of security on top of
this: they further limit the remote client's access to the remote
services specified in the policy. Without such policies, authenticated
remote clients are treated like users: they can call any remote API and
read or modify data on behalf of the authenticated user. Since remote
clients are often intended for a specific use case, granting them access
to everything the user has permissions for poses a security risk.

For example, consider a mobile app (client) that displays a user's
appointments from the Liferay Calendar app. This client app doesn't need
access to the API that updates the user profile, even though the user
has such permissions on the server. The client app doesn't even need
access to the Calendar API methods that create, update, and delete
appointments. It only needs access to the remote service methods for
finding and retrieving appointments. A service access policy on the
server can restrict the client's access to only these service methods.
Otherwise, once authenticated it would have access to all the remote
services the user has permission to access when logged in: services that
create, update, and delete calendar appointments, as well as those that
can update user data or other system entities the user can access. Since
the client doesn't perform these operations, having access to them is a
security risk if the mobile device is lost or stolen or the client app
is compromised by an attacker.

\subsection{How Service Access Policies
Work}\label{how-service-access-policies-work}

When a remote client issues a request to a web service, the request
contains the user's credentials or an authorization token. An
authentication module in Liferay DXP recognizes the client based on the
credentials/token and grants the appropriate service access policy to
the request. The service access policy authorization layer then
processes all granted policies and lets the request access the remote
service(s) permitted by the policy.

\begin{figure}
\centering
\includegraphics{./images/service-access-policies-arch.png}
\caption{The authorization module maps the credentials or token to the
proper Service Access Policy.}
\end{figure}

Service Access policies are created in the Control Panel by
administrators. If you want to start creating policies yourself, see
\href{/docs/7-0/deploy/-/knowledge_base/d/service-access-policies}{this
article on service access policies} that documents creating them in the
UI.

There may be cases, however, when your server-side Liferay app needs to
use the service access policies API. For example, your app may:

\begin{itemize}
\item
  use \href{/docs/7-0/tutorials/-/knowledge_base/t/auto-login}{custom
  remote API authentication} (tokens) and require certain services to be
  available for clients using the tokens.
\item
  require its services be made available to guest users, with no
  authentication necessary.
\item
  contain a
  \href{/docs/7-0/tutorials/-/knowledge_base/t/password-based-authentication-pipelines}{remote
  service authorization layer} that needs to drive access to remote
  services based on granted privileges.
\end{itemize}

\subsection{API Overview}\label{api-overview}

Liferay provides an Interface and a \texttt{ThreadLocal} if you don't
want to roll your own policies. If you want to get low level, an API is
provided that Liferay itself has used to implement
\href{/docs/7-0/user/-/knowledge_base/u/administering-liferay-sync}{Liferay
Sync}.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  The Interface and \texttt{ThreadLocal} are available in the
  \href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/security/service/access/policy/package-summary.html}{package
  \texttt{com.liferay.portal.kernel.security.service.access.policy}}.
  This package provides classes for basic access to policies. For
  example, you can use the
  \href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/security/service/access/policy/ServiceAccessPolicyManagerUtil.html}{singleton
  \texttt{ServiceAccessPolicyManagerUtil}} to obtain Service Access
  Policies configured in the system. You can also use the
  \href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/security/service/access/policy/ServiceAccessPolicyThreadLocal.html}{\texttt{ServiceAccessPolicyThreadLocal}
  class} to set and obtain Service Access Policies granted to the
  current request thread.

  At this level, you can get a list of the configured policies to let
  your app/client choose a policy for accessing services. Also, apps
  like OAuth can offer a list of available policies during the
  authorization step in the OAuth workflow and allow the user to choose
  the policy to assign to the remote application. You can also grant a
  policy to a current request thread. When a remote client accesses an
  API, something must tell the Liferay instance which policies are
  assigned to this call. This something is in most cases an
  \href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/security/auth/verifier/AuthVerifier.html}{\texttt{AuthVerifier}
  implementation}. For example, in the case of the OAuth app, an
  \texttt{AuthVerifier} implementation assigns the policy chosen by the
  user in the authorization step.
\item
  The API ships with the product as OSGi modules:
\end{enumerate}

\begin{itemize}
\item
  \texttt{com.liferay.portal.security.service.access.policy.api.jar}
\item
  \texttt{com.liferay.portal.security.service.access.policy.service.jar}
\item
  \texttt{com.liferay.portal.security.service.access.policy.web.jar}

  These OSGi modules are active in Liferay DXP by default, and you can
  use them to manage Service Access Policies programmatically. You can
  find their source code {[}here in
  GitHub{]}(https://github.com/liferay/liferay-portal/tree/master/modules/apps/foundation/portal-security).
  Each module publishes a list of packages and services that can be
  consumed by other OSGi modules.
\end{itemize}

You can use both tools to develop a token verification module (a module
that implements custom security token verification for use in
authorizing remote clients) for your app to use. For example, this
module may contain a JSON Web Token implementation for Liferay DXP's
remote API. A custom token verification module must use the Service
Access Policies API during the remote API/web service call to grant the
associated policy during the request. The module:

\begin{itemize}
\item
  can use
  \texttt{com.liferay.portal.security.service.access.policy.api.jar} and
  \texttt{com.liferay.portal.security.service.access.policy.service.jar}
  to create policies programmatically.
\item
  should use the method
  \texttt{ServiceAccessPolicyThreadLocal.addActiveServiceAccessPolicyName()}
  to grant the associated policy during a web service request.\\
\item
  can use \texttt{ServiceAccessPolicyManagerUtil} to display list of
  supported policies when authorizing the remote application, to
  associate the token with an existing policy.
\end{itemize}

\subsection{Example}\label{example}

\href{https://www.liferay.com/supporting-products/liferay-sync}{Liferay
Sync's} \texttt{sync-security} module is an example of such a module. It
uses \texttt{com.liferay.portal.security.service.access.policy.service}
to create the \texttt{SYNC\_DEFAULT} and \texttt{SYNC\_TOKEN} policies
programmatically. For service calls to Sync's remote API, these policies
grant access to Sync's
\texttt{com.liferay.sync.service.SyncDLObjectService\#getSyncContext}
and \texttt{com.liferay.sync.service.*}, respectively. Here's the code
in the \texttt{sync-security} module that defines and creates these
policies:

\begin{verbatim}
@Component(immediate = true)
public class SyncSAPEntryActivator {

    // Define the policies
    public static final Object[][] SAP_ENTRY_OBJECT_ARRAYS = new Object[][] {
        {
            "SYNC_DEFAULT",
            "com.liferay.sync.service.SyncDLObjectService#getSyncContext", true
        },
        {"SYNC_TOKEN", "com.liferay.sync.service.*", false}
    };

    ...

    // Create the policies
    protected void addSAPEntry(long companyId) throws PortalException {
            for (Object[] sapEntryObjectArray : SAP_ENTRY_OBJECT_ARRAYS) {
                String name = String.valueOf(sapEntryObjectArray[0]);
                String allowedServiceSignatures = String.valueOf(
                    sapEntryObjectArray[1]);
                boolean defaultSAPEntry = GetterUtil.getBoolean(
                    sapEntryObjectArray[2]);

                SAPEntry sapEntry = _sapEntryLocalService.fetchSAPEntry(
                    companyId, name);

                if (sapEntry != null) {
                    continue;
                }

                Map<Locale, String> map = new HashMap<>();

                map.put(LocaleUtil.getDefault(), name);

                _sapEntryLocalService.addSAPEntry(
                    _userLocalService.getDefaultUserId(companyId),
                    allowedServiceSignatures, defaultSAPEntry, true, name, map,
                    new ServiceContext());
            }
    }

    ...

}
\end{verbatim}

\href{https://github.com/liferay/liferay-portal/blob/7.0.x/modules/apps/sync/sync-security/src/main/java/com/liferay/sync/security/service/access/policy/SyncSAPEntryActivator.java}{Click
here} to see the entire \texttt{SyncSAPEntryActivator} class. This class
creates the policies when the module starts. Note that this module is
included and enabled in Liferay DXP by default. You can access these and
other policies in \emph{Control Panel} → \emph{Configuration} →
\emph{Service Access Policy}.

The \texttt{sync-security} module must then grant the appropriate policy
when needed. Since every authenticated call to Liferay Sync's remote API
requires access to \texttt{com.liferay.sync.service.*}, the module must
grant the \texttt{SYNC\_TOKEN} policy to such calls. The module does
this with the method
\texttt{ServiceAccessPolicyThreadLocal.addActiveServiceAccessPolicyName},
as shown in this code snippet:

\begin{verbatim}
if ((permissionChecker != null) && permissionChecker.isSignedIn()) {
    ServiceAccessPolicyThreadLocal.addActiveServiceAccessPolicyName(
        String.valueOf(
            SyncSAPEntryActivator.SAP_ENTRY_OBJECT_ARRAYS[1][0]));
}
\end{verbatim}

Now every authenticated call to Sync's remote API, regardless of
authentication method, has access to
\texttt{com.liferay.sync.service.*}. To see the full code example,
\href{https://github.com/liferay/liferay-portal/blob/7.0.x/modules/apps/sync/sync-security/src/main/java/com/liferay/sync/security/servlet/filter/SyncAuthFilter.java}{click
here}.

Nice! Now you know how to integrate your apps with the Service Access
Policies in Liferay DXP.

\section{Using JSR Roles in a
Portlet}\label{using-jsr-roles-in-a-portlet}

Roles in Liferay DXP are the primary means for granting or restricting
access to content. If you've decided \emph{not} to use Liferay's
permissions system, you can use the basic system offered by the JSR 168,
286, and 362 specifications that map Roles in a portlet to Roles
provided by the portal.

\subsection{JSR Portlet Security}\label{jsr-portlet-security}

The portlet specification defines a means to specify Roles used by
portlets in their \texttt{docroot/WEB-INF/portlet.xml} descriptors. The
Role names themselves, however, are not standardized. When these
portlets run in Liferay DXP, the Role names defined in the portlet must
be mapped to Roles that exist in the Portal.

For example, consider a Guestbook project that contains two portlets:
The Guestbook portlet and the Guestbook Admin portlet. The WAR version
of the Guestbook project's \texttt{portlet.xml} file references the
\emph{administrator}, \emph{guest}, \emph{power-user}, and \emph{user}
Roles:

\begin{verbatim}
<?xml version="1.0"?>
<portlet-app xmlns="http://java.sun.com/xml/ns/portlet/portlet-app_2_0.xsd" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/portlet/portlet-app_2_0.xsd http://java.sun.com/xml/ns/portlet/portlet-app_2_0.xsd" version="2.0">

<portlet>
    <portlet-name>guestbook</portlet-name>
    <display-name>Guestbook</display-name>
    <portlet-class>
        com.liferay.docs.guestbook.portlet.GuestbookPortlet
    </portlet-class>
    <init-param>
        <name>view-template</name>
        <value>/html/guestbook/view.jsp</value>
    </init-param>
    <expiration-cache>0</expiration-cache>
    <supports>
        <mime-type>text/html</mime-type>
        <portlet-mode>view</portlet-mode>
    </supports>
    <portlet-info>
        <title>Guestbook</title>
        <short-title>Guestbook</short-title>
        <keywords></keywords>
    </portlet-info>
    <security-role-ref>
        <role-name>administrator</role-name>
    </security-role-ref>
    <security-role-ref>
        <role-name>guest</role-name>
    </security-role-ref>
    <security-role-ref>
        <role-name>power-user</role-name>
    </security-role-ref>
    <security-role-ref>
        <role-name>user</role-name>
    </security-role-ref>
</portlet>
<portlet>
    <portlet-name>guestbook-admin</portlet-name>
    <display-name>Guestbook Admin</display-name>
    <portlet-class>
        com.liferay.docs.guestbook.portlet.GuestbookAdminPortlet
    </portlet-class>
    <init-param>
        <name>view-template</name>
        <value>/html/guestbookadmin/view.jsp</value>
    </init-param>
    <expiration-cache>0</expiration-cache>
    <supports>
        <mime-type>text/html</mime-type>
        <portlet-mode>view</portlet-mode>
    </supports>
    <portlet-info>
        <title>Guestbook Admin</title>
        <short-title>Guestbook Admin</short-title>
        <keywords></keywords>
    </portlet-info>
    <security-role-ref>
        <role-name>administrator</role-name>
    </security-role-ref>
    <security-role-ref>
        <role-name>guest</role-name>
    </security-role-ref>
    <security-role-ref>
        <role-name>power-user</role-name>
    </security-role-ref>
    <security-role-ref>
        <role-name>user</role-name>
    </security-role-ref>
</portlet>
\end{verbatim}

An OSGi-based \texttt{guestbook-web} module project defines Roles
without an XML file, in the portlet class's \texttt{@Component}
annotation:

\begin{verbatim}
@Component(
    immediate = true,
    property = {
        "com.liferay.portlet.display-category=category.sample",
        "com.liferay.portlet.instanceable=true",
        "javax.portlet.init-param.template-path=/",
        "javax.portlet.init-param.view-template=/view.jsp",
        "javax.portlet.name=" + GuestbookPortletKeys.Guestbook,
        "javax.portlet.resource-bundle=content.Language",
        "javax.portlet.security-role-ref=power-user,user"
    },
    service = Portlet.class
)
\end{verbatim}

If you are using an OSGi-based MVC Portlet, you must use Liferay's
permissions system, as the only way to map JSR-362 Roles to Liferay
Roles is to place them in the Liferay WAR file's \texttt{portlet.xml}.

Your \texttt{portlet.xml} Roles must be mapped to specific Roles that
have been created. These mappings allow Liferay DXP to resolve conflicts
between Roles with the same name that are from different portlets
(e.g.~portlets from different developers).

\noindent\hrulefill

\textbf{Note:} Each Role named in a portlet's
\texttt{\textless{}security-role-ref\textgreater{}} element is given
permission to add the portlet to a page.

\noindent\hrulefill

\subsection{Mapping Portlet Roles to Portal
Roles}\label{mapping-portlet-roles-to-portal-roles}

To map the Roles to Liferay DXP, you must use the
\texttt{docroot/WEB-INF/liferay-portlet.xml} Liferay-specific
configuration file. For an example, see the mapping defined in the
Guestbook project's \texttt{liferay-portlet.xml} file.

\begin{verbatim}
<role-mapper>
    <role-name>administrator</role-name>
    <role-link>Administrator</role-link>
</role-mapper>
<role-mapper>
    <role-name>guest</role-name>
    <role-link>Guest</role-link>
</role-mapper>
<role-mapper>
    <role-name>power-user</role-name>
    <role-link>Power User</role-link>
</role-mapper>
<role-mapper>
    <role-name>user</role-name>
    <role-link>User</role-link>
</role-mapper>
\end{verbatim}

If a portlet definition references the Role \texttt{power-user}, that
portlet is mapped to the Liferay Role called \emph{Power User} that's
already in Liferay's database.

As stated above, there is no standardization with portal Role names. If
you deploy a portlet with Role names different from the above default
Liferay names, you must add the names to the \texttt{system.roles}
property in your \texttt{portal-ext.properties} file:

\begin{verbatim}
system.roles=my-role,your-role,our-role
\end{verbatim}

This prevents Roles from being created accidentally.

Once Roles are mapped to the portal, you can use methods as defined in
the portlet specification:

\begin{itemize}
\tightlist
\item
  \texttt{getRemoteUser()}
\item
  \texttt{isUserInRole()}
\item
  \texttt{getUserPrincipal()}
\end{itemize}

For example, you can use the following code to check if the current User
has the \texttt{power-user} Role:

\begin{verbatim}
if (renderRequest.isUserInRole("power-user")) {
    // ...
}
\end{verbatim}

By default, Liferay doesn't use the \texttt{isUserInRole()} method in
any built-in portlets. Liferay uses its own permission system directly
to achieve more fine-grained security. If you don't intend on deploying
your portlets to other portal servers, we recommend using Liferay's
permission system, because it offers a much more robust way of tailoring
your application's permissions.

\subsection{Related Topics}\label{related-topics-160}

\href{/docs/7-0/tutorials/-/knowledge_base/t/defining-application-permissions}{Liferay
Permissions}

\href{/docs/7-0/tutorials/-/knowledge_base/t/asset-framework}{Asset
Framework}

\href{/docs/7-0/tutorials/-/knowledge_base/t/portlets}{Portlets}

\href{/docs/7-0/tutorials/-/knowledge_base/t/understanding-servicecontext}{Understanding
ServiceContext}

\chapter{Internationalization}\label{internationalization}

Liferay DXP makes it easier than ever to localize content and design
apps for different locales. You can centralize messages (language keys)
and have manual and automatic translation, including localizing forms
and setting text directionality from left-to-right or right-to-left.
Customizing messages in apps is easy too. Internationalization is a snap
with Liferay DXP!

\section{Localizing Your Application}\label{localizing-your-application}

If you're writing a Liferay Application, you're probably a genius who is
also really cool. Which means your application is going to be used
throughout the entire world. At least, it will if the messages that
appear to its users can be translated into their language. Thankfully,
Liferay makes it easy to support translation of your application's
language keys.

\noindent\hrulefill

\textbf{Note:} Even if you don't think your application needs to be
translated into multiple languages, use the localization pattern
presented here for any messages displayed in your user interface. It's
much easier to change the messages by updating a language properties
file than by finding every instance of a message and replacing it in
your JSPs and Java classes.

\noindent\hrulefill

You just need to create a default language properties file
(\texttt{Language.properties}) and one for each translation you'd like
to support (for example, \texttt{Language\_fr.properties} for your
French translation), and put them in the correct location in your
application. Use the two letter locale that corresponds to the language
you want to translate in your file names (for example,
\texttt{Language\_es.properties} provides a Spanish translation for each
key).

Application localization topics:

\begin{itemize}
\tightlist
\item
  \hyperref[what-are-language-keys]{What are Language Keys?}
\item
  \hyperref[what-locales-are-available-by-default]{What Locales are
  Available By Default?}
\item
  \hyperref[where-do-i-put-language-files]{Where do I Put Language
  Files?}
\item
  \hyperref[creating-a-language-module]{Creating a Language Module}
\item
  \hyperref[using-a-language-module]{Using a Language Module}
\item
  \hyperref[using-global-language-properties]{Using Global Language
  Properties}
\end{itemize}

\subsection{What are Language Keys?}\label{what-are-language-keys}

Each language property file holds key/value pairs. The key is the same
in all the language property files, while the value is translated in
each file. You specify the key in your user interface code, and the
appropriately translated message is returned automatically for your
users, depending on the locale being used in Liferay. If you have
Liferay running locally, append the URL with a supported locale to see
how Liferay's language keys are translated (for example, enter
\texttt{localhost:8080/es}).

\begin{figure}
\centering
\includegraphics{./images/locale-message-spain.png}
\caption{Append the locale to your running Liferay's URL and see
Liferay's translation power in action.}
\end{figure}

Language keys are just keys you'll use in place of a hard coded, fully
translated String value in your user interface code. For example, you
can use a language key in your JSP via a
\texttt{\textless{}liferay-ui:message\ /\textgreater{}} tag.

The tag might be set up like this if you're not considering the need to
translate your application's messages:

\begin{verbatim}
<liferay-ui:message key="Howdy, Partner!" />
\end{verbatim}

In that case you'll get a properly capitalized and punctuated message in
your application.

Alternatively, you can specify a simple key instead of the final value:

\begin{verbatim}
<liferay-ui:message key="howdy-partner" />
\end{verbatim}

That way you can provide a translation of the key in a default language
properties file (\texttt{Language.properties}):

\begin{verbatim}
howdy-partner=Howdy, Partner!
\end{verbatim}

You'll get the same output in your application with either method above,
but you have the flexibility to add additional language properties files
that provide translations for your application's keys if you use the
language properties approach. Use a key in your UI code, then provide
the value (or translation) in your language properties file. You just
need to make sure there's a locale that corresponds to your translation.

The values from your default \texttt{Language.properties} file will
appear if no locale is specified. If a locale is specified, Liferay will
try to find a file that corresponds to the locale. For example, if a
Spanish translation is sought, a \texttt{Language\_es.properties} file
must be present to provide the proper values. If it isn't, the default
language properties (from the \texttt{Language.properties} file) will be
used.

\subsection{What Locales are Available By
Default?}\label{what-locales-are-available-by-default}

There are a bunch of locales available by default in Liferay. Look in
the \texttt{portal.properties} file
\href{@platform-ref@/7.0-latest/propertiesdoc/portal.properties.html\#Languages\%20and\%20Time\%20Zones}{file}
to find them.

\begin{verbatim}
locales=ar_SA,eu_ES,bg_BG,ca_AD,ca_ES,zh_CN,zh_TW,hr_HR,cs_CZ,da_DK,nl_NL,
    nl_BE,en_US,en_GB,en_AU,et_EE,fi_FI,fr_FR,fr_CA,gl_ES,de_DE,el_GR,
    iw_IL,hi_IN,hu_HU,in_ID,it_IT,ja_JP,ko_KR,lo_LA,lt_LT,nb_NO,fa_IR,
    pl_PL,pt_BR,pt_PT,ro_RO,ru_RU,sr_RS,sr_RS_latin,sl_SI,sk_SK,es_ES,
    sv_SE,tr_TR,uk_UA,vi_VN
\end{verbatim}

To provide a translation for one of these locales, specify the locale in
the file name where the translated keys will be (for example,
\texttt{Langauge\_es.properties} holds the Spanish translation).

\subsection{Where do I Put Language
Files?}\label{where-do-i-put-language-files}

In an application with only one module that holds all your application's
views (for example, all its JSPs) and portlet components, just create a
\texttt{src/main/resources/content} folder in that module, and place
your \texttt{Language.properties} and \texttt{Language\_xx.properties}
files there.

After that, make sure any portlet components (the \texttt{@Component}
annotation in your \texttt{-Portlet} classes) in the module include this
property:

\begin{verbatim}
"javax.portlet.resource-bundle=content.Language"
\end{verbatim}

Providing translated language properties files and specifying the
\texttt{javax.portlet.resource-bundle} property in your portlet
component is all you need to do to have your language keys translated.
Then, when the locale is changed in Liferay DXP, your application's
language keys will be automatically translated.

In a more complicated, well-modularized application, you might have
language keys spread over multiple modules providing portlet components
and JSP files. Moreover, there might be a fair number of duplicated
language keys between the modules. Thankfully you don't need to maintain
language properties files in each module.

\subsection{Creating a Language
Module}\label{creating-a-language-module}

If you're crazy about modularity (and you should be), you might have an
application with multiple modules that provide the view layer. These
modules are often called web modules.

\begin{verbatim}
my-application/
my-application-web/
my-admin-application-web/
my-application-content-web/
my-application-api/
my-application-service/
\end{verbatim}

Each of these modules can have language keys and translations to
maintain, and there will probably be duplicate keys. You don't want to
end up with different values for the same key, and you don't want to
maintain language keys in multiple places. In this case, you need to go
even crazier with modularity and create a new module, which we'll call a
language module.

In the root project folder (the one that holds your service, API, and
web modules),
\href{/docs/7-0/tutorials/-/knowledge_base/t/starting-module-development\#creating-a-module}{create
a new module} to hold your app's language keys. For example, here's the
folder structure of a language module called
\texttt{my-application-lang}.

\begin{verbatim}
my-application-lang/
    bnd.bnd
    src/
        main/
            resources/
                content/
                    Language.properties
                    Language_ar.properties
                    Language_bg.properties
                    ...
\end{verbatim}

In the language module, create a \texttt{src/main/resources/content}
folder. Put your language properties files here. A
\texttt{Language.properties} file might look like this:

\begin{verbatim}
application=My Application
add-entity=Add Entity
\end{verbatim}

Create any translations you want, adding the translation locale ID to
the language file name. File \texttt{Language\_es.properties} might look
like this:

\begin{verbatim}
my-app-title=Mi Aplicación
add-entity=Añadir Entity
\end{verbatim}

On building the language module, Liferay DXP's
\texttt{ResourceBundleLoaderAnalyzerPlugin} detects the
\texttt{content/Language.properties} file and adds a resource bundle
\href{http://blog.osgi.org/2015/12/using-requirements-and-capabilities.html}{\emph{capability}}
to the module. A capability is a contract a module declares to Liferay
DXP's OSGi framework. Capabilities let you associate services with
modules that provide them. In this case, Liferay DXP registers a
\href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/util/ResourceBundleLoader.html}{ResourceBundleLoader}
service for the resource bundle capability.

Next, you'll configure a web module to use the language module resource
bundle.

\subsection{Using a Language Module}\label{using-a-language-module}

A module or traditional Liferay plugin can use a resource bundle from
another module and optionally include its own resource bundle. OSGi
manifest headers \texttt{Require-Capability} and
\texttt{Provide-Capability} make this possible, and it's especially easy
in modules generated from Liferay project templates. Instructions for
using a language module are divided into these environments:

\begin{itemize}
\tightlist
\item
  \hyperref[using-a-language-module-from-a-module]{Using a Language
  Module from a Module}
\item
  \hyperref[using-a-language-module-from-a-traditional-plugin]{Using a
  Language Module from a Traditional Plugin}
\end{itemize}

If you're using bnd with Maven or Gradle, you need only specify
Liferay's \texttt{-liferay-aggregate-resource-bundle:} bnd
instruction--at build time, Liferay's bnd plugin converts the
instruction to \texttt{Require-Capability} and
\texttt{Provide-Capability} parameters automatically. Both approaches
are demonstrated.

\subsubsection{Using a Language Module from a
Module}\label{using-a-language-module-from-a-module}

Modules generated from Liferay project templates have a Liferay bnd
build time instruction called
\texttt{-liferay-aggregate-resource-bundles}. It lets you use other
resource bundles (e.g., including their language keys) along with your
own. Here's how to do it:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open your module's \texttt{bnd.bnd} file.
\item
  Add the \texttt{-liferay-aggregate-resource-bundles:} bnd instruction
  and assign it the bundle symbolic names of modules whose resource
  bundles to aggregate with the current module's resource bundle.

\begin{verbatim}
-liferay-aggregate-resource-bundles: \
    [bundle.symbolic.name1],\
    [bundle.symbolic.name2]
\end{verbatim}
\end{enumerate}

For example, a module that uses resource bundles from modules
\texttt{com.liferay.docs.l10n.myapp1.lang} and
\texttt{com.liferay.docs.l10n.myapp2.lang} would set this in its
\texttt{bnd.bnd} file:

\begin{verbatim}
-liferay-aggregate-resource-bundles: \
    com.liferay.docs.l10n.myapp1.lang,\
    com.liferay.docs.l10n.myapp2.lang
\end{verbatim}

The current module's resource bundle is prioritized over those of the
listed modules.

\noindent\hrulefill

The
\href{/docs/7-1/reference/-/knowledge_base/r/shared-language-keys}{Shared
Language Key sample project} is a working example that demonstrates
aggregating resource bundles. You can deploy it in Gradle, Maven, and
Liferay Workspace build environments.

\noindent\hrulefill

At build time, Liferay's bnd plugin converts the bnd instruction to
\texttt{Require-Capability} and \texttt{Provide-Capability} parameters
automatically. In traditional Liferay plugins, you must specify the
parameters manually.

\noindent\hrulefill

\textbf{Note:} You can always specify the \texttt{Require-Capability}
and \texttt{Provide-\ \ Capability} OSGi manifest headers manually, as
the next section demonstrates.

\noindent\hrulefill

\subsubsection{Using a Language Module from a Traditional
Plugin}\label{using-a-language-module-from-a-traditional-plugin}

To use a language module, from a traditional Liferay plugin you must
specify the language module using \texttt{Require-Capability} and
\texttt{Provide-Capability} OSGi manifest headers in the plugin's
\texttt{liferay-plugin-package.properties} file.

Follow these steps to configure your traditional plugin to use a
language module:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open the plugin's \texttt{liferay-plugin-package.properties} file and
  add a \texttt{Require-Capability} header that filters on the language
  module's resource bundle capability. For example, if the language
  module's symbolic name is \texttt{myapp.lang}, you'd specify the
  requirement like this:

\begin{verbatim}
Require-Capability: liferay.resource.bundle;filter:="(bundle.symbolic.name=myapp.lang)"
\end{verbatim}
\item
  In the same \texttt{liferay-plugin-package.properties} file, add a
  \texttt{Provide-Capability} header that adds the language module's
  resource bundle \emph{as} this plugin's (the \texttt{myapp.web}
  plugin) own resource bundle:

\begin{verbatim}
Provide-Capability:\
liferay.resource.bundle;resource.bundle.base.name="content.Language",\
liferay.resource.bundle;resource.bundle.aggregate:String="(bundle.symbolic.name=myapp.lang)";bundle.symbolic.name=myapp.web;resource.bundle.base.name="content.Language";service.ranking:Long="4";\
servlet.context.name=myapp-web
\end{verbatim}
\end{enumerate}

In this case, the \texttt{myapp.web} plugin solely uses the language
module's resource bundle---the resource bundle aggregate only includes
language module \texttt{myapp.lang}.

Aggregating resource bundles comes into play when you want to use your a
language module's resource bundle \emph{in addition to} your plugin's
resource bundle. These instructions show you how to do this, while
prioritizing your current plugin's resource bundle over the language
module resource bundle. In this way, the language module's language keys
compliment your plugin's language keys.

For example, a portlet whose bundle symbolic name is \texttt{myapp.web}
uses keys from language module \texttt{myapp.lang}, in addition to its
own. The portlet's \texttt{Provide-Capability} and
\texttt{Web-ContextPath} OSGi headers accomplish this.

\begin{verbatim}
Provide-Capability:\
liferay.resource.bundle;resource.bundle.base.name="content.Language",\
liferay.resource.bundle;resource.bundle.aggregate:String="(bundle.symbolic.name=myapp.web),(bundle.symbolic.name=myapp.lang)";bundle.symbolic.name=myapp.web;resource.bundle.base.name="content.Language";service.ranking:Long="4";\
servlet.context.name=myapp-web
\end{verbatim}

Let's examine the example \texttt{Provide-Capability} header.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \texttt{liferay.resource.bundle;resource.bundle.base.name="content.Language"}
  declares that the module provides a resource bundle whose base name is
  \texttt{content.language}.
\item
  The
  \texttt{liferay.resource.bundle;resource.bundle.aggregate:String=...}
  directive specifies the list of bundles whose resource bundles are
  aggregated, the target bundle, the target bundle's resource bundle
  name, and this service's ranking:

  \begin{itemize}
  \tightlist
  \item
    \texttt{"(bundle.symbolic.name=myapp.web),(bundle.symbolic.name=myapp.lang)"}:
    The service aggregates resource bundles from bundles
    \texttt{bundle.symbolic.name=myapp.web} (the current module) and
    \texttt{bundle.symbolic.name=myapp.lang}. Aggregate as many bundles
    as desired. Listed bundles are prioritized in descending order.
  \item
    \texttt{bundle.symbolic.name=myapp.web;resource.bundle.base.name="content.Language"}:
    Override the \texttt{myapp.web} bundle's resource bundle named
    \texttt{content.Language}.
  \item
    \texttt{service.ranking:Long="4"}: The resource bundle's service
    ranking is \texttt{4}. The OSGi framework applies this service if it
    outranks all other resource bundle services that target
    \texttt{myapp.web}'s \texttt{content.Language} resource bundle.
  \item
    \texttt{servlet.context.name=myapp-web}: The target resource bundle
    is in servlet context \texttt{myapp-web}.
  \end{itemize}
\end{enumerate}

Now the language keys from the aggregated resource bundles compliment
your plugin's language keys.

Did you know that Liferay DXP's core language keys are also available to
your module? They're up next.

\subsection{Using Global Language
Properties}\label{using-global-language-properties}

If you have Liferay DXP's source code, you can check out Liferay DXP's
core language properties by looking in the
\texttt{portal-impl/src/main/content} folder. Otherwise, you can look in
the \texttt{portal-impl.jar} that's in your Liferay bundle.

\begin{verbatim}
liferay-portal/portal-impl/src/content/Language_xx.properties

[Liferay Home]/tomcat-[version]/webapps/ROOT/WEB-INF/lib/portal-impl.jar
\end{verbatim}

These keys are available at runtime, so when you use any of Liferay
DXP's default keys in your user interface code, they're automagically
swapped out for the appropriately translated value. Using Liferay DXP's
keys where possible saves you time and ensures that your application
follows Liferay's UI conventions.

If you want to generate language files for each supported locale
automatically, or to configure your application to generate translations
automatically using the Microsoft Translator API, check out the tutorial
\href{/docs/7-0/tutorials/-/knowledge_base/t/automatically-generating-language-files}{Automatically
Generating Language Files}.

\section{Automatically Generating Language
Files}\label{automatically-generating-language-files}

If you already have a \texttt{Language.properties} file that holds
\href{/docs/7-0/tutorials/-/knowledge_base/t/localizing-your-application}{language
keys for your user interface messages}, or even a language module that
holds these keys, you're in the right place.

\begin{itemize}
\item
  Instead of manually creating a language properties file for each
  locale that's supported by Liferay, you can get them all automatically
  generated for you with one command. The same command also propagates
  the keys from the default language file to all translation files.
\item
  You can also generate automatic translations using Microsoft's
  Translator Text API.
\end{itemize}

\subsection{Generating Language Files for Supported
Locales}\label{generating-language-files-for-supported-locales}

If you want to generate files automatically for all
\href{@platform-ref@/7.0-latest/propertiesdoc/portal.properties.html\#Languages\%20and\%20Time\%20Zones}{locales
supported by Liferay}, you must make a small modification to your
application's build file.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Make sure your module's build includes the
  \texttt{com.liferay.lang.builder}
  \href{https://github.com/liferay/liferay-portal/tree/master/modules/sdk/gradle-plugins-lang-builder}{plugin},
  by putting the plugin in build script classpath.
\item
  Make sure you have a default \texttt{Language.properties} file in
  \texttt{src/main/resources/content}.
\item
  Run the \texttt{gradle\ buildLang} task from your project's root
  directory to generate default translation files.

  The generated files contain automatic copies of all the keys and
  values in your default \texttt{Language.properties} files. That way
  you don't have to copy your lanugage keys manually into all of the
  files. Run the \texttt{buildLang} task each time you change the
  default language file.

  When the task completes, it prints \texttt{BUILD\ SUCCESSFUL} with
  this log output:

\begin{verbatim}
Translation is disabled because credentials are not specified
\end{verbatim}

  See the next section to learn how to turn translation on and provide
  credentials.
\end{enumerate}

Here's what a configuration of the \texttt{com.liferay.lang.builder}
plugin looks in a \texttt{build.gradle} file:

\begin{verbatim}
    buildscript {
        dependencies {
            classpath 'com.liferay:com.liferay.gradle.plugins.lang.builder:latest.release'
        }

        repositories {
            maven {
                url "http://repository-cdn.liferay.com/nexus/content/groups/public"
            }
        }
    }

    apply plugin: "com.liferay.lang.builder"

    repositories {
        maven {
            url "http://repository-cdn.liferay.com/nexus/content/groups/public"
        }
    }
\end{verbatim}

Now you can start translating your application's messages. If you want
to configure your app to generate automatic translations using the
Microsoft Translator Text API, keep reading.

\subsection{Translating Language Keys
Automatically}\label{translating-language-keys-automatically}

If you've configured the \texttt{com.liferay.lang.builder} plugin in
your app, you're almost there. Now you have to configure
\href{https://azure.microsoft.com/en-us/services/cognitive-services/translator-text-api/}{Microsoft's
Translator Text API} so you can generate automatic translations of your
language keys. You cannot, however, use Liferay's Lang Builder to
automatically translate language keys containing HTML (e.g.,
\texttt{\textless{}em\textgreater{}},
\texttt{\textless{}b\textgreater{}},
\texttt{\textless{}code\textgreater{}}, etc.). Language keys containing
HTML are automatically \emph{copied} to all supported language files.

\noindent\hrulefill

\textbf{Note:} These translations are best used as a starting point. A
machine translation can't match the accuracy of a real person who is
fluent in the language. Then again, if you only speak English and you
need a Hungarian translation, this is better and faster than your
attempts at a manual translation.

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Generate a translation subscription key for the Microsoft Translator
  Text API. Follow the instructions
  \href{http://docs.microsofttranslator.com/text-translate.html}{here}.
\item
  Make sure the \texttt{buildLang} task knows to use your subscription
  key for translation by setting the \texttt{translateSubscriptionKey}
  property:

\begin{verbatim}
buildLang {
    translateSubscriptionKey = "my-key"
}
\end{verbatim}

  For security reasons you probably don't want to pass them directly in
  your application's build script. Instead, pass the credentials to a
  property that's stored in your
  \href{https://docs.gradle.org/current/userguide/build_environment.html}{local
  build environment}, and pass the property into your application's
  build script.

\begin{verbatim}
 buildLang {
   translateSubscriptionKey = langTranslateSubscriptionKey
}
\end{verbatim}
\end{enumerate}

So what would the complete \texttt{buildLang} configuration look like if
you followed all the steps above?

\begin{verbatim}
buildscript {
    dependencies {
        classpath 'com.liferay:com.liferay.gradle.plugins.lang.builder:latest.release'
    }

    repositories {
        maven {
            url "http://repository-cdn.liferay.com/nexus/content/groups/public"
        }
    }
}

apply plugin: "com.liferay.lang.builder"

buildLang {
   translateSubscriptionKey = langTranslateSubscriptionKey
}

repositories {
    maven {
        url "http://repository-cdn.liferay.com/nexus/content/groups/public"
    }
}
\end{verbatim}

Great! You now know how to generate language files and provide automatic
translations of your language keys.

\section{Using Liferay's Language
Settings}\label{using-liferays-language-settings}

For a given locale, you can
\href{/docs/7-0/tutorials/-/knowledge_base/t/overriding-language-keys}{override
Liferay's core UI messages}. Modifying Language key values in Liferay
provides a lot of localization flexibility in itself, but we're always
looking for new ways to give you more control. There are language
settings in Liferay's \texttt{Language\_xx.properties} files that give
you even more localization options.

\begin{itemize}
\item
  In the add and edit user forms, configure the name fields that are
  displayed and the field values available in select fields. For
  example, leave out the middle name field if you want, or alter the
  prefix selections.
\item
  Control the directionality of content and messages in Liferay (left to
  right or right to left).
\end{itemize}

To see how these settings are configured, open Liferay's core
\texttt{Language.properties} file in one of two ways:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  From Liferay's source code, navigate to

\begin{verbatim}
 liferay-portal/portal-impl/src/content/Language.properties
\end{verbatim}
\item
  From a Liferay bundle's \texttt{portal-impl.jar}.

\begin{verbatim}
 [Liferay Home]/tomcat-[version]/webapps/ROOT/WEB-INF/lib/portal-impl.jar
\end{verbatim}

  Just open the \texttt{content} folder in the Jar to find the language
  files.
\end{enumerate}

The first section in the \texttt{Language.properties} file is labeled
\emph{Language settings}:

\begin{verbatim}
##
## Language settings
##

lang.dir=ltr
lang.line.begin=left
lang.line.end=right
lang.user.name.field.names=prefix,first-name,middle-name,last-name,suffix
lang.user.name.prefix.values=Dr,Mr,Ms,Mrs
lang.user.name.required.field.names=last-name
lang.user.name.suffix.values=II,III,IV,Jr,Phd,Sr
\end{verbatim}

\noindent\hrulefill

\textbf{Note:} To use the language settings mentioned here, you need a
module, which is like a magic carpet on which your code and resources
ride triumphantly into Liferay's OSGi runtime. Refer to the tutorial on
\href{/docs/7-0/tutorials/-/knowledge_base/t/overriding-language-keys}{overriding
language keys} to set up a module with the following characteristics:

\begin{itemize}
\item
  Contains an implementation of \texttt{ResourceBundle} that is
  registered in the OSGi runtime.
\item
  Contains a \texttt{Language.properties} file for the locale whose
  properties you want to override.
\end{itemize}

\noindent\hrulefill

The user name properties are used to customize certain fields of the add
and edit user forms based on a user's locale.

\subsection{Localizing User Names}\label{localizing-user-names}

Liferay's customers come from all over the world, and we recognize that
naming conventions are different between locales. Liferay's engineers
have made several of the user name fields configurable in Liferay where
user name information is entered or edited.

\begin{itemize}
\item
  Remove certain name fields and make others appear more than once. Some
  locale's need more than one last name, for example.

\begin{verbatim}
 lang.user.name.field.names=prefix,first-name,middle-name,last-name,suffix
\end{verbatim}
\item
  Change the prefix and suffix values for a locale.

\begin{verbatim}
 lang.user.name.prefix.values=Dr,Mr,Ms,Mrs
 lang.user.name.suffix.values=II,III,IV,Jr,Phd,Sr
\end{verbatim}
\item
  Specify which fields are required.

\begin{verbatim}
 lang.user.name.required.field.names=last-name
\end{verbatim}
\end{itemize}

\noindent\hrulefill

\textbf{Note:} A user's first name is mandatory in Liferay. Because of
this, take these two points into consideration when configuring a
locale's user name settings:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  The \texttt{first-name} field can't be removed from the field names
  list.

\begin{verbatim}
 lang.user.name.field.names=prefix,first-name,middle-name,last-name,suffix
\end{verbatim}
\item
  Because first name is required, it's always implicitly included in the
  \emph{required field names} property:

\begin{verbatim}
 lang.user.name.required.field.names=last-name
\end{verbatim}

  Therefore, any fields you enter here are \emph{in addition to} the
  first name field. Last name is required by default, but you can
  disable it by deleting its value from the property:

\begin{verbatim}
 lang.user.name.required.field.names=
\end{verbatim}

  In that case, only first name would be required.
\end{enumerate}

\noindent\hrulefill

The properties for changing user name settings are those that begin with
\texttt{lang.user.name} in the language settings section of a locale's
language properties file.

For most of the
\href{@platform-ref@/7.0-latest/propertiesdoc/portal.properties.html\#Languages\%20and\%20Time\%20Zones}{locales
enabled by default} the user name properties are specifically tailored
to that location.

\begin{verbatim}
locales.enabled=ca_ES,zh_CN,nl_NL,en_US,fi_FI,fr_FR,de_DE,iw_IL,hu_HU,ja_JP,pt_BR,es_ES
\end{verbatim}

For example, these are the English (\texttt{Language\_en.properties})
properties for setting user name fields:

\begin{verbatim}
lang.user.name.field.names=prefix,first-name,middle-name,last-name,suffix
lang.user.name.prefix.values=Dr,Mr,Ms,Mrs
lang.user.name.required.field.names=last-name
lang.user.name.suffix.values=II,III,IV,Jr,Phd,Sr
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/english-user-name-fields.png}
\caption{The user name settings impact the way user information and
forms appear in Liferay.}
\end{figure}

Compare those to the Spanish (\texttt{Language\_es.properties})
settings:

\begin{verbatim}
lang.user.name.field.names=prefix,first-name,last-name
lang.user.name.prefix.values=Sr,Sra,Sta,Dr,Dra
lang.user.name.required.field.names=last-name
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/spanish-user-name-fields.png}
\caption{The Spanish user name settings omit the suffix and middle name
fields entirely.}
\end{figure}

The biggest difference between the English and Spanish form fields in
the images above is that the middle name and suffix fields are omitted
in the Spanish configuration. Other differences include the specific
prefix values.

¡Muy excelente! Localizing the forms for adding and editing users is
accomplished using the same method by which Liferay's UI messages are
localized: by overriding one of Liferay's
\texttt{Lanuguage\_xx.properties} files.

\subsection{Right to Left or Left to
Right?}\label{right-to-left-or-left-to-right}

The first three properties in the language settings section are used for
changing the direction in which the language's characters are displayed.
Most languages are read from left to right, but other languages are
meant to be read from right to left (Arabic, Hebrew, and Persian, for
example). It can also be changed for languages that have been
traditionally displayed left to right (like English) as a funny
practical joke. Just don't tell anyone that you got the idea here.

Here's what the relevant language properties look like for a language
that should be displayed from right to left:

\begin{verbatim}
lang.dir=rtl
lang.line.begin=right
lang.line.end=left
\end{verbatim}

With these customizations yo can transform Liferay's UI into a
user-friendly environment no matter where your users are from.

\chapter{WYSIWYG Editors}\label{wysiwyg-editors}

WYSIWYG editors are an important part of content creation. Liferay's
platform supports several different editors, including CKEditor,
TinyMCE, and our flagship, AlloyEditor. This section contains tutorials
relating to WYSIWYG editors on the Liferay platform.

\section{Adding a WYSIWYG Editor to a
Portlet}\label{adding-a-wysiwyg-editor-to-a-portlet}

It's easy to include WYSIWYG editors in your portlet, thanks to the
\texttt{\textless{}liferay-ui:input-editor\ /\textgreater{}} tag. Below
is an example configuration:

\begin{verbatim}
<%@ taglib prefix="liferay-ui" uri="http://liferay.com/tld/ui" %>

<div class="alloy-editor-container">
    <liferay-ui:input-editor
        contents="Default Content"
        cssClass="my-alloy-editor"
        editorName="alloyeditor"
        name="myAlloyEditor"
        placeholder="description"
        showSource="true" />
</div>
\end{verbatim}

It is also possible to pass JavaScript functions through the
\texttt{onBlurMethod}, \texttt{onChangeMethod}, \texttt{onFocusMethod},
and \texttt{onInitMethod} attributes. Here is an example configuration
that uses the \texttt{onInitMethod} attribute to pass a JavaScript
function called \texttt{OnDescriptionEditorInit}:

\begin{verbatim}
<%@ taglib prefix="aui" uri="http://liferay.com/tld/aui" %>
<%@ taglib prefix="liferay-ui" uri="http://liferay.com/tld/ui" %>

<div class="alloy-editor-container">
    <liferay-ui:input-editor
        contents="Default Content"
        cssClass="my-alloy-editor"
        editorName="alloyeditor"
        name="myAlloyEditor"
        onInitMethod="OnDescriptionEditorInit"
        placeholder="description"
        showSource="true" />
</div>

<aui:script>
    function <portlet:namespace />OnDescriptionEditorInit() {
        <c:if test="<%= !customAbstract %>">
            document.getElementById('<portlet:namespace />myAlloyEditor').setAttribute('contenteditable', false);
        </c:if>
    }
</aui:script>
\end{verbatim}

Below is an overview of the main attributes of the
\texttt{\textless{}liferay-ui:input-editor\ /\textgreater{}} tag:

\noindent\hrulefill

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.3333}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Attribute
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Type
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Description
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
autoCreate & \texttt{java.lang.String} & Whether to show the HTML edit
view of the editor initially \\
contents & \texttt{java.lang.String} & Sets the initial contents of the
editor \\
contentsLanguageId & \texttt{java.lang.String} & Sets the language ID
for the input editor's text \\
cssClass & \texttt{java.lang.String} & A CSS class for styling the
component. \\
data & \texttt{java.util.Map} & Data that can be used as the
editorConfig \\
editorName & \texttt{java.lang.String} & The editor you want to use
(alloyeditor, ckeditor, tinymce, simple) \\
name & \texttt{java.lang.String} & A name for the input editor. The
default value is \texttt{editor}. \\
onBlurMethod & \texttt{java.lang.String} & A function to be called when
the input editor loses focus. \\
onChangeMethod & \texttt{java.lang.String} & A function to be called on
a change in the input editor. \\
onFocusMethod & \texttt{java.lang.String} & A function to be called when
the input editor gets focus. \\
onInitMethod & \texttt{java.lang.String} & A function to be called when
the input editor initializes. \\
placeholder & \texttt{java.lang.String} & Placeholder text to display in
the input editor. \\
showSource & \texttt{java.lang.String} & Whether to enable editing the
HTML source code of the content. The default value is \texttt{true}. \\
\end{longtable}

\noindent\hrulefill

See the
\href{@platform-ref@/7.0-latest/taglibs/util-taglib/liferay-ui/input-editor.html}{taglibdocs}
for the complete list of supported attributes.

As you can see, it's easy to include WYSIWYG editors in your portlets!

\subsection{Related Topics}\label{related-topics-161}

\href{/docs/7-0/tutorials/-/knowledge_base/t/adding-new-behavior-to-an-editor}{Adding
New Behavior to an Editor}

\href{/docs/7-0/tutorials/-/knowledge_base/t/modifying-an-editors-configuration}{Modifying
an Editor's Configuration}

\href{/docs/7-0/tutorials/-/knowledge_base/t/using-the-liferay-ui-taglib}{Using
the Liferay UI Taglib}

\section{Modifying an Editor's
Configuration}\label{modifying-an-editors-configuration}

Liferay DXP supports many different kinds of WYSIWYG editors that can be
used in portlets to edit content. Depending on the content you're
editing, you may want to modify the editor to provide a better
configuration for your needs. In this tutorial, you'll learn how to
extend your Liferay supported WYSIWYG editor to add new or modify
existing configurations exactly how you'd like.

\subsection{Extending the Editor's
Configuration}\label{extending-the-editors-configuration}

To modify the editor's configuration, create a module that has a
component that implements the
\href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/editor/configuration/EditorConfigContributor.html}{\texttt{EditorConfigContributor}}
interface. When you implement this interface, your module will provide a
service that modifies the editors you'd like to change. A simple example
of this is provided below.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/starting-module-development\#creating-a-module}{Create
  an OSGi module}.
\item
  Create a unique package name in the module's \texttt{src} directory,
  and create a new Java class in that package. The class should extend
  the
  \href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/editor/configuration/BaseEditorConfigContributor.html}{BaseEditorConfigContributor}
  class.
\item
  Directly above the class's declaration, insert a component annotation:

\begin{verbatim}
@Component(
    property = {

    },

    service = EditorConfigContributor.class
)
\end{verbatim}

  This annotation declares the implementation class of the Component and
  specifies the Component's properties. You should implement the
  \texttt{EditorConfigContributor} interface for this scenario. The
  \texttt{property} element is blank in the code snippet above. You need
  to insert properties that distinguish the editor's name, editor's
  configuration key, and/or the portlet name where the editor resides.
  These three properties can be specified independently or in any
  variation with each other. You can find out more about the available
  properties and how they should be used by reading the Javadoc provided
  in the
  \href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/editor/configuration/EditorConfigContributor.html}{EditorConfigContributor}
  interface.

  The following code is a sample of what the \texttt{@Component}
  annotation could look like when modifying an editor's configuration:

\begin{verbatim}
@Component(
    property = {
        "editor.config.key=contentEditor", "editor.name=alloyeditor",
        "javax.portlet.name=com_liferay_blogs_web_portlet_BlogsPortlet",
        "javax.portlet.name=com_liferay_blogs_web_portlet_BlogsAdminPortlet", 
        "service.ranking:Integer=100"
    },

    service = EditorConfigContributor.class
)
\end{verbatim}

  This annotation declares that the following service is applied for the
  AlloyEditor identified by the \texttt{contentEditor} configuration
  key.
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** If you're targeting all editors for a portlet, the
 `editor.config.key` is not required. For example, if you just want to target
 the Web Content portlet's editors, you can provide the configuration below:
 
     @Component(
       property = {"editor.name=ckeditor",
       "javax.portlet.name=com_liferay_journal_web_portlet_JournalPortlet",
       "service.ranking:Integer=100"
     }
\end{verbatim}

\noindent\hrulefill

\begin{verbatim}
Two portlet names are specified (Blogs and Blogs Admin), which means the 
service applies to all editors in those portlets. Lastly, the service 
ranking is listed, which prioritizes this service over others that are 
currently deployed in Liferay DXP.
\end{verbatim}

\noindent\hrulefill

\begin{verbatim}
 **NOTE:** If you want to create a global configuration that applies to an
 editor everywhere it's used, you must create two separate configurations:
 one configuration that targets just the editor and a second configuration
 that targets the Blogs and Blogs Admin portlets. For example, the two
 separate configurations below apply the updates to AlloyEditor everywhere
 it's used:
 
 Configuration one:
 
 ```java
 @Component(
     immediate = true,
     property = {
         "editor.name=alloyeditor",
         "service.ranking:Integer=100"
     },
 
     service = EditorConfigContributor.class
 )
 ```
 
 Configuration two:
 
 ```java
 @Component(
     immediate = true,
     property = {
         "editor.name=alloyeditor",
         "javax.portlet.name=com_liferay_blogs_web_portlet_BlogsPortlet",
         "javax.portlet.name=com_liferay_blogs_web_portlet_BlogsAdminPortlet",
         "service.ranking:Integer=100"
     },
 
     service = EditorConfigContributor.class
 )
 ```
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{3}
\item
  Now that you've specified which editor configurations you want to
  modify, you must specify what about them must change. Add the
  following method to your new class:

\begin{verbatim}
@Override
public void populateConfigJSONObject(
    JSONObject jsonObject, Map<String, Object> inputEditorTaglibAttributes,
    ThemeDisplay themeDisplay,
    RequestBackedPortletURLFactory requestBackedPortletURLFactory) {

}
\end{verbatim}

  This method updates the original configuration JSON object with a new
  configuration. It can even update or delete the original
  configuration, or any other configuration introduced by another
  \texttt{EditorConfigContributor}. The configuration object contains
  the configuration to be directly used by the editor. This means that
  the configuration object used for this editor may differ from other
  editors used in Liferay DXP.

  Currently, this method does nothing. You need to add some logic, which
  you'll do next.
\item
  In the \texttt{populateConfigJSONObject} method, you need to
  instantiate a
  \href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/json/JSONObject.html}{JSONObject}
  that holds the current configuration of the editor. For instance, you
  could do something like this:

\begin{verbatim}
JSONObject toolbars = jsonObject.getJSONObject("toolbars");
\end{verbatim}

  This gets the editor's toolbar.
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** This toolbar configuration is only applicable for the AlloyEditor.
 If you choose a configuration that is supported by multiple editors, you
 could apply it to them all. To do this, you could specify all the editors
 (e.g., `"editor.name=alloyeditor"`, `"editor.name=ckeditor"`,
 `ckeditor_bbcode` etc.) in the `@Component` annotation  of your
 `EditorConfigContributor` implementation, as you did in step 3. Use the
 site links provided at the bottom of this tutorial to view each editor's
 configuration options and requirements.
\end{verbatim}

\noindent\hrulefill

\begin{verbatim}
Now that you've retrieved the toolbar, you can modify it. You'll do this
next.
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{5}
\item
  You'll modify the editor's toolbar by adding a camera button. To
  complete this, extract the \emph{Add} buttons out of your toolbar
  configuration object as a
  \href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/json/JSONArray.html}{JSONArray},
  and then add the button to that \texttt{JSONArray}. The following code
  adds a \emph{Camera} button to the editor's toolbar:

\begin{verbatim}
if (toolbars != null) {
    JSONObject toolbarAdd = toolbars.getJSONObject("add");

    if (toolbarAdd != null) {
        JSONArray addButtons = toolbarAdd.getJSONArray("buttons");

        addButtons.put("camera");
    }
}
\end{verbatim}

  The configuration JSON object is passed to the editor with the
  modifications you've implemented in the
  \texttt{populateConfigJSONObject} method.
\end{enumerate}

Your Java class is complete! The only thing left to do is generate the
module's JAR file and copy it to your Portal's \texttt{deploy} folder.
Once the module is installed and activated in your Portal's service
registry, your new editor configuration is available for use.

Liferay DXP supports several different types of WYSIWYG editors, which
include (among others):

\begin{itemize}
\tightlist
\item
  \href{https://alloyeditor.com/api/1.4.1/}{AlloyEditor}
\item
  \href{http://docs.ckeditor.com/\#!/api/CKEDITOR.config}{CKEditor}
\item
  \href{http://www.tinymce.com/wiki.php/Configuration}{TinyMCE}
\end{itemize}

Make sure to visit each editor's configuration API to learn what each
editor offers for configuration settings.

\subsection{Related Topics}\label{related-topics-162}

\href{/docs/7-0/tutorials/-/knowledge_base/t/adding-new-behavior-to-an-editor}{Adding
New Behavior to an Editor}

\href{/docs/7-0/tutorials/-/knowledge_base/t/embedding-portlets-in-themes}{Embedding
Portlets in Themes}

\href{/docs/7-0/tutorials/-/knowledge_base/t/portlets}{Developing
Portlets}

\section{Adding New Behavior to an
Editor}\label{adding-new-behavior-to-an-editor}

With the support of several kinds of WYSIWYG editors, Liferay gives you
many options to support your users' editing needs. Sometimes, however,
you can't get what you want with configuration alone. To help developers
in these situations, Liferay provides a way to programmatically access
the editor instance to create the editor experience you want.

This can be done by using the \texttt{liferay-util:dynamic-include}
JavaScript extension point. This allows anyone to inject JavaScript code
right after the editor instantiation to configure/change the editor.

\noindent\hrulefill

\textbf{Note:} By default, the CKEditor strips empty
\texttt{\textless{}i\textgreater{}} tags, such as those used for Font
Awesome icons, from published content, when switching between the Code
View and the Source View of the editor. You can disable this behavior by
using the \texttt{ckeditor\#onEditorCreate} or
\texttt{alloyeditor\#onEditorCreate} extension points to
\href{/docs/7-0/tutorials/-/knowledge_base/t/adding-new-behavior-to-an-editor}{add
the following code} to the editor:

\begin{verbatim}
 CKEDITOR.dtd.$removeEmpty.i = 0
\end{verbatim}

\noindent\hrulefill

In this tutorial, you'll learn how to use the JavaScript extension point
in your Liferay supported WYSIWYG editor.

\subsection{Injecting JavaScript into a WYSIWYG
Editor}\label{injecting-javascript-into-a-wysiwyg-editor}

The \texttt{liferay-util:dynamic-include} extension point is available
in the JSP files of Liferay DXP's configurable editors. This extension
point serves as the gateway for injecting JavaScript into your editor
instance. To take advantage of this extension point, you should follow
these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a JS file with the JavaScript code you'd like to execute in
  your editor. Create the JS file in a folder that makes sense to
  reference, since you'll need to register the file in your module. Also
  remember that the extension point is configured to inject the
  JavaScript code into the editor immediately following editor
  initialization.

  Some examples of JS files that are injected into the CKEditor are
  \href{https://github.com/liferay/liferay-portal/blob/7.0.6-ga7/modules/apps/foundation/frontend-editor/frontend-editor-ckeditor-web/src/main/resources/META-INF/resources/_diffs/extension/creole_dialog_definition.js}{creole\_dialog\_definition.js},
  \href{https://github.com/liferay/liferay-portal/blob/7.0.6-ga7/modules/apps/foundation/frontend-editor/frontend-editor-ckeditor-web/src/main/resources/META-INF/resources/_diffs/extension/creole_dialog_show.js}{creole\_dialog\_show.js},
  and
  \href{https://github.com/liferay/liferay-portal/blob/7.0.6-ga7/modules/apps/foundation/frontend-editor/frontend-editor-ckeditor-web/src/main/resources/META-INF/resources/_diffs/extension/dialog_definition.js}{dialog\_definition.js}.
  These JS files are used by Liferay DXP to redefine which fields show
  in different dialogs, depending on what the selected language (HTML,
  BBCode, Creole) supports. For example, Creole doesn't support
  background color in table cells, so the table cells are removed from
  the options displayed to the user when running in Creole mode.
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/starting-module-development\#creating-a-module}{Create
  a module} that can register your new JS file and inject it into your
  editor instance. The module should have a structure similar to this:

  \begin{itemize}
  \tightlist
  \item
    \texttt{bnd.bnd}
  \item
    \texttt{build.gradle}
  \item
    \texttt{gradle/}

    \begin{itemize}
    \tightlist
    \item
      \texttt{wrapper/}

      \begin{itemize}
      \tightlist
      \item
        \texttt{gradle-wrapper.jar}\strut \\
      \item
        \texttt{gradle-wrapper.properties}
      \end{itemize}
    \end{itemize}
  \item
    \texttt{gradlew}
  \item
    \texttt{gradlew.bat}
  \item
    \texttt{src/main/}

    \begin{itemize}
    \tightlist
    \item
      \texttt{java/com/liferay/editor/myeditormodule/}

      \begin{itemize}
      \tightlist
      \item
        \texttt{constants/}

        \begin{itemize}
        \tightlist
        \item
          \texttt{MyEditorModulePortletKeys.java}
        \end{itemize}
      \item
        \texttt{internal/}

        \begin{itemize}
        \tightlist
        \item
          \texttt{CKEditorOnDialogDefinitionCreateDynamicInclude.java}
        \end{itemize}
      \end{itemize}
    \item
      \texttt{resources/}

      \begin{itemize}
      \tightlist
      \item
        \texttt{META-INF/resources/ckeditor/extension/}

        \begin{itemize}
        \tightlist
        \item
          \texttt{ckeditor\_dialog\_definition.js}
        \end{itemize}
      \item
        \texttt{content/}

        \begin{itemize}
        \tightlist
        \item
          \texttt{Language.properties}
        \end{itemize}
      \end{itemize}
    \end{itemize}
  \end{itemize}
\item
  Create a unique package name in the module's \texttt{src} directory,
  and create a new Java class in that package. To follow naming
  conventions, your class name should begin with the editor you're
  modifying, followed by custom attributes, and ending with
  \emph{DynamicInclude} (e.g.,
  \texttt{CKEditorCreoleOnEditorCreateDynamicInclude.java}). Your Java
  class should implement the
  \href{https://github.com/liferay/liferay-portal/blob/7.0.6-ga7/portal-kernel/src/com/liferay/portal/kernel/servlet/taglib/DynamicInclude.java}{DynamicInclude}
  interface.
\item
  Directly above the class's declaration, insert the following code:

\begin{verbatim}
@Component(immediate = true, service = DynamicInclude.class)
\end{verbatim}

  This annotation declares the implementation class of the Component,
  and specifies to immediately start the module once deployed to Portal.
\item
  If you have not yet inherited the abstract methods from
  \texttt{DynamicInclude}, do that now. You'll have two implemented
  methods to edit: \texttt{include(...)} and \texttt{register(...)}.
\item
  In the \texttt{include(...)} method, retrieve the bundle where your
  custom JS file resides. Then retrieve the JS file as a URL and inject
  the contents into the editor. You can view some example code below
  that does this for the \texttt{creole\_dialog\_definition.js} file:

\begin{verbatim}
Bundle bundle = _bundleContext.getBundle();

URL entryURL = bundle.getEntry(
    "/META-INF/resources/html/editors/ckeditor/extension" +
        "/creole_dialog_definition.js");

StreamUtil.transfer(entryURL.openStream(), response.getOutputStream());
\end{verbatim}

  In the \texttt{include(...)} method, you can also retrieve editor
  configurations and choose what JS file to inject based on the
  configuration selected by the user. For example, this would be
  applicable for the use case that was suggested previously dealing with
  Creole's deficiency with displaying background colors in table cells.
  You can look at how this could be done by looking at the
  \texttt{include(...)} method in the
  \href{https://github.com/liferay/liferay-portal/blob/7.0.6-ga7/modules/apps/foundation/frontend-editor/frontend-editor-ckeditor-web/src/main/java/com/liferay/frontend/editor/ckeditor/web/internal/servlet/taglib/CKEditorCreoleOnEditorCreateDynamicInclude.java}{CKEditorCreoleOnEditorCreateDynamicInclude}
  class.
\item
  Make sure you've instantiated your bundle's context so you can
  successfully retrieve your bundle. As a best practice, do this by
  creating an activation method and then setting the
  \texttt{BundleContext} as a private field. Here's an example:

\begin{verbatim}
@Activate
protected void activate(BundleContext bundleContext) {
    _bundleContext = bundleContext;
}

private BundleContext _bundleContext;
\end{verbatim}

  This method uses the \texttt{@Activate} annotation, which specifies
  that it should be invoked once the service component has satisfied its
  requirements. For this default example, the \texttt{\_bundleContext}
  was used in the \texttt{include(...)} method.
\item
  Now register the editor you're customizing. For example, if you were
  injecting JS code into the CKEditor's JSP file, the code would look
  like this:

\begin{verbatim}
dynamicIncludeRegistry.register(
    "com.liferay.frontend.editor.ckeditor.web#ckeditor#onEditorCreate");
\end{verbatim}

  This registers the CKEditor into the Dynamic Include registry and
  specifies that JS code will be injected into the editor once it's
  created.

  Just as you can configure individual JSP pages to use a specific
  implementation of the available WYSIWYG editors, you can use those
  same implementation options for the registration process. Visit the
  \href{@platform-ref@/7.0-latest/propertiesdoc/portal.properties.html\#Editors}{Editors}
  section of \texttt{portal.properties} for more details. For example,
  to configure the Creole implementation of the CKEditor, you could use
  the following key:

\begin{verbatim}
"com.liferay.frontend.editor.ckeditor.web#ckeditor_creole#onEditorCreate"
\end{verbatim}
\end{enumerate}

That's it! The JS code that you created is now injected into the editor
instance you've specified. You're now able to use JavaScript to add new
behavior to your Liferay supported WYSIWYG editor!

\subsection{Related Topics}\label{related-topics-163}

\href{/docs/7-0/tutorials/-/knowledge_base/t/modifying-an-editors-configuration}{Modifying
an Editor's Configuration}

\href{/docs/7-0/tutorials/-/knowledge_base/t/embedding-portlets-in-themes}{Embedding
Portlets in Themes}

\href{/docs/7-0/tutorials/-/knowledge_base/t/portlets}{Portlets}

\chapter{AlloyEditor}\label{alloyeditor}

AlloyEditor is a modern WYSIWYG editor built on top of CKEDITOR,
designed to create modern and gorgeous web content.

As of Liferay DXP, AlloyEditor is the default WYSIWYG editor in
Liferay DXP. Writing content is now enjoyable, and it has never been so
easy!

\begin{figure}
\centering
\includegraphics{./images/alloyeditor-website.png}
\caption{AlloyEditor is the new WYSIWYG editor by default, built on top
of CKEditor.}
\end{figure}

\section{Creating and Contributing new Buttons to
AlloyEditor}\label{creating-and-contributing-new-buttons-to-alloyeditor}

It is possible to add additional AlloyEditor functionality through OSGi
bundles. This tutorial demonstrates how to add a button to the editor.

\noindent\hrulefill

\textbf{Note:} To use the syntax covered here, you must have AlloyEditor
2.11.0 or higher, which is included in Liferay DXP 7.0 Fix Pack 90 and
Service Pack 13.

\noindent\hrulefill

In this tutorial, you will learn how to

\begin{itemize}
\tightlist
\item
  Create an OSGi bundle for your own button
\item
  Create a custom button for \texttt{AlloyEditor}
\item
  Contribute your button to the list of available buttons
\item
  Use your custom button in a toolbar in \texttt{AlloyEditor}
\end{itemize}

Go ahead and get started by creating the OSGi bundle next.

\subsection{Creating the OSGi Bundle}\label{creating-the-osgi-bundle}

AlloyEditor is built on \texttt{React.js} and uses \texttt{jsx} to
render each button in the editor. Below is the folder structure for a
module that adds a new button:

\begin{itemize}
\tightlist
\item
  \texttt{frontend-editor-my-button-web}

  \begin{itemize}
  \item
    \texttt{src}

    \begin{itemize}
    \tightlist
    \item
      \texttt{main}

      \begin{itemize}
      \tightlist
      \item
        \texttt{java} -
        \texttt{com/liferay/frontend/editor/my/button/web/}

        \begin{itemize}
        \tightlist
        \item
          \texttt{editor}
        \end{itemize}
      \item
        \texttt{configuration}

        \begin{itemize}
        \tightlist
        \item
          \texttt{AlloyEditorMyButtonConfigContributor.java}
        \end{itemize}
      \end{itemize}
    \item
      \texttt{servlet}

      \begin{itemize}
      \tightlist
      \item
        \texttt{taglib}

        \begin{itemize}
        \tightlist
        \item
          \texttt{AlloyEditorMyButtonDynamicInclude.java}
        \end{itemize}
      \end{itemize}
    \item
      \texttt{resources}

      \begin{itemize}
      \tightlist
      \item
        \texttt{META-INF}

        \begin{itemize}
        \tightlist
        \item
          \texttt{resources}
        \item
          \texttt{js}

          \begin{itemize}
          \tightlist
          \item
            \texttt{my\_button.jsx}
          \end{itemize}
        \end{itemize}
      \end{itemize}
    \end{itemize}
  \item
    \texttt{.babelrc} - needed since \texttt{JSX} is being compiled
  \item
    \texttt{bnd.bnd}(example configuration shown below)

    Bundle-Name: Liferay Frontend Editor AlloyEditor My Button Web
    Bundle-SymbolicName:
    com.liferay.frontend.editor.alloyeditor.my.button.web
    Bundle-Version: 1.0.0 Liferay-Releng-Module-Group-Description:
    Liferay-Releng-Module-Group-Title: Rich Text Editors
    Web-ContextPath: /frontend-editor-alloyeditor-my-button-web
  \item
    \texttt{build.gradle}(contents shown below)

    configJSModules \{ enabled = false \}

    dependencies \{ provided group: ``com.liferay.portal'', name:
    ``com.liferay.portal.kernel'', version: ``2.0.0'' provided group:
    ``javax.servlet'', name: ``javax.servlet-api'', version: ``3.0.1''
    provided group: ``org.osgi'', name:
    ``org.osgi.service.component.annotations'', version: ``1.3.0'' \}

    transpileJS \{ bundleFileName = ``js/buttons.js'' globalName =
    ``AlloyEditor.Buttons'' modules = ``globals'' srcIncludes =
    ``**/*.jsx'' \}
  \item
    \texttt{package.json}(contents shown below)

    \{ ``devDependencies'': \{ ``babel-preset-react'': ``\^{}6.11.1'',
    ``metal-cli'': ``\^{}2.0.0'' \}, ``name'':
    ``frontend-editor-alloyeditor-my-button-web'', ``version'':
    ``1.0.0'' \}
  \end{itemize}
\end{itemize}

The contents of some of the files have been added as well, since the
\texttt{build\ gradle} file requires some customizing.

Now that your OSGi bundle is configured, you can learn how to create
buttons for the AlloyEditor next.

\subsection{Creating the Button}\label{creating-the-button}

Below is an example configuration for a JSX file that creates a new
button:

\begin{verbatim}
/* global React, ReactDOM AlloyEditor */
(function() {
        'use strict';
        var React = AlloyEditor.React;
        var ButtonMyButton = React.createClass(
                {
                        mixins: [AlloyEditor.Compat.ButtonStateClasses],
                        displayName: 'ButtonMyButton',
                        propTypes: {
                                editor: React.PropTypes.object.isRequired
                        },
                        statics: {
                                key: 'myButton'
                        },
                        /**
                         * Lifecycle. Renders the UI of the button.
                         *
                         * @method render
                         * @return {Object} The content which should be rendered.
                         */
                        render: function() {
                                var cssClass = 'ae-button ' + this.getStateClasses();
                                return (
                                        <button className={cssClass} 
                                        onClick={this._requestExclusive} 
                                        tabIndex={this.props.tabIndex}>
                                                <small className="ae-icon small">
                                                Alt
                                                </small>
                                        </button>
                                );
                        },
                        /**
                         * @protected
                         * @method  _doSomething
                         * @param {MouseEvent} event
                         */
                        _doSomething: function(event) {
                                console.log('do something!');
                        }
                }
        );
        AlloyEditor.Buttons[ButtonMyButton.key] = AlloyEditor.ButtonMyButton 
        = ButtonMyButton;
}());
\end{verbatim}

The configuration above creates a new button called
\texttt{ButtonMyButton}. The key aspects to note here are the lines that
reference the global \texttt{AlloyEditor}. You can create your own
JavaScript functions to interact with your button.

Now that you've seen how you can use a JSX file to create a new button,
you can learn how to use your button in the editor next.

\subsection{Contributing the Button}\label{contributing-the-button}

The next step is to add your button to the list of already available
buttons. This can be achieved thanks to some smartly placed
\texttt{\textless{}liferay-util:dynamic-include\ /\textgreater{}} tags
in the editor's infrastructure. To make your button available in the
AlloyEditor, you must extend the
\href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/servlet/taglib/BaseDynamicInclude.html}{\texttt{BaseDynamicInclude}
class}. Below is an example configuration that extends this class:

\begin{verbatim}
package com.liferay.frontend.editor.alloyeditor.my.button.web.servlet.taglib;

import com.liferay.portal.kernel.servlet.taglib.BaseDynamicInclude;
import com.liferay.portal.kernel.servlet.taglib.DynamicInclude;
import com.liferay.portal.kernel.theme.ThemeDisplay;
import com.liferay.portal.kernel.util.PortalUtil;
import com.liferay.portal.kernel.util.StringBundler;
import com.liferay.portal.kernel.util.WebKeys;

import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.ServletContext;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Reference;

@Component(immediate = true, service = DynamicInclude.class)
public class AlloyEditorMyButtonDynamicInclude extends BaseDynamicInclude {

        @Override
        public void include(
                        HttpServletRequest request, HttpServletResponse response,
                        String key)
                throws IOException {

                ThemeDisplay themeDisplay = (ThemeDisplay)request.getAttribute(
                        WebKeys.THEME_DISPLAY);

                PrintWriter printWriter = response.getWriter();

                StringBundler sb = new StringBundler(7);

                sb.append("<script src=\"");
                sb.append(themeDisplay.getPortalURL());
                sb.append(PortalUtil.getPathProxy());
                sb.append(_servletContext.getContextPath());
                sb.append("/js/buttons.js");
                sb.append("\" ");
                sb.append("type=\"text/javascript\"></script>");

                printWriter.println(sb.toString());
        }

        @Override
        public void register(DynamicIncludeRegistry dynamicIncludeRegistry) {
                dynamicIncludeRegistry.register(
                        "com.liferay.frontend.editor.alloyeditor.web#alloyeditor#" +
                                "additionalResources");
        }

        @Reference(
                target = "(osgi.web.symbolicname=com.liferay.frontend.editor.alloyeditor.my.button.web)"
        )
        private ServletContext _servletContext;
}
\end{verbatim}

Now that your button is included, you can learn how to make the button
available in the editor's toolbar next.

\subsection{Using the Button in a
Toolbar}\label{using-the-button-in-a-toolbar}

As explained in the
\href{/docs/7-0/tutorials/-/knowledge_base/t/modifying-an-editors-configuration}{Modifying
an Editor's Configuration} tutorial, you can configure which buttons
show in the AlloyEditor toolbars by adding your own
\texttt{EditorConfigContributor}. This file allows you to specify where
in the toolbar your button should appear. The example configuration
below doesn't specify a portlet name, so the button is added to the
global AlloyEditor.

\begin{verbatim}
package com.liferay.frontend.editor.alloyeditor.my.button.web.editor.configuration;

import com.liferay.portal.kernel.editor.configuration.BaseEditorConfigContributor;
import com.liferay.portal.kernel.editor.configuration.EditorConfigContributor;
import com.liferay.portal.kernel.json.JSONArray;
import com.liferay.portal.kernel.json.JSONFactoryUtil;
import com.liferay.portal.kernel.json.JSONObject;
import com.liferay.portal.kernel.portlet.RequestBackedPortletURLFactory;
import com.liferay.portal.kernel.theme.ThemeDisplay;

import java.util.Map;
import java.util.Objects;

import org.osgi.service.component.annotations.Component;

@Component(
        property = {"editor.name=alloyeditor", "service.ranking:Integer=1000"},
        service = EditorConfigContributor.class
)
public class AlloyEditorMyButtonConfigContributor
        extends BaseEditorConfigContributor {

        @Override
        public void populateConfigJSONObject(
                JSONObject jsonObject, Map<String, Object> inputEditorTaglibAttributes,
                ThemeDisplay themeDisplay,
                RequestBackedPortletURLFactory requestBackedPortletURLFactory) {

                JSONObject toolbarsJSONObject = jsonObject.getJSONObject("toolbars");

                if (toolbarsJSONObject == null) {
                        toolbarsJSONObject = JSONFactoryUtil.createJSONObject();
                }

                JSONObject stylesJSONObject = toolbarsJSONObject.getJSONObject(
                        "styles");

                if (stylesJSONObject == null) {
                        stylesJSONObject = JSONFactoryUtil.createJSONObject();
                }

                JSONArray selectionsJSONArray = stylesJSONObject.getJSONArray(
                        "selections");

                for (int i = 0; i < selectionsJSONArray.length(); i++) {
                        JSONObject selection = selectionsJSONArray.getJSONObject(i);

                        if (Objects.equals(selection.get("name"), "text")) {
                                JSONArray buttons = selection.getJSONArray("buttons");

                                buttons.put("myButton");
                        }
                }

                stylesJSONObject.put("selections", selectionsJSONArray);

                toolbarsJSONObject.put("styles", stylesJSONObject);

                jsonObject.put("toolbars", toolbarsJSONObject);
        }
}
\end{verbatim}

There you have it. Now you know how to create and use custom buttons in
the AlloyEditor!

\subsection{Related Topics}\label{related-topics-164}

\href{/docs/7-0/tutorials/-/knowledge_base/t/adding-a-wysiwyg-editor-to-a-portlet}{Adding
a WYSIWYG Editor to a Portlet}

\href{/docs/7-0/tutorials/-/knowledge_base/t/modifying-an-editors-configuration}{Modifying
an Editor's Configuration}

\section{Using the Default CKEditor Plugins Bundled with
AlloyEditor}\label{using-the-default-ckeditor-plugins-bundled-with-alloyeditor}

You can customize an editor's configuration to include several
modifications, such as
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-and-contributing-new-buttons-to-alloyeditor}{adding
new buttons} and
\href{/docs/7-0/tutorials/-/knowledge_base/t/adding-new-behavior-to-an-editor}{adding
new behaviors}. You can also use existing CKEditor plugins in
AlloyEditor. Several CKEditor plugins are packaged with Liferay DXP's
AlloyEditor, so you can use them with just a few configuration
adjustments. This tutorial shows how to use the CKEditor plugins bundled
with Liferay DXP's AlloyEditor. The
\href{https://github.com/liferay/liferay-docs/tree/7.0.x/develop/tutorials/code/my-blogs-editor-config-contributor}{\texttt{com.liferay.docs.myblogseditorconfigcontributor}
module} is used as an example throughout this tutorial.

Follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a module to
  \href{/docs/7-0/tutorials/-/knowledge_base/t/modifying-an-editors-configuration}{modify
  the AlloyEditor's configuration}. The example boilerplate below
  modifies the AlloyEditor's configuration for the Blogs and Blogs Admin
  portlets:

\begin{verbatim}
@Component(
    immediate = true,
    property = {
        "editor.config.key=contentEditor",
        "editor.name=alloyeditor",
        "editor.name=ckeditor",
        "javax.portlet.name=com_liferay_blogs_web_portlet_BlogsPortlet",
        "javax.portlet.name=com_liferay_blogs_web_portlet_BlogsAdminPortlet",
        "service.ranking:Integer=100"
    },
    service = EditorConfigContributor.class
)
public class MyBlogsEditorConfigContributor
  extends BaseEditorConfigContributor {

    @Override
    public void populateConfigJSONObject(
      JSONObject jsonObject, Map<String, Object> inputEditorTaglibAttributes,
      ThemeDisplay themeDisplay,
      RequestBackedPortletURLFactory requestBackedPortletURLFactory) {

    }
  }
\end{verbatim}
\item
  Add additional plugins to the AlloyEditor via the
  \texttt{extraPlugins} JSON object. To add a CKEditor plugin, extract
  the current list of \texttt{extraPlugins} from your editor
  configuration object as a \texttt{String}:

\begin{verbatim}
String extraPlugins = jsonObject.getString("extraPlugins");
\end{verbatim}
\item
  Choose the plugin(s) you want to use from the
  \href{/docs/7-0/reference/-/knowledge_base/r/ckeditor-plugin-reference-guide}{default
  CKEditor plugins bundled with Liferay DXP's AlloyEditor}.
\item
  Add the CKEditor plugin(s) you want to use to the
  \texttt{extraPlugins} configuration. Liferay DXP's AlloyEditor also
  comes with several plugins to bridge the gap between the CKEditor's UI
  and the AlloyEditor's UI. These are prefixed with \texttt{ae\_}. We
  recommend that you include them all to ensure compatibility. The
  example below checks for existing \texttt{extraPlugins} and adds the
  \href{https://ckeditor.com/cke4/addon/font}{\texttt{font} CKEditor
  plugin} along with its required
  \href{https://ckeditor.com/cke4/addon/richcombo}{Rich Combo plugin}
  dependency and the remaining UI bridge plugins:

\begin{verbatim}
if (Validator.isNotNull(extraPlugins)) {
  extraPlugins = extraPlugins + ",ae_uibridge,ae_autolink,ae_buttonbridge,ae_menubridge,ae_panelmenubuttonbridge,ae_placeholder,ae_richcombobridge,font"; 
}
else {
  extraPlugins = "ae_uibridge,ae_autolink,ae_buttonbridge,ae_menubridge,ae_panelmenubuttonbridge,ae_placeholder,ae_richcombobridge,font";
}

jsonObject.put("extraPlugins", extraPlugins);
\end{verbatim}
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** Make sure the `ae_uibridge` plugin appears first, followed by
 the remaining UI bridge plugins, and finally the CKEditor plugin(s).
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{4}
\item
  If the plugin includes buttons, add them in the appropriate toolbar.
  The configuration below retrieves the Text Selection Toolbar's buttons
  and adds the \texttt{font} plugin's \texttt{Font} and
  \texttt{FontSize} buttons to it:

\begin{verbatim}
JSONObject toolbarsJSONObject = jsonObject.getJSONObject("toolbars");

if (toolbarsJSONObject == null) {
 toolbarsJSONObject = JSONFactoryUtil.createJSONObject();
}

JSONObject stylesJSONObject = toolbarsJSONObject.getJSONObject(
 "styles");

if (stylesJSONObject == null) {
 stylesJSONObject = JSONFactoryUtil.createJSONObject();
}

JSONArray selectionsJSONArray = stylesJSONObject.getJSONArray(
 "selections");

for (int i = 0; i < selectionsJSONArray.length(); i++) {
 JSONObject selection = selectionsJSONArray.getJSONObject(i);

    if (Objects.equals(selection.get("name"), "text")) {
     JSONArray buttons = selection.getJSONArray("buttons");

     buttons.put("Font");
     buttons.put("FontSize");
    }

 }

 stylesJSONObject.put("selections", selectionsJSONArray);

 toolbarsJSONObject.put("styles", stylesJSONObject);

 jsonObject.put("toolbars", toolbarsJSONObject);
\end{verbatim}
\end{enumerate}

\noindent\hrulefill

\textbf{Note:} A plugin's buttons may not have the same name as the
plugin. You can find the button names for a plugin by
\href{/docs/7-0/reference/-/knowledge_base/r/ckeditor-plugin-reference-guide}{searching
its \texttt{plugin.js} file} for \texttt{editor.ui.addButton}. Note that
button names are case sensitive and may be aliased in the
\texttt{addButton()} method, such as the
\href{https://github.com/ckeditor/ckeditor-dev/blob/release/4.0.x/plugins/clipboard/plugin.js\#L341-L350}{\texttt{clipboard}
plugin's} \texttt{Cut}, \texttt{Copy}, and \texttt{Paste} buttons.

\noindent\hrulefill

Below is the full example \texttt{*EditorConfigContributor} class that
adds the \texttt{font} plugin to the AlloyEditor for the Blogs and Blogs
Admin portlets:

\begin{verbatim}
package com.liferay.docs.myblogseditorconfigcontributor;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Objects;

import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Reference;


import com.liferay.portal.kernel.editor.configuration.BaseEditorConfigContributor;
import com.liferay.portal.kernel.editor.configuration.EditorConfigContributor;
import com.liferay.portal.kernel.json.JSONArray;
import com.liferay.portal.kernel.json.JSONFactoryUtil;
import com.liferay.portal.kernel.json.JSONObject;
import com.liferay.portal.kernel.portlet.RequestBackedPortletURLFactory;
import com.liferay.portal.kernel.theme.ThemeDisplay;
import com.liferay.portal.kernel.util.Portal;
import com.liferay.portal.kernel.util.Validator;

/**
 * @author liferay
 */
 @Component(
    immediate = true,
    property = {
        "editor.config.key=contentEditor",
        "editor.name=alloyeditor",
        "editor.name=ckeditor",
        "javax.portlet.name=com_liferay_blogs_web_portlet_BlogsPortlet",
        "javax.portlet.name=com_liferay_blogs_web_portlet_BlogsAdminPortlet",
        "service.ranking:Integer=100"
    },
    service = EditorConfigContributor.class
 )
 public class MyBlogsEditorConfigContributor
   extends BaseEditorConfigContributor {
 
   @Override
   public void populateConfigJSONObject(
     JSONObject jsonObject, Map<String, Object> inputEditorTaglibAttributes,
     ThemeDisplay themeDisplay,
     RequestBackedPortletURLFactory requestBackedPortletURLFactory) {
             
            String extraPlugins = jsonObject.getString("extraPlugins");
             
             if (Validator.isNotNull(extraPlugins)) {
                  extraPlugins = extraPlugins + ",ae_uibridge,ae_autolink,ae_buttonbridge,ae_menubridge,ae_panelmenubuttonbridge,ae_placeholder,ae_richcombobridge,font"; 
                }
                else {
                  extraPlugins = "ae_uibridge,ae_autolink,ae_buttonbridge,ae_menubridge,ae_panelmenubuttonbridge,ae_placeholder,ae_richcombobridge,font";
                }

                jsonObject.put("extraPlugins", extraPlugins);
                
                JSONObject toolbarsJSONObject = jsonObject.getJSONObject("toolbars");

                if (toolbarsJSONObject == null) {
                 toolbarsJSONObject = JSONFactoryUtil.createJSONObject();
                }

                JSONObject stylesJSONObject = toolbarsJSONObject.getJSONObject(
                 "styles");

                if (stylesJSONObject == null) {
                 stylesJSONObject = JSONFactoryUtil.createJSONObject();
                }

                JSONArray selectionsJSONArray = stylesJSONObject.getJSONArray(
                 "selections");

                for (int i = 0; i < selectionsJSONArray.length(); i++) {
                 JSONObject selection = selectionsJSONArray.getJSONObject(i);

                        if (Objects.equals(selection.get("name"), "text")) {
                         JSONArray buttons = selection.getJSONArray("buttons");

                         buttons.put("Font");
                         buttons.put("FontSize");
                        }
 
                 }
         
                stylesJSONObject.put("selections", selectionsJSONArray);

                toolbarsJSONObject.put("styles", stylesJSONObject);

                jsonObject.put("toolbars", toolbarsJSONObject);
   }
 }
\end{verbatim}

Now you know how to use Liferay DXP's bundled CKEditor plugins in its
AlloyEditor!

\subsection{Related Topics}\label{related-topics-165}

\href{/docs/7-0/tutorials/-/knowledge_base/t/modifying-an-editors-configuration}{Modifying
an Editor's Configuration}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-and-contributing-new-buttons-to-alloyeditor}{Creating
and Contributing New Buttons to AlloyEditor}

\href{/docs/7-0/tutorials/-/knowledge_base/t/adding-new-behavior-to-an-editor}{Adding
New Behavior to an Editor}

\chapter{JavaScript Module Loaders}\label{javascript-module-loaders}

JavaScript modules encapsulate code into useful units that export their
functions. Structuring an application this way makes it easier to work
with in these ways:

\begin{itemize}
\tightlist
\item
  Other modules can explicitly require this piece of code.
\item
  Structuring an application this way makes it easier to see the broader
  scope.
\item
  Modular applications keep related functionality close together.
\item
  Modularized code makes it easier to find what you're looking for.
\end{itemize}

This section contains tutorials relating to the different JavaScript
Module Loaders included present on the Liferay platform.

\section{Configuring Modules for Liferay DXP's
Loaders}\label{configuring-modules-for-liferay-dxps-loaders}

To load your modules in Liferay DXP, you need to know when they are
needed, where they are located at build time, if you want to bundle them
together or load them independently, and you must assemble them at
runtime. Keeping track of all these tasks can be a hassle. Liferay DXP's
module Loaders (YUI Loader and AMD Loader) provide a streamlined process
that handles loading for you, which saves you time.

ES2015 \texttt{*.es.js} files are automatically transpiled to AMD
modules and configured, so no additional work is needed for the Loader
to recognize them. Other JavaScript modules, however, require more
information to use Liferay DXP's Loaders.

Manual configuration is required for the following use cases:

\begin{itemize}
\tightlist
\item
  Custom AUI and YUI modules
\item
  External libraries with named AMD modules
\item
  External libraries with global exports that you want to load
  asynchronously or from other modules
\item
  Initialization code
\end{itemize}

This tutorial covers these concepts:

\begin{itemize}
\tightlist
\item
  How to configure JavaScript modules to use Liferay DXP's Loaders
\item
  How to use your loaded JavaScript modules in a portlet or a JavaScript
\end{itemize}

See the
\href{/docs/7-0/tutorials/-/knowledge_base/t/preparing-your-javascript-files-for-es2015}{Preparing
your JavaScript Files for ES2015} tutorial to learn how to use ES2015 in
your JavaScript modules.

Get started by configuring your module next.

\subsection{Configuring your Module}\label{configuring-your-module}

To use the loaders you must first define your modules. This metadata,
known as the \emph{module definition}, provides details such as
dependencies, name and location, when they should be loaded, and more.

The module is defined using a configuration file. Liferay DXP uses
\texttt{config.js} as a naming convention, but you can use whatever name
you prefer.

You must specify your configuration file's location in your bundle's
\texttt{bnd.bnd} file, so Liferay DXP knows where to access it. You'll
learn how to do this next.

\subsubsection{Configuring your Bundle's BND
File}\label{configuring-your-bundles-bnd-file}

Follow these steps to configure your BND file:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open your bundle's \texttt{bnd.bnd} file and add the
  \texttt{Liferay-JS-Config} header to point to the configuration file
  that contains the module's definition.

  For example, the header below points to a \texttt{config.js} file in
  the module's bundle:

\begin{verbatim}
Liferay-JS-Config: /META-INF/resources/config.js
\end{verbatim}

  \begin{figure}
  \centering
  \includegraphics{./images/loading-custom-modules-configuration.png}
  \caption{Custom JavaScript modules must use the
  \texttt{Liferay-JS-Config} BND header to point to a configuration file
  with the module definition.}
  \end{figure}
\item
  Next, add a web context path to retrieve resources for your module:

\begin{verbatim}
Web-ContextPath: /my-bundle-name
\end{verbatim}
\end{enumerate}

Now that Liferay DXP knows how to find the file, you can write it next.

\subsubsection{Writing the Configuration
File}\label{writing-the-configuration-file}

Follow these steps to define your module:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a configuration file, for example \texttt{config.js}, in the
  location you specified above.

  For example:

\begin{verbatim}
src/main/resources/META-INF/resources
\end{verbatim}
\item
  Identify the loader your module requires.

  The type of module you are configuring determines the loader you must
  use in your configuration file.

  \textbf{YUI and AlloyUI modules:} Use the \texttt{YUI.applyConfig}
  mechanism to provide the module information. Note that AUI modules use
  the AUI mechanism built on top of the existing YUI mechanism:
  \texttt{AUI().applyConfig}. You can also use this mechanism to
  \href{/docs/7-0/tutorials/-/knowledge_base/t/overriding-liferays-default-yui-and-aui-modules}{override
  Liferay DXP's default YUI/AUI modules}.

  \textbf{AMD or global libraries}: Use the
  \texttt{Liferay.Loader.addModule} mechanism to provide the module
  information.

  \textbf{Initialization code:} requires no loader mechanism. Simply add
  your code to the module's configuration file.
\item
  Add the module's definition to the configuration file using the loader
  mechanism you identified in step 2.

  Below are some example configurations for each use case.

  \textbf{Custom AUI module \texttt{config.js} example}
  \href{https://github.com/liferay/liferay-portal/blob/7.0.x/modules/apps/foundation/map/map-common/src/main/resources/META-INF/resources/js/config.js}{\texttt{com.liferay.map.common}
  module}:

\begin{verbatim}
;(function() {
        AUI().applyConfig(
                {
                        groups: {
                                mapbase: {
                                        base: MODULE_PATH + '/js/',
                                        combine: Liferay.AUI.getCombine(),
                                        modules: {
                                                'liferay-map-common': {
                                                        path: 'map.js',
                                                        requires: [
                                                                'aui-base'
                                                        ]
                                                }
                                        },
                                        root: MODULE_PATH + '/js/'
                                }
                        }
                }
        );
})();
\end{verbatim}
\end{enumerate}

\noindent\hrulefill

\textbf{Note:} You can use the \texttt{MODULE\_PATH} variable to
reference your module's location in relative paths. This mechanism is
more robust and reliable than hard coded paths in the event of modified
system settings.

\noindent\hrulefill

The parameters used in the AUI module example are defined below:

\textbf{groups:} A list of group definitions. Each group can contain
definitions for \texttt{base}, \texttt{comboBase}, \texttt{Combine}, and
a list of \texttt{modules}.

\textbf{base:} The base directory to fetch the module from.

\textbf{combine:} Whether to use a combo service to reduce the number of
HTTP connections required to load your dependencies. Best practice is to
use \texttt{Liferay.AUI.getCombine()} as the value, as Liferay DXP's own
modules do. If \texttt{js\_fast\_load} in enabled in your theme,
\texttt{Liferay.AUI.getCombine()} returns \texttt{true}, otherwise it
returns \texttt{false}. Hard coding a value can result in odd or
unexpected behavior, and is not recommended.

\textbf{modules:} A list of module definitions.

\textbf{path:} The path to the script from \texttt{base}. This parameter
is required.

\textbf{requires:} An array of modules required by this component.

See the
\href{http://alloyui.com/api/classes/Loader.html\#method_addModule}{\texttt{Loader.addModule}
method} for a full list of the supported module metadata.

\textbf{root:} The root path to prepend to module names for the combo
service. Ex: \texttt{2.5.2/build}.

See the
\href{http://alloyui.com/api/classes/Loader.html}{\texttt{Loader} class}
for a full list of available methods and properties.

\textbf{Custom AMD module \texttt{config.js} example}
\href{https://github.com/liferay/liferay-portal/blob/7.0.x/modules/apps/foundation/frontend-js/frontend-js-polyfill-babel-web/bnd.bnd}{\texttt{com.liferay.frontend.js.polyfill.babel.web}
module}:

\begin{verbatim}
    Liferay.Loader.addModule(
            {
                    dependencies: [],
                    exports: '_babelPolyfill',
                    name: 'polyfill-babel',
                    path: MODULE_PATH + 'browser-polyfill.min.js'
            }
    );
\end{verbatim}

The parameters used in the custom AMD module example are defined below:

\textbf{dependencies:} An array of module dependencies.

\textbf{exports:} The value, as a \texttt{string}, that the module
exports to the global namespace. This is used for non-AMD modules. For
example if your module exposes the global attribute
\texttt{window.MyLibrary}, then you can set
\texttt{exports\ =\ \textquotesingle{}MyLibrary\textquotesingle{}} to
let the loader know when this module is done loading.

\textbf{name:} The name of the module.

\textbf{path:} Sets the path of the module. If omitted, the module
\texttt{name} value will be used as the path.

\textbf{fullpath:} Sets the full path to the module. This property
should be used instead of the \texttt{path} property when the module
isn't located in Portal. For example, you can use the \texttt{fullpath}
property to load a library from an external CDN:
\texttt{fullPath:\ \textquotesingle{}https://web/address/external-library.js\textquotesingle{}}.

\textbf{Library initialization code module \texttt{config.js} example}
\href{https://github.com/liferay/liferay-portal/blob/7.0.x/modules/apps/foundation/frontend-js/frontend-js-metal-web/src/main/resources/META-INF/resources/config.js}{\texttt{com.liferay.frontend.js.metal.web}
module}:

\begin{verbatim}
    window.__METAL_COMPATIBILITY__ = {
            renderers: ['soy']
    };
\end{verbatim}

Although the example above contains library configuration code, you
could add any initialization code that you require.

Liferay DXP automatically collects all the module definitions in a
single request at startup, so you don't need to be concerned about the
timing and placement of their configuration.

Now that your module is configured, you can learn how to use it in
Liferay DXP next.

\subsection{Using your Module}\label{using-your-module}

Once your module is configured, you have a few ways in which you can use
it in Liferay DXP.

This example is configured to use a module in the JSP of a portlet, via
the \texttt{aui:script}'s \texttt{require} attribute:

\begin{verbatim}
<aui:script require="relative/path/to/module/module-name">
  // variable `relativePathToModuleModuleName` is available here
</aui:script>
\end{verbatim}

To adhere to JavaScript standards, references to the module within the
script tag are named after the require value, in camel-case and with all
invalid characters removed. For more information on using your module in
a portlet, see the
\href{/docs/7-0/tutorials/-/knowledge_base/t/using-es2015-modules-in-your-portlet}{Using
ES2015 Modules in your Portlet} tutorial.

You can also use the module in a generic JavaScript:

\begin{verbatim}
<script>
Liferay.Loader.require('module-name', function (moduleName) {
  // variable `moduleName` is available here
});
</script>
\end{verbatim}

\noindent\hrulefill

\textbf{Note:} Using \texttt{Liferay.Loader.require} rather than just
\texttt{require} is safer if you plan to hide the Loader by disabling
the \texttt{exposeGlobal} option.

In Liferay DXP 7.1, \texttt{exposeGlobal} will be disabled by default.

\noindent\hrulefill

Now you know how to load your custom JavaScript modules and global
libraries in Liferay DXP!

\subsection{Related Topics}\label{related-topics-166}

\href{/docs/7-0/tutorials/-/knowledge_base/t/preparing-your-javascript-files-for-es2015}{Preparing
your JavaScript Files for ES2015}

\href{/docs/7-0/tutorials/-/knowledge_base/t/using-es2015-modules-in-your-portlet}{Using
ES2015 Modules in your Portlet}

\href{/docs/7-0/tutorials/-/knowledge_base/t/overriding-liferays-default-yui-and-aui-modules}{Overriding
Liferay DXP's Default YUI and AUI Modules}

\section{Using External Libraries}\label{using-external-libraries}

You can use external (i.e., anything but Metal.js, jQuery, or Lodash,
which are included in Liferay DXP) JavaScript libraries in your
portlets. There are a few methods you can use to make external libraries
available. The method you should choose depends on the external
libraries you plan to use and how you plan to use them (as modules or as
browser globals).

This tutorial covers how to adapt external libraries for Liferay's
JavaScript Loaders.

Go ahead and get started.

\subsection{Configuring Libraries to Support
UMD}\label{configuring-libraries-to-support-umd}

If you're the owner of the library, you should make sure that it
supports \href{https://github.com/umdjs/umd}{UMD} (Universal Module
Definition). You can configure your code to support UMD with the
template shown below:

\begin{verbatim}
// Assuming your "module" will be exported as "mylibrary"
(function (root, factory) {
    if (typeof Liferay.Loader.define === 'function' && Liferay.Loader.define.amd) {
        // AMD. Register as a "named" module.
        Liferay.Loader.define('mylibrary', [], factory);
    } else if (typeof module === 'object' && module.exports) {
        // Node. Does not work with strict CommonJS, but
        // only CommonJS-like environments that support module.exports,
        // like Node.
        module.exports = factory();
    } else {
        // Browser globals (root is window)
        root.mylibrary = factory();
  }
}(this, function () {

    // Your library code goes here
    return {};
}));
\end{verbatim}

Next you can learn how to load external libraries as browser globals.

\subsection{Loading Libraries as Browser
Globals}\label{loading-libraries-as-browser-globals}

If you want to use a library that doesn't export itself as a named
module (as is the case for many plugins) or load the library as a
browser global, follow the steps in this section.

\noindent\hrulefill

\textbf{Note:} These steps only apply to users on Liferay Portal CE 7.0
GA4, Liferay Digital Enterprise 7.0 SP2 (Fix Pack 8), or lower patch
levels. If you're on a higher patch level, follow the steps in the
\href{/docs/7-0/tutorials/-/knowledge_base/t/using-external-libraries\#using-libraries-that-you-host}{Using
Libraries that You Host} section.

\noindent\hrulefill

Follow these steps to load your libraries as browser globals:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add a \texttt{\textless{}script\textgreater{}} tag with the following
  content before loading your module:

\begin{verbatim}
<script>
    Liferay.Loader.define._amd = Liferay.Loader.define.amd;
    Liferay.Loader.define.amd = false;
</script>
\end{verbatim}
\item
  Next, add a \texttt{\textless{}script\textgreater{}} tag to load the
  module itself. Below is an example configuration:

\begin{verbatim}
<script type="text/javascript" src="${javascript_folder}/library.js">
</script>
\end{verbatim}
\item
  Finally, cancel the change made in the previous step, by adding the
  following \texttt{\textless{}script\textgreater{}} tag:

\begin{verbatim}
<script>
    Liferay.Loader.define.amd = Liferay.Loader.define._amd;
</script>
\end{verbatim}
\end{enumerate}

This approach lets you load your modules as browser globals. Next, you
can learn how to load libraries that you host.

\subsection{Using Libraries That You
Host}\label{using-libraries-that-you-host}

If you're hosting the library (and not loading it from a CDN), you must
hide the Liferay AMD Loader to use your Library.

If you're running Liferay Portal CE 7.0 GA4, Liferay Digital Enterprise
7.0 SP2 (Fix Pack 8), or a higher patch level, you can hide the Liferay
AMD Loader through the control panel. Follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open the Control Panel, navigate to \emph{Configuration} →
  \emph{System Settings}.
\item
  Click \emph{JavaScript Loader} under the \emph{Foundation} tab.
\item
  Uncheck the \texttt{expose\ global} option.
\end{enumerate}

\noindent\hrulefill

\textbf{Note:} Once this option is unchecked, you can no longer use the
\texttt{Liferay.Loader.define} or \texttt{Liferay.Loader.require}
functions in your app. Also, if you're using third party libraries that
are AMD compatible, they could stop working after unchecking this option
because they usually use global functions like \texttt{require()} or
\texttt{define()}.

\noindent\hrulefill

If you're running a lower patch level than Liferay Portal CE 7.0 GA4 or
Liferay Digital Enterprise 7.0 SP2 (Fix Pack 8), follow these steps to
hide the Liferay AMD Loader:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Name the library in the define function, as covered in the
  \href{/docs/7-0/tutorials/-/knowledge_base/t/using-external-libraries\#configuring-libraries-to-support-umd}{Configuring
  Libraries to Support UMD} section. Below is an example configuration:

\begin{verbatim}
Liferay.Loader.define('mylibrary', [], factory);
\end{verbatim}
\item
  Remove the UMD wrapper
  \texttt{if\ (typeof\ Liferay.Loader.define\ ===\ \textquotesingle{}function\textquotesingle{}\ \&\&\ Liferay.Loader.define.amd)}
  or update the UMD wrapper to match the one below:

\begin{verbatim}
if (false && typeof Liferay.Loader.define === 'function' && Liferay.Loader.define.amd)
\end{verbatim}
\item
  Configure your bundle's build task to run the \texttt{configJSModules}
  task over the library.

  This task names the library and generates the appropriate loader
  configuration for you.
\end{enumerate}

Now you know how to adapt external libraries for Liferay's JavaScript
Loaders.

\subsection{Related Topics}\label{related-topics-167}

\href{/docs/7-0/tutorials/-/knowledge_base/t/configuring-modules-for-products-loaders}{Configuring
Modules for Liferay Portal's Loaders}

\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-amd-module-loader}{Liferay
AMD Module Loader}

\href{/docs/7-0/tutorials/-/knowledge_base/t/using-es2015-modules-in-your-portlet}{Using
ES2015 Modules in Your Portlet}

\section{Liferay AMD Module Loader}\label{liferay-amd-module-loader}

The
\href{https://github.com/liferay/liferay-amd-loader\#amd-module-loader}{Liferay
AMD Module Loader} is a JavaScript module loader.

\subsection{What is a JavaScript
module?}\label{what-is-a-javascript-module}

A JavaScript module encapsulates a piece of code into a useful unit that
exports its capability/value. This makes it easy for other modules to
explicitly require this piece of code. Structuring an application this
way makes it easier to see the broader scope, easier to find what you're
looking for, and keeps related pieces close together. This way of coding
is a specification for the JavaScript language called Asynchronous
Module Definition, or AMD.

\subsection{Purpose of Liferay AMD Module
Loader}\label{purpose-of-liferay-amd-module-loader}

A normal web page usually loads JavaScript files via HTML
\texttt{script} tags. That's fine for small websites, but when
developing large scale web applications, a more robust organization and
loader is needed. A module loader allows an application to load
dependencies easily by specifying a string that identifies the module
name.

Now that you know the purpose of the Liferay AMD Module Loader, you can
learn how to define modules next.

\subsection{Defining a Module}\label{defining-a-module}

The Liferay AMD Module loader works with JavaScript modules that are in
the AMD format. Here is a basic example of the definition of an AMD
module:

\begin{verbatim}
Liferay.Loader.define('my-dialog', ['my-node', 'my-plugin-base'], function(myNode, myPluginBase) {
    return {
        log: function(text) {
            console.log('module my-dialog: ' + text);
        }
    };
});
\end{verbatim}

You can specify to load the module when another module is triggered or
when a given condition is met:

\begin{verbatim}
Liferay.Loader.define('my-dialog', ['my-node', 'my-plugin-base'], function(myNode, myPluginBase) {
    return {
        log: function(text) {
            console.log('module my-dialog: ' + text);
        }
    };
}, {
    condition: {
        trigger: 'my-test',
        test: function() {
            var el = document.createElement('input');

            return ('placeholder' in el);
        }
    },
    path: 'my-dialog.js'
});
\end{verbatim}

The configuration above specifies that this module should be loaded
automatically, if the developer requests the \texttt{my-test} module
under the given condition.

Next you can learn how to load a module.

\subsection{Loading a Module}\label{loading-a-module}

Loading a module is as easy as passing the module name to the
\texttt{Liferay.Loader.require} method. The example below loads a module
called \texttt{my-dialog}:

\begin{verbatim}
Liferay.Loader.require('my-dialog', function(myDialog) {
    // your code here
}, function(error) {
    console.error(error);
});
\end{verbatim}

Next you can learn how to map module names.

\subsection{Mapping Module Names}\label{mapping-module-names}

You can map module names to specific versions or other naming
conventions. The example below maps the \texttt{liferay} and
\texttt{liferay2} modules to \texttt{liferay@1.0.0}:

\begin{verbatim}
__CONFIG__.maps = {
    'liferay': 'liferay@1.0.0',
    'liferay2': 'liferay@1.0.0'
};
\end{verbatim}

Mapping a module changes its name to the value specified in the map.
Take this require value for example:

\begin{verbatim}
Liferay.Loader.require('liferay/html/js/autocomplete'...)
\end{verbatim}

Under the hood, this is the same as the value shown below:

\begin{verbatim}
Liferay.Loader.require('liferay@1.0.0/html/js/autocomplete'...)
\end{verbatim}

\subsection{Using Liferay AMD Module Loader in Liferay
DXP}\label{using-liferay-amd-module-loader-in-liferay-dxp}

Tools, like the
\href{https://github.com/liferay/liferay-module-config-generator}{Liferay
AMD Module Config Generator}, have been integrated into Liferay DXP to
make it easy for developers to create and load modules. Here's how it
works:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  The Module Config Generator scans your code and looks for AMD module
  \texttt{Liferay.Loader.define(...)} statements.
\item
  It then names the module if it is not named already.
\item
  It uses that information, along with the listed dependencies, as well
  as any other configurations specified, to create a
  \texttt{config.json} file. Below is an example of a generated
  \texttt{config.json} file:

\begin{verbatim}
 {
     "frontend-js-web@1.0.0/html/js/parser": {
         "dependencies": []
     },
     "frontend-js-web@1.0.0/html/js/list-display": {
         "dependencies": ["exports"]
     },
     "frontend-js-web@1.0.0/html/js/autocomplete": {
         "dependencies": ["exports", "./parser", "./list-display"]
     }
 }
\end{verbatim}
\end{enumerate}

This configuration object tells the loader which modules are available,
where they are, and what dependencies they require.

Now you know all about the Liferay AMD Module Loader!

\subsection{Related Topics}\label{related-topics-168}

\href{/docs/7-0/tutorials/-/knowledge_base/t/configuring-modules-for-products-loaders}{Configuring
Modules for Liferay Portal's Loaders}

\section{Loading Modules with AUI Script in Liferay
DXP}\label{loading-modules-with-aui-script-in-liferay-dxp}

The \texttt{aui:script} tag is a JSP tag that loads JavaScript in script
tags on the page, while ensuring that certain resources are loaded
before executing.

\subsection{Using aui:script}\label{using-auiscript}

The \texttt{aui:script} tag supports the following options:

\begin{itemize}
\tightlist
\item
  \texttt{require}: Requires an AMD module that will be loaded with the
  \href{https://github.com/liferay/liferay-amd-loader\#amd-module-loader}{Liferay
  AMD Module Loader}.
\item
  \texttt{use}: Uses an AlloyUI/YUI module that is loaded via the YUI
  loader.
\item
  \texttt{position}: The position the script tag is put on the page.
  Possible options are \texttt{inline} or \texttt{auto}.
\item
  \texttt{sandbox}: Whether to wrap the script tag in an anonymous
  function. If set to \texttt{true}, in addition to the wrapping,
  \texttt{\$} and \texttt{\_} are defined for jQuery and underscore.
\end{itemize}

Next you can learn how to load ES2015 and Metal.js modules.

\subsection{Loading ES2015 and Metal.js
Modules}\label{loading-es2015-and-metal.js-modules}

You can use \texttt{aui:script} to load your ES2015 and Metal.js modules
like this:

\begin{verbatim}
<aui:script require="metal-clipboard/src/Clipboard">
    new metalClipboardSrcClipboard.default();
</aui:script>
\end{verbatim}

This resolves the dependencies of the registered \texttt{Clipboard.js}
and loads them in order until all of them are satisfied and the
requested module can be safely executed.

In the browser, the \texttt{aui:script} translates to the full HTML
shown below:

\begin{verbatim}
<script type="text/javascript">
    Liferay.Loader.require("metal-clipboard/src/Clipboard", function(metalClipboardSrcClipboard) {
        (function() {
            new metalClipboardSrcClipboard.default();
        })()
    }, function(error) {
        console.error(error)
    });
</script>
\end{verbatim}

Next you can learn how to load AlloyUI modules.

\subsection{Loading AlloyUI Modules}\label{loading-alloyui-modules}

You can use the \texttt{use} attribute to load AlloyUI/YUI modules:

\begin{verbatim}
<aui:script use="aui-base">
    A.one('#someNodeId').on(
        'click',
        function(event) {
            alert('Thank you for clicking.')
        }
    );
</aui:script>
\end{verbatim}

This loads the \texttt{aui-base} AlloyUI component and makes it
available to the code inside the \texttt{aui:script}.

In the browser, the \texttt{aui:script} translates to the full HTML
shown below:

\begin{verbatim}
<script type="text/javascript">
    AUI().use("aui-base",
        function(A){
            A.one('#someNodeId').on(
                'click',
                function(event) {
                    alert('Thank you for clicking.')
                }
            );
        }
    );
</script>
\end{verbatim}

Next you can learn how to load AlloyUI modules together with ES2015 and
Metal.js modules.

\subsection{Loading AlloyUI Modules and ES2015 and Metal.js Modules
Together}\label{loading-alloyui-modules-and-es2015-and-metal.js-modules-together}

You may want to load an AUI module along with an ES2015 module or
Metal.js module in an \texttt{aui:script}. The \texttt{aui:script} tag
doesn't support both the \texttt{require} and \texttt{use} attributes in
the same configuration. Not to worry though. You can use the
\texttt{aui:script}'s \texttt{require} attribute to load the ES2015 and
Metal.js modules, while loading the AUI module(s) with the
\texttt{AUI().use()} function within the script. Below is an example
configuration:

\begin{verbatim}
<aui:script require="path-to/metal/module">
 AUI().use(
    'liferay-aui-module', 
    function(A) {
        let var = pathToMetalModule.default;
    }
);
</aui:script>
\end{verbatim}

Now you know how to load modules with the \texttt{aui:script} tag!

\subsection{Related Topics}\label{related-topics-169}

\href{/docs/7-0/tutorials/-/knowledge_base/t/configuring-modules-for-products-loaders}{Configuring
Modules for Liferay Portal Loaders}

\chapter{Liferay JavaScript APIs}\label{liferay-javascript-apis}

The \texttt{Liferay} JavaScript object is populated with some helpful
tools. This section contains a comprehensive list of some of the most
useful utilities you can find inside the \texttt{Liferay} object.

\section{Liferay ThemeDisplay}\label{liferay-themedisplay}

In Java, developers are used to being able to find lots of context
information at runtime. You can learn about what user is browsing your
application, what page it's on, what site it's in, and lots more.
Wouldn't it be great if you could access that same information in
JavaScript? You can! You can use Liferay DXP's \texttt{ThemeDisplay}
JavaScript object!

It's a part of the \texttt{Liferay} global object that's automatically
available to you in Liferay DXP at runtime. You can refer to the object
as \texttt{Liferay.ThemeDisplay}. The \texttt{ThemeDisplay} object
provides information on many aspects of a portal. It can identify the
portal instance, the current user, the user's language, and the user's
navigational context. It can tell you the paths to a portlet's scripts
and images, a theme's images and files, and a portal's main folder. And
it lets you know if a user is signed in and if the user is being
impersonated. You can quickly assess your portal surroundings with
\texttt{ThemeDisplay}.

This tutorial describes some of the most commonly used
\texttt{ThemeDisplay} methods for getting IDs, paths, and user sign-in
details.

\subsection{Retrieving IDs}\label{retrieving-ids}

Using the \texttt{ThemeDisplay} methods below, you can grab IDs of
various portal elements:

\textbf{getCompanyId:} Returns the
\href{/participate/liferaypedia/-/wiki/Main/Company+ID}{company ID}.

\textbf{getLanguageId:} Returns the user's language ID.

\textbf{getScopeGroupId:} Returns the
\href{/participate/liferaypedia/-/wiki/Main/Group+ID}{group ID} of the
current site.

\textbf{getUserId:} Returns the
\href{/participate/liferaypedia/-/wiki/Main/User+ID}{user's ID}.

\textbf{getUserName:} Returns the user's name.

Now that you know how to retrieve IDs of some of Liferay's key elements,
you can learn how to get paths to various deployed entities in the
portal.

\subsection{Retrieving File Paths}\label{retrieving-file-paths}

The \texttt{ThemeDisplay} object has methods for retrieving commonly
used file paths. Below are a few of the methods:

\textbf{getPathImage:} Returns the relative path of the portlet's image
directory.

\textbf{getPathJavaScript:} Returns the relative path of the directory
containing the portlet's JavaScript source files.

\textbf{getPathMain:} Returns the path of the portal instance's main
directory.

\textbf{getPathThemeImages:} Returns the path of the current theme's
image directory.

\textbf{getPathThemeRoot:} Returns the relative path of the current
theme's root directory.

Now that you know how to retrieve paths to Liferay's deployed entities,
you can next learn how to get information about the current user.

\subsection{Retrieving Login
Information}\label{retrieving-login-information}

Here are a couple methods related to the current user.

\textbf{isImpersonated:} Returns \texttt{true} if the current user is
being impersonated. Authorized administrative users can
\href{/docs/6-2/user/-/knowledge_base/u/the-users-section-of-the-control-panel\#user-management}{impersonate}
act as another user to test that user's account.

\textbf{isSignedIn:} Returns \texttt{true} if the user is logged in to
the portal.

Below is JavaScript code that demonstrates using \texttt{ThemeDisplay}'s
\texttt{isSignedIn} method:

\begin{verbatim}
if(Liferay.ThemeDisplay.isSignedIn()){
    alert('Hello ' + Liferay.ThemeDisplay.getUserName() + '. Welcome Back.')
}
else {
    alert('Hello Guest.')
}
\end{verbatim}

The example above alerts a signed in user with a personalized greeting.
Otherwise, it defaults to a guest greeting. Although this is a basic
example, it shows how you can easily define unique user experiences with
the \texttt{ThemeDisplay} object.

\subsection{Liferay ThemeDisplay API}\label{liferay-themedisplay-api}

For completeness, you can find every available method inside the
\texttt{Liferay.ThemeDisplay} object in the table below:

\noindent\hrulefill

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.3333}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Method
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Type
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Description
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
getLayoutId & number & \\
getLayoutRelativeURL & string & \\
getLayoutURL & string & \\
getParentLayoutId & number & \\
isControlPanel & boolean & \\
isPrivateLayout & boolean & \\
isVirtualLayout & boolean & \\
getBCP47LanguageId & number & \\
getCDNBaseURL & string & \\
getCDNDynamicResourcesHost & string & \\
getCDNHost & string & \\
getCompanyGroupId & number & \\
getCompanyId & number & Returns the
\href{/participate/liferaypedia/-/wiki/Main/Company+ID}{company ID} \\
getDefaultLanguageId & number & \\
getDoAsUserIdEncoded & string & \\
getLanguageId & number & Returns the user's language ID \\
getParentGroupId & number & \\
getPathContext & string & \\
getPathImage & string & Returns the relative path of the portlet's image
directory \\
getPathJavaScript & string & Returns the relative path of the directory
containing the \\
\end{longtable}

\noindent\hrulefill portlet's JavaScript source files \textbar{}

\noindent\hrulefill

getPathMain \textbar{} string \textbar{} Returns the path of the portal
instance's main directory \textbar{} getPathThemeImages \textbar{}
string \textbar{} Returns the path of the current theme's image
directory \textbar{} getPathThemeRoot \textbar{} string \textbar{}
Returns the relative path of the current theme's root

\noindent\hrulefill directory \textbar{}

\noindent\hrulefill

getPlid \textbar{} string \textbar{} \textbar{} getPortalURL \textbar{}
string \textbar{} \textbar{} getScopeGroupId \textbar{} number
\textbar{} Returns the
\href{/participate/liferaypedia/-/wiki/Main/Group+ID}{group ID} of the
current site \textbar{} getSiteGroupIdOrLiveGroupId \textbar{} number
\textbar{} Returns the
\href{/participate/liferaypedia/-/wiki/Main/Group+ID}{group ID} of the
live site. This is relevant for staging. \textbar{} getSessionId
\textbar{} number \textbar{} \textbar{} getSiteGroupId \textbar{} number
\textbar{} \textbar{} getURLControlPanel \textbar{} string \textbar{}
\textbar{} getURLHome \textbar{} string \textbar{} \textbar{} getUserId
\textbar{} number \textbar{} Returns the
\href{/participate/liferaypedia/-/wiki/Main/User+ID}{user's ID}
\textbar{} getUserName \textbar{} string \textbar{} Returns the user's
name \textbar{} isAddSessionIdToURL \textbar{} boolean \textbar{}
\textbar{} isFreeformLayout \textbar{} boolean \textbar{} \textbar{}
isImpersonated \textbar{} boolean \textbar{} Returns \texttt{true} if
the current user is being impersonated. Authorized administrative users
can
\href{/docs/6-2/user/-/knowledge_base/u/the-users-section-of-the-control-panel\#user-management}{impersonate}
act as another user to test that user's account \textbar{} isSignedIn
\textbar{} boolean \textbar{} Returns \texttt{true} if the user is
logged in to the portal \textbar{} isStateExclusive \textbar{} boolean
\textbar{} \textbar{} isStateMaximized \textbar{} boolean \textbar{}
\textbar{} isStatePopUp \textbar{} boolean \textbar{} \textbar{}

\noindent\hrulefill

\subsection{Related Topics}\label{related-topics-170}

\href{/docs/7-0/tutorials/-/knowledge_base/t/javascript-utilities}{Liferay
DXP JavaScript Utilities}

\section{Working with URLs in
JavaScript}\label{working-with-urls-in-javascript}

In Java, developers are able to create and work with URLs using their
APIs. The \texttt{Liferay} global object offers some features to help
you create and work with URLs.

This tutorial covers some of the most commonly used methods inside the
\texttt{Liferay} global JavaScript object to manipulate URLs.

\subsection{Liferay PortletURL}\label{liferay-portleturl}

The \texttt{Liferay.PortletURL} class provides a way to create Liferay
PortletURL's such as the \texttt{actionURL}, \texttt{renderURL}, and
\texttt{resourceURL} through JavaScript. Below is an example
configuration:

\begin{verbatim}
var portletURL = Liferay.PortletURL.createURL(themeDisplay.getURLControlPanel());

portletURL.setDoAsGroupId('true');
portletURL.setLifecycle(Liferay.PortletURL.ACTION_PHASE);
portletURL.setParameter('cmd', 'add_temp');
portletURL.setParameter('javax.portlet.action', '/document_library/upload_file_entry');
portletURL.setParameter('p_auth', Liferay.authToken);
portletURL.setPortletId(Liferay.PortletKeys.DOCUMENT_LIBRARY);
\end{verbatim}

\subsection{Liferay AuthToken}\label{liferay-authtoken}

Below is an example configuration for the \texttt{Liferay.authToken}:

\begin{verbatim}
Liferay.authToken = '<%= AuthTokenUtil.getToken(request) %>';
\end{verbatim}

\subsection{Liferay CurrentURL}\label{liferay-currenturl}

The \texttt{Liferay.currentURL} variable holds the path of the current
URL from the server root.

For example, if checked from \texttt{my.domain.com/es/web/guest/home},
the value is \texttt{/es/web/guest/home}, as shown below:

\begin{verbatim}
// Inside my.domain.com/es/web/guest/home
console.log(Liferay.currentURL); // "/es/web/guest/home"
\end{verbatim}

\subsection{Liferay CurrentURLEncoded}\label{liferay-currenturlencoded}

The \texttt{Liferay.currentURLEncoded} variable holds the path of the
current URL from the server root encoded in ASCII for safe transmission
over the Internet.

For example, if checked from \texttt{my.domain.com/es/web/guest/home},
the value is \texttt{\%2Fes\%2Fweb\%2Fguest\%2Fhome}, as shown below:

\begin{verbatim}
// Inside my.domain.com/es/web/guest/home
console.log(Liferay.currentURLEncoded); // "%2Fes%2Fweb%2Fguest%2Fhome"
\end{verbatim}

Now you know how to manipulate URLs using methods within the
\texttt{Liferay} global JavaScript object.

\subsection{Related Topics}\label{related-topics-171}

\href{/docs/7-0/tutorials/-/knowledge_base/t/javascript-utilities}{Liferay
DXP JavaScript Utilities}

\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-themedisplay}{Liferay
Theme Display}

\section{Liferay DXP JavaScript
Utilities}\label{liferay-dxp-javascript-utilities}

This tutorial explains some of the utility methods and objects inside
the \texttt{Liferay} global JavaScript object.

\subsection{Liferay Browser}\label{liferay-browser}

The \texttt{Liferay.Browser} object contains methods that expose the
current user agent characteristics without the need of accessing and
parsing the global \texttt{window.navigator} object.

The available methods for the \texttt{Liferay.Browser} object are listed
in the table below:

\noindent\hrulefill

\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Method & Type & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
acceptsGzip & boolean & \\
getMajorVersion & number & \\
getRevision & number & \\
getVersion & number & \\
isAir & boolean & \\
isChrome & boolean & \\
isFirefox & boolean & \\
isGecko & boolean & \\
isIe & boolean & \\
isIphone & boolean & \\
isLinux & boolean & \\
isMac & boolean & \\
isMobile & boolean & \\
isMozilla & boolean & \\
isOpera & boolean & \\
isRtf & boolean & \\
isSafari & boolean & \\
isSun & boolean & \\
isWebKit & boolean & \\
isWindows & boolean & \\
\end{longtable}

\noindent\hrulefill

\subsection{Related Topics}\label{related-topics-172}

\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-themedisplay}{Liferay
Theme Display}

\section{Invoking Liferay Services}\label{invoking-liferay-services}

Liferay DXP provides many web services out-of-the-box to you. These
services include retrieving data and information about various assets,
creating new assets, and even editing existing assets.

To see a comprehensive list of the available web services, start up a
bundle and navigate to \texttt{http://localhost:8080/api/jsonws}. This
list includes any custom web services that have been deployed to the
bundle. These services are useful for creating single page applications,
and can even be used to create custom front-ends, both inside and
outside of Liferay DXP.

This tutorial explains how to invoke these web services using
JavaScript.

Go ahead and get started.

\subsection{Invoking Web Services via
JavaScript}\label{invoking-web-services-via-javascript}

7.0 contains a global JavaScript object called \texttt{Liferay} that has
many useful utilities. One method is \texttt{Liferay.Service}, which is
used for invoking JSON web services.

The \texttt{Liferay.Service} method takes four possible arguments:

\textbf{service \{string\textbar object\}:} Either the service name, or
an object with the keys as the service to call, and the value as the
service configuration object. (Required)

\textbf{data \{object\textbar node\textbar string\}:} The data to send
to the service. If the object passed is the ID of a form or a form
element, the form fields will be serialized and used as the data.

\textbf{successCallback \{function\}:} A function to execute when the
server returns a response. It receives a JSON object as it's first
parameter.

\textbf{exceptionCallback \{function\}:} A function to execute when the
response from the server contains a service exception. It receives an
exception message as it's first parameter.

One of the major benefits of using the \texttt{Liferay.Service} method
versus using a standard AJAX request is that it handles the
authentication for you.

Below is an example configuration of the \texttt{Liferay.Service}
method:

\begin{verbatim}
Liferay.Service(
        '/user/get-user-by-email-address',
        {
                companyId: Liferay.ThemeDisplay.getCompanyId(),
                emailAddress: 'test@example.com'
        },
        function(obj) {
                console.log(obj);
        }
);
\end{verbatim}

The example above retrieves information about a user by passing in the
\texttt{companyId} and \texttt{emailAddress} of the user in question.
The response data resembles the following JSON object:

\begin{verbatim}
{
        "agreedToTermsOfUse": true,
        "comments": "",
        "companyId": "20116",
        "contactId": "20157",
        "createDate": 1471990639779,
        "defaultUser": false,
        "emailAddress": "test@example.com",
        "emailAddressVerified": true,
        "facebookId": "0",
        "failedLoginAttempts": 0,
        "firstName": "Test",
        "googleUserId": "",
        "graceLoginCount": 0,
        "greeting": "Welcome Test Test!",
        "jobTitle": "",
        "languageId": "en_US",
        "lastFailedLoginDate": null,
        "lastLoginDate": 1471996720765,
        "lastLoginIP": "127.0.0.1",
        "lastName": "Test",
        "ldapServerId": "-1",
        "lockout": false,
        "lockoutDate": null,
        "loginDate": 1472077523149,
        "loginIP": "127.0.0.1",
        "middleName": "",
        "modifiedDate": 1472077523149,
        "mvccVersion": "7",
        "openId": "",
        "portraitId": "0",
        "reminderQueryAnswer": "test",
        "reminderQueryQuestion": "what-is-your-father's-middle-name",
        "screenName": "test",
        "status": 0,
        "timeZoneId": "UTC",
        "userId": "20156",
        "uuid": "c641a7c9-5acb-aa68-b3ea-5575e1845d2f"
}
\end{verbatim}

Now that you know how to send an individual request, you're ready to run
batch requests.

\subsection{Batching Requests}\label{batching-requests}

Another format for invoking the \texttt{Liferay.Service} method is by
passing an object with the keys as the service to call and the value as
the service configuration object.

Below is an example configuration for a batch request:

\begin{verbatim}
Liferay.Service(
        {
                '/user/get-user-by-email-address': {
                        companyId: Liferay.ThemeDisplay.getCompanyId(),
                        emailAddress: 'test@example.com'
                }
        },
        function(obj) {
                console.log(obj);
        }
);
\end{verbatim}

You can use this format to invoke multiple services with the same
request by passing in an array of service objects. Here's an example:

\begin{verbatim}
Liferay.Service(
        [
                {
                        '/user/get-user-by-email-address': {
                                companyId: Liferay.ThemeDisplay.getCompanyId(),
                                emailAddress: 'test@example.com'
                        }
                },
                {
                        '/role/get-user-roles': {
                                userId: Liferay.ThemeDisplay.getUserId()
                        }
                }
        ],
        function(obj) {
                // obj is now an array of response objects
                // obj[0] == /user/get-user-by-email-address data
                // obj[1] == /role/get-user-roles data

                console.log(obj);
        }
);
\end{verbatim}

Next you can learn how to nest your requests.

\subsection{Nesting Requests}\label{nesting-requests}

Nested service calls allow you to bind information from related objects
together in a JSON object. You can call other services in the same HTTP
request and conveniently nest returned objects.

You can use variables to reference objects returned from service calls.
Variable names must start with a dollar sign (\texttt{\$}).

The example in this section retrieves user data with
\texttt{/user/get-user-by-id}, and uses the \texttt{contactId} returned
from that service to then invoke \texttt{/contact/get-contact} in the
same request.

\noindent\hrulefill

\textbf{Note:} You must flag parameters that take values from existing
variables. To flag a parameter, insert the \texttt{@} prefix before the
parameter name.

\noindent\hrulefill

Below is an example configuration that demonstrates the concepts covered
in this section:

\begin{verbatim}
Liferay.Service(
        {
                "$user = /user/get-user-by-id": {
                        "userId": Liferay.ThemeDisplay.getUserId(),
                        "$contact = /contact/get-contact": {
                                "@contactId": "$user.contactId"
                        }
                }
        },
        function(obj) {
                console.log(obj);
        }
);
\end{verbatim}

Here is what the response data would look like for the request above:

\begin{verbatim}
{
        "agreedToTermsOfUse": true,
        "comments": "",
        "companyId": "20116",
        "contactId": "20157",
        "createDate": 1471990639779,
        "defaultUser": false,
        "emailAddress": "test@example.com",
        "emailAddressVerified": true,
        "facebookId": "0",
        "failedLoginAttempts": 0,
        "firstName": "Test",
        "googleUserId": "",
        "graceLoginCount": 0,
        "greeting": "Welcome Test Test!",
        "jobTitle": "",
        "languageId": "en_US",
        "lastFailedLoginDate": null,
        "lastLoginDate": 1472231639378,
        "lastLoginIP": "127.0.0.1",
        [...]
        "screenName": "test",
        "status": 0,
        "timeZoneId": "UTC",
        "userId": "20156",
        "uuid": "c641a7c9-5acb-aa68-b3ea-5575e1845d2f",
        "contact": {
                "accountId": "20118",
                "birthday": 0,
                [...]
                "createDate": 1471990639779,
                "emailAddress": "test@example.com",
                "employeeNumber": "",
                "employeeStatusId": "",
                "facebookSn": "",
                "firstName": "Test",
                "lastName": "Test",
                "male": true,
                "middleName": "",
                "modifiedDate": 1471990639779,
                [...]
                "userName": ""
        }
}
\end{verbatim}

Now that you know how to process requests, you can learn how to filter
the results next.

\subsection{Filtering Results}\label{filtering-results-1}

If you don't want all the properties returned by a service, you can
define a whitelist of properties. This returns only the specific
properties you request in the object.

Below is an example of whitelisting properties:

\begin{verbatim}
Liferay.Service(
        {
                '$user[emailAddress,firstName] = /user/get-user-by-id': {
                        userId: Liferay.ThemeDisplay.getUserId()
                }
        },
        function(obj) {
                console.log(obj);
        }
);
\end{verbatim}

To specify whitelist properties, place the properties in square brackets
(e.g., \texttt{{[}whiteList{]}}) immediately following the name of your
variable. The example above requests only the \texttt{emailAddress} and
\texttt{firstName} of the user.

Below is the filtered response:

\begin{verbatim}
{
        "firstName": "Test",
        "emailAddress": "test@example.com"
}
\end{verbatim}

Next you can learn how to populate the inner parameters of the request.

\subsection{Inner Parameters}\label{inner-parameters-1}

When you pass in an object parameter, you'll often need to populate its
inner parameters (i.e., fields).

Consider a default parameter \texttt{serviceContext} of type
\texttt{ServiceContext}. To make an appropriate call to JSON web
services you might need to set \texttt{serviceContext} fields such
as\texttt{scopeGroupId}, as shown below:

\begin{verbatim}
Liferay.Service(
        '/example/some-web-service',
        {
                serviceContext: {
                        scopeGroupId: 123
                }
        },
        function(obj) {
                console.log(obj);
        }
);
\end{verbatim}

Now you know how to invoke Liferay services!

\subsection{Related Topics}\label{related-topics-173}

\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-javascript-apis}{Liferay
JavaScript APIs}

\chapter{Front-End Taglibs}\label{front-end-taglibs}

Liferay DXP offers a powerful set of taglibs that are fully maintained
and integrated. They provide common implementations for UI components
and utilities to ensure that your apps, themes, and web content behave
in a very clean and efficient way.

In this section of tutorials, you'll learn how to use Liferay DXP's
taglibs to build awesome user interfaces.

\section{Using the Liferay UI Taglib}\label{using-the-liferay-ui-taglib}

You can create a lot of components using the Liferay UI taglibs. Liferay
DXP's taglibs provide the following benefits to your markup:

\begin{itemize}
\tightlist
\item
  Consistent
\item
  Responsive
\item
  Accessible across your portlets
\end{itemize}

The full markup generated by the tags can be found in the JSPs of the
tag's folder in the
\href{https://github.com/liferay/liferay-portal/tree/7.0.x/portal-web/docroot/html/taglib/ui}{Liferay
Github Repo}.

Now that you know the benefits of Liferay DXP's tags, you can learn how
to use them next.

\subsection{Using Liferay UI Tags}\label{using-liferay-ui-tags}

A list of the available Liferay UI taglibs can be found
\href{@platform-ref@/7.0-latest/taglibs/util-taglib/}{here}. To use the
Liferay-UI taglib library in your apps, you must add the following
declaration to your JSP:

\begin{verbatim}
<%@ taglib prefix="liferay-ui" uri="http://liferay.com/tld/ui" %>
\end{verbatim}

The Liferay-UI taglib is also available via a macro for your FreeMarker
theme and web content templates. Follow this syntax:

\begin{verbatim}
<@liferay_ui["tag-name"] attribute="string value" attribute=10 />
\end{verbatim}

Now you're good to go!

Each taglib has a list of attributes that can be passed to the tag. Some
of these are required and some are optional. See the
\href{@platform-ref@/7.0-latest/taglibs/util-taglib/liferay-ui/tld-summary.html}{taglibdocs}
to view the requirements for each tag.

The example below uses the
\texttt{\textless{}liferay-ui:alert\textgreater{}} taglib to create a
success alert that the user can close:

\begin{verbatim}
<liferay-ui:alert
        closeable="true"
        icon="exclamation-full"
        message="Here is our awesome alert example"
        type="success"
/>
\end{verbatim}

Here is an example implementation of a
\texttt{\textless{}liferay-ui:user-display\textgreater{}} taglib:

\begin{verbatim}
<liferay-ui:user-display
        markupView="lexicon"
        showUserDetails="true"
        showUserName="true"
        userId="<%= themeDisplay.getRealUserId() %>"
        userName="<%= themeDisplay.getRealUser().getFullName() %>"
/>
\end{verbatim}

Now you know how to use Liferay-UI taglibs in your JSPs!

\subsection{Related Topics}\label{related-topics-174}

\href{/docs/7-0/tutorials/-/knowledge_base/t/javascript-module-loaders}{JavaScript
Module Loaders}

\href{/docs/7-0/tutorials/-/knowledge_base/t/loading-modules-with-aui-script-in-liferay}{Loading
Modules with the AUI Script in Liferay}

\href{/docs/7-0/tutorials/-/knowledge_base/t/using-the-liferay-util-taglib}{Using
the Liferay Util Taglib}

\section{Using the Liferay Util
Taglib}\label{using-the-liferay-util-taglib}

The Liferay Util taglib is used to pull in other resources into a
portlet or theme, it can be used to dictate which resources need to be
inserted at the bottom or top of the HTML source.

\subsection{Using Liferay Util Tags}\label{using-liferay-util-tags}

A list of the available Liferay Util tags can be found
\href{@platform-ref@/7.0-latest/taglibs/util-taglib/}{here}. To use the
Liferay Util taglib library in your apps, you must add the following
declaration to your JSP:

\begin{verbatim}
<%@ taglib prefix="liferay-util" uri="http://liferay.com/tld/util" %>
\end{verbatim}

The Liferay Util taglib is also available via a macro for your
FreeMarker theme and web content templates. Follow this syntax:

\begin{verbatim}
<@liferay_util["tag-name"] attribute="string value" attribute=10 />
\end{verbatim}

Each taglib has a list of attributes that can be passed to the tag. Some
of these are required and some are optional. See the
\href{@platform-ref@/7.0-latest/taglibs/util-taglib/liferay-util/tld-summary.html}{taglibdocs}
to view the requirements for each tag.

Since each of the Liferay Util taglibs is unique, each tag is covered
briefly in the sections that follow.

\subsubsection{Using Liferay Util Body
Bottom}\label{using-liferay-util-body-bottom}

The \texttt{\textless{}liferay-util:body-bottom\textgreater{}} tag is
not a self-closing tag. The content placed between the opening and
closing of this tag is moved to the bottom of the \texttt{body} tag.
When something is passed using this taglib, the
\href{https://github.com/liferay/liferay-portal/blob/7.0.6-ga7/portal-web/docroot/html/common/themes/body_bottom.jsp\#L26-L31}{body\_bottom.jsp}
is passed markup and outputs in this JSP. The attribute
\texttt{outputKey} is the reference key for this content.

Below is an example configuration for the
\texttt{\textless{}liferay-util:body-bottom\textgreater{}} tag:

\begin{verbatim}
<%@ taglib uri="http://liferay.com/tld/portlet" prefix="liferay-portlet" %>
<%@ taglib uri="http://liferay.com/tld/theme" prefix="liferay-theme" %>
<%@ taglib uri="http://liferay.com/tld/util" prefix="liferay-util" %>

<%@ page import="com.liferay.portal.kernel.util.PortalUtil" %>
<%@ page import="com.liferay.product.navigation.product.menu.web.constants.ProductNavigationProductMenuPortletKeys" %>

<liferay-theme:defineObjects />

<%
String portletNamespace = PortalUtil.getPortletNamespace(ProductNavigationProductMenuPortletKeys.PRODUCT_NAVIGATION_PRODUCT_MENU);
%>

<liferay-util:body-bottom outputKey="productMenu">
        <div class="lfr-product-menu-panel sidenav-fixed sidenav-menu-slider" 
        id="<%= portletNamespace %>sidenavSliderId">
                <div class="product-menu sidebar sidenav-menu">
                        <liferay-portlet:runtime portletName="<%= ProductNavigationProductMenuPortletKeys.PRODUCT_NAVIGATION_PRODUCT_MENU %>" />
                </div>
        </div>
</liferay-util:body-bottom>
\end{verbatim}

\subsubsection{Using Liferay Util Body
Top}\label{using-liferay-util-body-top}

The \texttt{\textless{}liferay-util:body-top\textgreater{}} tag is not a
self-closing tag. The content placed between the opening and closing of
this tag is moved to the top of the \texttt{body} tag. When something is
passed using this taglib the
\href{https://github.com/liferay/liferay-portal/blob/7.0.6-ga7/portal-web/docroot/html/common/themes/body_top.jsp\#L25-L31}{body\_top.jsp}
is passed markup and outputs in this JSP. The attribute
\texttt{outputKey} is the reference key for this content.

Below is an example configuration for the
\texttt{\textless{}liferay-util:body-top\textgreater{}} tag:

\begin{verbatim}
<%@ taglib uri="http://liferay.com/tld/util" prefix="liferay-util" %>

<liferay-util:body-top outputKey="topContent">
        <div>
                <h1>I'm at the top of the page!</h1>
        </div>
</liferay-util:body-top>
\end{verbatim}

\subsubsection{Using Liferay Util
Buffer}\label{using-liferay-util-buffer}

\texttt{\textless{}liferay-util:buffer\textgreater{}} is not a
self-closing tag. The content placed between the opening and closing of
this tag is saved to the value of the \texttt{var} attribute. This
allows a developer to build a piece of markup that can be reused in a
JSP.

Below is an example configuration for the
\texttt{\textless{}liferay-util:buffer\textgreater{}} tag:

\begin{verbatim}
<%@ taglib uri="http://liferay.com/tld/util" prefix="liferay-util" %>

<liferay-util:buffer var="myBuffer">
        <small class="text-capitalize text-muted">
                This is my buffer content
        </small>
</liferay-util:buffer>

<div class="container">
        <h1>Welcome!</h1>

        <%= myBuffer %>
</div>

<div class="container">
        <h1>A Wonderful Title!</h1>

        <%= myBuffer %>
</div>
\end{verbatim}

\subsubsection{Using Liferay Util Dynamic
Include}\label{using-liferay-util-dynamic-include}

The \texttt{\textless{}liferay-util:dynamic-inlude\textgreater{}} tag
allows you to register some content with the
\texttt{DynamicIncludeRegistry}. You can read more about the OSGi
Service Registry
\href{http://docs.spring.io/osgi/docs/current/reference/html/service-registry.html}{here}.
It's easier for modules using the OSGi registry to use the content that
you include with this tag.

Below is an example configuration for the
\texttt{\textless{}liferay-util:dynamic-inlude\textgreater{}} tag:

\begin{verbatim}
<%@ taglib uri="http://liferay.com/tld/util" prefix="liferay-util" %>

<liferay-util:dynamic-include key="/path/to/jsp#pre" />

<div>
        <p>And here we have our content</p>
</div>

<liferay-util:dynamic-include key="/path/to/jsp#post" />
\end{verbatim}

\subsubsection{Using Liferay Util Get
URL}\label{using-liferay-util-get-url}

The \texttt{\textless{}liferay-util:get-url\textgreater{}} tag scrapes
the URL provided by the \texttt{url} attribute. If a value is provided
for the \texttt{var} attribute, the content from the screen scrape is
scoped to that variable. Otherwise, the scraped content is displayed
where the taglib is used.

Below is a basic example configuration for the
\texttt{\textless{}liferay-util:get-url\textgreater{}} tag:

\begin{verbatim}
<%@ taglib uri="http://liferay.com/tld/util" prefix="liferay-util" %>

<liferay-util:get-url url="https://www.google.com/" />
\end{verbatim}

Here is an example that uses the \texttt{var} attribute:

\begin{verbatim}
<liferay-util:get-url url="https://www.google.com/" var="google" />

<div>
        <h2>We stole <a href="https://www.google.com/">Google</a>, here it is.</h2>

        <div class="google">
                <%= google %>
        </div>
</div>
\end{verbatim}

\subsubsection{Using Liferay Util HTML
Bottom}\label{using-liferay-util-html-bottom}

The \texttt{\textless{}liferay-util:html-bottom\textgreater{}} tag is
not a self-closing tag. The content placed between the opening and
closing of this tag will be moved to the bottom of the \texttt{html}
tag. When something is passed using this taglib the
\href{https://github.com/liferay/liferay-portal/blob/7.0.6-ga7/portal-web/docroot/html/common/themes/bottom.jsp\#L53-L59}{bottom.jsp}
is passed markup and outputs in this JSP. The attribute
\texttt{outputKey} is the reference key for this content.

Below is an example of using
\texttt{\textless{}liferay-util:html-bottom\textgreater{}}. Commonly,
JavaScript is passed to this tag:

\begin{verbatim}
<%@ taglib uri="http://liferay.com/tld/util" prefix="liferay-util" %>

<liferay-util:html-bottom outputKey="taglib_alert_user">
        <aui:script use="liferay-alert">
                new Liferay.Alert(
                        {
                                closeable: true,
                                message: 'Just saying hello from the 
                                &lt;liferay-util:html-bottom&gt; taglib!',
                                type: 'success'
                        }
                ).render(#wrapper);
        </aui:script>
</liferay-util:html-bottom>
\end{verbatim}

\subsubsection{Using Liferay Util HTML
Top}\label{using-liferay-util-html-top}

The \texttt{\textless{}liferay-util:html-top\textgreater{}} tag is not a
self-closing tag. The content placed between the opening and closing of
this tag is moved to the \texttt{head} tag. When something is passed
using this taglib the
\href{https://github.com/liferay/liferay-portal/blob/7.0.6-ga7/portal-web/docroot/html/common/themes/top_head.jsp\#L147-L153}{top\_head.jsp}
is passed markup and outputs in this JSP. The attribute
\texttt{outputKey} is the reference key for this content.

Below is an example configuration for the
\texttt{\textless{}liferay-util:html-top\textgreater{}} tag:

\begin{verbatim}
<%@ taglib uri="http://liferay.com/tld/util" prefix="liferay-util" %>

<liferay-util:html-top>
        <link data-senna-track="permanent" href="/path/to/style.css" rel="stylesheet" type="text/css" />
</liferay-util:html-top>
\end{verbatim}

\subsubsection{Using Liferay Util
Include}\label{using-liferay-util-include}

The \texttt{\textless{}liferay-util:include\textgreater{}} tag can be
used to include other JSP files in a portlet. This can increase
readability as well as provide separation of concerns for JSP files.

Below is an explanation of some of the available attributes:

\begin{itemize}
\item
  \texttt{page}: This attribute is required. The value of this attribute
  is the path to the JSP or JSPF to be included.
\item
  \texttt{servletContext}: Refers to the request context that the
  included JSP should use. Passing
  \texttt{\textless{}\%=\ application\ \%\textgreater{}} to this
  attribute allows the included JSP to use the same \texttt{request}
  object and other objects that might be set in the prior JSP.
\end{itemize}

Below is an example configuration for the
\texttt{\textless{}liferay-util:include\textgreater{}} tag:

\begin{verbatim}
<%@ taglib uri="http://liferay.com/tld/util" prefix="liferay-util" %>

<liferay-util:include page="/path/to/view.jsp" servletContext="<%= application %>" />
\end{verbatim}

\subsubsection{Using Liferay Util Param}\label{using-liferay-util-param}

The \texttt{\textless{}liferay-util:param\textgreater{}} tag can be used
to add a parameter value to a URL. This tag is best used when combined
with the \texttt{\textless{}liferay-util:include\textgreater{}} tag for
accessing new parameter values in another JSP.

Below is an example configuration for the
\texttt{\textless{}liferay-util:param\textgreater{}} tag:

\begin{verbatim}
<%@ taglib uri="http://liferay.com/tld/util" prefix="liferay-util" %>

<liferay-util:include page="/path/to/answer.jsp" servletContext="<%= application %>">
        <liferay-util:param name="answer" value="42" />
</liferay-util:include>
\end{verbatim}

The new parameter can then be used in \texttt{answer.jsp} like this:

\begin{verbatim}
<%@ page import="com.liferay.portal.kernel.util.ParamUtil" %>

<div>
        <p>The answer to life the universe and everything is 
        <%= ParamUtil.getString(request, "answer") %></p>
</div>
\end{verbatim}

\subsubsection{Using Liferay Util Whitespace
Remover}\label{using-liferay-util-whitespace-remover}

The \texttt{\textless{}liferay-util:whitespace-remover\textgreater{}}
tag is used for removing all whitespace from whatever is included
between the opening and closing of the tag.

Below is an example configuration for the
\texttt{\textless{}liferay-util:whitespace-remover\textgreater{}} tag:

\begin{verbatim}
<%@ taglib uri="http://liferay.com/tld/util" prefix="liferay-util" %>

<liferay-util:whitespace-remover>
        <div class="input-container">
                <label for="myInput">
                        Is the &lt;liferay-util:whitespace-remover&gt; taglib 
                        fantastic!
                </label>

                <input class="input" id="myInput" name="myInput" type="checkbox">
        </div>
</liferay-util:whitespace-remover>
\end{verbatim}

Now you know how to use the Liferay-Util taglib!

\subsection{Related Topics}\label{related-topics-175}

\href{/docs/7-0/tutorials/-/knowledge_base/t/loading-modules-with-aui-script-in-liferay}{Loading
Modules with the AUI Script in Liferay}

\href{/docs/7-0/tutorials/-/knowledge_base/t/using-the-liferay-ui-taglib}{Using
the Liferay UI Taglib}

\chapter{HTML Forms}\label{html-forms}

Forms are a must-have tool in any developer's UI bag. Rather than write
your HTML from scratch, Liferay provides you with taglibs that offer
everything standard HTML elements have, as well as some additional
attributes that are Liferay specific. For a full list of all the
available taglibs and attributes, look at Liferay's API docs on
\href{@platform-ref@/7.0-latest/taglibs/util-taglib}{docs.liferay.com}

Using a combination of Liferay's \texttt{AUI} taglibs and
\href{https://liferay.github.io/clay/}{Lexicon} classes, you can create
forms in your app's JSPs. You can learn how to create an MVC portlet
project in the
\href{/docs/7-0/reference/-/knowledge_base/r/using-the-mvc-portlet-template}{using-the-mvc-portlet-template}
tutorial.

In this section of tutorials, you'll learn how to use the platform
features to create forms with ease.

\section{Forms and Validation}\label{forms-and-validation}

Creating forms is easy and flexible, thanks to Liferay DXP's form,
input, and validation tags.

The \texttt{\textless{}aui:form\textgreater{}} tag sets up the necessary
code (HTML, JS), uses Liferay JavaScript APIs, calls the validation
framework, and submits the form data to the back-end.

The \emph{input} tags (\texttt{\textless{}aui:input\textgreater{}},
\texttt{\textless{}liferay-ui:input-*\textgreater{}}, etc.) generate the
necessary code (HTML, CSS, JS) to provide you with a consistent UI
throughout your form. These tags also initialize the field's state
(e.g.~\texttt{value}, \texttt{disabled}, \texttt{readonly}, etc.).

The \texttt{\textless{}aui:validator\textgreater{}} tag lets you create
validation rules for your form's input tags. This ensures that your
users enter the proper data in the format you expect before it gets sent
to the back-end for final validation and processing.

The following tags support validators natively:

\begin{itemize}
\tightlist
\item
  \texttt{\textless{}aui:input\textgreater{}}
\item
  \texttt{\textless{}aui:select\textgreater{}}
\item
  \texttt{\textless{}liferay-ui:input-date\textgreater{}}
\item
  \texttt{\textless{}liferay-ui:input-search\textgreater{}}
\end{itemize}

All other fields can be validated using the method described in the
\href{/docs/7-0/tutorials/-/knowledge_base/t/forms-and-validation\#adding-custom-validators-in-javascript}{Adding
Custom Validators in JavaScript} section below.

Get started by creating a basic form next.

\subsection{Creating Your First Form}\label{creating-your-first-form}

Below is an example configuration for a simple form in a JSP:

\begin{verbatim}
<aui:form action="<%= myActionURL %>" method="post" name="myForm">
        <aui:input label="My Text Input" name="myTextInput" type="text" 
        value='<%= "My Text Value" %>' />

        <aui:button type="submit" />
</aui:form>
\end{verbatim}

Although this form is simple, it provides all that's needed to pass the
data to the back-end. The full HTML generated for this example is shown
below:

\begin{verbatim}
<form action="http://localhost:8080/web/guest/home?p_p_id=my_portlet&amp;p_p_lifecycle=1&amp;p_p_state=normal&amp;p_p_mode=view&amp;p_p_col_id=column-1&amp;p_p_col_count=3&amp;_my_portlet_javax.portlet.action=%2Fmy%2Faction&amp;_my_portlet_mvcRenderCommandName=%2Fmy%2Faction&amp;p_auth=WAxorpsN" class="form" data-fm-namespace="_my_portlet_" id="_my_portlet_myForm" method="post" name="_my_portlet_myForm">
        <input class="field form-control" id="_my_portlet_formDate" 
        name="_my_portlet_formDate" type="hidden" value="1472516415545">

        <div class="form-group input-text-wrapper">
                <label class="control-label" 
                for="_my_portlet_myTextInput">My Text Input</label>

                <input class="field form-control" id="_my_portlet_myTextInput" 
                name="_my_portlet_myTextInput" type="text" 
                value="My Text Value">
        </div>

        <button class="btn  btn-primary btn-default" id="_my_portlet_kpyg" 
        type="submit">
                <span class="lfr-btn-label">Save</span>
        </button>
</form>
\end{verbatim}

As you can see, the tags provide all this to you for very little work!
Next you can learn how to add validation to your forms.

\subsection{Adding Validation}\label{adding-validation}

What if you want to ensure the user enters the required data? Add
validators.

An example configuration is shown below:

\begin{verbatim}
<aui:input label="My Text Input" name="myTextInput" type="text" 
value='<%= "My Text Value" %>'>
        <aui:validator name="required" />
</aui:input>
\end{verbatim}

This forces the user to enter something before the form is submitted.

\begin{figure}
\centering
\includegraphics{./images/forms-input-required.png}
\caption{A field with a failed required validator.}
\end{figure}

What if you wanted to restrict the value to a number between \texttt{0}
and \texttt{10}? There's a validator for that. Each of the validators
shown below must pass to submit the form:

\begin{verbatim}
<aui:validator name="required" />
<aui:validator name="number" />
<aui:validator name="range">[0,10]</aui:validator>
\end{verbatim}

You can even customize the error message, as shown below:

\begin{verbatim}
<aui:validator errorMessage="Please enter how many fingers you have." 
name="range">[0,10]</aui:validator>
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/forms-input-required-message.png}
\caption{A required validator with a custom error message.}
\end{figure}

Below is a list of all the available validation rules:

\textbf{acceptFiles:} Specifies that the field can contain only the file
types given. Each file extension must be separated by a comma. For
example
\texttt{\textless{}aui:validator\ name="acceptFiles"\textgreater{}\textquotesingle{}jpg,png,tif,gif\textquotesingle{}\textless{}/aui:validator\textgreater{}}

\textbf{alpha:} Allows only alphabetic characters.

\textbf{alphanum:} Allows only alphanumeric characters.

\textbf{date:} Allows only a date.

\textbf{digits:} Allows only digits.

\textbf{email:} Allows only an email address.

\textbf{equalTo:} Allows only contents equal to some other field that
has the specified field ID. The ID is declared in the opening and
closing validator tags. For example
\texttt{\textless{}aui:validator\ name="equalTo"\textgreater{}\textquotesingle{}\#\textless{}portlet:namespace\ /\textgreater{}password\textquotesingle{}\textless{}/aui:validator\textgreater{}}

\textbf{max:} Allows only an integer value less than the specified
value. For example, a \texttt{max} value of \texttt{20} is specified
here
\texttt{\textless{}aui:validator\ name="max"\textgreater{}20\textless{}/aui:validator\textgreater{}}

\textbf{maxLength:} Allows a maximum field length of the specified size.
The syntax is the same as \texttt{max}.

\textbf{min:} Allows only an integer value greater than the specified
value. The syntax is the same as \texttt{max}.

\textbf{minLength:} Allows a field length longer than the specified
size. The syntax is the same as \texttt{max}.

\textbf{number:} Allows only numerical values.

\textbf{range:} Allows only a number between the specified range. For
example, a range between 1.23 and 10 is specified here
\texttt{\textless{}aui:validator\ name="range"\textgreater{}{[}1.23,10{]}\textless{}/aui:validator\textgreater{}}

\textbf{rangeLength:} Allows a field length between the specified range.
For example, a range between 3 and 8 characters long is specified here
\texttt{\textless{}aui:validator\ name="rangeLength"\textgreater{}{[}3,8{]}\textless{}/aui:validator\textgreater{}}

\textbf{required:} Prevents a blank field.

\textbf{url:} Allows only a URL value.

Now that you know how to validate your forms, you can learn how to
conditionally require user input next.

\subsection{Conditionally Requiring A
Field}\label{conditionally-requiring-a-field}

Sometimes you'll want to validate a field based on the value of another
field. You can do this by checking for that condition in a JavaScript
function within the \texttt{required} validator's body.

Below is an example configuration:

\begin{verbatim}
<aui:input label="My Checkbox" name="myCheckbox" type="checkbox" />

<aui:input label="My Text Input" name="myTextInput" type="text">
        <aui:validator name="required">
                function() {
                        return AUI.$('#<portlet:namespace />myCheckbox').prop('checked');
                }
        </aui:validator>
</aui:input>
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/forms-input-required-condition.png}
\caption{Fields can required based on other conditions.}
\end{figure}

Next you can learn how to add custom validators.

\subsection{Adding Custom Validators}\label{adding-custom-validators}

So far, you've only seen the default set of AUI validator rules. What if
you need something that the default rules don't provide?

You can write your own validator and optionally supplement it with
built-in validators, as shown below:

\begin{verbatim}
<aui:input label="Email" name="email" type="text">
        <aui:validator name="email" />

        <aui:validator errorMessage="Only emails from @example.com are allowed." 
        name="custom">
                function(val, fieldNode, ruleValue) {
                        var regex = new RegExp(/@example\.com$/i);

                        return regex.test(val);
                }
        </aui:validator>
</aui:input>
\end{verbatim}

This example runs the regular \texttt{email} validator, as well as a
\texttt{custom} domain validator.

\begin{figure}
\centering
\includegraphics{./images/forms-input-custom.png}
\caption{You can write your own custom validations.}
\end{figure}

Next you can learn how to add custom validators in JavaScript.

\subsection{Adding Custom Validators in
JavaScript}\label{adding-custom-validators-in-javascript}

Sometimes you need to add additional validation dynamically after the
page has rendered. Perhaps some additional fields were added to the DOM
via an AJAX request.

To do this, you must access the \texttt{Liferay.Form} object, as
demonstrated below:

\begin{verbatim}
<aui:script use="liferay-form">
        var form = Liferay.Form.get('<portlet:namespace />myForm');
        // ...
\end{verbatim}

The \texttt{Liferay.Form} object allows you to \texttt{get()} and
\texttt{set()} \texttt{fieldRules}.

\texttt{fieldRules} are the JavaScript equivalent of all the validators
attached to the form.

This example below uses a \texttt{custom} validator and the built-in
\texttt{number} validator.

\begin{verbatim}
<aui:script use="liferay-form">
        var form = Liferay.Form.get('<portlet:namespace />myForm');

        var oldFieldRules = form.get('fieldRules');

        var newFieldRules = [
                {
                        body: function (val, fieldNode, ruleValue) {
                                return (val !== '2');
                        },
                        custom: true,
                        errorMessage: 'must-not-equal-2',
                        fieldName: '<portlet:namespace />fooInput',
                        validatorName: 'custom_fooInput'
                },
                {
                        fieldName: '<portlet:namespace />fooInput',
                        validatorName: 'number'
                }
        ];

        var fieldRules = oldFieldRules.concat(newFieldRules);

        form.set('fieldRules', fieldRules);

</aui:script>
\end{verbatim}

Notice that \texttt{newFieldRules} are combined with
\texttt{oldFieldRules}, using \texttt{concat()}. You could leave this
part out, and you'd have a whole new set of validators for the whole
form.

Next you can learn how to validate your forms manually.

\subsection{Manual Validation}\label{manual-validation}

You may need to execute validation on a field, based on some event not
typical of user input. For instance, you may need to validate a related
field at the same time.

To do this, you must access the \texttt{formValidator} object and call
the \texttt{validateField()} method, passing the field's \texttt{name}.
Below is an example configuration:

\begin{verbatim}
<aui:input label="Old Title" name="oldTitle" type="text">
        <aui:validator errorMessage="The New Title cannot match the Old Title" 
        name="custom">
                function(val, fieldNode, ruleValue) {
                        <portlet:namespace />checkOtherTitle('<portlet:namespace />newTitle');

                        // check if old and new titles are a match

                        return !match;
                }
        </aui:validator>
</aui:input>

<aui:input label="New Title" name="newTitle" type="text">
        <!-- same custom validator -->
</aui:input>

<aui:script use="liferay-form">
        function <portlet:namespace />checkOtherTitle(fieldName) {
                var formValidator = 
                Liferay.Form.get('<portlet:namespace />myForm').formValidator;

                formValidator.validateField(fieldName);
        }
</aui:script>
\end{verbatim}

Now you know how to create and validate forms!

\subsection{Related Topics}\label{related-topics-176}

\href{/docs/7-0/tutorials/-/knowledge_base/t/front-end-taglibs}{Front-End
Taglibs}

\section{Creating Forms with Liferay's
Taglibs}\label{creating-forms-with-liferays-taglibs}

This tutorial demonstrates how to:

\begin{itemize}
\tightlist
\item
  Create a form using 7.0's taglibs in your application's JSPs
\end{itemize}

To begin, take a look at the Portlet Configuration application's
\href{https://github.com/liferay/liferay-portal/blob/2960360870ae69360861a720136e082a06c5548f/modules/apps/web-experience/portlet-configuration/portlet-configuration-web/src/main/resources/META-INF/resources/add_configuration_template.jsp}{add\_configuration\_template.jsp}
form for example:

\begin{verbatim}
<aui:form action="<%= updateArchivedSetupURL %>"
cssClass="container-fluid-1280" method="post" name="fm">
        <aui:input name="redirect" type="hidden" value="<%= redirect %>" />
        <aui:input name="portletResource" type="hidden"
        value="<%= portletResource %>" />

        <aui:fieldset-group markupView="lexicon">
                <aui:fieldset>

                        <%
                        String name = StringPool.BLANK;
                        boolean useCustomTitle =
                        GetterUtil.getBoolean(portletPreferences.getValue
                        ("portletSetupUseCustomTitle", null));
                        if (useCustomTitle) {
                                name = PortletConfigurationUtil.getPortletTitle
                                (portletPreferences, LocaleUtil.toLanguageId
                                (themeDisplay.getSiteDefaultLocale()));
                        }
                        %>

                        <aui:input name="name" placeholder="name"
                        required="<%= true %>" type="text" value="<%= name
                        %>">
                                <aui:validator name="maxLength">75
                                </aui:validator>
                        </aui:input>
                </aui:fieldset>
        </aui:fieldset-group>

        <aui:button-row>
                <aui:button type="submit" />

                <aui:button href="<%= redirect %>" type="cancel" />
        </aui:button-row>
</aui:form>
\end{verbatim}

As you can see, a standard form uses quite a few taglibs. If you take a
closer look, you'll notice that all of the taglibs are prefixed with
\texttt{aui}. \texttt{aui} stands for
\href{http://alloyui.com/}{AlloyUI}, a JavaScript framework that uses
Bootstrap to allow you to create UI components, easily and effectively.
In order to use these AUI tags, you will need to have the AUI taglib
declaration imported into your JSP. You'll take care of this next.

\subsection{Adding the Taglib
Declaration}\label{adding-the-taglib-declaration}

The first thing you'll need to do is make sure you have the
\texttt{\textless{}\%@\ taglib\ uri="http://liferay.com/tld/aui"\ prefix="aui"\%\textgreater{}}
declaration is in your JSP. This can be added to the main view of your
app, \texttt{view.jsp} for example, or it can be added to a separate JSP
file, such as \texttt{init.jsp}, and imported into the JSP in which you
want to show the form. For example, the Portlet Configuration
application includes the taglib declarations in its \texttt{init.jsp},
and then imports the \texttt{init.jsp} into its \texttt{view.jsp}, using
the following line:

\begin{verbatim}
<%@ include file="/init.jsp"%>
\end{verbatim}

Once the AUI taglib declaration is imported, you can move onto creating
the form next.

\subsection{Creating the Form}\label{creating-the-form}

A form's design is determined by the input needed from the user. To that
end, there are multiple design possibilities. The examples covered in
the sections that follow are one possible design, and highlight some of
the available attributes for the tags. The steps are laid out in a
natural order, however you can jump to any section you wish.

For a full list of the available attributes for the form tags covered,
checkout the API docs for the
\href{@platform-ref@/7.0-latest/taglibs/util-taglib/aui/tld-summary.html}{AUI
Tags}.

Go ahead and get started by adding the form tag next.

\subsubsection{Adding the Form Wrapper}\label{adding-the-form-wrapper}

Start off by adding a \texttt{\textless{}aui:form\textgreater{}} tag to
your jsp. Make sure to add a closing
\texttt{\textless{}aui:form/\textgreater{}} tag, to wrap your form. This
acts as a wrapper for your form and offers some additional styling and
custom portlet namespacing for you to use. If you are familiar with HTML
\texttt{\textless{}form\textgreater{}} tags,
\texttt{\textless{}aui:form\textgreater{}} tags are configured the same
way. For instance, the Bloggs Aggregator app has the following
configuration:

\begin{verbatim}
<aui:form action="<%= configurationActionURL %>" method="post" name="fm">
\end{verbatim}

The \texttt{action} attribute specifies where to send the form data when
the form is submitted. The \texttt{method} attribute defines the method
to use to send the form data(in most cases this will be post). Finally,
the \texttt{name} attribute specifies the name for the form, as well as
the ID for the component instance for the form. It's important to note
that, by default, \texttt{aui:form} places the portlet namespace in
front of the \texttt{name} and \texttt{id} attributes. This is also the
default behavior for the \texttt{aui:input} tag as well.

You can find a full list of the available attributes for the
\texttt{\textless{}aui:form\textgreater{}} tag in the
\href{@platform-ref@/7.0-latest/taglibs/util-taglib/aui/form.html}{AUI
Form Taglib Docs}.

Now that your form element is created, you can add your fieldsets next.

\subsubsection{Adding the Fieldset Groups and
Fieldsets}\label{adding-the-fieldset-groups-and-fieldsets}

The next main element is the
\texttt{\textless{}aui:fieldset-group\textgreater{}} tag. This tag
creates a \texttt{\textless{}div\textgreater{}} to group fieldset
elements of the form. Looking at the Portlet Configuration example, you
can see the following pattern:

\begin{verbatim}
<aui:fieldset-group markupView="lexicon">
\end{verbatim}

It's important to note the addition of the \texttt{markupView="lexicon"}
attribute. This ensures that the lexicon HTML markup and CSS styles are
used to render the element, rather than the standard markup.

Add the
\texttt{\textless{}aui:fieldset-group\ markupView="lexicon"\textgreater{}}
tag, just below the \texttt{\textless{}aui:form\textgreater{}} tag you
just added. And make sure to add the closing
\texttt{\textless{}/aui:fieldset-group\textgreater{}} tag just before
the closing \texttt{\textless{}/aui:form\textgreater{}} tag. Your form
should look something like this at this point:

\begin{verbatim}
<aui:form action="<%= ActionURL %>" method="post" name="fm">
    <aui:fieldset-group markupView="lexicon">

    </aui:fieldset-group>
</aui:form>
\end{verbatim}

Now that your fieldset group is added, you can add your fieldset next.
The \texttt{\textless{}aui:fieldset\textgreater{}} tag creates a
\texttt{\textless{}div\textgreater{}} to group related form elements and
offers some additional styling attributes as well.

Use the following pattern to add the
\texttt{\textless{}aui:fieldset\textgreater{}} tag to your form:

\begin{verbatim}
<aui:fieldset >

</aui:fieldset>
\end{verbatim}

Alternatively, if you have multiple fieldsets, you can update your tags
to be collapsible, using the following pattern:

\begin{verbatim}
<aui:fieldset collapsed="<%= true %>" collapsible="<%= true %>" >

</aui:fieldset>
\end{verbatim}

You can find a full list of the available attributes for the
\texttt{\textless{}aui:fieldset\textgreater{}} tag in the
\href{@platform-ref@/7.0-latest/taglibs/util-taglib/aui/fieldset.html}{AUI
Fieldset Taglib Docs}.

Next, you can add your input fields.

\subsubsection{Adding the Input Fields}\label{adding-the-input-fields}

Each fieldset is used to group similar form elements together. In this
section, you'll take a look at the different kinds of input fields you
can use in your form.

AUI input fields use the following pattern:

\begin{verbatim}
<aui:input label="label" name="name" type="type" />
\end{verbatim}

The \texttt{label} attribute sets the label for the input field. The
\texttt{name} attribute sets the name for the field. Finally, the
\texttt{type} attribute sets the type of input to use for the field.

The \texttt{type} attribute supports the following types:

\begin{itemize}
\tightlist
\item
  file: Adds a file browser.
\item
  text: The default value if no \texttt{type} is specified. Adds a text
  input field.
\item
  hidden: Adds a hidden text field.
\item
  assetCategories: Adds a \texttt{liferay-ui:asset-categories-selector}
  component.
\item
  assetTags: Adds a \texttt{liferay-ui:asset-tags-selector} component.
\item
  textarea: Adds a textarea box.
\item
  timeZone: Adds a \texttt{liferay-ui:input-time-zone} component.
\item
  password: Adds a password input field.
\item
  checkbox: Adds a checkbox.
\item
  radio: Adds a radio button.
\item
  color: Adds a HTML color picker.
\item
  editor: Adds a \texttt{liferay-ui:input-editor} component.
\item
  email: Adds an email input field.
\item
  number: Adds a number selector.
\item
  range: Adds a range slider.
\item
  resource: Adds a \texttt{liferay-ui:input-resource} component.
\item
  toggle-card: Adds a
  \href{https://liferay.github.io/clay/content/toggles/\#toggleCard}{Toggle
  Card}
\item
  toggle-switch: Adds a
  \href{https://liferay.github.io/clay/content/toggles/\#toggle-switch}{Toggle
  Switch}
\item
  url: Adds a URL input field.
\end{itemize}

For a full list of all the attributes available for the
\texttt{\textless{}aui:input\textgreater{}} tag, check out the
\href{@platform-ref@/7.0-latest/taglibs/util-taglib/aui/input.html}{AUI
Input Taglib Docs}.

Once you've added all of your input fields, you can move onto the form's
buttons next.

\subsubsection{Adding the Button Rows and
Buttons}\label{adding-the-button-rows-and-buttons}

Taking a look at the portlet configuration application example once
again, you can see that form buttons follow the pattern below:

\begin{verbatim}
<aui:button-row>
        <aui:button type="submit" />

        <aui:button href="<%= redirect %>" type="cancel" />
</aui:button-row>
\end{verbatim}

The \texttt{\textless{}aui:button-row\textgreater{}} tags acts as a
wrapper for the form's buttons, and offers some additional styling
through the \texttt{cssClass} attribute.

The \texttt{\textless{}aui:button\textgreater{}} tag is a standard input
button, with some additional attributes. It supports the
\texttt{button}, \texttt{submit}(the default type), \texttt{cancel}, and
\texttt{reset} types for the \texttt{type} attribute. Note that you if
you wish to emphasize the button as a primary action, you can add the
\texttt{primary="true"} attribute to your button:

\begin{verbatim}
<aui:button
    cssClass="btn-lg"
    id="submit"
    label="save"
    primary="<%= true %>"
    type="submit"
/>
\end{verbatim}

For a full list of the attributes available for the
\texttt{\textless{}aui:button\textgreater{}} tag, check out the
\href{@platform-ref@/7.0-latest/taglibs/util-taglib/aui/button.html}{AUI
Button Taglib Docs}.

Your form is complete!

\subsection{Related Topics}\label{related-topics-177}

\href{/docs/7-0/tutorials/-/knowledge_base/t/portlet-decorators}{Portlet
Decorators}

\href{/docs/7-0/user/-/knowledge_base/u/basic-forms}{Basic Forms}

\href{/docs/7-0/tutorials/-/knowledge_base/t/themes-generator}{Liferay
Theme Generator}

\section{Form Navigator Extensions}\label{form-navigator-extensions}

Some data-centric applications require the creation of large data-entry
forms. Examples abound in healthcare, transportation, pharmaceutical, or
any other heavily regulated industry. For these applications, you need
an easy way to section off your forms into easily navigable groups.

Since 7.0, the Form Navigator framework enables you to add new sections
and section categories dynamically to existing form navigation. The
framework includes a well-described API and a powerful
\href{@platform-ref@/7.0-latest/taglibs/util-taglib/liferay-ui}{\texttt{liferay-ui}}
tag called
\href{@platform-ref@/7.0-latest/taglibs/util-taglib/liferay-ui/form-navigator.html}{\texttt{form-navigator}}.
It's easy to use and facilitates organizing large forms into sections of
input and categories.

\begin{figure}
\centering
\includegraphics{./images/form-navigator-portal-setting-extension.png}
\caption{The Form Navigator framework lets you add your app's
configuration forms to existing form navigators, like the one used in
Portal Settings.}
\end{figure}

Form Navigators can be used in two ways: customizing a Form Navigator
that already exists in the portal, and creating your own Form Navigator
for your application. This tutorial demonstrates customizing an existing
form. It references source code from an example portlet called the Form
Nav Extension portlet. On GitHub, you can find its complete project
called
\href{https://github.com/liferay/liferay-docs/tree/master/develop/tutorials/code/osgi/modules/form-nav-extension-portlet}{form-nav-extension-portlet}.
You can also download the Form Nav Extension portlet's bundle
\texttt{form-nav-extension-portlet-1.0.jar}. To download it, go to its
GitHub
\href{https://github.com/liferay/liferay-docs/blob/master/develop/tutorials/code/osgi/modules/form-nav-extension-portlet-1.0.jar}{page}
and click the \emph{View Raw} link.

Before extending a Form Navigator, you should understand the parts of
the Form Navigator Framework and what they do.

\subsection{Understanding the Parts of the Form Navigator
Framework}\label{understanding-the-parts-of-the-form-navigator-framework}

Form Navigator implementations contain the following parts:

\begin{itemize}
\tightlist
\item
  \textbf{A JSP that contains a form}: The form must specify a
  \texttt{form-navigator} tag. All the form's input sections tie into
  the Form Navigator.
\item
  \textbf{Sections}: A section (or entry) is a JSP that specifies inputs
  and a Java class that models the section and ties it into the Form
  Navigator.
\item
  \textbf{Categories}: A category aggregates one or more sections. A
  Java class models it and ties it into the Form Navigator.
\item
  \textbf{IDs}: A Form Navigator and its categories should be publicly
  identified. That is, they should all have IDs that can be looked up in
  a public API (e.g., Javadoc). A developer extending a Form Navigator
  must otherwise have access to the Form Navigator's source code in
  order to find the IDs.
\end{itemize}

Liferay's Form Navigator implementations meet all these requirements.
They're implemented similarly and their IDs are published in the Javadoc
for the class
\href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/servlet/taglib/ui/FormNavigatorConstants.html}{\texttt{FormNavigatorConstants}}.

\noindent\hrulefill

\textbf{Note}: Form Navigator extensions implemented using portal
properties and form navigation entry JSPs are deprecated but still
supported in 7.0. All new Form Navigator extensions should be
implemented as this tutorial describes.

\noindent\hrulefill

Now that you know the parts of a Form Navigator, it'll be easier for you
to extend one.

\subsection{Extending a Form
Navigator}\label{extending-a-form-navigator}

Here's an overview of the steps to extend a Form Navigator:

\begin{itemize}
\tightlist
\item
  \textbf{Step 1: Implement a component portlet project to accommodate
  form navigation.}
\item
  \textbf{Step 2: Create a JSP for each new section of inputs.}
\item
  \textbf{Step 3: Identify the Form Navigator and category (if any)
  you're extending.}
\item
  \textbf{Step 4: Create new categories.}
\item
  \textbf{Step 5: Create new sections.}
\end{itemize}

Let's set up a component portlet project to support form navigation.

\subsubsection{Step 1: Implement a component portlet project to
accommodate form
navigation}\label{step-1-implement-a-component-portlet-project-to-accommodate-form-navigation}

First, your component portlet must be implemented as an OSGi bundle. You
can develop it in any environment that supports creating a bundle.
Please refer to the 7.0 tutorial section
\href{/docs/7-0/tutorials/-/knowledge_base/t/tooling}{Tooling} to learn
about development environments. The Form Nav Extension portlet was
created with BLADE based on the \texttt{blade.portlet.jsp} template.
This is also covered in the tutorial section linked above.

A Form Navigator extension bundle's metadata must do the following
things:

\begin{itemize}
\tightlist
\item
  Specify the bundle's symbolic name for your servlet context to target
\item
  Include your project's classes, JSPs, and resource bundles (for
  localization)
\item
  Include the \texttt{JspAnalyzerPlugin} to generate generate metadata
  for the JSPs' dependencies
\item
  Specify a web context path for the Form Navigator classes to associate
  with the JSPs
\end{itemize}

You should use a \texttt{bnd.bnd} file to specify this metadata. Your
Bnd file should include definitions and directives similar to those
specified in the Form Nav Extension portlet's \texttt{bnd.bnd} file:

\begin{verbatim}
Bundle-Name: Form Nav Extension Portlet
Bundle-SymbolicName: com.liferay.docs.formnavextensionportlet
Bundle-Version: 1.0.0
Include-Resource:\
        classes,\
        META-INF/resources=src/main/resources/META-INF/resources
-jsp: *.jsp,*.jspf
-plugin.jsp: com.liferay.ant.bnd.jsp.JspAnalyzerPlugin
Web-ContextPath: /formnavextensionportlet
\end{verbatim}

The \texttt{Bundle-Name} value is arbitrary, but should be recognizable
and unique. The \texttt{Bundle-SymbolicName} must be unique--the
project's package path makes for a good symbolic name. For the
\texttt{Include-Resource}, make sure to include your project's classes
and the root path of its JSPs. The directive below includes all the
project's \texttt{.jsp} and \texttt{.jspf} files:

\begin{verbatim}
-jsp: *.jsp,*.jspf
\end{verbatim}

And the following directive to specify a plugin to include all the JSP
dependencies:

\begin{verbatim}
-plugin.jsp: com.liferay.ant.bnd.jsp.JspAnalyzerPlugin
\end{verbatim}

Lastly, the \texttt{Web-ContextPath} specifies the root of the portlet's
web context.

As you progress through this tutorial, you'll refer to the metadata in
your portlet's classes. Before diving into the Java classes, howerver,
let's create JSPs for your sections' inputs.

\subsubsection{Step 2: Create a JSP for each new section of
inputs}\label{step-2-create-a-jsp-for-each-new-section-of-inputs}

The existing Form Navigator has a form, and each of its sections extend
the form with sets of input. Your section will add its own inputs. You
should create your section's JSP under the \texttt{META-INF/resources}
property folder you defined in your \texttt{bnd.bnd} file's
\texttt{Include-Resource} directive. The example Bnd file specified the
folder like this:

\begin{verbatim}
META-INF/resources=src/main/resources/META-INF/resources 
\end{verbatim}

Under the folder, you can add a JSP for each section of inputs you want
to add to the Form Navigator. Feel free to organize these with
subfolders.

The Form Nav Extension portlet's JSP file
\texttt{/portal\_settings/my\_app.jsp} provides a checkbox input to
enable/disable My App's feature in the portal:

\begin{verbatim}
    <%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %>

    <%@ taglib uri="http://liferay.com/tld/aui" prefix="aui" %>
    <%@ taglib uri="http://liferay.com/tld/ui" prefix="liferay-ui" %>

    <%@ page import="com.liferay.docs.formnavextensionportlet.MyAppWebKeys" %>
    <%@ page import="com.liferay.portal.kernel.util.GetterUtil" %>
    <%@ page import="com.liferay.portal.kernel.util.ResourceBundleUtil" %>

    <%@ page import="java.util.ResourceBundle" %>

    <%
    boolean companyMyAppFeatureEnabled = GetterUtil.getBoolean(request.getAttribute(MyAppWebKeys.COMPANY_MY_APP_FEATURE_ENABLED));

    ResourceBundle resourceBundle = ResourceBundleUtil.getBundle("content.Language", request.getLocale(), getClass());
    %>

    <h3><liferay-ui:message key='<%= resourceBundle.getString("my-app-features") %>' /><h3>

    <aui:input checked="<%= companyMyAppFeatureEnabled %>" label='<%= resourceBundle.getString("enable-my-app-feature") %>' name="settings--myAppFeatureEnabled--" type="checkbox" value="<%= companyMyAppFeatureEnabled %>" />
\end{verbatim}

The input's name is \texttt{settings-\/-myAppFeatureEnabled-\/-}. So
that the Form Navigator detects the inputs automatically, make sure to
start each of your input's names with \texttt{settings-\/-} and end them
with \texttt{-\/-}. Add all the inputs you need in each of your sets of
inputs.

After creating section JSPs, you must find out the IDs of the existing
Form Navigator and categories you're adding sections to. You refer to
these IDs in the category and section classes you'll create to represent
your Form Navigator extensions.

\subsubsection{Step 3: Identify the form navigator and category you're
extending}\label{step-3-identify-the-form-navigator-and-category-youre-extending}

Liferay's class
\href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/servlet/taglib/ui/FormNavigatorConstants.html}{\texttt{FormNavigatorConstants}}
specifies constant values for all the portlet Form Navigators and
categories. The identifiers follow the naming conventions below, where
you substitue \emph{FOO} for the navigator's or category's name:

\begin{itemize}
\tightlist
\item
  \textbf{Form navigator}: \texttt{FORM\_NAVIGATOR\_ID\_FOO}
\item
  \textbf{Category}: \texttt{CATEGORY\_KEY\_FOO}
\end{itemize}

Note the names of the constants that match the Form Navigator and
categories you're extending--you'll refer to them in your Java classes
in the next steps.

\subsubsection{Step 4: Create new
categories}\label{step-4-create-new-categories}

To add a new category, create a class that implements the
\href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/servlet/taglib/ui/FormNavigatorCategory.html}{\texttt{FormNavigatorCategory}}
interface. The class needs a \texttt{@Component} annotation to register
it as a service in Liferay's module framework. Here are the things your
category class's component annotation should do:

\begin{itemize}
\tightlist
\item
  Declare that the component is of service type
  \texttt{FormNavigatorCategory.class}
\item
  Request immediate loading
\item
  Optionally, specify the category's entry order relative to the Form
  Navigator's other categories. The higher the category's order integer
  relative to the order of the other categories, the higher the category
  is listed in the form navigation.
\end{itemize}

Here's an example component annotation for a category:

\begin{verbatim}
@Component(
    immediate = true,
    property = {"form.navigator.category.order:Integer=20"},
    service = FormNavigatorCategory.class
)
\end{verbatim}

Next, you implement the
\href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/servlet/taglib/ui/FormNavigatorCategory.html}{\texttt{FormNavigatorCategory}}
methods:

\begin{itemize}
\tightlist
\item
  \texttt{getFormNavigatorId}: Return the Form Navigator's constant you
  noted previously from
  \href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/servlet/taglib/ui/FormNavigatorConstants.html}{\texttt{FormNavigatorConstants}}
\item
  \texttt{getKey}: Return an identifier for your category. You can
  optionally create a public class like
  \href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/servlet/taglib/ui/FormNavigatorConstants.html}{\texttt{FormNavigatorConstants}},
  to publish your project's identifiers.
\item
  \texttt{getLabel(Locale)}: Return the localized category label. You
  can create a \texttt{Language.properties} file in your project's
  \texttt{src/main/resources/content} folder and specify a key/value
  pair for the category label. You can then add the localized value of
  the property in language properties files for other locales.
\end{itemize}

For example, here's a Form Navigator category implementation for the
\emph{Social} Portal Setting category:

\begin{verbatim}
package com.liferay.portal.settings.web.internal.servlet.taglib.ui;

import com.liferay.portal.kernel.language.LanguageUtil;
import com.liferay.portal.kernel.servlet.taglib.ui.FormNavigatorCategory;
import com.liferay.portal.kernel.servlet.taglib.ui.FormNavigatorConstants;

import java.util.Locale;

import org.osgi.service.component.annotations.Component;

/**
 * @author Sergio González
 * @author Philip Jones
 */
@Component(
    immediate = true, property = {"form.navigator.category.order:Integer=20"},
    service = FormNavigatorCategory.class
)
public class CompanySettingsSocialFormNavigatorCategory
    implements FormNavigatorCategory {

    @Override
    public String getFormNavigatorId() {
        return FormNavigatorConstants.FORM_NAVIGATOR_ID_COMPANY_SETTINGS;
    }

    @Override
    public String getKey() {
        return FormNavigatorConstants.CATEGORY_KEY_COMPANY_SETTINGS_SOCIAL;
    }

    @Override
    public String getLabel(Locale locale) {
        return LanguageUtil.get(locale, "social");
    }

}
\end{verbatim}

After you've implemented new Form Navigator categories, you can add new
Form Navigator sections.

\subsubsection{Step 5: Create new
sections}\label{step-5-create-new-sections}

To add a new section (entry) that uses a JSP, create a class that
extends the abstract base class
\href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/servlet/taglib/ui/BaseJSPFormNavigatorEntry.html}{\texttt{BaseJSPFormNavigatorEntry}}
and implements the
\href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/servlet/taglib/ui/FormNavigatorEntry.html}{\texttt{FormNavigatorEntry}}
interface. The \texttt{BaseJSPFormNavigatorEntry} base class integrates
the section's JSP with the Form Navigator. In both these parts of your
class declaration, you must specify the Form Navigator's model bean
class as the generic type on which they operate. For example, if your
Form Navigator's model bean class is \texttt{User}, your decarlation
would be like this:

\begin{verbatim}
public class MyEntry extends BaseJSPFormNavigatorEntry<User>
        implements FormNavigatorEntry<User>
\end{verbatim}

There are a couple different ways to determine the model bean class. If
you can access the Form Navigator's JSP source code, inspect the
\href{@platform-ref@/7.0-latest/taglibs/util-taglib/liferay-ui/form-navigator.html}{\texttt{form-navigator}}
element's \texttt{formModelBean} attribute value. The model bean class
is the class type of the object passed in as the
\texttt{form-navigator}'s \texttt{formModelBean} attribute.

You can also deduce the model bean class from the name of the ID's
constant in
\href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/servlet/taglib/ui/FormNavigatorConstants.html}{\texttt{FormNavigatorConstants}}.
The word(s) right after \texttt{FORM\_NAVIGATOR\_ID\_} in the constant's
name hints at the class type. For example, if the navigator's ID is
\texttt{FORM\_NAVIGATOR\_ID\_USERS\_SETTINGS}, then \texttt{User} is the
model bean class; if the ID is
\texttt{FORM\_NAVIGATOR\_ID\_ORGANIZATIONS}, then \texttt{Organization}
is the class; etc. Note: this is only a hint, and there are exceptions.
For example, if the ID is is \texttt{FORM\_NAVIGATOR\_ID\_SITES}, then
\texttt{Group} is the class.

For example, here's a class declaration of a
\texttt{FormNavigatorEntry}, from the Form Nav Extension portlet:

\begin{verbatim}
    @Component(
        immediate = true,
        property = {
            "form.navigator.entry.order:Integer=71"
        },
        service = FormNavigatorEntry.class
    )
    public class MyAppCompanySettingsFormNavigatorEntry 
        extends BaseJSPFormNavigatorEntry<Company>
            implements FormNavigatorEntry<Company> {

            // ...

    }
\end{verbatim}

It implements an entry on the \texttt{Company} model bean for the Portal
Settings Form Navigator: the navigator identifed by the constant
\texttt{FormNavigatorConstants.FORM\_NAVIGATOR\_ID\_COMPANY\_SETTINGS}.

The class also includes the \texttt{@Component} annotation, which is the
next thing an entry must specify. An entry's \texttt{@Component}
annotation registers the entry as a service in Liferay's module
framework.

Here's what a Form Navigation entry's component annotation should do:

\begin{itemize}
\tightlist
\item
  Declare that the component is of service type
  \texttt{FormNavigatorEntry.class}
\item
  Request immediate loading
\item
  Optionally, specify a \texttt{form.navigator.entry.order} property for
  the entry relative to the other entries in the category. The higher
  the entry's order integer relative to the order of the category's
  other entries, the higher the entry is listed in the category. For
  example,
  \texttt{@Component(property\ =\ \ \ \ \ \ \{"form.navigator.entry.order:Integer=71"\},\ service\ =\ \ \ \ \ \ FormNavigatorEntry.class)}
\end{itemize}

Except for your entry's order (optional), your entry's
\texttt{@Component} annotation should look similar to the previous
example's annotation. Next, you'll implement the entry class's methods.

The
\href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/servlet/taglib/ui/FormNavigatorEntry.html}{\texttt{FormNavigatorEntry}}
implementation must implement the following methods:

\begin{itemize}
\item
  \texttt{getFormNavigatorId}: Return the Form Navigator's constant you
  noted previously from
  \href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/servlet/taglib/ui/FormNavigatorConstants.html}{\texttt{FormNavigatorConstants}}
\item
  \texttt{getCategoryKey}: Return the Form Navigator category constant
  you noted previously from
  \href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/servlet/taglib/ui/FormNavigatorConstants.html}{\texttt{FormNavigatorConstants}}
\item
  \texttt{getKey}: Return an identifier for your entry. You can
  optionally create a public class like
  \href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/servlet/taglib/ui/FormNavigatorConstants.html}{\texttt{FormNavigatorConstants}},
  to publish your project's identifiers.
\item
  \texttt{getLabel(Locale)}: Return the entry's localized label. You can
  create a \texttt{Language.properties} file in your project's
  \texttt{src/main/resources/content} folder and specify a key/value
  pair for the entry label.
\item
  \texttt{getJspPath}: Return the path to the entry's JSP, starting from
  the path you specified previously for your \texttt{bnd.bnd} file's
  \texttt{META-INF/resources} property.
\item
  \texttt{include(HttpServletRequest,\ HttpServletResponse)}: Sets the
  request and response attributes for displaying the entry's HTML. You
  can retrieve the form's current settings and pass them to the request.
  You can optionally use a template (e.g., FreeMarker or Velocity) to
  render the form page, as long as you completely override
  \texttt{BaseJSPFormNavigatorEntry}'s \texttt{include} method. The Form
  Nav Extension portlet's entry class's \texttt{include} method passes
  to the request the current settings that were saved as portlet
  preferences. It doesn't use a template language and instead calls
  \texttt{BaseJSPFormNavigatorEntry}'s \texttt{include} method.

\begin{verbatim}
@Override
public void include(HttpServletRequest request, HttpServletResponse response)
        throws IOException {

    ThemeDisplay themeDisplay =
        (ThemeDisplay)request.getAttribute(WebKeys.THEME_DISPLAY);

    PortletPreferences companyPortletPreferences =
        PrefsPropsUtil.getPreferences(themeDisplay.getCompanyId(), true);

    boolean companyMyAppFeatureEnabled =
        PrefsParamUtil.getBoolean(
            companyPortletPreferences, request, "myAppFeatureEnabled",
            true);

    request.setAttribute(
        MyAppWebKeys.COMPANY_MY_APP_FEATURE_ENABLED,
        companyMyAppFeatureEnabled);

    super.include(request, response);
}
\end{verbatim}
\item
  \texttt{setServletContext(ServletContext)}: In this method, you set
  the parent entry class's servlet context. Then, using a
  \texttt{@Reference} annotation, you unbind the servlet context from
  its current target and target it to your app's OSGi bundle. First, add
  the \texttt{@Reference} annotation. Next, unbind the servlet context
  by specifying \texttt{unbind\ =\ "-"}. Finally, to target the servlet
  context to your app's OSGi bundle, specify as the target value the
  bundle's symbolic name--it's the value you specified for
  \texttt{Bundle-SymbolicName} in your \texttt{bnd.bnd} file.

  For example, here's the \texttt{setServletContext(ServletContext)}
  method from the Form Nav Extension portlet's entry class:

\begin{verbatim}
@Override
@Reference(
    target = "(osgi.web.symbolicname=com.liferay.docs.formnavextensionportlet)",
    unbind = "-"
)
public void setServletContext(ServletContext servletContext) {
    super.setServletContext(servletContext);
}
\end{verbatim}
\end{itemize}

The above method calls its parent's
\texttt{setServletContext(ServletContext)} method. But look at what its
\texttt{@Reference} annotation does. It unbinds the servlet context from
its current binding and instead targets it to its own bundle--it targets
the bundle symbolically named
\texttt{com.liferay.docs.formnavextensionportlet}. That is the exact
symbolic name defined by
\texttt{Bundle-SymbolicName:\ com.liferay.docs.formnavextensionportlet}
in the Form Nav Extension portlet's \texttt{bnd.bnd} file.

You've learned what's required to create a section class. You declared
your class to extend the \texttt{BaseJSPFormNavigatorEntry} class and
implement the \texttt{FormNavigatorEntry} interface, both with respect
to your Form Navigator's form model bean class. Using annotations, you
registered your entry class as an OSGi service. Then you implemented all
the entry methods to relate your entry to a Form Navigator, category,
and JSP, populate your entry's request object, and target the servlet
context to your bundle.

If you're curious about what a working entry implementation looks like,
check out the example entry class next.

\subsection{Example Form Navigator Entry
Class}\label{example-form-navigator-entry-class}

Inspecting an example implementation can help you work out details in
your implementation. Here's the Form Nav Extension portlet's entry class
\texttt{MyAppCompanySettingsFormNavigatorEntry}:

\begin{verbatim}
    package com.liferay.docs.formnavextensionportlet;                                      

    import java.io.IOException;
    import java.util.Locale;
    import java.util.ResourceBundle;

    import javax.portlet.PortletPreferences;
    import javax.servlet.ServletContext;
    import javax.servlet.http.HttpServletRequest;
    import javax.servlet.http.HttpServletResponse;

    import org.osgi.service.component.annotations.Component;
    import org.osgi.service.component.annotations.Reference;

    import com.liferay.portal.kernel.servlet.taglib.ui.BaseJSPFormNavigatorEntry;
    import com.liferay.portal.kernel.servlet.taglib.ui.FormNavigatorConstants;
    import com.liferay.portal.kernel.servlet.taglib.ui.FormNavigatorEntry;
    import com.liferay.portal.kernel.util.PrefsParamUtil;
    import com.liferay.portal.kernel.util.PrefsPropsUtil;
    import com.liferay.portal.kernel.util.ResourceBundleUtil;
    import com.liferay.portal.kernel.util.WebKeys;
    import com.liferay.portal.model.Company;
    import com.liferay.portal.theme.ThemeDisplay;

    @Component(
        immediate = true,
        property = {
            "form.navigator.entry.order:Integer=71"
        },
        service = FormNavigatorEntry.class
    )
    public class MyAppCompanySettingsFormNavigatorEntry 
        extends BaseJSPFormNavigatorEntry<Company>
            implements FormNavigatorEntry<Company> {

        @Override
        public String getCategoryKey() {
            return FormNavigatorConstants.CATEGORY_KEY_COMPANY_SETTINGS_MISCELLANEOUS;
        }

        @Override
        public String getFormNavigatorId() {
            return FormNavigatorConstants.FORM_NAVIGATOR_ID_COMPANY_SETTINGS;
        }

        @Override
        protected String getJspPath() {
            return "/portal_settings/my_app.jsp";
        }

        @Override
        public String getKey() {
            return "my-app";
        }

        @Override
        public String getLabel(Locale locale) {
            ResourceBundle resourceBundle = ResourceBundleUtil.getBundle(
                "content.Language", locale, getClass());

            return resourceBundle.getString("my-app");
        }

        @Override
        public void include(HttpServletRequest request, HttpServletResponse response)
                throws IOException {

            ThemeDisplay themeDisplay =
                (ThemeDisplay)request.getAttribute(WebKeys.THEME_DISPLAY);

            PortletPreferences companyPortletPreferences =
                PrefsPropsUtil.getPreferences(themeDisplay.getCompanyId(), true);

            boolean companyMyAppFeatureEnabled =
                PrefsParamUtil.getBoolean(
                    companyPortletPreferences, request, "myAppFeatureEnabled",
                    true);

            request.setAttribute(
                MyAppWebKeys.COMPANY_MY_APP_FEATURE_ENABLED,
                companyMyAppFeatureEnabled);

            super.include(request, response);
        }

        @Override
        @Reference(
            target = "(osgi.web.symbolicname=com.liferay.docs.formnavextensionportlet)",
            unbind = "-"
        )
        public void setServletContext(ServletContext servletContext) {
            super.setServletContext(servletContext);
        }

    }
\end{verbatim}

The above class is declared an OSGi component that provides a
\texttt{FormNavigatorEntry.class} service. Since the entry adds a JSP to
Portal Settings, the class extends \texttt{BaseJSPFormNavigatorEntry}
and implements \texttt{FormNavigatorEntry} on the \texttt{Company} model
bean class. The class specifies that the entry belongs to the
\emph{Miscellaneous} portal settings category, by returning navigator
key
\texttt{FormNavigatorConstants.FORM\_NAVIGATOR\_ID\_COMPANY\_SETTINGS}
from method \texttt{getFormNavigatorId} and category key
\texttt{FormNavigatorConstants.CATEGORY\_KEY\_COMPANY\_SETTINGS\_MISCELLANEOUS}
from method \texttt{getCategoryKey}. The entry's method \texttt{getKey}
returns \emph{my-app} as its own key and method \texttt{getJspPath} maps
the class to the entry's JSP by returning its JSP file path
\texttt{/portal\_settings/my\_app.jsp}.

The entry's \texttt{include} method retrieves a boolean portlet
preference variable \texttt{myAppFeatureEnabled} that specifies whether
My App's feature is enabled for the portal. It then sets the
preference's value as an attribute on the request. The Form Nav
Portlet's language keys for the entry's name, input screen title, and
input label are defined in its
\texttt{src/main/content/Language.properties} file. The method
\texttt{getLabel(Locale)} uses language key \texttt{my-app} to return
the entry's localized label. In summary, the
\texttt{MyAppCompanySettingsFormNavigatorEntry} class meets all of the
Form Navigation framework's section entry requirements.

There you have it! You learned all the parts of the Form Navigator
framework and worked through all the steps to implement new categories
and sections. To recap, you prepared your project's \texttt{bnd.bnd}
file to support form navigator extension, created JSPs for your new form
sections, identified the targeted form navigator and categories, created
new categories, and created new entry implementations. You did it all!
You now know what it takes to extend Liferay Form Navigators.

\subsection{Related Topics}\label{related-topics-178}

\href{/docs/7-0/tutorials/-/knowledge_base/t/portlets}{Portlets}

\href{/docs/7-0/tutorials/-/knowledge_base/t/service-builder}{Service
Builder}

\section{Creating Form Navigator
Contexts}\label{creating-form-navigator-contexts}

Form Navigator System Settings let you specify what categories and
sections are visible in your forms. You can learn how to set Form
Navigator System Settings in
\href{/docs/7-0/user/-/knowledge_base/u/configuring-form-navigator-forms}{Configuring
Form Navigator Forms}. Form Navigator configurations let you specify an
optional context which defines the circumstances for which the
configuration is applied. The following Form Navigator contexts are
available by default:

\begin{itemize}
\item
  \texttt{add}: Denotes that the form is viewed when new content is
  being created. For example, you could use the \texttt{add} context to
  specify the visible form sections when someone creates a new site.
\item
  \texttt{update}: Denotes that the form is viewed when content is being
  edited. For example, you could use the \texttt{update} context to
  specify the visible form sections when someone edits a site.
\end{itemize}

Although the default contexts cover most use cases, you may want to
provide additional contexts for users. For example, you may want a
custom configuration for a form when it's viewed by an administrator.
This tutorial covers how to create additional contexts for Form
Navigators.

Your first step is to manage the dependencies.

\subsection{Adding the Form Navigator
Dependency}\label{adding-the-form-navigator-dependency}

Open your module's \texttt{build.gradle} file and add the following
dependency:

\begin{verbatim}
dependencies {
    compileOnly group: "com.liferay.portal", name: 
    "com.liferay.frontend.taglib.form.navigator", version: "1.0.2"
}
\end{verbatim}

Now that you have the Form Navigator taglib dependency added, you can
create the component class.

\subsection{Implementing the Context Provider
Class}\label{implementing-the-context-provider-class}

Follow these steps to create a Form Navigator Context:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a component class that implements the
  \texttt{FormNavigatorContextProvider} service:

\begin{verbatim}
@Component(
    service = FormNavigatorContextProvider.class
)
\end{verbatim}
\item
  Set the \texttt{FormNavigatorContextConstants.FORM\_NAVIGATOR\_ID}
  property to the form associated with the context. The example
  configuration below specifies the Users form, using a constant
  provided by the
  \href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/servlet/taglib/ui/FormNavigatorConstants.html}{\texttt{com.liferay.portal.kernel.servlet.taglib.ui.FormNavigatorConstants}
  class}:

\begin{verbatim}
@Component(
    property = FormNavigatorContextConstants.FORM_NAVIGATOR_ID + "=" + 
  FormNavigatorConstants.FORM_NAVIGATOR_ID_USERS,
    service = FormNavigatorContextProvider.class
)
\end{verbatim}
\item
  Implement the
  \href{https://github.com/liferay/liferay-portal/blob/7.0.x/modules/apps/foundation/frontend-taglib/frontend-taglib-form-navigator/src/main/java/com/liferay/frontend/taglib/form/navigator/context/FormNavigatorContextProvider.java}{\texttt{FormNavigatorContextProvider}
  interface}, specifying the Form Navigator's model bean class as a
  generic type. The example below sets the Users form's \texttt{User}
  model bean class as the generic type:

\begin{verbatim}
public class UsersFormNavigatorContextProvider
    implements FormNavigatorContextProvider<User> {
    ...
  }
\end{verbatim}

  You can determine the model bean class from the name of the ID's
  constant in
  \href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/servlet/taglib/ui/FormNavigatorConstants.html}{\texttt{FormNavigatorConstants}}.
  The word(s) right after \texttt{FORM\_NAVIGATOR\_ID\_} in the
  constant's name hints at the class type. If you can access the Form
  Navigator's JSP source code, you can find the model bean from the
  \texttt{form-navigator} tag's \texttt{formModelBean} attribute value.
  You can locate the constant in the
  \href{https://github.com/liferay/liferay-portal}{Liferay Portal
  repository} using the following pattern:
  \texttt{id="\textless{}\%=\ FormNavigatorConstants.{[}CONSTANT{]}}.

  For example, if the form navigator's ID is
  \texttt{FORM\_NAVIGATOR\_ID\_USERS}, then you would search for
  \texttt{id="\textless{}\%=\ FormNavigatorConstants.FORM\_NAVIGATOR\_ID\_USERS};
  Make sure that the \texttt{form-navigator} tag's
  \texttt{formModelBean} attribute's value isn't a reference to another
  class. For example, the web content form navigator's
  \texttt{formModelBean} attribute value is \texttt{article}, but upon
  further inspection, it's clear that \texttt{article} is a
  \href{https://github.com/liferay/liferay-portal/blob/7.0.x/modules/apps/web-experience/journal/journal-web/src/main/resources/META-INF/resources/edit_article.jsp\#L29}{reference
  variable} to the true model bean class: \texttt{JournalArticle}.
\item
  Override the \texttt{*ContextProvider}'s \texttt{getContext()} method.
  This method also takes the Form Navigator's model bean class as a
  generic type and defines the logic for the new context. The example
  configuration below creates a new context called \texttt{my.account}
  for the Users form:

\begin{verbatim}
@Override
public String getContext(User selectedUser) {
    if (PortletKeys.MY_ACCOUNT.equals(_getPortletName())) {
        return "my.account";
    }

    if (selectedUser == null) {
        return FormNavigatorContextConstants.CONTEXT_ADD;
    }

    return FormNavigatorContextConstants.CONTEXT_UPDATE;
}
\end{verbatim}

  If you are viewing the Users form from the
  \texttt{com\_liferay\_my\_account\_web\_portlet\_MyAccountPortlet}
  portlet, the \texttt{my.account} context is returned. You also need to
  specify under what circumstances the \texttt{add} and \texttt{update}
  contexts are returned. In the example above, if the user doesn't exist
  (i.e.~you are creating a new user), the \texttt{add} context is
  returned. Otherwise it defaults to the \texttt{update} context (edit
  view).
\end{enumerate}

The new context is ready to use in your Form Navigator configurations.

A full \texttt{*ContextProvider} example class is provided next.

\subsection{Context Provider Example
class}\label{context-provider-example-class}

Below is an example configuration for the
\href{https://github.com/liferay/liferay-portal/blob/7.0.x/modules/apps/foundation/users-admin/users-admin-web/src/main/java/com/liferay/users/admin/web/servlet/taglib/ui/UsersFormNavigatorContextProvider.java}{\texttt{com.liferay.users.admin.web.servlet.taglib.ui.UsersFormNavigatorContextProvider}
class}:

\begin{verbatim}
package com.liferay.users.admin.web.servlet.taglib.ui;

import com.liferay.frontend.taglib.form.navigator.constants.FormNavigatorContextConstants;
import com.liferay.frontend.taglib.form.navigator.context.FormNavigatorContextProvider;
import com.liferay.portal.kernel.model.User;
import com.liferay.portal.kernel.service.ServiceContext;
import com.liferay.portal.kernel.service.ServiceContextThreadLocal;
import com.liferay.portal.kernel.servlet.taglib.ui.FormNavigatorConstants;
import com.liferay.portal.kernel.theme.PortletDisplay;
import com.liferay.portal.kernel.theme.ThemeDisplay;
import com.liferay.portal.kernel.util.PortletKeys;

import org.osgi.service.component.annotations.Component;

/**
 * @author Alejandro Tardín
 */
@Component(
    property = FormNavigatorContextConstants.FORM_NAVIGATOR_ID + "=" + FormNavigatorConstants.FORM_NAVIGATOR_ID_USERS,
    service = FormNavigatorContextProvider.class
)
public class UsersFormNavigatorContextProvider
    implements FormNavigatorContextProvider<User> {

    @Override
    public String getContext(User selectedUser) {
        if (PortletKeys.MY_ACCOUNT.equals(_getPortletName())) {
            return "my.account";
        }

        if (selectedUser == null) {
            return FormNavigatorContextConstants.CONTEXT_ADD;
        }

        return FormNavigatorContextConstants.CONTEXT_UPDATE;
    }

    private String _getPortletName() {
        ServiceContext serviceContext =
            ServiceContextThreadLocal.getServiceContext();

        ThemeDisplay themeDisplay = serviceContext.getThemeDisplay();

        PortletDisplay portletDisplay = themeDisplay.getPortletDisplay();

        return portletDisplay.getPortletName();
    }

}
\end{verbatim}

Now you know how to create a Form Navigator context!

\subsection{Related Topics}\label{related-topics-179}

\href{/docs/7-0/user/-/knowledge_base/u/configuring-form-navigator-forms}{Configuring
Form Navigator Forms}

\href{/docs/7-0/tutorials/-/knowledge_base/t/form-navigator}{Form
Navigator Extensions}

\chapter{Themes and Layout Templates}\label{themes-and-layout-templates}

Do you want to transform the look and feel of your Liferay DXP? Create
your own user interface with a Liferay Theme! Create a layout template
to specify where content can be placed on a page! Define a custom look
and feel for your portlets! All these customizations and more are
possible with Liferay DXP!

In this section of tutorials, you'll learn how to develop themes and
layout templates, customize portlets, and more.

\chapter{Themes}\label{themes-2}

A Liferay Theme is the overall look and feel for a site. Themes are a
combination of CSS, JavaScript, HTML, and FreeMarker templates. Although
the default themes are nice, you may wish to create your own custom look
and feel for your site. Liferay DXP provides several tools and
environments that you can use to create themes:

\begin{itemize}
\tightlist
\item
  \href{/docs/7-0/reference/-/knowledge_base/r/theme-builder-gradle-plugin}{Theme
  Builder Gradle Plugin}
\item
  The
  \href{/docs/7-0/tutorials/-/knowledge_base/t/themes-generator}{Liferay
  Theme Generator}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/creating-themes-with-liferay-ide}{@ide@}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/blade-cli}{Blade CLI}'s
  \href{/docs/7-0/reference/-/knowledge_base/r/theme-template}{Theme
  Template}
\end{itemize}

What if you only wish to make a minor change to the overall look and
feel? Let's say you just want to change a menu animation. Instead of
creating an entire theme for this single modification, you can
\href{/docs/7-0/tutorials/-/knowledge_base/t/themelets}{create a
Themelet}. Themelets are modular, customizable, reusable, shareable
pieces of code that extend a theme. They enable reusable code for
themes. Instead of rewriting the code each time, you can use the same
themelet in each theme.

Liferay has its own set of base themes, called
\href{https://github.com/liferay/liferay-portal/tree/7.0.x/modules/apps/foundation/frontend-theme/frontend-theme-styled}{styled}
and
\href{https://github.com/liferay/liferay-portal/tree/7.0.x/modules/apps/foundation/frontend-theme/frontend-theme-unstyled}{unstyled}
that create the default look and feel you see at first start. The
\emph{styled} theme inherits from the \emph{unstyled} theme, and simply
adds some additional styling on top. These same base themes are used to
create a custom theme. See the
\href{https://github.com/liferay/liferay-portal/tree/1ec7ef30e409de8b53dc8342e8ba7e7540bceef8/modules/apps/foundation/frontend-theme/frontend-theme-user-profile}{User
Profile Theme}, which uses the \emph{styled} theme as its base. Using a
base theme as your foundation, you can then make your customizations to
the theme files. To modify the theme, mirror the folder structure of the
files you wish to change and copy them into your theme. Place the
modified files in the \texttt{src} folder of your theme if using the
Liferay Theme Generator, or copy them into the \texttt{webapp} folder of
your theme if using Liferay @ide@. Build the theme to apply the changes.

Once your theme is developed it is packaged as a WAR (Web application
ARchive) file and can be deployed to the server, either manually or
using build tools. Apply your theme to your pages through the
\href{/docs/7-0/user/-/knowledge_base/u/creating-and-managing-pages\#customizing-the-look-and-feel-of-site-pages}{Look
and Feel menu}. The only limitation is your imagination.

\section{Liferay Theme Generator}\label{liferay-theme-generator}

The Liferay Theme Generator is an easy-to-use command-line wizard that
streamlines the theme creation process. It is independent of the Liferay
Plugins SDK, and generates themes for Liferay Portal 6.2, 7.0, and up.
It is just one of
\href{https://github.com/liferay/liferay-themes-sdk/tree/master/packages}{Liferay
JS Theme Toolkit}. This tutorial focuses on using the Liferay Theme
Generator to create themes. In just a few steps, you'll have a working
Liferay theme.

\noindent\hrulefill

\textbf{Note:} The
\href{https://github.com/liferay/generator-liferay-theme}{Liferay Theme
Generator} is unsupported. The tool is still in development and is not
guaranteed to work on all platforms and environments.

\noindent\hrulefill

This tutorial demonstrates how to:

\begin{itemize}
\item
  \hyperref[installing-the-theme-generator]{Install the Liferay Theme
  Generator}
\item
  \hyperref[running-the-liferay-theme-generator]{Generate a theme}
\end{itemize}

The first step is to install the Liferay Theme Generator.

\subsection{Installing the Theme
Generator}\label{installing-the-theme-generator}

The Liferay Theme Generator has several dependencies. Follow these steps
to install them:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Install \href{http://nodejs.org/}{Node.js}, if it's not already
  installed. We recommend installing
  \href{https://nodejs.org/download/release/v6.6.0/}{v6.6.0}, which is
  the version Liferay Portal 7.0 supports.

  To test your Node.js installation, execute the following command:

\begin{verbatim}
node -v
\end{verbatim}

  The resulting output should look similar to this:

\begin{verbatim}
v4.2.2
\end{verbatim}

  Note: To avoid any potential compatibility issues, we recommend
  installing the Long Term Support (LTS) version of Node.js--at the time
  of this writing, the LTS version is v4.2.2.

  Node Package Manager (npm) is installed along with Node.js.
\item
  Set up your npm environment.

  First, create an \texttt{.npmrc} file in your user's home directory.
  This helps you bypass npm permission-related issues.

  In the \texttt{.npmrc} file, specify a \texttt{prefix} property like
  this one:

\begin{verbatim}
prefix=/Users/[username]/.npm-packages
\end{verbatim}

  Set the \texttt{prefix} value based on your user's home directory. The
  location you specify is where global npm packages are to be installed.

  Next, set the \texttt{NPM\_PACKAGES} system environment variable to
  the \texttt{prefix} value you just specified:

\begin{verbatim}
NPM_PACKAGES=/Users/[username]/.npm-packages (same as prefix value)
\end{verbatim}

  As a last npm configuration, since npm installs Yeoman and gulp
  executables to \texttt{\$\{NPM\_PACKAGES\}/bin} on UNIX and to
  \texttt{\%NPM\_PACKAGES\%} on Windows, make sure to add the
  appropriate directory to your system path. For example, on UNIX you'd
  set this:

\begin{verbatim}
PATH=${PATH}:${NPM_PACKAGES}/bin
\end{verbatim}
\item
  Install \href{http://yeoman.io/}{Yeoman} and
  \href{https://www.npmjs.com/package/gulp}{gulp} globally by executing
  the following command:

\begin{verbatim}
npm install -g yo gulp
\end{verbatim}

  You've completed installing the Liferay Theme Generator's
  dependencies.
\item
  Install the Liferay Theme Generator. 7.x.x versions of the Theme
  Generator create themes for 6.2 and 7.0. 8.x.x versions create themes
  for 7.0 and 7.1. 9.x.x versions create themes for 7.2 and up.

  To create themes for \textbf{6.2} or \textbf{7.0}, run the following
  command:

\begin{verbatim}
npm install -g generator-liferay-theme@7.x.x
\end{verbatim}

  To create themes for \textbf{7.0} or \textbf{7.1} versions of Liferay
  DXP, run this command:

\begin{verbatim}
npm install -g generator-liferay-theme@8.x.x
\end{verbatim}
\end{enumerate}

If you are on Windows, you must do additional setup for generated themes
to use Sass.

\subsubsection{Installing Sass on
Windows}\label{installing-sass-on-windows}

To use Sass on Windows, you must use either Sass from node-sass or Sass
from Ruby. By default, the generator creates theme projects to use
node-sass; but you can reconfigure them to use Ruby based Sass and
Compass. Since node-sass indirectly requires Visual Studio, developers
who are not already using Visual Studio may opt to use Ruby based Sass
and Compass instead of node-sass.

\noindent\hrulefill

\textbf{Note:} If your theme was built with an older version of the
Liferay Theme Generator and specifies the
\texttt{"liferay-theme-deps-7.0":\ "1.0.0"} dependency in its
\texttt{package.json}, \texttt{npm\ install} may fail in Liferay DXP due
to its dependency on node-sass \texttt{v3.13.1}. To fix this issue,
change the dev dependency in your \texttt{package.json} to
\texttt{"liferay-theme-deps-7.0":\ "7.0.0"} and rebuild your theme. We
recommend that you use the latest 7.x.x version of the Theme Generator
and dependencies in your \texttt{package.json} to ensure full
compatibility.

\noindent\hrulefill

This section explains both Sass installations.

\paragraph{Installing Sass from
node-sass}\label{installing-sass-from-node-sass}

By default, the generator uses Sass from node-sass. node-sass requires
node-gyp, which in turn requires Python and Visual Studio. The
\href{https://github.com/nodejs/node-gyp\#installation}{node-gyp
installation instructions} explain how to set up node-gyp, Python, and
Visual Studio. Since Visual Studio is a particularly large dependency,
if you aren't already using Visual Studio you might want to consider
using Ruby Sass instead of node-sass.

\paragraph{Installing Ruby Sass and
Compass}\label{installing-ruby-sass-and-compass}

As an alternative to using Sass from node-sass, you can use Sass from
Ruby. Liferay themes require using Compass along with Ruby based Sass.
In order to install and use Sass and Compass, you must install Ruby via
the \href{http://rubyinstaller.org/}{Ruby installer}.

\noindent\hrulefill

\textbf{Note:} Sass version 3.5 has compatibility issues with Compass.
We recommend that you install Sass version 3.4.0 as shown in the command
below.

\noindent\hrulefill

The following commands install the Sass and Compass gems:

\begin{verbatim}
gem install sass -v "=3.4.0"

gem install compass
\end{verbatim}

After creating a theme project in the next section, you'll learn how to
configure a project to use Ruby based Sass and Compass.

Now that you've installed the Liferay Theme Generator and theme
dependencies, you can generate a theme.

\subsection{Running the Liferay Theme
Generator}\label{running-the-liferay-theme-generator}

When you installed the Liferay Theme Generator, you also installed three
sub-generators with it: a
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-layout-templates-with-the-themes-generator-0}{layout
template creator}, a
\href{/docs/7-0/tutorials/-/knowledge_base/t/themelets}{themelet
creator}, and a
\href{/docs/7-0/tutorials/-/knowledge_base/t/migrating-a-6-2-theme-to-liferay-7}{theme
importer}. For the purposes of this tutorial, the focus will be on the
default Liferay Theme Generator.

\noindent\hrulefill

\textbf{Note}: If you run into permissions issues during theme
generation, make sure you have read/write access to all folders on your
system.

\noindent\hrulefill

From a directory in which you want to create a theme, run the following
command:

\begin{verbatim}
yo liferay-theme
\end{verbatim}

\noindent\hrulefill

\textbf{Note}: Some theme options are deprecated for 7.0 (such as
Velocity theme templates). To view the deprecated options, run the
generator with the \texttt{-\/-deprecated} flag:

\begin{verbatim}
 yo liferay-theme --deprecated
\end{verbatim}

\noindent\hrulefill

The Liferay Theme Generator prompts you for the following things:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Enter a name for your theme.
\item
  Enter a theme ID, or press \emph{enter} to accept the default.
\item
  Select the version of your Liferay instance (e.g., \emph{7.0}).
\item
  Choose a template language. Note that Freemarker is used by default;
  you can only select Velocity if you run the generator with the
  \texttt{-\/-deprecated} flag.

  Based on the inputs up to this point, the default generator starts
  installing additional required software and creating your theme
  project.
\item
  When prompted, enter your app server's path. The information you
  provide is added to the \texttt{liferay-theme.json} in your theme's
  root folder. you can change the path in that file if you change app
  servers.
\item
  Finally, enter your Liferay instance's URL, or press \emph{enter} to
  accept the default \texttt{localhost:8080}.
\end{enumerate}

The generator creates a new theme project in your current directory. The
theme inherits styles from the
\href{https://www.npmjs.com/package/liferay-theme-styled}{liferay-theme-styled}
theme. Note that you can switch to using a different base theme by
executing the
\href{/docs/7-0/reference/-/knowledge_base/r/theme-gulp-tasks}{\texttt{gulp\ extend}}
command.

\noindent\hrulefill

\textbf{Note}: The
\href{https://www.npmjs.com/package/liferay-theme-styled}{liferay-theme-styled}
and
\href{https://www.npmjs.com/package/liferay-theme-unstyled}{liferay-theme-unstyled}
themes are base themes. They're analogous to Java APIs. Liferay's
Classic theme and other themes that use liferay-theme-styled or
liferay-theme-unstyled as a base theme are analogous to API
implementations--they're not meant to be extended. Extending Liferay's
Classic theme is strongly discouraged.

\noindent\hrulefill

\textbf{Important}: By default, your theme is based off of the styled
theme and uses lib-sass/bourbon, instead of Compass. If, however, you
are on Windows and are using the Ruby version of Sass, you must
configure the theme to support Compass. To do so, follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open the \texttt{package.json} file found in the root folder of your
  theme, and locate the \texttt{rubySass} property and change it from
  \texttt{false} to \texttt{true}.

  Now that your theme is set to support Compass, you must install the
  Ruby Sass middleware and save it as a dependency for your theme.
\item
  Run the following command to install the Ruby Sass middleware:

\begin{verbatim}
npm i --save gulp-ruby-sass
\end{verbatim}

  The \texttt{-\/-save} flag adds Ruby Sass to the list of dependencies
  in your theme's \texttt{package.json} file. Your theme is ready to
  use.
\item
  Run the \texttt{gulp\ build} task to generate the base files for your
  theme. Open the \texttt{build} folder of your theme to view the base
  files.
\end{enumerate}

There you have it! You now have a working theme. At the moment, the
theme is a bit bare bones, but you have everything you need to develop
it.

The generated theme's structure differs slightly from a theme created in
the Liferay Plugins SDK. In a theme generated in the Liferay Plugins
SDK, you put changes in a \texttt{\_diffs} folder. In a theme generated
by the Liferay Theme Generator, you put changes in the \texttt{src}
folder.

To develop your theme, copy the build files into your \texttt{src}
folder. For instance to make a change to the \texttt{portal\_normal.ftl}
theme template, you would create a \texttt{templates} folder in your
\texttt{src} folder, and copy the \texttt{portal\_normal.ftl} file from
the \texttt{build/templates} folder into the \texttt{src/templates}
folder. This gives you the base template to build on. It is important
that you mirror the folder structure in order for the changes to be
applied.

Another noticeable difference in the generator created theme is that all
CSS files have been converted to Sass SCSS files. Sassy CSS (SCSS) is
the new main syntax which allows you to use the latest CSS3 styles and
leverage Sass syntax advantages, such as nesting and variables.

To deploy your theme to your configured Liferay DXP instance, execute
this command:

\begin{verbatim}
gulp deploy
\end{verbatim}

You can apply your theme by following the instructions found in the
\href{/docs/7-0/user/-/knowledge_base/u/creating-and-managing-pages\#customizing-the-look-and-feel-of-site-pages}{Creating
and Managing Pages} User Guide.

\noindent\hrulefill

\textbf{Note:} By default theme images are cached by the browser. If you
need to update images in the theme, it is best practice to use
versioning in the image URL. For example,
\texttt{background-image:url("../images/image.jpg?v=1")} . You can then
just update the version each time you update the image, which will
remove the potential for any caching issues.

\noindent\hrulefill

Now that you've created a theme and deployed it, you can use the theme
project's
\href{/docs/7-0/reference/-/knowledge_base/r/theme-gulp-tasks}{gulp
tasks} to further develop and manage your theme. These offer basic
functions, such as \texttt{build} and \texttt{deploy}, as well as more
complex interactions, such as auto deploying when a change is made and
setting the base theme.

There you have it! You're ready to design a terrific theme!

\subsection{Related Topics}\label{related-topics-180}

\href{/docs/7-0/reference/-/knowledge_base/r/theme-gulp-tasks}{Theme
Gulp Tasks}

\href{/docs/7-0/tutorials/-/knowledge_base/t/themelets}{Themelets}

\href{/docs/7-0/tutorials/-/knowledge_base/t/importing-resources-with-a-theme}{Importing
Resources with a Theme}

\section{Themelets}\label{themelets}

Themelets are small, extendable, and reusable pieces of code. Whereas
themes require multiple components, a themelet only requires the files
you wish to extend. This creates a more modular approach to theme
design, that lends itself well to collaboration, and reduces the need
for duplicated code in your theme.

Themelets let developers easily share code snippets across their themes
with other developers. A themelet can consist of CSS and JavaScript.
Themelets \textbf{do not support} theme templates.

Themelets are very flexible, and therefore they have a number of
possible uses. You can make a themelet to modify the appearance of 7.0
admin tools, or a themelet that uses a custom JavaScript component for
responsive embedded videos. For example, take a look at the
\href{https://www.npmjs.com/package/lfr-product-menu-animation-themelet}{Liferay
Product Menu Animation Themelet}. This themelet simply alters the
animation for Liferay's Product Menu.

\begin{figure}
\centering
\includegraphics{./images/product-menu-animation-themelet.png}
\caption{Themelets can be used to modify one aspect of the UI, that you
can then reuse in your other themes.}
\end{figure}

If there is something you find yourself coding over and over again for
themes, it's a good candidate for a themelet.

This tutorial demonstrates how to:

\begin{itemize}
\item
  Create a themelet to extend your theme
\item
  Install a Themelet
\end{itemize}

To create a themelet, you need a theme to extend and the Liferay Theme
Generator and dependencies installed, as explained in the
\href{/docs/7-0/tutorials/-/knowledge_base/t/themes-generator}{Liferay
Theme Generator} tutorial.

\subsection{Creating a Themelet}\label{creating-a-themelet}

Follow these steps to create a themelet:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open the Command Line and navigate to the directory you want to create
  your themelet in.
\item
  Run \texttt{yo\ liferay-theme:themelet} and follow the prompts to
  generate the themelet.

  \begin{figure}
  \centering
  \includegraphics{./images/themelet-prompt.png}
  \caption{The Themelet sub-generator automates the themelet creation
  process, making it quick and easy.}
  \end{figure}
\item
  The generated themelet contains a \texttt{package.json} file with
  configuration information and a \texttt{src/css} folder that contains
  a \texttt{\_custom.scss} file. Just like a theme, add your CSS changes
  to the \texttt{src/css} folder, and add your JavaScript changes to the
  \texttt{src/js} folder.
\item
  To use your themelet, you must install it globally first. This makes
  the themelet visible to the generator. To install your themelet
  globally, navigate into its root folder and run \texttt{npm\ link}.
  Note, you may need to run the command using \texttt{sudo\ npm\ link}.
  This creates a globally-installed symbolic link for the themelet in
  your npm packages folder. Now your themelet is available to install in
  your themes.
\end{enumerate}

Now that your themelet is developed, you can install it in your theme.

\subsection{Installing a Themelet}\label{installing-a-themelet}

After you've developed your themelet, follow the steps below to install
it into your theme.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Navigate to your theme's root directory and run the following command:

\begin{verbatim}
gulp extend
\end{verbatim}
\item
  Choose \emph{Themelet} as the theme asset to extend.
\item
  Select \emph{Search globally installed npm modules}.

  \begin{figure}
  \centering
  \includegraphics{./images/install-themelet.png}
  \caption{You can extend your theme using globally installed npm
  modules or published npm modules.}
  \end{figure}
\item
  Highlight your themelet, press spacebar to activate it, and press
  \emph{Enter} to install it.
\item
  Run \texttt{gulp\ deploy} to build and deploy your theme with the new
  themelet updates.
\end{enumerate}

Your themelet is installed! As you can see, themelets are a handy tool
to add to your theme development bag o' tricks.

\subsection{Related Topics}\label{related-topics-181}

\href{/docs/7-0/tutorials/-/knowledge_base/t/importing-resources-with-a-theme}{Importing
Resources with Your Themes}

\href{/docs/7-0/tutorials/-/knowledge_base/t/themes-generator}{Liferay
Theme Generator}

\section{Importing Resources with a
Theme}\label{importing-resources-with-a-theme}

A theme without content is like an empty house. If you're trying to sell
an empty house, it may be difficult for prospective buyers to see its
full beauty. However, staging the house with some furniture and
decorations helps prospective buyers imagine what the house might look
like with their belongings. Liferay's resources importer module is a
tool that allows a theme developer to have files and web content
automatically imported into Liferay DXP when a theme is deployed.
Usually, the resources are imported into a site template but they can
also be imported directly into a site. Liferay Administrators can use
the site or site template created by the resources importer to showcase
the theme. This is a great way for theme developers to provide a sample
context that optimizes the design of their theme. In fact, all
standalone themes that are uploaded to Liferay Marketplace must use the
resources importer. This ensures a uniform experience for Marketplace
users: a user can download a theme from Marketplace, install it on
Liferay DXP, go to Sites or Site Templates in the Control Panel and
immediately see their new theme in action. In this tutorial, we explain
how to include resources with your theme.

\noindent\hrulefill

\textbf{Note:} The resources importer has undergone some changes that
affect the properties, class names, and structures that were referred to
in versions prior to 7.0. Please read through the steps below to see the
updates. In previous versions of Liferay, you had to deploy the
resources importer if you declared it as a dependency in your theme's
\texttt{liferay-plugin-package.properties} file. In 7.0 and up, this is
no longer a requirement. The resources importer is now an OSGi module,
and is deployed to your instance by default.

\noindent\hrulefill

When you create a new theme using the Liferay Theme Generator, check
your theme's \texttt{src/WEB-INF/liferay-plugin-package.properties} file
for the developer mode entry:

\begin{verbatim}
resources-importer-developer-mode-enabled=true
\end{verbatim}

This is a convenience feature for theme developers. With this setting
enabled, importing resources to a site or site template that already
exists, recreates the site or site template. Importing resources into a
site template reapplies the site template and its resources to the sites
that are based on the site template. Without
\texttt{resources-importer-developer-mode-enabled=true}, you have to
manually delete the sites or site templates built by the resources
importer, each time you want to apply changes from your theme's
\texttt{src/WEB-INF/src/resources-importer} folder.

\noindent\hrulefill

\textbf{Warning:} the
\texttt{resources-importer-developer-mode-enabled=true} setting can be
dangerous since it involves \emph{deleting} (and re-creating) the
affected site or site template. It's only intended to be used during
development. Never use it in production.

\noindent\hrulefill

If you'd like to import your theme's resources directly into a site,
instead of into a site template, you can specify the following in your
\texttt{liferay-plugin-package.properties} file:

\begin{verbatim}
resources-importer-target-class-name=com.liferay.portal.kernel.model.Group

resources-importer-target-value=[site-name]
\end{verbatim}

If you're using the
\texttt{resources-importer-target-value={[}site-name{]}} property,
double check the site name that you're specifying. If you specify the
wrong value, you could end up deleting (and re-creating) the wrong site!

\noindent\hrulefill

\textbf{Warning:} It's safer to import theme resources into a site
template than into an actual site. The
\texttt{resources-importer-target-class-name=com.liferay.portal.kernel.model.Group}
setting can be handy for development and testing but should be used
cautiously. Don't use this setting in a theme that will be deployed to a
production Liferay instance or a theme that will be submitted to Liferay
Marketplace. To prepare a theme for deployment to a production Liferay
instance, use the default setting so that the resources are imported
into a site template. You can do this explicitly by setting
\texttt{resources-importer-target-class-name=com.liferay.portal.kernel.model.LayoutSetPrototype}
or implicitly by commenting out or removing the
\texttt{resources-importer-target-class-name} property.

\noindent\hrulefill

All of the resources a theme uses with the resources importer go in the
\texttt{{[}theme-name{]}/src/WEB-INF/src/resources-importer} folder. The
assets to be imported by your theme should be placed in the following
directory structure:

\begin{itemize}
\tightlist
\item
  \texttt{{[}theme-name{]}/src/WEB-INF/src/resources-importer/}

  \begin{itemize}
  \tightlist
  \item
    \texttt{sitemap.json} - defines the pages, layout templates, and
    portlets
  \item
    \texttt{assets.json} - (optional) specifies details on the assets
  \item
    \texttt{document\_library/}

    \begin{itemize}
    \tightlist
    \item
      \texttt{documents/} - contains documents and media files
    \end{itemize}
  \item
    \texttt{journal/}

    \begin{itemize}
    \tightlist
    \item
      \texttt{articles/} - contains web content (HTML) and folders
      grouping web content articles (XML) by template. Each folder name
      must match the file name of the corresponding template. For
      example, create folder \texttt{Template\ 1/} to hold an article
      based on template file \texttt{Template\ 1.ftl}.
    \item
      \texttt{structures/} - contains structures (JSON) and folders of
      child structures. Each folder name must match the file name of the
      corresponding parent structure. For example, create folder
      \texttt{Structure\ 1/} to hold a child of structure file
      \texttt{Structure\ 1.json}.
    \item
      \texttt{templates/} - groups templates (VM or FTL) into folders by
      structure. Each folder name must match the file name of the
      corresponding structure. For example, create folder
      \texttt{Structure\ 1/} to hold a template for structure file
      \texttt{Structure\ 1.json}.
    \end{itemize}
  \end{itemize}
\end{itemize}

The following is the XML file for a basic web content article:

\begin{verbatim}
<?xml version="1.0"?>

<root available-locales="en_US" default-locale="en_US">
    <dynamic-element name="content" type="text_area" index-type="keyword" index="0">
        <dynamic-content language-id="en_US">
            <![CDATA[
                <center>
                <p><img alt="" src="[$FILE=space-program-history.jpg$]" /></p>
                </center>

                <p>In the mid-20th century, after two of the 
                most violent wars in history, mankind turned 
                its gaze upwards to the stars. Instead of 
                continuing to strive against one another, 
                man choose instead to strive against the 
                limits that we had bound ourselves to. And 
                so the Great Space Race began.</p>

                <p>At first the race was to reach space--get 
                outside the earth's atmosphere, and when 
                that had been reached, we shot for the moon. 
                After sending men to the moon, robots to 
                Mars, and probes beyond the reaches of our 
                solar system, it seemed that there was 
                nowhere left to go.</p>

                <p>The Space Program aims to change that. 
                Beyond national boundaries, beyond what 
                anyone can imagine that we can do. The sky 
                is not the limit.</p>
            ]]>
        </dynamic-content>
    </dynamic-element>
</root>
\end{verbatim}

You can view an article's XML by going to its source.

When you create a new theme using the Liferay Theme Generator, a default
\texttt{sitemap.json} file is created and a default
\texttt{liferay-plugin-package.properties} file is created in the
\texttt{WEB-INF} folder.

You have two options for specifying resources to be imported with your
theme. The recommended approach is to add resource files to the folders
outlined above and to specify the contents of the site or site template
in a \texttt{sitemap.json} file (described below). Alternatively, you
can use an \texttt{archive.lar} file to package the resources you'd like
your theme to deploy. To create such an \texttt{archive.lar}, just
export the contents of a site from Liferay Portal using the site scope.
Then place the \texttt{archive.lar} file in your theme's
\texttt{{[}theme-name{]}/src/WEB-INF/src/resources-importer} folder. If
you choose to use an archive file to package all of your resources, you
won't need a \texttt{sitemap.json} file or any other files in your
\texttt{{[}theme-name{]}/src/WEB-INF/src/resources-importer} folder.
Note, however, a LAR file is version-specific; it won't work on any
version of Liferay other than the one from which it was exported. For
this reason, using a \texttt{sitemap.json} file to specify resources is
the most flexible approach. If you're developing themes for Liferay
Marketplace, you should use the \texttt{sitemap.json} to specify
resources to be imported with your theme.

The \texttt{sitemap.json} in the
\texttt{{[}theme-name{]}/src/WEB-INF/src/resources-importer} folder
specifies the site pages, layout templates, web content, assets, and
portlet configurations provided with the theme. This file describes the
contents and hierarchy of the site for Liferay to import as a site or
site template.

\noindent\hrulefill

\textbf{Note:} Site templates only support the importing of either
public page sets or private page sets.

If you want to import both public and private page sets, as shown in the
example \texttt{sitemap.json} below, you must import your resources into
a site.

\noindent\hrulefill

Even if you're not familiar with JSON, the \texttt{sitemap.json} file is
easy to understand. Let's examine a sample \texttt{sitemap.json} file:

\begin{verbatim}
{
"layoutTemplateId": "2_columns_ii",
"privatePages": [
    {
        "friendlyURL": "/private-page",
    "name": "Private Page",
    "title": "Private Page"
    }
],
"publicPages": [
        {
            "columns": [
                [
                    {
                        "portletId": "com_liferay_login_web_portlet_LoginPortlet"
                    },
                    {
                        "portletId": "com_liferay_site_navigation_menu_web_portlet_SiteNavigationMenuPortlet"
                    },
                    {
                        "portletId": "com_liferay_journal_content_web_portlet_JournalContentPortlet",
                        "portletPreferences": {
                            "articleId": "Without Border.html",
                            "groupId": "${groupId}",
                            "portletSetupPortletDecoratorId": "borderless"
                        }
                    },
                    {
                        "portletId": "com_liferay_journal_content_web_portlet_JournalContentPortlet",
                        "portletPreferences": {
                            "articleId": "Custom Title.html",
                            "groupId": "${groupId}",
                            "portletSetupPortletDecoratorId": "decorate",
                            "portletSetupTitle_en_US": "Web Content Display with Custom Title",
                            "portletSetupUseCustomTitle": "true"
                        }
                    }
                ],
                [
                    {
                        "portletId": "com_liferay_hello_world_web_portlet_HelloWorldPortlet"
                    },
                    {
                        "portletId": "com_liferay_site_navigation_menu_web_portlet_SiteNavigationMenuPortlet_INSTANCE_${groupId}",
                        "portletPreferences": {
                            "displayStyle": "[custom]",
                            "headerType": "root-layout",
                            "includedLayouts": "all",
                            "nestedChildren": "1",
                            "rootLayoutLevel": "3",
                            "rootLayoutType": "relative"
                        }
                    },
                    "Web Content with Image.html",
                    {
                        "portletId": "com_liferay_nested_portlets_web_portlet_NestedPortletsPortlet",
                        "portletPreferences": {
                            "columns": [
                                [
                                    {
                                        "portletId": "com_liferay_journal_content_web_portlet_JournalContentPortlet",
                                        "portletPreferences": {
                                        "articleId": "Child Web Content 1.xml",
                                        "groupId": "${groupId}",
                                        "portletSetupPortletDecoratorId": "decorate",
                                        "portletSetupTitle_en_US": "Web Content Display with Child Structure 1",
                                            "portletSetupUseCustomTitle": "true"
                                        }
                                    }
                                ],
                                [
                                    {
                                        "portletId": "com_liferay_journal_content_web_portlet_JournalContentPortlet",
                                        "portletPreferences": {
                                        "articleId": "Child Web Content 2.xml",
                                        "groupId": "${groupId}",
                                        "portletSetupPortletDecoratorId": "decorate",
                                        "portletSetupTitle_en_US": "Web Content Display with Child Structure 2",
                                            "portletSetupUseCustomTitle": "true"
                                        }
                                    }
                                ]
                            ],
                            "layoutTemplateId": "2_columns_i"
                        }
                    }
                ]
            ],
            "friendlyURL": "/home",
            "nameMap": {
                "en_US": "Welcome",
                "fr_FR": "Bienvenue"
            },
            "title": "Welcome"
        },
        {
            "columns": [
                [
                    {
                        "portletId": "com_liferay_login_web_portlet_LoginPortlet"
                    }
                ],
                [
                    {
                        "portletId": "com_liferay_hello_world_web_portlet_HelloWorldPortlet"
                    }
                ]
            ],
            "friendlyURL": "/layout-prototypes-parent-page", "layouts": [
                {
                    "friendlyURL": "/layout-prototypes-page-1",
                    "layoutPrototypeLinkEnabled": "true",
                    "layoutPrototypeUuid": "371647ba-3649-4039-bfe6-ae32cf404737",
                    "name": "Layout Prototypes Page 1",
                    "title": "Layout Prototypes Page 1"
                },
                {
                    "friendlyURL": "/layout-prototypes-page-2",
                    "layoutPrototypeUuid": "c98067d0-fc10-9556-7364-238d39693bc4",
                    "name": "Layout Prototypes Page 2",
                    "title": "Layout Prototypes Page 2"
                }
            ],
            "name": "Layout Prototypes",
            "title": "Layout Prototypes"
        },
        {
            "columns": [
                [
                    {
                        "portletId": "com_liferay_login_web_portlet_LoginPortlet"
                    }
                ],
                [
                    {
                        "portletId": "com_liferay_hello_world_web_portlet_HelloWorldPortlet"
                    }
                ]
            ],
            "friendlyURL": "/parent-page",
            "layouts": [
                {
                    "friendlyURL": "/child-page-1",
                    "name": "Child Page 1",
                    "title": "Child Page 1"
                },
                {
                    "friendlyURL": "/child-page-2",
                    "name": "Child Page 2",
                    "title": "Child Page 2"
                }
            ],
            "name": "Parent Page",
            "title": "Parent Page"
        },
        {
            "friendlyURL": "/url-page",
            "name": "URL Page",
            "title": "URL Page",
            "type": "url"
        },
        {
            "friendlyURL": "/link-page",
            "name": "Link to another Page",
            "title": "Link to another Page",
            "type": "link_to_layout",
            "typeSettings": "linkToLayoutId=1"
        },
        {
            "friendlyURL": "/hidden-page",
            "name": "Hidden Page",
            "title": "Hidden Page",
            "hidden": "true"
        }
    ]
}
\end{verbatim}

The first thing you should declare in your \texttt{sitemap.json} file is
a default layout template ID so the target site or site template can
reference the layout template to use for its pages. You can also specify
different layout templates to use for individual pages. You can find
layout templates in your Liferay installation's \texttt{/layouttpl}
folder. Next, you have to declare the layouts, or pages, that your site
template should use. Note that pages are called \emph{layouts} in
Liferay DXP's code. You can specify a name, title, and friendly URL for
a page, and you can set a page to be hidden. To declare that web content
should be displayed on a page, simply specify an XML file. You can
declare portlets by specifying their portlet IDs, which can be found in
the App Manager of the Control Panel. Select the suite that the App is
located in, click the App, click the App web link, and open the
\emph{Portlets} tab that appears. The portlet ID is displayed below the
name of the App. You can find a full list of the default portlet IDs for
Liferay in the
\href{/docs/7-1/reference/-/knowledge_base/r/fully-qualified-portlet-ids}{Portlet
ID quick reference}. You can also specify portlet preferences for each
portlet.

The following properties are available in the \texttt{sitemap.json}:

\textbf{colorSchemeId:} Specifies a different color scheme (by ID) than
the default color scheme to use for the layout.

\textbf{columns:} Specifies the column contents for the layout.

\textbf{friendlyURL:} Sets the layout's friendly URL.

\textbf{hidden:} Sets whether the layout is hidden.

\textbf{layoutCss:} Sets custom CSS for the layout to load after the
theme.

\textbf{layoutPrototypeLinkEnabled:} Sets whether the layout inherits
changes made to the page template (if the layout has one).

\textbf{layoutPrototypeName:} Specifies the page template (by name) to
use for the layout. If this is defined, the page template's UUID is
retrieved using the name, and \texttt{layoutPrototypeUuid} is not
required.

\textbf{layoutPrototypeUuid:} Specifies the page template (by UUID) to
use for the layout. If \texttt{layoutPrototypeName} is defined, this is
not required.

\textbf{layoutTemplateId:} When defined outside the scope of a portlet,
sets the default layout template for the theme's layouts. When placed
inside a layout, sets the layout template for the layout.

\textbf{layouts:} Specifies child pages for a layout set
(\texttt{publicPages} \textbar\textbar{} \texttt{privatePages}).

\textbf{name:} The layout's name.

\textbf{nameMap:} Passes a name object with multiple name key/value
pairs. As shown in the example sitemap above, you can use this to pass
language keys for layout names.

\textbf{portletPreferences:} Specifies the portlet's preferences. See
note below for more information.

\textbf{portletSetupPortletDecoratorId:} Specifies the portlet decorator
to use for the portlet (\texttt{borderless} \textbar\textbar{}
\texttt{barebone} \textbar\textbar{} \texttt{decorate}). See the
\href{/docs/7-0/tutorials/-/knowledge_base/t/portlet-decorators}{Portlet
Decorators} tutorial for more info.

\textbf{portlets:} specifies the portlets to display in the layout's
column. To nest portlets, recursively use columns as shown in the
example \texttt{sitemap.json} above for the
\texttt{com\_liferay\_nested\_portlets\_web\_portlet\_NestedPortletsPortlet}
portlet.

\textbf{privatePages:} Specifies private layouts.

\textbf{publicPages:} Specifies public layouts.

\textbf{themeId:} Specifies a different theme (by ID) than the default
theme bundled with the \texttt{sitemap.json} to use for the layout.

\textbf{title:} The layout's title.

\textbf{type:} Sets the layout type. The default value is
\texttt{portlet} (empty page). Possible values are \texttt{copy} (copy
of a page of this site), \texttt{embedded},
\texttt{full\_page\_application}, \texttt{link\_to\_layout},
\texttt{node} (page set), \texttt{panel}, \texttt{portlet}, and
\texttt{url} (link to URL).

\textbf{typeSettings:} Specifies settings (using key/value pairs) for
the layout \texttt{type}.

\noindent\hrulefill

\textbf{Note:} Portlet preferences set in \texttt{sitemap.json} are
saved in the database to the column:
\texttt{portletPreferences.preferences}. To determine the proper
key:value pair for a portlet preference, there are a couple approaches
you can take.

You can manually set the portlet preference in Liferay DXP, and then
check the values in this column of the database as a hint for what to
configure in your \texttt{sitemap.json}. For example, you can configure
the Asset Publisher to display assets that match the specified asset
tags, using the following configuration:

\begin{verbatim}
 "queryName0": "assetTags",
 "queryValues0": "MyAssetTagName"
\end{verbatim}

Alternatively, you can search each app in your Liferay DXP bundle for
the keyword \texttt{preferences-\/-}. This returns some of the app's
JSPs that have the portlet preferences defined for the portlet.

You can use a combination of both of these approaches to determine the
key/value pairs for the portlet preferences.

Note that portlet preferences that require an existing configuration,
such as a tag or category, may require you to create the configuration
on the Global site first, so that the Resources Importer finds a match
when deployed with the theme.

\noindent\hrulefill

\noindent\hrulefill

\textbf{Tip:} You can specify an application display template (ADT) for
a portlet in the \texttt{sitemap.json} file by setting the
\texttt{displayStyle} and \texttt{displayStyleGroupId} portlet
preferences. For example:

\begin{verbatim}
 "portletId": "com_liferay_asset_publisher_web_portlet_AssetPublisherPortlet",
     "portletPreferences": {
         "displayStyleGroupId": "10197",
         "displayStyle": "ddmTemplate_6fe4851b-53bc-4ca7-868a-c836982836f4",
 }
\end{verbatim}

To learn more about ADTs, visit the
\href{/docs/7-0/user/-/knowledge_base/u/styling-apps-with-application-display-templates}{Styling
Apps with Application Display Templates} chapter.

\noindent\hrulefill

Optionally, you can create an \texttt{assets.json} file in your
\texttt{{[}theme-name{]}/src/WEB-INF/src/resources-importer} folder.
While the \texttt{sitemap.json} file defines the pages of the site or
site template to be imported, along with the layout templates, portlets,
and portlet preferences of these pages, the \texttt{assets.json} file
specifies details about the assets to be imported. Tags can be applied
to any asset. Abstract summaries and small images can be applied to web
content articles. For example, the following \texttt{assets.json} file
specifies two tags for the \texttt{company\_logo.png} image, one tag for
the \texttt{Custom\ Title.xml} web content article, and an abstract
summary and small image for the \texttt{Child\ Web\ Content\ 1.json}
article structure:

\begin{verbatim}
{
    "assets": [
        {
            "name": "company_logo.png",
            "tags": [
                "logo",
                "company"
            ]
        },
        {
            "name": "Custom Title.xml",
            "tags": [
                "web content"
            ]
        },
        {
            "abstractSummary": "This is an abstract summary.",
            "name": "Child Web Content 1.xml",
            "smallImage": "company_logo.png"
        }
    ]
}
\end{verbatim}

Now that you've learned about the directory structure for your
resources, the \texttt{sitemap.json} file for referencing your
resources, and the \texttt{assets.json} file for describing the assets
of your resources, it's time to put resources into your theme. You can
create resources from scratch and/or bring in resources that you've
already created in Liferay. Let's go over how to leverage your HTML
(basic web content), JSON (structures), or VM or FTL (templates) files
from Liferay:

\noindent\hrulefill

\textbf{Note:} In previous versions of Liferay, basic web content could
be added without the need of a structure or template. In 7.0 and above,
all web content articles require a structure and template.

\noindent\hrulefill

\begin{itemize}
\item
  \textbf{web content:} Edit the article, and copy the content from the
  \emph{Source} view. Create a folder for the article under
  \texttt{resources-importer/journal/articles/}, copy the contents into
  an XML file, named as desired, and place it into the folder for the
  article. The web content article's XML fills in the data required by
  the structure.
\item
  \textbf{structure:} Edit the structure by clicking the link under
  \emph{Structure and Template}, and copy and paste its contents into a
  new JSON file for the structure in the
  \texttt{resources-importer/journal/structures/} folder. The structure
  JSON sets a wireframe, or blueprint, for an article's data.
\item
  \textbf{template:} Create a folder for the template under
  \texttt{resources-importer/journal/templates/}. Edit the template by
  clicking the link under \emph{Structure and Template}, and copy and
  paste its contents into a new FTL file for the template, and place it
  into the folder for the template. The template defines how the data
  should be displayed.
\end{itemize}

Here is an outline of steps you can use in developing your theme and its
resources:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create your theme.
\item
  Add your resources under the
  \texttt{{[}theme-name{]}/src/WEB-INF/src/resources-importer} folder
  and its subfolders.
\item
  Create a \texttt{sitemap.json} file in your
  \texttt{resources-importer/} folder. In this file, define the pages of
  the site or site template to be imported, along with the layout
  templates, portlets, and portlet preferences of these pages.
\item
  Create an \texttt{assets.json} file in your
  \texttt{resources-importer/} folder. In this file, specify details of
  your resource assets.
\item
  In your \texttt{liferay-plugin-package.properties} file, set
  \texttt{resources-importer-developer-mode-enabled=true}:

\begin{verbatim}
resources-importer-developer-mode-enabled=true
\end{verbatim}
\item
  Set the \texttt{resources-importer-target-value} property to the name
  of the site or site template into which you are importing, or comment
  it out to use the theme's name.

  For example, the following configuration sets the target value to the
  name of an existing site or site template:

\begin{verbatim}
resources-importer-target-value = site/site template name
\end{verbatim}

  Alternatively, this configuration uses the theme's name as the target
  value:

\begin{verbatim}
#resources-importer-target-value
\end{verbatim}
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** By default resources are imported into a new site template named
 after the theme. If you want your resources to be imported into an existing
 site or site template, you must specify a value for the
 `resources-importer-target-value` property.
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{6}
\item
  Comment out the \texttt{resources-importer-target-class-name} property
  to import into a site template or set it to
  \texttt{com.liferay.portal.kernel.model.Group} to import directly into
  a site.

  As mentioned above the example \texttt{sitemap.json}, \textbf{you must
  import your resources into a site, if you define both public and
  private page sets in your \texttt{sitemap.json}.}
\end{enumerate}

\textbf{If you don't specify a value for the
\texttt{resources-importer-target-class-name} property, your resources
will be imported into a site template.}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{7}
\item
  Deploy your theme into your Liferay instance.
\item
  View your theme, and its resources, from within Liferay. Log in to
  your portal as an administrator and check the Sites or Site Templates
  section of the Control Panel to make sure that your resources were
  deployed correctly. From the Control Panel you can easily view your
  theme and its resources:

  \begin{itemize}
  \tightlist
  \item
    If you imported into a site template, select its \emph{Actions} →
    \emph{View Pages} to see it.
  \item
    If you imported directly into a site, select its \emph{Actions} →
    \emph{Go to Public Pages} to see it.
  \end{itemize}
\end{enumerate}

You can go back to any of the beginning steps in this outline to make
refinements. It's just that easy to develop a theme with resources
intact!

\subsection{Related Topics}\label{related-topics-182}

\href{/docs/7-0/tutorials/-/knowledge_base/t/themes-generator}{Liferay
Theme Generator}

\href{/docs/7-0/user/-/knowledge_base/u/styling-apps-with-application-display-templates}{Styling
Apps with Application Display Templates}

\section{Using Developer Mode with
Themes}\label{using-developer-mode-with-themes}

Do you want to develop Liferay DXP themes without having to redeploy to
see your modifications? Use Liferay DXP's Developer Mode! In Developer
Mode, all caches are removed, so any changes you make are visible right
away. Also, you don't have to reboot the server as often in Developer
Mode.

How does Developer Mode let you see your changes more quickly? By
default, Liferay DXP is optimized for performance. Developer mode
optimizes your configuration for development instead. Here is a list of
Developer Mode's key behavior changes and the
\href{@platform-ref@/7.0-latest/propertiesdoc/portal.properties.html}{Portal
Property} override settings that trigger them (if applicable):

\begin{itemize}
\tightlist
\item
  CSS files are loaded individually rather than being combined and
  loaded as a single CSS file (\texttt{theme.css.fast.load=false}).
\item
  Layout template caching is disabled
  (\texttt{layout.template.cache.enabled=false}).
\item
  The server does not launch a browser when starting
  (\texttt{browser.launcher.url=}).
\item
  FreeMarker Templates for themes and web content are not cached, so
  changes are applied immediately (via the system setting in your
  Liferay DXP instance).
\item
  Minification of CSS and JavaScript resources is disabled
  (\texttt{minifier.enabled=false}).
\end{itemize}

\noindent\hrulefill

\textbf{Note:} There are two known issues
\href{https://issues.liferay.com/browse/LPS-71350}{LPS-71350} and
\href{https://issues.liferay.com/browse/LPS-70364}{LPS-70364} that
prevent CSS changes from being applied to the page and the Control Panel
and Product Menu to break when using Developer Mode. Both these issues
are fixed in Liferay Portal CE 7.0.3 GA4 and Liferay DXP 7.0 Fixpack DE
13.

\noindent\hrulefill

Individual file loading of your styling and behaviors, combined with
disabled caching for layout and FreeMarker templates, lets you see your
changes more quickly.

These developer settings are defined in the
\href{https://github.com/liferay/liferay-portal/blob/7.0.x/portal-impl/src/portal-developer.properties}{\texttt{portal-developer.properties}
file}. To use these settings, you can include them in your
\texttt{portal-ext.properties} file or copy them over to your
\texttt{portal-ext.properties} file and override specific properties as
needed. These configurations are covered in this tutorial.

First, you can explore how it's done in @ide@.

\subsection{Setting Developer Mode for Your Server in
@ide@}\label{setting-developer-mode-for-your-server-in-ide}

To enable Developer Mode for your server in @ide@, follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Double-click on your server in the \emph{Servers} window and open the
  \emph{Liferay Launch} section.
\item
  Select \emph{Custom Launch Settings} and check the \emph{Use developer
  mode} option.
\item
  Save the changes and start your server.
\end{enumerate}

\begin{figure}
\centering
\includegraphics{./images/developer-mode-ide.png}
\caption{The \emph{Use developer mode} option lets you enable Developer
Mode for your server in @ide@.}
\end{figure}

\noindent\hrulefill

\textbf{Warning:} Only change the Server settings from the runtime
environment's Liferay Launch section.

\noindent\hrulefill

For Liferay Portal servers below version 6.2 (e.g., Liferay v6.1 CE
Server, Liferay v6.0 CE Server), @ide@ enables Developer Mode by
default. When starting your Liferay DXP server for the first time, it
creates a \texttt{portal-ext.properties} file in your server's
directory. This properties file contains the property setting
\texttt{include-and-override=portal-developer.properties}, which enables
Developer Mode.

Most of the configuration is provided by the
\texttt{portal-developer.properties} file, but you still have to
configure the FreeMarker template setting. Follow the steps in the
\href{/docs/7-0/tutorials/-/knowledge_base/t/using-developer-mode-with-themes\#configuring-freemarker-system-settings}{Configuring
FreeMarker System Settings} section to configure the FreeMarker template
cache.

If you're not using @ide@, manual configuration for Developer Mode is
covered next.

\subsection{Setting Developer Mode for Your Server Using
portal-developer.properties}\label{setting-developer-mode-for-your-server-using-portal-developer.properties}

To set Developer Mode manually, you must point to
\texttt{portal-developer.properties} as shown in the last section. Add
the \texttt{portal-ext.properties} file to the root folder of your app
server's bundle and add the following line:

\begin{verbatim}
include-and-override=portal-developer.properties
\end{verbatim}

Developer Mode is enabled upon starting your app server.
\texttt{portal-developer.properties} provides the majority of the
settings you'll need for smooth development. To disable the cache for
FreeMarker templates, you must update the System Setting covered in the
next section.

\subsection{Configuring FreeMarker System
Settings}\label{configuring-freemarker-system-settings}

FreeMarker Templates for themes and web content are cached by default.
Therefore, any changes you make to your FreeMarker theme templates
aren't immediately displayed. You can change this behavior through
System Settings. Follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open the Control Panel and go to \emph{Configuration} → \emph{System
  Settings}.
\item
  Click the \emph{Foundation} tab and select \emph{FreeMarker Engine}.
\item
  By default, the \emph{Resource modification check} (the time in
  milliseconds that the template is cached) is set to \texttt{60}. Set
  this value to \texttt{0} to disable caching.
\end{enumerate}

Your FreeMarker templates are ready for development. Next you can learn
how you can improve JavaScript file loading for development.

\subsection{JavaScript Fast Loading}\label{javascript-fast-loading}

By default, JavaScript fast loading is enabled in Developer Mode
(\texttt{javascript.fast.load=true}). This loads the packed version of
files listed in the
\href{@platform-ref@/7.0-latest/propertiesdoc/portal.properties.html\#JavaScript}{Portal
Properties} \texttt{javascript.barebone.files} or
\texttt{javascript.everything.files}. You can, however, disable
JavaScript fast loading for easier debugging for development. Just set
\texttt{javascript.fast.load} to \texttt{false} in your
\texttt{portal.properties}, or you can disable fast loading by setting
the URL parameter \texttt{js\_fast\_load} to \texttt{0}.

\noindent\hrulefill

\textbf{Note:} JavaScript fast loading is retrieved from one of three
places: the request (determined by the current URL:
\texttt{http://localhost:8080/web/guest/home?js\_fast\_load=1}(on) or
\texttt{...?js\_fast\_load=0}(off)), the Session, or the Portal Property
(\texttt{javascript.fast.load=true}). Liferay DXP gives preference in
the order of request, session, and then Portal Properties. This lets you
change \texttt{js\_fast\_load}'s value from the default in
\texttt{portal.properties} without having to manually re-enter
\texttt{js\_fast\_load} into the URL upon every new page load.

\noindent\hrulefill

Great! You've set up your Liferay DXP server for Developer Mode. Now,
when you modify your theme's file directly in your bundle, you can see
your changes applied immediately on redeploying your theme!

\subsection{Related Topics}\label{related-topics-183}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-layout-templates-manually}{Creating
Layout Templates Manually}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-themes-with-liferay-ide}{Creating
Themes with @ide@}

\section{Theme Contributors}\label{theme-contributors}

If you want to package UI resources independent of a specific theme and
include them on a Liferay DXP page, Theme Contributors are your best
option. If, instead, you'd like to include separate UI resources on a
Liferay DXP page that are attached to a theme, you should look into
\href{/docs/7-0/tutorials/-/knowledge_base/t/themelets}{themelets}.

A Theme Contributor is a
\href{/docs/7-0/tutorials/-/knowledge_base/t/fundamentals\#modules}{module}
that contains UI resources to use in Liferay DXP. Once a Theme
Contributor is deployed to Liferay DXP, it's scanned for all valid CSS
and JS files, and then its resources are included on the page. You can,
therefore, style these UI components as you like, and the styles are
applied for the current theme.

This tutorial demonstrates how to

\begin{itemize}
\tightlist
\item
  Identify a Theme Contributor module.
\item
  Create a Theme Contributor module.
\end{itemize}

Next, you'll learn how to create a Theme Contributor.

\subsection{Creating Theme
Contributors}\label{creating-theme-contributors}

In Liferay versions prior to 7.0, the standard UI for User menus and
navigation (the Dockbar) was included in the theme template. Starting in
Liferay DXP 7.0, these standard UI components are packaged as Theme
Contributors.

For example, the Control Menu, Product Menu, and Simulation Panel are
packaged as Theme Contributor modules in Liferay, separating them from
the theme. This means that these UI components must be handled outside
the theme.

\begin{figure}
\centering
\includegraphics{./images/theme-contributor-menus-diagram.png}
\caption{The Control Menu, Product Menu, and Simulation Panel are
packaged as Theme Contributor modules.}
\end{figure}

If you want to edit or style these standard UI components, you'll need
to create your own Theme Contributor and add your modifications on top.
You can also add new UI components to Liferay DXP by creating a Theme
Contributor.

To create a Theme Contributor module, follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a generic OSGi module using your favorite third party tool, or
  use \href{/docs/7-0/tutorials/-/knowledge_base/t/blade-cli}{Blade
  CLI}. You can also use the
  \href{/docs/7-0/reference/-/knowledge_base/r/theme-contributor-template}{Blade
  Template} to create your module, in which case you can skip step 2.
\item
  To identify your module as a Theme Contributor, add the
  \texttt{Liferay-Theme-Contributor-Type} and \texttt{Web-ContextPath}
  headers to your module's \texttt{bnd.bnd} file. For example, see the
  Control Menu Theme Contributor module's \texttt{bnd.bnd}:

\begin{verbatim}
Bundle-Name: Liferay Product Navigation Control Menu Theme Contributor
Bundle-SymbolicName: com.liferay.product.navigation.control.menu.theme.contributor
Bundle-Version: 1.0.0
Liferay-Releng-Module-Group-Description:
Liferay-Releng-Module-Group-Title: Product Navigation
Liferay-Theme-Contributor-Type: product-navigation-control-menu
Web-ContextPath: /product-navigation-control-menu-theme-contributor
-include: ../../../../../marketplace/web-content-management/bnd.bnd
\end{verbatim}

  The Theme Contributor type helps Liferay DXP better identify your
  module. For example, if you're creating a Theme Contributor to
  override an existing Theme Contributor, you should try to use the same
  type to maximize compatibility with future developments. The
  \texttt{Web-ContextPath} header sets the context from which the Theme
  Contributor's resources are hosted.
\item
  Because you'll often be overriding CSS of another Theme Contributor,
  you should load your CSS after theirs. You can do this by setting a
  weight for your Theme Contributor. In your \texttt{bnd.bnd} file, add
  the following header:

\begin{verbatim}
Liferay-Theme-Contributor-Weight: [value]
\end{verbatim}

  The higher the value, the higher the priority. If your Theme
  Contributor has a weight of 100, it will be loaded after one with a
  weight of 99, allowing your CSS to override theirs.
\item
  Create a \texttt{src/main/resources/META-INF/resources} folder in your
  module and place your resources (CSS and JS) in that folder.
\item
  Build and deploy your module to see your modifications applied to
  Liferay DXP pages and themes.
\end{enumerate}

That's all you need to do to create a Theme Contributor for your site.
Remember, with great power comes great responsibility, so use Theme
Contributors wisely. The UI contributions affect every page and aren't
affected by theme deployments.

\subsection{Related Topics}\label{related-topics-184}

\href{/docs/7-0/tutorials/-/knowledge_base/t/themes-generator}{Liferay
Theme Generator}

\href{/docs/7-0/tutorials/-/knowledge_base/t/themelets}{Themelets}

\href{/docs/7-0/tutorials/-/knowledge_base/t/importing-resources-with-a-theme}{Importing
Resources with Your Themes}

\href{/docs/7-0/reference/-/knowledge_base/r/theme-contributor-template}{Theme
Contributor Template}

\section{Context Contributors}\label{context-contributors}

JSP templates are the predominant templating framework in Liferay DXP.
Themes, application display templates (ADTs), DDM templates, and more
make use of JSPs as a templating engine. JSPs, however, are not the only
templating language supported by Liferay DXP. Since many developers
prefer other templating frameworks (e.g., FreeMarker and Velocity),
Liferay enables you to use other template formats by offering the
Context Contributors framework.

Because JSPs are ``native'' to Java EE, they have access to all the
contextual objects inherent to the platform, like the request and the
session. Through these objects, developers can normally obtain
Liferay-specific context information by accessing container objects like
\texttt{themeDisplay} or \texttt{serviceContext}.

Template formats like FreeMarker aren't native to Java EE, so they don't
have access to these objects. If your template needs contextual
information such as the current user, the page, or anything else, Java
EE won't make it available to the template like it does for JSPs: you
must inject it yourself into the template. Liferay, however, gives you a
head start by injecting a \texttt{contextObjects} map of common
variables (e.g., \texttt{themeDisplay}, \texttt{locale}, \texttt{user},
etc.) by default into FreeMarker templates (e.g., themes). This map is
usually referred to as the \emph{context} of a template. If you need to
access some other context object that Liferay doesn't provide by
default, you must modify or add to a template's context. To do that, you
create a context contributor.

Context contributors modify a template's context by injecting variables
and functionality usable by the template framework. This lets you use
non-JSP templating languages for themes, ADTs, and any other templates
used in Liferay DXP. For example, suppose you want your theme to change
color based on the user's organization. You could create a context
contributor to inject the user's organization to your theme's context,
and then determine the theme's color based on that information.

Context contributors are already used in Liferay DXP by default.
Liferay's Product Menu display is determined by a variable injected by a
context contributor. You'll learn more about this later.

First, you'll learn how to create your own context contributor, and then
you'll examine one example of how Liferay DXP uses context contributors.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a generic OSGi module using your favorite third party tool, or
  use \href{/docs/7-0/tutorials/-/knowledge_base/t/blade-cli}{Blade
  CLI}.
\item
  Create a unique package name in the module's \texttt{src} directory
  and create a new Java class in that package. To follow naming
  conventions, begin the class name with the entity you want to inject
  context-specific variables for, followed by
  \emph{TemplateContextContributor} (e.g.,
  \texttt{ProductMenuTemplateContextContributor}).
\item
  Directly above the class's declaration, insert the following
  annotation:

\begin{verbatim}
@Component(
    immediate = true,
    property = {"type=" + TemplateContextContributor.[Type of Contributor]},
    service = TemplateContextContributor.class
)
\end{verbatim}

  The \texttt{immediate} element instructs the module to start
  immediately once deployed to Liferay DXP. The \texttt{type} property
  should be set to one of the two fields defined in the
  \href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/template/TemplateContextContributor.html}{TemplateContextContributor}
  interface: \texttt{TYPE\_GLOBAL} or \texttt{TYPE\_THEME}. The
  \texttt{TYPE\_THEME} field should be set if you only wish to inject
  context-specific variables for your theme; otherwise, setting the
  \texttt{TYPE\_GLOBAL} field affects every context execution in Liferay
  DXP, like themes, ADTs, DDM templates, etc. Finally, your
  \texttt{service} element should be set to
  \texttt{TemplateContextContributor.class}.

  The \texttt{ProductMenuTemplateContextContributor} class's
  \texttt{@Component} annotation follows a similar layout:

\begin{verbatim}
@Component(
    immediate = true,
    property = {"type=" + TemplateContextContributor.TYPE_THEME},
    service = TemplateContextContributor.class
)
\end{verbatim}
\item
  Implement the
  \href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/template/TemplateContextContributor.html}{TemplateContextContributor}
  interface in your \texttt{-TemplateContextContributor} class. This
  only requires implementing the
  \texttt{prepare(Map\textless{}String,Object\textgreater{},\ HttpServletRequest)}
  method.

  Notice that the \texttt{prepare} method receives the
  \texttt{contextObjects} map as a parameter. This is your template's
  context that was described earlier. This method should be used to edit
  the context by injecting new or modified variables into the
  \texttt{contextObjects} map.
\end{enumerate}

For a quick example of how you can implement the
\texttt{TemplateContextContributor} interface to inject variables into a
template's context, you'll examine the
\texttt{ProductMenuTemplateContextContributor} class used by Liferay DXP
by default. This class injects variables into Liferay's FreeMarker theme
and determines whether the Product Menu is displayed in the current
theme.

The \texttt{ProductMenuTemplateContextContributor} class implements the
\texttt{prepare(...)} method, which injects a modified variable
(\texttt{bodyCssClass}) and a new variable
(\texttt{liferay\_product\_menu\_state}) into the theme context:

\begin{verbatim}
@Override
public void prepare(
    Map<String, Object> contextObjects, HttpServletRequest request) {

    if (!isShowProductMenu(request)) {
        return;
    }

    String cssClass = GetterUtil.getString(
        contextObjects.get("bodyCssClass"));
    String productMenuState = SessionClicks.get(
        request,
        ProductNavigationProductMenuWebKeys.
            PRODUCT_NAVIGATION_PRODUCT_MENU_STATE,
        "closed");

    contextObjects.put(
        "bodyCssClass", cssClass + StringPool.SPACE + productMenuState);

        contextObjects.put("liferay_product_menu_state", productMenuState);
}
\end{verbatim}

This method prepares the context contributor to inject variables into
the theme to be used by the Product Menu. For this example, the
\texttt{cssClass} and \texttt{productMenuState} variables are defined
and then placed in the \texttt{contextObjects} map. By doing this, these
variables have been injected into the theme context, making them
accessible to the theme. Specifically, the \texttt{cssClass} variable
provides styling for the Product Menu and the \texttt{productMenuState}
variable determines whether the visible Product Menu should be open or
closed.

\noindent\hrulefill

\textbf{Note:} In previous versions of Liferay, if you needed to inject
variables into themes, you were forced to create those variables in the
\texttt{init.ftl} file of every theme. This forced theme developers to
keep that logic updated in every theme version of every theme they
developed. With context contributors, you can inject variables into
existing frameworks without forcing theme developers to update their
\texttt{init.ftl} files.

\noindent\hrulefill

The \texttt{prepare} method above also determines whether to show the
Product Menu or not with the following if statement:

\begin{verbatim}
if (!isShowProductMenu(request)) {
    return;
}
\end{verbatim}

The \texttt{isShowProductMenu(...)} method injects functionality into
the theme's context by providing an option to show/hide the Product
Menu. This method is also included in the
\texttt{ProductMenuTemplateContextContributor} class:

\begin{verbatim}
protected boolean isShowProductMenu(HttpServletRequest request) {
    ThemeDisplay themeDisplay = (ThemeDisplay)request.getAttribute(
        WebKeys.THEME_DISPLAY);

    if (themeDisplay.isImpersonated()) {
        return true;
    }

    if (!themeDisplay.isSignedIn()) {
        return false;
    }

    User user = themeDisplay.getUser();

    if (!user.isSetupComplete()) {
        return false;
    }

    return true;
}
\end{verbatim}

The \texttt{ProductMenuTemplateContextContributor} provides an easy way
to inject variables into Liferay DXP's theme directly related to the
Product Menu. You can do the same with your custom context contributor.
With the power to inject additional variables to any context in Liferay,
you're free to fully harness the power of your chosen templating
language.

\subsection{Related Topics}\label{related-topics-185}

\href{/docs/7-0/tutorials/-/knowledge_base/t/customizing-the-product-menu}{Customizing
the Product Menu}

\href{/docs/7-0/tutorials/-/knowledge_base/t/themes-generator}{Liferay
Theme Generator}

\href{/docs/7-0/tutorials/-/knowledge_base/t/theme-contributors}{Theme
Contributors}

\section{Macros}\label{macros}

Macros let you assign theme template fragments to a variable. This keeps
your theme templates from becoming cluttered and makes them easier to
read. Liferay DXP defines several FreeMarker macros in
\href{https://github.com/liferay/liferay-portal/blob/7.0.x/modules/apps/foundation/portal-template/portal-template-freemarker/src/main/resources/FTL_liferay.ftl}{\texttt{FTL\_liferay.ftl}
template} that you can use in your FreeMarker theme templates to include
theme resources, standard portlets, and more. Likewise, Velocity macros
are available in
\href{https://github.com/liferay/liferay-portal/blob/7.0.x/modules/apps/foundation/portal-template/portal-template-velocity/src/main/resources/VM_liferay.vm}{\texttt{VM\_liferay.vm}
template} Liferay DXP also exposes its taglibs as FreeMarker macros. See
the corresponding
\href{/docs/7-0/tutorials/-/knowledge_base/t/front-end-taglibs}{taglib
tutorial} for more information on using the taglib in your FreeMarker
templates. This tutorial shows how to use Liferay DXP's macros in your
FreeMarker and Velocity theme templates.

Note that \textbf{Velocity templates are supported, but deprecated as of
Liferay Portal CE 7.0 and Liferay DXP 7.0}. We recommend that you
convert your Velocity theme templates to FreeMarker at your earliest
convenience to avoid future issues. This tutorial covers both FreeMarker
and Velocity template macros to help with your conversion process.

The syntax for a macro is straightforward. A macro directive is defined
containing the template fragment. For example, below is the macro
directive for Liferay DXP's Control Menu:

FreeMarker:

\begin{verbatim}
<#macro control_menu>
        <#if themeDisplay.isImpersonated() || (is_setup_complete && is_signed_in)>
                <@liferay_product_navigation["control-menu"] />
        </#if>
</#macro>
\end{verbatim}

Velocity:

\begin{verbatim}
#macro (control_menu)
        #if ($themeDisplay.isImpersonated() || ($is_setup_complete && $is_signed_in))
            $theme.runtime(
                "com.liferay.admin.kernel.util.PortalProductNavigationControlMenuApplicationType$ProductNavigationControlMenu",  
                $portletProviderAction.VIEW
            )
        #end
#end
\end{verbatim}

\noindent\hrulefill

\textbf{Note:} Liferay DXP's default FreeMarker macro calls are
namespaced with \texttt{liferay} (for example,
\texttt{\textless{}@liferay.macro\_variable\_name\ /\textgreater{}}). If
you create custom macros, they can be called with the explicit variable
name.

\noindent\hrulefill

To include the template fragment in your theme templates, call the macro
using the variable name:

FreeMarker:

\begin{verbatim}
<@liferay.control_menu />
\end{verbatim}

Velocity:

\begin{verbatim}
#control_menu()
\end{verbatim}

The macro is replaced with the template fragment when the page is
rendered. That's all there is to a basic macro.

Macros can also be passed arguments. For example Liferay DXP's
\texttt{language} macro has a language key parameter:

FreeMarker:

\begin{verbatim}
<#macro language
        key
>
${languageUtil.get(locale, key)}
</#macro>
\end{verbatim}

Velocity:

\begin{verbatim}
#macro (language $lang_key)
$languageUtil.get($locale, $lang_key)
#end    
\end{verbatim}

You can pass an argument in the macro call like this:

FreeMarker:

\begin{verbatim}
<@liferay.language key="powered-by" />
\end{verbatim}

Velocity:

\begin{verbatim}
#language ("powered-by")
\end{verbatim}

You can read more about FreeMarker macros and Velocity macros at
\href{http://freemarker.org/docs/ref_directive_macro.html}{freemarker.org}
and
\href{http://velocity.apache.org/engine/1.7/user-guide.html\#velocimacros}{velocity.apache.org}.

Liferay DXP provides several macros that you can use in your theme
templates. These are covered next.

\subsection{Liferay DXP Macros}\label{liferay-dxp-macros}

There are several default macros defined in the
\href{https://github.com/liferay/liferay-portal/blob/7.0.x/modules/apps/foundation/portal-template/portal-template-freemarker/src/main/resources/FTL_liferay.ftl}{\texttt{FTL\_Liferay.ftl}
template} that you can use in your FreeMarker theme templates. Likewise,
\href{https://raw.githubusercontent.com/liferay/liferay-portal/7.0.x/modules/apps/foundation/portal-template/portal-template-velocity/src/main/resources/VM_liferay.vm}{VM\_liferay.vm}
defines the default macros for Velocity. The table below lists the
available macros and parameters:

\noindent\hrulefill

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.3333}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Macro
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Parameters
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Description
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
breadcrumbs & default preferences & Adds the Breadcrumbs portlet with
optional preferences \\
control\_menu & N/A & Adds the Control Menu portlet \\
css & filename & Adds an external stylesheet with the specified file
name location \\
date & format & Prints the date in the current locale with the given
format \\
js & filename & Adds an external JavaScript file with the specified file
name source \\
language & key & Prints the specified language key in the current
locale \\
language\_format & argumentskey & Formats the given language key with
the specified arguments. For example, passing \texttt{go-to-x} as the
key and \texttt{Mars} as the arguments prints \emph{Go to Mars}. \\
languages & default preferences & Adds the Languages portlet with
optional preferences \\
navigation\_menu & default preferencesinstance ID & Adds the Navigation
Menu portlet with optional preferences and instance ID.
\texttt{\$\{freeMarkerPortletPreferences\}} or
\texttt{\$velocityPortletPreferences.toString()} is a common value for
default preferences. \\
search & default preferences & Adds the Search portlet with optional
preferences \\
user\_personal\_bar & N/A & Adds the User Personal Bar portlet \\
\end{longtable}

\noindent\hrulefill

Now you know how to use Liferay DXP's macros in your theme templates!

\subsection{Related Topics}\label{related-topics-186}

\href{/docs/7-0/tutorials/-/knowledge_base/t/themes-generator}{Liferay
Theme Generator}

\href{/docs/7-0/tutorials/-/knowledge_base/t/themelets}{Themelets}

\href{/docs/7-0/reference/-/knowledge_base/r/theme-reference-guide}{Theme
Reference Guide}

\section{Theme Builder}\label{theme-builder}

Liferay's Theme Builder gives developers who aren't using
\href{/docs/7-0/tutorials/-/knowledge_base/t/themes-generator}{Liferay's
Theme Generator} (e.g., Gradle or Maven) a way to compile and build a
theme WAR file. To use the Theme Builder, you must apply it to your
project. If you're unsure how to structure themes for Liferay DXP, see
the
\href{/docs/7-0/tutorials/-/knowledge_base/t/introduction-to-themes}{Introduction
to Themes} tutorial.

Follow the instructions below to apply the Theme Builder plugin and
build your theme WAR.

\subsection{Step 1: Apply the Theme Builder Plugin to Your Theme
Project}\label{step-1-apply-the-theme-builder-plugin-to-your-theme-project}

Liferay provides two Theme Builder plugins depending on your build tool:

\begin{itemize}
\tightlist
\item
  \href{https://repository.liferay.com/nexus/content/repositories/liferay-public-releases/com/liferay/com.liferay.portal.tools.theme.builder/}{com.liferay.portal.tools.theme.builder}
  (Ant, Maven, etc.)
\item
  \href{https://repository.liferay.com/nexus/content/repositories/liferay-public-releases/com/liferay/com.liferay.gradle.plugins.theme.builder/}{com.liferay.gradle.plugins.theme.builder}
  (Gradle)
\end{itemize}

If you want to apply the Theme Builder plugin to an Ant project, examine
the \texttt{build.xml} file as an example below:

\begin{verbatim}
<?xml version="1.0"?>
<!DOCTYPE project>

<project>
    <path id="theme.builder.classpath">
        <fileset dir="[PATH_TO_THEME_BUILDER_JAR]" includes="com.liferay.portal.tools.theme.builder-*.jar" />
    </path>

    <taskdef classpathref="theme.builder.classpath" resource="com/liferay/portal/tools/theme/builder/ant/taskdefs.properties" />

    <target name="build-theme">
        <build-theme
            diffsDir="diffs"
            outputDir="../dist"
            parentDir="[PATH_TO_STYLED_THEME]/classes/META-INF/resources/_styled"
            parentName="_styled"
            unstyledDir="[PATH_TO_UNSTYLED_THEME]/classes/META-INF/resources/_unstyled"
        />
    </target>
</project>
\end{verbatim}

You should first supply the path to the Theme Builder JAR. The above
code configures the literal path to the JAR on your local machine. As an
alternative, you could configure \href{http://ant.apache.org/ivy/}{Ivy}
to do this for you behind the scenes. Then create an Ant target (e.g.,
\texttt{build-theme}) that configures the required parameters to build
your theme.

For assistance applying the Theme Builder plugin for a Gradle or Maven
project, see the
\href{/docs/7-0/reference/-/knowledge_base/r/theme-builder-gradle-plugin}{Theme
Builder Gradle Plugin} or
\href{/docs/7-0/tutorials/-/knowledge_base/t/building-themes-in-a-maven-project}{Building
Themes in a Maven Project} articles, respectively.

\subsection{Step 2: Build Your Theme}\label{step-2-build-your-theme}

Execute the appropriate command based on your build tool:

\begin{itemize}
\tightlist
\item
  \emph{Ant:} \texttt{ant\ build-theme}
\item
  \emph{Gradle:} \texttt{gradlew\ buildTheme}
\item
  \emph{Maven:} \texttt{mvn\ verify}
\end{itemize}

The WAR is generated in the following folder, depending on the build
tool you used:

\begin{itemize}
\tightlist
\item
  \emph{Ant:} \texttt{/dist}
\item
  \emph{Gradle:} \texttt{/build}
\item
  \emph{Maven:} \texttt{/target}
\end{itemize}

That's it! You've successfully configured and leveraged the Theme
Builder in your project. You can also use the Theme Builder to migrate a
Plugins SDK theme to Liferay Workspace. See the
\href{/docs/7-0/tutorials/-/knowledge_base/t/migrating-a-theme-from-the-plugins-sdk-to-workspace}{Migrating
a Theme from the Plugins SDK to Workspace} tutorial for details.

\section{Creating a Theme Thumbnail}\label{creating-a-theme-thumbnail}

Theme thumbnails help users quickly identify your theme. It's especially
important to provide thumbnails when your theme offers
\href{/docs/7-0/tutorials/-/knowledge_base/t/specifying-color-schemes}{color
schemes}.

Here's how to create a proper thumbnail image for your theme:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a thumbnail image. Make sure it's 150 pixels wide by 120 pixels
  high. You may want to take a snapshot of your theme and re-size it to
  these dimensions. \textbf{Your thumbnail must be these exact
  dimensions} or the image won't display properly.
\item
  Save the image as a \texttt{.png} file named \texttt{thumbnail.png}
  and place it in the theme's \texttt{images} folder (create this folder
  if it doesn't already exist). On redeployment, the
  \texttt{thumbnail.png} file automatically becomes the theme's
  thumbnail.
\end{enumerate}

\noindent\hrulefill

\textbf{Note:} The
\href{/docs/7-0/reference/-/knowledge_base/r/theme-builder-gradle-plugin}{Theme
Builder Gradle plugin} doesn't recognize a \texttt{thumbnail.png} file.
If you're using this plugin to build your theme instead, you must create
a \texttt{screenshot.png} file in your theme's \texttt{images} folder
that is 1080 pixels high by 864 pixels wide. The thumbnail is
automatically generated from the screenshot for you when the theme is
built.

\noindent\hrulefill

Now, when you apply the theme, its thumbnail displays along with the
other themes that are available to your site.

\begin{figure}
\centering
\includegraphics{./images/available-themes-thumbnail.png}
\caption{Your theme thumbnail is displayed with the rest of the
available themes.}
\end{figure}

Congrats! Now you know how to create a thumbnail image for your theme!

\subsection{Related Topics}\label{related-topics-187}

\href{/docs/7-0/tutorials/-/knowledge_base/t/themes-generator}{Liferay
Theme Generator}
\href{/docs/7-0/tutorials/-/knowledge_base/t/specifying-color-schemes}{Specifying
Color Schemes in Your Theme}

\section{Specifying Color Schemes in your
Theme}\label{specifying-color-schemes-in-your-theme}

You can provide various ``flavors'' of your theme by creating color
schemes. Color schemes let you keep the styles and overall design for
your theme, while giving a new look for your users to enjoy. You specify
color schemes with a CSS class name, which also lets you choose
different background images, different border colors, and more.

\begin{figure}
\centering
\includegraphics{./images/theme-color-schemes.png}
\caption{You can offer eye-pleasing color schemes for your themes.}
\end{figure}

Follow these steps to create color schemes for your theme:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a folder to hold color schemes (\texttt{color\_schemes} for
  example) in the theme's \texttt{css} folder.
\item
  Create an \texttt{.scss} file in the color schemes folder for each
  color scheme your theme supports. If you don't specify a
  \texttt{.scss} file for a color scheme, the theme's default color
  scheme is used.
\item
  Prefix all CSS styles with the name of your color scheme. The color
  scheme CSS class is placed on the page's
  \texttt{\textless{}body\textgreater{}} element, so you can use it to
  identify your styling. For example, you'd prefix all the styles with
  the word \emph{day} in a color scheme CSS file named
  \texttt{\_day.scss}:

\begin{verbatim}
body.day { background-color: #DDF; }
.day a { color: #66A; }
\end{verbatim}
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** The default color scheme does not require a prefix, as it uses
 the theme's `_custom.scss` for styling.
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{3}
\item
  Import the color scheme \texttt{.scss} files into the
  \texttt{\_custom.scss} file. The example below imports
  \texttt{\_day.scss} and \texttt{\_night.scss} files:

\begin{verbatim}
@import "color_schemes/day";
@import "color_schemes/night";
\end{verbatim}
\item
  Open the theme's \texttt{liferay-look-and-feel.xml} file and add the
  default color scheme for the theme. Pass the default color scheme's
  CSS class name (the name of the CSS file) in the
  \texttt{\textless{}css-class\textgreater{}} element. If the default
  color scheme styling is in the theme's \texttt{\_custom.scss} file,
  use \texttt{default} for the
  \texttt{\textless{}css-class\textgreater{}}:

\begin{verbatim}
<theme id="my-theme-id" name="My Theme Name">
   <color-scheme id="01" name="My Default Color Scheme Name">
       <default-cs>true</default-cs>
       <css-class>default</css-class>

       <color-scheme-images-path>
           ${images-path}/my_color_schemes_folder_name/${css-class}
       </color-scheme-images-path>
   </color-scheme
   ...
</theme>
\end{verbatim}

  A default color scheme lets users return to the theme's default look
  and feel. Note that the color scheme's \texttt{name} is arbitrary.
  Only the color scheme's \texttt{css-class} element must match the name
  of the color scheme's CSS class.

  Note that color schemes are sorted alphabetically by \texttt{name}
  rather than \texttt{id}. For example, a color scheme named
  \texttt{Day} and \texttt{id} \texttt{02} would be selected by default
  over a color scheme named \texttt{Clouds} with \texttt{id}
  \texttt{01}. The \texttt{\textless{}default-cs\textgreater{}} element
  overrides the alphabetical sorting and sets the color scheme that is
  selected by default, when the theme is chosen. Adding this element to
  the default color scheme ensures that it is selected when the theme is
  chosen.

  The \texttt{\textless{}color-scheme-images-path\textgreater{}} element
  specifies theme thumbnail image location. Place this element in the
  first color scheme to affect them all. For example you could use the
  folders \texttt{/images/color\_schemes/default},
  \texttt{/images/color\_schemes/day}, and
  \texttt{/images/color\_schemes/night}.
\item
  Add the remaining color schemes to the
  \texttt{liferay-look-and-feel.xml} using the pattern below:

\begin{verbatim}
<color-scheme id="02" name="my-color-scheme-name">
   <css-class>my-color-scheme-css-class-name</css-class>
</color-scheme>
\end{verbatim}

  The example below defines a \emph{Day} color scheme and a \emph{Night}
  color scheme for a theme named \emph{Big Green}. Here's the code as
  specified in the \texttt{liferay-look-and-feel.xml} file:

\begin{verbatim}
<theme id="big-green" name="Big Green">
    <color-scheme id="01" name="Default">
        <default-cs>true</default-cs>
        <css-class>default</css-class>
        <color-scheme-images-path>
            ${images-path}/color_schemes/${css-class}
        </color-scheme-images-path>
    </color-scheme>
    <color-scheme id="02" name="Day">
        <css-class>day</css-class>
    </color-scheme>
    <color-scheme id="03" name="Night">
        <css-class>night</css-class>
    </color-scheme>
</theme>
\end{verbatim}
\item
  Place a \texttt{thumbnail.png} and \texttt{screenshot.png} file in
  each of the color scheme's folders. Make sure thumbnail images follow
  the specifications defined in the
  \href{/docs/7-0/tutorials/-/knowledge_base/t/creating-a-theme-thumbnail}{Creating
  a Theme Thumbnail} tutorial.
\end{enumerate}

There you have it. Now you can go color scheme crazy with your themes!

\subsection{Related Topics}\label{related-topics-188}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-layout-templates-with-the-themes-generator-0}{Layout
Templates with the Theme Generator}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-a-theme-thumbnail}{Creating
a Theme Thumbnail}

\section{Making Themes Configurable with
Settings}\label{making-themes-configurable-with-settings}

Theme settings let site administrators control the look and feel of
certain aspects of a theme. For example, you can create a theme setting
to control the visibility of theme elements, such as only showing a site
banner when the user is logged in. You can also create a theme setting
to configure an element, such as a title or a background image. The
Settings API is built flexibly to meet your needs. The sky's the limit.

This tutorial covers how to create theme settings for a theme.

Making configurable theme settings involves a multi-step process:

\begin{itemize}
\tightlist
\item
  Add the settings to \texttt{liferay-look-and-feel.xml}
\item
  Assign the settings to variables in \texttt{init\_custom.ftl}
\item
  Use the settings variables in your theme templates
\end{itemize}

Follow these steps to create theme settings:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open \texttt{liferay-look-and-feel.xml} from the theme's
  \texttt{WEB-INF} folder. Settings placed here appear in the \emph{Look
  and Feel} menu of Liferay DXP's \emph{Site Administration}. If your
  project doesn't have this file, create it in the \texttt{WEB-INF}
  folder and add the following XML content (make sure to replace the
  theme \texttt{id} and \texttt{name} with your theme's):

\begin{verbatim}
 <?xml version="1.0"?>
 <!DOCTYPE look-and-feel PUBLIC "-//Liferay//DTD Look and Feel 7.0.0//EN" 
 "http://www.liferay.com/dtd/liferay-look-and-feel_7_0_0.dtd">

 <look-and-feel>
     <compatibility>
         <version>7.0.0+</version>
     </compatibility>
     <theme id="your-theme-name" name="Your Theme Name">
         <template-extension>ftl</template-extension>
     <portlet-decorator id="barebone" name="Barebone">
             <portlet-decorator-css-class>portlet-barebone</portlet-decorator-css-class>
         </portlet-decorator>
         <portlet-decorator id="borderless" name="Borderless">
             <portlet-decorator-css-class>portlet-borderless</portlet-decorator-css-class>
         </portlet-decorator>
         <portlet-decorator id="decorate" name="Decorate">
             <default-portlet-decorator>true</default-portlet-decorator>
             <portlet-decorator-css-class>portlet-decorate</portlet-decorator-css-class>
         </portlet-decorator>
     </theme>
 </look-and-feel>
\end{verbatim}
\item
  Add
  \texttt{\textless{}settings\textgreater{}\textless{}/settings\textgreater{}}
  tags before the opening
  \texttt{\textless{}portlet-decorator\textgreater{}} tag.
\item
  Add a \texttt{\textless{}setting/\textgreater{}} element between the
  \texttt{\textless{}settings\textgreater{}\textless{}/settings\textgreater{}}
  tags for each setting the theme requires. Below is an example pattern
  along with the available attributes:

\begin{verbatim}
<setting configurable="true" key="my-setting-language-key" 
options="true,false" type="select" value="false" />
\end{verbatim}

  The following attributes are available for theme settings:

  \textbf{configurable:} whether the setting is configurable or static.
  \textbf{key:} the language key that identifies the theme setting.
  \textbf{options:} sets the options for the select menu if the
  \texttt{type} is \texttt{select}. \textbf{type:} the type of UI to
  render to control the theme setting. Possible values are
  \texttt{checkbox}, \texttt{select}, \texttt{text}, or
  \texttt{textarea}. \textbf{value:} sets the default value for the
  theme setting.

  You can find more information about setting attributes and all other
  configurations for the \texttt{liferay-look-and-feel.xml} in its
  \href{@platform-ref@/7.0-latest/definitions/liferay-look-and-feel_7_0_0.dtd.html\#settings}{DTD
  docs}.
\item
  Open \texttt{init\_custom.ftl} and assign the settings to variables
  using the patterns below.

  Use the following pattern for settings that return a \texttt{Boolean}
  (for example a select box with the options \texttt{true} and
  \texttt{false} or a toggle-switch checkbox with values \texttt{yes}
  and \texttt{no}):

\begin{verbatim}
<#assign my_variable_name =
getterUtil.getBoolean(theme_settings["theme-setting-key"])>
\end{verbatim}

  Use the following pattern for settings that return a \texttt{String}
  (for example, a text input or textarea input):

\begin{verbatim}
<#assign footer_text = 
getterUtil.getString(theme_settings["theme-setting-key"])/>
\end{verbatim}
\item
  Use the theme setting variable in the theme template. For example, you
  can use the variable to check a condition, print a value, or even
  display a theme template. Examples of each case are shown below.

  This configuration is used in \texttt{portal\_normal.ftl} to show the
  navigation breadcrumbs element if the \texttt{show\_breadcrumbs} theme
  setting is \texttt{true}:
\end{enumerate}

\texttt{liferay-look-and-feel.xml}:

\begin{verbatim}
    <setting configurable="true" key="show-breadcrumbs" type="checkbox" 
    value="false" />
\end{verbatim}

\texttt{init\_custom.ftl}:

\begin{verbatim}
   <#assign show_breadcrumbs =
   getterUtil.getBoolean(theme_settings["show-breadcrumbs"])>
\end{verbatim}

\texttt{portal\_normal.ftl}:

\begin{verbatim}
    <#if show_breadcrumbs>
      <nav id="breadcrumbs">
        <@liferay.breadcrumbs />
      </nav>
    </#if>

This example configuration prints a text input's value in a `<p>` element, 
or defaults to *Hello Text* if no value is given:

`liferay-look-and-feel.xml`:

    <setting configurable="true" key="custom-text" type="text" 
    value="Hello Text"/>

`init_custom.ftl`:

    <#assign custom_text = 
    getterUtil.getString(theme_settings["custom-text"])/>

`portal_normal.ftl`:

    <p>${custom_text}</p>

This example renders the brief header template or detailed header 
template based on the theme setting:

`liferay-look-and-feel.xml`:

    <setting configurable="true" key="header-type" type="select" 
    options="brief,detailed" value="brief"/>

`init_custom.ftl`:

    <#assign header_type = 
    getterUtil.getString(theme_settings["header-type"])/>

`header_brief.ftl`: brief header template

`header_detailed.ftl`: detailed header template

`portal_normal.ftl`:

    <#if header_type == "brief">
      <#include "${full_templates_path}/header_brief.ftl" />
    <#elseif header_type == "detailed">
      <#include "${full_templates_path}/header_detailed.ftl" />
    </#if>
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{5}
\tightlist
\item
  Make sure the theme is installed. Open the \emph{Control Menu} →
  \emph{Site Administration} → \emph{Navigation} → \emph{Public Pages}
  and select the \emph{Configure} option. Configure the theme settings
  from the \emph{Look and Feel} section to see your changes. You can set
  the theme settings for an individual page by selecting the
  \emph{Configure Page} option from the page's Actions menu and
  selecting the \emph{Define a Specific look and feel for this page}
  option under the \emph{Look and Feel} section.
\end{enumerate}

\begin{figure}
\centering
\includegraphics{./images/theme-settings-look-and-feel.png}
\caption{Here are examples of configurable settings for the site Admin.}
\end{figure}

Now you know how to make configurable theme settings for your themes!

\subsection{Related Topics}\label{related-topics-189}

\href{/docs/7-0/tutorials/-/knowledge_base/t/freemarker-macros}{Macros}

\href{/docs/7-0/tutorials/-/knowledge_base/t/themelets}{Themelets}

\href{/docs/7-0/tutorials/-/knowledge_base/t/theme-contributors}{Theme
Contributors}

\chapter{Layout Templates}\label{layout-templates}

Are you craving more than Liferay DXP's default page layouts? Do you
have a special use case that a default layout template doesn't meet?
Well, look no further. Create your own Layout Template! Layout templates
allow you to set the rows and columns of a page and determine where
content can be placed.

In this section of tutorials, you'll learn how to develop layout
templates for Liferay DXP.

\section{Layout Templates with the Liferay Theme
Generator}\label{layout-templates-with-the-liferay-theme-generator}

Layout Templates specify how content is arranged on your site pages in
Liferay DXP. For example, take a look at the \emph{1-2-1 Columns Layout
CE} layout shown below:

\begin{figure}
\centering
\includegraphics{./images/layout-template-1-2-1-columns.png}
\caption{The \emph{1-2-1 Columns Layout CE} page layout creates a nice
flow for your content.}
\end{figure}

7.0 and DXP provide several layout templates out-of-the-box for you to
choose from. You can change the layout for your page, and view the
installed layout templates, by opening the \texttt{Edit} menu for your
page, under the \texttt{Navigation} heading of the
\texttt{Product\ Menu} and scrolling down to the \emph{Layouts} heading.

\begin{figure}
\centering
\includegraphics{./images/layout-templates.png}
\caption{Liferay provides several layout templates out-of-the-box for
you to use.}
\end{figure}

If you'd like to create your own custom layout templates, you've come to
the right place.

This tutorial demonstrates how to:

\begin{itemize}
\item
  Create a Layout Template with the Layouts Sub-generator
\item
  Create a Thumbnail for a Layout Template
\end{itemize}

In order to create a layout template with the Layouts Sub-generator, you
will need the Node.js build tools installed. The
\href{/docs/7-0/tutorials/-/knowledge_base/t/themes-generator}{Liferay
Theme Generator} tutorial explains how to install these tools and how to
create a theme.

Once you have the Liferay Theme Generator installed you can go ahead and
get started.

\subsection{Creating a Layout Template with the Layouts
Sub-generator}\label{creating-a-layout-template-with-the-layouts-sub-generator}

Follow these steps to create a layout template:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open the Command Line and navigate to the directory you want to create
  your layout template in.
\item
  Run \texttt{yo\ liferay-theme:layout} to start the layouts
  sub-generator.

  \begin{figure}
  \centering
  \includegraphics{./images/layout-prompt.png}
  \caption{The Layout Template sub-generator automates the layout
  creation process.}
  \end{figure}

  \textbf{Note:} If you run the layout sub-generator from the root
  directory of a theme created with the themes generator, it will add
  the layout template as a part of the theme in the
  \texttt{src/layouttpl} directory.
\item
  Enter a name and ID for your layout template, or press Enter to accept
  the default values.
\item
  Choose your Liferay version and press Enter to continue.

  At this point the layout template design process begins. As the
  generator states, Layout templates implement Bootstrap's grid system.
  Every row consists of 12 sections, so columns range in size from 1 to
  12. The sub-generator is user-friendly, allowing you to add and remove
  rows and columns as you design.
\item
  Enter the number of columns you would like for \texttt{row\ 1}.

  Once you've entered a value, the generator asks how wide you want your
  row and column to be, and presents you with the available width(s).
\item
  Choose from the available option(s) with your arrow keys and press
  Enter to make your selection.

  If you have remaining space, the generator will repeat this step for
  the remaining columns.

  Once you're done configuring your row, you are presented with a few
  options:

  \begin{itemize}
  \item
    Add a row: Adds a row below the last row.
  \item
    Insert row: Displays a vi to insert your row. Use your arrow keys to
    choose where to insert your row, highlighted in blue, then press
    Enter to insert the row.
  \end{itemize}

  \begin{figure}
  \centering
  \includegraphics{./images/insert-row.png}
  \caption{Rows can be inserted using the layout vi.}
  \end{figure}

  \begin{itemize}
  \tightlist
  \item
    Remove row: Displays a vi to remove your row. Use your arrow keys to
    select the row you want to remove, highlighted in red, then press
    Enter to remove the row.
  \end{itemize}

  \begin{figure}
  \centering
  \includegraphics{./images/remove-row.png}
  \caption{Rows are removed using the layout vi.}
  \end{figure}

  Once you are done designing your layout you can move onto the next
  step.
\item
  Select \emph{Finish layout} to complete your layout's design.

  \begin{figure}
  \centering
  \includegraphics{./images/finish-layout.png}
  \caption{Select the \emph{Finish layout} option to complete your
  design.}
  \end{figure}

  Your layout template files are generated for you in the current
  directory.
\item
  Enter the path to your app server directory, or press Enter to accept
  the default.
\item
  Enter the URL to your server or press Enter to accept the default
  \texttt{http://localhost:8080} development site.

  Your layout template is generated, but you still need to include it in
  your \texttt{liferay-look-and-feel.xml} file.
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** Currently the Liferay Theme Generator does not add the layout
 template configuration to your `liferay-look-and-feel.xml`. This feature
 will be added in a future release. For now you must add this manually next.
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{9}
\item
  Add your custom layout template to your
  \texttt{liferay-look-and-feel.xml} using the
  \texttt{\textless{}layout-templates\textgreater{}} tag. Below is an
  example configuration for the
  \href{https://github.com/liferay/liferay-portal/blob/7.0.x/modules/apps/frontend-theme-porygon/frontend-theme-porygon/src/WEB-INF/liferay-look-and-feel.xml\#L16-L27}{Porygon
  theme}`s' layout templates:

  \ldots{} /layouttpl/custom/porygon\_70\_30\_width\_limited.tpl
  /layouttpl/custom/porygon\_70\_30\_width\_limited.png
  /layouttpl/custom/porygon\_50\_50\_width\_limited.tpl
  /layouttpl/custom/porygon\_50\_50\_width\_limited.png
\end{enumerate}

\begin{verbatim}
The `<layout-template>` tag's `id` attribute must match the ID you gave in 
step 3 (the TPL file name).
\end{verbatim}

When your layout template was generated, a default thumbnail was
created. You can learn how to create a custom thumbnail in the next
section.

\subsection{Creating a Custom Thumbnail for Your Layout
Template}\label{creating-a-custom-thumbnail-for-your-layout-template}

To create your own thumbnail follow the steps below:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Navigate to the \texttt{docroot} directory of the layout template you
  just created.

  \textbf{Note:} if you created the layout template in your existing
  themes generator theme, the thumbnail is located in your theme's
  \texttt{src/layouttpl/custom} directory.
\item
  Replace the \texttt{layout-name.png} file with your own custom
  thumbnail PNG.
\item
  navigate back to the layout's root directory and run
  \texttt{gulp\ deploy} to re-build and deploy the template to your app
  server.

  \textbf{Note:} If your layout template was added as part of your
  themes generator theme, the layout template will deploy when the theme
  is deployed.
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** Currently the Liferay Theme Generator does not add the thumbnail
 configuration to your `liferay-look-and-feel.xml`. This feature will be
 added in a future release. For now you must add this manually next.
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{3}
\item
  Specify the thumbnail's location in your
  \texttt{liferay-look-and-feel.xml} using the
  \texttt{\textless{}thumbnail-path\textgreater{}} tag. Below is an
  example configuration for the Porygon theme:

\begin{verbatim}
<layout-template id="porygon_50_50_width_limited" 
name="Porygon 2 Columns (50/50) width limited">
    <template-path>
        /layoutttpl/custom/porygon_50_50_width_limited.tpl
    </template-path>
    <thumbnail-path>
        /layoutttpl/custom/porygon_50_50_width_limited.png
    </thumbnail-path>
</layout-template>
\end{verbatim}
\end{enumerate}

Your layout template is complete! As you can see, the layouts
sub-generator makes creating a layout template a piece of cake.

Edit a page on your site and select your new layout template to use it.

\subsection{Related Topics}\label{related-topics-190}

\href{/docs/7-0/tutorials/-/knowledge_base/t/importing-resources-with-a-theme}{Importing
Resources with Your Themes}

\href{/docs/7-0/tutorials/-/knowledge_base/t/themes-generator}{Liferay
Theme Generator}

\section{Creating Layout Templates
Manually}\label{creating-layout-templates-manually}

You can use the
\href{/docs/7-0/tutorials/-/knowledge_base/t/themes-generator}{Liferay
Theme Generator} to generate Layout Templates automatically. This is
covered in the
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-layout-templates-with-the-themes-generator-0}{Layout
Templates with the Liferay Theme Generator} tutorial. You may, however,
want to create or modify your layout templates manually.

In this tutorial you'll learn how to create or modify a Layout Template
manually.

You can see the HTML markup for a basic layout template next.

\subsection{Basic Layout Template}\label{basic-layout-template}

Below is an example of a basic Layout Template \texttt{.tpl} file:

\begin{verbatim}
<div class="my-liferay-layout" id="main-content" role="main">
        <div class="portlet-layout row">
                <div class="col-md-4 portlet-column portlet-column-first" 
                id="column-1">
                        $processor.processColumn("column-1", 
                        "portlet-column-content portlet-column-content-first")
                </div>
                <div class="col-md-8 portlet-column portlet-column-last" id="column-2">
                        $processor.processColumn("column-2", 
                        "portlet-column-content portlet-column-content-last")
                </div>
        </div>
        <div class="portlet-layout row">
                <div class="col-md-12 portlet-column portlet-column-only" id="column-3">
                        $processor.processColumn("column-3", 
                        "portlet-column-content portlet-column-content-only")
                </div>
        </div>
        <div class="portlet-layout row">
                <div class="col-md-4 portlet-column portlet-column-first" id="column-4">
                        $processor.processColumn("column-4", 
                        "portlet-column-content portlet-column-content-first")
                </div>
                <div class="col-md-4 portlet-column" id="column-5">
                        $processor.processColumn("column-5", "portlet-column-content")
                </div>
                <div class="col-md-4 portlet-column portlet-column-last" id="column-6">
                        $processor.processColumn("column-6", 
                        "portlet-column-content portlet-column-content-last")
                </div>
        </div>
</div>
\end{verbatim}

The column elements and classes are described in more detail next.

\subsection{Column Elements and
Classes}\label{column-elements-and-classes}

To understand how the layout template works, you must look closely at
how the HTML is structured. This section uses the first column of the
example above to demonstrate the key elements and classes of a layout
template:

\begin{verbatim}
<div class="col-md-4 portlet-column portlet-column-first" id="column-1">
        $processor.processColumn("column-1", "portlet-column-content 
        portlet-column-content-first")
</div>
\end{verbatim}

You can learn more about the column container next.

\subsubsection{Column Container}\label{column-container}

Below is a description of each of the column container classes:

\texttt{column-1}: A unique identifier for the column that matches the
ID passed to \texttt{\$processor.processColumn}.

\texttt{col-md-4}: This class comes from Bootstrap's grid system and
determines two things: the percentage based width of the element, and
the media query breakpoint for when this element expands to 100\% width.
12 is the maximum amount, so \texttt{col-md-4} indicates \texttt{4/12}
width, or \texttt{33.33\%}.

\texttt{portlet-column\ portlet-column-first}: All column containers
must use the \texttt{portlet-column} class. For rows with more than one
column, the first column must have \texttt{portlet-column-first} and the
last must have \texttt{portlet-column-last}. For rows with only one
column, use the \texttt{portlet-column-only} class.

Next you can learn more about the \texttt{\$processor.processColumn}.

\subsubsection{Processor ProcessColumn}\label{processor-processcolumn}

\texttt{\$processor.processColumn} takes these arguments:

\texttt{column-1}: A unique identifier. This should match the ID of the
parent \texttt{div}.

\texttt{portlet-column-content\ portlet-column-content-first}:
Additional classes added to the content element. These classes must
match the parent \texttt{div}'s classes with \texttt{-content} appended.

Next you can learn how to modify template breakpoints.

\subsection{Modifying Template
Breakpoints}\label{modifying-template-breakpoints}

When looking at the example template, you'll notice this Bootstrap grid
class is used on every column:

\begin{verbatim}
col-md-{size}
\end{verbatim}

The different sizes available are \texttt{xs}, \texttt{sm}, \texttt{md},
and \texttt{lg}. The medium size is used by default, but the others can
be used in layout templates as well.

For example, setting the column classes to \texttt{col-lg-\{size\}}
means the columns would expand to 100\% width at a larger screen width
than \texttt{col-md-\{size\}}.

These classes can also be mixed to achieve more advanced layouts, as
shown below:

\begin{verbatim}
<div class="portlet-layout row">
        <div class="col-md-4 col-sm-6 portlet-column portlet-column-first" 
        id="column-1">
                $processor.processColumn("column-1", 
                "portlet-column-content portlet-column-content-first")
        </div>
        <div class="col-md-8 col-sm-6 portlet-column portlet-column-last" 
        id="column-2">
                $processor.processColumn("column-2", 
                "portlet-column-content portlet-column-content-last")
        </div>
</div>
\end{verbatim}

In the example row above, on medium sized view, ports \texttt{column-1}
are 33.33\% width and \texttt{column-2} are 66.66\% width, but on small
sized view ports both \texttt{column-1} and \texttt{column-2} are 50\%
width.

Place the completed layout in your theme's \texttt{src/layouttpl} folder
if you created your theme with Theme's Generator, or place it in your
theme's \texttt{docroot/layouttpl/custom} folder if using the Plugins
SDK.

Next you can learn how to include layout templates in a theme.

\subsection{Including Layout Templates with a
Theme}\label{including-layout-templates-with-a-theme}

You can deploy a layout template with a theme by specifying it in the
theme's \texttt{liferay-look-and-feel.xml} file.

Add your custom layout template to your
\texttt{liferay-look-and-feel.xml} using the
\texttt{\textless{}layout-templates\textgreater{}} tag. Below is an
example configuration using the basic layout template example shown
above:

\begin{verbatim}
<theme id="my-theme-name" name="My Theme Name">
    ...
      <layout-templates>
        <custom>
          <layout-template id="my_liferay_layout_template" 
          name="My Liferay Layout Template">
            <template-path>
                /layoutttpl/custom/my_liferay_layout_template.tpl
            </template-path>
            <thumbnail-path>
                /layoutttpl/custom/my_liferay_layout_template.png
            </thumbnail-path>
          </layout-template>
        </custom>
      </layout-templates>
    ...
</theme>
\end{verbatim}

The \texttt{\textless{}layout-template\textgreater{}} tag's \texttt{id}
attribute must match the layout template's filename. The template and
thumbnail paths shown above are for files in the
\texttt{layouttpl/custom} folder. If you created your layout template
with the Liferay Theme Generator, your file paths may differ.

There you have it. Now you know how to create and modify layout
templates manually and how to include them with a theme!

\subsection{Related Topics}\label{related-topics-191}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-layout-templates-with-the-themes-generator-0}{Layout
Templates with the Liferay Theme Generator}

\href{/docs/7-0/tutorials/-/knowledge_base/t/themes-generator}{Liferay
Theme Generator}

\chapter{Portlets and Themes}\label{portlets-and-themes}

Liferay DXP gives you complete control over the look and feel of your
portlets. You can provide custom styles for portlets, create style
configuration options via portlet decorators, and embed portlets in
themes and layout templates.

All these topics are covered in this section of tutorials.

\chapter{Portlet Decorators}\label{portlet-decorators}

In previous versions of Liferay DXP, administrators could display or
hide the application borders through the \emph{Show Borders} option of
the look and feel configuration menu. In 7.0 this option has been
replaced with Portlet Decorators, a more powerful mechanism to customize
the style of the application wrapper.

If you inspect the markup of your Liferay application when it's on a
page you'll observe that it is wrapped by two layers. Among other
things, these layers provide some common basic features like the drag
and drop and the application border style. In order to protect these
features, you can't modify the markup of these layers directly with a
theme.

Portlet Decorators provide a mechanism to add a CSS class to one of
these wrapping layers via a user's setting. By defining styles for this
class in your theme, you can change the look and feel of the application
instances where the Portlet Decorator is applied, including its wrapper.

The figure below shows the markup of the layers wrapping a Liferay
application when the \emph{Decorate} Portlet Decorator is applied:

\begin{figure}
\centering
\includegraphics{./images/portlet-application-markup.png}
\caption{Portlet Decorators add the decorator's CSS class to the
application's wrapper}
\end{figure}

Once your Portlet Decorator is complete, apply it to your applications
through the
\href{/docs/7-0/user/-/knowledge_base/u/look-and-feel-configuration}{Look
and Feel Configuration menu}.

\begin{figure}
\centering
\includegraphics{./images/app-decor-look-and-feel.png}
\caption{Portlet Decorators can be applied through the Look and Feel
Configuration menu}
\end{figure}

Your portlet's decor is now in your hands.

\section{Adding Portlet Decorators to a
Theme}\label{adding-portlet-decorators-to-a-theme}

Portlet Decorators are associated with a particular theme. If your theme
does not define any portlet decorators, none are available. It is
recommended that you provide a few decorators for your portlets, to
cover the basic use cases.

For example, the Liferay Portal CE 7.0
\href{https://github.com/liferay/liferay-portal/tree/7.0.x/modules/apps/foundation/frontend-theme/frontend-theme-classic}{Classic
theme} includes three Portlet Decorators:

\begin{itemize}
\item
  Decorate: this is the default Application Decorator when using the
  Classic theme. When this decorator is applied, the portlet is wrapped
  in a white box with a border and the portlet title is displayed at the
  top.

  \begin{figure}
  \centering
  \includegraphics{./images/application-decorator-decorate.png}
  \caption{The Classic theme's Decorate Application Decorator wraps the
  portlet in a white box.}
  \end{figure}
\item
  Borderless: when this decorator is applied, the portlet is no longer
  wrapped in a white box, but the portlet title is displayed at the top.

  \begin{figure}
  \centering
  \includegraphics{./images/application-decorator-borderless.png}
  \caption{The Classic theme's Borderless Application Decorator displays
  the application's custom title.}
  \end{figure}
\item
  Barebone: when this decorator is applied, neither the wrapping box nor
  the custom portlet title are shown. This option is recommended when
  you only want to display the bare portlet content.

  \begin{figure}
  \centering
  \includegraphics{./images/application-decorator-barebone.png}
  \caption{The Classic theme's Barebone Application Decorator displays
  only the application's content.}
  \end{figure}
\end{itemize}

\noindent\hrulefill

\textbf{Note:} Upgrading to Liferay DXP will assign the
\emph{borderless} decorator automatically to those portlets that had the
\emph{Show Borders} option set to false in previous versions of Liferay.

As mentioned, you should consider updating your Liferay DXP Themes to
provide at least one for the \emph{decorate}, \emph{borderless} and
\emph{barebone} use cases.

\noindent\hrulefill

This tutorial demonstrates how to

\begin{itemize}
\item
  Add Portlet Decorators to your theme
\item
  Affect theme markup with Portlet Decorators
\end{itemize}

Now that you know why you should have Portlet Decorators in your theme,
you can learn how to add them to your theme.

\subsection{Adding Portlet Decorators to a
Theme}\label{adding-portlet-decorators-to-a-theme-1}

Adding Portlet Decorators to your theme is similar to adding Color
Schemes. You just have to follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Configure your theme's \texttt{liferay-look-and-feel.xml}
\item
  Define the Application Decorator CSS styles
\item
  Optional: Add conditions to your theme's markup
\end{enumerate}

\subsubsection{Configuring
liferay-look-and-feel.xml}\label{configuring-liferay-look-and-feel.xml}

The first thing you must do is declare the Portlet Decorators in your
theme's \texttt{liferay-look-and-feel.xml}.

The
\href{@platform-ref@/7.0-latest/definitions/liferay-look-and-feel_7_0_0.dtd.html\#portlet-decorator}{Document
Type Definition for the liferay-look-and-feel.xml} in Liferay DXP
contains the information and rules to add Portlet Decorators (in the
code referred as portlet-decorators) to your theme.

Here is how the classic theme defines Portlet Decorators in its
\texttt{liferay-look-and-feel.xml}:

\begin{verbatim}
<?xml version="1.0"?>
<!DOCTYPE look-and-feel PUBLIC "-//Liferay//DTD Look and Feel 7.0.0//EN" "http://www.liferay.com/dtd/liferay-look-and-feel_7_0_0.dtd">

<look-and-feel>
    <compatibility>
        <version>7.0.0+</version>
    </compatibility>
    ...
        <theme id="classic" name="Classic">
        ...
        <portlet-decorator id="barebone" name="Barebone">
            <portlet-decorator-css-class>portlet-barebone</portlet-decorator-css-class>
        </portlet-decorator>
        <portlet-decorator id="borderless" name="Borderless">
            <portlet-decorator-css-class>portlet-borderless</portlet-decorator-css-class>
        </portlet-decorator>
        <portlet-decorator id="decorate" name="Decorate">
            <default-portlet-decorator>true</default-portlet-decorator>
            <portlet-decorator-css-class>portlet-decorate</portlet-decorator-css-class>
        </portlet-decorator>
        </theme>
</look-and-feel>
\end{verbatim}

The \texttt{portlet-decorator} element contains all the information
about the Application Decorator:

\begin{itemize}
\tightlist
\item
  id: this required attribute contains a unique string that identifies
  this specific Application Decorator. This is the value that is stored
  when applying an Application Decorator, and it can be used to refer to
  this decorator in your theme templates.
\item
  name: this required attribute is a user friendly identifier for the
  Application Decorator to be displayed in the Look and Feel UI.
\item
  portlet-decorator-css-class: this required element contains the name
  of the CSS class that is added to the application wrapping layer when
  this Application Decorator is applied.
\item
  default-portlet-decorator: use this optional element to identify the
  default Application Decorator for your theme.
\end{itemize}

You can define as many Portlet Decorators as you want, but it's
recommended to include at least one for the \emph{decorate},
\emph{borderless} and \emph{barebone} use cases.

\subsubsection{Define the Styles for Your Application Decorator CSS
Class}\label{define-the-styles-for-your-application-decorator-css-class}

Once you've declared your Portlet Decorators, it's time to define their
effect in the application look and feel. While the previous step was
straightforward, this depends on your creativity.

As an example, look at the \texttt{\_portlet\_decorator.scss} of the
Classic theme:

\begin{verbatim}
.portlet-decorate .portlet-content {
    background: #FFF;
    border: 1px solid #DEEEEE;
}

.portlet-barebone .portlet-content {
    padding: 0;
}
\end{verbatim}

Once your CSS styles are written, make sure to import the CSS file into
your \texttt{\_custom.scss}:

\begin{verbatim}
@import "portlet_decorator"
\end{verbatim}

That's all that is required to add Portlet Decorators to your theme. If
you want to modify your application's markup with your Portlet
Decorators, read the next section.

\subsubsection{Changing Your Application Markup with Portlet
Decorators}\label{changing-your-application-markup-with-portlet-decorators}

So far you've seen how to use Portlet Decorators to change the look and
feel of an application with styles.

It's possible to go a step further and alter the markup of your
application based on the Application Decorator applied. For this, you
must edit the \texttt{portlet.ftl} template for your theme, retrieve the
\texttt{portletDecoratorId} of the current Application Decorator from
the \texttt{portlet\_display} object, and make some decisions based on
it.

For example, this is how the Classic theme shows the application title
when the \emph{barebone} Application Decorator is not applied:

\begin{verbatim}
<#if portlet_display.getPortletDecoratorId() != "barebone">
        <h2 class="portlet-title-text">${portlet_title}</h2>
</#if>
\end{verbatim}

There you have it! Now you know how to add Portlet Decorators to your
theme. Let your creativity be your guide.

\subsection{Related Topics}\label{related-topics-192}

\href{/docs/7-0/tutorials/-/knowledge_base/t/themelets}{Themelets}

\href{/docs/7-0/tutorials/-/knowledge_base/t/making-your-applications-configurable}{Making
Your Applications Configurable}

\section{Applying Portlet Decorators to Embedded
Portlets}\label{applying-portlet-decorators-to-embedded-portlets}

Once you have installed a theme that contains Portlet Decorators, site
administrators can apply them to a portlet instance by selecting the
Application Decorator in the Look and Feel Configuration dialog.

If your theme contains embedded portlets, it's also possible to apply an
Application Decorator other than the default one by setting its
preferences.

This tutorial demonstrates how to apply Portlet Decorators to Embedded
Portlets in your theme.

\subsection{Setting Application Decorator
Preferences}\label{setting-application-decorator-preferences}

To define a default Application Decorator for your theme's embedded
portlets, you must set a default decorator in the portlet preferences.

For example, the
\href{https://github.com/liferay/liferay-portal/blob/7.0.x/modules/apps/foundation/frontend-theme/frontend-theme-classic/src/templates/navigation.ftl}{Classic
theme} declares an Application Decorator with Id \texttt{barebone} and
applies it to the embedded Navigation Menu portlet and Search portlet in
its \texttt{navigation.ftl}:

\begin{verbatim}
<#assign VOID =
freeMarkerPortletPreferences.setValue("portletSetupPortletDecoratorId",
"barebone")>

<div aria-expanded="false" class="collapse navbar-collapse"
id="navigationCollapse">
    <#if has_navigation && is_setup_complete>
        <nav class="${nav_css_class} site-navigation"
        id="navigation" role="navigation">
            <div class="navbar-form navbar-right" role="search">
                <@liferay.search default_preferences=
                "${freeMarkerPortletPreferences}" />
            </div>

            <div class="navbar-right">
                <@liferay.navigation_menu default_preferences=
                "${freeMarkerPortletPreferences}" />
            </div>
        </nav>
    </#if>
</div>

<#assign VOID = freeMarkerPortletPreferences.reset()>
\end{verbatim}

To set the default decorator for your embedded portlets, follow these
steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Set the value for the \texttt{portletSetupPortletDecoratorId} to the
  Id of the Application Decorator you want to use:

\begin{verbatim}
<#assign VOID =
freeMarkerPortletPreferences.setValue("portletSetupPortletDecoratorId",
"barebone")>
\end{verbatim}
\item
  Next, set the \texttt{default\_preferences} attribute of the portlet's
  tag to the \texttt{freeMarkerPortletPreferences} variable you just
  defined:

\begin{verbatim}
<@liferay.search default_preferences= "${freeMarkerPortletPreferences}" />
\end{verbatim}
\end{enumerate}

Your embedded portlets now have a custom default Application Decorator!

\subsection{Related Topics}\label{related-topics-193}

\href{/docs/7-0/tutorials/-/knowledge_base/t/embedding-portlets-in-themes}{Embedding
Portlets in Themes}

\href{/docs/7-0/tutorials/-/knowledge_base/t/providing-portlets-to-manage-requests}{Providing
Portlets to Manage Requests}

\section{Theming Portlets}\label{theming-portlets}

Liferay DXP themes can provide additional styles to a portlet. You can
change the markup for the portlet containers by modifying the
\texttt{portlet.ftl} file.

This tutorial demonstrates how to style portlets with your themes.

\subsection{Portlet FTL}\label{portlet-ftl}

Here is a quick look at the default
\href{https://github.com/liferay/liferay-portal/blob/7.0.x/modules/apps/foundation/frontend-theme/frontend-theme-classic/src/templates/portlet.ftl}{\texttt{portlet.ftl}}
that's included in the default theme of 7.0:

\begin{verbatim}
<#assign
        portlet_display = portletDisplay

        portlet_back_url = htmlUtil.escapeHREF(portlet_display.getURLBack())
        portlet_content_css_class = "portlet-content"
        portlet_display_name = htmlUtil.escape(portlet_display.getPortletDisplayName())
        portlet_display_root_portlet_id = htmlUtil.escapeAttribute(portlet_display.getRootPortletId())
        portlet_id = htmlUtil.escapeAttribute(portlet_display.getId())
        portlet_title = htmlUtil.escape(portlet_display.getTitle())
/>
\end{verbatim}

An explanation of each variable used in \texttt{portlet.ftl} is shown
below:

\begin{itemize}
\tightlist
\item
  \texttt{portletDisplay}: is fetched from the \texttt{themeDisplay}
  object and contains information about the portlet.
\item
  \texttt{portlet\_back\_url}: URL to return to the previous page with
  portlet \texttt{WindowState} is maximized.
\item
  \texttt{portlet\_display\_name}: The ``friendly'' name of the portlet
  as displayed in the GUI.
\item
  \texttt{portlet\_display\_root\_portlet\_id}: Sets the
\item
  \texttt{portlet\_id}: The ID of the portlet (not the same as the
  portlet namespace)
\item
  \texttt{portlet\_title}: The portlet name set in the portlet Java
  class (usually from a \texttt{Keys.java} class).
\end{itemize}

The following condition checks if the portlet header should be
displayed. If the portlet has a portlet toolbar (Configuration,
Permissions, Look and Feel), the condition is true:

\begin{verbatim}
<#if portlet_display.isPortletDecorate() && !portlet_display.isStateMax() 
&& portlet_display.getPortletConfigurationIconMenu()?? 
&& portlet_display.getPortletToolbar()??>
\end{verbatim}

Portlet title menus are used in portlets that allow you to add resources
(Web Content Display, Media Gallery, Documents and Media). This is used
to build a menu of items for adding resources:

\begin{verbatim}
portlet_title_menus = portlet_toolbar.getPortletTitleMenus(portlet_display_root_portlet_id, renderRequest, renderResponse)
\end{verbatim}

The configuration below contains the information for the configuration
menu (Configuration, Permissions, Look and Feel):

\begin{verbatim}
portlet_configuration_icons = portlet_configuration_icon_menu.getPortletConfigurationIcons(portlet_display_root_portlet_id, renderRequest, renderResponse)
\end{verbatim}

The rest of the file contains the HTML markup for the portlet topper and
the portlet content. It is possible to add CSS classes, change markup,
or add custom information to the \texttt{portlet.ftl}. To provide a
default style for all portlets, use the CSS classes found in this file,
in conjunction with the portlet decorators to achieve the desired look
and feel.

Portlet Decorators are explained in more detail next.

\subsection{Portlet Decorators}\label{portlet-decorators-1}

In previous versions of Liferay DXP, administrators could display or
hide the application borders through the Show Borders option of the look
and feel configuration menu. In 7.0 this option has been replaced with
Portlet Decorators, a more powerful mechanism to customize the style of
the application wrapper.

The default portlet decorators are covered next.

\subsubsection{Default Portlet
Decorators}\label{default-portlet-decorators}

Themes come bundled with three default portlet decorators in their
\texttt{liferay-look-and-feel.xml}. These are listed below:

\begin{itemize}
\item
  \texttt{Barebone}: when this decorator is applied, neither the
  wrapping box nor the custom application title are shown. This option
  is recommended when you only want to display the bare application
  content.
\item
  \texttt{Borderless}: when this decorator is applied, the application
  is no longer wrapped in a white box, but the application custom title
  is displayed at the top.
\item
  \texttt{Decorate}: this is the default Portlet Decorator when using
  the Classic theme. When this decorator is applied, the application is
  wrapped in a white box with a border and the application custom title
  is displayed at the top.
\end{itemize}

You can learn how to create and apply your own portlet decorators in the
section dedicated to
\href{/docs/7-0/tutorials/-/knowledge_base/t/portlet-decorators}{Portlet
Decorators}.

Now you know how to make your portlets stylish!

\subsection{Related Topics}\label{related-topics-194}

\href{/docs/7-0/tutorials/-/knowledge_base/t/portlet-decorators}{Portlet
Decorators}

\href{/docs/7-0/tutorials/-/knowledge_base/t/themes-and-layout-templates}{Themes
and Layout Templates}

\section{Embedding Portlets in
Themes}\label{embedding-portlets-in-themes}

One thing developers often want to do is embed a portlet in a theme.
This makes the portlet visible on all pages where the theme is used. In
the past, this was only possible by hard-coding a specific portlet into
place, which has many drawbacks. Liferay DXP provides the \emph{Portlet
Providers} framework that requires you only specify the entity type and
action to be displayed. Based on the given entity type and action,
Liferay DXP determines which deployed portlet to use. This increases the
flexibility and modularity of embedding portlets in Liferay DXP.

In this tutorial, you'll learn how to declare an entity type and action
in a custom theme, and you'll create a module that finds the correct
portlet to use based on those given parameters. You'll first learn how
to embed portlets into a theme.

\subsection{Adding a Portlet to a Custom
Theme}\label{adding-a-portlet-to-a-custom-theme}

The first thing you should do is open the template file for which you
want to declare an embedded portlet. For example, the
\texttt{portal\_normal.ftl} template file is a popular place to declare
embedded portlets. There are two ways two embed a portlet in a theme: by
class name or by portlet name. Both methods are covered in this section.

\subsubsection{Embedding a Portlet by Class
Name}\label{embedding-a-portlet-by-class-name}

To embed a portlet by class name, insert the following declaration
wherever you want to embed the portlet:

\begin{verbatim}
<@liferay_portlet["runtime"]
    portletProviderAction=ACTION
    portletProviderClassName="CLASS_NAME"
/>
\end{verbatim}

This declaration expects two parameters: the type of action and the
class name of the entity type the portlet should handle. Here's an
example of an embedded portlet declaration that uses the class name:

\begin{verbatim}
<@liferay_portlet["runtime"]
    portletProviderAction=portletProviderAction.VIEW
    portletProviderClassName="com.liferay.portal.kernel.servlet.taglib.ui.LanguageEntry"
/>
\end{verbatim}

This declares that the theme is requesting to view language entries.
Liferay DXP determines which deployed portlet to use in this case by
providing the portlet with the highest service ranking.

\noindent\hrulefill

\textbf{Note:} In some cases, a default portlet is already provided to
fulfill certain requests. You can override the default portlet with your
custom portlet by specifying a higher service rank. To do this, set the
following property in your class' \texttt{@Component} declaration:

\begin{verbatim}
 property= {"service.ranking:Integer=20"}
\end{verbatim}

Make sure you set the service ranking higher than the default portlet
being used.

\noindent\hrulefill

There are five different kinds of actions supported by the Portlet
Providers framework: \texttt{ADD}, \texttt{BROWSE}, \texttt{EDIT},
\texttt{PREVIEW}, and \texttt{VIEW}. Specify the entity type and action
in your theme's runtime declaration.

Great! Your theme declaration is complete. However, the Portal is not
yet configured to handle this request. You must create a module that can
find the portlet that fits the theme's request.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/starting-module-development\#creating-a-module}{Create
  an OSGi module}.
\item
  Create a unique package name in the module's \texttt{src} directory,
  and create a new Java class in that package. To follow naming
  conventions, name the class based on the entity type and action type,
  followed by \emph{PortletProvider} (e.g.,
  \texttt{SiteNavigationLanguageEntryViewPortletProvider}). The class
  should extend the
  \href{https://github.com/liferay/liferay-portal/blob/7.0.6-ga7/portal-kernel/src/com/liferay/portal/kernel/portlet/BasePortletProvider.java}{\texttt{BasePortletProvider}}
  class and implement the appropriate portlet provider interface based
  on the action you chose in your theme (e.g.,
  \href{https://github.com/liferay/liferay-portal/blob/7.0.6-ga7/portal-kernel/src/com/liferay/portal/kernel/portlet/ViewPortletProvider.java}{ViewPortletProvider},
  \href{https://github.com/liferay/liferay-portal/blob/7.0.6-ga7/portal-kernel/src/com/liferay/portal/kernel/portlet/BrowsePortletProvider.java}{BrowsePortletProvider},
  etc.).
\item
  Directly above the class's declaration, insert the following
  annotation:

\begin{verbatim}
 @Component(
     immediate = true,
     property = {"model.class.name=CLASS_NAME"},
     service = INTERFACE.class
 )
\end{verbatim}

  The \texttt{property} element should match the entity type you
  specified in your theme declaration (e.g.,
  \texttt{com.liferay.portal.kernel.servlet.taglib.ui.LanguageEntry}).
  Also, your \texttt{service} element should match the interface you're
  implementing (e.g., \texttt{ViewPortletProvider.class}). You can view
  an example of a similar \texttt{@Component} annotation in the
  \href{https://github.com/liferay/liferay-portal/blob/7.0.6-ga7/modules/apps/foundation/roles/roles-selector-web/src/main/java/com/liferay/roles/selector/web/internal/portlet/RolesSelectorEditPortletProvider.java}{RolesSelectorEditPortletProvider}
  class.
\item
  Specify the methods you want to implement. Make sure to retrieve the
  portlet ID and page ID that should be provided when this service is
  called by your theme.

  A common use case is to implement the \texttt{getPortletId()} and
  \texttt{getPlid(ThemeDisplay)} methods. You can view the
  \href{https://github.com/liferay/liferay-portal/blob/7.0.6-ga7/modules/apps/web-experience/site-navigation/site-navigation-language-web/src/main/java/com/liferay/site/navigation/language/web/internal/portlet/SiteNavigationLanguageViewPortletProvider.java}{SiteNavigationLanguageViewPortletProvider}
  for an example of how these methods can be implemented to provide a
  portlet for embedding in a theme. This example module returns the
  portlet ID of the Language portlet specified in
  \href{https://github.com/liferay/liferay-portal/blob/7.0.6-ga7/modules/apps/web-experience/site-navigation/site-navigation-language-api/src/main/java/com/liferay/site/navigation/language/constants/SiteNavigationLanguagePortletKeys.java}{SiteNavigationLanguagePortletKeys}.
  Furthermore, it returns the PLID, which is the ID that uniquely
  identifies a page used by your theme. By retrieving these, your theme
  will know which portlet to use, and which page to use it on.
\end{enumerate}

The only thing left to do is generate the module's JAR file and copy it
to your Portal's \texttt{osgi/modules} directory. Once the module is
installed and activated in your Portal's service registry, your embedded
portlet is available for use wherever your theme is used.

You successfully requested a portlet based on the entity and action
types required, and created and deployed a module that retrieves the
portlet and embeds it in your theme.

\subsubsection{Embedding a Portlet by Portlet
Name}\label{embedding-a-portlet-by-portlet-name}

If you'd like to embed a specific portlet in the theme, you can hard
code it by providing its instance ID and name:

\begin{verbatim}
<@liferay_portlet["runtime"]
    instanceId="INSTANCE_ID"
    portletName="PORTLET_NAME"
/>
\end{verbatim}

\noindent\hrulefill

\textbf{Note:} If your portlet is instanceable, an instance ID must be
provided; otherwise, you can remove this line. To set your portlet to
non-instanceable, set the property
\texttt{com.liferay.portlet.instanceable} in the component annotation of
your portlet to \texttt{false}.

\noindent\hrulefill

The portlet name must be the same as \texttt{javax.portlet.name}'s
value.

Here's an example of an embedded portlet declaration that uses the
portlet name to embed a web content portlet:

\begin{verbatim}
<@liferay_portlet["runtime"]
    portletName="com_liferay_journal_content_web_portlet_JournalContentPortlet"
/>
\end{verbatim}

You can also set default preferences for an application. This process is
covered next.

\subsubsection{Setting Default Preferences for an Embedded
Portlet}\label{setting-default-preferences-for-an-embedded-portlet}

Follow these steps to set default portlet preferences for an embedded
portlet:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Temporarily assign the \texttt{VOID} variable to set portlet
  preferences using the \texttt{freeMarkerPortletPreferences} object as
  shown in the example below:

\begin{verbatim}
<#assign VOID = freeMarkerPortletPreferences.setValue(
"portletSetupPortletDecoratorId", "barebone") />
\end{verbatim}
\item
  Set the \texttt{defaultPreferences} attribute to use the
  \texttt{freeMarkerPortletPreferences} object you just configured:

\begin{verbatim}
<@liferay_portlet["runtime"]
    defaultPreferences="${freeMarkerPortletPreferences}"
    portletName="com_liferay_login_web_portlet_LoginPortlet"
/>
\end{verbatim}
\item
  Once the preferences are set and passed to your portlet, reset the
  \texttt{freeMarkerPortletPreferences} object so it can be fresh for
  the next portlet:

\begin{verbatim}
<#assign VOID = freeMarkerPortletPreferences.reset() />
\end{verbatim}
\end{enumerate}

Now you know how to set default preferences for embedded portlets! Next
you can see the additional attributes you can use for your embedded
portlets.

\subsubsection{Additional Attributes for
Portlets}\label{additional-attributes-for-portlets}

Below are some additional attributes you can define for embedded
portlets:

\textbf{defaultPreferences}: A string of Portlet Preferences for the
application. This includes look and feel configurations.

\textbf{instanceId}: The instance ID for the app, if the application is
instanceable.

\textbf{persistSettings}: Whether to have an application use its default
settings, which will persist across layouts. The default value is
\emph{true}.

\textbf{settingsScope}: Specifies which settings use for the
application. The default value is \texttt{portletInstance}, but can be
set to \texttt{group} or \texttt{company}.

Now you know how to embed a portlet in your theme by class name and by
portlet name and how to configure your embedded portlet!

\subsection{Related Topics}\label{related-topics-195}

\href{/docs/7-0/tutorials/-/knowledge_base/t/providing-portlets-to-manage-requests}{Providing
Portlets to Manage Requests}

\href{/docs/7-0/tutorials/-/knowledge_base/t/portlets}{Portlets}

\href{/docs/7-0/tutorials/-/knowledge_base/t/service-builder}{Service
Builder}

\chapter{Lexicon CSS and Themes}\label{lexicon-css-and-themes}

Lexicon CSS is an extension of Bootstrap's CSS Framework. Bootstrap is
by far the most popular CSS framework on the web. Also, it's open
source, so anyone can use it. Built with Sass, Lexicon CSS fills the
front-end gaps between Bootstrap and the specific needs of Liferay DXP.

These tutorials look briefly at Lexicon CSS and show you how to use it
in your Liferay DXP themes.

\section{Importing Lexicon CSS into a
Theme}\label{importing-lexicon-css-into-a-theme}

As mentioned before, Lexicon CSS fills the gaps between Bootstrap and
the specific needs of Liferay DXP. Bootstrap features have been extended
to cover more use cases. Here are some of the new components added by
Lexicon CSS:

\begin{itemize}
\tightlist
\item
  Aspect Ratio
\item
  Cards
\item
  Dropdown Wide and Dropdown Full
\item
  Figures
\item
  Nameplates
\item
  Sidebar / Sidenav
\item
  Stickers
\item
  SVG Icons
\item
  Timelines
\item
  Toggles
\end{itemize}

Several reusable CSS patterns have also been added to help accomplish
time consuming tasks such as these:

\begin{itemize}
\tightlist
\item
  truncating text
\item
  content filling the remaining container width
\item
  truncating text inside table cells
\item
  table cells filling remaining container width and table cells only
  being as wide as their content
\item
  open and close icons inside collapsible panels
\item
  nested vertical navigations
\item
  slide out panels
\item
  notification icons/messages
\item
  vertical alignment of content
\end{itemize}

Next you can learn more about Lexicon's structure.

\subsection{Lexicon CSS Structure}\label{lexicon-css-structure}

Lexicon CSS is bundled with two sub-themes: Lexicon Base and Atlas.
Lexicon Base is Liferay DXP's Bootstrap API extension. It is also the
theme that is used in Liferay DXP's Styled Theme. It adds all the
features and components you need and inherits Bootstrap's styles. As a
result, Lexicon Base is fully compatible with third party themes that
leverage Bootstrap's Sass variable API. As a best practice, you should
use the Lexicon Base as your base theme to integrate third party themes
into Liferay DXP.

Atlas is Liferay DXP's custom Bootstrap theme that is used in the
Classic Theme. Its purpose is to overwrite and manipulate Bootstrap and
Lexicon Base to create Liferay DXP's classic look and feel. Atlas is
equivalent to installing a Bootstrap third party theme.

\noindent\hrulefill

\textbf{Note:} It is not recommended to integrate third party themes
with Atlas, as it adds variables and styles that are outside the scope
of Bootstrap's API.

\noindent\hrulefill

You can learn how to customize the Atlas theme next.

\subsection{Customizing Atlas in Liferay
DXP}\label{customizing-atlas-in-liferay-dxp}

If you want to include all the Classic Theme's files, you can skip these
steps and move on to the next section.

Follow these steps to customize the Atlas theme:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In your theme's \texttt{/src/css} directory (for legacy ant themes,
  place in \texttt{/\_diff/css}) add a file named \texttt{aui.scss} with
  the code below and save:

\begin{verbatim}
@import "aui/lexicon/atlas";
\end{verbatim}
\item
  Add a file named \texttt{\_imports.scss} with the code below and save:

\begin{verbatim}
@import "bourbon";
@import "mixins";
@import "aui/lexicon/atlas-variables";
@import "aui/lexicon/bootstrap/mixins";
@import "aui/lexicon/lexicon-base/mixins";
@import "aui/lexicon/atlas-theme/mixins";
\end{verbatim}
\item
  Add a file named \texttt{\_aui\_variables.scss} with the code below
  and save:

\begin{verbatim}
// Icon paths

$FontAwesomePath: "aui/lexicon/fonts/alloy-font-awesome/font";
$font-awesome-path: "aui/lexicon/fonts/alloy-font-awesome/font";
$icon-font-path: "aui/lexicon/fonts/";
\end{verbatim}

  All your Atlas, Bootstrap, and Lexicon Base variable modifications
  must be placed in this file.
\item
  Add a file named \texttt{\_custom.scss} with the code below and save:

\begin{verbatim}
/* Use these inject tags to dynamically create imports for 
themelet styles. You can place them where ever you like in this file. */

/* inject:imports */
/* endinject */

/* This file allows you to override default styles in one central 
location for easier upgrade and maintenance. */
\end{verbatim}
\end{enumerate}

Place your custom CSS in this file. Next you can learn how to extend
Atlas with the Classic theme.

\subsubsection{Extending Atlas with the Classic
Theme}\label{extending-atlas-with-the-classic-theme}

To extend the Atlas theme with the Classic theme, copy all the files
located in these directories into your theme:

\begin{verbatim}
frontend-theme-classic/src/css
frontend-theme-classic/src/images
frontend-theme-classic/src/js
frontend-theme-classic/src/templates
\end{verbatim}

You can also automatically copy these files into your theme using the
\href{https://github.com/liferay/liferay-theme-tasks}{Liferay Theme
Tasks} module
\href{https://github.com/liferay/liferay-theme-tasks\#kickstart}{gulp
kickstart} command and following the prompts.

Next you can learn how to customize the Lexicon Base.

\subsection{Customizing Lexicon Base}\label{customizing-lexicon-base}

You can customize Lexicon Base with just a few imports.

In your custom theme's \texttt{/src/css} directory (for legacy ant
themes, place in \texttt{/\_diff/css}) add a file named
\texttt{\_aui\_variables.scss} with the code below and save:

\begin{verbatim}
// Icon paths

    $FontAwesomePath: "aui/lexicon/fonts/alloy-font-awesome/font";
    $font-awesome-path: "aui/lexicon/fonts/alloy-font-awesome/font";
    $icon-font-path: "aui/lexicon/fonts/";
\end{verbatim}

All your Atlas, Bootstrap, and Lexicon Base variable modifications must
be placed in this file.

As mentioned earlier, any custom CSS should be placed in
\texttt{\_custom.scss}.

You can learn how to add third party themes in Liferay DXP next.

\subsection{Adding a Third Party
Theme}\label{adding-a-third-party-theme}

Third party themes must be built with Sass to be compatible with Liferay
DXP. \textbf{Make sure the Sass files are included before making any
theme purchase.}

Follow these steps to add a third party theme:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Follow the steps above in the
  \href{/docs/7-0/tutorials/-/knowledge_base/t/importing-lexicon-css-into-a-theme\#customizing-lexicon-base}{Customizing
  Lexicon Base} section.
\item
  Create a folder inside \texttt{/src/css} (for legacy ant themes,
  \texttt{/\_diff/css}) that contains your third party theme
  (e.g.~\texttt{/src/css/awesome-theme} or
  \texttt{/\_diff/css/awesome-theme})
\item
  Copy the contents of the theme to the folder you just created.
\item
  In \texttt{\_aui\_variables.scss}, import the file containing the
  theme variables. For example,
  \texttt{@import\ "awesome-theme/variables.scss";}
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** You may omit the leading underscore when importing Sass files.
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{4}
\item
  In \texttt{\_custom.scss}, import the file containing the CSS. For
  example, \texttt{@import\ "awesome-theme/main.scss";}
\item
  Deploy your theme with \texttt{gulp\ deploy} (for legacy ant themes,
  use \texttt{ant\ deploy})
\end{enumerate}

Now you know how to use Lexicon CSS in your theme!

\subsection{Related Topics}\label{related-topics-196}

\href{/docs/7-0/tutorials/-/knowledge_base/t/applying-lexicon-styles-to-your-app}{Applying
Lexicon Styles to Your App}

\chapter{Product Navigation}\label{product-navigation}

Liferay's product navigation consists of the main menus you use to
customize, configure, and navigate your Liferay instance. Whether you
edit a page, switch to a different site scope, access a user's
credentials, etc., you're constantly using the default navigation menus.
Liferay's product navigation is designed to be intuitive and extensive,
but often times, providing a customization to a default menu is
necessary to give your Liferay instance that unique touch you're
searching for. Liferay allows developers to extend and customize the
default product navigation to fit their needs.

There are four main sections of Liferay's product navigation that you
can extend: Product Menu, Control Menu, Simulation Menu, and User
Personal Bar.

\begin{figure}
\centering
\includegraphics{./images/product-navigation-summary.png}
\caption{The main product navigation menus include the Product Menu,
Control Menu, Simulation Menu, and User Personal Bar.}
\end{figure}

As you can see from the figure above, the Product Menu is the menu to
the left that displays your's instance's Control Panel, user account
settings, and Site Administration functionality. The Control Menu is the
top menu offering navigation to the Product Menu, Simulation Menu (the
right menu), and \emph{Add} button. When certain settings are enabled
(e.g., Staging, Page Customization, etc.) more tools are offered. The
Simulation Menu offers options to simulate your site's look for
different scenarios (devices, user segments, etc.). Lastly, the User
Personal Bar is used to hold selectable items that aid with a user's own
account settings.

In this section of tutorials, you'll learn about the various ways you
can extend and customize Liferay's product navigation to fit your needs.

\section{Customizing the Product
Menu}\label{customizing-the-product-menu}

Liferay's Product Menu comes with three major sections to choose from,
by default: the Control Panel, User Settings, and Site Administration.
These options are called panel categories, which is the term used to
differentiate between sections of the menu. For instance, the Control
Panel is a single panel category, and when clicking on it, you're
presented with four other child panel categories: \emph{Users},
\emph{Sites}, \emph{Apps}, and \emph{Configuration}. It you click on one
of these child panel categories, you're presented with panel apps.

\noindent\hrulefill

\textbf{Note:} The Product Menu cannot be changed by applying a new
theme. To change the layout/style of the Product Menu, you must create
and deploy a theme contributor. See the
\href{/docs/7-0/tutorials/-/knowledge_base/t/theme-contributors}{Theme
Contributors} tutorial for more details.

\noindent\hrulefill

This construction of the Product Menu was designed to be intuitive and
easy to use. For your instance of Liferay, however, you may want to add
other panel categories with custom panel apps. Also, you may desire to
change the order of your panel categories and/or apps. In this tutorial,
you'll learn how to provide your own custom or modify existing panel
categories and panel apps for the Product Menu.

\subsection{Adding Custom Panel
Categories}\label{adding-custom-panel-categories}

Liferay provides an easy way to extend the Product Menu and customize it
to display what is most helpful in your particular situation. First,
you'll learn how to add a panel category.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a generic OSGi module using your favorite third party tool, or
  use \href{/docs/7-0/tutorials/-/knowledge_base/t/blade-cli}{Blade
  CLI}. Blade CLI offers a
  \href{/docs/7-0/reference/-/knowledge_base/r/panel-app-template}{Panel
  App} template, which you can use to generate a basic panel category
  and panel app.
\item
  Create a unique package name in the module's \texttt{src} directory
  and create a new Java class in that package. To follow naming
  conventions, give your class a unique name followed by
  \emph{PanelCategory} (e.g., \texttt{ControlPanelCategory}).
\item
  Directly above the class's declaration, insert the following
  annotation:

\begin{verbatim}
 @Component(
     immediate = true,
     property = {
         "panel.category.key=" + [Panel Category Key],
         "panel.category.order:Integer=[int]"
     },
     service = PanelCategory.class
 )
\end{verbatim}

  The \texttt{property} element designates two properties that should be
  assigned for your category. The \texttt{panel.category.key} specifies
  the parent category for your custom category. You can find popular
  parent categories to assign in the
  \href{@app-ref@/web-experience/latest/javadocs/com/liferay/application/list/constants/PanelCategoryKeys.html}{PanelCategoryKeys}
  class. For instance, if you wanted to create a child category in the
  Control Panel, you could assign
  \texttt{PanelCategoryKeys.CONTROL\_PANEL}. Likewise, if you wanted to
  create a root category, like the Control Panel or Site Administration,
  you could assign \texttt{PanelCategoryKeys.ROOT}.

  The \texttt{panel.category.order:Integer} property specifies the order
  in which your category is displayed. The higher the number (integer),
  the lower your category is listed among other sibling categories
  assigned to a parent.

  Lastly, your \texttt{service} element should specify the
  \texttt{PanelCategory.class} service. You can view an example of a
  similar \texttt{@Component} annotation for the
  \texttt{UserPanelCategory} class below.

\begin{verbatim}
 @Component(
     immediate = true,
     property = {
         "panel.category.key=" + PanelCategoryKeys.ROOT,
         "panel.category.order:Integer=200"
     },
     service = PanelCategory.class
 )
\end{verbatim}
\item
  Implement the \texttt{PanelCategory} interface. A popular way to do
  this is by extending the
  \href{@app-ref@/web-experience/latest/javadocs/com/liferay/application/list/BasePanelCategory.html}{BasePanelCategory}
  or
  \href{@app-ref@/web-experience/latest/javadocs/com/liferay/application/list/BaseJSPPanelCategory.html}{BaseJSPPanelCategory}
  abstract classes. Typically, the \texttt{BasePanelCategory} is
  extended for basic categories (e.g., the Control Panel category) that
  only display the category name or other simple functionality. If you'd
  like to provide a custom UI for your panel, you can do so using any
  frontend technology, you only need to implement the methods
  \texttt{include()} or \texttt{includeHeader()} from the
  \texttt{PanelCategory} interface. The \texttt{includeHeader} method is
  used to render the header of the section and the \texttt{include}
  method is used to render the body. Implementing a custom UI gives you
  the flexibility to add more complex functionality. If you are going to
  use JSPs as the frontend technology, a base class called
  \texttt{BaseJSPPanelCategory} can be extended that already implements
  the methods \texttt{include()} and \texttt{includeHeader()} for you.
  This will be elaborated on more extensively later.
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** In this tutorial, JSPs are used to describe how to provide
 functionality to panel categories and apps. JSPs, however, are not the only
 way to provide frontend functionality to your categories/apps. You can
 create your own class implementing `PanelCategory` to use other
 technologies, such as FreeMarker.
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{4}
\item
  Since you're implementing the
  \href{@app-ref@/web-experience/latest/javadocs/com/liferay/application/list/PanelCategory.html}{PanelCategory}
  interface, you'll need to implement its methods if you're not
  extending a base class:

  \begin{itemize}
  \tightlist
  \item
    \texttt{getNotificationCount}: returns the number of notifications
    to be shown in the panel category.
  \item
    \texttt{include}: renders the body of the panel category.
  \item
    \texttt{includeHeader}: renders the panel category header.
  \item
    \texttt{isActive}: whether the panel is selected.
  \item
    \texttt{isPersistState}: whether to persist the panel category's
    state to the database. This is used to save the state of the panel
    category when navigating away from the menu.
  \end{itemize}
\item
  Add any other methods that are necessary to create your custom panel
  category. As you learned earlier, you can extend the
  \texttt{BasePanelCategory} and \texttt{BaseJSPPanelCategory} abstract
  classes to implement \texttt{PanelCategory}.

  If you'd like to provide something simple for your panel category like
  a name, extending \texttt{BasePanelCategory} is probably sufficient.
  For example, the
  \href{https://github.com/liferay/liferay-portal/blob/7.0.3-ga4/modules/apps/web-experience/product-navigation/product-navigation-control-panel/src/main/java/com/liferay/product/navigation/control/panel/internal/application/list/ControlPanelCategory.java}{ControlPanelCategory}
  extends \texttt{BasePanelCategory} and specifies a \texttt{getLabel}
  method to set and display the panel category name.

\begin{verbatim}
 @Override
 public String getLabel(Locale locale) {
     return LanguageUtil.get(locale, "control-panel");
 }
\end{verbatim}

  If you'd like to provide functionality that is more complex, you can
  use JSPs or any other similar technology to render the panel category.
  You can easily do this by extending \texttt{BaseJSPPanelCategory}. For
  example, the
  \href{https://github.com/liferay/liferay-portal/blob/7.0.3-ga4/modules/apps/web-experience/product-navigation/product-navigation-site-administration/src/main/java/com/liferay/product/navigation/site/administration/internal/application/list/SiteAdministrationPanelCategory.java}{SiteAdministrationPanelCategory}
  specifies the \texttt{getHeaderJspPath} and \texttt{getJspPath}
  methods. You could create a JSP with the UI you'd like to render and
  specify its path in methods like these:

\begin{verbatim}
 @Override
 public String getHeaderJspPath() {
     return "/sites/site_administration_header.jsp";
 }

 @Override
 public String getJspPath() {
     return "/sites/site_administration_body.jsp";
 }
\end{verbatim}

  One JSP is responsible for rendering the panel category's header
  (displayed when panel is collapsed) and the other for its body
  (displayed when panel is expanded).

  You will also need to specify the servlet context from where you are
  loading the JSP files. If this is inside an OSGi module, make sure
  your \texttt{bnd.bnd} file has defined a web context path:

\begin{verbatim}
 Bundle-SymbolicName: com.sample.my.module.web
 Web-ContextPath: /my-module-web
\end{verbatim}

  And then reference the Servlet context using the symbolic name of your
  module like this:

\begin{verbatim}
 @Override
 @Reference(
     target = "(osgi.web.symbolicname=com.sample.my.module.web)",
     unbind = "-"
 )
 public void setServletContext(ServletContext servletContext) {
     super.setServletContext(servletContext);
 }
\end{verbatim}
\end{enumerate}

Excellent! You've successfully created a custom panel category to
display in the Product Menu. In many cases, a panel category holds panel
apps for users to access. You'll learn about how to add a panel app to a
panel category next.

\subsection{Adding Custom Panel Apps}\label{adding-custom-panel-apps}

Just as adding panel categories is straight-forward and dynamic, so too
is the process for adding panel apps. Panel apps are, by default, links
provided in a panel category that allow you to access an application.
For instance, if you navigate to the Site Administration →
\emph{Content} panel category, you can select the \emph{Web Content}
option, which is a panel app that allows you to access web content.
Panel apps can also have a custom UI in the same way Panel categories
could have a more complex UI.

Follow the steps below to add a panel app to your Liferay instance's
Product Menu.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a generic OSGi module using your favorite third party tool, or
  use \href{/docs/7-0/tutorials/-/knowledge_base/t/blade-cli}{Blade
  CLI}. Blade CLI offers a
  \href{/docs/7-0/reference/-/knowledge_base/r/panel-app-template}{Panel
  App} template, which you can use to generate a basic panel category
  and panel app.
\item
  Create a unique package name in the module's \texttt{src} directory
  and create a new Java class in that package. To follow naming
  conventions, give your class a unique name followed by \emph{PanelApp}
  (e.g., \texttt{JournalPanelApp}).
\item
  Directly above the class's declaration, insert the following
  annotation:

\begin{verbatim}
 @Component(
     immediate = true,
     property = {
         "panel.app.order:Integer=INTEGER"
         "panel.category.key=" + PANEL_CATEGORY_KEY,
     },
     service = PanelApp.class
 )
\end{verbatim}

  These properties and attributes are very similar to the ones discussed
  for panel categories. The \texttt{panel.app.order:Integer} property
  specifies the order your panel app is listed among other panel apps in
  the same category. The \texttt{panel.category.key} specifies the panel
  category your panel app will reside in. For example, if you want to
  add a panel app to Site Administration → \emph{Content}, you would add
  the following property:

\begin{verbatim}
 "panel.category.key=" + PanelCategoryKeys.SITE_ADMINISTRATION_CONTENT
\end{verbatim}

  Visit the
  \href{@app-ref@/web-experience/latest/javadocs/com/liferay/application/list/constants/PanelCategoryKeys.html}{PanelCategoryKeys}
  class for keys you can use to specify default panel categories in
  Liferay.

  Lastly, be sure to set the \texttt{service} attribute to
  \texttt{PanelApp.class}. You can view an example of a similar
  \texttt{@Component} annotation for the \texttt{JournalPanelApp} class
  below.

\begin{verbatim}
 @Component(
     immediate = true,
     property = {
         "panel.app.order:Integer=100",
         "panel.category.key=" + PanelCategoryKeys.SITE_ADMINISTRATION_CONTENT
     },
     service = PanelApp.class
 )
\end{verbatim}
\item
  Implement the \texttt{PanelApp} interface. A popular way to do this is
  by extending the
  \href{@app-ref@/web-experience/latest/javadocs/com/liferay/application/list/BasePanelApp.html}{BasePanelApp}
  abstract class. Just as you learned in the previous sub-section on
  panel categories, if you need to create a more complex UI to render in
  the panel, you can do so. If you want to use JSPs to render that UI,
  you can extend an additional abstract class which extends
  \texttt{BasePanelApp} called
  \href{@app-ref@/web-experience/latest/javadocs/com/liferay/application/list/BaseJSPPanelApp.html}{BaseJSPPanelApp}.
  This provides additional methods you can use to incorporate JSP
  functionality into your app's listing in the Product Menu.

  JSPs are not the only way to provide frontend functionality to your
  panel apps. You can create your own class implementing
  \texttt{PanelCategory} to use other technologies, such as FreeMarker.
\item
  Since you're implementing the
  \href{@app-ref@/web-experience/latest/javadocs/com/liferay/application/list/PanelApp.html}{PanelApp}
  interface, you must implement its methods if you're not extending a
  base class. The \texttt{BlogsPanelApp} is a simple example of how to
  specify your portlet as a panel app. This class extends the
  \texttt{BasePanelApp}, overriding the \texttt{getPortletId} and
  \texttt{setPortlet} methods. These methods specify and set the Blogs
  portlet as a panel app.

  Each panel app must belong to a portlet and each portlet can have at
  most one panel app. If more than one panel app is needed, another
  custom portlet must be created. By default, the panel app will only be
  shown if the user has permission to view the associated portlet.

  This is how those methods look for the Blogs portlet:

\begin{verbatim}
 @Override
 public String getPortletId() {
     return BlogsPortletKeys.BLOGS_ADMIN;
 }

 @Override
 @Reference(
     target = "(javax.portlet.name=" + BlogsPortletKeys.BLOGS_ADMIN + ")",
     unbind = "-"
 )
 public void setPortlet(Portlet portlet) {
     super.setPortlet(portlet);
 }
\end{verbatim}

  Liferay DXP also lets you customize your panel app's appearance in the
  Product Menu. As you learned before, the \texttt{BaseJSPPanelApp}
  abstract class can be extended to provide further functionality with
  JSPs. For instance, the Navigation category in Site Administration
  offers a dynamic Pages panel app that provides much more than a simple
  link to access a portlet. This is accomplished by extending
  \texttt{BaseJSPPanelApp} in the
  \href{https://github.com/liferay/liferay-portal/blob/7.0.4-ga5/modules/apps/web-experience/layout/layout-admin-web/src/main/java/com/liferay/layout/admin/web/internal/application/list/GroupPagesPanelApp.java}{GroupPagesPanelApp}
  class, which provides this functionality in the Product Menu.

  In \texttt{GroupPagesPanelApp}, notice that the portlet ID is still
  returned similarly to the previous \texttt{BlogsPanelApp} example, but
  a \texttt{getJspPath} method is also called, which gives the panel app
  much more functionality provided by the \texttt{layouts\_tree} JSP
  file:

\begin{verbatim}
 @Override
 public String getJspPath() {
     return "/panel/app/layouts_tree.jsp";
 }
\end{verbatim}

  Since you're including custom JSPs in your module, you'll also need to
  set the right \texttt{ServletContext}.

\begin{verbatim}
 @Override
 @Reference(
     target = "(osgi.web.symbolicname=com.liferay.layout.admin.web)",
     unbind = "-"
 )
 public void setServletContext(ServletContext servletContext) {
     super.setServletContext(servletContext);
 }
\end{verbatim}
\end{enumerate}

Now you know how to add or modify a panel app in the Product Menu. Not
only does Liferay provide a simple solution to add new panel categories
and apps, it also gives you the flexibility to add a more complex UI to
the Product Menu using any technology.

\section{Customizing the Control
Menu}\label{customizing-the-control-menu}

The Control Menu is the most visible and accessible menu in Liferay. It
is visible to the user in most places, always displaying helpful text or
options at the top of the page. For example, on your home page, the
Control Menu offers default options for accessing the Product Menu,
Simulation Menu, and Add Menu. You can think of this menu as the gateway
to configuring options in Liferay.

\begin{figure}
\centering
\includegraphics{./images/control-menu-home.png}
\caption{The Control Menu has three configurable areas: left, right, and
middle.}
\end{figure}

If you navigate away from the home page, the Control Menu adapts and
provides helpful functionality for what ever option you're using. For
example, if you navigated to Site Administration → \emph{Content} →
\emph{Web Content}, you'd be displayed a Control Menu with different
functionality tailored for that option.

\begin{figure}
\centering
\includegraphics{./images/control-menu-web-content.png}
\caption{When switching your context to web content, the Control Menu
adapts to provide helpful options for that area.}
\end{figure}

The default Control Menu is made up of three categories that represent
the left, middle, and right portions of the menu. You can create
navigation entries for each category, which can provide options or
further navigation for the particular screen you're on.

\noindent\hrulefill

\textbf{Note:} You can add the Control Menu to a custom theme by adding
the following snippet into your \texttt{portal\_normal.ftl}:

\begin{verbatim}
 <@liferay.control_menu />
\end{verbatim}

The other product navigation menus (e.g., Product Menu, Simulation Menu)
are included in this tag, so specifying the above snippet will embed all
three menus into your theme. Embedding the User Personal Bar is slightly
different. Visit the
\href{/docs/7-0/tutorials/-/knowledge_base/t/providing-the-user-personal-bar}{Providing
the User Personal Bar} tutorial for more information.

\noindent\hrulefill

You can reference a sample Control Menu Entry by visiting the
\href{/docs/7-0/reference/-/knowledge_base/r/control-menu-entry}{Control
Menu Entry} article.

In this tutorial, you'll learn how to create your own entries to
customize the Control Menu. Make sure to read the
\href{/docs/7-0/tutorials/-/knowledge_base/t/customizing-the-product-menu\#adding-custom-panel-categories}{Adding
Custom Panel Categories} before beginning this tutorial. This tutorial
assumes you have knowledge on creating a panel category. You'll begin by
creating an entry for the Control Menu.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a generic OSGi module using your favorite third party tool, or
  use \href{/docs/7-0/tutorials/-/knowledge_base/t/blade-cli}{Blade
  CLI}. Your module must contain a Java class, \texttt{bnd.bnd} file,
  and build file (e.g., \texttt{build.gradle} or \texttt{pom.xml}).
  You'll create your Java class next if your project does not already
  define one.
\item
  Create a unique package name in the module's \texttt{src} directory
  and create a new Java class in that package. To follow naming
  conventions, give your class a unique name followed by
  \emph{ProductNavigationControlMenuEntry} (e.g.,
  \texttt{StagingProductNavigationControlMenuEntry}).
\item
  Directly above the class's declaration, insert the following
  annotation:

\begin{verbatim}
 @Component(
     immediate = true,
     property = {
         "product.navigation.control.menu.category.key=" + [Control Menu Category],
         "product.navigation.control.menu.category.order:Integer=[int]"
     },
     service = ProductNavigationControlMenuEntry.class
 )
\end{verbatim}

  The \texttt{product.navigation.control.menu.category.key} property
  specifies the category your entry should reside in. As mentioned
  previously, the default Control Menu provides three categories: Sites
  (left portion), Tools (middle portion), and User (right portion).

  \begin{figure}
  \centering
  \includegraphics{./images/control-menu-areas.png}
  \caption{This image shows where your entry will reside depending on
  the category you select.}
  \end{figure}

  To specify the category, reference the appropriate key in the
  \href{@app-ref@/web-experience/latest/javadocs/com/liferay/product/navigation/control/menu/constants/ProductNavigationControlMenuCategoryKeys.html}{ProductNavigationControlMenuCategoryKeys}
  class. For example, the following property would place your entry in
  the middle portion of the Control Menu:

\begin{verbatim}
 "product.navigation.control.menu.category.key=" + ProductNavigationControlMenuCategoryKeys.TOOLS
\end{verbatim}

  Similar to panel categories, you'll also need to specify an integer
  for the order in which your entry will be displayed in the category.
  Entries are ordered from left to right. For example, an entry with
  order \texttt{1} will be listed to the left of an entry with order
  \texttt{2}. If the order is not specified, it's chosen at random based
  on which service was registered first in the OSGi container. Lastly,
  your \texttt{service} element should specify the
  \texttt{ProductNavigationControlMenuEntry.class} service.
\item
  Implement the
  \href{@app-ref@/web-experience/latest/javadocs/com/liferay/product/navigation/control/menu/ProductNavigationControlMenuEntry.html}{ProductNavigationControlMenuEntry}
  interface. You can also extend the
  \href{@app-ref@/web-experience/latest/javadocs/com/liferay/product/navigation/control/menu/BaseProductNavigationControlMenuEntry.html}{BaseProductNavigationControlMenuEntry}
  or
  \href{@app-ref@/web-experience/latest/javadocs/com/liferay/product/navigation/control/menu/BaseJSPProductNavigationControlMenuEntry.html}{BaseJSPProductNavigationControlMenuEntry}
  abstract classes. Typically, the
  \texttt{BaseProductNavigationControlMenuEntry} is extended for basic
  entries (e.g., \texttt{IndexingProductNavigationControlMenuEntry})
  that only display a link with text or a simple icon. If you'd like to
  provide a more complex UI, like buttons or a sub-menu, you can do so
  by overriding the \texttt{include()} and \texttt{includeBody()}
  methods. If you are going to use JSPs for generating the UI, you can
  extend \texttt{BaseJSPProductNavigationControlMenuEntry} to save time.
  This will be elaborated on more extensively in the next step.
\item
  Define your Control Menu entry. You'll explore two examples to
  discover some options you have available for defining your entry.
  First, let's take a look at a simple example for providing text and an
  icon. The
  \href{https://github.com/liferay/liferay-portal/blob/7.0.3-ga4/modules/apps/foundation/portal-search/portal-search-web/src/main/java/com/liferay/portal/search/web/internal/product/navigation/control/menu/IndexingProductNavigationControlMenuEntry.java}{IndexingProductNavigationControlMenuEntry}
  extends the \texttt{BaseProductNavigationControlMenuEntry} class and
  is used when Liferay is indexing. For this process, the indexing entry
  is displayed in the \emph{Tools} (middle) area of the Control Menu
  with a \emph{Refresh} icon and text stating \emph{The Portal is
  currently indexing}. The icon is defined by calling the following
  method:

\begin{verbatim}
 @Override
 public String getIcon(HttpServletRequest request) {
     return "reload";
 }
\end{verbatim}

  By default, Lexicon icons are expected to be returned. This is because
  the
  \href{@app-ref@/web-experience/latest/javadocs/com/liferay/product/navigation/control/menu/BaseProductNavigationControlMenuEntry.html\#getMarkupView-javax.servlet.http.HttpServletRequest-}{\texttt{BaseProductNavigationControlMenuEntry.getMarkupView}
  method} returns \texttt{lexicon}. To view all the Lexicon icons
  available, see
  \url{https://liferay.github.io/clay/content/icons-lexicon/}. You can
  also return FontAwesome icons, but you must implement the
  \href{@app-ref@/web-experience/latest/javadocs/com/liferay/product/navigation/control/menu/ProductNavigationControlMenuEntry.html\#getMarkupView-javax.servlet.http.HttpServletRequest-}{ProductNavigationControlMenuEntry.getMarkupView(\ldots)}
  method in your class and have it return \texttt{null}. Then you can
  return FontAwesome icons for the \texttt{getIcon(...)} method. To view
  all the FontAwesome icons available, see the
  \href{https://fortawesome.github.io/Font-Awesome/icons/}{FontAwesome
  4.6.1 docs}.

  You can also provide a label for the Control Menu entry that displays
  when hovering over it with your pointer. This label is stored in the
  module's resource bundle, which you can learn more about in the
  \href{/docs/7-0/tutorials/-/knowledge_base/t/internationalization}{Internationalization}
  tutorials.

\begin{verbatim}
 @Override
 public String getLabel(Locale locale) {
     ResourceBundle resourceBundle = ResourceBundleUtil.getBundle(
         "content.Language", locale, getClass());

     return LanguageUtil.get(
         resourceBundle, "the-portal-is-currently-reindexing");
 }
\end{verbatim}

  To do this, you'll need to create a \texttt{Language.properties} for
  your module.

  You also have the option to provide a Lexicon or CSS icon in your
  \texttt{*ControlMenuEntry}. To use a Lexicon icon, you should override
  the methods in \texttt{ProductMenuProductNavigationControlMenuEntry}
  like the following:

\begin{verbatim}
 public String getIconCssClass(HttpServletRequest request) {
     return "";
 }

 public String getIcon(HttpServletRequest request) {
     return "lexicon-icon";
 }

 public String getMarkupView(HttpServletRequest request) {
     return "lexicon";
 }
\end{verbatim}

  Likewise, you can use a CSS icon by overriding the
  \texttt{ProductMenuProductNavigationControlMenuEntry} methods like the
  following:

\begin{verbatim}
 public String getIconCssClass(HttpServletRequest request) {
     return "icon-css";
 }

 public String getIcon(HttpServletRequest request) {
     return "";
 }

 public String getMarkupView(HttpServletRequest request) {
     return "";
 }
\end{verbatim}

  The icons used in the two examples for Lexicon and CSS icons can be
  found in the
  \href{https://liferay.github.io/clay/content/icons-lexicon/}{icons-lexicon}
  and
  \href{https://liferay.github.io/clay/content/icons-font-awesome/}{icons-font-awesome}
  components, respectively.

  The
  \href{https://github.com/liferay/liferay-portal/blob/7.0.3-ga4/modules/apps/web-experience/product-navigation/product-navigation-product-menu-web/src/main/java/com/liferay/product/navigation/product/menu/web/internal/product/navigation/control/menu/ProductMenuProductNavigationControlMenuEntry.java}{ProductMenuProductNavigationControlMenuEntry}
  is a more advanced example. This entry displays in the \emph{Sites}
  (left) area of the Control Menu, but unlike the previous example, it
  extends the \texttt{BaseJSPProductNavigationControlMenuEntry} class.
  This provides several more methods that lets you use JSPs to define
  your entry's UI. There are two methods to pay special attention to:

\begin{verbatim}
 @Override
 public String getBodyJspPath() {
     return "/portlet/control_menu/product_menu_control_menu_entry_body.jsp";
 }

 @Override
 public String getIconJspPath() {
     return "/portlet/control_menu/product_menu_control_menu_entry_icon.jsp";
 }
\end{verbatim}

  The \texttt{getIconJspPath()} method provides the Product Menu icon
  (\includegraphics{./images/icon-menu.png} →
  \includegraphics{./images/icon-menu-open.png}) and the
  \texttt{getBodyJspPath()} method adds the UI body for the entry
  outside of the Control Menu. The latter method must be used when
  providing a UI outside the Control Menu. You can easily test this when
  you open and close the Product Menu on the home page.

  Lastly, if you're planning on providing functionality that will stay
  exclusively inside the Control Menu, the
  \texttt{StagingProductNavigationControlMenuEntry} class calls its JSP
  like this:

\begin{verbatim}
 @Override
 public String getIconJspPath() {
     return "/control_menu/entry.jsp";
 }
\end{verbatim}

  In particular, the \texttt{entry.jsp} is returned, which embeds the
  Staging Bar portlet into the Control Menu.

  You will also need to specify the servlet context from where you are
  loading the JSP files. If this is inside an OSGi module, make sure
  your \texttt{bnd.bnd} file has defined a web context path:

\begin{verbatim}
 Bundle-SymbolicName: com.sample.my.module.web
 Web-ContextPath: /my-module-web
\end{verbatim}

  And then reference the Servlet context using the symbolic name of your
  module like this:

\begin{verbatim}
 @Override
 @Reference(
     target = "(osgi.web.symbolicname=com.sample.my.module.web)",
     unbind = "-"
 )
 public void setServletContext(ServletContext servletContext) {
     super.setServletContext(servletContext);
 }
\end{verbatim}
\item
  Define when to display your new entry in the Control Menu. As you've
  learned already, the Control Panel displays different entries
  depending on the page you've navigated to. You can specify when your
  entry should display using the \texttt{isShow(HttpServletRequest)}
  method.

  For example, the \texttt{IndexingProductNavigationControlMenuEntry}
  class queries the number of indexing jobs when calling
  \texttt{isShow}. If the query count is \emph{0}, then the indexing
  entry is not displayed in the Control Menu:

\begin{verbatim}
 @Override
 public boolean isShow(HttpServletRequest request) throws PortalException {
     int count = _indexWriterHelper.getReindexTaskCount(
         CompanyConstants.SYSTEM, false);

     if (count == 0) {
         return false;
     }

     return super.isShow(request);
 }
\end{verbatim}

  The \texttt{StagingProductNavigationControlMenuEntry} class is
  selective over which pages to display for. The staging entry is
  configured to never display if the page is an administration page
  (e.g., \emph{Site Administration}, \emph{My Account}, etc.):

\begin{verbatim}
 @Override
 public boolean isShow(HttpServletRequest request) throws PortalException {
     ThemeDisplay themeDisplay = (ThemeDisplay)request.getAttribute(
         WebKeys.THEME_DISPLAY);

     Layout layout = themeDisplay.getLayout();

     // This controls if the page is an Administration Page

     if (layout.isTypeControlPanel()) {
         return false;
     }

     // This controls if Staging is enabled

     if (!themeDisplay.isShowStagingIcon()) {
         return false;
     }

     return true;
 }
\end{verbatim}
\item
  Define the dependencies for your Control Menu Entry. This should be
  completed in your build file (e.g., \texttt{build.grade} or
  \texttt{pom.xml}). For example, some popular dependencies (in Gradle
  format) are defined below:

\begin{verbatim}
 dependencies {
     compileOnly group: "com.liferay", name: "com.liferay.product.navigation.control.menu.api", version: "[VERSION]"
     compile group: "com.liferay", name: "com.liferay.product.navigation.taglib", version: "[VERSION]"
     compileOnly group: "com.liferay.portal", name: "com.liferay.portal.kernel", version: "[VERSION]"
     compileOnly group: "javax.servlet", name: "javax.servlet-api", version: "[VERSION]"
     compile group: "javax.servlet.jsp", name: "javax.servlet.jsp-api", version: "[VERSION]"
     compileOnly group: "org.osgi", name: "org.osgi.service.component.annotations", version: "[VERSION]"
 }
\end{verbatim}

  Your project may require more dependencies, depending on your module's
  functionality.
\end{enumerate}

Excellent! You've created your entry in one of the three default panel
categories in the Control Menu. You learned a basic way and an advanced
way of providing that entry, and learned how to apply both.

\section{Extending the Simulation
Menu}\label{extending-the-simulation-menu}

When testing how Liferay pages and apps will appear for users, it's
critical to simulate their views on as many useful ways as possible. By
default, Liferay provides the Simulation Menu on the right-side of the
main page. What if, however, you'd like to simulate something in Liferay
that is not provided by the Simulation Menu? You'll need to extend the
Simulation Menu, of course! Luckily, Liferay offers a simple way to
extend and customize the Simulation Menu so you can test what you need.
In this tutorial, you'll learn how to add additional functionality to
the menu so you can do more simulating and less wondering.

The first thing you'll need to do is get accustomed to using panel
categories/apps. This is covered in detail in the
\href{/docs/7-0/tutorials/-/knowledge_base/t/customizing-the-product-menu}{Customizing
The Product Menu} tutorial. Once you know the difference between panel
categories and panel apps, and know how to create them, continue on in
this tutorial.

There are few differences between the Simulation Menu and Product Menu,
mostly because they extend the same base classes. The Simulation Menu,
by default, is made up of only one panel category and one panel app.
Liferay provides the
\href{https://github.com/liferay/liferay-portal/blob/7.0.6-ga7/modules/apps/web-experience/product-navigation/product-navigation-simulation-web/src/main/java/com/liferay/product/navigation/simulation/web/internal/application/list/SimulationPanelCategory.java}{SimulationPanelCategory}
class, which is a hidden category needed to hold the
\texttt{DevicePreviewPanelApp}. This is the app and functionality you
see in the Simulation Menu by default.

\begin{figure}
\centering
\includegraphics{./images/simulation-menu-preview.png}
\caption{The Simulation Menu offers a device preview application.}
\end{figure}

To provide your own functionality in the Simulation Menu, you'll need to
create a panel app in the \texttt{SimulationPanelCategory}. If you're
looking to add extensive functionality, you can even create additional
panel categories in the menu to divide up your panel apps. This tutorial
will cover the simpler case of creating a panel app for the already
present hidden category.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Follow the steps documented in the
  \href{/docs/7-0/tutorials/-/knowledge_base/t/customizing-the-product-menu\#adding-custom-panel-apps}{Adding
  Custom Panel Apps} section for creating custom panel apps. Once you've
  created the foundation of your panel app, move on to learn how to
  tweak it so it customizes the Simulation Menu.

  You can easily generate a Simulation Panel App by using Blade CLI's
  \href{/docs/7-0/reference/-/knowledge_base/r/simulation-panel-entry-template}{Simulation
  Panel Entry template}. You can also refer to the
  \href{/docs/7-0/reference/-/knowledge_base/r/simulation-panel-app}{Simulation
  Panel App sample} for a working example.
\item
  Since this tutorial assumes you're providing more functionality to the
  existing simulation category, set the simulation category in the
  \texttt{panel.category.key} of the \texttt{@Component} annotation:

\begin{verbatim}
 "panel.category.key=" + SimulationPanelCategory.SIMULATION
\end{verbatim}

  In order to use this constant, you need to add a dependency on
  \href{https://repository.liferay.com/nexus/content/repositories/liferay-public-releases/com/liferay/com.liferay.product.navigation.simulation/}{com.liferay.product.navigation.simulation}.
  Be sure to also specify the order you'd like to display your new panel
  app, which was explained in the
  \href{/docs/7-0/tutorials/-/knowledge_base/t/customizing-the-product-menu\#adding-custom-panel-apps}{Adding
  Custom Panel Apps} section.
\item
  This tutorial assumes you're using JSPs for creating a complex UI.
  Therefore, you should extend the
  \href{@app-ref@/web-experience/latest/javadocs/com/liferay/application/list/BaseJSPPanelApp.html}{BaseJSPPanelApp}
  abstract class. This class implements the
  \href{@app-ref@/web-experience/latest/javadocs/com/liferay/application/list/PanelApp.html}{PanelApp}
  interface and also provides additional methods necessary for
  specifying JSPs to render your panel app's UI. Remember that you can
  also implement your own \texttt{include()} method to use any frontend
  technology you want, if you'd like to use a technology other than JSP
  (e.g., FreeMarker).
\item
  Define your simulation view. For instance, in
  \texttt{DevicePreviewPanelApp}, the \texttt{getJspPath} method points
  to the \texttt{simulation-device.jsp} file in the
  \texttt{resources/META-INF/resources} folder, where the device
  simulation interface is defined. Optionally, you can also add your own
  language keys, CSS, or JS resources in your simulation module.

  The right servlet context is also provided implementing this method:

\begin{verbatim}
 @Override
 @Reference(
     target = "(osgi.web.symbolicname=com.liferay.product.navigation.simulation.device)",
     unbind = "-"
 )
 public void setServletContext(ServletContext servletContext) {
     super.setServletContext(servletContext);
 }
\end{verbatim}

  As explained in
  \href{/docs/7-0/tutorials/-/knowledge_base/t/customizing-the-product-menu}{Customizing
  The Product Menu}, a panel app should be associated with a portlet.
  This makes the panel app visible only when the user has permission to
  view the portlet. This panel app is associated to the Simulation
  Device portlet using these methods:

\begin{verbatim}
 @Override
 public String getPortletId() {
     return ProductNavigationSimulationPortletKeys.
         PRODUCT_NAVIGATION_SIMULATION;
 }

 @Override
 @Reference(
     target = "(javax.portlet.name=" + ProductNavigationSimulationPortletKeys.PRODUCT_NAVIGATION_SIMULATION + ")",
     unbind = "-"
 )
 public void setPortlet(Portlet portlet) {
     super.setPortlet(portlet);
 }
\end{verbatim}

  Audience Targeting also provides a good example of how to extend the
  Simulation Menu. When the Audience Targeting app is deployed, the
  Simulation Menu is extended to offer more functionality, in
  particular, for Audience Targeting User Segments and Campaigns. You
  can simulate particular scenarios for campaigns and users directly
  from the Simulation Menu. Its panel app class is very similar to
  \texttt{DevicePreviewPanelApp}, except it points to a different
  portlet and JSP.

  \begin{figure}
  \centering
  \includegraphics{./images/simulation-menu-at.png}
  \caption{The Audience Targeting app extends the Simulation Menu to
  help simulate different users and campaign views.}
  \end{figure}
\item
  You can combine your simulation options with the device simulation
  options by interacting with the device preview iFrame. To retrieve the
  device preview frame in an \texttt{aui:script} block of your custom
  simulation view's JavaScript, you can use the following:

\begin{verbatim}
 var iframe = A.one('#simulationDeviceIframe');
\end{verbatim}

  Then you can modify the device preview frame URL like this:

\begin{verbatim}
 iframe.setAttribute('src', newUrlWithCustomParameters);
\end{verbatim}
\end{enumerate}

Now that you know how to extend the necessary panel categories and panel
apps to modify the Simulation Menu, go ahead and
\href{/docs/7-0/tutorials/-/knowledge_base/t/starting-module-development\#creating-a-module}{create
a module} of your own and customize the Simulation Menu so it's most
helpful for your needs.

\section{Providing the User Personal
Bar}\label{providing-the-user-personal-bar}

Liferay offers a touch of personability with the User Personal Bar. This
navigation menu is used to display options that are unique to the
current logged in user. By default, Liferay displays this menu as a
simple avatar button that expands the User Settings sub-menu in the
Product Menu.

\begin{figure}
\centering
\includegraphics{./images/user-personal-bar.png}
\caption{By default, the User Personal Bar contains the signed-in user's
avatar, which navigates to the Product Menu when selected.}
\end{figure}

Although Liferay's default usage of the User Personal Bar is bare-bones,
you can add more functionality to the user bar to fit your needs. Unlike
other product navigation menus (e.g., Product Menu), the User Personal
Bar does not require the extension/creation of panel categories and
panel apps. It uses another common Liferay framework for providing
functionality:
\href{/docs/7-0/tutorials/-/knowledge_base/t/providing-portlets-to-manage-requests}{Portlet
Providers}. Be sure to visit the linked tutorial to learn about how the
Portlet Providers framework works in Liferay.

The User Personal Bar can be seen as a placeholder in every Liferay
theme. By default, Liferay provides one sample \emph{User Personal Bar}
portlet that fills that placeholder, but the portlet Liferay provides
can be easily replaced by other portlets.

\noindent\hrulefill

\textbf{Note:} You can add the User Personal Bar to a custom theme by
adding the following snippet into your \texttt{portal\_normal.ftl}:

\begin{verbatim}
 <@liferay.user_personal_bar />
\end{verbatim}

\noindent\hrulefill

In this tutorial, you'll learn how to customize the User Personal Bar.
You'll create a single Java class where you'll specify a portlet to
replace the existing default portlet.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/starting-module-development\#creating-a-module}{Create
  an OSGi module}.
\item
  Create a unique package name in the module's \texttt{src} directory
  and create a new Java class in that package.
\item
  Directly above the class's declaration, insert the following
  annotation:

\begin{verbatim}
 @Component(
     immediate = true,
     property = {
         "model.class.name=" + PortalUserPersonalBarApplicationType.UserPersonalBar.CLASS_NAME,
         "service.ranking:Integer=10"
     },
     service = ViewPortletProvider.class
 )
\end{verbatim}

  The \texttt{model.class.name} property must be set to the class name
  of the entity type you want the portlet to handle. In this case, you
  want your portlet to be provided based on whether or not it can be
  displayed in the User Personal Bar. You may recall from the
  \href{/docs/7-0/tutorials/-/knowledge_base/t/providing-portlets-to-manage-requests}{Portlet
  Providers} tutorial that you can request portlets in several different
  ways (e.g., \emph{Edit}, \emph{Browse}, etc.).

  You should also specify the service rank for your new portlet so it
  overrides the default one provided by Liferay DXP. Make sure to set
  the \texttt{service.ranking:Integer} property to a number that is
  ranked higher than the portlet being used by default.

  Since you're only wanting the User Personal Bar to display your
  portlet, you'll always have the \texttt{service} element be
  \texttt{ViewPortletProvider.class}.
\item
  Update the class's declaration to extend the
  \href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/BasePortletProvider.html}{BasePortletProvider}
  abstract class and implement \texttt{ViewPortletProvider}:

\begin{verbatim}
public class ExampleViewPortletProvider extends BasePortletProvider implements ViewPortletProvider {
\end{verbatim}
\item
  Specify the portlet you'd like to provide in the User Personal Bar by
  declaring the following method in your class:

\begin{verbatim}
 @Override
 public String getPortletName() {
     return PORTLET_NAME;
 }
\end{verbatim}

  You should replace the \texttt{PORTLET\_NAME} text with the portlet
  you want to provide Liferay when it requests one to be viewed in the
  User Personal Bar. For example, Liferay declares
  \texttt{com\_liferay\_product\_navigation\_user\_personal\_bar\_web\_portlet\_ProductNavigationPersonalBarPortlet}
  for its default User Personal Bar portlet.
\end{enumerate}

You've successfully provided a portlet to be displayed in the User
Personal Bar. If you'd like to inspect the entire module used for
Liferay's default User Personal Bar, see
\href{https://github.com/liferay/liferay-portal/tree/7.0.2-ga3/modules/apps/web-experience/product-navigation/product-navigation-user-personal-bar-web}{product-navigation-user-personal-bar-web}.
Besides the \texttt{*ViewPortletProvider} class, this module contains
two classes defining constants and a portlet class defining the default
portlet to provide. Although these additional classes are not required,
your module should have access to the portlet you want to provide.

\chapter{Testing}\label{testing}

Assuring top quality is paramount in producing awesome software. Test
driven development plays a key role in this process. Liferay's tooling
and integration with standard test frameworks support test driven
development and help you reach quality milestones. Here are the ways
Liferay facilitates testing:

\begin{itemize}
\tightlist
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/unit-testing-with-junit}{Unit
  testing}: Using JUnit to unit test Liferay DXP modules in Gradle and
  Maven build environments and in IDEs that have JUnit plugins is
  seamless.
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/arquillian-integration-test-example}{Integration
  testing}: The
  \href{/docs/7-0/tutorials/-/knowledge_base/t/arquillian-extension-for-liferay-example}{Arquillian
  Extension for Liferay} lets you spin up a Liferay DXP instance, deploy
  modules whose components provide and consume services, and exercise
  their APIs.
  \href{/docs/7-0/tutorials/-/knowledge_base/t/injecting-service-components-into-tests}{Liferay's
  \texttt{@Inject} annotation} allows you to inject service instances
  into tests.
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/arquillian-functional-test-example}{Functional
  testing}: Selenium and the Arquillian Extension for Liferay support
  functional UI testing.
\item
  Code Coverage: JaCoCo analyzes and reports test code coverage.
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-slim-runtime}{Slim
  Runtime}: Liferay Slim Runtime facilitates testing modules (including
  Service Builder modules) in a fast, lightweight environment.
\end{itemize}

Unit testing is the first step in test driven development.

\section{Unit Testing with JUnit}\label{unit-testing-with-junit}

Test driven development is a best practice for any developer. Unit tests
verify and validate functionality of classes and methods in isolation by
``mocking'' external dependencies. One of the most widely-used tools for
test driven development on the Java platform is JUnit. You can use the
\href{http://junit.org}{JUnit} framework to write unit tests for Liferay
DXP applications.

JUnit integrates with build environments such as Maven and Gradle. JUnit
plugins are available in IDEs such as Eclipse, IntelliJ, and NetBeans.
And of course,
\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-workspace}{Liferay
Workspace} supports running JUnit tests.

This tutorial covers the following topics:

\begin{itemize}
\item
  \hyperref[writing-good-tests]{Writing good tests}
\item
  \hyperref[understanding-junit-annotations]{JUnit annotations}
\item
  \hyperref[creating-a-junit-test-class]{Creating JUnit test classes}
\item
  \hyperref[running-junit-tests]{Running JUnit tests}
\end{itemize}

You'll start by learning best practices for writing unit tests.

\subsection{Writing Good Tests}\label{writing-good-tests}

To write good tests, developers must understand assertions and follow
best practices.

\textbf{Assertion}: an executable specification of the expected behavior
of the software under test (SUT) given a scenario. The tests define the
behavior in the scenario using several methods: a test setup method, a
class setup method, and a test method. It's \emph{executable} because it
programmatically checks behavior and tracks requirements.

\textbf{Best Practices for Unit Tests:}

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.7812}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.2188}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Rule
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Description
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
A test should have only one reason to fail. & Resolving failures from a
single root cause is easiest. \\
A test should check just one thing. & Tests that verify or validate one
thing are easier to understand and maintain. Focusing on multiple things
can lead to multiple failure points, thus breaking the \emph{one reason
to fail} rule. \\
Avoid conditional logic in tests. & Conditional test logic that uses
loops or if/else clauses increases the probability of test bugs. \\
A test that asserts nothing or cannot fail is worthless. & Tests that
can't fail create a false sense of security.Here's example test code
that can't
fail:\texttt{File\ f\ =\ new\ File\ ("foo");}\texttt{Assert.assertTrue(f\ !=\ null);} \\
A test that inaccurately advertises what it asserts is untrustworthy & A
test's name should accurately express what it tests. A name that's
inaccurate or that promises more than what the test does creates
confusion.
\texttt{@Test}\texttt{public\ void\ testAddUser()\ \{\ //\ do\ something\ not\ related\ to\ user\ creation\ \}} \\
\end{longtable}

Next, you'll learn JUnit's annotations for test methods.

\subsection{Understanding JUnit
Annotations}\label{understanding-junit-annotations}

The following table describes the JUnit method annotations.

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.6585}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.3415}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Method signature
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Description
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{@BeforeClass}\texttt{public\ static\ void\ method()} & The
method is invoked once, before the class's entire suite of tests is
executed. It should prepare the general test environment. \\
\texttt{@Before}\texttt{public\ void\ method()} & The method is invoked
before each test. It should prepare the environment for each test. \\
\texttt{@Test}\texttt{public\ void\ method()} & Marks the method as a
test. \\
\texttt{@Test\ (expected\ =\ SomeException.class)}\texttt{public\ void\ method()}
& The test fails if the method doesn't throw the exception. \\
\texttt{@After}\texttt{public\ void\ method()} & The method is invoked
after each test. It should clean up the environment. \\
\texttt{@AfterClass}\texttt{public\ static\ void\ method()} & The method
is invoked once, after the class's entire suite of tests is executed. It
should cleanup the general test environment. \\
\texttt{@Ignore\ or\ @Ignore("Why\ disabled")}\texttt{public\ void\ method()}
& The method is skipped. Adding the \texttt{@Ignore} annotation is an
easy way to skip a test. The message (optional) can explain why the test
is being ignored. \\
\end{longtable}

JUnit follows the algorithm below to execute the test class's methods.

\begin{figure}
\centering
\includegraphics{./images/junit-test-flow.png}
\caption{JUnit executes the annotated methods following this algorithm.}
\end{figure}

Let's create a JUnit test class.

\subsection{Creating a JUnit Test
Class}\label{creating-a-junit-test-class}

Here you'll create a JUnit test class and fill it with methods that both
set up/clean up the test environment and assert the software's expected
behavior.

To help illustrate creating unit tests, here's an example class to test:

\begin{verbatim}
public class MySampleNameClass {

   public MySampleNameClass(String firstName, String middleName, String lastName) {
      _firstName = firstName;
      _middleName = middleName;
      _lastName = lastName;
   }

   public int fullNameLength() {
      return _firstName.length() + _middleName.length() + _lastName.length();
   }

   public String getMiddleInitial() {
      return _middleName.charAt(0) + ".";
   }

   @Override
   public String toString() {
      return _firstName + " " + getMiddleInitial() + " " + _lastName;
   }

   private String _firstName;
   private String _middleName;
   private String _lastName;

}
\end{verbatim}

In the sections that follow, you'll see setup, cleanup, and test methods
that relate to this example class.

Create a test class:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open the module of the class you're testing.
\item
  Add a \texttt{src/test/java/} folder to the module.
\item
  In that folder, create a package path (ending in \texttt{test}) that
  mirrors the package path of the class you're testing.

  For example, if the class is in package \texttt{com.sample}, add a
  test package \texttt{com.sample.test}.
\item
  In that package, create a test class that ends in \texttt{Test} (e.g.,
  \texttt{SomeTest.java}).
\end{enumerate}

Your new test class is ready for test methods.

\begin{figure}
\centering
\includegraphics{./images/junit-project-structure.png}
\caption{In this example module, the JUnit test class is in the same
module of the class it tests. The test class resides in a source folder
and package following standard test structure conventions.}
\end{figure}

Now create methods in the order of test flow execution.

\subsubsection{@BeforeClass}\label{beforeclass}

Identify resources or computationally expensive tasks that must be
completed prior to running all the tests. Create a method that
initializes these resources and invokes these tasks. Apply the
\texttt{@BeforeClass} annotation to the method.

\subsubsection{@Before}\label{before}

Consider what needs to be done before running each individual test.
Create a method that makes small preparations before each test case. Add
the \texttt{@Before} annotation to the method.

For example, each of the tests for the class \texttt{MySampleNameClass}
operate on a populated \texttt{MySampleNameClass} object. Implementing a
method that instantiates such an object beforehand is appropriate.
Adding the \texttt{@Before} annotation to the method ensures it's
executed before each individual test.

Here's what the \texttt{MySampleNameClassTest} class might look like
with such a method:

\begin{verbatim}
public class MySampleNameClassTest {

   @Before
   public void setUp() {
      _mySampleNameClass = new MySampleNameClass("Brian", "Edward", "Greenwald");
   }

   private MySampleNameClass _mySampleNameClass;

}
\end{verbatim}

\textbf{Note}: Since this example class is immutable, it might make more
sense to instantiate the object once in the \texttt{@BeforeClass} method
and forgo the \texttt{@Before} method. It's probably more typical,
however, that you'll be testing methods that change an object's state;
so pretend this example object must be instantiated anew before each
\texttt{@Test} method.

Now that you've instantiated objects each test needs, you can add
\texttt{@Test} methods to assert expected output from the object's
methods.

\subsubsection{@Test}\label{test}

JUnit's
\href{http://junit.org/junit4/javadoc/latest/org/junit/Assert.html}{\texttt{Assert}
utility class} contains static methods for comparing actual test results
with expected results. When an assertion fails, an
\texttt{AssertionException} is thrown and the test fails. If a test
method completes execution without throwing an exception, the test
succeeds.

For tests that contain a large amount of logic it's typically a best
practice to use multiple assertions within the test to better identify
the earliest point of failure. But since the example class is fairly
simple, it's better to create a test for each of its methods:

\begin{verbatim}
@Test
public void testFullNameLength() {
   int length = _mySampleNameClass.fullNameLength();

   Assert.assertEquals(20, length);
}

@Test
public void testGetMiddleInitial() {
   String middleInitial = _mySampleNameClass.getMiddleInitial();

   Assert.assertEquals("E.", middleInitial);
}

@Test
public void testToString() {
   String fullName = _mySampleNameClass.toString();

   Assert.assertEquals("Brian E. Greenwald", fullName);
}
\end{verbatim}

Since you know the test input (e.g., the parameters passed into the
\texttt{MySampleNameClass} constructor), you can easily determine
expected output. You can compare the computed value each method
invocation returns with the expected value.

To test that a method throws a particular exception when given certain
invalid inputs, add an \texttt{expected} attribute to the \texttt{@Test}
annotation and assign the attribute the expected exception's class name.
Important: refrain from making any assertions in the test method.

\begin{verbatim}
@Test(expected = MySampleException.class)
public void testToString() {
   String fullName = _mySampleNamenClass.toString();
}
\end{verbatim}

\textbf{Warning}: Each test method should be independent. Since JUnit
doesn't guarantee test order, you can't rely on a test being run before
or after other tests.

\subsubsection{@After}\label{after}

On finishing each individual test, you should clean up anything that was
created or modified. Implement the cleanup instructions in a method and
add the \texttt{@After} annotation to it.

\subsubsection{@AfterClass}\label{afterclass}

On finishing the entire set of tests, you should clean up any remaining
test environment resources. Implement the final cleanup instructions in
a method and add the \texttt{@AfterClass} annotation to it.

It's time to compile and run your JUnit tests.

\subsection{Running JUnit Tests}\label{running-junit-tests}

Unit testing involves these things:

\begin{itemize}
\item
  Resolving test dependencies
\item
  Executing the tests
\item
  Analyzing test results
\end{itemize}

Add JUnit as a dependency. Here's a dependency on JUnit in Gradle:

\begin{verbatim}
testCompile group: "junit", name: "junit", version: "4.12"
\end{verbatim}

If your tests require accessing classes outside the module, declare them
as \texttt{testCompile}
\href{/docs/7-0/tutorials/-/knowledge_base/t/configuring-dependencies}{dependencies}
in the module's \texttt{build.gradle} file. Here's an example
\texttt{testCompile} dependency.

\begin{verbatim}
testCompile group: "com.sample", name: "com.sample.external", version: "1.0.0"
\end{verbatim}

Because unit tests run independent of any running Liferay DXP instance,
you can use external modules in tests but can't access their services.

Gradle and Maven commands execute module unit tests:

\textbf{Gradle}: \texttt{./gradlew\ test}

\textbf{Maven}: \texttt{mvn\ test}

The module's classes and tests compile and its tests run. The following
figure shows command output for a successful test execution.

\begin{figure}
\centering
\includegraphics{./images/junit-command-output.png}
\caption{Command output of successful test execution looks like this.}
\end{figure}

Reports are generated to module subfolders based on the build
environment and/or reporting mechanism.

\textbf{Gradle}:

\begin{itemize}
\tightlist
\item
  HTML report \texttt{build/reports/tests/index.html}
\item
  XML report file in \texttt{build/test-results/}
\end{itemize}

\textbf{Maven}:

\begin{itemize}
\tightlist
\item
  \href{http://maven.apache.org/surefire/maven-surefire-plugin/}{SureFire
  plugin} generates XML and text report files in
  \texttt{targets/surefire-reports/}
\end{itemize}

Gradle's HTML report, for example, shows overall test metrics and
organizes test results by package. Clicking on a package name lists test
class results. Clicking on a test class name lists test method results.

\begin{figure}
\centering
\includegraphics{./images/junit-results-html.png}
\caption{In Gradle environments, JUnit produces an HTML file named
\texttt{index.html} that reports test result details.}
\end{figure}

While it's certainly helpful to see successful test results, it's even
more helpful to see results of failing tests.

As an experiment, change the expected values of a test's assertions to
force the test to fail and rerun the tests to yield the respective
failures.

\begin{figure}
\centering
\includegraphics{./images/junit-failure-command-output.png}
\caption{Command output of failing tests looks like this.}
\end{figure}

The command output shows the class and method name of each failed test,
the JUnit assertion type, and the assertion's line number.

The generated HTML report shows each failing test's stack trace.

\begin{figure}
\centering
\includegraphics{./images/junit-failure-results-html.png}
\caption{Here's a failed test's stack trace.}
\end{figure}

Stack traces show exactly why the test failed. They're essential for
determining whether the failure is the result of faulty business logic
or an incorrect expected value in the assertion. Using this information
the developer can resolve the issue.

Congratulations on creating and executing unit tests with JUnit!

\subsection{Related Topics}\label{related-topics-197}

\href{/docs/7-0/tutorials/-/knowledge_base/t/arquillian-extension-for-liferay-example}{Integration
Testing with the Arquillian Extension}

\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-workspace}{Liferay
Workspace}

\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-ide}{Liferay @ide@}

\chapter{Arquillian Extension for Liferay
Example}\label{arquillian-extension-for-liferay-example}

\href{http://arquillian.org}{Arquillian} is an extensible Java testing
platform that's designed to make integration testing easy. Arquillian
manages the lifecycle of setting up, starting, or connecting to a
container (e.g., Tomcat), packaging your test cases and any dependent
classes or resources, deploying them to the container, running the tests
in the container, and capturing and reporting the results. The
\href{https://github.com/arquillian/arquillian-extension-liferay}{Arquillian
Extension for Liferay} is a set of tools designed to help developers
test their Liferay plugins.

The
\href{https://github.com/liferay-labs/arquillian-blade-example}{Arquillian
Blade Example project} demonstrates performing integration and
functional tests using the
\href{https://github.com/liferay-labs/arquillian-liferay}{Arquillian
Liferay Extension}. Additionally it measures code coverage using
\href{http://eclemma.org/jacoco/}{JaCoCo}. In this tutorial, you'll
learn how the Arquillian Liferay Extension and JaCoCo work. You can
download the Arquillian Blade Example project
\href{https://portal.liferay.dev/documents/113763090/114000186/arquillian-blade-example.zip}{here}
or access its latest code on
\href{https://github.com/liferay-labs/arquillian-blade-example}{GitHub}.

Here are the tutorial sections:

\begin{itemize}
\tightlist
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/arquillian-example-sample-portlet}{Arquillian
  Sample Portlet}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/arquillian-integration-test-example}{Arquillian
  Integration Test Example}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/arquillian-functional-test-example}{Arquillian
  Functional Test Example}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/jacoco-code-coverage-example}{JaCoCo
  Code Coverage Example}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/running-the-arquillian-example}{Running
  the Arquillian Example}
\end{itemize}

\section{Arquillian Example Sample
Portlet}\label{arquillian-example-sample-portlet}

The sample portlet calculates the sum of two numbers.

\begin{figure}
\centering
\includegraphics{./images/arquillian-example-portlet.png}
\caption{The Arquillian Sample Portlet calculates the sum of two
numbers.}
\end{figure}

The portlet project comprises a portlet class, service classes, and
JSPs. It follows the standard OSGi module folder structure with Java
files in \texttt{src/main/java/}, resource files in
\texttt{src/main/resources/META-INF/resources}, and build files in the
project root.

Here are the primary files:

\begin{itemize}
\item
  \href{https://github.com/liferay-labs/arquillian-blade-example/blob/master/src/main/java/com/liferay/arquillian/sample/service/SampleService.java}{\texttt{SampleService.java}}:
  Provides an interface that defines method
  \texttt{public\ long\ add(final\ int\ \ \ \ \ addend1,\ final\ int\ addend2)}
  for returning the sum of two numbers.
\item
  \href{https://github.com/liferay-labs/arquillian-blade-example/blob/master/src/main/java/com/liferay/arquillian/sample/service/SampleServiceImpl.java}{\texttt{SampleServiceImpl.java}}:
  Uses OSGi Declarative Services to implement the \texttt{SampleService}
  interface.
\item
  \href{https://github.com/liferay-labs/arquillian-blade-example/blob/master/src/main/java/com/liferay/arquillian/sample/portlet/SamplePortlet.java}{\texttt{SamplePortlet.java}}:
  Extends
  \href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/bridges/mvc/MVCPortlet.html}{Liferay
  \texttt{MVCPortlet}} and processes portlet action commands and renders
  the result of executing the \texttt{add} service.
\item
  \href{https://github.com/liferay-labs/arquillian-blade-example/blob/master/bnd.bnd}{\texttt{bnd.bnd}}:
  Specifies the module's name, symbolic name, and version.
\item
  \href{https://github.com/liferay-labs/arquillian-blade-example/blob/master/src/main/resources/META-INF/resources/init.jsp}{\texttt{init.jsp}}:
  Imports classes and tag libraries for the view layer.
\item
  \href{https://github.com/liferay-labs/arquillian-blade-example/blob/master/src/main/resources/META-INF/resources/view.jsp}{\texttt{view.jsp}}:
  Provides a form for calculating the sum of two numbers.
\end{itemize}

You'll examine the tests next.

\section{Arquillian Integration Test
Example}\label{arquillian-integration-test-example}

Integration tests exercise module interaction. The following integration
test validates the sample portlet using its API. Although the example's
\texttt{BasicPortletIntegrationTest} class demonstrates invoking the
sample module's \texttt{SampleService.add} method only, an Arquillian
integration test could just as easily invoke many methods to test
behavior across many modules. The test classes are in the
\texttt{src/testIntegration/java} folder and test resources are in the
\texttt{src/testIntegration/resources} folder.

Here's the \texttt{BasicPortletIntegrationTest} class:

\begin{verbatim}
package com.liferay.arquillian.test;

import com.google.common.io.Files;

import com.liferay.arquillian.containter.remote.enricher.Inject;
import com.liferay.arquillian.sample.service.SampleService;
import com.liferay.portal.kernel.exception.PortalException;

import java.io.File;
import java.io.IOException;

import org.jboss.arquillian.container.test.api.Deployment;
import org.jboss.arquillian.junit.Arquillian;
import org.jboss.shrinkwrap.api.ShrinkWrap;
import org.jboss.shrinkwrap.api.spec.JavaArchive;

import org.junit.Assert;
import org.junit.Test;
import org.junit.runner.RunWith;

@RunWith(Arquillian.class)
public class BasicPortletIntegrationTest {

    @Deployment
    public static JavaArchive create() throws Exception {
        final File tempDir = Files.createTempDir();

        String gradlew = "./gradlew";

        String osName = System.getProperty("os.name", "");
        if (osName.toLowerCase().contains("windows")) {
            gradlew = "./gradlew.bat";
        }

        final ProcessBuilder processBuilder = new ProcessBuilder(
            gradlew, "jar", "-Pdir=" + tempDir.getAbsolutePath());

        final Process process = processBuilder.start();

        process.waitFor();

        final File jarFile = new File(
            tempDir.getAbsolutePath() +
                "/com.liferay.arquillian.sample-1.0.0.jar");

        return ShrinkWrap.createFromZipFile(JavaArchive.class, jarFile);
    }

    @Test
    public void testAdd() throws IOException, PortalException {
        final long result = _sampleService.add(1, 3);

        Assert.assertEquals(4, result);
    }

    @Inject
    private SampleService _sampleService;

}
\end{verbatim}

JUnit annotation \texttt{@RunWith(Arquillian.class)} marks the class for
Arquillian to execute.

The \texttt{create} method packages the test class and resources in a
Java archive (JAR). Invoking the project's \texttt{jar} Gradle task
creates the test JAR Arquillian executes.

\begin{verbatim}
@Deployment
public static JavaArchive create() throws Exception {
    final File tempDir = Files.createTempDir();

    final ProcessBuilder processBuilder = new ProcessBuilder(
        "./gradlew", "jar", "-Pdir=" + tempDir.getAbsolutePath());

    final Process process = processBuilder.start();

    process.waitFor();

    final File jarFile = new File(
        tempDir.getAbsolutePath() +
            "/com.liferay.arquillian.sample-1.0.0.jar");

    return ShrinkWrap.createFromZipFile(JavaArchive.class, jarFile);
}
\end{verbatim}

JUnit annotation \texttt{@Test} designates the \texttt{testAdd} method
as a test. The method invokes the \texttt{SampleService} object's
\texttt{add} method and asserts its result.

\begin{verbatim}
@Test
public void testAdd() throws IOException, PortalException {
    final long result = _sampleService.add(1, 3);

    Assert.assertEquals(4, result);
}
\end{verbatim}

The Liferay Arquillian Extension injects the \texttt{\_sampleService}
field with a \texttt{SampleService} implementation (i.e., a
\texttt{SampleServiceImpl} instance).

\begin{verbatim}
@Inject
private SampleService _sampleService;
\end{verbatim}

The integration test has some dependencies, of course.

\subsection{Dependencies}\label{dependencies}

The project's \texttt{build.gradle} file specifies this test's
dependencies on Liferay's Arquillian container, JUnit, and an Arquillian
JUnit test container:

\begin{verbatim}
testIntegrationCompile group: "com.liferay.arquillian", name: "com.liferay.arquillian.arquillian-container-liferay", version: "1.0.6"
testIntegrationCompile group: "junit", name: "junit", version: "4.12"
testIntegrationCompile group: "org.jboss.arquillian.junit", name: "arquillian-junit-container", version: "1.1.11.Final"
\end{verbatim}

Arquillian tests are configurable too.

\subsection{Arquillian Configuration}\label{arquillian-configuration}

Arquillian configuration file
\texttt{src/testIntegration/resources/arquillian.xml} uses property
\texttt{deploymentExportPath} (optional) to write a test archive (e.g.,
JAR file) to a folder before deploying the tests. You can inspect all
the test files from this archive. To highlight the
\texttt{deploymentExportPath} property, here's an abbreviated view of
the
\href{https://github.com/liferay-labs/arquillian-blade-example/blob/master/src/testIntegration/resources/arquillian.xml}{\texttt{arquillian.xml}
file}:

\begin{verbatim}
<?xml version="1.0" encoding="UTF-8"?>
<arquillian xmlns="http://jboss.org/schema/arquillian"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://jboss.org/schema/arquillian http://jboss.org/schema/arquillian/arquillian_1_0.xsd">

    <!-- More content here -->

    <engine>
        <property name="deploymentExportPath">build/deployments</property>
    </engine>
</arquillian>
\end{verbatim}

The project uses Java Management Extensions (JMX) to deploy OSGi modules
to Liferay DXP. Enabling JMX for the application server is next.

\subsection{JMX Settings}\label{jmx-settings}

Apache Aries JMX exposes the JMX API that Arquillian uses to
install/deploy/start the modules. Since DXP Digital Enterprise 7.0 Fix
Pack 16 and Liferay CE 7.0 GA4, Liferay Workspace's
\texttt{startTestableTomcat} Gradle task installs the Apache Aries JMX
modules automatically. In case you're using an earlier Liferay DXP
version or haven't already installed the Aries modules, here's their
group ID, artifact ID, and version information. You can install them
using
\href{/docs/7-0/reference/-/knowledge_base/r/using-the-felix-gogo-shell}{Apache
Felix GoGo Shell}:

\begin{verbatim}
"org.apache.aries.jmx:org.apache.aries.jmx:1.1.5"
"org.apache.aries:org.apache.aries.util:1.1.3"
\end{verbatim}

JMX is enabled on the application server via Java runtime options. The
following Apache Tomcat environment script excerpts demonstrate enabling
JMX (without authentication) on port 8099.

\subsubsection{\texorpdfstring{\texttt{setenv.sh} JMX
Settings}{setenv.sh JMX Settings}}\label{setenv.sh-jmx-settings}

\begin{verbatim}
JMX_OPTS="-Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.port=8099 -Dcom.sun.management.jmxremote.ssl=false"

CATALINA_OPTS="${CATALINA_OPTS} ${JMX_OPTS}"
\end{verbatim}

\subsubsection{\texorpdfstring{\texttt{setenv.bat} JMX
Settings}{setenv.bat JMX Settings}}\label{setenv.bat-jmx-settings}

\begin{verbatim}
set "JMX_OPTS=-Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.port=8099 -Dcom.sun.management.jmxremote.ssl=false"

set "CATALINA_OPTS=%CATALINA_OPTS% %JMX_OPTS%"
\end{verbatim}

Apache Tomcat's guide
\href{https://tomcat.apache.org/tomcat-7.0-doc/monitoring.html\#Enabling_JMX_Remote}{\emph{Enabling
JMX Remote}} has more JMX configuration details.

You've seen how setting up the example integration test class is
straightforward. Next, you'll discover how fun it is to develop
functional browser-based tests using Arquillian.

\section{Arquillian Functional Test
Example}\label{arquillian-functional-test-example}

Where the
\href{/docs/7-0/tutorials/-/knowledge_base/t/arquillian-integration-test-example}{integration
test} invokes the \texttt{SampleService}'s \texttt{add} method directly,
the functional test invokes the \texttt{add} method indirectly using a
web browser. The Arquillian Blade Example's functional tests interact
with the portlet UI to verify content and validate behavior. The test
classes are in the \texttt{src/testIntegration/java} folder and test
resources are in the \texttt{src/testIntegration/resources} folder.

The example functional tests operate on the following view parameters:

\begin{itemize}
\tightlist
\item
  \texttt{firstParameter}: First number to add
\item
  \texttt{secondParameter}: Second number to add
\item
  \texttt{result}: Sum of the two numbers
\end{itemize}

The JSP file \texttt{view.jsp} and portlet class
\texttt{BasicPortletFunctionalTest} use these parameters. Here's the
\texttt{view.jsp} code:

\begin{verbatim}
<%@ include file="/init.jsp" %>

<%@ page import="com.liferay.portal.kernel.util.ParamUtil" %>

<%
int firstParameter = ParamUtil.getInteger(request, "firstParameter", 1);
int secondParameter = ParamUtil.getInteger(request, "secondParameter", 1);
int result = ParamUtil.getInteger(request, "result");
%>

<portlet:actionURL name="add" var="portletURL" />

<p>
<b>Sample Portlet is working!</b>
</p>

<aui:form action="<%= portletURL %>" method="post" name="fm">
<aui:input inlineField="<%= true %>" label="" name="firstParameter" size="4" type="int" value="<%= firstParameter %>" />
<span> + </span>
<aui:input inlineField="<%= true %>" label="" name="secondParameter" size="4" type="int" value="<%= secondParameter %>" />
<span> = </span>
<span class="result"><%= result %></span>

<aui:button type="submit" value="add" />
</aui:form>
\end{verbatim}

Users enter numbers in the \texttt{firstParameter} and
\texttt{secondParameter} input fields and click on the \texttt{add}
button to show the sum to the \texttt{result} field.

Functional test class \texttt{BasicPortletFunctionalTest} uses Selenium
to interact with the portlet's UI. Here's the
\texttt{BasicPortletFunctionalTest} class:

\begin{verbatim}
package com.liferay.arquillian.test;

import com.google.common.io.Files;

import com.liferay.arquillian.portal.annotation.PortalURL;
import com.liferay.portal.kernel.exception.PortalException;

import java.io.File;
import java.io.IOException;

import java.net.URL;

import org.jboss.arquillian.container.test.api.Deployment;
import org.jboss.arquillian.container.test.api.RunAsClient;
import org.jboss.arquillian.drone.api.annotation.Drone;
import org.jboss.arquillian.junit.Arquillian;
import org.jboss.shrinkwrap.api.ShrinkWrap;
import org.jboss.shrinkwrap.api.spec.JavaArchive;

import org.junit.Assert;
import org.junit.Test;
import org.junit.runner.RunWith;

import org.openqa.selenium.OutputType;
import org.openqa.selenium.TakesScreenshot;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;
import org.openqa.selenium.support.FindBy;

@RunAsClient
@RunWith(Arquillian.class)
public class BasicPortletFunctionalTest {

    @Deployment
    public static JavaArchive create() throws Exception {
        final File tempDir = Files.createTempDir();

        String gradlew = "./gradlew";

        String osName = System.getProperty("os.name", "");
        if (osName.toLowerCase().contains("windows")) {
            gradlew = "./gradlew.bat";
        }

        final ProcessBuilder processBuilder = new ProcessBuilder(
            gradlew, "jar", "-Pdir=" + tempDir.getAbsolutePath());

        final Process process = processBuilder.start();

        process.waitFor();

        final File jarFile = new File(
            tempDir.getAbsolutePath() +
                "/com.liferay.arquillian.sample-1.0.0.jar");

        return ShrinkWrap.createFromZipFile(JavaArchive.class, jarFile);
    }

    @Test
    public void testAdd()
        throws InterruptedException, IOException, PortalException {

        _browser.get(_portlerURL.toExternalForm());

        _firstParamter.clear();

        _firstParamter.sendKeys("2");

        _secondParameter.clear();

        _secondParameter.sendKeys("3");

        _add.click();

        Thread.sleep(5000);

        Assert.assertEquals("5", _result.getText());
    }

    @Test
    public void testInstallPortlet() throws IOException, PortalException {
        _browser.get(_portlerURL.toExternalForm());

        final String bodyText = _browser.getPageSource();

        Assert.assertTrue(
            "The portlet is not well deployed",
            bodyText.contains("Sample Portlet is working!"));
    }

    @FindBy(css = "button[type=submit]")
    private WebElement _add;

    @Drone
    private WebDriver _browser;

    @FindBy(css = "input[id$='firstParameter']")
    private WebElement _firstParamter;

    @PortalURL("arquillian_sample_portlet")
    private URL _portlerURL;

    @FindBy(css = "span[class='result']")
    private WebElement _result;

    @FindBy(css = "input[id$='secondParameter']")
    private WebElement _secondParameter;

}
\end{verbatim}

Arquillian annotation \texttt{@RunAsClient} and JUnit annotation
\texttt{@RunWith} mark the class as a web client that runs on
Arquillian.

Similar to the integration test class, this class's \texttt{create}
method packages the test as a JAR file for Arquillian to execute.

Method \texttt{testInstallPortlet} verifies portlet content.

\begin{verbatim}
@Test
public void testInstallPortlet() throws IOException, PortalException {
    _browser.get(_portlerURL.toExternalForm());

    final String bodyText = _browser.getPageSource();

    Assert.assertTrue(
        "The portlet is not well deployed",
        bodyText.contains("Sample Portlet is working!"));
}
\end{verbatim}

This test class uses the following fields:

\begin{itemize}
\item
  \texttt{\_browser}: Arquillian annotation \texttt{@Drone} sets this
  field as a Selenium \texttt{WebDriver} (browser).

\begin{verbatim}
@Drone
private WebDriver _browser;
\end{verbatim}
\item
  \texttt{\_portlerURL}: Liferay Arquillian annotation
  \texttt{@PortalURL} assigns the portlet's URL to this field.

\begin{verbatim}
@PortalURL("arquillian_sample_portlet")
private URL _portlerURL;
\end{verbatim}
\item
  \texttt{\_firstParamter} and \texttt{\_secondParameter}: JavaScript
  selectors and Selenium annotation \texttt{@FindBy} map these fields to
  the form's inputs.

\begin{verbatim}
@FindBy(css = "input[id$='firstParameter']")
private WebElement _firstParamter;

@FindBy(css = "input[id$='secondParameter']")
private WebElement _secondParameter;
\end{verbatim}
\item
  \texttt{\_add}: The form's \texttt{submit} button.

\begin{verbatim}
@FindBy(css = "button[type=submit]")
private WebElement _add;
\end{verbatim}
\item
  \texttt{\_result}: Sum of the two numbers.

\begin{verbatim}
@FindBy(css = "span[class='result']")
private WebElement _result;
\end{verbatim}
\end{itemize}

Using the \texttt{*Parameter} fields, the \texttt{testAdd} method
injects numbers \texttt{2} and \texttt{3} into the form, submits the
form, and asserts \texttt{5} as the result.

\begin{verbatim}
@Test
public void testAdd()
    throws InterruptedException, IOException, PortalException {

    _browser.get(_portlerURL.toExternalForm());

    _firstParameter.clear();

    _firstParameter.sendKeys("2");

    _secondParameter.clear();

    _secondParameter.sendKeys("3");

    _add.click();

    Thread.sleep(5000);

    Assert.assertEquals("5", _result.getText());
}
\end{verbatim}

Testing portlets via a web client is that simple!

Functional tests typically require more setup than integration tests.

\subsection{Dependencies}\label{dependencies-1}

In addition to the Liferay Arquillian container, JUnit, and an
Arquillian JUnit test container artifacts that the
\href{/docs/7-0/tutorials/-/knowledge_base/t/arquillian-integration-test-example\#dependencies}{integration
test} required, the \texttt{BasicPortletFunctionalTest} class requires
Arquillian's Graphine extension to use the web client. Here's the
dependency from the Gradle file \texttt{build.gradle}:

\begin{verbatim}
testIntegrationCompile group: "org.jboss.arquillian.graphene", name: "graphene-webdriver", version: "2.1.0.Final"
\end{verbatim}

\noindent\hrulefill

\textbf{Note}: To learn more about functional testing using Graphine,
see this
\href{http://arquillian.org/guides/functional_testing_using_graphene/}{guide}.

\noindent\hrulefill

The test requires additional Arquillian configuration elements too.

\subsection{Arquillian Configuration}\label{arquillian-configuration-1}

In addition to the \texttt{deploymentExportPath} property introduced
with the integration test, this functional test specifies the browser
type using \texttt{phantomjs} and the portal's URL. Here's the project's
\texttt{arquillian.xml} file:

\begin{verbatim}
<?xml version="1.0" encoding="UTF-8"?>
<arquillian xmlns="http://jboss.org/schema/arquillian"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://jboss.org/schema/arquillian http://jboss.org/schema/arquillian/arquillian_1_0.xsd">

    <extension qualifier="webdriver">
        <property name="browser">phantomjs</property>
    </extension>

    <extension qualifier="graphene">
        <property name="url">http://localhost:8080</property>
    </extension>

    <engine>
        <property name="deploymentExportPath">build/deployments</property>
    </engine>
</arquillian>
\end{verbatim}

\noindent\hrulefill

\textbf{Note}: The Arquillian Liferay Extension provides these options
for injecting the URL of the container (e.g., Apache Tomcat):

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In a test class deployment method or field, use the annotation
  \texttt{@ArquillianResource} to designate the URL.
\item
  Configure Arquillian using the graphene URL property (via
  \texttt{arquillian.xml}, \texttt{arquillian.properties}, or System
  Properties).
\end{enumerate}

\noindent\hrulefill

You should use Portal properties to prevent Liferay DXP from launching a
browser and the Setup Wizard.

\subsection{Portal Properties}\label{portal-properties}

The Arquillian Blade Example specifies the following Portal properties
in file \texttt{src/testIntegration/resources/portal-ext.properties}:

\begin{verbatim}
browser.launcher.url=
setup.wizard.enabled=false
\end{verbatim}

Browsers other than the ones the functional tests launch can interfere
with tests. Setting \texttt{browser.launcher.url} to an empty value
prevents Liferay DXP from launching a browser on its own. You don't need
Liferay DXP's setup wizard either. Setting
\texttt{setup.wizard.enabled=false} bypasses launching the Setup Wizard.

The example project's Gradle task \texttt{copyPortalExt}, copies the
Portal properties file into the Liferay DXP installation.

As you develop tests, you might want to track the parts of the product
your tests cover. The example project uses JaCoCo to measure code
coverage. JaCoCo is explained next.

If you'd rather launch the Arquillian Blade Example before investigating
JaCoCo, skip to
\href{/docs/7-0/tutorials/-/knowledge_base/t/running-the-arquillian-example}{Running
the Arquillian Example}. Otherwise, jump into JaCoCo!

\section{JaCoCo Code Coverage
Example}\label{jacoco-code-coverage-example}

\href{http://eclemma.org/jacoco/}{JaCoCo} measures Java code coverage.
The Arquillian Blade Example uses JaCoCo to report parts and percentages
of the product code the tests execute.

\begin{figure}
\centering
\includegraphics{./images/arquillian-example-jacoco-results.png}
\caption{JaCoCo reports lines of code tests execute in methods and
classes.}
\end{figure}

\subsection{Enabling JaCoCo}\label{enabling-jacoco}

JaCoCo requires attaching an agent to the JVM. To attach the JaCoCo
agent, append the following JaCoCo options to the Tomcat environment
script's \texttt{CATALINA\_OPTS} variable.

\subsubsection{\texorpdfstring{\texttt{setenv.sh} JaCoCo
Settings}{setenv.sh JaCoCo Settings}}\label{setenv.sh-jacoco-settings}

\begin{verbatim}
JACOCO_OPTS="-javaagent:PATH_TO_JACOCO_AGENT_JAR/jacocoagent.jar=destfile=JACOCO_EXEC_FILE,output=file,append=true,jmx=true"

CATALINA_OPTS="${CATALINA_OPTS} ${JACOCO_OPTS}"
\end{verbatim}

\subsubsection{\texorpdfstring{\texttt{setenv.bat} JaCoCo
Settings}{setenv.bat JaCoCo Settings}}\label{setenv.bat-jacoco-settings}

\begin{verbatim}
set "JACOCO_OPTS=-javaagent:PATH_TO_JACOCO_AGENT_JAR/jacocoagent.jar=destfile=JACOCO_EXEC_FILE,output=file,append=true,jmx=true"

set "CATALINA_OPTS=%CATALINA_OPTS% %JACOCO_OPTS%"
\end{verbatim}

Replace \texttt{PATH\_TO\_JACOCO\_AGENT\_JAR} with the path to the
\texttt{jacocoagent.jar} file and \texttt{JACOCO\_EXEC\_FILE} with the
path to the JaCoCo result dump file.

\subsection{JaCoCo Build Instructions}\label{jacoco-build-instructions}

The Gradle build file \texttt{build.gradle} specifies several
JaCoCo-related instructions:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Apply the plugin to the build:

\begin{verbatim}
apply plugin: 'jacoco'

jacoco {
    toolVersion = '0.7.9'
}
\end{verbatim}
\item
  Copy the JaCoCo agent into the project build.

\begin{verbatim}
task copyJacocoAgent(type: Copy) {
println configurations.jacocoAgent

    configurations.jacocoAgent.asFileTree.each {
        from(zipTree(it))
    }

    into "${rootDir}/build/jacoco"
}
\end{verbatim}
\item
  Dump the code coverage data:

\begin{verbatim}
task dumpJacoco {
    doLast {
        def serverUrl = 'service:jmx:rmi:///jndi/rmi://localhost:8099/jmxrmi'
        String beanName = "org.jacoco:type=Runtime"
        def server = JmxFactory.connect(new JmxUrl(serverUrl)).MBeanServerConnection
        def gmxb = new GroovyMBean(server, beanName)

        println "Connected to:\n$gmxb\n"
        println "Executing dump()"
        gmxb.dump(true)
    }
}
\end{verbatim}
\item
  Generate JaCoCo reports:

\begin{verbatim}
jacocoTestReport {
    dependsOn dumpJacoco
    group = "Reporting"
    reports {
        xml.enabled true
        csv.enabled false
        html.destination "${buildDir}/reports/coverage"
    }
    executionData = files("${rootDir}/build/jacoco/testIntegration.exec")
}
\end{verbatim}
\end{enumerate}

JaCoCo code coverage reporting runs as part of the project's
\texttt{testIntegration} Gradle task. You'll run the tests and JaCoCo
next.

\section{Running the Arquillian
Example}\label{running-the-arquillian-example}

You're ready to run the Arquillian Blade Example tests. Open a terminal
to the project root and execute the following command:

\begin{verbatim}
gradlew testIntegration
\end{verbatim}

The command does these things:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Downloads and installs 7.0 bundled with Apache Tomcat
\item
  Starts a 7.0 server
\item
  Runs the tests, including the functional browser-based tests
\item
  Shuts down the server
\item
  Reports test and code coverage results
\end{enumerate}

For \texttt{testIntegration} task details, examine the
\texttt{build.gradle} file in the project root.

The command can take several minutes to execute because of all it does.

Test results are found in these locations:

\begin{itemize}
\tightlist
\item
  \emph{Tests}:
  \texttt{build\textbackslash{}reports\textbackslash{}tests\textbackslash{}testIntegration\textbackslash{}index.html}
\item
  \emph{Code Coverage}:
  \texttt{build\textbackslash{}reports\textbackslash{}coverage\textbackslash{}index.html}
\end{itemize}

\begin{figure}
\centering
\includegraphics{./images/arquillian-example-test-results.png}
\caption{Open the test reports to analyze the results.}
\end{figure}

\noindent\hrulefill

Note: before rerunning the tests, you must delete the
\texttt{build/reports/} and \texttt{build/test-results/} folders.

\noindent\hrulefill

Now that you've examined Arquillian functional and integration tests and
JaCoCo code coverage capabilities, you can create similar tests and
improve test code coverage in your projects.

\textbf{Related Topics}

\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-slim-runtime}{Liferay's
Slim Runtime}

\href{/docs/7-0/tutorials/-/knowledge_base/t/unit-testing-with-junit}{Unit
Testing with JUnit}

\section{Liferay Slim Runtime}\label{liferay-slim-runtime}

The Liferay Slim Runtime provides the bare necessities for running
Service Builder modules. It's useful for testing applications quickly in
a Liferay runtime environment free of Liferay add-ons.

The Liferay Slim Runtime provides

\begin{itemize}
\tightlist
\item
  Caching infrastructure
\item
  Database infrastructure
\item
  HTTP support
\item
  JAX-RS support
\item
  Limited set of Liferay utility classes
\item
  OSGi framework for running modules
\item
  Service Builder runtime for Service Builder modules
\item
  Spring infrastructure
\item
  Transaction infrastructure
\end{itemize}

It does \textbf{not} provide

\begin{itemize}
\tightlist
\item
  Authentication/Authorization layers
\item
  Layout templates
\item
  Permissions
\item
  Portlet support (no portlet container)
\item
  Sites
\item
  Themes
\item
  etc.
\end{itemize}

Building and launching a Liferay Slim Runtime is much quicker than a
typical Liferay DXP bundle. Because of decreased build and startup
times, the Slim Runtime provides a great environment for testing. You'll
learn how to build one next.

\subsection{Build}\label{build}

To build the Slim Runtime, you must have the
\href{https://github.com/liferay/liferay-portal}{liferay-portal} Github
repository \href{https://help.github.com/articles/fork-a-repo/}{forked}
and
\href{https://help.github.com/articles/cloning-a-repository/}{cloned} to
your local machine. Navigate to the repository's root folder and execute
the following Ant command:

\begin{verbatim}
ant all -Dbuild.profile=slim
\end{verbatim}

It's built in the server directory specified by the
\texttt{app.server.properties} file's \texttt{app.server.parent.dir}
property. Note that the Slim Runtime only supports Apache Tomcat 8+.
This limitation simplifies packaging and configuration.

\subsection{Launch}\label{launch}

To launch the Slim Runtime, run the Tomcat start scripts found in the
runtime's \texttt{\textless{}tomcat\textgreater{}/bin} directory:

\begin{verbatim}
./startup.[sh|bat]
\end{verbatim}

\subsection{Deploying Modules}\label{deploying-modules-1}

You can deploy modules from any of the default directories the
\href{@platform-ref@/7.0-latest/propertiesdoc/portal.properties.html}{portal.properties}
file defines (see properties below) or from a custom auto-deploy
directory you add to the \texttt{module.framework.auto.deploy.dirs}
property.

\begin{verbatim}
module.framework.base.dir=${liferay.home}/osgi

module.framework.configs.dir=${module.framework.base.dir}/configs
module.framework.marketplace.dir=${module.framework.base.dir}/marketplace
module.framework.modules.dir=${module.framework.base.dir}/modules
module.framework.war.dir=${module.framework.base.dir}/war

module.framework.auto.deploy.dirs=\
    ${module.framework.configs.dir},\
    ${module.framework.marketplace.dir},\
    ${module.framework.modules.dir},\
    ${module.framework.war.dir}
\end{verbatim}

By default, a pristine Slim Runtime has no UI or apps. Requests to it
result in 404 errors.

The modules you add provide all the functionality.

\subsection{Adding Functionality}\label{adding-functionality}

A web endpoint is the simplest type of function.

The following snippet demonstrates a simple servlet that responds to all
requests to \texttt{http://localhost:8080{[}/*{]}}:

\begin{verbatim}
package web.sample;

import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.Servlet;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.osgi.service.component.annotations.Component;
import org.osgi.service.http.whiteboard.HttpWhiteboardConstants;

@Component(
    immediate = true,
    property = {
        HttpWhiteboardConstants.HTTP_WHITEBOARD_SERVLET_PATTERN + "=/*"
    },
    service = Servlet.class
)
public class SampleServlet extends HttpServlet {

    private static final long serialVersionUID = 1L;

    @Override
    protected void service(
            HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException {

        response.setContentType("text/html");

        PrintWriter writer = response.getWriter();

        writer.println("<h2>Hello You!</h2>");
    }

}
\end{verbatim}

\subsection{The Database}\label{the-database}

The Slim Runtime creates the database schema automatically the first
time it runs.

\begin{verbatim}
MariaDB [lportal]> show tables;
+------------------+
\end{verbatim}

\noindent\hrulefill

\begin{verbatim}
 Tables_in_lportal|
\end{verbatim}

\noindent\hrulefill +------------------+

\noindent\hrulefill

\begin{verbatim}
 ClassName_       |
 Configuration_   |
 Counter          |
 Release_         |
 ServiceComponent |
\end{verbatim}

\noindent\hrulefill +------------------+ 5 rows in set (0.00 sec)

Only the following core services are available:

\begin{itemize}
\tightlist
\item
  \texttt{ClassNameLocalService}
\item
  \texttt{CounterLocalService}
\item
  \texttt{ReleaseLocalService}
\item
  \texttt{ServiceComponentLocalService}
\end{itemize}

The Slim Runtime provides no other services! To test your services,
therefore, you must deploy modules that provide the capabilities they
depend on.

\subsection{Service Builder}\label{service-builder-1}

The Service Builder runtime bootstraps all deployed Service Builder
services (API and service modules).

For example, deploying the \texttt{com.liferay.contacts.api} and
\texttt{com.liferay.contacts.service} modules adds the
\texttt{Contacts\_Entry} table to the database:

\begin{verbatim}
MariaDB [lportal]> show tables;
+------------------+
\end{verbatim}

\noindent\hrulefill

\begin{verbatim}
 Tables_in_lportal|
\end{verbatim}

\noindent\hrulefill +------------------+

\noindent\hrulefill

\begin{verbatim}
 ClassName_       |
 Configuration_   |
 Contacts_Entry   |
 Counter          |
 Release_         |
 ServiceComponent |
\end{verbatim}

\noindent\hrulefill +------------------+ 6 rows in set (0.00 sec)

\subsubsection{A Basic Service Builder Web
App}\label{a-basic-service-builder-web-app}

The servlet in the following snippet implements a simple web app that
uses the contacts service.

\begin{verbatim}
package web.sample;

import java.io.IOException;
import java.io.PrintWriter;
import java.util.List;

import javax.servlet.Servlet;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Reference;
import org.osgi.service.http.whiteboard.HttpWhiteboardConstants;

import com.liferay.contacts.model.Entry;
import com.liferay.contacts.service.EntryLocalService;
import com.liferay.counter.kernel.service.CounterLocalService;
import com.liferay.portal.kernel.dao.orm.DynamicQuery;
import com.liferay.portal.kernel.dao.orm.QueryUtil;
import com.liferay.portal.kernel.dao.orm.RestrictionsFactoryUtil;
import com.liferay.portal.kernel.util.ParamUtil;
import com.liferay.portal.kernel.util.Validator;

@Component(
    immediate = true,
    property = {
        HttpWhiteboardConstants.HTTP_WHITEBOARD_SERVLET_PATTERN + "=/*"
    },
    service = Servlet.class
)
public class SampleServlet extends HttpServlet {

    private static final long serialVersionUID = 1L;

    @Override
    protected void service(
            HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException {

        response.setContentType("text/html");

        PrintWriter writer = response.getWriter();

        String fullNameParameter = ParamUtil.getString(request, "fullName");

        if (Validator.isNull(fullNameParameter)) {
            writer.println("<h2>Hello You!</h2>");
            writer.println("Do you want to sign up for this thing?<br/>");
            writer.println("<form action='/join' method='post'>");
            writer.println("<input type='text' name='fullName' placeholder='Full Name'><br>");
            writer.println("<input type='text' name='emailAddress' placeholder='Email Address'><br>");
            writer.println("<input type='submit' value='Sign Up'><br>");
            writer.println("</form>");

            List<Entry> entries = _entryLocalService.getEntries(QueryUtil.ALL_POS, QueryUtil.ALL_POS);

            if (entries.isEmpty()) {
                writer.println("I'm so lonely! :(<br/>");
            }
            else {
                writer.println("Here's a list of others who've already signed up:<br/>");

                for (Entry entry : _entryLocalService.getEntries(QueryUtil.ALL_POS, QueryUtil.ALL_POS)) {
                    writer.println(String.format("%s &lt;%s><br/>", entry.getFullName(), entry.getEmailAddress()));
                }
            }

            return;
        }

        String emailAddressParameter = ParamUtil.getString(request, "emailAddress");

        if (Validator.isNull(emailAddressParameter)) {
            writer.println(String.format("Ooops! %s, you forgot your emailAddress :(<br/>", fullNameParameter));
            writer.println("<a href='/'>Retry?</a>");

            return;
        }

        DynamicQuery dynamicQuery = _entryLocalService.dynamicQuery();

        dynamicQuery.add(RestrictionsFactoryUtil.eq("emailAddress", emailAddressParameter));

        long count = _entryLocalService.dynamicQueryCount(dynamicQuery);

        if (count > 0) {
            writer.println(String.format("Ooops! Someone already registered with the email address &lt;%s> :(<br/>", emailAddressParameter));
            writer.println("<a href='/'>Retry?</a>");

            return;
        }

        long entryId = _counterLocalService.increment();

        Entry entry = _entryLocalService.createEntry(entryId);

        entry.setFullName(fullNameParameter);
        entry.setEmailAddress(emailAddressParameter);

        _entryLocalService.updateEntry(entry);

        writer.println(String.format("Great! Thanks for signing up %s :D<br/>", fullNameParameter));
        writer.println("<a href='/'>Go Back!</a>");
    }

    @Reference
    private CounterLocalService _counterLocalService;

    @Reference
    private EntryLocalService _entryLocalService;

}
\end{verbatim}

Note how it uses OSGi Declarative Services to reference an instance of
Portal Kernel's \texttt{CounterLocalService} and Contacts API's
\texttt{EntryLocalService}.

\subsection{Related Topics}\label{related-topics-198}

\href{/docs/7-0/tutorials/-/knowledge_base/t/arquillian-extension-for-liferay-example}{Arquillian
Extension for Liferay Example}

\href{/docs/7-0/tutorials/-/knowledge_base/t/unit-testing-with-junit}{Unit
Testing with JUnit}

\section{Injecting Service Components into
Tests}\label{injecting-service-components-into-tests}

You can use Liferay DXP's \texttt{@Inject} annotation to inject service
components into a test, like you use the \texttt{@Reference} annotation
to inject service components into a module component.

\texttt{@Inject} uses reflection to inject a field with a service
component object matching the field's interface.
\href{https://docs.liferay.com/ce/portal/7.0-latest/javadocs/portal-test-integration/com/liferay/portal/test/rule/LiferayIntegrationTestRule.html}{Test
rule \texttt{LiferayIntegrationTestRule}} provides this annotation. The
annotation accepts \texttt{filter} and \texttt{type} parameters, which
you can use separately or together.

\noindent\hrulefill

DXP Digital Enterprise 7.0 Fix Pack 30 and Liferay CE Portal 7.0 GA5
introduced the \texttt{@Inject} annotation.

\noindent\hrulefill

To fill a field with a particular implementation or sub-class object,
set the \texttt{type} with it.

\begin{verbatim}
@Inject(type = SubClass.class)
\end{verbatim}

Replace \texttt{SubClass} with the name of the service interface to
inject.

Here's an example test class that injects a \texttt{DDLServiceUpgrade}
object into an \texttt{UpgradeStepRegistrator} interface field:

\begin{verbatim}
public class Test {

    @ClassRule
    @Rule
    public static final AggregateTestRule aggregateTestRule = 
        new LiferayIntegrationTestRule();

    @Test
    public void testSomething() {
        // your test code here
    }

    @Inject(
        filter = "(&(objectClass=com.liferay.dynamic.data.lists.internal.upgrade.DDLServiceUpgrade))"
    )
    private static UpgradeStepRegistrator _upgradeStepRegistrator;

} 
\end{verbatim}

Here's how to inject a service component into a test class:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In your test class, add a rule field of
  \href{https://docs.liferay.com/ce/portal/7.0-latest/javadocs/portal-test-integration/com/liferay/portal/test/rule/LiferayIntegrationTestRule.html}{type
  \texttt{com.liferay.portal.test.rule.LiferayIntegrationTestRule}}. For
  example,

\begin{verbatim}
@ClassRule
@Rule
public static final AggregateTestRule aggregateTestRule = 
    new LiferayIntegrationTestRule();
\end{verbatim}
\item
  Add a field to hold a service component. Making the field static
  improves efficiency, because the container injects static fields once
  before test runs and nulls them after all tests run. Non-static fields
  are injected before each test run but stay in memory till all tests
  finish.
\item
  Annotate the field with an \texttt{@Inject} annotation. By default,
  the container injects the field with a service component object
  matching the field's type.
\item
  Optionally add a \texttt{filter} string or \texttt{type} parameter to
  further specify the service component object to inject.
\end{enumerate}

At runtime, the \texttt{@Inject} annotation blocks the test until a
matching service component is available. The block has a timeout and
messages are logged regarding the test's unavailable dependencies.

\noindent\hrulefill

\textbf{Important}: If you're publishing the service component you are
injecting, the test might never run. If you must publish the service
component from the test class, use
\href{/docs/7-0/tutorials/-/knowledge_base/t/service-trackers}{Service
Trackers} to access service components.

\noindent\hrulefill

Great! Now you can inject service components into your tests.

\subsection{Related Articles}\label{related-articles-4}

\href{/docs/7-0/tutorials/-/knowledge_base/t/service-trackers}{Service
Trackers}

\href{/docs/7-0/tutorials/-/knowledge_base/t/finding-and-invoking-liferay-services}{Finding
and Invoking Liferay Services}

\href{/docs/7-0/tutorials/-/knowledge_base/t/unit-testing-with-junit}{Unit
Testing with JUnit}

\chapter{Modularity and OSGi}\label{modularity-and-osgi}

Things we use every day are made of carefully designed, created, and
tested subsystems. For example, a car has an engine, suspension, and air
conditioner. Teams of engineers, machinists, and technicians make these
subsystems the best they can be separately before combining them to
create a high quality car. This is modularity in action--creating things
from smaller well-designed, well-tested parts.

Liferay DXP is modular too. It comprises code modules created and tested
independently and in parallel. It's a platform on which modules and
modular applications are installed, started, used, stopped, and
uninstalled. Liferay DXP's components use the OSGi modularity standard.

These tutorials demonstrate developing OSGi services and components to
customize Liferay DXP and create applications on it. As Liferay's
developers used modules to create Liferay DXP and its applications, you
and your teammates can enjoy developing your own modules, applications,
and customizations in parallel on Liferay DXP.

\section{The Benefits of Modularity}\label{the-benefits-of-modularity}

Dictionary.com defines
\href{http://www.dictionary.com/browse/modularity}{modularity} as
\emph{the use of individually distinct functional units, as in
assembling an electronic or mechanical system.} The distinct functional
units are called \emph{modules}.

NASA's Apollo spacecraft, for example, comprised three modules, each
with a distinct function:

\begin{itemize}
\tightlist
\item
  \emph{Lunar Module}: Carried astronauts from the Apollo spacecraft to
  the moon's surface and back.
\item
  \emph{Service Module}: Provided fuel for propulsion, air conditioning,
  and water.
\item
  \emph{Command Module}: Housed the astronauts and communication and
  navigation controls.
\end{itemize}

\begin{figure}
\centering
\includegraphics{./images/modularity_apollo_spacecraft_diagram.png}
\caption{The Apollo spacecraft's modules collectively took astronauts to
the moon's surface and back to Earth.}
\end{figure}

The spacecraft and its modules exemplified these modularity
characteristics:

\begin{itemize}
\item
  \textbf{Distinct functionality}: Each module provides a distinct
  function (purpose); modules can be combined to provide an entirely new
  collective function.

  The Apollo spacecraft's modules were grouped together for a distinct
  collective function: take astronauts from the Earth's atmospheric rim,
  to the moon's surface, and back to Earth. The previous list identifies
  each module's distinct function.
\item
  \textbf{Dependencies}: Modules can require capabilities other modules
  satisfy.

  The Apollo modules had these dependencies:

  \begin{itemize}
  \item
    Lunar Module depended on the Service Module to get near the moon.
  \item
    Command Module depended on the Service Module for power and oxygen.
  \item
    Service Module depended on the Command Module for instruction.
  \end{itemize}
\item
  \textbf{Encapsulation}: Modules hide their implementation details but
  publicly define their capabilities and interfaces.

  Each Apollo module was commissioned with a contract defining its
  capabilities and interface, while each module's details were
  encapsulated (hidden) from other modules. NASA integrated the modules
  based on their interfaces.
\item
  \textbf{Reusability}: A module can be applied to different scenarios.

  The Command Module's structure and design were reusable. NASA used
  different versions of the Command Module, for example, throughout the
  Apollo program, and in the Gemini Program, which focused on Earth
  orbit.
\end{itemize}

NASA used modularity to successfully complete over a dozen missions to
the moon. Can modularity benefit software too? Yes! The following
sections show you how:

\begin{itemize}
\tightlist
\item
  \hyperref[modularity-benefits-for-software]{Modularity benefits for
  software}
\item
  \hyperref[example-designing-a-modular-application]{Example: How to
  design a modular application}
\end{itemize}

\subsection{Modularity Benefits for
Software}\label{modularity-benefits-for-software}

Java applications have predominantly been monolithic: they're developed
in large code bases. In a monolith, it's difficult to avoid tight
coupling of classes. Modular application design, conversely, facilitates
loose coupling, making the code easier to maintain. It's much easier and
more fun to develop small amounts of cohesive code in modules. Here are
some key benefits of developing modular software.

\subsubsection{Distinct Functionality}\label{distinct-functionality}

It's natural to focus on developing one piece of software at a time. In
a module, you work on a small set of classes to define and implement the
module's function. Keeping scope small facilitates writing high quality,
elegant code. The more cohesive the code, the easier it is to test,
debug, and maintain. Modules can be combined to provide a new function,
distinguishable from each module's function.

\subsubsection{Encapsulation}\label{encapsulation}

A module encapsulates a function (capability). Module implementations
are hidden from consumers, so you can create and modify them as you
like. Throughout a module's lifetime, you can fix and improve the
implementation or swap in an entirely new one. You make the changes
behind the scenes, transparent to consumers. A module's contract defines
its capability and interface, making the module easy to understand and
use.

\subsubsection{Dependencies}\label{dependencies-2}

Modules have requirements and capabilities. The interaction between
modules is a function of the capability of one satisfying the
requirement of another and so on. Modules are published to artifact
repositories, such as Maven Central. Module versioning schemes let you
specify dependencies on particular module versions or version ranges.

\subsubsection{Reusability}\label{reusability}

Modules that do their job well are hot commodities. They're reusable
across projects, for different purposes. As you discover helpful
reliable modules, you'll use them again and again.

It's time to design a modular application.

\subsection{Example: Designing a Modular
Application}\label{example-designing-a-modular-application}

Application design often starts out simple but gets more complex as you
determine capabilities the application requires. If a third party
library already provides the capability, you can
\href{/docs/7-0/tutorials/-/knowledge_base/t/adding-third-party-libraries-to-a-module}{deploy
it with your app}. You can otherwise implement the capability yourself.

As you design various aspects of your app to support its function, you
must decide how those aspects fit into the code base. Putting them in a
single monolithic code base often leads to tight coupling, while
designating separate modules for each aspect fosters loose coupling.
Adopting a modular approach to application design lets you reap the
modularity benefits.

For example, you can apply modular design to a speech recognition app.
Here are the app's function and required capabilities:

\emph{Function}: interface with users to translate their speech into
text for the computer to understand.

\emph{Required capabilities}: - Translates user words to text - Uses a
selected computer voice to speak to users. - Interacts with users based
on a script of instructions that include questions, commands, requests,
and confirmations.

You could create modules to provide the required capabilities:

\begin{itemize}
\tightlist
\item
  \emph{Speech to text}: Translates spoken words to text the computer
  understands.
\item
  \emph{Voice UI}: Interacts with users based on stored questions,
  commands, and confirmations.
\item
  \emph{Instruction manager}: Stores and provides the application's
  questions, commands, and confirmations.
\item
  \emph{Computer voice}: Stores and provides computer voices for users
  to choose from.
\end{itemize}

The following diagram contrasts a monolithic design for the speech
recognition application with a modular design.

\begin{figure}
\centering
\includegraphics{./images/modularity-benefits-application-design-example.png}
\caption{The speech recognition application can be implemented in a
single monolithic code base or in modules, each focused on a particular
function.}
\end{figure}

Designing the app as a monolith lumps everything together. There are no
initial boundaries between the application aspects, whereas the modular
design distinguishes the aspects.

Developers can create the modules in parallel, each one with its own
particular capability. Designing applications that comprise modules
fosters writing cohesive pieces of code that represent capabilities.
Each module's capability can potentially be \emph{reused} in other
scenarios too.

For example, the \emph{Instruction manager} and \emph{Computer voice}
modules can be \emph{reused} by a navigation app.

\begin{figure}
\centering
\includegraphics{./images/modularity-benefits-module-reuse.png}
\caption{The \emph{Instruction manager} and \emph{Computer voice}
modules designed for the speech recognition app can be used (or
\emph{reused}) by a navigation app.}
\end{figure}

Here are the benefits of designing the speech recognition app as
modules:

\begin{itemize}
\tightlist
\item
  Each module represents a capability that contributes to the app's
  overall function.
\item
  The app depends on modules, that are easy to develop, test, and
  maintain.
\item
  The modules can be reused in different applications.
\end{itemize}

In conclusion, modularity has literally taken us to the moon and back.
It benefits software development too. The example speech recognition
application demonstrated how to design an app that comprises modules.

Next you'll learn how OSGi facilitates creating modules that provide and
consume services.

\section{OSGi and Modularity}\label{osgi-and-modularity}

Modularity makes writing software, especially as a team, fun! Here are
some benefits to modular development on DXP:

\begin{itemize}
\tightlist
\item
  Liferay DXP's runtime framework is lightweight, fast, and secure.
\item
  The framework uses the OSGi standard. If you have experience using
  OSGi with other projects, you can apply your existing knowledge to
  developing on DXP.
\item
  Modules publish services to and consume services from a service
  registry. Service contracts are loosely coupled from service providers
  and consumers, and the registry manages the contracts automatically.
\item
  Modules' dependencies are managed automatically by the container,
  dynamically (no restart required).
\item
  The container manages module life cycles dynamically. Modules can be
  installed, started, updated, stopped, and uninstalled while Liferay
  DXP is running, making deployment a snap.
\item
  Only a module's classes whose packages are explicitly exported are
  publicly visible; OSGi hides all other classes by default.
\item
  Modules and packages are semantically versioned and declare
  dependencies on specific versions of other packages. This allows two
  applications that depend on different versions of the same packages to
  each depend on their own versions of the packages.
\item
  Team members can develop, test, and improve modules in parallel.
\item
  You can use your existing developer tools and environment to develop
  modules.
\end{itemize}

There are many benefits to modular software development with OSGi, and
we can only scratch the surface here. Once you start developing modules,
you might find it hard to go back to developing any other way.

\subsection{Modules}\label{modules-1}

It's time to see what module projects look like and see Liferay DXP's
modular development features in action. To keep things simple, only
project code and structure are shown: you can
\href{/docs/7-0/tutorials/-/knowledge_base/t/starting-module-development}{create
modules} like these anytime.

These modules collectively provide a command that takes a String and
uses it in a greeting. Consider it ``Hello World'' for modules.

\subsubsection{API}\label{api}

The API module is first. It defines the contract that a provider
implements and a consumer uses. Here is its structure:

\begin{itemize}
\tightlist
\item
  \texttt{greeting-api}

  \begin{itemize}
  \tightlist
  \item
    \texttt{src}

    \begin{itemize}
    \tightlist
    \item
      \texttt{main}

      \begin{itemize}
      \tightlist
      \item
        \texttt{java}

        \begin{itemize}
        \tightlist
        \item
          \texttt{com/liferay/docs/greeting/api}

          \begin{itemize}
          \tightlist
          \item
            \texttt{Greeting.java}
          \end{itemize}
        \end{itemize}
      \end{itemize}
    \end{itemize}
  \item
    \texttt{bnd.bnd}
  \item
    \texttt{build.gradle}
  \end{itemize}
\end{itemize}

Very simple, right? Beyond the Java source file, there are only two
other files: a Gradle build script (though you can use any build system
you want), and a configuration file called \texttt{bnd.bnd}. The
\texttt{bnd.bnd} file describes and configures the module:

\begin{verbatim}
Bundle-Name: Greeting API
Bundle-SymbolicName: com.liferay.docs.greeting.api
Bundle-Version: 1.0.0
Export-Package: com.liferay.docs.greeting.api
\end{verbatim}

The module's name is \emph{Greeting API}. Its symbolic name--a name that
ensures uniqueness--is \texttt{com.liferay.docs.greeting.api}. Its
semantic version is declared next, and its package is \emph{exported},
which means it's made available to other modules. This module's package
is just an API other modules can implement.

Finally, there's the Java class, which in this case is an interface:

\begin{verbatim}
package com.liferay.docs.greeting.api;

import aQute.bnd.annotation.ProviderType;

@ProviderType
public interface Greeting {

        public void greet(String name);

}
\end{verbatim}

The interface's \texttt{@ProviderType} annotation tells the service
registry that anything implementing the interface is a provider. The
interface's one method asks for a \texttt{String} and doesn't return
anything.

That's it! As you can see, creating modules is not very different from
creating other Java projects.

\subsubsection{Provider}\label{provider}

An interface only defines an API; to do something, it must be
implemented. This is what the provider module is for. Here's what a
provider module for the Greeting API looks like:

\begin{itemize}
\tightlist
\item
  \texttt{greeting-impl}

  \begin{itemize}
  \tightlist
  \item
    \texttt{src}

    \begin{itemize}
    \tightlist
    \item
      \texttt{main}

      \begin{itemize}
      \tightlist
      \item
        \texttt{java}

        \begin{itemize}
        \tightlist
        \item
          \texttt{com/liferay/docs/greeting/impl}

          \begin{itemize}
          \tightlist
          \item
            \texttt{GreetingImpl.java}
          \end{itemize}
        \end{itemize}
      \end{itemize}
    \end{itemize}
  \item
    \texttt{bnd.bnd}
  \item
    \texttt{build.gradle}
  \end{itemize}
\end{itemize}

It has the same structure as the API module: a build script, a
\texttt{bnd.bnd} configuration file, and an implementation class. The
only differences are the file contents. The \texttt{bnd.bnd} file is a
little different:

\begin{verbatim}
Bundle-Name: Greeting Impl
Bundle-SymbolicName: com.liferay.docs.greeting.impl
Bundle-Version: 1.0.0
\end{verbatim}

The bundle name, symbolic name, and version are all set similarly to the
API.

Finally, there's no \texttt{Export-Package} declaration. A client (which
is the third module you'll create) just wants to use the API: it doesn't
care how its implementation works as long as the API returns what it's
supposed to return. The client, then, only needs to declare a dependency
on the API; the service registry injects the appropriate implementation
at runtime.

Pretty cool, eh?

All that's left, then, is the class that provides the implementation:

\begin{verbatim}
package com.liferay.docs.greeting.impl;

import com.liferay.docs.greeting.api.Greeting;

import org.osgi.service.component.annotations.Component;

@Component(
    immediate = true,
    property = {
    },
    service = Greeting.class
)
public class GreetingImpl implements Greeting {

    @Override
    public void greet(String name) {
        System.out.println("Hello " + name + "!");
    }

}
\end{verbatim}

The implementation is simple. It uses the \texttt{String} as a name and
prints a hello message. A better implementation might be to use Liferay
DXP's API to collect all the names of all the users in the system and
send each user a greeting notification, but the point here is to keep
things simple. You should understand, though, that there's nothing
stopping you from replacing this implementation by deploying another
module whose Greeting implementation's \texttt{@Component} annotation
specifies a higher service ranking property (e.g.,
\texttt{"service.ranking:Integer=100"}).

This \texttt{@Component} annotation defines three options:
\texttt{immediate\ =\ true}, an empty property list, and the service
class that it implements. The \texttt{immediate\ =\ true} setting means
that this module should not be lazy-loaded; the service registry loads
it as soon as it's deployed, instead of when it's first used. Using the
\texttt{@Component} annotation declares the class as a Declarative
Services component, which is the most straightforward way to create
components for OSGi modules. A component is a POJO that the runtime
creates automatically when the module starts.

To compile this module, the API it's implementing must be on the
classpath. If you're using Gradle, you'd add the \texttt{greetings-api}
project to your \texttt{dependencies\ \{\ ...\ \}} block. In a
\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-workspace}{Liferay
Workspace} module, the dependency looks like this:

\begin{verbatim}
compileOnly project (':modules:greeting-api')
\end{verbatim}

That's all there is to a provider module.

\subsubsection{Consumer}\label{consumer}

The consumer or client uses the API that the API module defines and the
provider module implements. DXP has many different kinds of consumer
modules.
\href{/docs/7-0/tutorials/-/knowledge_base/t/portlets}{Portlets} are the
most common consumer module type, but since they are a topic all by
themselves, this example stays simple by creating an command for the
Apache Felix Gogo shell. Note that consumers can, of course, consume
many different APIs to provide functionality.

A consumer module has the same structure as the other module types:

\begin{itemize}
\tightlist
\item
  \texttt{greeting-command}

  \begin{itemize}
  \tightlist
  \item
    \texttt{src}

    \begin{itemize}
    \tightlist
    \item
      \texttt{main}

      \begin{itemize}
      \tightlist
      \item
        \texttt{java}

        \begin{itemize}
        \tightlist
        \item
          \texttt{com/liferay/docs/greeting/command}

          \begin{itemize}
          \tightlist
          \item
            \texttt{GreetingCommand.java}
          \end{itemize}
        \end{itemize}
      \end{itemize}
    \end{itemize}
  \item
    \texttt{bnd.bnd}
  \item
    \texttt{build.gradle}
  \end{itemize}
\end{itemize}

Again, you have a build script, a \texttt{bnd.bnd} file, and a Java
class. This module's \texttt{bnd.bnd} file is almost the same as the
provider's:

\begin{verbatim}
Bundle-Name: Greeting Command
Bundle-SymbolicName: com.liferay.docs.greeting.command
Bundle-Version: 1.0.0
\end{verbatim}

There's nothing new here: you declare the same things you declared for
the provider.

Your Java class has a little bit more going on:

\begin{verbatim}
package com.liferay.docs.greeting.command;

import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Reference;

import com.liferay.docs.greeting.api.Greeting;

@Component(
    immediate = true,
    property = {
        "osgi.command.scope=greet",
        "osgi.command.function=greet"
    },
    service = Object.class
)
public class GreetingCommand {

    public void greet(String name) {
        Greeting greeting = _greeting;

        greeting.greet(name);
    }

    @Reference
    private Greeting _greeting;

}
\end{verbatim}

The \texttt{@Component} annotation declares the same attributes, but
specifies different properties and a different service. As in Java,
where every class is a subclass of \texttt{java.lang.Object} (even
though you don't need to specify it by default), in Declarative
Services, the runtime needs to know the type of class to register.
Because you're not implementing any particular type, your parent class
is \texttt{java.lang.Object}, so you must specify that class as the
service. While Java doesn't require you to specify \texttt{Object} as
the parent when you're creating a class that doesn't inherit anything,
Declarative Services does.

The two properties define a command scope and a command function. All
commands have a scope to define their context, as it's common for
multiple APIs to have similar functions, such as \texttt{copy} or
\texttt{delete}. These properties specify you're creating a command
called \texttt{greet} in a scope called \texttt{greet}. While you get no
points for imagination, this sufficiently defines the command.

Since you specified \texttt{osgi.command.function=greet} in the
\texttt{@Component} annotation, your class must have a method named
\texttt{greet}, and you do. But how does this \texttt{greet} method
work? It obtains an instance of the \texttt{Greeting} OSGi service and
invokes its \texttt{greet} method, passing in the \texttt{name}
parameter. How is an instance of the \texttt{Greeting} OSGi service
obtained? The \texttt{GreetingCommand} class declares a private service
bean, \texttt{\_greeting} of type \texttt{Greeting}. This is the OSGi
service type that the provider module registers. The \texttt{@Reference}
annotation tells the OSGi runtime to instantiate the service bean with a
service from the service registry. The runtime binds the
\texttt{Greeting} object of type \texttt{GreetingImpl} to the private
field \texttt{\_greeting}. The \texttt{greet} method uses the
\texttt{\_greeting} field value.

Just like the provider, the consumer needs to have the API on its
classpath in order to compile, but at runtime, since you've declared all
the dependencies appropriately, the container knows about these
dependencies, and provides them automatically.

If you were to
\href{/docs/7-0/tutorials/-/knowledge_base/t/starting-module-development\#building-and-deploying-a-module}{deploy
these modules to a DXP instance}, you'd be able to attach to the
\href{develop/reference/-/knowledge_base/7-0/using-the-felix-gogo-shell}{Gogo
Shell} and execute a command like this:

\begin{verbatim}
greet:greet "Captain\ Kirk"
\end{verbatim}

The shell would then return your greeting:

\begin{verbatim}
Hello Captain Kirk!
\end{verbatim}

This most basic of examples should make it clear that module-based
development is easy and straightforward. The API-Provider-Consumer
contract fosters loose coupling, making your software easy to manage,
enhance, and support.

\subsection{A Typical Liferay
Application}\label{a-typical-liferay-application}

If you look at a typical application from Liferay DXP's source, you'll
generally find at least four modules:

\begin{itemize}
\tightlist
\item
  An API module
\item
  A Service (provider) module
\item
  A Test module
\item
  A Web (consumer) module
\end{itemize}

This is exactly what you'll find for some smaller applications, like the
Mentions application that lets users mention other users with the
\texttt{@username} nomenclature in comments, blogs, or other
applications. Larger applications like the Documents and Media library
have more modules. In the case of the Documents and Media library, there
are separate modules for different document storage back-ends. In the
case of the Wiki, there are separate modules for different Wiki engines.

Encapsulating capability variations as modules facilitates
extensibility. If you have a document storage back-end that Liferay DXP
doesn't yet support, you can implement Liferay's document storage API
for your solution by developing a module for it and thus extend
Liferay's Documents and Media library. If there's a Wiki dialect that
you like better than what Liferay's wiki provides, you can write a
module for it and extend Liferay's wiki.

Are you excited yet? Are you ready to start developing? Here are some
resources for you to learn more.

\subsection{Related Topics}\label{related-topics-199}

\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-ide}{Liferay IDE}

\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-workspace}{Liferay
Workspace}

\href{/docs/7-0/tutorials/-/knowledge_base/t/blade-cli}{Blade CLI}

\href{/docs/7-0/tutorials/-/knowledge_base/t/maven}{Maven}

\href{/docs/7-0/tutorials/-/knowledge_base/t/developing-a-web-application}{Developing
a Web Application}

\href{/docs/7-0/tutorials/-/knowledge_base/t/migrating-existing-code-to-liferay-7}{Planning
a Plugin Upgrade to Liferay 7}

\chapter{OSGi Basics for Liferay
Development}\label{osgi-basics-for-liferay-development}

Liferay leverages the OSGi framework to provide a development
environment for modular applications. There are many OSGi best practices
that Liferay DXP follows to provide an easy-to-develop-for platform.
Here, you're introduced to some OSGi basics and common Liferay best
practices for your bundle's (module) development.

\section{Liferay Portal Classloader
Hierarchy}\label{liferay-portal-classloader-hierarchy}

All Liferay DXP applications live in its OSGi container. Portal is a web
application deployed on your application server. Portal's Module
Framework bundles (modules) live in the OSGi container and have class
loaders. All the classloaders from Java's Bootstrap classloader to
classloaders for bundle classes and JSPs are part of a hierarchy.

This tutorial explains Liferay DXP's classloader hierarchy and describes
how it works in the following contexts:

\begin{itemize}
\tightlist
\item
  Web application, such as Liferay Portal, deployed on the app server
\item
  OSGi bundle deployed in the Module Framework
\end{itemize}

The following diagram shows Liferay DXP's classloader hierarchy.

\begin{figure}
\centering
\includegraphics{./images/portal-classloader-hierarchy.png}
\caption{0: Here is Liferay DXP's classloader hierarchy.}
\end{figure}

Here are the classloader descriptions:

\begin{itemize}
\item
  \textbf{Bootstrap}: The JRE's classes (from packages \texttt{java.*})
  and Java extension classes (from \texttt{\$JAVA\_HOME/lib/ext}). No
  matter the context, loading all \texttt{java.*} classes is delegated
  to the Bootstrap classloader.
\item
  \textbf{System}: Classes configured on the \texttt{CLASSPATH} and or
  passed in via the application server's Java classpath (\texttt{-cp} or
  \texttt{-classpath}) parameter.
\item
  \textbf{Common}: Classes accessible globally to web applications on
  the application server.
\item
  \textbf{Web Application}: Classes in the application's
  \texttt{WEB-INF/classes} folder and \texttt{WEB-INF/lib/*.jar}.
\item
  \textbf{Module Framework}: Liferay DXP's OSGi module framework
  classloader which is used to provide controlled isolation for the
  module framework bundles.
\item
  \textbf{bundle}: Classes from a bundle's packages or from packages
  other bundles export.
\item
  \textbf{JSP}: A classloader that aggregates the following bundle and
  classloaders:

  \begin{itemize}
  \tightlist
  \item
    Bundle that contains the JSPs' classloader
  \item
    JSP servlet bundle's classloader
  \item
    Javax Expression Language (EL) implementation bundle's classloader
  \item
    Javax JSTL implementation bundle's classloader
  \end{itemize}
\item
  \textbf{Service Builder}: Service Builder classes
\end{itemize}

The classloader used depends on context. Classloading rules vary between
application servers. Classloading in web applications and OSGi bundles
differs too. In all contexts, however, the Bootstrap classloader loads
classes from \texttt{java.*} packages.

Classloading from a web application perspective is up next.

\subsection{Web Application Classloading
Perspective}\label{web-application-classloading-perspective}

Application servers dictate where and in what order web applications,
such as Liferay DXP, search for classes and resources. Application
servers such as
\href{https://tomcat.apache.org/tomcat-7.0-doc/class-loader-howto.html}{Apache
Tomcat} enforce the following default search order:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Bootstrap classes
\item
  Web app's \texttt{WEB-INF/classes}
\item
  web app's \texttt{WEB-INF/lib/*.jar}
\item
  System classloader
\item
  Common classloader
\end{enumerate}

First, the web application searches Bootstrap. If the class/resource
isn't there, the web application searches its own classes and JARs. If
the class/resource still isn't found, it checks the System classloader
and then Common classloader. Except for the web application checking its
own classes and JARs, it searches the hierarchy in parent-first order.

Application servers such as
\href{https://docs.oracle.com/cd/E19501-01/819-3659/beadf/index.html}{Oracle
WebLogic} and IBM WebSphere have additional classloaders. They may also
have a different classloader hierarchy and search order. Consult your
application server's documentation for classloading details.

\subsection{Other Classloading
Perspectives}\label{other-classloading-perspectives}

The
\href{/docs/7-0/tutorials/-/knowledge_base/t/bundle-classloading-flow}{Bundle
Classloading Flow} tutorial explains classloading from an OSGi bundle
perspective.

Classloading for JSPs and Service Builder classes is similar to that of
web applications and OSGi bundle classes.

You now know Liferay DXP's classloading hierarchy, understand it in
context of web applications, and have references to information on other
classloading perspectives.

\subsection{Related Topics}\label{related-topics-200}

\href{/docs/7-0/tutorials/-/knowledge_base/t/bundle-classloading-flow}{Bundle
Classloading Flow}

\section{Bundle Classloading Flow}\label{bundle-classloading-flow}

The OSGi container searches several places for imported classes. It's
important to know where it looks and in what order. Liferay DXP's
classloading flow for OSGi bundles follows the OSGi Core specification.
It's straightforward, but complex. The figure below illustrates the flow
and this tutorial walks you through it.

\begin{figure}
\centering
\includegraphics{./images/bundle-classloading-flow-chart.png}
\caption{0: This flow chart illustrates classloading in a bundle.}
\end{figure}

Here is the algorithm for classloading in a bundle:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  If the class is in a \texttt{java.*} package, delegate loading to the
  parent classloader. Otherwise, continue.
\item
  If the class is in the OSGi Framework's boot delegation list, delegate
  loading to the parent classloader. Otherwise, continue.
\item
  If the class is in one of the packages the bundle imports from a wired
  exporter, the exporting bundle's classloader loads it. A \emph{wired
  exporter} is another bundle's classloader that previously loaded the
  package. If the class isn't found, continue.
\item
  If the class is imported by one of the bundle's required bundles, the
  required bundle's classloader loads it.
\item
  If the class is in the bundle's classpath (manifest header
  \texttt{Bundle-ClassPath}), the bundle's classloader loads it.
  Otherwise, continue.
\item
  If the class is in the bundle's fragments classpath, the bundle's
  classloader loads it.
\item
  If the class is in a package that's dynamically imported using
  \texttt{DynamicImport-Package} and a wire is established with the
  exporting bundle, the exporting bundle's classloader loads it.
  Otherwise, the class isn't found.
\end{enumerate}

Congratulations! Now you know how Liferay DXP finds and loads classes
OSGi bundles use.

\section{Resolving Third Party Library Package
Dependencies}\label{resolving-third-party-library-package-dependencies}

The OSGi framework lets you build applications composed of multiple
modules. The modules must resolve their Java package dependencies for
the framework to assemble the modules into a working system. In a
perfect world, every Java library would be an OSGi bundle (module), but
many libraries aren't. So how do you resolve the packages your OSGi
module needs from non-OSGi third party libraries?

Here is the main workflow for resolving third party Java library
packages:

\textbf{Step 1 - Find an OSGi module of the library}: Projects, such as
\href{https://www.eclipse.org/orbit/}{Eclipse Orbit} and
\href{https://servicemix.apache.org/developers/source/bundles-source.html}{ServiceMix
Bundles}, convert hundreds of traditional Java libraries to OSGi
modules. Their artifacts are available at these locations:

\begin{itemize}
\tightlist
\item
  \href{https://download.eclipse.org/tools/orbit/downloads/drops/R20170919201930/}{Eclipse
  Orbit}
\item
  \href{https://mvnrepository.com/artifact/org.apache.servicemix.bundles}{ServiceMix
  Bundles}
\end{itemize}

Deploying the module to Liferay's OSGi framework lets you share it on
the system. If you find a module for the library you need,
\href{/docs/7-0/tutorials/-/knowledge_base/t/starting-module-development\#building-and-deploying-a-module}{deploy}
it. Then add a \texttt{compileOnly} (Gradle) or
\texttt{\textless{}scope\textgreater{}provided\textless{}/scope\textgreater{}}
(Maven) dependency for it in your module. When you deploy your module,
the OSGi framework wires the dependency module to your module. If
there's no OSGi module based on the Java library, go to Step 2.

\noindent\hrulefill

\textbf{Tip:} Refrain from embedding library JARs that provide the same
\href{/docs/7-0/reference/-/knowledge_base/r/third-party-packages-portal-exports}{packages
that Liferay DXP or existing modules provide already}.

\noindent\hrulefill

\noindent\hrulefill

\textbf{Note:} If you're developing a WAR that requires a different
version of a third-party package that
\href{/docs/7-0/reference/-/knowledge_base/r/third-party-packages-portal-exports}{Liferay
DXP or another module exports}, specify that package in your
\href{/docs/7-0/tutorials/-/knowledge_base/t/importing-packages}{\texttt{Import-Package:}
list}. If the package provider is an OSGi module, publish its exported
packages by deploying that module. Otherwise, rename the third-party
library (not an OSGi module) differently from the
\href{/docs/7-0/tutorials/-/knowledge_base/t/resolving-a-plugins-dependencies\#understanding-excluded-jars}{JAR
that the WAB generator excludes} and embed the JAR in your project.

\noindent\hrulefill

\textbf{Step 2 - Resolve the Java packages privately in your module}:
You can copy required library packages into your OSGi module or embed
them wholesale, if you must. The rest of the tutorial shows you how to
do this.

\noindent\hrulefill

\textbf{Note}: Liferay's Gradle plugin \texttt{com.liferay.plugin}
automates several third party library configuration steps. The plugin is
applied to
\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-workspace}{Liferay
Workspace} Gradle module projects created in
\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-ide}{Liferay @ide@}
or using \href{/docs/7-0/tutorials/-/knowledge_base/t/blade-cli}{Liferay
Blade CLI} automatically.

To leverage the \texttt{com.liferay.plugin} plugin outside of Liferay
Workspace, add code like the listing below to your Gradle project:

\begin{verbatim}
 buildscript {
     dependencies {
         classpath group: "com.liferay", name: "com.liferay.gradle.plugins", version: "3.2.29"
     }

     repositories {
         maven {
             url "https://repository-cdn.liferay.com/nexus/content/groups/public"
         }
     }
 }

 apply plugin: "com.liferay.plugin"
\end{verbatim}

If you use Gradle without the \texttt{com.liferay.plugin} plugin, you'll
have to embed the third party libraries wholesale.

\noindent\hrulefill

The recommended package resolution workflow is next.

\subsection{Library Package Resolution
Workflow}\label{library-package-resolution-workflow}

When you depend on a library JAR, much of the time you only need parts
of it. Explicitly specifying only the Java packages you need makes your
bundle more modular. This also insulates modules that depend on your
module from unneeded packages.

Here's a configuration workflow that minimizes dependencies and Java
package imports:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add the library as a compile-only dependency (e.g.,
  \texttt{compileOnly} in Gradle).
\item
  Copy only the library packages you need by specifying them in a
  conditional package instruction (\texttt{Conditional-Package}) in your
  \texttt{bnd.bnd} file. Here are some examples:

  \texttt{Conditional-Package:\ foo.common*} adds packages your module
  uses such as \texttt{foo.common}, \texttt{foo.common-messages},
  \texttt{foo.common-web} to your module's class path.

  \texttt{Conditional-Package:\ foo.bar.*} adds packages your module
  uses such as \texttt{foo.bar} and all its sub-packages (e.g.,
  \texttt{foo.bar.baz}, \texttt{foo.bar.biz}, etc.) to your module's
  class path.

  Deploy your module. If a class your module needs or class its
  dependencies need isn't found, go back to main workflow \textbf{Step 1
  - Find an OSGi module version of the library} to resolve it.

  \textbf{Important}: Resolving packages by using compile-only
  dependencies and conditional package instructions assures you use only
  the packages you need and avoids unnecessary transitive dependencies.
  It's recommended to use the steps up to this point, as much as
  possible, to resolve required packages.
\item
  If a library package you depend on requires non-class files (e.g.,
  DLLs, descriptors) from the library, then you might need to
  \hyperref[embedding-libraries-in-a-module]{embed the library wholesale
  in your module}. This adds the entire library to your module's
  classpath.
\end{enumerate}

Next you'll learn how to embed libraries in your module.

\subsection{Embedding Libraries in a
Module}\label{embedding-libraries-in-a-module}

You can use Gradle, Maven, or Ivy to embed libraries in your module.
Below are examples for adding \href{https://shiro.apache.org}{Apache
Shiro} using all three build utilities.

\subsubsection{Embedding a Library Using
Gradle}\label{embedding-a-library-using-gradle}

Open your module's \texttt{build.gradle} file and add the library as a
dependency in the \texttt{compileInclude} configuration:

\begin{verbatim}
dependencies {
    compileInclude group: 'org.apache.shiro', name: 'shiro-core', version: '1.1.0'
}
\end{verbatim}

The \texttt{com.liferay.plugin} plugin's \texttt{compileInclude}
configuration is transitive. The \texttt{compileInclude} configuration
embeds the artifact and all its dependencies in a \texttt{lib} folder in
the module's JAR. Also, it adds the artifact JARs to the module's
\texttt{Bundle-ClassPath} manifest header.

\textbf{Note}: The \texttt{compileInclude} configuration does not
download transitive
\href{https://maven.apache.org/guides/introduction/introduction-to-optional-and-excludes-dependencies.html}{optional
dependencies}. If your module requires such artifacts, add them as you
would another third party library.

\noindent\hrulefill

\textbf{Note:} If the library you've added as a dependency in your
\texttt{build.gradle} file has transitive dependencies, you can
reference them in an \texttt{-includeresource:} instruction by name
without having to add them explicitly to the list of dependencies. See
how it's used in the Maven section next.

\noindent\hrulefill

\subsubsection{Embedding a Library Using Maven or
Ivy}\label{embedding-a-library-using-maven-or-ivy}

Follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open your module's build file and add the library as a dependency in
  the \texttt{provided} scope:

  \textbf{Maven:}

\begin{verbatim}
<dependency>
  <groupId>org.apache.shiro</groupId>
  <artifactId>shiro-core</artifactId>
  <version>1.1.0</version>
  <scope>provided</scope>
</dependency>
\end{verbatim}

  \textbf{Ant/Ivy:}

\begin{verbatim}
<dependency conf="provided" name="shiro-core" org="org.apache.shiro" rev="1.1.0" />
\end{verbatim}
\item
  Open your module's \texttt{bnd.bnd} file and add the library to an
  \texttt{-includeresource} instruction:

\begin{verbatim}
-includeresource: META-INF/lib/shiro-core.jar=shiro-core-[0-9]*.jar;lib:=true
\end{verbatim}

  This instruction adds the \texttt{shiro-core-{[}version{]}.jar} file
  as an included resource in the module's \texttt{META-INF/lib} folder.
  The \texttt{META-INF/lib/shiro-core.jar} is your module's embedded
  library. The expression \texttt{{[}0-9{]}*} helps the build tool match
  the library version to make available on the module's classpath. The
  \texttt{lib:=true} directive adds the embedded JAR to the module's
  classpath via the \texttt{Bundle-Classpath} manifest header.
\end{enumerate}

Lastly, if after embedding a library you get unresolved imports when
trying to deploy to Liferay, you may need to blacklist some imports:

\begin{verbatim}
Import-Package:\
    !foo.bar.baz,\
    *
\end{verbatim}

The \texttt{*} character represents all packages that the module refers
to explicitly. Bnd detects the referenced packages.

Congratulations! Resolving all of your module's package dependencies,
especially those from traditional Java libraries, is a quite an
accomplishment.

\subsection{Related Topics}\label{related-topics-201}

\href{/docs/7-0/tutorials/-/knowledge_base/t/importing-packages}{Importing
Packages}

\href{/docs/7-0/tutorials/-/knowledge_base/t/exporting-packages}{Exporting
Packages}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-modules-with-blade-cli}{Creating
Modules with Blade CLI}

\section{Overriding Reluctant Service
References}\label{overriding-reluctant-service-references}

When there's an existing service that you want to customize or implement
differently, you can override the existing one. To do this, you create
and deploy a new, higher-ranked service implementation. But how do you
replace a component's service that's bound by a static and reluctant
reference? Reactivating the component would bind it to the new service
but would render the component temporarily inactive. To replace the
service and keep the component active, you can change the component's
service reference to target your new service.

Here are the steps for overriding a component's service reference:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Find the component and service details.
\item
  Create a custom service.
\item
  Configure the component to use the custom service.
\end{enumerate}

Throughout the tutorial, example modules
\texttt{override-my-service-reference} and
\texttt{overriding-service-reference} are used. You can download them
and build them using Gradle (bundled with each module) or you can apply
the tutorial steps to configure your own customization. Executing
\texttt{gradlew\ jar} in each example module root generates the module
JAR to the \texttt{build/libs} folder.

\begin{itemize}
\item
  \texttt{override-my-service-reference}
  (\href{https://portal.liferay.dev/documents/113763090/114000186/override-my-service-reference.zip}{download}):
  This module's portlet component
  \texttt{OverrideMyServiceReferencePortlet}'s field
  \texttt{\_someService} references a service of type
  \texttt{SomeService}. The reference's policy is static and reluctant.
  By default, it binds to an implementation called
  \texttt{SomeServiceImpl}.
\item
  \texttt{overriding-service-reference}
  (\href{https://portal.liferay.dev/documents/113763090/114000186/overriding-service-reference.zip}{download}):
  Provides a custom \texttt{SomeService} implementation called
  \texttt{CustomServiceImpl}. The module's configuration file overrides
  \texttt{OverrideMyServiceReferencePortlet}'s \texttt{SomeService}
  reference so that it binds to \texttt{CustomServiceImpl}.
\end{itemize}

\begin{figure}
\centering
\includegraphics{./images/overriding-service-refs-default-impl.png}
\caption{Prior to overriding the service reference in example portlet
module \texttt{override-my-service-reference}, the portlet's message
indicates it's calling the default service implementation
\texttt{override.my.service.reference.service.impl.SomeServiceImpl}}
\end{figure}

The first step to overriding a service reference is finding the name of
the component, service reference, and service interface. If you already
have them, you can skip the next section.

\subsection{Find the Component and Service
Reference}\label{find-the-component-and-service-reference}

You must have the following information to create a custom service and
configure the component to use it.

\begin{itemize}
\tightlist
\item
  \emph{Component name}: Name of the component whose service to replace.
\item
  \emph{Reference name}: Name of the component field that references the
  service.
\item
  \emph{Service interface}: Fully qualified name of the referenced
  service interface.
\end{itemize}

You can
\href{/docs/7-0/tutorials/-/knowledge_base/t/finding-extension-points\#locate-the-related-module-and-component}{find
the component} using Liferay DXP's
\href{/docs/7-0/user/-/knowledge_base/u/managing-and-configuring-apps\#using-the-app-manager}{Application
Manager} and find the service reference information using
\href{/docs/7-0/reference/-/knowledge_base/r/using-the-felix-gogo-shell}{Felix
Gogo Shell}.

Gogo Shell's Service Component Runtime (SCR) commands help you inspect
components. The Gogo Shell command
\texttt{scr:info\ {[}componentName{]}} lists the component's attributes,
including the services it uses. Execute the command using
\href{/docs/7-0/tutorials/-/knowledge_base/t/blade-cli}{Liferay Blade
CLI} or in
\href{/docs/7-0/reference/-/knowledge_base/r/using-the-felix-gogo-shell}{Gogo
Shell via telnet}.

Here's an example of executing the \texttt{scr:info} command in a Gogo
Shell telnet session:

\begin{verbatim}
scr:info override.my.service.reference.OverrideMyServiceReference 
\end{verbatim}

The resulting SCR information includes the component's service
references.

For example, the following information describes the component's
reference to service \texttt{SomeService}:

\begin{verbatim}
...
Component Description:
    Name: override.my.service.reference.portlet.OverrideMyServiceReferencePortlet
...
Reference: _someService
    Interface Name: override.my.service.reference.service.api.SomeService
    Cardinality: 1..1
    Policy: static
    Policy option: reluctant
    Reference Scope: bundle
...
\end{verbatim}

Copy the following values from the command results. You'll use them in
the custom service and service reference configuration you create later.

\begin{itemize}
\tightlist
\item
  \emph{Component}: The component name you passed to the
  \texttt{scr:info} command.
\item
  \emph{Reference}: The \emph{Reference} value.
\item
  \emph{Interface}: The \emph{Interface Name} in the \emph{Reference}
  section.
\end{itemize}

Note that the example result confirm's that the reference's policy and
policy option are \texttt{static} and \texttt{reluctant}, respectively.

Here are the values for the example:

\begin{itemize}
\tightlist
\item
  \emph{Component name}:
  \texttt{override.my.service.reference.portlet.OverrideMyServiceReferencePortlet}
\item
  \emph{Reference name}: \texttt{\_someService}
\item
  \emph{Service interface}:
  \texttt{override.my.service.reference.service.api.SomeService}
\end{itemize}

The \texttt{scr:info} result's component configuration describes the
service component implementation bound to the reference.

\begin{verbatim}
...
Component Configuration:
ComponentId: 2399
State: active
SatisfiedReference: _someService
  Target: null
  Bound to:        6840
      Properties:
        component.id = 2400
        component.name = override.my.service.reference.service.impl.SomeServiceImpl
        objectClass = [override.my.service.reference.service.api.SomeService]
        service.bundleid = 524
        service.id = 6840
        service.scope = bundle
...
\end{verbatim}

The example's reference is bound to a component named
\texttt{override.my.service.reference.service.impl.SomeServiceImpl}. By
the end of this tutorial, the reference will be reconfigured to bind to
a custom service implementation.

\noindent\hrulefill

\textbf{Note}: OSGi Configuration Admin makes all Declarative Services
components configurable, even if they don't explicitly declare anything
about configuration. Each \texttt{@Reference} annotation in the source
code has a name property, either \emph{explicitly} set in the annotation
or \emph{implicitly} derived from the name of the member on which the
annotation is used.

\begin{itemize}
\tightlist
\item
  If no reference name property is used and the \texttt{@Reference} is
  on a field, then the reference name is the field name.
\item
  If the \texttt{@Reference} is on a method, then heuristics derive the
  reference name. Method name prefixes such as \texttt{set},
  \texttt{add}, and \texttt{put} are ignored. If \texttt{@Reference} is
  on a method called\texttt{setSearchEngine(SearchEngine\ se)}, for
  example, then the reference name is \texttt{SearchEngine}.
\end{itemize}

\noindent\hrulefill

Once you've found the referenced service component implementation, you
can implement a replacement for it. If you've already created one, you
can skip this section.

\subsection{Create Your Service}\label{create-your-service}

It's time to create your own service implementation. Refer to the
appropriate \href{Liferay\%20DXP}{app, app suite}, and
\href{@platform-ref@/7.0-latest/javadocs/modules}{Liferay DXP module}
Javadoc for service interface details.

\href{/docs/7-0/tutorials/-/knowledge_base/t/starting-module-development}{Create
a module} and implement your service in it. Use the \texttt{@Component}
annotation to make the service a Declarative Services component.

The example custom implementation for service \texttt{SomeService} looks
like this:

\begin{verbatim}
@Component(
    immediate = true,
    service = SomeService.class
)
public class CustomServiceImpl implements SomeService {

    @Override
    public String doSomething() {

        StringBuilder sb = new StringBuilder();
        sb.append(this.getClass().getName());
        sb.append(", which delegates to ");
        sb.append(_defaultService.doSomething());

        return sb.toString();
    }

    @Reference  (
        unbind = "-",
        target = "(component.name=override.my.service.reference.service.impl.SomeServiceImpl)"
    )
    private SomeService _defaultService;
}
\end{verbatim}

The service component above refers to the default service so that it can
delegate work to it in its \texttt{doSomething} method. The reference
targets the default service by its component name
\texttt{override.my.service.reference.service.impl.SomeServiceImpl}.

To register your service with the Liferay DXP's OSGi runtime framework,
\href{/docs/7-0/tutorials/-/knowledge_base/t/starting-module-development\#building-and-deploying-a-module}{deploy
its module}. To bind the component reference to your custom service, you
must create and deploy instructions that configure the component
reference to target your custom service.

\subsection{Configure the Component to Use Your
Service}\label{configure-the-component-to-use-your-service}

You're ready to change the component's service reference to target your
service. Liferay DXP's Configuration Admin lets you use configuration
files to swap in service references on the fly.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a configuration file named after the referencing component.
  Here's the example component's configuration file name:

\begin{verbatim}
override.my.service.reference.portlet.OverrideMyServiceReferencePortlet.config
\end{verbatim}
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** Liferay DXP DE 7.0 Fix Pack 8 and later, and Liferay CE Portal 7.0
 GA4 and later support the Apache Felix ConfigAdmin implementation of OSGi
 Configuration Admin files. Felix ConfigAdmin uses the file suffix `.config`
 and supports additional types, such as arrays and vectors. The syntax for
 `.config` and `.cfg` files can be found
 [here](https://sling.apache.org/documentation/bundles/configuration-installer-factory.html).
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\item
  In the configuration file, add a reference target entry that filters
  on your custom service. Follow this format for the entry:

\begin{verbatim}
[reference].target=[filter]
\end{verbatim}

  Replace \texttt{{[}reference{]}} with the name of the reference you're
  overriding. Replace \texttt{{[}filter{]}} with service properties that
  filter on your custom service.
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Tip**: You can use a `component.name` or `objectClass` reference to filter
 on your custom implementation.
\end{verbatim}

\noindent\hrulefill

\begin{verbatim}
A `.config` file reference target entry for the example looks like this:

    _someService.target="(component.name\=overriding.service.reference.service.CustomServiceImpl)"

[The `.config` file syntax](https://sling.apache.org/documentation/bundles/configuration-installer-factory.html#configuration-files-config) 
requires surrounding the value in double quotes and escaping the value's
equals sign. 

A `.cfg` file entry for the example looks like this:

    _someService.target=(component.name=overriding.service.reference.service.CustomServiceImpl)
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\item
  Optionally, you can add a \texttt{cardinality.minimum} entry to
  specify the number of services the reference can use. Here's the
  format:

\begin{verbatim}
[reference].cardinality.minimum=[int]
\end{verbatim}

  Here's an example cardinality minimum:

\begin{verbatim}
_someService.cardinality.minimum=1
\end{verbatim}
\item
  Deploy the configuration by copying the configuration file into the
  folder \texttt{{[}Liferay\_Home{]}/osgi/configs}.
\end{enumerate}

Executing \texttt{scr:info} on your component shows that the custom
service implementation is now bound to the reference.

For example, executing
\texttt{scr:info\ override.my.service.reference.portlet.OverrideMyServiceReferencePortlet}
reports the following information:

\begin{verbatim}
...
Component Description:
  Name: override.my.service.reference.portlet.OverrideMyServiceReferencePortlet
  ...
  Reference: _someService
    Interface Name: override.my.service.reference.service.api.SomeService
    Cardinality: 1..1
    Policy: static
    Policy option: reluctant
    Reference Scope: bundle
    ...
  Component Configuration:
    ComponentId: 2399
    State: active
    SatisfiedReference: _someService
      Target: (component.name=overriding.service.reference.CustomServiceImpl)
      Bound to:        6841
          Properties:
            _defaultService.target = (component.name=overriding.service.reference.service.CustomServiceImpl)
            component.id = 2398
            component.name = overriding.service.reference.service.CustomServiceImpl
            objectClass = [override.my.service.reference.service.api.SomeService]
            service.bundleid = 525
            service.id = 6841
            service.scope = bundle
      Component Configuration Properties:
        _someService.target = (component.name=overriding.service.reference.service.CustomServiceImpl)
        ...
\end{verbatim}

The example component's \texttt{\_someService} reference targets custom
service component
\texttt{overriding.service.reference.service.CustomServiceImpl}.
\texttt{CustomServiceImpl} references default service
\texttt{SomeServiceImpl} to delegates work to it.

\begin{figure}
\centering
\includegraphics{./images/overriding-service-refs-result.png}
\caption{Because the example component's service reference is overridden
by the configuration file deployment, the portlet indicates it's calling
the custom service.}
\end{figure}

Liferay DXP processed the configuration file and injected the service
reference, which in turn bound the custom service to the referencing
component!

\subsection{Related Topics}\label{related-topics-202}

\begin{itemize}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/finding-extension-points}{Finding
  Extension Points}
\item
  \href{/docs/7-0/reference/-/knowledge_base/r/using-the-felix-gogo-shell}{Using
  Felix Gogo Shell}
\end{itemize}

\section{Using the WAB Generator}\label{using-the-wab-generator}

Developers creating applications for 7.0 can choose to create them as
Java EE-style Web Application ARchive (WAR) artifacts or as Java ARchive
(JAR) OSGi bundle artifacts. Some plugin developers, however, don't have
that flexibility. Portlets like Spring MVC and JSF must be packaged as
WAR artifacts because their frameworks are designed for Java EE.
Therefore, they expect a WAR layout and require Java EE resources such
as the \texttt{WEB-INF/web.xml} descriptor.

Liferay provides a way for these WAR-styled plugins to be deployed and
treated like OSGi modules by Liferay's OSGi runtime. They can be
converted to \emph{WABs}.

7.0 supports the OSGi Web Application Bundle (WAB) standard for
deployment of Java EE style WARs. Simply put, a WAB is an archive that
has a WAR layout and contains a \texttt{META-INF/MANIFEST.MF} file with
the \texttt{Bundle-SymbolicName} OSGi directive. A WAB is an OSGi
bundle. Although the source of the project has a WAR layout, the
artifact filename may end with either the \texttt{.jar} or \texttt{.war}
extension.

Liferay only supports the use of WABs that have been auto-generated by
the WAB Generator. The WAB Generator transforms a general WAR-style
plugin into a WAB during its deployment process. So what exactly does
the WAB Generator do to a WAR file to transform it into a WAB?

The WAB Generator detects packages referenced in a plugin WAR's JSPs,
descriptor files, and classes (in \texttt{WEB-INF/classes} and embedded
JARs). The descriptor files include \texttt{web.xml},
\texttt{liferay-web.xml}, \texttt{portlet.xml},
\texttt{liferay-portlet.xml}, and \texttt{liferay-hook.xml}. The WAB
Generator verifies whether the detected packages are in the plugin's
\texttt{WEB-INF/classes} folder or in an embedded JAR in the
\texttt{WEB-INF/lib} folder. Packages that aren't found in either
location are added to an \texttt{Import-Package} header in the WAB's
\texttt{META-INF/MANIFEST.MF} file.

To import a package that is only referenced in the following types of
locations, you must add an \texttt{Import-Package} OSGi header to the
plugin's \texttt{WEB-INF/liferay-plugin-package.properties} file and add
the package to the header's list of values. - Unrecognized descriptor
file - Custom or unrecognized descriptor element or attribute -
Reflection code - Class loader code

\noindent\hrulefill

\textbf{Note}: A
\href{https://issues.liferay.com/browse/LPS-76229}{known issue} is
preventing packages referenced in \texttt{web.xml} file
\texttt{listener-class} elements from being detected and added to WAB
\texttt{META-INF/MANIFEST.MF} file \texttt{Import-Package} headers. To
import such packages, add them to an \texttt{Import-Package} header in
the plugin's \texttt{WEB-INF/liferay-plugin-package.properties} file.

\noindent\hrulefill

The WAB folder structure and WAR folder structure differ. Consider the
following folder structure of a WAR-style portlet:

\begin{itemize}
\tightlist
\item
  my-war-portlet

  \begin{itemize}
  \tightlist
  \item
    src

    \begin{itemize}
    \tightlist
    \item
      main

      \begin{itemize}
      \tightlist
      \item
        java
      \item
        webapp

        \begin{itemize}
        \tightlist
        \item
          WEB-INF

          \begin{itemize}
          \tightlist
          \item
            classes
          \item
            lib
          \item
            resources
          \item
            views
          \item
            faces-config.xml
          \item
            liferay-display.xml
          \item
            liferay-plugin-package.properties
          \item
            liferay-portlet.xml
          \item
            portlet.xml
          \item
            web.xml
          \end{itemize}
        \end{itemize}
      \end{itemize}
    \end{itemize}
  \end{itemize}
\end{itemize}

When a WAR-style portlet is deployed to Liferay DXP and processed by the
WAB Generator, the portlet's folder structure is transformed to
something like this

\begin{itemize}
\tightlist
\item
  my-war-portlet-that-is-now-a-wab

  \begin{itemize}
  \tightlist
  \item
    META-INF

    \begin{itemize}
    \tightlist
    \item
      MANIFEST.MF
    \end{itemize}
  \item
    WEB-INF

    \begin{itemize}
    \tightlist
    \item
      classes
    \item
      lib
    \item
      resources
    \item
      views
    \item
      faces-config.xml
    \item
      liferay-display.xml
    \item
      liferay-plugin-package.properties
    \item
      liferay-portlet.xml
    \item
      portlet.xml
    \item
      web.xml
    \end{itemize}
  \end{itemize}
\end{itemize}

The major difference is the addition of the
\texttt{META-INF/MANIFEST.MF} file. The WAB Generator automatically
generates an OSGi-ready \texttt{MANIFEST.MF} file. If you want to affect
the content of the manifest file, you can place BND directives and OSGi
headers directly into the \texttt{liferay-plugin-package.properties}
file. A \texttt{bnd.bnd} and/or a build-time plugin (e.g.,
\texttt{bnd-maven-plugin}) should not be provided for your WAR plugin,
because the generated WAB cannot make use of them.

Do you want to try this out for yourself? Follow the steps below to see
the WAB Generator in action.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a WAR-style plugin that follows a similar structure to the one
  outlined above. You can download an example WAR-style portlet
  \href{https://portal.liferay.dev/documents/113763090/114000186/com.liferay.hello.user.jsf.portlet-1.0-SNAPSHOT.war}{here},
  for demonstration.
\item
  Open your Liferay DXP instance in a file explorer and add a
  \texttt{portal-ext.properties} file with the following properties:

\begin{verbatim}
module.framework.web.generator.generated.wabs.store=true
module.framework.web.generator.generated.wabs.store.dir=${module.framework.base.dir}/wabs
\end{verbatim}

  These properties store your generated WAB into your Liferay DXP
  instance's \texttt{osgi/wabs} folder. You can learn more about these
  properties in the
  \href{@platform-ref@/7.0-latest/propertiesdoc/portal.properties.html\#Module\%20Framework\%20Web\%20Application\%20Bundles}{Module
  Framework Web Application Bundles} properties section. Restart Liferay
  DXP for these changes to be recognized.
\item
  Copy your WAR plugin in your Liferay DXP instance's \texttt{deploy}
  folder.
\item
  Navigate to your Liferay DXP instance's \texttt{osgi/wabs} folder and
  inspect the generated WAB.
\end{enumerate}

Awesome! You've seen the WAB Generator in action!

\subsection{Related Topics}\label{related-topics-203}

\href{/docs/7-0/tutorials/-/knowledge_base/t/generating-a-jsf-application}{Generating
a JSF Application}

\href{/docs/7-0/tutorials/-/knowledge_base/t/customizing-the-product-menu}{Customizing
the Product Menu}

\href{/docs/7-0/tutorials/-/knowledge_base/t/configuration}{Configuration}

\section{Importing Packages}\label{importing-packages}

Your modules will often need to use Java classes from packages
\href{/docs/7-0/tutorials/-/knowledge_base/t/exporting-packages}{exported}
by other modules. When a module is set up to import, the OSGi framework
finds other registered modules that export the needed packages and wires
them to the importing module. At run time, the importing module gets the
class from the wired module that exports the class's package.

For this to happen, a module must specify the
\href{https://bnd.bndtools.org/heads/import_package.html}{\texttt{Import-Package}}
OSGi manifest header with a comma-separated list of the Java packages it
needs. For example, if a module needs classes from the
\texttt{javax.portlet} and \texttt{com.liferay.portal.kernel.util}
packages, it must specify them like so:

\begin{verbatim}
Import-Package: javax.portlet,com.liferay.portal.kernel.util,*
\end{verbatim}

The \texttt{*} character represents all packages that the module refers
to explicitly. Bnd detects the referenced packages.

Import packages must sometimes be specified manually, but not always.
Conveniently, Liferay DXP project templates and tools automatically
detect the packages a module uses and add them to the package imports in
the module JAR's manifest. Let's explore how package imports are
specified in different scenarios.

\href{/docs/7-0/reference/-/knowledge_base/r/project-templates}{Gradle
and Maven module projects} created using
\href{/docs/7-0/tutorials/-/knowledge_base/t/blade-cli}{Blade CLI},
\href{/docs/7-0/tutorials/-/knowledge_base/t/maven}{Liferay's Maven
archetypes}, or
\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-ide}{Liferay @ide@}
use \href{http://bnd.bndtools.org/}{bnd}. On building such a project's
module JAR, bnd detects the packages the module uses and generates a
\texttt{META-INF/MANIFEST.MF} file whose \texttt{Import-Package} header
specifies the packages.

\noindent\hrulefill

\textbf{Note}: Liferay's Maven module archetypes use the
\texttt{bnd-maven-plugin}. Liferay's Gradle module project templates use
\href{https://github.com/TomDmitriev/gradle-bundle-plugin}{a third-party
Gradle plugin} to invoke bnd.

\noindent\hrulefill

For example, suppose you're developing a Liferay module using Maven or
Gradle. In most cases, you specify your module's dependencies in your
\texttt{pom.xml} or \texttt{build.gradle} file. At build time, the Maven
or Gradle bundle plugin reads your \texttt{pom.xml} or
\texttt{build.gradle} file and bnd adds the required
\texttt{Import-Package} headers to your module JAR's
\texttt{META-INF/MANIFEST.MF}.

Here's an example dependencies section from a module's
\texttt{build.gradle} file:

\begin{verbatim}
dependencies {
    compileOnly group: "com.liferay.portal", name: "com.liferay.portal.kernel", version: "2.0.0"
    compileOnly group: "javax.portlet", name: "portlet-api", version: "2.0"
    compileOnly group: "org.osgi", name: "org.osgi.service.component.annotations", version: "1.3.0"
}
\end{verbatim}

And here's the \texttt{Import-Package} header that's generated in the
module JAR's \texttt{META-INF/MANIFEST.MF} file:

\begin{verbatim}
Import-Package: com.liferay.portal.kernel.portlet.bridges.mvc;version=
"[1.0,2)",com.liferay.portal.kernel.util;version="[7.0,8)",javax.nami
ng,javax.portlet;version="[2.0,3)",javax.servlet,javax.servlet.http,j
avax.sql
\end{verbatim}

Note that your build file need only specify JAR file dependencies. bnd
examines your module's class path to determine which packages from those
JAR files contain classes your application uses and imports the
packages. The examination includes all classes found in the class
path--even those from embedded
\href{/docs/7-0/tutorials/-/knowledge_base/t/adding-third-party-libraries-to-a-module}{third
party library JARs}.

Regarding classes used by a traditional Liferay plugin WAR,
\href{/docs/7-0/tutorials/-/knowledge_base/t/using-the-wab-generator}{Liferay's
WAB Generator} detects their use in the WAR's JSPs, descriptor files,
and classes (in \texttt{WEB-INF/classes} and embedded JARs). The WAB
Generator searches the \texttt{web.xml}, \texttt{liferay-web.xml},
\texttt{portlet.xml}, \texttt{liferay-portlet.xml}, and
\texttt{liferay-hook.xml} descriptor files. It adds package imports for
classes that are neither found in the plugin's \texttt{WEB-INF/classes}
folder nor in embedded JARs.

The WAB Generator and bnd don't add package imports for classes
referenced in these places:

\begin{itemize}
\tightlist
\item
  Unrecognized descriptor file
\item
  Custom or unrecognized descriptor element or attribute
\item
  Reflection code
\item
  Class loader code
\end{itemize}

In such cases, you must manually determine these packages and specify an
\texttt{Import-Package} OSGi header that includes these packages and the
packages that Bnd detects automatically. The \texttt{Import-Package}
header belongs in the location appropriate to your project type:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.2727}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.7273}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Project type
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\texttt{Import-Package} header location
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Module (uses bnd) & \texttt{{[}project{]}/bnd.bnd} \\
Module (doesn't use bnd) &
\texttt{{[}module\ JAR{]}/META-INF/MANIFEST.MF} \\
Traditional Liferay plugin WAR &
\texttt{WEB-INF/liferay-plugin-package.properties} \\
\end{longtable}

Here's an example of adding a package called
\texttt{com.liferay.docs.foo} to the list of referenced packages that
Bnd detects automatically:

\begin{verbatim}
Import-Package:\
    com.liferay.docs.foo,\
    *
\end{verbatim}

\noindent\hrulefill

\textbf{Note:} The WAB Generator refrains from adding WAR project
embedded third-party JARs to a WAB if
\href{/docs/7-0/tutorials/-/knowledge_base/t/resolving-a-plugins-dependencies\#understanding-excluded-jars}{Liferay
DXP already exports the JAR's packages}.

If your WAR requires a different version of a third-party package that
Liferay DXP exports, specify that package in your
\texttt{Import-Package:} list. Then if the package provider is an OSGi
module, publish its exported packages by deploying the module. If the
package provider is not an OSGi module, follow\\
the instructions for
\href{/docs/7-0/tutorials/-/knowledge_base/t/adding-third-party-libraries-to-a-module}{adding
third-party libraries}.

\noindent\hrulefill

Please see the
\href{https://bnd.bndtools.org/heads/import_package.html}{\texttt{Import-Package}}
header documentation for more information.

Congratulations! Now you can import all kinds of packages for your
modules and plugins to use.

\subsection{Related Topics}\label{related-topics-204}

\href{/docs/7-0/tutorials/-/knowledge_base/t/configuring-dependencies}{Configuring
Dependencies}

\href{/docs/7-0/tutorials/-/knowledge_base/t/resolving-a-plugins-dependencies}{Resolving
a Plugin's Dependencies}

\href{/docs/7-0/tutorials/-/knowledge_base/t/using-the-wab-generator}{Using
the WAB Generator}

\href{/docs/7-0/tutorials/-/knowledge_base/t/tooling}{Tooling}

\section{Exporting Packages}\label{exporting-packages}

An OSGi module's Java packages are private by default. To expose a
package, you must explicitly export it. This way you share only the
classes you want to share. Exporting a package in your OSGi module JAR's
manifest makes all the package's classes available for other modules to
\href{/docs/7-0/tutorials/-/knowledge_base/t/importing-packages}{import}.

To export a package, add it to your module's or plugin's
\texttt{Export-Package} OSGi header. A header exporting
\texttt{com.liferay.petra.io} and \texttt{com.liferay.petra.io.unsync}
would look like this:

\begin{verbatim}
Export-Package:\
com.liferay.petra.io,\
com.liferay.petra.io.unsync
\end{verbatim}

The correct location for the header depends on your project's type:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.2727}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.7273}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Project Type
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\texttt{Export-Package} header location
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Module (uses bnd) & \texttt{{[}project{]}/bnd.bnd} \\
Module (doesn't use bnd) &
\texttt{{[}module\ JAR{]}/META-INF/MANIFEST.MF} \\
Traditional Liferay plugin WAR &
\texttt{WEB-INF/liferay-plugin-package.properties} \\
\end{longtable}

Module projects created using
\href{/docs/7-0/tutorials/-/knowledge_base/t/blade-cli}{Blade CLI},
\href{/docs/7-0/tutorials/-/knowledge_base/t/maven}{Liferay's Maven
archetypes}, or
\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-ide}{Liferay @ide@}
use \href{http://bnd.bndtools.org/}{bnd}. On building such a project's
module JAR, bnd propagates the OSGi headers from the project's
\texttt{bnd.bnd} file to the JAR's \texttt{META-INF/MANIFEST.MF}.

In module projects that don't use bnd, you must manually add package
exports to an \texttt{Export-Package} header in the module JAR's
\texttt{META-INF/MANIFEST.MF}.

In traditional Liferay plugin WAR projects, you must add package exports
to an \texttt{Export-Package} header in the project's
\texttt{liferay-plugin-package.properties}. On copying the WAR into the
\texttt{{[}Liferay\ Home{]}/deploy} folder, the
\href{/docs/7-0/tutorials/-/knowledge_base/t/using-the-wab-generator}{WAB
Generator} propagates the OSGi headers from the WAR's
\texttt{liferay-plugin-package.properties} file to the
\texttt{META-INF/MANIFEST.MF} file in the generated Web Application
Bundle (WAB).

\noindent\hrulefill

\textbf{Note}: bnd makes a module's exported packages
\emph{substitutable}. That is, the OSGi framework can substitute your
module's exported package with a compatible package of the same name,
but potentially different version, that's exported from a different
module. bnd enables this for your module by automatically making your
module import every package it exports. In this way, your module can
work on its own, but can also work in conjunction with modules that
provide a different (compatible) version, or even the same version, of
the package. A package from another module might provide better
``wiring'' opportunities with other modules.
\href{http://blog.osgi.org/2007/04/importance-of-exporting-nd-importing.html}{Peter
Kriens' blog post} provides more details on how substitutable exports
works.

\noindent\hrulefill

\noindent\hrulefill

\textbf{Important:} Don't export the same package from different JARs.
Multiple exports of the same package leads to ``split package'' issues,
whose side affects differ from case to case.

\noindent\hrulefill

Now you can share your module's or plugin's terrific {[}EDITOR: or
terrible!{]} packages with other modules!

\subsection{Related Topics}\label{related-topics-205}

\href{/docs/7-0/tutorials/-/knowledge_base/t/using-the-wab-generator}{Using
the WAB Generator}

\href{/docs/7-0/tutorials/-/knowledge_base/t/tooling}{Tooling}

\section{Semantic Versioning}\label{semantic-versioning}

\href{https://semver.org}{Semantic Versioning} is a three tiered
versioning system that increments version numbers based on the type of
API change introduced to a releasable software component. It's a
standard way of communicating programmatic compatibility of a package or
module for dependent consumers and API implementations. If a package is
programmatically (i.e., semantically) incompatible with a project,
\href{http://bnd.bndtools.org}{Bnd} (used when building modules) fails
that project's build immediately.

The semantic version format looks like this:

\begin{verbatim}
MAJOR.MINOR.MICRO
\end{verbatim}

Certain events force each tier to be incremented:

\begin{itemize}
\tightlist
\item
  \emph{MAJOR:} an incompatible, API-breaking change is made
\item
  \emph{MINOR:} a change that affects only providers of the API, or new
  backwards- compatible functionality is added
\item
  \emph{MICRO:} a backwards-compatible bug fix is made
\end{itemize}

For more details on semantic versioning, see the official
\href{https://semver.org/}{Semantic Versioning} site and
\href{http://www.osgi.org/wp-content/uploads/SemanticVersioning1.pdf}{OSGi
Alliance's Semantic Versioning} technical whitepaper.

All of Liferay DXP's modules use Semantic Versioning.

Following Semantic Versioning is especially important because Liferay
DXP is a modular platform containing hundreds of independent OSGi
modules. With many independent modules containing a slew of
dependencies, releasing new package versions can quickly become
terrifying. With this complex intertwined system of dependencies, you
must meticulously manage your own project's API versions to ensure
compatibility for those who leverage it. With Semantic Versioning's
straightforward system and the help of Liferay tooling, managing your
project's versions is easy.

\subsection{Baselining Your Project}\label{baselining-your-project}

Following Semantic Versioning manually seems deceptively easy. There's a
sad history of good-intentioned developers updating their projects'
semantic versions manually, only to find out later they made a mistake.
The truth is, it's hard to anticipate the ramifications of a simple
update. To avoid this, you can \emph{baseline} your project after it has
been updated. Baselining verifies that the Semantic Versioning rules are
obeyed by your project. This can catch many obvious API changes that are
not so obvious to humans. Care must always be taken, however, when
making any kind of code change because this tool is not smart enough to
identify compatibility changes not represented in the signatures of Java
classes or interfaces, or in API \emph{use} changes (e.g., assumptions
about method call order, or changes to input and/or output encoding).
Baseline, as the name implies, does give you a certain measure of
\emph{baseline} comfort that a large class of compatibility issues won't
sneak past you.

You can use Liferay's Baseline Gradle plugin to provide baselining
capabilities. Add it to your Gradle build configuration and execute the
following command:

\begin{verbatim}
./gradlew baseline
\end{verbatim}

See the
\href{/docs/7-0/reference/-/knowledge_base/r/baseline-gradle-plugin}{Baseline
Gradle Plugin} article for configuration details. This plugin is not
provided in
\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-workspace}{Liferay
Workspace} by default.

When you run the \texttt{baseline} command, the plugin baselines your
new module against the latest released non-snapshot module (i.e., the
baseline). That is, it compares the public exported API of your new
module with the baseline. If there are any changes, it uses the OSGi
Semantic Versioning rules to calculate the minimum new version. If your
new module has a lower version, errors are thrown.

With baselining, your project's Semantic Versioning is as accurate as
its API expresses.

\subsection{Managing Artifact and Dependency
Versions}\label{managing-artifact-and-dependency-versions}

There are two ways to track your project's artifact and dependency
versions with Semantic Versioning:

\begin{itemize}
\tightlist
\item
  Range of versions
\item
  Exact version (one-to-one)
\end{itemize}

You should track a range of versions if you intend to build your project
for multiple versions of Liferay DXP and maintain maximum compatibility.
In other words, if several versions of a package work for an app, you
can configure the app to use any of them. What's more, Bnd automatically
determines the semantically compatible range of each package a module
depends on and records the range to the module's manifest.

For help with version range syntax, see the
\href{https://osgi.org/specification/osgi.core/7.0.0/framework.module.html\#i3189032}{OSGi
Specifications}.

A version range for imported packages in an OSGi bundle's
\texttt{bnd.bnd} looks like this:

\begin{verbatim}
Import-Package: com.liferay.docs.test; version="[1.0.0,2.0.0)"
\end{verbatim}

Popular build tools also follow this syntax. In Gradle, a version range
for a dependency looks like this:

\begin{verbatim}
compile group: "com.liferay.portal", name: "com.liferay.portal.test", version: "[1.0.0,2.0.0)"
\end{verbatim}

In Maven, it looks like this:

\begin{verbatim}
<groupId>com.liferay.portal</groupId>
<artifactId>com.liferay.portal.test</artifactId>
<version>[1.0.0,2.0.0)</version>
\end{verbatim}

Specifying the latest release version can also be considered a range of
versions with no upper limit. For example, in Gradle, it's specified as
\texttt{version:\ "latest.release"}. This can be done in Maven 2.x with
the usage of the version marker \texttt{RELEASE}. This is not possible
if you're using Maven 3.x. See \href{https://gradle.org/docs}{Gradle}
and \href{http://maven.apache.org/guides/}{Maven}'s respective docs for
more information.

Tracking a range of versions comes with a price. It's hard to reproduce
old builds when you're debugging an issue. It also comes with the risk
of differing behaviors depending on the version used. Also, relying on
the latest release could break compatibility with your project if a
major change is introduced. You should proceed with caution when
specifying a range of versions and ensure your project is tested on all
included versions.

Tracking a dependency's exact version is much safer, but is less
flexible. This might limit you to a specific version of Liferay DXP. You
would also be locked in to APIs that only exist for that specific
version. This means your module is much easier to test and has less
chance for unexpected failures.

\noindent\hrulefill

\textbf{Note:} When specifying package versions in your \texttt{bnd.bnd}
file, exact versions are typically specified like this:
\texttt{version="1.1.2"}. However, this syntax is technically a range;
it is interpreted as {[}1.1.2, ∞). Therefore, if a higher version of the
package is available, it's used instead of the version you specified.
For these cases, it may be better to specify a version range for
compatible versions that have been tested. If you want to specify a true
exact match, the syntax is like this: \texttt{{[}1.1.2{]}}. See the
\href{https://osgi.org/specification/osgi.core/7.0.0/framework.module.html\#i3189032}{Version
Range} section in the OSGi specifications for more info.

Gradle and Maven use exact versions when only one version is specified.

\noindent\hrulefill

You now know the pros and cons for tracking dependencies as a range and
as an exact match.

\section{Service Trackers}\label{service-trackers-1}

Now that Liferay is promoting more modular plugins deployed into an OSGi
runtime, you have to consider how your own code, living in its own
module, can rely on services in other modules for functionality. You
must account for the possibility of service implementations being
swapped out or removed entirely if your module is to survive and thrive
in an OSGi environment. It's easy for 7.0 developers who need to
\href{/docs/7-0/tutorials/-/knowledge_base/t/finding-and-invoking-liferay-services}{call
services} from their \texttt{@Component} classes. They just use another
\href{https://osgi.org/specification/osgi.cmpn/7.0.0/service.component.html}{Declarative
Services (DS)} annotation, \texttt{@Reference}, to get a service
reference. The component activates when the referenced service is
available.

If you're able to use DS and leverage the \texttt{@Component} and
\texttt{@Reference} annotations, you should. DS handles much of the
complexity of handling service dynamism for you transparently.

If you can't use DS to create a Component, keep reading to learn how to
implement a Service Tracker to look up services in the service registry.

\begin{figure}
\centering
\includegraphics{./images/service-registry.png}
\caption{Service implementations that are registered in the OSGi service
registry can be accessed using Service Trackers.}
\end{figure}

\noindent\hrulefill

\textbf{Note:} When using Service Trackers in your WAR-style project,
you must configure the required \texttt{org.osgi.core} dependency
carefully in your build file (e.g., \texttt{build.gradle},
\texttt{pom.xml}, etc.) to avoid errors. Since it's included in Liferay
DXP by default, it must be configured as \texttt{provided}. See the
\href{/docs/7-0/reference/-/knowledge_base/r/third-party-packages-portal-exports}{Third
Party Packages Portal Exports} tutorial for more information.

\noindent\hrulefill

What scenarios might require using a service tracker? Keep in mind we're
focusing on scenarios where DS \emph{can't} be used. This typically
involves a non-native (to OSGi) Dependency Injection framework.

\begin{itemize}
\tightlist
\item
  Calling OSGi services from a
  \href{/docs/7-0/tutorials/-/knowledge_base/t/spring-mvc}{Spring MVC
  portlet}
\item
  Calling OSGi services from a
  \href{/docs/7-0/tutorials/-/knowledge_base/t/jsf-portlets-with-liferay-faces}{JSF
  portlet}
\item
  Calling OSGi services from a
  \href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-plugins-to-liferay-7}{WAR-packaged
  portlet} that's been upgraded to run on 7.0, but not
  \href{/docs/7-0/tutorials/-/knowledge_base/t/modularizing-an-existing-portlet}{fully
  modularized} and made into an OSGi module
\end{itemize}

\noindent\hrulefill

\textbf{Note:} The static utility classes (e.g.,
\texttt{UserLocalServiceUtil}) that were useful in Liferay Portal 6.2
(and earlier) exist for compatibility but should not be called, if
possible. Static utility classes cannot account for the OSGi runtime's
dynamic environment. Using a static class, for example, you might
attempt calling a service that has stopped or hasn't been deployed or
started--this could cause unrecoverable runtime errors. Service Tracker,
however, helps you make OSGi-friendly service calls.

\noindent\hrulefill

Using a Service Tracker, your non-OSGi application can access any
service registered in the OSGi runtime, including your own
\href{/docs/7-0/tutorials/-/knowledge_base/t/what-is-service-builder}{Service
Builder services} and the services published by Liferay's modules (like
the popular \texttt{UserLocalService}).

\subsection{Implementing a Service
Tracker}\label{implementing-a-service-tracker}

Although you don't have the luxury of using DS to manage your service
dependencies, you can call services from the service registry with a
little bit of code.

To implement a service tracker you can do this:

\begin{verbatim}
import org.osgi.framework.Bundle;
import org.osgi.framework.FrameworkUtil;
import org.osgi.util.tracker.ServiceTracker;

Bundle bundle = FrameworkUtil.getBundle(this.getClass());
BundleContext bundleContext = bundle.getBundleContext();
ServiceTracker<SomeService, SomeService> serviceTracker =
    new ServiceTracker(bundleContext, SomeService.class, null);
serviceTracker.open();
SomeService someService = serviceTracker.waitForService(500);
\end{verbatim}

To simplify your code, you can create a class that extends
\texttt{org.osgi.util.tracker.ServiceTracker}.

\begin{verbatim}
public class SomeServiceTracker
    extends ServiceTracker<SomeService, SomeService> {

    public SomeServiceTracker(Object host) {
        super(
            FrameworkUtil.getBundle(host.getClass()).getBundleContext(),
            SomeService.class, null);
    }
}
\end{verbatim}

From the initialization part of your logic that uses the service, call
your service tracker constructor. The \texttt{Object\ host} parameter is
used to obtain your own bundle context and in order to give accurate
results must be an object from your own bundle.

\begin{verbatim}
ServiceTracker<SomeService, SomeService> someServiceTracker =
    new SomeServiceTracker(this);
\end{verbatim}

Remember to open the service tracker before using it, typically as early
as you can.

\begin{verbatim}
someServiceTracker.open();
\end{verbatim}

The most basic usage of a Service Tracker is to interrogate the
service's state. In your program logic, for example, check whether the
service is \texttt{null} before using it:

\begin{verbatim}
SomeService someService = someServiceTracker.getService();

if (someService == null) {
    _log.warn("The required service 'SomeService' is not available.");
}
else {
    someService.doSomethingCool();
}
\end{verbatim}

Service Trackers have several other utility functions for introspecting
tracked services.

Later when your application is being destroyed or undeployed, close the
service tracker.

\begin{verbatim}
someServiceTracker.close();
\end{verbatim}

\subsection{Implementing a Callback Handler for
Services}\label{implementing-a-callback-handler-for-services}

If there's a strong possibility the service might not be available, or
if you need to track multiple services, the Service Tracker API provides
a callback mechanism which operates on service \emph{events}. To use
this, override \texttt{ServiceTracker}'s \texttt{addingService} and
\texttt{removedService} methods. Their \texttt{ServiceReference}
parameter references an active service object.

Here's an example \texttt{ServiceTracker} implementation from the
\href{https://osgi.org/specification/osgi.core/7.0.0/util.tracker.html\#d0e51991}{OSGi
Alliance's OSGi Core Release 7 specification}:

\begin{verbatim}
new ServiceTracker<HttpService, MyServlet>(context, HttpService.class, null) {

    public MyServlet addingService(ServiceReference<HttpService> reference) {
        HttpService httpService = context.getService(reference);
        MyServlet myServlet = new MyServlet(httpService);
        return myServlet;
    }

    public void removedService(
        ServiceReference<HttpService> reference, MyServlet myServlet) {
        myServlet.close();
        context.ungetService(reference);
    }
}
\end{verbatim}

When the \texttt{HttpService} is added to the OSGi registry, this
\texttt{ServiceTracker} creates a new wrapper class, \texttt{MyServlet},
which uses the newly added service. When the service is removed from the
registry, the \texttt{removedService} method cleans up related
resources.

As an alternative to directly overloading \texttt{ServiceTracker}
methods, create a
\texttt{org.osgi.util.tracker.ServiceTrackerCustomizer}:

\begin{verbatim}
class MyServiceTrackerCustomizer 
    implements ServiceTrackerCustomizer<SomeService, MyWrapper> {
    
    private final BundleContext bundleContext;
    
    MyServiceTrackerCustomizer(BundleContext bundleContext) {
        this.bundleContext = bundleContext;
    }
    
    @Override
    public MyWrapper addedService(
        ServiceReference<SomeService> serviceReference) {
        
        // Determine if the service is one that's interesting to you.
        // The return type of this method is the `tracked` type. Its type 
        // is what is returned from `getService*` methods; useful for wrapping 
        // the service with your own type (e.g., MyWrapper).
        if (isInteresting(serviceReference)) {
            MyWrapper myWrapper = new MyWrapper(
                serviceReference, bundleContext.getService());
            
            // trigger the logic that requires the available service(s)
            triggerServiceAddedLogic(myWrapper);
            
            return myWrapper;
        }
        
        // If the return is null, the tracker is effectively ignoring any further
        // events for the service reference
        return null;
    }

    @Override
    public void modifiedService(
        ServiceReference<SomeService> serviceReference, MyWrapper myWrapper) {
        // handle the modified service
    }

    @Override
    public void removedService(
        ServiceReference<SomeService> serviceReference, MyWrapper myWrapper) {

        // finally, trigger logic when the service is going away
        triggerServiceRemovedLogic(myWrapper);
    }

}
\end{verbatim}

Register the \texttt{ServiceTrackerCustomizer} by passing it as the
\texttt{ServiceTracker} constructor's third parameter.

\begin{verbatim}
ServiceTrackerCustomizer<SomeService, MyWrapper> serviceTrackerCustomizer =
    new MyServiceTrackerCustomizer();

ServiceTracker<SomeService, MyWrapper> serviceTracker = 
    new ServiceTracker<>(
        bundleContext, SomeService.class, serviceTrackerCustomizer);
\end{verbatim}

There's a little boilerplate code you need to produce, but now you can
look up services in the service registry, even if your plugins can't
take advantage of the Declarative Services component model.

\section{Waiting on Lifecycle Events}\label{waiting-on-lifecycle-events}

Liferay registers lifecycle events like portal and database
initialization into the OSGi service registry. Your OSGi Component or
non-component class can listen for these events by way of their service
registrations. The
\href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/module/framework/ModuleServiceLifecycle.html}{\texttt{ModuleServiceLifecycle}
interface} defines these names for the lifecycle event services:

\begin{itemize}
\tightlist
\item
  \href{@platform-ref@/7.0-latest/javadocs/portal-kernel/constant-values.html\#com.liferay.portal.kernel.module.framework.ModuleServiceLifecycle.DATABASE_INITIALIZED}{DATABASE\_INITIALIZED}
\item
  \href{@platform-ref@/7.0-latest/javadocs/portal-kernel/constant-values.html\#com.liferay.portal.kernel.module.framework.ModuleServiceLifecycle.PORTAL_INITIALIZED}{PORTAL\_INITIALIZED}
\item
  \href{@platform-ref@/7.0-latest/javadocs/portal-kernel/constant-values.html\#com.liferay.portal.kernel.module.framework.ModuleServiceLifecycle.SPRING_INITIALIZED}{SPRING\_INITIALIZED}
\end{itemize}

Here you'll learn how to wait on lifecycle event services to act on them
from within a component or non-component class.

\subsection{Taking action from a
component}\label{taking-action-from-a-component}

\href{https://osgi.org/specification/osgi.cmpn/7.0.0/service.component.html}{Declarative
Services (DS)} facilitates waiting for OSGi services and acting on them
once they're available.

Here's a component whose \texttt{doSomething} method is invoked once the
\texttt{ModuleServiceLifecycle.PORTAL\_INITIALIZED} lifecycle event
service and other services are available.

\begin{verbatim}
@Component
public class MyXyz implements XyzApi {

    // Plain old OSGi service
    @Reference
    private SomeOsgiService _someOsgiService;

    // Service Builder generated service
    @Reference
    private DDMStructureLocalService _ddmStructureLocalService;

    // Liferay lifecycle service
    @Reference(target = ModuleServiceLifecycle.PORTAL_INITIALIZED)
    private ModuleServiceLifecycle _portalInitialized;

    @Activate
    public void doSomething() {
        // `@Activate` method is only executed once all of
        // `_someOsgiService`,
        // `_ddmStructureLocalService` and
        // `_portalInitialized`
        // are set.
    }
}
\end{verbatim}

Here's how to act on services in your component:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  For each lifecycle event service and OSGi service your component uses,
  add a field of that service type and add an \texttt{@Reference}
  annotation to that field. The OSGi framework binds the services to
  your fields. This field, for example, binds to a standard OSGi
  service.

\begin{verbatim}
@Reference
SomeOsgiService _someOsgiService;
\end{verbatim}
\item
  To bind to a particular lifecycle event service, target its name as
  the
  \href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/module/framework/ModuleServiceLifecycle.html}{\texttt{ModuleServiceLifecycle}
  interface} defines. This field, for example, targets database
  initialization.

\begin{verbatim}
@Reference(target = ModuleServiceLifecycle.DATABASE_INITIALIZED)
ModuleServiceLifecycle _dataInitialized;
\end{verbatim}
\item
  Create a method that's triggered on the event(s) and add the
  \texttt{@Activate} annotation to that method. It's invoked when all
  the service objects are bound to the component's fields.
\end{enumerate}

Your component fires (via its \texttt{@Activate} method) after all its
service dependencies resolve. DS components are the easiest way to act
on lifecycle event services.

\subsection{Taking action from a non-component
class}\label{taking-action-from-a-non-component-class}

Classes that aren't DS components can use a
\texttt{org.osgi.util.tracker.ServiceTracker} or
\texttt{org.osgi.util.tracker.ServiceTrackerCustomizer} as a
\href{/docs/7-0/tutorials/-/knowledge_base/t/service-trackers\#implementing-a-callback-handler-for-services}{service
callback handler} for the lifecycle event. If you depend on multiple
services, add logic to your \texttt{ServiceTracker} or
\texttt{ServiceTrackerCustomizer} to coordinate taking action when all
the services are available.

To target a lifecycle event service, create a service tracker that
filters on that service. Use \texttt{org.osgi.framework.FrameworkUtil}
to create an \texttt{org.osgi.framework.Filter} that specifies the
service. Then pass that filter as a parameter to the service tracker
constructor. For example, this service tracker filters on the lifecycle
service \texttt{ModuleServiceLifecycle.PORTAL\_INITIALIZED}.

\begin{verbatim}
import org.osgi.framework.Filter;
import org.osgi.framework.FrameworkUtil;

Filter filter = FrameworkUtil.createFilter(
    String.format(
        "(&(objectClass=%s)%s)",
        ModuleServiceLifecycle.class.getName(),
        ModuleServiceLifecycle.PORTAL_INITIALIZED));

new ServiceTracker<>(bundleContext, filter, null);
\end{verbatim}

Acting on lifecycle event services in this way requires service callback
handling and some boilerplate code. Using DS components is easier and
more elegant, but at least service trackers provide a way to work with
lifecycle events outside of DS components.

\subsection{Related Topics}\label{related-topics-206}

\href{/docs/7-0/tutorials/-/knowledge_base/t/service-trackers}{Service
Trackers}

\chapter{Troubleshooting FAQ}\label{troubleshooting-faq}

When coding on any platform, you can sometimes run into issues that have
no clear resolution. This can be particularly frustrating. If you have
issues building, deploying, or running modules, you want to resolve them
fast. These frequently asked questions and answers help you troubleshoot
problems that arise based on the underlying OSGi platform, and then
correct them.

Here are the troubleshooting sections:

\begin{itemize}
\tightlist
\item
  \hyperref[modules]{Modules}
\item
  \hyperref[services-and-components]{Services and Components}
\end{itemize}

Click a question to view the answer.

\section{Modules}\label{modules-2}

{How can I configure dependencies on Liferay Portal artifacts?~{}}

\begin{verbatim}
<p>See <a href="/docs/7-0/tutorials/-/knowledge_base/t/configuring-dependencies">Configuring Dependencies</a>. </p>
\end{verbatim}

{What are optional package imports and how can I specify them?~{}}

\begin{verbatim}
<p>When developing Liferay Portal modules, you can declare <em>optional</em> package imports. An optional package import is one your module can use if it's available, but can still function without it. <a href="/docs/7-0/tutorials/-/knowledge_base/t/declaring-optional-import-package-requirements">Specifying optional package imports</a> is straightforward. </p>
\end{verbatim}

{How can I connect to a JNDI data source from my module?~{}}

\begin{verbatim}
<p>Connecting to an application server's JNDI data sources from Liferay Portal's OSGi environment is almost the same as connecting to them from the Java EE environment. In an OSGi environment, the only difference is that you must <a href="/docs/7-0/tutorials/-/knowledge_base/t/connecting-to-data-sources-using-jndi">use Liferay Portal's class loader to load the application server's JNDI classes</a>. </p>
\end{verbatim}

{How can I make sure my module works?~{}}

\begin{verbatim}
<p><a href="/docs/7-0/tutorials/-/knowledge_base/t/testing">The Testing tutorials demonstrate several ways to test Liferay Portal modules</a>:</p>
<ul> <li>Unit testing</li> <li>Integration testing</li> <li>Functional testing</li> </ul>
\end{verbatim}

{My module has an unresolved requirement. What can I do?~{}}

\begin{verbatim}
<p>If one of your bundles imports a package that no other bundle in the Liferay OSGi runtime exports, Liferay Portal reports an unresolved requirement:</p>
<pre><code>! could not resolve the bundles: ...
Unresolved requirement: Import-Package: ...
...
Unresolved requirement: Require-Capability ...
</code></pre>
<p>To satisfy the requirement, <a href="/docs/7-0/tutorials/-/knowledge_base/t/resolving-bundle-requirements">find a module that provides the capability, add it to your build file's dependencies, and deploy it</a>. </p>
\end{verbatim}

{An IllegalContextNameException reports that my bundle's context name
does not follow Bundle-SymbolicName syntax. How can I fix the context
name?~{}}

\begin{verbatim}
<p><a href="/docs/7-0/tutorials/-/knowledge_base/t/resolving-bundle-symbolicname-syntax-issues">Adjust the <code>Bundle-SymbolicName</code> to adhere to the syntax</a>. </p>
\end{verbatim}

{Why aren't my module's JavaScript and CSS changes showing?~{}}

\begin{verbatim}
<p><a href="/docs/7-0/tutorials/-/knowledge_base/t/why-arent-my-modules-javascript-and-css-changes-showing">Incorrect component properties or stale browser cache can prevent JavaScript and CSS changes from showing</a>. </p>
\end{verbatim}

{Why aren't my fragment's JSP overrides showing?~{}}

\begin{verbatim}
<p><a href="/docs/7-0/tutorials/-/knowledge_base/t/why-arent-jsp-overrides-i-made-using-fragments-showing">Make sure your <code>Fragment-Host</code>'s bundle version is compatible with the host's bundle version</a>. </p>
\end{verbatim}

{The application server and database started, but Liferay DXP failed to
connect to the database. What happened and how can I fix this?~{}}

\begin{verbatim}
<p>Liferay Portal initialization can fail while attempting to connect to a database server that isn't ready. <a href="/docs/7-0/tutorials/-/knowledge_base/t/portal-failed-to-initialize-because-the-database-wasnt-ready">Configuring Liferay Portal startup to retry JDBC connections</a> facilitates connecting Liferay Portal to databases. </p>
\end{verbatim}

{How can I adjust my module's logging?~{}}

\begin{verbatim}
<p>See <a href="/docs/7-0/tutorials/-/knowledge_base/t/adjusting-module-logging">Adjusting Module Logging</a>. </p>
\end{verbatim}

{How can I implement logging in my module or plugin?~{}}

\begin{verbatim}
<p><a href="/docs/7-0/tutorials/-/knowledge_base/t/implementing-logging">Use Simple Logging Facade for Java (SLF4J) to log messages</a>.</p>
\end{verbatim}

{Why did the entity sort order change when I migrated to a new database
type?~{}}

\begin{verbatim}
<p><a href="/docs/7-0/tutorials/-/knowledge_base/t/sort-order-changed-with-a-different-database">Your new database uses a different default query result order--you should be able to configure a different order</a>.</p>
\end{verbatim}

\section{Services and Components}\label{services-and-components}

{How can I detect unresolved OSGi components?~{}}

\begin{verbatim}
<p>Liferay Portal module components that use Service Builder use Dependency Manager (DM) and most other Liferay Portal module components use Declarative Services (DS). <a href="/docs/7-0/tutorials/-/knowledge_base/t/detecting-unresolved-osgi-components">Gogo shell commands and tools help you find and inspect unsatisfied component references for DM and DS components</a>. </p>
\end{verbatim}

{What is the safest way to call non-OSGi code that uses OSGi
services?~{}}

\begin{verbatim}
<p>See <a href="/docs/7-0/tutorials/-/knowledge_base/t/calling-non-osgi-code-that-uses-osgi-services">Calling Non-OSGi Code that Uses OSGi Services</a>. </p>
\end{verbatim}

{How can I use files to configure components?~{}}

\begin{verbatim}
<p>See <a href="/docs/7-0/tutorials/-/knowledge_base/t/using-files-to-configure-product-modules">Using Files to Configure Module Components</a>. </p>
\end{verbatim}

{How can I use OSGi services from Ext Plugins?~{}}

\begin{verbatim}
<p><a href="/docs/7-0/tutorials/-/knowledge_base/t/using-osgi-services-from-ext-plugins">The registry API lets Ext Plugins use OSGi services </a>. </p>
\end{verbatim}

\section{Resolving Bundle
Requirements}\label{resolving-bundle-requirements}

If one of your bundles imports a package that no other bundle in the
Liferay OSGi runtime exports, you get a bundle exception. Here's an
example exception:

\begin{verbatim}
! could not resolve the bundles: [com.liferay.messaging.client.command-1.0.0.201707261701 org.osgi.framework.BundleException: Could not resolve module: com.liferay.messaging.client.command [1]
Unresolved requirement: Import-Package: com.liferay.messaging.client.api; version="[1.0.0,2.0.0)"
-> Export-Package: com.liferay.messaging.client.api; bundle-symbolic-name="com.liferay.messaging.client.provider"; bundle-version="1.0.0.201707261701"; version="1.0.0"; uses:="org.osgi.framework"
com.liferay.messaging.client.provider [2]
Unresolved requirement: Import-Package: com.liferay.messaging; version="[1.0.0,2.0.0)"
-> Export-Package: com.liferay.messaging; bundle-symbolic-name="com.liferay.messaging.api"; bundle-version="1.0.0"; version="1.0.0"; uses:="com.liferay.petra.concurrent"
com.liferay.messaging.api [12]
Unresolved requirement: Import-Package: com.liferay.petra.io; version="[1.0.0,2.0.0)"
-> Export-Package: com.liferay.petra.io; bundle-symbolic-name="com.liferay.petra.io"; bundle-version="1.0.0"; version="1.0.0"
com.liferay.petra.io [16]
Unresolved requirement: Require-Capability osgi.extender; filter:="(osgi.extender=osgi.serviceloader.processor)"
\end{verbatim}

The first part of the message states \emph{could not resolve the
bundles}. The rest of the message shows a string of unresolved
requirements. Liferay's OSGi Runtime could not resolve one of the
bundle's transitive requirements.

The bundle exception message follows this general pattern:

\begin{itemize}
\tightlist
\item
  Module A has an unresolved requirement (package or capability)
  \texttt{aaa.bbb}.
\item
  Module B provides \texttt{aaa.bbb} but has an unresolved requirement
  \texttt{ccc.ddd}.
\item
  Module C provides \texttt{ccc.ddd} but has an unresolved requirement
  \texttt{eee.fff}.
\item
  etc.
\item
  Module Z provides \texttt{www.xxx} but has an unresolved requirement
  \texttt{yyy.zzz}.
\end{itemize}

The pattern stops at the final requirement no module provides. The last
module's dependencies are key to resolving the bundle exception. There
are two possible causes:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  A dependency that satisfies the final requirement might be missing
  from the build file.
\item
  A dependency that satisfies the final requirement might not be
  deployed.
\end{enumerate}

Both cases require deploying a bundle that provides the missing
requirement.

The example bundle exception concludes that module
\texttt{com.liferay.petra.io} requires capability
\texttt{osgi.extender;\ filter:="(osgi.extender=osgi.serviceloader.processor)"}.
To resolve the requirement, make sure all of
\texttt{com.liferay.petra.io}'s dependencies are deployed.

First, note the module's dependencies. Here is the \texttt{dependencies}
section of the \texttt{com.liferay.petra.io} module's
\texttt{build.gradle} file.

\begin{verbatim}
dependencies {
    provided group: "com.liferay", name: "com.liferay.petra.concurrent", version: "1.0.0"
    provided group: "com.liferay", name: "com.liferay.petra.memory", version: "1.0.0"
    provided group: "org.apache.aries.spifly", name: "org.apache.aries.spifly.dynamic.bundle", version: "1.0.8"
    provided group: "org.slf4j", name: "slf4j-api", version: "1.7.2"
    testCompile group: "com.liferay.portal", name: "com.liferay.portal.kernel", version: "default"
}
\end{verbatim}

Then use
\href{/docs/7-0/reference/-/knowledge_base/r/using-the-felix-gogo-shell}{Felix
Gogo Shell's \texttt{lb\ command}} to verify the dependencies in
Liferay's OSGi Runtime:

\begin{verbatim}
lb
START LEVEL 1
   ID|State      |Level|Name
    0|Active     |    0|OSGi System Bundle (3.10.100.v20150529-1857)|3.10.100.v20150529-1857
    1|Active     |    1|com.liferay.messaging.client.command (1.0.0.201707261923)|1.0.0.201707261923
    2|Active     |    1|com.liferay.messaging.client.provider (1.0.0.201707261927)|1.0.0.201707261927
    3|Active     |    1|Apache Felix Configuration Admin Service (1.8.8)|1.8.8
    4|Active     |    1|Apache Felix Log Service (1.0.1)|1.0.1
    5|Active     |    1|Apache Felix Declarative Services (2.0.2)|2.0.2
    6|Active     |    1|Meta Type (1.4.100.v20150408-1437)|1.4.100.v20150408-1437
    7|Active     |    1|org.osgi:org.osgi.service.metatype (1.3.0.201505202024)|1.3.0.201505202024
    8|Active     |    1|Apache Felix Gogo Command (0.16.0)|0.16.0
    9|Active     |    1|Apache Felix Gogo Runtime (0.16.2)|0.16.2
   10|Active     |    1|Apache Felix Gogo Runtime (1.0.0)|1.0.0
...
\end{verbatim}

Notice the dependency module
\texttt{org.apache.aries.spifly.dynamic.bundle} is missing from the
runtime bundle list. Examining the module's \texttt{MANIFEST.MF} file
shows it provides the requirement capability
\texttt{osgi.extender;\ filter:="(osgi.extender=osgi.serviceloader.processor)"}.

\begin{verbatim}
Provide-Capability: osgi.extender;osgi.extender="osgi.serviceloader.regi
 strar";version:Version="1.0",osgi.extender;osgi.extender="osgi.servicel
 oader.processor";version:Version="1.0"
\end{verbatim}

Deploying this missing bundle
\texttt{org.apache.aries.spifly.dynamic.bundle} resolves the example's
bundle exception.

You can follow these similar steps to resolve your bundle exceptions.

\noindent\hrulefill

Note: Bndtools's \emph{Resolve} button can resolve bundle dependencies
automatically. You specify the bundles your application requires and
Bndtools adds transitive dependencies from your configured artifact
repository.

\noindent\hrulefill

\subsection{Related Topics}\label{related-topics-207}

\href{/docs/7-0/tutorials/-/knowledge_base/t/configuring-dependencies}{Configuring
Dependencies}

\href{/docs/7-0/tutorials/-/knowledge_base/t/adding-third-party-libraries-to-a-module}{Adding
Third Party Libraries to a Module}

\href{/docs/7-0/reference/-/knowledge_base/r/using-the-felix-gogo-shell}{Felix
Gogo Shell}

\href{/docs/7-0/tutorials/-/knowledge_base/t/resolving-a-plugins-dependencies}{Resolving
a Plugins's Dependencies}

\section{Resolving Bundle-SymbolicName Syntax
Issues}\label{resolving-bundle-symbolicname-syntax-issues}

An OSGi bundle's \texttt{Bundle-SymbolicName} and
\texttt{Bundle-Version} manifest headers uniquely identify it. You can
specify a bundle's \texttt{Bundle-SymbolicName} in these ways:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \texttt{Bundle-SymbolicName} header in a bundle's (module's)
  \texttt{bnd.bnd} file.
\item
  \texttt{Bundle-SymbolicName} header in a plugin WAR's
  \texttt{liferay-plugin-package.properties} file.
\item
  Plugin WAR file name, if the WAR's
  \texttt{liferay-plugin-package.properties} has no
  \texttt{Bundle-SymbolicName} header.
\end{enumerate}

For plugin WARs, specifying the \texttt{Bundle-SymbolicName} in the
\texttt{liferay-plugin-package.properties} file is preferred.

\textbf{Important}: \texttt{Bundle-SymbolicName} values must not contain
spaces. On bundle deployment, Liferay's OSGi Runtime framework throws an
\texttt{IllegalContextNameException} if its \texttt{Bundle-SymbolicName}
has a space.

For example, if you deploy a plugin WAR that has no
\texttt{Bundle-SymbolicName} header in its
\texttt{liferay-plugin-package.properties}, the
\href{/docs/7-0/tutorials/-/knowledge_base/t/using-the-wab-generator}{WAB
Generator} uses the WAR's name as the WAB's
\texttt{Bundle-SymbolicName}. If the WAR's name has a space in it (e.g.,
\texttt{space-program-theme\ v1.war}) an
\texttt{IllegalContextNameException} occurs on deployment.

\begin{verbatim}
org.apache.catalina.core.ApplicationContext.log The context name 'space-program-theme v1' does not follow Bundle-SymbolicName syntax.
org.eclipse.equinox.http.servlet.internal.error.IllegalContextNameException: The context name 'space-program-theme v1' does not follow Bundle-SymbolicName syntax.
\end{verbatim}

To avoid using spaces and to follow naming best practices, you can use a
reverse-domain name in your \texttt{Bundle-SymbolicName}.

Here's an example domain name and reverse domain name:

\textbf{Module domain}: \texttt{troubleshooting.liferay.com}

\textbf{Module reverse-domain}: \texttt{com.liferay.troubleshooting}

However you set your a \texttt{Bundle-SymbolicName}, refrain from using
spaces.

\subsection{Related Topics}\label{related-topics-208}

\href{/docs/7-0/tutorials/-/knowledge_base/t/using-the-wab-generator}{Using
the WAB Generator}

\section{Resolving ClassNotFoundException and NoClassDefFoundError in
OSGi
Bundles}\label{resolving-classnotfoundexception-and-noclassdeffounderror-in-osgi-bundles}

Understanding a \texttt{ClassNotFoundException} or
\texttt{NoClassDefFoundError} in non-OSGi environments is
straightforward.

\begin{itemize}
\tightlist
\item
  \texttt{ClassNotFoundException}: thrown when looking up a class that
  isn't on the classpath or using an invalid name to look up a class
  that isn't on the runtime classpath.
\item
  \texttt{NoClassDefFoundError}: occurs when a compiled class references
  another class that isn't on the runtime classpath.
\end{itemize}

In OSGi environments, however, there are additional cases where a
\texttt{ClassNotFoundException} or \texttt{NoClassDefFoundError} can
occur. Here are four:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  The missing class belongs to a module dependency that's an OSGi
  module.
\item
  The missing class belongs to a module dependency that's \emph{not} an
  OSGi module.
\item
  The missing class belongs to a global library, either at the Liferay
  DXP webapp scope or the application server scope.
\item
  The missing class belongs to a Java runtime package.
\end{enumerate}

This tutorial explains how to handle each case.

\subsection{Case 1: The Missing Class Belongs to an OSGi
Module}\label{case-1-the-missing-class-belongs-to-an-osgi-module}

In this case, there are two possible causes:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{The module doesn't import the class's package:} For a module
  (or WAB) to consume another module's exported class, the consuming
  module must import the exported package that contains the class. To do
  this, you add an \texttt{Import-Package} header in the consuming
  module's \texttt{bnd.bnd} file. If the consuming module tries to
  access the class without importing it, a
  \texttt{ClassNotFoundException} or \texttt{NoClassDefFoundError}
  occurs.

  In the consuming module, make sure you import the correct package.
  First check the package name. If the package import is correct but you
  still get the exception or error, the class might no longer exist in
  the package.
\item
  \textbf{The class no longer exists in the imported package:} In OSGi
  runtime environments, modules can change and come and go. If you
  reference another module's class that its developer removed, a
  \texttt{NoClassDefFoundError} or \texttt{ClassNotFoundException}
  occurs. \href{http://semver.org}{Semantic Versioning} guards against
  this scenario: removing a class from an exported package constitutes a
  new major version for that package. Neglecting to increment the
  package's major version breaks dependent modules.

  For example, say a module that consumes the class \texttt{com.foo.Bar}
  specifies the package import
  \texttt{com.foo;version={[}1.0.0,\ 2.0.0)}. The module uses
  \texttt{com.foo} versions from \texttt{1.0.0} up to (but not
  including) \texttt{2.0.0}. The first part of the version number (the
  \texttt{1} in \texttt{1.0.0}) represents the \emph{major} version. The
  consuming module doesn't expect any \emph{major} breaking changes,
  like a class removal. Removing \texttt{com.foo.Bar} from
  \texttt{com.foo} without incrementing the package to a new major
  version (e.g., \texttt{2.0.0}) causes a
  \texttt{ClassNotFoundException} or \texttt{NoClassDefFoundError} when
  other modules look up or reference that class.

  You have these options since the class no longer exists in the
  package:

  \begin{itemize}
  \item
    Adapt to the new API. To learn how to do this, read the
    package's/module's Javadoc, release notes, and or formal
    documentation. You can also ask the author, or search forums.
  \item
    Revert to the module version you used previously. Deployed module
    versions reside in \texttt{{[}Liferay\_Home{]}/osgi/}. For details,
    see
    \href{/docs/7-0/deploy/-/knowledge_base/d/backing-up-a-liferay-installation\#backing-up-liferays-file-system}{Backing
    up Liferay Installations}.
  \end{itemize}

  Do what you think is best to get your module working properly.
\end{enumerate}

Now you know how to resolve common situations involving
\texttt{ClassNotFoundException} or \texttt{NoClassDefFoundError}. For
additional information on \texttt{NoClassDefFoundError}, see OSGi
Enroute's article
\href{http://enroute.osgi.org/faq/class-not-found-exception.html}{What
is NoClassDefFoundError?}.

\subsection{Case 2: The Missing Class Doesn't Belong to an OSGi
Module}\label{case-2-the-missing-class-doesnt-belong-to-an-osgi-module}

In this case, you have two options:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Convert the dependency into an OSGi module so it can export the
  missing class. Converting a non-OSGi \texttt{JAR} file dependency into
  an OSGi module that you can deploy alongside your application is the
  ideal solution, so it should be your first choice.
\item
  Embed the dependency in your module by embedding the dependency
  \texttt{JAR} file's packages as private packages in your module. If
  you want to embed a non-OSGi \texttt{JAR} file in your application,
  see the tutorial
  \href{/docs/7-0/tutorials/-/knowledge_base/t/adding-third-party-libraries-to-a-module}{Adding
  Third Party Libraries to a Module}.
\end{enumerate}

\subsection{Case 3: The Missing Class Belongs to a Global
Library}\label{case-3-the-missing-class-belongs-to-a-global-library}

In this case, you can configure Liferay DXP so the OSGi system module
exports the missing class's package. Then your module can import it. You
should \textbf{NOT}, however, undertake this lightly. If Liferay
intended to make a global library available for use by developers, the
system module would already export this library! Still, if you must
access a global library that's not currently exported and can't think of
\textbf{any} other solution, you can consider adding the required
package for export by the system module. There are two ways to do this:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In your \texttt{portal-ext.properties} file, use the property
  \texttt{module.framework.system.packages.extra} to specify the
  packages to export.
\item
  If the package you need is from a Liferay DXP JAR, you might be able
  to add the module to the list of exported packages in
  \texttt{{[}LIFERAY\_HOME{]}/osgi/core/com.liferay.portal.bootstrap.jar}'s
  \texttt{META-INF/system.packages.extra.bnd} file. Try this option only
  if the first option doesn't work.
\end{enumerate}

If the package you need is from a Liferay DXP module, (i.e., it's
\textbf{NOT} from a global library), you can add the package to that
module's \texttt{bnd.bnd} exports. You should \textbf{NOT}, however,
undertake this lightly. The package would already be be exported if
Liferay intended for it to be available.

\subsection{Case 4: The Missing Class Belongs to a Java Runtime
Package}\label{case-4-the-missing-class-belongs-to-a-java-runtime-package}

\texttt{rt.jar} (the JRE library) has non-public packages. If your
module imports one of them, configure Liferay DXP's system bundle to
export the package to the module framework.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add the current
  \href{@platform-ref@/7.0-latest/propertiesdoc/portal.properties.html\#Module\%20Framework}{\texttt{module.framework.system.packages.extra}
  property setting} to a
  \texttt{{[}LIFERAY\_HOME{]}/portal-ext.properties} file. Your server's
  current setting is in the Liferay DXP web application's
  \texttt{/WEB-INF/lib/portal-impl.jar/portal.properties} file.
\item
  In your \texttt{portal-ext.properties} file, append the required Java
  runtime package to the end of the
  \texttt{module.framework.system.packages.extra} property's package
  list.
\item
  Restart your server.
\end{enumerate}

The package requirement resolves.

\subsection{Related Topics}\label{related-topics-209}

\href{/docs/7-0/deploy/-/knowledge_base/d/backing-up-a-liferay-installation}{Backing
up Liferay Installations}

\href{/docs/7-0/tutorials/-/knowledge_base/t/adding-third-party-libraries-to-a-module}{Adding
Third Party Libraries to a Module}

\href{/docs/7-0/tutorials/-/knowledge_base/t/bundle-classloading-flow}{Bundle
Classloading Flow}

\section{Identifying Liferay Artifact Versions for
Dependencies}\label{identifying-liferay-artifact-versions-for-dependencies}

When you're developing a Liferay DXP application, it's often necessary
to use various Liferay DXP APIs or tools. For example, you might want to
create a Service Builder application or use Liferay DXP's message bus or
asset framework. How can you determine which versions of Liferay DXP
artifacts (modules, apps, etc.) your application's modules need to
specify as dependencies? To learn how to find and configure Liferay DXP
dependencies, please refer to the following tutorial:

\begin{itemize}
\tightlist
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/configuring-dependencies}{Configuring
  Dependencies}
\end{itemize}

\subsection{Related Topics}\label{related-topics-210}

\href{/docs/7-0/tutorials/-/knowledge_base/t/finding-extension-points}{Finding
Extension Points}

\section{Connecting to JNDI Data
Sources}\label{connecting-to-jndi-data-sources}

Connecting to an application server's JNDI data sources from Liferay
DXP's OSGi environment is almost the same as connecting to them from the
Java EE environment. In an OSGi environment, the only difference is that
you must use Liferay DXP's class loader to load the application server's
JNDI classes. The following code demonstrates this.

\begin{verbatim}
Thread thread = Thread.currentThread();

// Get the thread's class loader. You'll reinstate it after using
// the data source you look up using JNDI

ClassLoader origLoader = thread.getContextClassLoader();

// Set Liferay's class loader on the thread

thread.setContextClassLoader(PortalClassLoaderUtil.getClassLoader());

try {

        // Look up the data source and connect to it

        InitialContext ctx = new InitialContext();
        DataSource datasource = (DataSource)
            ctx.lookup("java:comp/env/jdbc/TestDB");

        Connection connection = datasource.getConnection();
        Statement statement = connection.createStatement();

        // Execute SQL statements here ...

        connection.close();
}
catch (NamingException ne) {

    ne.printStackTrace();
}
catch (SQLException sqle) {

    sqle.printStackTrace();
}
finally {
       // Switch back to the original context class loader

       thread.setContextClassLoader(origLoader);
}
\end{verbatim}

The example code sets Liferay DXP's classloader on the thread to access
the JNDI API. After working with the data source, the code reinstates
the thread's original classloader.

Here are the class imports for the code above:

\begin{verbatim}
import java.sql.Connection;
import java.sql.SQLException;
import java.sql.Statement;
import javax.naming.InitialContext;
import javax.naming.NamingException;
import javax.sql.DataSource;
import com.liferay.portal.kernel.util.PortalClassLoaderUtil;
\end{verbatim}

Your applications can use similar code to access a data source. Make
sure to substitute \texttt{jdbc/TestDB} with your data source name.

\noindent\hrulefill

\textbf{Note}: An OSGi bundle's attempt to connect to a JNDI data source
without using Liferay DXP's classloader results in a
\texttt{java.lang.ClassNotFoundException}. For example, here's an
exception from attempting to use Apache Tomcat's JNDI API without using
Liferay DXP's classloader:

\begin{verbatim}
 javax.naming.NoInitialContextException: Cannot instantiate class:
 org.apache.naming.java.javaURLContextFactory [Root exception is
 java.lang.ClassNotFoundException:
 org.apache.naming.java.javaURLContextFactory]
\end{verbatim}

\noindent\hrulefill

An easier way to work with databases is to
\href{/docs/7-0/tutorials/-/knowledge_base/t/connecting-service-builder-to-external-data-sources}{connect
to them using Service Builder}.

\subsection{Related Topics}\label{related-topics-211}

\href{/docs/7-0/tutorials/-/knowledge_base/t/connecting-service-builder-to-external-data-sources}{Connecting
Service Builder to External Data Sources}

\section{Adjusting Module Logging}\label{adjusting-module-logging}

Liferay DXP uses \href{http://logging.apache.org/log4j/1.2/}{Log4j}
logging services. Here are the ways to configure logging for module
classes and class hierarchies.

\begin{itemize}
\tightlist
\item
  \href{/docs/7-0/user/-/knowledge_base/u/server-administration\#log-levels}{Liferay
  DXP's UI}
\item
  Configure Log4j for multiple modules in a
  \texttt{{[}anyModule{]}/src/main/resources/META-INF/module-log4j.xml}
  file.
\item
  Configure Log4j for a specific module in a
  \texttt{{[}Liferay\ Home{]}/osgi/log4j/{[}symbolicNameOfBundle{]}-log4j-ext.xml}
  file.
\item
  Configure Log4j for an OSGi fragment host module in a
  \texttt{/META-INF/module-log4j-ext.xml} file
\end{itemize}

Here's an example Log4j XML configuration:

\begin{verbatim}
<?xml version="1.0"?>
<!DOCTYPE log4j:configuration SYSTEM "log4j.dtd">
<log4j:configuration xmlns:log4j="http://jakarta.apache.org/log4j/">
    <category name="org.foo">
        <priority value="DEBUG" />
    </category>
</log4j:configuration>
\end{verbatim}

Use \texttt{category} elements to specify each class or class hierarchy
to log messages for. Set the \texttt{name} attribute to that class name
or root package. The example category sets logging for the class
hierarchy starting at package \texttt{org.foo}. Log messages at or above
the \texttt{DEBUG} log level are printed for classes in \texttt{org.foo}
and classes in packages starting with \texttt{org.foo}.

Set each category's \texttt{priority} element to the log
\href{http://logging.apache.org/log4j/1.2/apidocs/org/apache/log4j/Level.html}{level}
(priority) you want.

\begin{itemize}
\tightlist
\item
  ALL
\item
  DEBUG
\item
  ERROR
\item
  FATAL
\item
  INFO
\item
  OFF
\item
  TRACE
\item
  WARN
\end{itemize}

The log messages are printed to Liferay log files in
\texttt{{[}Liferay\_Home{]}/logs}.

You can see examples of module logging in several
\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-sample-modules}{Liferay
sample projects}. For example, the
\href{https://github.com/liferay/liferay-blade-samples/tree/7.0/gradle/apps/action-command-portlet}{action-command-portlet},
\href{/docs/7-0/reference/-/knowledge_base/r/document-action}{document-action},
and
\href{/docs/7-0/reference/-/knowledge_base/r/service-builder-application-using-external-database-via-jdbc}{service-builder/jdbc}
samples (among others) leverage module logging.

\noindent\hrulefill

Note: If the log level configuration isn't appearing (e.g., you set the
log level to \texttt{ERROR} but you're still getting \texttt{WARN}
messages), make sure the log configuration file name prefix matches the
module's symbolic name. If you have Bnd installed, output from command
\texttt{bnd\ print\ {[}path-to-bundle{]}} includes the module's symbolic
name
(\href{https://github.com/bndtools/bnd/wiki/Install-bnd-on-the-command-line}{Here}
are instructions for installing Bnd for the command line).

\noindent\hrulefill

\noindent\hrulefill

Note: A Log4j configuration's appenders control log file location,
naming, and rotation.
\href{/docs/7-0/tutorials/-/knowledge_base/t/advanced-customization-with-ext-plugins\#using-advanced-configuration-files}{To
override advanced Log4j options such as Liferay DXP's log appenders, use
an Ext plugin}.

\noindent\hrulefill

That's it for module log configuration. You're all set to print the
information you want.

\section{Implementing Logging}\label{implementing-logging}

7.0 uses the Log4j logging framework, but a different one may eventually
replace it. It's a best practice to use
\href{https://www.slf4j.org/}{Simple Logging Facade for Java (SLF4J)} to
log messages in your modules and traditional plugins. SLF4J is already
integrated into Liferay DXP, so you can focus on logging messages.

Here's how to use SLF4J to log messages in a class:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add a private static SLF4J
  \href{https://www.slf4j.org/apidocs/org/slf4j/Logger.html}{\texttt{Logger}
  field}.

\begin{verbatim}
private static Logger _logger;
\end{verbatim}
\item
  Instantiate the logger.

\begin{verbatim}
_logger = LoggerFactory.getLogger(this.getClass().getName());
\end{verbatim}
\item
  Throughout your class, log messages where noteworthy things happen.

  For example,

\begin{verbatim}
_logger.debug("...");
_logger.warn("...");
_logger.error("...");
...
\end{verbatim}

  Use \texttt{Logger} methods appropriate for each message:

  \begin{itemize}
  \tightlist
  \item
    \texttt{debug}: Event and application information helpful for
    debugging.
  \item
    \texttt{error}: Normal errors. This is the least verbose message
    level.
  \item
    \texttt{info}: High level events.
  \item
    \texttt{trace}: Provides more information than debug. This is the
    most verbose message level.
  \item
    \texttt{warn}: Information that might, but does not necessarily,
    indicate a problem.
  \end{itemize}
\end{enumerate}

Log verbosity should correlate with the log level set for the class or
package. Make sure you provide additional information at log levels
expected to be more verbose, such as \texttt{info} and \texttt{debug}.

You're all set to add logging to your modules and traditional plugins.

\section{Declaring Optional Import Package
Requirements}\label{declaring-optional-import-package-requirements}

When developing Liferay DXP modules, you can declare \emph{optional}
dependencies. An optional dependency is one your module can use if it's
available, but can still function without it.

\noindent\hrulefill

\textbf{Important:} Try to avoid optional dependencies. The best module
designs rely on normal dependencies. If an optional dependency seems
desirable, your module may be trying to provide distinct types of
functionality. In such a situation, it's best to split it into multiple
modules that provide smaller, more focused functionality.

\noindent\hrulefill

If you decide that your module requires an optional dependency, follow
these steps to add it:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Declare the package that your module optionally requires as an
  optional dependency in your module's \texttt{bnd.bnd} file:

\begin{verbatim}
Import-Package: com.liferay.demo.foo;resolution:="optional"
\end{verbatim}

  Note that you can use either an optional or dynamic import. The
  differences are explained
  \href{http://web.ist.utl.pt/ist162500/?p=65}{in this blog post}.
\item
  Create a component to use the optional package:

\begin{verbatim}
import com.liferay.demo.foo.Foo; // A class from the optional package

@Component(
    enabled = false // instruct declarative services to ignore this component by default
)
public class OptionalPackageConsumer implements Foo {...}
\end{verbatim}
\item
  Create a second component to act as a controller of the first
  component. The second component checks the classloader for the
  optional class on the classpath. It handles both cases appropriately.
  If it's not there, this means you must catch any
  \texttt{ClassNotFoundException}. For example:

\begin{verbatim}
@Component
public class OptionalPackageConsumerStarter {
    @Activate
    void activate(ComponentContext componentContext) {
        try {
            Class.forName(com.liferay.demo.foo.Foo.class.getName());

            componentContext.enableComponent(OptionalPackageConsumer.class.getName());
        }
        catch (Throwable t) {
            _log.warn("Could not find {}", t.getMessage()); // Could use _log.info instead
        }
    }
}
\end{verbatim}
\end{enumerate}

If the classloader check in the controller component is successful, the
client component is enabled. This check is automatically performed
whenever there are any wiring changes to the module containing these
components (Declarative Services components are always restarted when
there are wiring changes).

As above, if you install the module when the optional dependency is
missing from Liferay DXP's OSGi runtime, your controller component
catches a \texttt{ClassNotFoundException} and logs a warning or info
message (or takes whatever other action you implement to handle this
case). If you install the optional dependency, refreshing your module
triggers the OSGi bundle lifecycle events that trigger your controller's
\texttt{activate} method and the check for the optional dependency.
Since the dependency exists, your client component uses it.

Note that you can refresh a bundle from Liferay DXP's Gogo shell with
this command:

\begin{verbatim}
equinox:refresh [bundle ID]
\end{verbatim}

For more information about optional dependencies, see
\href{http://enroute.osgi.org/tutorial_wrap/220-optional-dependencies}{OSGi
Enroute's documentation}.

\subsection{Related Topics}\label{related-topics-212}

\href{/docs/7-0/tutorials/-/knowledge_base/t/configuring-dependencies}{Configuring
Dependencies}

\section{Why Aren't my Module's JavaScript and CSS Changes
Showing?}\label{why-arent-my-modules-javascript-and-css-changes-showing}

To determine why JavaScript and CSS updates to your module aren't having
an effect in your browser, perform these checks:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  If you're developing a portlet module, check that your portlet class
  has the correct properties specified in its \texttt{@Component}
  annotation:

  \begin{itemize}
  \tightlist
  \item
    Make sure the resources referred to by the properties of your
    portlet class's \texttt{@Component} annotation exist in the correct
    location in your module project.
  \item
    Make sure that you're using a portlet CSS wrapper class to prevent
    potential CSS ID and class name conflicts with other applications on
    the page.
  \end{itemize}

  For example, consider this sample portlet class:

\begin{verbatim}
@Component(
    immediate = true,
    property = {
        "com.liferay.portlet.css-class-wrapper=example-portlet",
        "com.liferay.portlet.display-category=category.sample",
        "com.liferay.portlet.instanceable=true",
        "com.liferay.portlet.header-portlet-css=/css/main.css",
        "com.liferay.portlet.header-portlet-javascript=/css/main.js",
        "javax.portlet.display-name=Example Portlet",
        "javax.portlet.init-param.template-path=/",
        "javax.portlet.init-param.view-template=/view.jsp",
        "javax.portlet.name=" + ExamplePortletKeys.TicTacToe,
        "javax.portlet.resource-bundle=content.Language",
        "javax.portlet.security-role-ref=power-user,user"
    },
    service = Portlet.class
)
public class ExamplePortlet extends MVCPortlet {

}
\end{verbatim}

  As described in the first item above, the portlet's CSS file is
  specified by the property
  \texttt{com.liferay.portlet.header-portlet-css}. Paths specified as
  values of this property are relative to the module's
  \texttt{src/main/resources/META-INF/resources} folder. So if you
  specify a value of \texttt{css/main.css}, the actual path to the CSS
  file in the module is
  \texttt{src/main/resources/META-INF/resources/css/main.css}. The path
  to your portlet's JavaScript file is specified by the property
  \texttt{com.liferay.portlet.header-portlet-javascript}. Values for
  this property work the same as the values for the CSS property.

  Also note that the property
  \texttt{com.liferay.portlet.css-class-wrapper} specifies the CSS class
  wrapper \texttt{example-portlet}. Thus, you should use subclasses of
  \texttt{example-portlet} in your portlet's actual CSS file. For
  example, in \texttt{main.css} you'd do this to change the background
  to green:

\begin{verbatim}
.example-portlet {
    .greenBackground {
        background-color: green;
    }

    ... (further properties)

}
\end{verbatim}

  In other words, to avoid CSS class and ID name conflicts, all the CSS
  properties you specify must be subclasses of the class specified via
  the \texttt{com.liferay.portlet.css-class-wrapper} property. Liferay
  DXP wraps your portlet's HTML content with a
  \texttt{\textless{}div\textgreater{}}. The class specified by
  \texttt{com.liferay.portlet.css-class-wrapper}
  (\texttt{example-portlet}, in this example) has been applied to this
  \texttt{\textless{}div\textgreater{}}.
\item
  Check that caching isn't preventing JS and CSS updates to your module
  from appearing in your browser:

  \begin{itemize}
  \tightlist
  \item
    Clear your browser's cache.
  \item
    During development, enable developer mode to turn off Liferay DXP's
    resource caching.
    \href{/docs/7-0/tutorials/-/knowledge_base/t/using-developer-mode-with-themes}{Click
    here} to learn how to enable Liferay DXP's developer mode.
  \end{itemize}
\end{enumerate}

\subsection{Related Topics}\label{related-topics-213}

\href{/docs/7-0/tutorials/-/knowledge_base/t/using-developer-mode-with-themes}{Using
Developer Mode with Themes}

\section{Why Aren't JSP overrides I Made Using Fragments
Showing?}\label{why-arent-jsp-overrides-i-made-using-fragments-showing}

The fragment module must specify the exact version of the host module. A
Liferay DXP upgrade might have changed some JSPs in the host module,
prompting a version update. If this occurs, check that your JSP
customizations are compatible with the updated host JSPs and then update
your fragment module's targeted version to match the host module.

For example, this \texttt{bnd.bnd} file from a fragment module uses
\texttt{Fragment-Host} to specify the host module and host module
version:

\begin{verbatim}
Bundle-Name: custom-login-jsp
Bundle-SymbolicName: custom.login.jsp
Bundle-Version: 1.0.0
Fragment-Host: com.liferay.login.web;bundle-version="1.1.18"
\end{verbatim}

For information on finding the versions of your deployed modules,
\href{/docs/7-0/tutorials/-/knowledge_base/t/configuring-dependencies\#finding-liferay-app-and-independent-artifacts}{click
here}.

For more information on overriding JSPs,
\href{/docs/7-0/tutorials/-/knowledge_base/t/overriding-jsps}{click
here}.

\subsection{Related Topics}\label{related-topics-214}

\href{/docs/7-0/tutorials/-/knowledge_base/t/overriding-jsps}{Overriding
JSPs}

\href{/docs/7-0/tutorials/-/knowledge_base/t/configuring-dependencies}{Configuring
Dependencies}

\section{Detecting Unresolved OSGi
Components}\label{detecting-unresolved-osgi-components}

Liferay DXP includes
\href{/docs/7-0/reference/-/knowledge_base/r/using-the-felix-gogo-shell}{Gogo
shell} commands that come in handy when trying to diagnose a problem due
to an unresolved OSGi component. The specific tools to use depend on the
component framework of the unresolved component. Most Liferay DXP
components are developed using Declarative Services (DS), also known as
SCR (Service Component Runtime). An exception to this is Liferay DXP's
Service Builder services, which are provided as Dependency Manager (DM)
components. Both
\href{http://felix.apache.org/documentation/subprojects/apache-felix-service-component-runtime.html}{Declarative
Services} and
\href{http://felix.apache.org/documentation/subprojects/apache-felix-dependency-manager.html}{Dependency
Manager} are Apache Felix projects.

The troubleshooting instructions are divided into these sections:

\begin{itemize}
\tightlist
\item
  \hyperref[declarative-services-components]{Declarative Services
  Components}

  \begin{itemize}
  \tightlist
  \item
    \hyperref[declarative-services-unsatisfied-component-scanner]{Declarative
    Services Unsatisfied Component Scanner}
  \item
    \hyperref[dsunsatisfied-command]{ds:unsatisfied Command}
  \end{itemize}
\item
  \hyperref[service-builder-components]{Service Builder Components}

  \begin{itemize}
  \tightlist
  \item
    \hyperref[unavailable-component-scanner]{Unavailable Component
    Scanner}
  \item
    \hyperref[serviceproxyfactory]{ServiceProxyFactory}
  \end{itemize}
\end{itemize}

\subsection{Declarative Services
Components}\label{declarative-services-components}

Start with DS, since most Liferay DXP components, apart from Service
Builder components, are DS components. Suppose one of your bundle's
components has an unsatisfied service reference. How can you detect
this? Two ways:

\begin{itemize}
\item
  You can enable a
  \hyperref[declarative-services-unsatisfied-component-scanner]{Declarative
  Services Unsatisfied Component Scanner} to report unsatisfied
  references automatically or
\item
  You can use the \hyperref[dsunsatisfied-command]{Gogo shell command
  \texttt{ds:unsatisfied}} to check for them manually.
\end{itemize}

\subsubsection{Declarative Services Unsatisfied Component
Scanner}\label{declarative-services-unsatisfied-component-scanner}

\noindent\hrulefill

\textbf{Note}: The Declarative Services Unsatisfied Component Scanner
appears in DXP Digital Enterprise Fix 7.0 Pack 31 and Liferay CE Portal
7.0 GA5.

\noindent\hrulefill

Here are the steps for enabling the unsatisfied component scanner:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a file
  \texttt{com.liferay.portal.osgi.debug.declarative.service.internal.configuration.UnsatisfiedComponentScannerConfiguration.cfg}.
\item
  Add the following file content:

\begin{verbatim}
unsatisfiedComponentScanningInterval=5
\end{verbatim}
\item
  Copy the file into \texttt{{[}LIFERAY\_HOME{]}/osgi/configs}.
\end{enumerate}

The scanner detects and logs unsatisfied service component references.
The log message includes the class that contains the reference, the
bundle's ID, and the referenced component type.

Here's an example scanner message:

\begin{verbatim}
11:18:28,881 WARN  [Declarative Service Unsatisfied Component Scanner][UnsatisfiedComponentScanner:91]
Bundle {id: 631, name: com.liferay.blogs.web, version: 2.0.0}
    Declarative Service {id: 3333, name: com.liferay.blogs.web.internal.portlet.action.EditEntryMVCRenderCommand, unsatisfied references:
        {name: ItemSelectorHelper, target: null}
    }
\end{verbatim}

The message above warns that service component
\texttt{com.liferay.blogs.web.internal.portlet.action.EditEntryMVCRenderCommand}
has an unsatisfied reference to a component of type
\texttt{ItemSelectorHelper}. The referencing component's ID (SCR ID) is
\texttt{3333} and the component belongs to bundle \texttt{631}.

\subsubsection{ds:unsatisfied Command}\label{dsunsatisfied-command}

Another way to detect unsatisfied component references is to invoke the
Gogo shell command \texttt{ds:unsatisfied}.

\begin{itemize}
\tightlist
\item
  \texttt{ds:unsatisfied} shows all unsatisfied services
\item
  \texttt{ds:unsatisfied\ {[}BUNDLE\_ID{]}} shows the bundle's
  unsatisfied services
\end{itemize}

\noindent\hrulefill

\textbf{Note}: The Gogo shell command \texttt{ds:unsatisfied} appears in
DXP Digital Enterprise Fix 7.0 Pack 31 and Liferay CE Portal 7.0 GA5.

\noindent\hrulefill

To view more detailed information about the component with the
unsatisfied reference, use the command
\texttt{scr:info\ {[}component\ ID{]}}. For example, the following
command does this for the component ID \texttt{1701}:

\begin{verbatim}
g! scr:info 1701
*** Bundle: org.foo.bar.command (507)
Component Description:
    Name: org.foo.bar.command
    Implementation Class: org.foo.bar.command.FooBarCommand
    Default State: enabled
    Activation: delayed
    Configuration Policy: optional
    Activate Method: activate
    Deactivate Method: deactivate
    Modified Method: -
    Configuration Pid: [org.foo.bar.command]
    Services:
        org.foo.bar.command.DuckQuackCommand
    Service Scope: singleton
    Reference: Duck
        Interface Name: org.foo.bar.api.Foo
        Cardinality: 1..1
        Policy: static
        Policy option: reluctant
        Reference Scope: bundle
    Component Description Properties:
        osgi.command.function = foo
        osgi.command.scope = bar
    Component Configuration:
        ComponentId: 1701
        State: unsatisfied reference
        UnsatisfiedReference: Foo
        Target: null
        (no target services)
        Component Configuration Properties:
        component.id = 1701
        component.name = org.foo.bar.command
        osgi.command.function = foo
        osgi.command.scope = bar
\end{verbatim}

In the \texttt{Component\ Configuration} section,
\texttt{UnsatisfiedReference} lists the unsatisfied reference's type.
This bundle's component isn't working because it's missing a
\texttt{Foo} service. Now you can focus on why \texttt{Foo} is
unavailable. The solution may be as simple as starting or deploying a
bundle that provides the \texttt{Foo} service.

\subsection{Service Builder
Components}\label{service-builder-components}

Liferay DXP's Service Builder modules are implemented using Spring.
Liferay DXP uses
\href{http://felix.apache.org/documentation/subprojects/apache-felix-dependency-manager.html}{the
Apache Felix Dependency Manager} to manage Service Builder modules' OSGi
components via the
\href{https://github.com/liferay/com-liferay-portal/tree/master/portal-spring-extender}{Portal
Spring Extender} module.

When developing a Liferay Service Builder application, you might
encounter a situation where your application has an unresolved
Spring-related OSGi component. This could occur, for example, if you
update your application's database schema but forget to trigger an
upgrade (for information on creating database upgrade processes for your
Liferay DXP applications, see the tutorial
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-an-upgrade-process-for-your-app}{Creating
an Upgrade Process for Your App}).

These features detect unresolved Service Builder related components.

\begin{itemize}
\tightlist
\item
  \hyperref[unavailable-component-scanner]{Unavailable Component
  Scanner}
\item
  \hyperref[serviceproxyfactory]{ServiceProxyFactory}
\end{itemize}

\subsubsection{Unavailable Component
Scanner}\label{unavailable-component-scanner}

The Liferay Foundation application suite's Unavailable Component Scanner
reports missing components in modules that use Service Builder. Here are
the steps for enabling the scanner:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create configuration file
  \texttt{com.liferay.portal.osgi.debug.spring.extender.internal.configuration.UnavailableComponentScannerConfiguration.cfg}.
\item
  In the configuration file, set the time interval (in seconds) between
  scans:

\begin{verbatim}
unavailableComponentScanningInterval=5
\end{verbatim}
\item
  Copy the file into folder \texttt{{[}LIFERAY\_HOME{]}/osgi/configs}.
\end{enumerate}

The scanner reports Spring extender dependency manager component status
on the set interval. If all components are registered, the scanner sends
a confirmation message.

\begin{verbatim}
11:10:53,817 INFO  [Spring Extender Unavailable Component Scanner][UnavailableComponentScanner:166] All Spring extender dependency manager components are registered
\end{verbatim}

If a component is unavailable, it reports an error like this one:

\begin{verbatim}
11:13:08,851 WARN  [Spring Extender Unavailable Component Scanner][UnavailableComponentScanner:173] Found unavailable component in bundle com.liferay.screens.service_1.0.28 [516].
Component ComponentImpl[null com.liferay.portal.spring.extender.internal.context.ModuleApplicationContextRegistrator@1541eee] is unavailable due to missing required dependencies: ServiceDependency[interface com.liferay.blogs.service.BlogsEntryService null].
\end{verbatim}

Component unavailability, such as what's reported above, can occur when
declarative services components and Service Builder components are
published and used in the same module. We recommend you publish DS
components and Service Builder components in separate modules.

\noindent\hrulefill

\textbf{Note}: The Spring Extender Unavailable Component Scanner appears
in DXP Digital Enterprise Fix 7.0 Pack 24 and Liferay CE Portal 7.0 GA5.

\noindent\hrulefill

\subsubsection{ServiceProxyFactory}\label{serviceproxyfactory}

Liferay DXP's logs report unresolved Service Builder components too. For
example, Liferay DXP logs an error when a Service Proxy Factory can't
create a new instance of a Service Builder based entity because a
service is unresolved.

\noindent\hrulefill

\textbf{Note}: The Service Proxy Factory timeout logs appear in DXP
Digital Enterprise Fix 7.0 Pack 32 and Liferay CE Portal 7.0 GA5.

\noindent\hrulefill

The following code demonstrates using a
\href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/util/ServiceProxyFactory.html}{\texttt{ServiceProxyFactory}
class} to create a new entity instance:

\begin{verbatim}
private static volatile MessageBus _messageBus =
    ServiceProxyFactory.newServiceTrackedInstance(
        MessageBus.class, MessageBusUtil.class, "_messageBus", true);
\end{verbatim}

This message alerts you to the unavailable service:

\begin{verbatim}
11:07:35,139 ERROR [localhost-startStop-1][ServiceProxyFactory:265] Service "com.liferay.portal.kernel.messaging.sender.SingleDestinationMessageSenderFactory" is unavailable in 60000 milliseconds while setting field "_singleDestinationMessageSenderFactory" for class "com.liferay.portal.kernel.messaging.sender.SingleDestinationMessageSenderFactoryUtil", will retry...
\end{verbatim}

Based on the message above, there's no bundle providing the service
\texttt{com.liferay.portal.kernel.messaging.sender.SingleDestinationMessageSenderFactory}.

To check your Service Builder modules for unresolved Spring components,
you can use the Dependency Manager's \texttt{dm} Gogo shell command,
which is explained here:

\begin{itemize}
\tightlist
\item
  \href{http://felix.apache.org/documentation/subprojects/apache-felix-dependency-manager/tutorials/leveraging-the-shell.html}{Dependency
  Manager - Leveraging the shell}
\end{itemize}

For example, to get diagnostic information about Service Builder
components, use the \texttt{dependencymanager:dm} command. This command
lists all Service Builder components, their required services, and
whether each required service is available.

\subsection{Related Topics}\label{related-topics-215}

\href{/docs/7-0/tutorials/-/knowledge_base/t/calling-non-osgi-code-that-uses-osgi-services}{Calling
Non-OSGi Code that Uses OSGi Services}

\href{/docs/7-0/reference/-/knowledge_base/r/using-the-felix-gogo-shell}{Felix
Gogo Shell}

\href{/docs/7-0/tutorials/-/knowledge_base/t/osgi-basics-for-liferay-development}{OSGi
Basics For Liferay Development}

\section{Using Files to Configure Module
Components}\label{using-files-to-configure-module-components}

Liferay DXP uses
\href{http://felix.apache.org/documentation/subprojects/apache-felix-file-install.html}{Felix
File Install} to monitor file system folders for new/updated
configuration files, and the \href{http://felix.apache.org/}{Felix OSGi
implementation} of
\href{http://felix.apache.org/documentation/subprojects/apache-felix-config-admin.html}{Configuration
Admin} to let you use files to configure module service components.

To learn how to work with configuration files, first review
\href{/docs/7-0/user/-/knowledge_base/u/understanding-system-configuration-files}{Understanding
System Configuration Files}.

\subsection{Configuration File
Formats}\label{configuration-file-formats}

There are two different configuration file formats:

\begin{itemize}
\tightlist
\item
  \texttt{.cfg}: An older, simple format that only supports string
  values as properties.
\item
  \texttt{.config}: A format that supports strings, type information,
  and other non-string values in its properties.
\end{itemize}

Although Liferay DXP supports both formats, we recommend
\texttt{.config} files for their flexibility. Since \texttt{.cfg} file
lacks type information, if you want to store anything but a String,
you'll need a properties utility class that casts the Strings to their
proper types (and you must carefully document properties that aren't
Strings). Since \texttt{.config} files can include type information,
using them eliminates this need. The articles below provide a detailed
explanation of these file formats, including their syntax:

\begin{itemize}
\tightlist
\item
  \href{/docs/7-0/user/-/knowledge_base/u/understanding-system-configuration-files}{Understanding
  System Configuration Files}
\item
  \href{https://sling.apache.org/documentation/bundles/configuration-installer-factory.html\#configuration-files-config}{Configuration
  file (\texttt{.config}) syntax}
\item
  \href{https://sling.apache.org/documentation/bundles/configuration-installer-factory.html\#property-files-cfg}{Properties
  file(\texttt{.cfg}) syntax}
\end{itemize}

\subsection{Naming Configuration
Files}\label{naming-configuration-files}

Before you
\href{/docs/7-0/user/-/knowledge_base/u/understanding-system-configuration-files\#creating-configuration-files}{create
a configuration file}, you should determine whether multiple instances
of the component can be created, or if the component is intended to be a
singleton. Follow these steps to make that determination:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Deploy the component's module if you haven't done so already.
\item
  In Liferay DXP's UI, go to \emph{Control Panel} → \emph{Configuration}
  → \emph{System Settings}.
\item
  Find the component's settings by searching or browsing for the
  component.
\item
  If the component's settings page has a section called
  \emph{Configuration Entries}, you can create multiple instances of the
  component configured however you like. Otherwise, you should treat the
  component as a singleton.
\end{enumerate}

\begin{figure}
\centering
\includegraphics{./images/system-settings-page-lists-configuration-entries.png}
\caption{You can create multiple instances of components whose System
Settings page has a \emph{Configuration Entries} section.}
\end{figure}

\emph{All} configuration file names must start with the component's PID
(PID stands for \emph{persistent identity}) and end with
\texttt{.config} or \texttt{.cfg}.

For example, this class uses
\href{/docs/7-0/tutorials/-/knowledge_base/t/osgi-and-modularity-for-liferay-6-developers\#osgi-services-and-dependency-injection-with-declarative-services}{Declarative
Services} to define a component:

\begin{verbatim}
package com;
@Component
class Foo {}
\end{verbatim}

The component's PID is \texttt{com.Foo}. All the component's
configuration files must start with the PID \texttt{com.Foo}.

For each non-singleton component instance you want to create or update
with a configuration, you must use a uniquely named configuration file
that starts with the component's PID and ends with \texttt{.config} or
\texttt{.cfg}. Creating configurations for multiple component instances
requires that the configuration files use different \emph{subnames}. A
subname is the part of a configuration file name after the PID and
before the suffix \texttt{.config} or \texttt{.cfg}. Here's the
configuration file name pattern for non-singleton components:

\begin{itemize}
\tightlist
\item
  \texttt{{[}PID{]}-{[}subname1{]}.config}
\item
  \texttt{{[}PID{]}-{[}subname2{]}.config}
\item
  etc.
\end{itemize}

For example, you could configure two different instances of the
component \texttt{com.Foo} by using configuration files with these
names:

\begin{itemize}
\tightlist
\item
  \texttt{com.Foo-one.config}
\item
  \texttt{com.Foo-two.config}
\end{itemize}

Each configuration file creates and/or updates an instance of the
component that matches the PID. The subname is arbitrary--it doesn't
have to match a specific component instance. This means you can use
whatever subname you like. For example, these configuration files are
just as valid as the two above:

\begin{itemize}
\tightlist
\item
  \texttt{com.Foo-puppies.config}
\item
  \texttt{com.Foo-kitties.config}
\end{itemize}

Using the subname \texttt{default}, however, is Liferay DXP's convention
for configuring a component's first instance. The file name pattern is
therefore:

\begin{verbatim}
[PID]-default.config
\end{verbatim}

A singleton component's configuration file must also start with
\texttt{{[}PID{]}} and end with \texttt{.config} or \texttt{.cfg}.
Here's the common pattern used for singleton component configuration
file names:

\begin{verbatim}
[PID].config
\end{verbatim}

When you're done creating a configuration file, you can
\href{/docs/7-0/user/-/knowledge_base/u/understanding-system-configuration-files\#deploying-a-configuration-file}{deploy
it}.

\subsection{Resolving Configuration File Deployment
Failures}\label{resolving-configuration-file-deployment-failures}

The following \texttt{IOException} hints that the configuration file has
a syntax issue:

\begin{verbatim}
Failed to install artifact: [path to .config or .cfg file]
java.io.IOException: Unexpected token 78; expected: 61 (line=0, pos=107)
\end{verbatim}

To resolve this, fix the
\href{/docs/7-0/tutorials/-/knowledge_base/t/using-files-to-configure-product-modules\#configuration-file-formats}{configuration
file's syntax}.

Great! Now you know how to configure module components using
configuration files.

\subsection{Related Articles}\label{related-articles-5}

\href{/docs/7-0/user/-/knowledge_base/u/understanding-system-configuration-files}{Understanding
System Configuration Files}

\section{Calling Non-OSGi Code that Uses OSGi
Services}\label{calling-non-osgi-code-that-uses-osgi-services}

Liferay DXP's static utility functions (e.g., \texttt{UserServiceUtil},
\texttt{CompanyServiceUtil}, \texttt{GroupServiceUtil}, etc.) are
examples of non-OSGi code that use OSGi services.

Note that it's safer to track and use Liferay DXP's OSGi services
directly with Liferay DXP's Registry API than to invoke Liferay DXP's
similar static utility functions. For example, you can't call an OSGi
service unless all its dependencies are satisfied: the container won't
enable the service. If you invoke Liferay DXP's static utility
functions, you might invoke them prematurely (e.g., before OSGi bundle
activation and application startup events). You could work around this
by identifying all of the implied OSGi service dependencies and making
sure they are satisfied before invocation, but then you're not only
duplicating the container's more robust functionality for this, you're
also creating a bigger surface for bugs. Avoid this mess by using
Liferay DXP's Registry API to track the services you want. This way, you
let OSGi make sure a service's dependencies are satisfied before
invoking that service. For example, use Liferay DXP's OSGi service
\texttt{UserService} instead of \texttt{UserServiceUtil}, which in turn
uses the OSGi service \texttt{UserService}.
\href{/docs/7-0/tutorials/-/knowledge_base/t/using-osgi-services-from-ext-plugins}{Click
here} to see an example of this.

Remember that you can check the state of Liferay DXP's services in
\href{/docs/7-0/reference/-/knowledge_base/r/using-the-felix-gogo-shell}{the
Gogo shell}. If you're running Liferay DXP locally, use the command
\texttt{telnet\ localhost\ 11311} to connect to the Gogo shell. Once
connected, the \texttt{scr:list} command shows all Declarative Services
components, including inactive ones from unsatisfied dependencies. To
find unsatisfied dependencies for Service Builder services, use the
Dependency Manager's \texttt{dependencymanager:dm\ wtf} command. Note
that these commands only show components that haven't been activated
because of unsatisfied dependencies--they don't show pure service
trackers that are waiting for a service because of unsatisfied
dependencies.

\subsection{Related Topics}\label{related-topics-216}

\href{/docs/7-0/tutorials/-/knowledge_base/t/using-osgi-services-from-ext-plugins}{Using
OSGi Services from EXT Plugins}

\href{/docs/7-0/tutorials/-/knowledge_base/t/detecting-unresolved-osgi-components}{Detecting
Unresolved OSGi Components}

\href{/docs/7-0/reference/-/knowledge_base/r/using-the-felix-gogo-shell}{Felix
Gogo Shell}

\href{/docs/7-0/tutorials/-/knowledge_base/t/osgi-basics-for-liferay-development}{OSGi
Basics For Liferay Development}

\section{Patching DXP Source Code}\label{patching-dxp-source-code}

Auto mechanics, enthusiasts, and prospective owners ask about cars,
``What's under the hood?'' Here are common reasons for asking that
question:

\begin{itemize}
\tightlist
\item
  Concern about an issue
\item
  Curiosity about the car's capability and inner-workings
\item
  Desire to improve or customize the car
\end{itemize}

You might have similar reasons for asking ``What's under the
\emph{DXP's} hood?'' And since you get access to DXP Digital Enterprise
(DXP)'s source code, you can attach a debugger see it in action! Setting
up the code locally is your ticket to exploring DXP, investigating
issues, and making improvements and customizations.

Here's how:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Download DXP, the DXP source code, and patches
\item
  Prepare DXP
\item
  Patch the DXP source code
\end{enumerate}

\subsection{Step 1: Download DXP, the DXP source code, and
patches}\label{step-1-download-dxp-the-dxp-source-code-and-patches}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Download a DXP bundle (or DXP JARs) and the DXP source code for the
  version you're using from the
  \href{https://web.liferay.com/group/customer/dxp}{customer portal}.
\item
  Download fix packs and their source code from
  \href{https://web.liferay.com/group/customer/dxp/downloads/digital-enterprise/fix-packs}{here}.
  Fix pack ZIP files that end in \texttt{-src.zip} contain a fix pack
  and source code.
\end{enumerate}

Next you'll install and configure DXP. DXP's patching tool lets you
install fix packs and fix pack source code. If you have a patched DXP
installation already and want to use it, skip to the section
\emph{Patching the DXP Source Code}.

\subsection{Step 2: Prepare DXP}\label{step-2-prepare-dxp}

Preparing DXP locally involves installing, configuring, and patching
DXP.

\subsubsection{Install and Configure
DXP}\label{install-and-configure-dxp}

Here's how to install and configure DXP:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \href{/docs/7-0/deploy/-/knowledge_base/d/deploying-product}{Install
  and Deploy DXP} locally.
\item
  Start DXP.
\item
  Configure DXP to use your database.
\item
  Stop DXP.
\end{enumerate}

It's time apply the DXP patches you want.

\subsubsection{Patch DXP}\label{patch-dxp}

Here's how to patch DXP:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Copy all the patch ZIP files you want to
  \texttt{{[}LIFERAY\_HOME{]}/patching-tool/patches}. The
  \texttt{-src.zip} fix pack files are best to use because they contain
  both the fix pack binaries and source code.
\item
  Open a terminal window to \texttt{{[}LIFERAY\_HOME{]}/patching-tool}.
\item
  Run the command \texttt{patching-tool.sh\ auto-discovery} to generate
  the default patching profile called \texttt{default.properties}. Make
  sure the profile's properties refer to your DXP installation. See the
  \href{/docs/7-0/deploy/-/knowledge_base/d/patching-tool}{patching tool
  documentation} for more details.

  Here's an example profile:

\begin{verbatim}
    patching.mode=binary
    war.path=../tomcat-8.0.32/webapps/ROOT/
    global.lib.path=../tomcat-8.0.32/lib/ext/
    liferay.home=../
\end{verbatim}
\item
  To list all the patch files available in
  \texttt{{[}LIFERAY\_HOME{]}/patching-tool/patches}, execute the
  following command:

\begin{verbatim}
patching-tool.sh info
\end{verbatim}
\item
  Execute this command to install the patches:

\begin{verbatim}
patching-tool.sh install
\end{verbatim}

  The \href{/docs/7-0/deploy/-/knowledge_base/d/patching-tool}{patching
  tool documentation} describes additional steps that might apply to
  your situation, such as creating database indexes.
\end{enumerate}

It's time to prepare the DXP source code and patch source code.

\subsection{Step 3: Patch the DXP Source
Code}\label{step-3-patch-the-dxp-source-code}

Unzip the DXP source code to where you want to work with it.

Next you'll create a patching tool profile for your DXP source code.

\subsubsection{Create a Patching Tool Profile for the Source
Code}\label{create-a-patching-tool-profile-for-the-source-code}

Here's how to create a profile that refers to your source code.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Execute the following command to create a profile. Replace
  \texttt{{[}profile{]}} with a name for your profile.

\begin{verbatim}
patching-tool.sh auto-discovery [profile]
\end{verbatim}
\item
  In the profile properties file generated in the previous step, set the
  \texttt{patching.mode} property to \texttt{source} and set the
  \texttt{source.path} property to your source code path:

\begin{verbatim}
    patching.mode=source
    source.path=[DXP source code path]
\end{verbatim}
\end{enumerate}

It's time to apply the DXP patches you downloaded earlier.

\subsection{Patch the Source Code}\label{patch-the-source-code}

DXP's patching tool is safe and easy to use. Beyond installing patches,
it has these functions:

\begin{itemize}
\tightlist
\item
  List a patch's code changes
\item
  List the issues (LPS/LPE tickets) a patch fixes
\item
  Revert a patch
\end{itemize}

See the following patching tool documentation for more details:

\begin{itemize}
\tightlist
\item
  \href{/docs/7-0/deploy/-/knowledge_base/d/patching-tool\#comparing-patch-levels}{Comparing
  Patch Levels}
\item
  \href{/docs/7-0/deploy/-/knowledge_base/d/patching-tool\#removing-or-reverting-patches}{Removing
  or Reverting Patches}
\end{itemize}

\noindent\hrulefill

In addition to using the patching tool to manage DXP source code, you
can optionally manage it in a version control system such as
\href{https://git-scm.com/}{Git}.

Here are commands for setting up the DXP source code in Git:

\begin{verbatim}
 cd [path to source code root folder]
 git init
 git add .
 git commit -a
\end{verbatim}

Here's are the command descriptions:

\begin{itemize}
\tightlist
\item
  \texttt{init} creates a Git repository for the current folder (i.e.,
  the root folder) and all its contents.
\item
  \texttt{add} stages the root folder and its contents.
\item
  \texttt{commit} checks in the staged files.
\end{itemize}

You can commit any code changes (e.g., DXP patches) to your Git
repository.

\noindent\hrulefill

The patching tool installs all patches and patch source code from the
ZIP files it finds in
\texttt{{[}LIFERAY\_HOME{]}/patching-tool/patches}. All your patches
must be in the \texttt{patches} folder for the patching tool to apply
them.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Copy all the patch source ZIP files to
  \texttt{{[}LIFERAY\_HOME{]}/patching-tool/patches} if you haven't
  already copied them there.
\item
  Execute the \texttt{info} command to make sure it lists your patches.
  If a patch isn't listed, copy its ZIP file into the \texttt{patches}
  folder. Replace \texttt{{[}profile{]}} with your DXP source code
  profile name:

\begin{verbatim}
patching-tool.sh [profile] info
\end{verbatim}
\item
  Apply the patches by executing the \texttt{install} command on your
  profile:

\begin{verbatim}
patching-tool.sh [profile] install
\end{verbatim}
\end{enumerate}

Your DXP installation and source code is patched and ready to debug!

Attach your favorite debugger to your DXP instance and start the server.
See your debugger's documentation for configuration details.

Congratulations! You're free to explore DXP inside and out!

\subsection{Related Topics
(id=related-topics)}\label{related-topics-idrelated-topics}

\href{/docs/7-0/tutorials/-/knowledge_base/t/troubleshooting}{Troubleshooting}

\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-ide}{Liferay @ide@}

\section{Liferay DXP Failed to Initialize Because the Database Wasn't
Ready}\label{liferay-dxp-failed-to-initialize-because-the-database-wasnt-ready}

If you start your database server and application server at the same
time, Liferay DXP might try connecting to the data source before the
database is ready. By default, Liferay DXP doesn't retry connecting to
the database; it just fails. Now Liferay DXP provides a way to avoid
this situation: database connection retries.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a \texttt{portal-ext.properties} file.
\item
  Set the property \texttt{retry.jdbc.on.startup.max.retries} equal to
  the number of times to retry connecting to the data source.
\item
  Set property \texttt{retry.jdbc.on.startup.delay} equal to the number
  of seconds to wait before retrying connection.
\end{enumerate}

If at first the connection doesn't succeed, Liferay DXP uses the retry
settings to try again.

\subsection{Related Topics}\label{related-topics-217}

\href{/docs/7-0/tutorials/-/knowledge_base/t/connecting-to-data-sources-using-jndi}{Connecting
to JNDI Data Sources}

\section{Using OSGi Services from EXT
Plugins}\label{using-osgi-services-from-ext-plugins}

Using OSGi services from an Ext plugin is done the same way that Liferay
DXP's core uses OSGi services: via the \texttt{com.liferay.registry} API
provided by the \texttt{registry-api} bundle. All usages of this API in
Liferay DXP's core can serve as examples. Here's a very simple example:

\begin{verbatim}
Registry registry = RegistryUtil.getRegistry();
UserService userService = registry.getService(UserService.class);
If (userService != null) {
    User user = userService.getCurrentUser();
    System.out.println("Current user is " + user.getFirstName() + StringPool.BLANK + 
        user.getLastName());
}
\end{verbatim}

Remember that OSGi services can come and go at any time. Liferay DXP
services, including \texttt{UserService}, aren't an exception to this
rule. Although it's unlikely that \texttt{UserService} becomes
unavailable, you must still account for that possibility. Liferay DXP's
registry API provides \texttt{ServiceReference} and
\texttt{ServiceTracker}, which you can use to simplify dealing with OSGi
services. If you're familiar with OSGi development, you've heard of
these classes because the OSGi framework provides them. Liferay DXP's
versions of these classes wrap the OSGi ones, so you can use them the
same way.

Here's a smarter version of the above example. Using service trackers
takes away much of the pain of having to deal with services that can
appear and disappear dynamically:

\begin{verbatim}
Registry registry = RegistryUtil.getRegistry();
ServiceTracker<UserService, UserService> tracker = registry.trackServices(UserService.class);
tracker.open();
UserService userService = tracker.getService();
if (userService != null) {
    User user = userService.getCurrentUser();
    System.out.println("Current user is " + user.getFirstName() + StringPool.SPACE + 
        user.getLastName());
}
tracker.close();
\end{verbatim}

Remember to open your service trackers before use and close them after
use. If you must use Liferay DXP's OSGi services in a servlet, for
example, it's a good idea to open your service trackers in
\texttt{Servlet.init()} and close them in \texttt{Servlet.destroy()}.

\subsection{Related Topics}\label{related-topics-218}

\href{/docs/7-0/tutorials/-/knowledge_base/t/calling-non-osgi-code-that-uses-osgi-services}{Calling
Non-OSGi Code that Uses OSGi Services}

\href{/docs/7-0/tutorials/-/knowledge_base/t/osgi-basics-for-liferay-development}{OSGi
Basics For Liferay Development}

\section{Sort Order Changed with a Different
Database}\label{sort-order-changed-with-a-different-database}

If you've been using Liferay DXP, but are switching it to use a
different database type, consult your database vendor documentation to
understand your old and new database's default query result order. The
default order is either case-sensitive or case-insensitive. This affects
entity sort order in Liferay DXP.

Here are some examples of ascending alphabetical sort order.

Case-sensitive:

\begin{verbatim}
111
222
AAA
BBB
aaa
bbb
\end{verbatim}

Case-insensitive:

\begin{verbatim}
111
222
AAA
aaa
BBB
bbb
\end{verbatim}

Your new database's default query result order might differ from your
current database's order.

Consult your vendor's documentation to configure the order the way you
want.

\chapter{Data Upgrades}\label{data-upgrades}

Your module goes through various stages of development, because you're
constantly trying to improve it. You add new features, remove features,
enhance features, reorganize the code, and do whatever you can to
respond to what your users want and make your module the best it can be.
To transition users to new and improved versions of your module, you
need to take them through the process of upgrading.

Liferay provides a robust data upgrade framework for you to use. Here
you'll learn how to create a data upgrade process.

\section{Creating Data Upgrade Processes for
Modules}\label{creating-data-upgrade-processes-for-modules}

Some changes you make to a module involve modifying the database. These
changes bring with them the need for an upgrade process to move your
module's database from one version to the next. Liferay has an upgrade
framework you can use to make this easier to do. It's a feature-rich
framework that makes upgrades safe: the system records the current state
of the schema so that if the upgrade fails, the process can revert the
module back to its previous version.

\noindent\hrulefill

\textbf{Note}: Upgrade processes for traditional Liferay plugins (WAR
files) work
\href{/docs/7-0/tutorials/-/knowledge_base/t/optimizing-app-upgrade-processes\#understanding-liferay-portal-6-upgrade-processes}{the
same way they did for Liferay Portal 6.x}.

\noindent\hrulefill

Liferay DXP's upgrade framework executes your module's upgrades
automatically when the new version starts for the first time. You
implement concrete data schema changes in upgrade step classes and then
register them with the upgrade framework using an upgrade step
registrator. In this tutorial, you'll learn how to do all these things
to create an upgrade process for your module.

Here's what's involved:

\begin{itemize}
\item
  \textbf{Specifying the schema version}
\item
  \textbf{Declaring dependencies}
\item
  \textbf{Writing upgrade steps}
\item
  \textbf{Writing the registrator}
\item
  \textbf{Waiting for upgrade completion}
\end{itemize}

It's time to get started.

\subsection{Specifying the Schema
Version}\label{specifying-the-schema-version}

In your module's \texttt{bnd.bnd} file, specify a
\texttt{Liferay-Require-SchemaVersion} header with the new schema
version value. Here's an example schema version header for a module
whose new schema is version \texttt{1.1.0}:

\begin{verbatim}
    Liferay-Require-SchemaVersion: 1.1.0
\end{verbatim}

\noindent\hrulefill

\textbf{Important}: If no \texttt{Liferay-Require-SchemaVersion} header
is specified, Liferay DXP considers the \texttt{Bundle-Version} header
value to be the database schema version.

\noindent\hrulefill

Next, you'll specify your upgrade's dependencies.

\subsection{Declaring Dependencies}\label{declaring-dependencies}

In your module's dependency management file (e.g., Maven POM, Gradle
build file, or Ivy \texttt{ivy.xml} file),
\href{/docs/7-0/tutorials/-/knowledge_base/t/configuring-dependencies}{add
a dependency} on the
\href{https://repository.liferay.com/nexus/content/repositories/liferay-public-releases/com/liferay/com.liferay.portal.upgrade/}{\texttt{com.liferay.portal.upgrade}
module}.

In a \texttt{build.gradle} file, the dependency would look like this:

\begin{verbatim}
compile group: "com.liferay", name: "com.liferay.portal.upgrade", version: "2.0.0"
\end{verbatim}

If there are other modules your upgrade process requires, specify them
as dependencies.

You've configured your module project for the upgrade. It's time to
create upgrade steps to update the database from the current schema
version to the new one.

\subsection{Writing Upgrade Steps}\label{writing-upgrade-steps}

An upgrade step is a class that adapts module data to the module's
target database schema. It can execute SQL commands and DDL files to
upgrade the data. As a developer, you can encapsulate upgrade logic in
multiple upgrade step classes per schema version.

The upgrade class extends the
\href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/upgrade/UpgradeProcess.html}{\texttt{UpgradeProcess}
base class}, which implements the
\href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/upgrade/UpgradeStep.html}{\texttt{UpgradeStep}
interface}. Each upgrade step must override the \texttt{UpgradeProcess}
class's method \texttt{doUpgrade} with instructions for modifying the
database.

Since \texttt{UpgradeProcess} extends the
\href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/dao/db/BaseDBProcess.html}{\texttt{BaseDBProcess}
class}, you can use its \texttt{runSQL} and \texttt{runSQLTemplate*}
methods to execute your SQL commands and SQL DDL, respectively.

If you want to create, modify, or drop tables or indexes by executing
DDL sentences from an SQL file, make sure to use ANSI SQL only. Doing
this assures the commands work on different databases.

If you need to use non-ANSI SQL, it's best to write it in the
\href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/upgrade/UpgradeProcess.html}{\texttt{UpgradeProcess}
class's} \texttt{runSQL} or \texttt{alter} methods, along with tokens
that allow porting the sentences to different databases.

For example, consider the journal-service module's
\href{https://github.com/liferay/liferay-portal/blob/7.0.6-ga7/modules/apps/web-experience/journal/journal-service/src/main/java/com/liferay/journal/internal/upgrade/v0_0_4/UpgradeSchema.java}{\texttt{UpgradeSchema}
upgrade step class}:

\begin{verbatim}
package com.liferay.journal.internal.upgrade.v0_0_4;

import com.liferay.journal.internal.upgrade.v0_0_4.util.JournalArticleTable;
import com.liferay.journal.internal.upgrade.v0_0_4.util.JournalFeedTable;
import com.liferay.portal.kernel.upgrade.UpgradeMVCCVersion;
import com.liferay.portal.kernel.upgrade.UpgradeProcess;
import com.liferay.portal.kernel.util.StringUtil;

/**
 * @author Eduardo Garcia
 */
public class UpgradeSchema extends UpgradeProcess {

    @Override
    protected void doUpgrade() throws Exception {
        String template = StringUtil.read(
            UpgradeSchema.class.getResourceAsStream("dependencies/update.sql"));

        runSQLTemplateString(template, false, false);

        upgrade(UpgradeMVCCVersion.class);

        alter(
            JournalArticleTable.class,
            new AlterColumnName(
                "structureId", "DDMStructureKey VARCHAR(75) null"),
            new AlterColumnName(
                "templateId", "DDMTemplateKey VARCHAR(75) null"),
            new AlterColumnType("description", "TEXT null"));

        alter(
            JournalFeedTable.class,
            new AlterColumnName("structureId", "DDMStructureKey TEXT null"),
            new AlterColumnName("templateId", "DDMTemplateKey TEXT null"),
            new AlterColumnName(
                "rendererTemplateId", "DDMRendererTemplateKey TEXT null"),
            new AlterColumnType("targetPortletId", "VARCHAR(200) null"));
    }

}
\end{verbatim}

The above example class \texttt{UpgradeSchema} uses the
\texttt{runSQLTemplateString} method to execute ANSI SQL DDL from an SQL
file. To modify column names and column types, it uses the
\texttt{alter} method and
\href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/upgrade/UpgradeProcess.html}{\texttt{UpgradeProcess}'s}
\texttt{UpgradeProcess.AlterColumnName} and
\texttt{UpgradeProcess.AlterColumnType} inner classes as token classes.

Here's a simpler example upgrade step from the
\texttt{com.liferay.calendar.service} module. It uses the \texttt{alter}
method to modify a column type in the calendar booking table:

\begin{verbatim}
public class UpgradeCalendarBooking extends UpgradeProcess {

        @Override
        protected void doUpgrade() throws Exception {
                alter(
                        CalendarBookingTable.class,
                        new AlterColumnType("description", "TEXT null"));
        }

}
\end{verbatim}

You can implement upgrade steps just like these for your module schemas.

How you name and organize upgrade steps is up to you. Liferay's upgrade
classes are organized using a package structure similar to this one:

\begin{itemize}
\tightlist
\item
  \emph{some.package.structure}

  \begin{itemize}
  \tightlist
  \item
    \texttt{upgrade}

    \begin{itemize}
    \tightlist
    \item
      \texttt{v1\_1\_0}

      \begin{itemize}
      \tightlist
      \item
        \texttt{UpgradeFoo.java} ← Upgrade Step
      \end{itemize}
    \item
      \texttt{v2\_0\_0}

      \begin{itemize}
      \tightlist
      \item
        \texttt{UpgradeFoo.java} ← Upgrade Step
      \item
        \texttt{UpgradeBar.java} ← Upgrade Step
      \end{itemize}
    \item
      \texttt{MyCustomModuleUpgrade.java} ← Registrator
    \end{itemize}
  \end{itemize}
\end{itemize}

The example upgrade structure shown above is for a module that has two
database schema versions: \texttt{1.1.0} and \texttt{2.0.0}. They're
represented by packages \texttt{v1\_1\_0} and \texttt{v2\_0\_0}. Each
version package contains upgrade step classes that update the database.
The example upgrade steps focus on fictitious data elements \texttt{Foo}
and \texttt{Bar}. The registrator class (\texttt{MyCustomModuleUpgrade},
in this example) is responsible for registering the applicable upgrade
steps for each schema version.

Here are some organizational tips:

\begin{itemize}
\item
  Put all upgrade classes in a sub-package called \texttt{upgrade}.
\item
  Group together similar database updates (ones that operate on a data
  element or related data elements) in the same upgrade step class.
\item
  Create upgrade steps in sub-packages named after each data schema
  version.
\end{itemize}

Before continuing with upgrade step registrators, if your application
was modularized from a former traditional Liferay plugin application
(application WAR) and it uses Service Builder, it requires a Bundle
Activator to register itself in Liferay DXP's \texttt{Release\_} table.
If this is the case for your application,
\href{/docs/7-0/tutorials/-/knowledge_base/t/upgrade-processes-for-former-service-builder-plugins}{create
and register a Bundle Activator} and then return here to write your
upgrade step registrator.

\subsection{Writing the Upgrade Step
Registrator}\label{writing-the-upgrade-step-registrator}

A module's upgrade step registrator notifies Liferay's upgrade framework
of all the upgrade steps to update the module data for each schema
version. It specifies the module's entire upgrade process. The upgrade
framework executes the upgrade steps to update the current module data
to the latest schema.

For example, the upgrade step registrator class
\texttt{MyCustomModuleUpgrade} (below) registers upgrade steps
incrementally for each schema version (past and present):

\begin{verbatim}
package com.liferay.mycustommodule.upgrade;

import com.liferay.portal.upgrade.registry.UpgradeStepRegistrator;

import org.osgi.service.component.annotations.Component;

@Component(immediate = true, service = UpgradeStepRegistrator.class)
public class MyCustomModuleUpgrade implements UpgradeStepRegistrator {

    @Override
    public void register(Registry registry) {
        registry.register(
            "com.liferay.mycustommodule", "0.0.0", "2.0.0",
            new DummyUpgradeStep());

        registry.register(
            "com.liferay.mycustommodule", "1.0.0", "1.1.0",
            new com.liferay.mycustommodule.upgrade.v1_1_0.UpgradeFoo());

        registry.register(
            "com.liferay.mycustommodule", "1.1.0", "2.0.0",
            new com.liferay.mycustommodule.upgrade.v2_0_0.UpgradeFoo(),
            new com.liferay.mycustommodule.upgrade.v2_0_0.UpgradeBar());
    }

}
\end{verbatim}

The registrator's \texttt{register} method informs the upgrade framework
about each new schema and associated upgrade steps to adapt data to it.
Each schema upgrade is represented by a registration. A registration is
an abstraction for all the changes you need to apply to the database
from one schema version to the next one.

The following diagram illustrates the relationship between the
registrator and the upgrade steps.

\begin{figure}
\centering
\includegraphics{./images/data-upgrade-module-upgrade-architecture.png}
\caption{In a registrator class, the developer specifies a registration
for each schema version upgrade. The upgrade steps handle the database
updates.}
\end{figure}

The previous example \texttt{MyCustomModuleUpgrade} registrator class
listing shows how this works.

The registrator class declares itself to be an OSGi Component of service
type \texttt{UpgradeStepRegistrator.class}. The \texttt{@Component}
annotation registers the class to the OSGi framework as the module's
upgrade step registrator. The attribute \texttt{immediate\ =\ true}
tells the OSGi framework to activate this module immediately after it's
installed.

The registrator implements the
\href{@app-ref@/foundation/latest/javadocs/com/liferay/portal/upgrade/registry/UpgradeStepRegistrator.html}{\texttt{UpgradeStepRegistrator}
interface}, which is in the \texttt{com.liferay.portal.upgrade} module.
The interface declares a
\href{@app-ref@/foundation/latest/javadocs/com/liferay/portal/upgrade/registry/UpgradeStepRegistrator.html\#register-com.liferay.portal.upgrade.registry.UpgradeStepRegistrator.Registry-}{\texttt{register}
method} that the registrator must override. In that method, the
registrator implements all the module's upgrade registrations.

Upgrade registrations are defined by the following values:

\begin{itemize}
\tightlist
\item
  \textbf{Module's bundle symbolic name}
\item
  \textbf{Schema version to upgrade from} (as a \texttt{String})
\item
  \textbf{Schema version to upgrade to} (as a \texttt{String})
\item
  \textbf{List of upgrade steps}
\end{itemize}

The example registrator \texttt{MyCustomModuleUpgrade} registers three
upgrades:

\begin{itemize}
\tightlist
\item
  \texttt{0.0.0} to \texttt{2.0.0}
\item
  \texttt{1.0.0} to \texttt{1.1.0}
\item
  \texttt{1.1.0} to \texttt{2.0.0}
\end{itemize}

The \texttt{MyCustomModuleUpgrade} registrator's first registration is
applied by the upgrade framework if the module has not been installed
previously. Its list of upgrade steps contains only one:
\texttt{new\ DummyUpgradeStep()}.

\begin{verbatim}
registry.register(
    "com.liferay.document.library.web", "0.0.0", "2.0.0",
    new DummyUpgradeStep());
\end{verbatim}

The
\href{https://github.com/liferay/liferay-portal/blob/7.0.1-ga2/portal-kernel/src/com/liferay/portal/kernel/upgrade/DummyUpgradeStep.java}{\texttt{DummyUpgradeStep}
class} provides an empty upgrade step. The
\texttt{MyCustomModuleUpgrade} registrator defines this registration so
that the upgrade framework records the module's latest schema version
(i.e., \texttt{2.0.0}) in Liferay DXP's \texttt{Release\_} table.

\textbf{Important}: Modules that use Service Builder \emph{should not}
define a registration for their initial database schema version, as
Service Builder already records their schema versions to Liferay DXP's
\texttt{Release\_} table. Modules that don't use Service Builder,
however, \emph{should} define a registration for their initial schema.

The \texttt{MyCustomUpgrade} registrator's next registration (from
schema version \texttt{1.0.0} to \texttt{1.1.0}) includes one upgrade
step.

\begin{verbatim}
registry.register(
    "com.liferay.mycustommodule", "1.0.0", "1.1.0",
          new com.liferay.mycustommodule.upgrade.v1_1_0.UpgradeFoo());
\end{verbatim}

The upgrade step's fully qualified class name is required because
classes named \texttt{UpgradeFoo} are in package
\texttt{com.liferay.mycustommodule.upgrade.v1\_1\_0}and
\texttt{com.liferay.mycustommodule.upgrade.v2\_0\_0}.

The registrator's final registration (from schema version \texttt{1.1.0}
to \texttt{2.0.0}) contains two upgrade steps.

\begin{verbatim}
registry.register(
    "com.liferay.mycustommodule", "1.1.0", "2.0.0",
    new com.liferay.mycustommodule.upgrade.v2_0_0.UpgradeFoo(),
    new UpgradeBar());
\end{verbatim}

Both upgrade steps, \texttt{UpgradeFoo} and \texttt{UpgradeBar}, reside
in the module's \texttt{com.liferay.mycustommodule.upgrade.v2\_0\_0}
package. The fully qualified class name
\texttt{com.liferay.mycustommodule.upgrade.v2\_0\_0.UpgradeFoo} is used
for the \texttt{UpgradeFoo} class, while the simple class name
\texttt{UpgradeBar} is fine for the second upgrade step.

A registration's upgrade step list can consist of as many upgrade steps
as needed.

\textbf{Important}: If your upgrade step uses an OSGi service, your
upgrade must wait for that service's availability. To specify that your
upgrade is to be executed only after that service is available, add an
OSGi reference to that service.

For example, the
\href{https://github.com/liferay/liferay-portal/blob/7.0.1-ga2/modules/apps/collaboration/wiki/wiki-service/src/main/java/com/liferay/wiki/upgrade/WikiServiceUpgrade.java}{\texttt{WikiServiceUpgrade}
registrator class} references the \texttt{SettingsFactory} class. The
upgrade step class
\href{https://github.com/liferay/liferay-portal/blob/7.0.1-ga2/modules/apps/collaboration/wiki/wiki-service/src/main/java/com/liferay/wiki/upgrade/v1_0_0/UpgradePortletSettings.java}{\texttt{UpgradePortletSettings}
upgrade step} uses it. Here's the \texttt{WikiServiceUpgrade} class:

\begin{verbatim}
@Component(immediate = true, service = UpgradeStepRegistrator.class)
public class WikiServiceUpgrade implements UpgradeStepRegistrator {

    @Override
    public void register(Registry registry) {
        registry.register(
            "com.liferay.wiki.service", "0.0.1", "0.0.2", new UpgradeSchema());

        registry.register(
            "com.liferay.wiki.service", "0.0.2", "0.0.3",
            new UpgradeKernelPackage(), new UpgradePortletId());

        registry.register(
            "com.liferay.wiki.service", "0.0.3", "1.0.0",
            new UpgradeCompanyId(), new UpgradeLastPublishDate(),
            new UpgradePortletPreferences(),
            new UpgradePortletSettings(_settingsFactory),
            new UpgradeWikiPageResource());
    }

    @Reference(unbind = "-")
    protected void setSettingsFactory(SettingsFactory settingsFactory) {
        _settingsFactory = settingsFactory;
    }

    private SettingsFactory _settingsFactory;

}
\end{verbatim}

In the third registration in the listing above, the
\texttt{UpgradePortletSettings} upgrade step uses the
\texttt{SettingsFactory} service. The \texttt{setSettingsFactory}
method's \texttt{@Reference} annotation declares that the registrator
class depends on and must wait for the \texttt{SettingsFactory} service
to be available in the run time environment. The annotation's attribute
setting \texttt{unbind\ =\ "-"} indicates that the registrator class has
no method for unbinding the service.

Next, you must make sure the module's upgrade is executed before making
its services available.

\subsection{Waiting for Upgrade
Completion}\label{waiting-for-upgrade-completion}

Before module services that access the database are used, the database
should be upgraded to the latest database schema.

As a convenience, configuring the Bnd header
\texttt{Liferay-Require-SchemaVersion} to the latest schema version is
all that's required to assure the database is upgraded for
\href{/docs/7-0/tutorials/-/knowledge_base/t/what-is-service-builder}{Service
Builder} services.

For all other services, the developer can assure database upgrade by
specifying an \texttt{@Reference} annotation that targets the containing
module and its latest schema version.

Here are the target's required attributes:

\begin{itemize}
\tightlist
\item
  \texttt{release.bundle.symbolic.name}: module's bundle symbolic name
\item
  \texttt{release.schema.version}: module's current schema version
\end{itemize}

For example, the \texttt{com.liferay.comment.page.comments.web} module's
\href{https://github.com/liferay/liferay-portal/blob/7.0.2-ga3/modules/apps/collaboration/comment/comment-page-comments-web/src/main/java/com/liferay/comment/page/comments/web/internal/portlet/PageCommentsPortlet.java}{\texttt{PageCommentsPortlet}
class} assures upgrading to schema version \texttt{1.0.0} by defining
the following reference:

\begin{verbatim}
@Reference(
    target = "(&(release.bundle.symbolic.name=com.liferay.comment.page.comments.web)(release.schema.version=1.0.0))",
    unbind = "-"
)
protected void setRelease(Release release) {
}
\end{verbatim}

Dependencies between OSGi services can reduce the number of service
classes in which upgrade reference annotations are needed. For example,
there's no need to add an upgrade reference in a dependent service, if
the dependency already refers to the upgrade.

\noindent\hrulefill

\textbf{Note}: Data verifications using the class \texttt{VerifyProcess}
are deprecated. Verifications should be tied schema versions. Upgrade
processes are associated with schema versions but \texttt{VerifyProcess}
instances are not.

\noindent\hrulefill

Now you know how to create data upgrades for all your modules. You
specify the new data schema version in the \texttt{bnd.bnd} file, add a
reference to your module and to the schema version to assure upgrade
execution if the module doesn't use Service Builder, and add a
dependency on the \texttt{com.liferay.portal.upgrade} module. For the
second part of the process, you create upgrade step classes to update
the database schema and register the upgrade steps in a registrator
class. That's all there is to it!

\subsection{Related Topics}\label{related-topics-219}

\href{/docs/7-0/tutorials/-/knowledge_base/t/upgrade-processes-for-former-service-builder-plugins}{Upgrade
Processes for Former Service Builder Plugins}

\href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-plugins-to-liferay-7}{Upgrading
Plugins to Liferay 7}

\href{/docs/7-0/tutorials/-/knowledge_base/t/configuration}{Configuration}

\href{/docs/7-0/tutorials/-/knowledge_base/t/optimizing-app-upgrade-processes}{Migrating
Data Upgrade Processes to the New Framework for Modules}

\section{Upgrade Processes for Former Service Builder
Plugins}\label{upgrade-processes-for-former-service-builder-plugins}

If you modularized a traditional Liferay plugin application that
implements Service Builder services, your new modular application must
register itself in the \texttt{Release\_} table. This is required
regardless of whether release records already exist for previous
versions of the app. A Bundle Activator is the recommended way to add a
release record for the first modular version of your converted
application. Here you'll see an example Bundle Activator and learn how
to create and activate a Bundle Activator for your application.

\textbf{Important}: This tutorial only applies to modular applications
that use Service Builder and were modularized from traditional Liferay
plugin applications. It does not apply to you if your application does
not use Service Builder or has never been a traditional Liferay plugin
application (a WAR application).

Bundle Activator class code is dense but straightforward. Referring to
an example Bundle Activator can be helpful. Here's the Liferay Knowledge
Base application's Bundle Activator:

\begin{verbatim}
public class KnowledgeBaseServiceBundleActivator implements BundleActivator {

    @Override
    public void start(BundleContext bundleContext) throws Exception {
        Filter filter = bundleContext.createFilter(
            StringBundler.concat(
                "(&(objectClass=", ModuleServiceLifecycle.class.getName(), ")",
                ModuleServiceLifecycle.DATABASE_INITIALIZED, ")"));

        _serviceTracker = new ServiceTracker<Object, Object>(
            bundleContext, filter, null) {

            @Override
            public Object addingService(
                ServiceReference<Object> serviceReference) {

                try {
                    BaseUpgradeServiceModuleRelease
                        upgradeServiceModuleRelease =
                            new BaseUpgradeServiceModuleRelease() {

                                @Override
                                protected String getNamespace() {
                                    return "KB";
                                }

                                @Override
                                protected String getNewBundleSymbolicName() {
                                    return "com.liferay.knowledge.base.service";
                                }

                                @Override
                                protected String getOldBundleSymbolicName() {
                                    return "knowledge-base-portlet";
                                }

                            };

                    upgradeServiceModuleRelease.upgrade();

                    return null;
                }
                catch (UpgradeException ue) {
                    throw new RuntimeException(ue);
                }
            }

        };

        _serviceTracker.open();
    }

    @Override
    public void stop(BundleContext bundleContext) throws Exception {
        _serviceTracker.close();
    }

    private ServiceTracker<Object, Object> _serviceTracker;

}
\end{verbatim}

The following steps explain how to create a Bundle Activator, like the
example above.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a class that implements the interface
  \texttt{org.osgi.framework.BundleActivator}.
\item
  Add a service tracker field:

  \texttt{private\ ServiceTracker\textless{}Object,\ Object\textgreater{}\ \_serviceTracker;}
\item
  Override BundleActivator's \texttt{stop} method to close the service
  tracker:

\begin{verbatim}
@Override
public void stop(BundleContext bundleContext) throws Exception {
    _serviceTracker.close();
}
\end{verbatim}
\item
  Override BundleActivator's \texttt{start} method to instantiate a
  service tracker that creates a filter to listens for the app's
  database initialization event and initializes the service tracker to
  use that filter. You'll add the service tracker initialization code in
  the next steps. At the end of the \texttt{start} method, open the
  service tracker.

\begin{verbatim}
@Override
public void start(BundleContext bundleContext) throws Exception {
    Filter filter = bundleContext.createFilter(
        StringBundler.concat(
            "(&(objectClass=", ModuleServiceLifecycle.class.getName(), ")",
            ModuleServiceLifecycle.DATABASE_INITIALIZED, ")"));

    _serviceTracker = new ServiceTracker<Object, Object>(
        bundleContext, filter, null) {
        // See the next step for this code ...
    };

    _serviceTracker.open();
}
\end{verbatim}
\item
  In the service tracker initialization block
  \texttt{\{\ //\ See\ the\ next\ step\ for\ this\ \ \ \ \ code\ ...\ \}}
  from the previous step, add an \texttt{addingService} method that
  instantiates a \texttt{BaseUpgradeServiceModuleRelease} for describing
  your app. The example \texttt{BaseUpgradeServiceModuleRelease}
  instance below describes Liferay's Knowledge Base app:

\begin{verbatim}
@Override
public Object addingService(
    ServiceReference<Object> serviceReference) {

    try {
        BaseUpgradeServiceModuleRelease
                upgradeServiceModuleRelease =
            new BaseUpgradeServiceModuleRelease() {

                @Override
                protected String getNamespace() {
                    return "KB";
                }

                @Override
                protected String getNewBundleSymbolicName() {
                    return "com.liferay.knowledge.base.service";
                }

                @Override
                protected String getOldBundleSymbolicName() {
                    return "knowledge-base-portlet";
                }

            };

        upgradeServiceModuleRelease.upgrade();

        return null;
    }
    catch (UpgradeException ue) {
        throw new RuntimeException(ue);
    }
}
\end{verbatim}

  The \texttt{BaseUpgradeServiceModuleRelease} implements the following
  methods:

  \begin{itemize}
  \tightlist
  \item
    \texttt{getNamespace}: Returns the namespace value as specified in
    the former plugin's \texttt{service.xml} file. This value is also in
    the \texttt{buildNamespace} field in the plugin's
    \texttt{ServiceComponent} table record.
  \item
    \texttt{getOldBundleSymbolicName}: Returns the former plugin's name.
  \item
    \texttt{getNewBundleSymbolicName}: Returns the module's symbolic
    name. In the module's \texttt{bnd.bnd} file, it's the
    \texttt{Bundle-SymbolicName} value.
  \item
    \texttt{upgrade}: Invokes the app's upgrade processes.
  \end{itemize}
\item
  In the module's \texttt{bnd.bnd} file, reference the Bundle Activator
  class you created. Here's the example's Bundle Activator reference:

  \texttt{Bundle-Activator:\ com.liferay.knowledge.base.internal.activator.KnowledgeBaseServiceBundleActivator}
\end{enumerate}

The Bundle Activator uses one of the following values to initialize the
\texttt{schemaVersion} field in the application's \texttt{Release\_}
table record:

\begin{itemize}
\tightlist
\item
  Current \texttt{buildNumber}: if there is an existing Release\_ table
  record for the previous plugin.
\item
  \texttt{0.0.1}: if there is no existing Release\_ table record.
\end{itemize}

You've set your service module's data upgrade process.

\subsection{Related Topics}\label{related-topics-220}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-an-upgrade-process-for-your-app}{Creating
Data Upgrade Processes for Modules}

\href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-plugins-to-liferay-7}{Upgrading
Plugins to Liferay 7}

\section{Upgrading Data Schemas in
Development}\label{upgrading-data-schemas-in-development}

As you develop modules, you might need to iterate through several
database schema changes. Before you release new module versions with
your finalized schema changes, you must create a formal
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-an-upgrade-process-for-your-app}{data
upgrade process}. Until then, you can use the Build Auto Upgrade feature
to test schema changes on the fly.

\noindent\hrulefill

\textbf{Note}: In Liferay Portal 6.x Service Builder portlets, the
\texttt{build.auto.upgrade} property in \texttt{service.properties}
applies Liferay Service schema changes upon rebuilding services and
redeploying the portlets. As of 7.0, this property is deprecated.

Liferay Digital Enterprise 7.0 Fix Pack 28, and Liferay CE Portal 7.0.4
GA5 reintroduce Build Auto Upgrade in a new global property
\texttt{schema.module.build.auto.upgrade} in the file
\texttt{{[}Liferay\_Home{]}/portal-developer.properties}.

\noindent\hrulefill

Setting the global property \texttt{schema.module.build.auto.upgrade} to
\texttt{true} applies module schema changes for redeployed modules whose
service build numbers have incremented. The \texttt{build.number}
property in the module's \texttt{service.properties} file indicates the
service build number. Build Auto Upgrade executes schema changes without
massaging existing data. It leaves data empty for created columns, drops
data from deleted and renamed columns, and orphans data from deleted and
renamed tables.

Although Build Auto Upgrade updates databases quickly and automatically,
it doesn't guarantee a proper data upgrade--you implement that via
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-an-upgrade-process-for-your-app}{data
upgrade processes}. Build Auto Upgrade is for development purposes only.

\noindent\hrulefill

\textbf{WARNING}: DO NOT USE the Build Auto Upgrade feature in
production. Liferay DXP DOES NOT support Build Auto Upgrade in
production. Build Auto Upgrade is for development purposes only.
Enabling it in production can result in data loss and improper data
upgrade. In production environments, leave the property
\texttt{schema.module.build.auto.upgrade} in
\texttt{portal-developer.properties} set to \texttt{false}.

\noindent\hrulefill

By default, \texttt{schema.module.build.auto.upgrade} is set to
\texttt{false}. On any module's first deployment, the module's tables
are generated regardless of the
\texttt{schema.module.build.auto.upgrade} value.

The following table summarizes Build Auto Upgrade's handling of schema
changes:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.5200}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.4800}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Schema Change
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Result
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Add column & Create a new empty column. \\
Rename column & Drop the existing column and delete all its data. Create
a new empty column. \\
Delete column & Drop the existing column and delete all its data. \\
Create or rename a table in Liferay DXP's built-in data source. & Orphan
the existing table and all its data. Create the new table. \\
\end{longtable}

Great! Now you know how to use the Build Auto Upgrade developer feature.

\subsection{Related Topics}\label{related-topics-221}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-an-upgrade-process-for-your-app}{Creating
Data Upgrade Process for Modules}

\chapter{Back-end Frameworks}\label{back-end-frameworks}

What are back-end frameworks? Are they important? If so, why aren't they
up-front and center in the docs? Good questions.

Back-end frameworks are analogous to supporting actors and actresses in
show business. They fill out the stories in films we know and love. As
actors bring richness and life to their films, Liferay's powerful
back-end frameworks bring essential services and deliver terrific
performances of their own. Here are some of the frameworks:

\begin{itemize}
\tightlist
\item
  Device Recognition
\item
  Message Bus
\end{itemize}

These frameworks and more deliver smashing performances and are stars in
their own right.

\section{Device Recognition API}\label{device-recognition-api}

As you know, Internet traffic has risen exponentially over the past
decade, and this trend shows no sign of stopping. In addition, the bulk
of Internet traffic now comes from mobile devices. The mobile boom
presents new obstacles and challenges for content management. How will
content adapt to different devices with different capabilities? How can
your grandma's gnarly tablet and your cousin's awesome new smart phone
request the same information from your portal?

The Device API detects the capabilities of any device making a request
to your portal. It can also determine what mobile device or operating
system was used to make a request, and then follows rules to make
Liferay DXP render pages based on the device. To use these features, you
must first install a device detection database that can detect which
mobile devices are accessing the portal. Liferay DXP provides such a
database in the Liferay Mobile Device Detection (LMDD) app from the
Liferay Marketplace.
\href{/docs/7-0/user/-/knowledge_base/u/using-the-liferay-marketplace}{Click
here} for instructions on using Liferay Marketplace to find and install
apps.

\noindent\hrulefill

\textbf{Important:} On Windows, Liferay Mobile Device Detection
Enterprise must be run on a 64-bit JVM. On all operating systems,
Liferay Mobile Device Detection Enterprise requires a JVM minimum memory
setting of at least 2 gb.

\noindent\hrulefill

You can create your own plugin that makes use of the device database.
This tutorial shows you some of the methods in the Device API that you
can use to retrieve device attributes and capabilities. Now go ahead and
get started!

\subsection{Getting Started with the Device
API}\label{getting-started-with-the-device-api}

One important thing that you'll want to get using the Device API is the
\texttt{Device} object. You can obtain it from the \texttt{themeDisplay}
object like this:

\begin{verbatim}
Device device = themeDisplay.getDevice();
\end{verbatim}

You can view the
\href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/mobile/device/Device.html}{\texttt{Device}
API}. Using some of the methods from the Javadocs, here's an example
that obtains a device's dimensions:

\begin{verbatim}
Dimensions dimensions = device.getScreenSize();
float height = dimensions.getHeight();
float width = dimensions.getWidth();
\end{verbatim}

Now your code can get the \texttt{Device} object and the dimensions of a
device. Of course, this is just a simple example. You can acquire many
other device attributes that help you take care of the pesky problems
that arise when sending content to different devices. Refer to the
Device Javadocs mentioned above for assistance. Next, you'll learn about
retrieving some other device capabilities.

\subsection{Getting Device Properties}\label{getting-device-properties}

With the Device API, you can detect the \emph{properties} of a device
making a request to your portal and then render content accordingly.
Properties refer to things that the requesting device can do. For
example, you can determine the device's operating system, browser, form
factor, and much more. Properties can be retrieved with the
\texttt{getCapability} and \texttt{getCapabilities} methods of the
Device API.

Most of the properties of the requesting device can be detected,
depending on the device detection implementation you're using. For
example, you can obtain the brand name of the device with this code:

\begin{verbatim}
String brand = device.getCapability("OEM");
\end{verbatim}

You can grab many other device properties, including
\texttt{HardwareModel}, \texttt{HardwareName}, \texttt{ReleaseYear}, and
\texttt{ReleaseMonth}. You can also get boolean values like
\texttt{IsMobile}, \texttt{IsTablet}, and many more.

Keep in mind the Device API is an API. The underlying implementation of
the Device API may change. You can also implement your own. Thus, the
device property names are specific and proprietary to the underlying
Device API implementation.

Now that you know about the Device API, you can use it to make sure that
your grandma's gnarly tablet and your cousin's awesome new smart phone
can make requests to your portal and receive identical content. This
will make everyone happy!

\subsection{Related Topics}\label{related-topics-222}

\href{/docs/7-0/tutorials/-/knowledge_base/t/mobile}{Using the Mobile
SDK}

\href{/docs/7-0/tutorials/-/knowledge_base/t/service-builder}{Service
Builder and Services}

\chapter{Message Bus}\label{message-bus}

If you ever need to do some data processing outside the scope of the
web's request/response, look no further than the Message Bus. It's
conceptually similar to Java Messaging Service (JMS) Topics, but
sacrifices transactional, reliable delivery capabilities, making it much
lighter-weight. Liferay DXP uses Message Bus all over the place:

\begin{itemize}
\tightlist
\item
  Auditing
\item
  Search engine integration
\item
  Email subscriptions
\item
  Monitoring
\item
  Document Library processing
\item
  Background tasks
\item
  Cluster-wide request execution
\item
  Clustered cache replication
\end{itemize}

You can use it too! Here are some of Message Bus's most important
features:

\begin{itemize}
\tightlist
\item
  publish/subscribe messaging
\item
  request queuing and throttling
\item
  flow control
\item
  multi-thread message processing
\end{itemize}

There are also tools, such as the Java SE's JConsole, that can monitor
Message Bus activities.

\begin{figure}
\centering
\includegraphics{./images/message-bus-jconsole.png}
\caption{JConsole shows statistics on Message Bus messages sent,
messages pending, and more.}
\end{figure}

The Message Bus topics are covered in these tutorials:

\begin{itemize}
\tightlist
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/messaging-destinations}{Messaging
  Destinations}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/message-listeners}{Message
  Listeners}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/sending-messages}{Sending
  Messages}
\end{itemize}

Since all messages are sent to and received at destinations, messaging
destinations is worth exploring first.

\section{Messaging Destinations}\label{messaging-destinations}

In Message Bus, you send messages to \emph{destinations}. A destination
is a named logical (not physical) location. Sender classes send messages
to destinations, while listener classes wait to receive messages at the
destinations. In this way, the sender and recipient don't need to know
each other--they're loosely coupled. Here are the messaging destination
topics this tutorial covers:

\begin{itemize}
\tightlist
\item
  \hyperref[destination-configuration]{Destination configuration}
\item
  \hyperref[creating-a-destination]{Creating a destination}
\item
  \hyperref[messaging-event-listeners]{Messaging event listeners}
\end{itemize}

It's time to configure a destination.

\subsection{Destination Configuration}\label{destination-configuration}

Each destination has a name and type and can have several other
attributes. The destination type determines whether there's a message
queue, the kinds of threads involved with a destination, and the message
delivery behavior to expect at the destination.

Here are the primary destination types:

\begin{itemize}
\item
  \textbf{Parallel Destination}

  \begin{itemize}
  \item
    Messages sent here are queued.
  \item
    Multiple worker threads from a thread pool deliver each message to a
    registered message listener. There's one worker thread per message
    per message listener.
  \end{itemize}
\item
  \textbf{Serial Destination}

  \begin{itemize}
  \item
    Messages sent here are queued.
  \item
    Worker threads from a thread pool deliver the messages to each
    registered message listener, one worker thread per message.
  \end{itemize}
\item
  \textbf{Synchronous Destination}

  \begin{itemize}
  \item
    Messages sent here are directly delivered to message listeners.
  \item
    The thread sending the message here delivers the message to all
    message listeners also.
  \end{itemize}
\end{itemize}

Liferay has preconfigured destinations for various purposes. The
\href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/messaging/DestinationNames.html}{\texttt{DestinationNames}
class} defines \texttt{String} constants for each of them. For example,
\texttt{DestinationNames.HOT\_DEPLOY} (value is
\texttt{"liferay/hot\_deploy"}) is for deployment event messages. Since
destinations are tuned for specific purposes, don't modify them.

Destinations are based on
\href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/messaging/DestinationConfiguration.html}{\texttt{DestinationConfiguration}
instances}. The configuration specifies the destination type, name, and
these destination- related attributes:

\textbf{Maximum Queue Size}: limits the number of queued messages for
the destination.

\textbf{Rejected Execution Handler}: A
\href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/concurrent/RejectedExecutionHandler.html}{\texttt{com.liferay.portal.kernel.concurrent.RejectedExecutionHandler}
instance} can take action (e.g., log warnings) regarding rejected
messages when the destination queue is full.

\textbf{Workers Core Size}: initial number of worker threads for
processing messages.

\textbf{Workers Max Size}: limits the number of worker threads for
processing messages.

The \texttt{DestinationConfiguration} class provides these static
methods for creating the various types of configurations.

\begin{itemize}
\item
  \texttt{createParallelDestinationConfiguration(String\ destinationName)}
\item
  \texttt{createSerialDestinationConfiguration(String\ destinationName)}
\item
  \texttt{createSynchronousDestinationConfiguration(String\ destinationName)}
\end{itemize}

You can also use the
\href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/messaging/DestinationConfiguration.html\#DestinationConfiguration-java.lang.String-java.lang.String-}{\texttt{DestinationConfiguration}
constructor} to create a configuration for any destination type, even
your own.

\subsection{Creating a Destination}\label{creating-a-destination}

Message Bus destinations are based on destination configurations and
registered as OSGi services. Message Bus detects the destination
services and manages their associated destinations.

Here are the general steps for creating a destination. The example
configurator class that follows demonstrates these steps.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a destination configuration using one of
  \texttt{DestinationConfiguration}'s static \texttt{create*} methods or
  its constructor. Set any attributes that apply to the destinations
  you'll create with it.
\item
  Create a destination by invoking the
  \href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/messaging/DestinationFactory.html}{\texttt{DestinationFactory}}
  method \texttt{createDestination(DestinationConfiguration)}, passing
  in the destination configuration you created in the previous step.
\item
  Register the destination as an OSGi service by invoking the
  \href{https://osgi.org/javadoc/r4v43/core/org/osgi/framework/BundleContext.html}{\texttt{BundleContext}
  method \texttt{registerService}}, passing in the following parameters.

  \begin{itemize}
  \tightlist
  \item
    Destination class \texttt{Destination.class}
  \item
    Your \texttt{Destination} object
  \item
    A \texttt{Dictionary} of properties defining the destination,
    including the \texttt{destination.name}
  \end{itemize}
\item
  Manage the destination object and service registration resources using
  a collection, such as a
  \texttt{Map\textless{}String,\ ServiceRegistration\textless{}Destination\textgreater{}\textgreater{}}.
  Keeping references to these resources is helpful for when you're ready
  to unregister and destroy them. The \texttt{deactivate} method in
  example below demonstrates this.
\end{enumerate}

Here's an example messaging configurator component that creates and
registers a parallel destination and manages its resources:

\begin{verbatim}
@Component (
    immediate = true,
    service = MyMessagingConfigurator .class
)
public class MyMessagingConfigurator {

    @Activate
    protected void activate(BundleContext bundleContext) {

        _bundleContext = bundleContext;

        // Create a DestinationConfiguration for parallel destinations.

        DestinationConfiguration destinationConfiguration =
            new DestinationConfiguration(
                DestinationConfiguration.DESTINATION_TYPE_PARALLEL,
                    "myDestinationName");

        // Set the DestinationConfiguration's max queue size and
        // rejected execution handler.

        destinationConfiguration.setMaximumQueueSize(_MAXIMUM_QUEUE_SIZE);

        RejectedExecutionHandler rejectedExecutionHandler =
            new CallerRunsPolicy() {

                @Override
                public void rejectedExecution(
                    Runnable runnable, ThreadPoolExecutor threadPoolExecutor) {

                    if (_log.isWarnEnabled()) {
                        _log.warn(
                            "The current thread will handle the request " +
                                "because the graph walker's task queue is at " +
                                    "its maximum capacity");
                    }

                    super.rejectedExecution(runnable, threadPoolExecutor);
                }

            };

       destinationConfiguration.setRejectedExecutionHandler(
            rejectedExecutionHandler);

       // Create the destination

       Destination destination = _destinationFactory.createDestination(
            kaleoGraphWalkerDestinationConfiguration);

        // Add the destination to the OSGi service registry

        Dictionary<String, Object> properties = new HashMapDictionary<>();

        properties.put("destination.name", destination.getName());

        ServiceRegistration<Destination> serviceRegistration =
            _bundleContext.registerService(
                Destination.class, destination, properties);

        // Track references to the destination service registrations 

        _serviceRegistrations.put(destination.getName(),    
            serviceRegistration);
    }

    @Deactivate
    protected void deactivate() {

        // Unregister and destroy destinations this component unregistered

        for (ServiceRegistration<Destination> serviceRegistration : 
        _serviceRegistrations.values()) {

            Destination destination = _bundleContext.getService(
                serviceRegistration.getReference());

            serviceRegistration.unregister();

            destination.destroy();

        }

        _serviceRegistrations.clear();

     }

    @Reference
    private DestinationFactory _destinationFactory;

    private final Map<String, ServiceRegistration<Destination>>
        _serviceRegistrations = new HashMap<>();
}
\end{verbatim}

On activation, the example configurator above does these things:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Creates a \texttt{DestinationConfiguration} for parallel destinations.
\item
  Sets the \texttt{DestinationConfiguration}'s max queue size and a
  rejected execution handler.
\item
  Uses the \texttt{DestinationFactory} (the one bound to the
  \texttt{\_destinationFactory} field) to create the destination.
\item
  Adds the destination to the OSGi service registry
\item
  Adds the destination service registration to a map for managing them.
\end{enumerate}

Once the destination is registered, Message Bus detects its service and
manages the destination. On the example configurator's deactivation, its
\texttt{deactivate} method unregisters the destination services and
destroys the destinations.

As an added bonus to creating destinations, you can create classes that
listen for new destinations and new message listeners. You might want to
create such listeners to keep up to log the deployment of new message
bus endpoints.

\subsection{Messaging Event Listeners}\label{messaging-event-listeners}

There are Message Bus framework interfaces that let you listen for new
destinations and message listeners.

\subsubsection{Listening for new
Destinations}\label{listening-for-new-destinations}

The Message Bus notifies Message Bus Event Listeners when destinations
are added and removed. To register these listeners, publish a
\href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/messaging/MessageBusEventListener.html}{\texttt{MessageBusEventListener}
instance} to the OSGi service registry (e.g., via an \texttt{@Component}
annotation).

\begin{verbatim}
@Component(
    immediate = true,
    service = MessageBusEventListener.class
)
public class MyMessageBusEventListener implements MessageBusEventListener {

    void destinationAdded(Destination destination) {
        ...
    }

    void destinationDestroyed(Destination destination) {
        ...
    }
}
\end{verbatim}

Listening for new message listeners is easy too.

\subsubsection{Listening for new Message
Listeners}\label{listening-for-new-message-listeners}

The Message Bus notifies
\href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/messaging/DestinationEventListener.html}{\texttt{DestinationEventListener}
instances} when message listeners are either registered or unregistered
to destinations. To register a listener to a destination, publish a
\href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/messaging/DestinationEventListener.html}{\texttt{DestinationEventListener}
service} to the OSGi service registry, making sure to specify the
destination's \texttt{destination.name} property.

\begin{verbatim}
@Component(
    immediate = true,
    property = {"destination.name=myCustom/Destination"},
    service = DestinationEventListener.class
)
public class MyDestinationEventListener implements DestinationEventListener {

    void messageListenerRegistered(String destinationName,
                                   MessageListener messageListener) {
        ...
    }

    void messageListenerUnregistered(String destinationName,
                                   MessageListener messageListener) {
        ...
    }
}
\end{verbatim}

And that's how you listen for new destinations and message listeners.

Now you understand the different destination types, how to create and
register destinations, and how to manage destination resources. Once you
deploy your destination, registered message listeners receive messages
sent to it.

\subsection{Related Topics}\label{related-topics-223}

\href{/docs/7-0/tutorials/-/knowledge_base/t/message-listeners}{Message
Listeners}

\href{/docs/7-0/tutorials/-/knowledge_base/t/sending-messages}{Sending
Messages}

\section{Message Listeners}\label{message-listeners}

If you're interested in messages sent to a destination, you need to
``listen'' for them. That is, you must create and register a message
listener for the destination.

To create a message listener, implement the
\href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/messaging/MessageListener.html}{\texttt{MessageListener}
interface} and override its \texttt{receive(Message)} method to process
messages your way.

\begin{verbatim}
public void receive(Message message) {
    // Process messages your way
}
\end{verbatim}

Here are the ways to register your listener with Message Bus:

\begin{itemize}
\item
  \textbf{Automatic Registration as a Component}: Publish the listener
  to the OSGi registry as a Declarative Services Component that
  specifies a destination. Message Bus automatically wires the listener
  to the destination.
\item
  \textbf{Registering via MessageBus}: Obtain a reference to the Message
  Bus and use it directly to register the listener to a destination.
\item
  \textbf{Registering directly to a Destination}: Obtain a reference to
  a specific destination and use it directly to register the listener
  with that destination.
\end{itemize}

\noindent\hrulefill

\textbf{Note}: The
\href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/messaging/DestinationNames.html}{\texttt{DestinationNames}
class} defines \texttt{String} constants for Liferay's preconfigured
destinations.

\noindent\hrulefill

The Declarative Services component module provides the easiest way to
register a message listener.

\subsection{Automatic Registration as a
Component}\label{automatic-registration-as-a-component}

You can specify a message listener in the Declarative Services (DS)
\texttt{@Component} annotation:

\begin{verbatim}
@Component (
    immediate = true,
    property = {"destination.name=myCustom/Destination"},
    service = MessageListener.class
)
public class MyMessageListener implements MessageListener {
   ...

   public void receive(Message message) {
       // Handle the message
   }
}
\end{verbatim}

The Message Bus listens for \texttt{MessageListener} service components
like this one to publish themselves to the OSGi service registry. The
attribute \texttt{immediate\ =\ true} tells the OSGi framework to
activate the component as soon as its dependencies resolve. Message Bus
wires each registered listener to the destination its
\texttt{destination.name} property specifies. If the destination is not
yet registered, Message Bus queues the listener until the destination
registers.

Registration as a component is the preferred way to register message
listeners to destinations.

\subsection{Registering via
MessageBus}\label{registering-via-messagebus}

You can use the
\href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/messaging/MessageBus.html}{\texttt{MessageBus}
instance} directly to register message listeners to destinations. You
might want to do this if, for example, you want to create some special
proxy wrappers. Here's a registrator that demonstrates registering a
listener this way:

\begin{verbatim}
@Component (
    immediate = true,
    service = MyMessageListenerRegistrator.class
)
public class MyMessageListenerRegistrator {
    ...

    @Activate
    protected void activate() {

        _messageListener = new MessageListener() {

            public void receive(Message message) {
                // Handle the message
            }
        };

        _messageBus.registerMessageListener("myDestinationName",  
            _messageListener);
    }

    @Deactivate
    protected void deactivate() {
        _messageBus.unregisterMessageListener("myDestinationName",  
            _messageListener);
    }

    @Reference
    private MessageBus _messageBus;

    private MessageListener _messageListener;
}
\end{verbatim}

The \texttt{\_messageBus} field's \texttt{@Reference} annotation binds
it to the \texttt{MessageBus} instance. The \texttt{activate} method
creates the listener and uses the Message Bus to register the listener
to a destination named \texttt{"myDestination"}. When this registrator
component is destroyed, the \texttt{deactivate} method unregisters the
listener.

\subsection{Registering directly to the
Destination}\label{registering-directly-to-the-destination}

You can use a \texttt{Destination} instance to register a listener to
that destination. You might want to do this if, for example, you want to
create some special proxy wrappers. Here's a registrator that
demonstrates registering a listener this way:

\begin{verbatim}
@Component (
    immediate = true,
    service = MyMessageListenerRegistrator.class
)
public class MyMessageListenerRegistrator {
   ...

    @Activate
    protected void activate() {

        _messageListener = new MessageListener() {

            public void receive(Message message) {
                // Handle the message
            }
        };

        _destination.register(_messageListener);
    }

    @Deactivate
    protected void deactivate() {

        _destination.unregister(_messageListener);
    }

    @Reference(target = "(destination.name=someDestination)")
    private Destination _destination;

    private MessageListener _messageListener;
}
\end{verbatim}

The \texttt{\_destination} field's \texttt{@Reference} annotation binds
it to a destination named \texttt{"someDestination"}. The
\texttt{activate} method creates the listener and registers it to the
destination. When this registrator component is destroyed, the
\texttt{deactivate} method unregisters the listener.

Now you know how to create and register message listeners for receiving
messages sent to the destinations.

\subsection{Related Topics}\label{related-topics-224}

\href{/docs/7-0/tutorials/-/knowledge_base/t/messaging-destinations}{Messaging
Destinations}

\href{/docs/7-0/tutorials/-/knowledge_base/t/sending-messages}{Sending
Messages}

\section{Sending Messages}\label{sending-messages}

Message Bus lets you send messages to destinations that have any number
of listening classes. As a message sender you don't need to know the
message recipients. Instead, you focus on creating message content
(payload) and sending messages to destinations.

You can also send messages in a synchronous or asynchronous manner. The
synchronous option waits for a response that the message was received or
that it timed out. The asynchronous option gives you the ``fire and
forget'' behavior; send the message and continue processing without
waiting for a response.

Here are the message sending topics:

\begin{itemize}
\tightlist
\item
  \hyperref[creating-a-message]{Creating a message}
\item
  \hyperref[sending-a-message]{Sending a message} (the way you want)
\item
  \hyperref[sending-messages-across-the-cluster]{Sending messages across
  a cluster}
\end{itemize}

Start by creating a message.

\subsection{Creating a Message}\label{creating-a-message}

Here's how to create a message:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Call the
  \href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/messaging/Message.html}{\texttt{Message}
  constructor}.

  \texttt{Message\ message\ =\ new\ Message();}
\item
  Populate the message with a \texttt{String} or \texttt{Object} payload

  \begin{itemize}
  \item
    String payload:
    \texttt{message.setPayload("Message\ Bus\ is\ great!")}
  \item
    Object payload: \texttt{message.put("firstName",\ "Joe")}
  \end{itemize}
\item
  To receive responses at a particular location, set both of these
  attributes

  \begin{itemize}
  \item
    Response destination name:
    \texttt{setResponseDestinationName(String)}
  \item
    Response ID: \texttt{setResponseId(String)}
  \end{itemize}
\end{enumerate}

Your new message is ready to send.

\subsection{Sending a Message}\label{sending-a-message}

Here are the ways to send a message:

\begin{itemize}
\tightlist
\item
  \hyperref[directly-using-the-message-bus]{Directly using the
  \texttt{MessageBus}}
\item
  \hyperref[using-singledestinationmessagesender]{Asynchronously using a
  \texttt{SingleDestinationMessageSender}}
\item
  \hyperref[using-a-synchronousmessagesender]{Using a
  \texttt{SynchronousMessageSender}}
\end{itemize}

First, let's consider using Message Bus directly.

\subsubsection{Directly Using the Message
Bus}\label{directly-using-the-message-bus}

This method involves obtaining a
\href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/messaging/MessageBus.html}{\texttt{MessageBus}
instance} and invoking it to send messages. Here's an example of
directly using Message Bus to send a message.

\begin{verbatim}
@Component(
    immediate = true,
    service = SomeServiceImpl.class
)
public class SomeServiceImpl {
    ...

    public void sendSomeMessage() {

        Message message = new Message();
        message.put("myId", 12345);
        message.put("someAttribute", "abcdef");
        _messageBus.sendMessage("myDestinationName", message);
    }

    @Reference
    private MessageBus _messageBus;
}
\end{verbatim}

To send messages asynchronously, consider using
\texttt{SingleDestinationMessageSender}.

\subsubsection{Using
SingleDestinationMessageSender}\label{using-singledestinationmessagesender}

The
\href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/messaging/sender/SingleDestinationMessageSender.html}{\texttt{SingleDestinationMessageSender}
class} wraps the Message Bus to send messages asynchronously. This class
demonstrates using a \texttt{SingleDestinationMessageSender}:

\begin{verbatim}
@Component(
    immediate = true,
    service = SomeServiceImpl.class
)
public class SomeServiceImpl {
    ...

    public void sendSomeMessage() {

        Message message = new Message();
        message.put("myId", 12345);
        message.put("someValue", "abcdef");

        SingleDestinationMessageSender messageSender = 
           _messageSenderFactory.createSingleDestinationMessageSender("myDestinationName");

        messageSender.send(message);
    }

    @Reference
    private SingleDestinationMessageSenderFactory _messageSenderFactory;
}
\end{verbatim}

The \texttt{\_messageSenderFactory} field's \texttt{@Reference} wires it
to a \texttt{SingleDestinationMessageSenderFactory} instance. The method
\texttt{sendSomeMessage} creates a message, uses the
\texttt{\_messageSenderFactory} to create a
\texttt{SingleDestinationMessageSender} for the specified destination,
and sends the message through the sender.

\subsubsection{Using a
SynchronousMessageSender}\label{using-a-synchronousmessagesender}

A
\href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/messaging/sender/SynchronousMessageSender.html}{\texttt{SynchronousMessageSender}
instance} sends a message to the Message Bus and blocks until receiving
a response or the response times out. A
\texttt{SynchronousMessageSender} has these
\href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/messaging/sender/SynchronousMessageSender.Mode.html}{operating
modes}:

\begin{itemize}
\item
  \texttt{DEFAULT}: Delivers the message in a separate thread and also
  provides timeouts, in case the message is not delivered properly.
\item
  \texttt{DIRECT}: Delivers the message in the same thread of execution
  and blocks until it receives a response.
\end{itemize}

Here's an example of using \texttt{SynchronousMessageSender} in
\texttt{DEFAULT} mode.

\begin{verbatim}
@Component(
    immediate = true,
    service = SomeServiceImpl.class
)
public class SomeServiceImpl {
    ...

    public void sendSomeMessage() {

        Message message = new Message();
        message.put("myId", 12345);
        message.put("someAttribute", "abcdef");

        SingleDestinationSynchronousMessageSender messageSender = 
            _messageSenderFactory.createSingleDestinationSynchronousMessageSender(
                "myDestinationName", SynchronousMessageSender.Mode.DEFAULT);

        messageSender.send(message);

    }

    @Reference
    private SingleDestinationMessageSenderFactory _messageSenderFactory;
}
\end{verbatim}

And those are the ways to send messages. Next, if you're in a cluster
and want messages sent to a destination across all nodes, you must
register a bridge message listener to that destination.

\subsection{Sending Messages Across the
Cluster}\label{sending-messages-across-the-cluster}

To ensure a message sent to a destination is received by all cluster
nodes, you must register a
\href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/cluster/messaging/ClusterBridgeMessageListener.html}{\texttt{ClusterBridgeMessageListener}}
at that destination. This bridges the local destination to the cluster.

Here's a message listener registrator that bridges a destination for
distributing messages to all the cluster nodes.

\begin{verbatim}
@Component(
    immediate = true,
    service = MyMessageListenerRegistrator.class
)
public class MyMessageListenerRegistrator {
    ...

    @Activate
    protected void activate() {

        _clusterBridgeMessageListener = new ClusterBridgeMessageListener();
        _clusterBridgeMessageListener.setPriority(Priority.LEVEL_5)
        _destination.register(_clusterBridgeMessageListener);
    }

    @Deactivate
    protected void deactivate() {

        _destination.unregister(_clusterBridgeMessageListener );
    }

    @Reference(target = "(destination.name=liferay/live_users)")
    private Destination _destination;

    private MessageListener _clusterBridgeMessageListener;
}
\end{verbatim}

The destination named \texttt{"liferay/live\_users"} is bound to the
\texttt{\_destination} field. The \texttt{activate} method creates a
\texttt{ClusterBridgeMessageListener}, sets its priority queue, and
registers it to the destination. Messages sent to the destination are
distributed across the cluster's JVMs.

The
\href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/cluster/Priority.html}{\texttt{com.liferay.portal.kernel.cluster.Priority}
class} has ten levels (\texttt{Level\_1} through \texttt{Level\_10},
with \texttt{Level\ 10} being the most important). Each level is a
priority queue for sending messages through the cluster. This is similar
in concept to thread priorities: \texttt{Thread.MIN\_PRIORITY},
\texttt{Thread.MAX\_PRIORITY}, and \texttt{Thread.NORM\_PRIORITY}.

That concludes the tour on sending messages. You've learned how to
create messages, send messages synchronously and asynchronously, and
send messages to a destination in a clustered environment.

\subsection{Related Topics}\label{related-topics-225}

\href{/docs/7-0/tutorials/-/knowledge_base/t/messaging-destinations}{Messaging
Destinations}

\href{/docs/7-0/tutorials/-/knowledge_base/t/message-listeners}{Message
Listeners}

\chapter{Audience Targeting}\label{audience-targeting}

Liferay's Audience Targeting application lets you monitor your users.
You can organize them into user segments, target specific content to
those user segments, and create campaigns to expose user segments to a
certain set of assets. Visit the
\href{/docs/7-0/user/-/knowledge_base/u/targeting-content-to-your-audience}{Targeting
Content to your Audience} section for more information on Audience
Targeting and how to use it.

Although the Audience Targeting app can be configured to monitor your
audience out of the box, it is also designed as a framework to be
extended by developers.

There are a set of extensions that can be easily hooked by creating
other hot-deployable plugins.

These extension points include

\begin{itemize}
\tightlist
\item
  Rule Types
\item
  Report Types
\item
  Report Metrics
\end{itemize}

Audience Targeting extensions are created using OSGi modules. There are
convenient Blade CLI templates for creating these projects, but you can
create the modules any way you want. To use the templates, see the
\href{/docs/7-0/tutorials/-/knowledge_base/t/blade-cli}{Blade CLI
tutorials}.

In this section's tutorials, you'll learn how to create these extension
points for your Audience Targeting application.

\section{Accessing the Content Targeting
API}\label{accessing-the-content-targeting-api}

The
\href{https://www.liferay.com/marketplace/-/mp/application/43707761}{Audience
Targeting} application can be used to show relevant content to users
based on profiles. You might want to take the next step and use the
Content Targeting API. For instance, you could list user segments in
your own application or update a campaign when someone creates a
calendar event. Using the Content Targeting API, you can unleash the
power of Audience Targeting to the realms outside of Liferay's default
applications.

In this tutorial, you'll learn how to give your application access to
the Content Targeting API. Then you can view some examples of how to use
the Java and JSON APIs that are available.

\subsection{Exposing the Content Targeting
API}\label{exposing-the-content-targeting-api}

Configuring your app to have access to the Content Targeting API
requires only one line of code. This line of code is a dependency that
should be added to your Gradle project. Follow the instructions below to
add the Content Targeting API dependency.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open the \texttt{build.gradle} file in your app's project folder.
\item
  Find the \texttt{dependencies} declaration and add the following line
  within that declaration:

\begin{verbatim}
 provided group: "com.liferay.content-targeting", name: "com.liferay.content.targeting.api", version: "4.0.0"
\end{verbatim}

  The complete declaration should look like this:

\begin{verbatim}
 dependencies {
     ...
     provided group: "com.liferay.content-targeting", name: "com.liferay.content.targeting.api", version: "4.0.0"
 }
\end{verbatim}
\end{enumerate}

Your app now has access to the Content Targeting API and can take
advantage of everything Audience Targeting has to offer. In the next
section, you'll learn how to use the Content Targeting API by studying a
few examples.

\subsection{Using the Content Targeting Java
API}\label{using-the-content-targeting-java-api}

There are two ways to call the Content Targeting API: through the Java
API or through the JSON API.

Suppose you'd like to display a list of existing user segments in your
portlet. First you need to obtain an implementation of the
\texttt{UserSegmentLocalService} provided by Audience Targeting. You can
do this by adding the following code to your Portlet class (e.g., the
class that extends the \texttt{MVCPortlet} class):

\begin{verbatim}
@Reference(unbind = "-")
protected void setUserSegmentLocalService(
    UserSegmentLocalService userSegmentLocalService) {

    _userSegmentLocalService = userSegmentLocalService;
}

private UserSegmentLocalService _userSegmentLocalService;
\end{verbatim}

When an implementation of the \texttt{UserSegmentLocalService} is
available (i.e., the Audience Targeting app has been installed) the
\texttt{\_userSegmentLocalService} field is populated. Otherwise, the
portlet won't be available till this dependency is resolved.

It's a good practice to access Audience Targeting services this way
instead of using util classes (e.g.,
\texttt{UserSegmentLocalServiceUtil.java}). You can take advantage of
dependency management, and you also won't be tied to a specific
implementation of the service.

The next step is to use the service to obtain a list of existing user
segments and make it available to your view layer as a request
attribute. To do this, add logic to your portlet class that obtains user
segments and exposes them as a request attribute, like this:

\begin{verbatim}
ThemeDisplay themeDisplay = (ThemeDisplay)renderRequest.getAttribute(
    WebKeys.THEME_DISPLAY);

List<UserSegment> userSegments = null;

try {
    userSegments = _userSegmentLocalService.getUserSegments(
        themeDisplay.getScopeGroupId());
}
catch (Exception e) {
    _log.error(e, e);
}

renderRequest.setAttribute("userSegments", userSegments);

private static final Log _log = LogFactoryUtil.getLog(MyPortlet.class)
\end{verbatim}

Notice that the \texttt{userSegments} list is populated by calling
\texttt{UserSegmentLocalService}'s \texttt{getUserSegments} method. This
service is part of the Content Targeting API.

To finish off this example, some logic needs to be added to your
portlet's \texttt{view.jsp}:

\begin{verbatim}
<h2>User Segments</h2>

<ul>

<%
List<UserSegment> userSegments = (List<UserSegment>)request.getAttribute("userSegments");

for (UserSegment userSegment : userSegments) {
%>

    <li><%= userSegment.getName(locale) %></li>

<%
}
%>

</ul>
\end{verbatim}

This logic uses the \texttt{UserSegment} object to list the existing
user segments. That's it! By importing the \texttt{UserSegment} and
\texttt{UserSegmentLocalService} classes into your files, you have
direct access to your portal's user segments through the Content
Targeting Java API.

\subsection{Using the Content Targeting JSON
API}\label{using-the-content-targeting-json-api}

Suppose you'd like to show a list of existing campaigns in your portlet
using the JSON API. You could do this by opening your portlet's
\texttt{view.jsp} file and using the following code:

\begin{verbatim}
<h2>Campaigns</h2>

<ul id="<portlet:namespace/>campaigns">
</ul>

<aui:script use="aui-base">
    var campaignsList = A.one('#<portlet:namespace/>campaigns');

    Liferay.Service(
        '/ct.campaign/get-campaigns',
        {
        groupId: '<%= scopeGroupId %>'
        },
        function(response) {
            if (response.length) {
                A.Array.each(response, function(item) {
                    campaignsList.append('<li>' + item.name + '</li>');
                });
            }
        }
    );
</aui:script>
\end{verbatim}

Notice that the Content Targeting API is called to retrieve the existing
campaigns:

\begin{verbatim}
...
Liferay.Service(
    '/ct.campaign/get-campaigns',
    {
...
\end{verbatim}

Then, each campaign is listed in the \texttt{campaignsList} and
displayed in your portlet for users to see.

If you'd like to view all the available methods (with examples) exposed
in the JSON API by Audience Targeting, you can visit the
\texttt{/api/jsonws} URL (e.g., \texttt{localhost:8080/api/jsonws}). As
you can see, accessing the Content Targeting JSON API is just as easy as
accessing the related Java API.

You've learned how easy it is to expose the Content Targeting API and
use it in your application to unleash its power!

\subsection{Related Topics}\label{related-topics-226}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-new-audience-targeting-rule-types}{Creating
New Audience Rule Types}

\href{/docs/7-0/user/-/knowledge_base/u/targeting-content-to-your-audience}{Targeting
Content to Your Audience}

\href{/docs/7-0/tutorials/-/knowledge_base/t/running-service-builder-and-understanding-the-generated-code}{Running
Service Builder and Understanding the Generated Code}

\section{Creating New Audience Targeting Rule
Types}\label{creating-new-audience-targeting-rule-types}

In the Audience Targeting application, a User Segment is defined as a
group of users that match a set of rules. Out of the box, Liferay
provides several types of rules that are based on characteristics such
as age range, gender, location, and so on. You combine these rules to
create User Segments. For example, if you want to target probable buyers
of a shoe that has a particular style, you might create a User Segment
composed of Females over 40 who live in urban areas.

The Audience Targeting app ships with many rules you can use make up
User Segments, but it's also extensible. This means that if there isn't
a rule that already fits your case, you can create it yourself!

Creating a rule type involves targeting what you want to evaluate.
Suppose you own an Outdoor Sporting Goods store. On your website, you'd
like to promote goods that are appropriate for the current weather. If a
user is from Los Angeles and it's raining the day he or she visits your
website, you could show that user new umbrellas. If it's sunny, however,
you could show the user sunglasses instead. For this example, your
evaluation entity would be weather based on the user's location. To make
this work, you'll need to do two things:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Retrieve the user's location so you can obtain that location's
  weather.
\item
  Let administrators set the value that should be compared with the
  user's current weather, using a UI component like a selection list of
  weather options.
\end{enumerate}

With this design, an administrator can set \emph{rainy} as the value for
the rule, and the rule could be added to a user segment targeted for
rain-related goods. When users visit your site, their user segment
assignments come from matching the weather in their current locations
with the rule's preset weather value (rainy). On a match, you show
rain-related content; otherwise, the user is part of a different User
Segment and sees that segment's content, like a promotion for
sunglasses.

\begin{figure}
\centering
\includegraphics{./images-dxp/weather-rule-diagram.png}
\caption{This diagram breaks down the evaluation process for the weather
rule.}
\end{figure}

Now that you have an idea of how to plan your custom rule's development,
you'll begin creating one yourself!

\subsection{Creating a Custom Rule
Type}\label{creating-a-custom-rule-type}

Adding a new type of rule to the Audience Targeting application is easy.
First, you must create a module and ensure it has the necessary Content
Targeting API dependencies.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/starting-module-development\#creating-a-module}{Create
  a module} project for deploying a rule. A Blade CLI
  \href{/docs/7-0/reference/-/knowledge_base/r/content-targeting-rule-template}{content-targeting-rule}
  template is available to help you get started quickly. It sets the
  default configuration for you, and it contains boilerplate code so you
  can skip the file creation steps and get started right away.
\item
  Make sure your module specifies the dependencies necessary for an
  Audience Targeting rule. For example, you should specify the Content
  Targeting API and necessary Liferay packages. For example, this is the
  example \texttt{build.gradle} file used from a Gradle based rule:

\begin{verbatim}
dependencies {
    compileOnly group: "com.liferay.content-targeting", name: "com.liferay.content.targeting.analytics.api", version: "3.0.0"
    compileOnly group: "com.liferay.content-targeting", name: "com.liferay.content.targeting.anonymous.users.api", version: "2.0.2"
    compileOnly group: "com.liferay.content-targeting", name: "com.liferay.content.targeting.api", version: "4.0.0"
    compileOnly group: "com.liferay.portal", name: "com.liferay.portal.kernel", version: "2.3.0"
    compileOnly group: "com.liferay.portal", name: "com.liferay.util.taglib", version: "2.0.0"
    compileOnly group: "javax.portlet", name: "portlet-api", version: "2.0"
    compileOnly group: "javax.servlet", name: "javax.servlet-api", version: "3.0.1"
    compileOnly group: "org.osgi", name: "org.osgi.service.component.annotations", version: "1.3.0"
}
\end{verbatim}

  You can learn more about exposing the Content Targeting API in the
  \href{/docs/7-0/tutorials/-/knowledge_base/t/accessing-the-content-targeting-api}{Accessing
  the Content Targeting API} tutorial. Once you've created your module
  and specified its dependencies, you'll need to define your rule's
  behavior. How your rule behaves is controlled by a Java class file
  that you create.
\item
  Create a unique package name in the module's \texttt{src} directory,
  and create a new Java class in that package. To follow naming
  conventions, your class name should begin with the rule name you're
  creating, and end with \emph{Rule} (e.g., \texttt{WeatherRule.java}).
  Your Java class should implement the
  \href{@app-ref@/content-targeting/2.0.0/javadocs/com/liferay/content/targeting/api/model/Rule.html}{\texttt{com.liferay.content.targeting.api.model.Rule}
  interface}.

  It is required to implement the
  \href{@app-ref@/content-targeting/2.0.0/javadocs/com/liferay/content/targeting/api/model/Rule.html}{Rule}
  interface, but there are \texttt{Rule} extension classes that provide
  helpful utilities that you can extend. For example, your rule can
  extend the
  \href{@app-ref@/content-targeting/2.0.0/javadocs/com/liferay/content/targeting/api/model/BaseJSPRule.html}{BaseJSPRule}
  class to support generating your rule's UI using JSPs. This tutorial
  demonstrates implementing the UI using a JSP, and assumes the
  \texttt{Rule} interface is implemented by extending the
  \texttt{BaseJSPRule} class. For more information on choosing a UI for
  your rule, see the
  \href{/docs/7-0/tutorials/-/knowledge_base/t/best-practices-for-rules\#selecting-a-ui-technology}{Selecting
  a UI Technology} section.
\item
  Directly above the class's declaration, insert the following code:

\begin{verbatim}
@Component(immediate = true, service = Rule.class)
\end{verbatim}

  This annotation declares the implementation class of the Component and
  specifies to immediately start the module once deployed to Liferay
  DXP.
\end{enumerate}

Now that your Java class is set up, you'll need to define how your rule
works by implementing the
\href{@app-ref@/content-targeting/2.0.0/javadocs/com/liferay/content/targeting/api/model/Rule.html}{Rule}
interface's methods. You'll begin implementing these methods next.

\noindent\hrulefill

\textbf{Note:} If you're planning on developing a social rule type that
classifies users based on their social network profile, it's important
to remember that the specific social network's SSO (Single Sign On) must
be enabled and configured properly. Visit the
\href{/docs/7-0/user/-/knowledge_base/u/liferay-audience-targeting-rules\#social-rules}{Social
Rules} section for more details.

\noindent\hrulefill

The first thing you'll define in your weather rule is the view/save
lifecycle.

\subsection{Defining a Rule's View/Save
Lifecycle}\label{defining-a-rules-viewsave-lifecycle}

This section covers how to define a rule's view/save lifecycle. This is
when a user applies a rule to a user segment using the User Segment
Editor.

In this section, you'll begin defining the weather rule's Java class.
This assumes that you followed the instructions above, creating the
\texttt{WeatherRule} class and extending
\href{@app-ref@/content-targeting/2.0.0/javadocs/com/liferay/content/targeting/api/model/BaseJSPRule.html}{BaseJSPRule}.
If you used the \texttt{content-targeting-rule} Blade CLI template, your
project is already extending \texttt{BaseJSPRule} and has a default
\texttt{view.jsp} file already created.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add the activation and deactivation methods to your class.

\begin{verbatim}
@Activate
@Override
public void activate() {
    super.activate();
}

@Deactivate
@Override
public void deActivate() {
    super.deActivate();
}
\end{verbatim}

  These methods call the super class
  \href{@app-ref@/content-targeting/2.0.0/javadocs/com/liferay/content/targeting/api/model/BaseRule.html}{BaseRule}
  to implement necessary logging and processing for when your rule
  starts and stops. Make sure to include the
  \href{https://osgi.org/javadoc/r6/cmpn/org/osgi/service/component/annotations/Activate.html}{@Activate}
  and
  \href{https://osgi.org/javadoc/r6/cmpn/org/osgi/service/component/annotations/Deactivate.html}{@Deactivate}
  annotations, which are required.
\item
  Define the category for the Rule when displayed in the User Segment
  Editor.

\begin{verbatim}
@Override
public String getRuleCategoryKey() {
    return SessionAttributesRuleCategory.KEY;
}
\end{verbatim}

  This code puts the weather rule in the Session Attributes category. To
  put your rule into the appropriate category, use the
  \texttt{getRuleCategoryKey} method to return the category class's key.
  Available category classes include
  \href{@app-ref@/content-targeting/2.0.0/javadocs/com/liferay/content/targeting/rule/categories/BehaviorRuleCategory.html}{BehaviourRuleCategory},
  \href{@app-ref@/content-targeting/2.0.0/javadocs/com/liferay/content/targeting/rule/categories/SessionAttributesRuleCategory.html}{SessionAttributesRuleCategory},
  \href{@app-ref@/content-targeting/2.0.0/javadocs/com/liferay/content/targeting/rule/categories/SocialRuleCategory.html}{SocialRuleCategory},
  and
  \href{@app-ref@/content-targeting/2.0.0/javadocs/com/liferay/content/targeting/rule/categories/UserAttributesRuleCategory.html}{UserAttributesRoleCategory}.

  \begin{figure}
  \centering
  \includegraphics{./images-dxp/new-category-rule.png}
  \caption{This example Weather rule was modified to reside in the
  Session Attributes category.}
  \end{figure}
\item
  Add the following method:

\begin{verbatim}
@Override
protected void populateContext(
    RuleInstance ruleInstance, Map<String, Object> context,
    Map<String, String> values) {

    String weather = "";

    if (!values.isEmpty()) {
        weather = GetterUtil.getString(values.get("weather"));
    }
    else if (ruleInstance != null) {
        weather = ruleInstance.getTypeSettings();
    }

    context.put("weather", weather);
}
\end{verbatim}

  To understand what this method accomplishes, you'll need to examine
  the rule's configuration lifecycle.

  \begin{figure}
  \centering
  \includegraphics{./images-dxp/rule-lifecycle.png}
  \caption{An Audience Targeting rule must be configured by the user and
  processed before it can become part of a User Segment.}
  \end{figure}

  When the user opens the User Segment Editor, the render phase begins
  for the rule. The \texttt{getFormHTML(...)} method retrieves the HTML
  to display. You don't have to worry about implementing this method
  because it's already implemented in the
  \href{@app-ref@/content-targeting/2.0.0/javadocs/com/liferay/content/targeting/api/model/BaseJSPRule.html}{BaseJSPRule}
  class you're extending. The \texttt{getFormHTML} method calls the
  \texttt{populateContext(...)} method.

  You'll notice the \texttt{populateContext} method is not available in
  the
  \href{@app-ref@/content-targeting/2.0.0/javadocs/com/liferay/content/targeting/api/model/Rule.html}{Rule}
  interface. This is because it's not needed in all cases. It's
  available by extending the
  \href{@app-ref@/content-targeting/2.0.0/javadocs/com/liferay/content/targeting/api/model/BaseJSPRule.html}{BaseJSPRule}
  class, and you'll need to add more logic to it for the weather rule.

  The goal of the \texttt{populateContext} method is to generate a map
  with all the parameters your JSP view needs to render the rule's HTML.
  This map is stored in the \texttt{context} variable, which is
  pre-populated with basic values in the Portlet logic, and then each
  rule contributes its specific parameters to it. The
  \texttt{populateContext} method above populates a \texttt{weather}
  context variable with the \texttt{weather} values from the
  \texttt{values} map parameter, which is then passed to the JSP.

  For the weather rule, the \texttt{populateContext} method accounts for
  three use cases:

  \begin{enumerate}
  \def\labelenumii{\alph{enumii}.}
  \item
    The rule was added but has no set values yet. In this case, the
    default values defined by the developer are injected (e.g.,
    \texttt{weather=""}).
  \item
    The rule was added and a value is set, but the request failed to
    complete (e.g., due to an error). In this case, the \texttt{values}
    parameter of the \texttt{populateContext} method contains the values
    that were intended to be saved, and they are injected so that they
    are displayed in the rule's view together with the error message.
  \item
    The rule was added and a value was successfully set. In this case,
    the \texttt{values} parameter is empty, and you have to obtain the
    values from storage that the form should display and inject them in
    the context so they're displayed in the rule's HTML. The weather
    rule uses the \texttt{typeSettings} field of the rule instance, but
    complex rules could use services to store values.
  \end{enumerate}

  You can think of the \texttt{populateContext} method as the
  intermediary between your JSP and your backend code. You can see how
  to create the weather rule's UI using a JSP by seeing the
  \href{/docs/7-0/tutorials/-/knowledge_base/t/creating-new-audience-targeting-rule-types\#defining-the-rules-ui}{Defining
  the Rule's UI} section. Once the HTML is successfully retrieved and
  the user has set the weather value and clicked \emph{Save}, the action
  phase begins.
\item
  Add the following method:

\begin{verbatim}
@Override
public String processRule(
    PortletRequest portletRequest, PortletResponse portletResponse,
    String id, Map<String, String> values) {

    return values.get("weather");
}
\end{verbatim}

  The \texttt{processRule(...)} method is invoked when the action phase
  is initiated. The \texttt{values} parameter only contains the value(s)
  the user added in the form. The logic you could add to a
  \texttt{processRule} method is outlined below.

  \begin{enumerate}
  \def\labelenumii{\alph{enumii}.}
  \item
    Obtain the value(s) from the \texttt{values} parameter.
  \item
    (Optional) Validate the data consistency and possible errors. If
    anything is wrong, throw an
    \href{@app-ref@/content-targeting/2.0.0/javadocs/com/liferay/content/targeting/exception/InvalidRuleException.html}{InvalidRuleException}
    and prohibit the values from being stored. In the weather rule
    scenario, when the rule is reloaded after an exception is thrown in
    the form, case 3b from the previous step occurs.
  \item
    Return the value to be stored in the rule instance's
    \texttt{typeSettings} field. The \texttt{typeSettings} field is
    managed by the framework in the Rule Instance table. If your rule
    has its own storage mechanism, then you should call your services in
    the \texttt{processRule} method.
  \end{enumerate}

  Once the rule processing ends, the form is reloaded and the lifecycle
  restarts again. The value(s) selected in the rule are stored and are
  ready to be accessed once user segment evaluation begins. There are a
  couple more methods you'll need to add to the \texttt{WeatherRule}
  class before defining the rule's evaluation.
\item
  Define a way to retrieve the rule's localized summary. In many
  instances, you can do this by combining keys in the rule's resource
  bundle with the information stored for the rule. For the weather rule,
  you can return the rule's type settings, which contains the selected
  weather condition.

\begin{verbatim}
@Override
public String getSummary(RuleInstance ruleInstance, Locale locale) {
    return ruleInstance.getTypeSettings();
}
\end{verbatim}
\item
  Set the servlet context for your rule.

\begin{verbatim}
@Override
@Reference(
    target = "(osgi.web.symbolicname=weather)",
    unbind = "-"
)
public void setServletContext(ServletContext servletContext) {
    super.setServletContext(servletContext);
}
\end{verbatim}

  This is only required for rules extending the
  \href{@app-ref@/content-targeting/2.0.0/javadocs/com/liferay/content/targeting/api/model/BaseJSPRule.html}{BaseJSPRule}
  class. The servlet context must be set for the rule to render its own
  JSP files. The \texttt{setServletContext} method is invoked
  automatically when the rule module is installed and resolved in
  Liferay. Make sure the \texttt{osgi.web.symbolicname} in the
  \texttt{target} property of the \texttt{@Reference} annotation is set
  to the same value as the \texttt{Bundle-SymbolicName} defined in the
  \texttt{bnd.bnd} file of the module.
\end{enumerate}

Next, you'll learn how to evaluate a rule that is configured and saved
to a user segment.

\subsection{Evaluating a Rule}\label{evaluating-a-rule}

Imagine an administrator has successfully configured and saved your
custom rule to his or her user segment. Now what? Your rule needs to
fulfill its purpose, which is to evaluate the preset weather value
compared to a user's weather value visiting the site. If the user's
value matches the preset value (along with the segment's other rules),
that user is added to the user segment.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  You must implement the \texttt{evaluate(...)} rule to begin the
  evaluation process. This method is part of the user segmentation
  lifecycle. When a page is loaded, Liferay invokes the
  \texttt{evaluate} method of the rule to determine if the current user
  belongs to the user segment. For the weather rule, add this
  \texttt{evaluate} method:

\begin{verbatim}
@Override
public boolean evaluate(
        HttpServletRequest request, RuleInstance ruleInstance,
        AnonymousUser anonymousUser)
    throws Exception {

    String userWeather = getUserWeather(anonymousUser);

    String weather = ruleInstance.getTypeSettings();

    if (Validator.equals(userWeather, weather)) {
        return true;
    }

    return false;
}
\end{verbatim}

  You acquire the user's weather by calling the \texttt{getUserWeather}
  method, which you'll define later. Then you get the preset weather
  value by accessing the rule instance's \texttt{typeSettings}
  parameter. Finally, you compare the two values. If they match, return
  \texttt{true}; otherwise return \texttt{false}. Remember that users
  are only added to User Segments when all the Rules in the User Segment
  return true.
\item
  Next, you need to retrieve the user's weather. As you learned earlier,
  you must access the user's location first. Add the logic below to do
  this.

\begin{verbatim}
protected String getCityFromUserProfile(long contactId, long companyId)
    throws PortalException, SystemException {

    List<Address> addresses = AddressLocalServiceUtil.getAddresses(companyId, Contact.class.getName(), contactId);

    if (addresses.isEmpty()) {
        return null;
    }

    Address address = addresses.get(0);

    return address.getCity() + StringPool.COMMA + address.getCountry().getA2();
}
\end{verbatim}

  This method retrieves the location by accessing the user's profile
  information. You could also have used a geo-location service to find
  this by the user's IP address. Once you have the user's location, you
  can find the current weather for that location.
\item
  Add the following method to retrieve a user's weather forecast.

\begin{verbatim}
protected String getUserWeather(AnonymousUser anonymousUser)
    throws PortalException, SystemException {

    User user = anonymousUser.getUser();

    String city = getCityFromUserProfile(user.getContactId(), user.getCompanyId());

    Http.Options options = new Http.Options();

    String location = HttpUtil.addParameter(API_URL, "q", city);
    location = HttpUtil.addParameter(location, "format", "json");

    options.setLocation(location);

    int weatherCode = 0;

    try {
        String text = HttpUtil.URLtoString(options);

        JSONObject jsonObject = JSONFactoryUtil.createJSONObject(text);

        weatherCode = jsonObject.getJSONArray("weather").getJSONObject(0).getInt("id");
    }
    catch (Exception e) {
        _log.error(e);
    }

    return getWeatherFromCode(weatherCode);
}

private static Log _log = LogFactoryUtil.getLog(WeatherRule.class);
\end{verbatim}

  This method calls the \texttt{getCityFromUserProfile} method to
  acquire the user's location. Then it retrieves the weather code for
  that location from a weather service.
\item
  Set the \texttt{API\_URL} field to the Open Weather Map's API URL:

\begin{verbatim}
private static final String API_URL = "http://api.openweathermap.org/data/2.5/weather";
\end{verbatim}

  For the weather rule, you can access Open Weather Map's APIs to
  retrieve the weather code.
\item
  The last thing is to convert the weather code to a string you can
  evaluate (e.g., \texttt{sunny}). Add the following method to convert
  Open Weather Map's weather codes:

\begin{verbatim}
protected String getWeatherFromCode(int code) {
    if (code == 800 || code == 801) {
        return "sunny";
    }
    else if (code > 801 && code < 805) {
        return "clouds";
    }
    else if (code >= 600 && code < 622) {
        return "snow";
    }
    else if (code >= 500 && code < 532) {
        return "rain";
    }

    return null;
}
\end{verbatim}

  All possible weather codes are
  \href{http://openweathermap.org/weather-conditions}{here}.
\end{enumerate}

Excellent! You've implemented the \texttt{evaluate} method and added the
necessary logic in your \texttt{-Rule} class to acquire a user's local
weather. The weather rule's behavior is defined and complete. The last
thing you need to do is create a JSP template.

\subsection{Defining the Rule's UI}\label{defining-the-rules-ui}

The Java code you've added to this point has assumed that a preset
weather value is available for comparing during the evaluation process.
To let administrators set that value, you must define a UI so your rule
can be configured during the view/save lifecycle. Create a
\texttt{view.jsp} file in your rule's module (e.g.,
\texttt{/src/main/resources/META-INF/resources/view.jsp}) and add the
following logic:

\begin{verbatim}
<%
Map<String, Object> context = (Map<String, Object>)request.getAttribute("context");

String weather = (String)context.get("weather");
%>

<aui:fieldset>
    <aui:select name="weather" value="<%= weather %>">
        <aui:option label="sunny" value="sunny" />
        <aui:option label="clouds" value="clouds" />
        <aui:option label="snow" value="snow" />
        <aui:option label="rain" value="rain" />
    </aui:select>
</aui:fieldset>
\end{verbatim}

The \texttt{weather} variable in the \texttt{context} map should be set
for the weather rule. When the user selects an option, it's passed from
the view template to the \texttt{populateContext} method.

\begin{figure}
\centering
\includegraphics{./images-dxp/select-box-rule.png}
\caption{The weather rule uses a \texttt{select} drop-down box to set
the weather value.}
\end{figure}

\noindent\hrulefill

The weather rule uses JSP templates to display the rule's view. Audience
Targeting, however, is compatible with any UI technology. Visit the
\href{/docs/7-0/tutorials/-/knowledge_base/t/best-practices-for-rules\#selecting-a-ui-technology}{Selecting
a UI Technology} section for details on how to use other UI technologies
like FreeMarker.

\noindent\hrulefill

Congratulations! You've created the weather rule and can now target
users based on their weather conditions. You can view the finished
version of the weather rule by downloading its
\href{https://customer.liferay.com/documents/10738/200086/weather.zip}{ZIP
file}.

Now you've created and examined a fully functional rule and have the
knowledge to create your own.

\subsection{Related Topics}\label{related-topics-227}

\href{/docs/7-0/tutorials/-/knowledge_base/t/best-practices-for-rules}{Best
Practices for Rules}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-modules-with-blade-cli}{Creating
Modules with Blade CLI}

\href{/docs/7-0/tutorials/-/knowledge_base/t/internationalization}{Internationalization}

\href{/docs/7-0/tutorials/-/knowledge_base/t/service-builder-persistence}{Service
Builder Persistence}

\section{Tracking User Actions with Audience
Targeting}\label{tracking-user-actions-with-audience-targeting}

In the Audience Targeting (AT) application, a campaign defines a set of
content targeted to specific user segments during a time period.
Campaign custom reports allow campaign administrators to learn how users
behave in the context of a campaign by monitoring their interaction over
different elements of the site. Out of the box, Liferay provides several
metrics that are based on entity types that you can track, such as
content, forms, links, pages, etc. You can use these metrics to create
custom reports. For example, if you want track how many users watch a
YouTube video that is published on your site, you might create a custom
report with the YouTube Videos metric.

The AT app ships with many metrics you can apply to custom reports, but
it's also extensible. This means that if the default metrics available
do not fulfill your needs, you can create one yourself!

A metric's development strategy comes down to four choices:

\begin{itemize}
\tightlist
\item
  Entity to Track
\item
  Tracking Mechanism
\item
  Tracking Events
\item
  Differentiation Method
\end{itemize}

Creating a metric involves targeting what you want to track in a custom
report. Suppose you're the owner of a hardware store and you'd like to
send emails to your customers notifying them of the store's weekly
newsletter. You send the email every week, but you're in the dark about
how many customers actually open and read the newsletter. For this
example, your entity to track is a newsletter.

To track how many customers view the newsletter, you'll need to create a
tracking mechanism. You can provide a custom tracking mechanism (e.g., a
servlet) or you can use the ones provided by Audience Targeting. For a
newsletter, you could use a transparent image as the tracking mechanism,
which would have the \emph{View} tracking event capability. Whenever the
image is viewed, the Audience Targeting app computes and stores the
information.

In many cases, a metric can have multiple tracking event options. For
example, the YouTube Videos metric provides tracking event options like
Buffering, Playing, Paused, Ended, etc. This lets you track different
kinds of actions on an entity, providing a more accurate report on user
interactions.

Finally, you must assign the metric to an entity. For a newsletter, you
could provide a Newsletter ID field that the user could fill in to
differentiate newsletters, if there's more than one.

To learn more about how metrics are used in the Audience Targeting
application, visit the
\href{/docs/7-0/user/-/knowledge_base/u/managing-campaigns\#defining-metrics}{Defining
Metrics} section.

For this tutorial, you'll create a newsletter that can track who views
it. This process involves defining the view/save lifecycle, which is
when a user applies a metric to a report using the Report Editor. Then
you'll define its tracking mechanism, tracking event(s), and
differentiation method, similar to what was described above.

\begin{figure}
\centering
\includegraphics{./images-dxp/metric-template.png}
\caption{The sample Newsletter metric requires the newsletter name, ID,
and event type.}
\end{figure}

Now that you have an idea of how to plan your new metric, you'll begin
creating one next!

\subsection{Creating a Metric}\label{creating-a-metric}

Adding a new metric to the Audience Targeting application is easy.
First, you must create a module and ensure it has the necessary Content
Targeting API dependencies.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/starting-module-development\#creating-a-module}{Create
  a module} project for deploying a metric. A Blade CLI
  \href{/docs/7-0/reference/-/knowledge_base/r/content-targeting-tracking-action-template}{content-targeting-tracking-action}
  template is available to help you get started quickly. It sets the
  default configuration for you, and it contains boilerplate code so you
  can skip the file creation steps and get started right away.
\item
  Make sure your module specifies the dependencies necessary for an
  Audience Targeting metric. For example, you should specify the Content
  Targeting API and necessary Liferay packages. For example, this is the
  example \texttt{build.gradle} file used from a Gradle based metric:

\begin{verbatim}
dependencies {
    compileOnly group: "com.liferay.content-targeting", name: "com.liferay.content.targeting.analytics.api", version: "3.0.0"
    compileOnly group: "com.liferay.content-targeting", name: "com.liferay.content.targeting.anonymous.users.api", version: "2.0.2"
    compileOnly group: "com.liferay.content-targeting", name: "com.liferay.content.targeting.api", version: "4.0.0"
    compileOnly group: "com.liferay.portal", name: "com.liferay.portal.kernel", version: "2.3.0"
    compileOnly group: "com.liferay.portal", name: "com.liferay.util.taglib", version: "2.0.0"
    compileOnly group: "javax.portlet", name: "portlet-api", version: "2.0"
    compileOnly group: "javax.servlet", name: "javax.servlet-api", version: "3.0.1"
    compileOnly group: "org.osgi", name: "org.osgi.service.component.annotations", version: "1.3.0"
}
\end{verbatim}

  You can learn more about exposing the Content Targeting API in the
  \href{/docs/7-0/tutorials/-/knowledge_base/t/accessing-the-content-targeting-api}{Accessing
  the Content Targeting API} tutorial. Once you've created your module
  and specified its dependencies, you'll need to define your metric's
  behavior. How your metric behaves is controlled by a Java class file
  that you create.
\item
  Create a unique package name in the module's \texttt{src} directory,
  and create a new Java class in that package. To follow naming
  conventions, your class name should begin with the metric's name
  you're creating and end with \emph{TrackingAction} (e.g.,
  \texttt{NewsletterTrackingAction.java}). Your Java class should
  implement the
  \href{@app-ref@/content-targeting/2.0.0/javadocs/com/liferay/content/targeting/api/model/TrackingAction.html}{com.liferay.content.targeting.api.model.TrackingAction`
  interface}.

  You must implement the
  \href{@app-ref@/content-targeting/2.0.0/javadocs/com/liferay/content/targeting/api/model/TrackingAction.html}{TrackingAction}
  interface, but there are \texttt{TrackingAction} extension classes
  that provide helpful utilities that you can extend. For example, your
  metric can extend the
  \href{@app-ref@/content-targeting/2.0.0/javadocs/com/liferay/content/targeting/api/model/BaseJSPTrackingAction.html}{BaseJSPTrackingAction}
  class to support generating your metric's UI using JSPs. This tutorial
  demonstrates implementing the UI using a JSP and assumes the
  \href{@app-ref@/content-targeting/2.0.0/javadocs/com/liferay/content/targeting/api/model/TrackingAction.html}{TrackingAction}
  interface is implemented by extending the
  \texttt{BaseJSPTrackingAction} class. For more information on choosing
  a UI for your metric, see the
  \href{/docs/7-0/tutorials/-/knowledge_base/t/best-practices-for-metrics\#selecting-a-ui-technology}{Selecting
  a UI Technology} section.
\item
  Directly above the class's declaration, insert the following
  annotation:

\begin{verbatim}
@Component(immediate = true, service = TrackingAction.class)
\end{verbatim}

  This declares the Component's implementation class and configures it
  to start immediately once deployed to Liferay DXP.
\end{enumerate}

Now that your Java class is set up, you'll need to define how your
metric works by implementing the
\href{@app-ref@/content-targeting/2.0.0/javadocs/com/liferay/content/targeting/api/model/TrackingAction.html}{TrackingAction}
interface's methods. You'll begin implementing these methods next.

The first thing you'll define in your newsletter metric is the view/save
lifecycle.

\subsection{Defining a Metric's View/Save
Lifecycle}\label{defining-a-metrics-viewsave-lifecycle}

This section covers how to define a metric's view/save lifecycle. This
is when a user applies a metric to a report using the Report Editor.

In this section, you'll begin defining the newsletter metric's Java
class. This assumes that you followed the instructions above, creating
the \texttt{NewsletterTrackingAction} class and extending
\href{@app-ref@/content-targeting/2.0.0/javadocs/com/liferay/content/targeting/api/model/BaseJSPTrackingAction.html}{BaseJSPTrackingAction}.
If you used the \texttt{content-targeting-tracking-action} Blade CLI
template, your project is already extending
\texttt{BaseJSPTrackingAction} and a default \texttt{view.jsp} file is
already created.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add the activation and deactivation methods to your class.

\begin{verbatim}
@Activate
@Override
public void activate() {
    super.activate();
}

@Deactivate
@Override
public void deActivate() {
    super.deActivate();
}
\end{verbatim}

  These methods call the super class
  \href{@app-ref@/content-targeting/2.0.0/javadocs/com/liferay/content/targeting/api/model/BaseTrackingAction.html}{BaseTrackingAction}
  to implement necessary logging and processing for when your metric
  starts and stops. Make sure to include the
  \href{https://osgi.org/javadoc/r6/cmpn/org/osgi/service/component/annotations/Activate.html}{@Activate}
  and
  \href{https://osgi.org/javadoc/r6/cmpn/org/osgi/service/component/annotations/Deactivate.html}{@Deactivate}
  annotations, which are required.
\item
  Add the following method:

\begin{verbatim}
 @Override
 protected void populateContext(
     TrackingActionInstance trackingActionInstance,
     Map<String, Object> context, Map<String, String> values) {

     String alias = StringPool.BLANK;
     String elementId = StringPool.BLANK;
     String eventType = StringPool.BLANK;

     if (!values.isEmpty()) {
         alias = values.get("alias");
         elementId = values.get("elementId");
         eventType = values.get("eventType");
     }
     else if (trackingActionInstance != null) {
         alias = trackingActionInstance.getAlias();
         elementId = trackingActionInstance.getElementId();
         eventType = trackingActionInstance.getEventType();
     }

     context.put("alias", alias);
     context.put("elementId", elementId);
     context.put("eventType", eventType);
     context.put("eventTypes", getEventTypes());
 }
\end{verbatim}

  To understand what this method accomplishes, you should understand the
  metric's configuration lifecycle.

  \begin{figure}
  \centering
  \includegraphics{./images-dxp/metric-lifecycle.png}
  \caption{An Audience Targeting metric must be configured by the user
  and processed before it can become part of a Report.}
  \end{figure}

  When the user opens the Report Editor, the render phase begins for the
  metric. The \texttt{getFormHTML(...)} method retrieves the HTML to
  display. You don't have to worry about implementing this method
  because it's already implemented in the
  \href{@app-ref@/content-targeting/2.0.0/javadocs/com/liferay/content/targeting/api/model/BaseJSPTrackingAction.html}{BaseJSPTrackingAction}
  class you're extending. The \texttt{getFormHTML} method calls the
  \texttt{populateContext(...)} method.

  You'll notice the \texttt{populateContext} method is not available in
  the
  \href{@app-ref@/content-targeting/2.0.0/javadocs/com/liferay/content/targeting/api/model/TrackingAction.html}{TrackingAction}
  interface. This is because it's not needed in all cases. It's
  available by extending the \texttt{BaseJSPTrackingAction} class, and
  you'll need to add more logic to it for the newsletter metric.

  The goal of the \texttt{populateContext} method is to generate a map
  with all the parameters your JSP view needs to render the metric's
  HTML. This map is stored in the \texttt{context} variable, which is
  pre-populated with basic values in the Portlet logic, and then each
  metric contributes its specific parameters to it. The
  \texttt{populateContext} method above populates the \texttt{alias},
  \texttt{elementId}, \texttt{eventType}, and \texttt{eventTypes}
  context variables with the adjacent values from the \texttt{values}
  map parameter, which is then passed to the JSP.

  For the newsletter metric, the \texttt{populateContext} method
  accounts for three use cases:

  \begin{enumerate}
  \def\labelenumii{\alph{enumii}.}
  \item
    The metric was added but has no set values yet. In this case, the
    default values defined by the developer are injected (e.g.,
    \texttt{alias=""}).
  \item
    The metric was added and a value is set, but the request failed to
    complete (e.g., due to an error). In this case, the \texttt{values}
    parameter of the \texttt{populateContext} method contains the values
    that were intended to be saved, and they are injected so that they
    are displayed in the metric's view together with the error message.
  \item
    The metric was added and a value was successfully set. In this case,
    the \texttt{values} parameter is empty, and you have to obtain the
    values from storage that the form should display and inject them in
    the context so they're displayed in the metric's HTML. The
    newsletter metric stores values in the metric's instance, but
    complex metrics could use services to store values.
  \end{enumerate}

  You can think of the \texttt{populateContext} method as the
  intermediary between your JSP and your backend code. You can see how
  to create the newsletter metric's UI using a JSP by skipping to the
  \href{/docs/7-0/tutorials/-/knowledge_base/t/tracking-user-actions-with-audience-targeting\#defining-the-metrics-ui}{Defining
  the Metric's UI} section. Once the HTML is successfully retrieved and
  the user has set the newsletter's values and clicked \emph{Save}, the
  action phase begins.
\item
  Once the action phase begins, AT processes the tracking action
  (metric). The \texttt{processTrackingAction(...)} method takes the
  values from the
  \href{/docs/7-0/tutorials/-/knowledge_base/t/tracking-user-actions-with-audience-targeting\#defining-the-metrics-ui}{metric's
  UI form} and stores them in the corresponding fields of the
  \texttt{trackingActionInstance}. Since the
  \href{@app-ref@/content-targeting/2.0.0/javadocs/com/liferay/content/targeting/api/model/BaseTrackingAction.html}{BaseTrackingAction}
  class provides a default implementation of this method that returns
  \texttt{null}, the \texttt{NewsletterTrackingAction} class does not
  need to implement it.

  If you need to process any custom fields in your metric, you should
  override this method. If you want your custom values to be stored in
  the \texttt{typeSettings} field of the
  \texttt{trackingActionInstance}, return their value instead of
  \texttt{null}.
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** For more complex cases, you can create your own services to store
 your metric's information to a database. You should invoke your services'
 update logic within the `processTrackingAction` method. For more information
 on creating services, see the
 [Service Builder](/docs/7-0/tutorials/-/knowledge_base/t/service-builder)
 tutorials.
\end{verbatim}

\noindent\hrulefill

\begin{verbatim}
Once the metric processing ends, the form is reloaded and the lifecycle
restarts again. The value(s) specified in the metric are stored and are
ready to be accessed once the report generation begins. Next, you must set
the event types that the newsletter metric should evaluate.
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{3}
\item
  Add the following method and private field:

\begin{verbatim}
@Override
public List<String> getEventTypes() {
    return ListUtil.fromArray(_EVENT_TYPES);
}

private static final String[] _EVENT_TYPES = {"view"};
\end{verbatim}

  This specifies that your newsletter metric only tracks who views the
  newsletter.
\item
  Define a way to retrieve the metric's localized summary. In many
  instances, you can do this by combining keys in the metric's resource
  bundle with the information stored for the metric. For the newsletter
  metric, you can provide information about the ID of the newsletter
  being tracked, which is stored in the \texttt{alias} field of the
  \texttt{trackingActionInstance} object.

\begin{verbatim}
@Override
public String getSummary(
    String summary = LanguageUtil.format(
        locale, "tracking-newsletter-x",
        new Object[] {trackingActionInstance.getAlias()});

    return summary;
}
\end{verbatim}
\item
  Set the servlet context for your metric.

\begin{verbatim}
@Override
@Reference(
    target = "(osgi.web.symbolicname=newsletter)",
    unbind = "-"
)
public void setServletContext(ServletContext servletContext) {
    super.setServletContext(servletContext);
}
\end{verbatim}

  This is only required for metrics extending the
  \texttt{BaseJSPTrackingAction} class. The servlet context must be set
  for the metric to render its own JSP files. The
  \texttt{setServletContext} method is invoked automatically when the
  metric module is installed and resolved in Liferay. Make sure the
  \texttt{osgi.web.symbolicname} in the \texttt{target} property of the
  \texttt{@Reference} annotation is set to the same value as the
  \texttt{Bundle-SymbolicName} defined in the \texttt{bnd.bnd} file of
  the module.
\end{enumerate}

Next, you'll define a tracking mechanism for your metric to use.

\subsection{Using a Tracking
Mechanism}\label{using-a-tracking-mechanism}

Imagine an administrator has successfully configured and saved your
custom metric to his or her report. Now what? Your metric needs to
fulfill its purpose, which is to track the \texttt{view} event type for
the defined newsletter. To do this, you must define a tracking
mechanism. For your newsletter, you'll use a transparent image as the
tracking mechanism, which would have the \emph{View} tracking event
capability. Whenever the image is viewed, the newsletter metric computes
and stores the information.

For the newsletter metric, you'll use a tracking mechanism provided by
the Audience Targeting app.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  You must set the analytics processor that the Content Targeting API
  provides for tracking events. Add the following method and private
  field:

\begin{verbatim}
@Reference
protected void setAnalyticsProcessor(AnalyticsProcessor analyticsProcessor) {
    _analyticsProcessor = analyticsProcessor;
}

private AnalyticsProcessor _analyticsProcessor;
\end{verbatim}

  The analytics processor is a module of the Audience Targeting
  Analytics system. It contains a servlet to track analytics from
  Liferay pages (views, clicks, etc.) and an API to leverage this
  tracking mechanism. In the \texttt{setAnalyticsProcesoor(...)} method,
  you're obtaining a reference of the current analytics processor to
  build the URL used to generate a transparent image. All you have to do
  is insert the generated URL into your newsletter's HTML, and the
  transparent image tracks who reads it. Everything is processed by the
  default Audience Targeting Analytics system automatically.

  Now that you've obtained a reference of the analytics processor, you
  need to add logic for generating the appropriate tracking URL.
\item
  Replace the \texttt{populateContext} method with the updated method:

\begin{verbatim}
@Override
protected void populateContext(
    TrackingActionInstance trackingActionInstance,
    Map<String, Object> context, Map<String, String> values) {

    String alias = StringPool.BLANK;
    String elementId = StringPool.BLANK;
    String eventType = StringPool.BLANK;
    String trackImageHTML = StringPool.BLANK;

    if (!values.isEmpty()) {
        alias = values.get("alias");
        elementId = values.get("elementId");
        eventType = values.get("eventType");
    }
    else if (trackingActionInstance != null) {
        alias = trackingActionInstance.getAlias();
        elementId = trackingActionInstance.getElementId();
        eventType = trackingActionInstance.getEventType();

        String trackImageURL = _analyticsProcessor.getTrackingURL(
            trackingActionInstance.getCompanyId(), 0, 0, "", 0,
            Campaign.class.getName(),
            new long[] {trackingActionInstance.getCampaignId()},
            trackingActionInstance.getElementId(), "view", "");

        trackImageHTML = "<img alt=\"\" src=\"" + trackImageURL + "\" />";
    }

    context.put("alias", alias);
    context.put("elementId", elementId);
    context.put("eventType", eventType);
    context.put("eventTypes", getEventTypes());
    context.put("trackImageHTML", trackImageHTML);
}
\end{verbatim}

  This updated method creates a new variable named
  \texttt{trackImageHTML}, retrieves a tracking URL using the analytics
  processor, and then populates the \texttt{trackImageHTML} context
  variable. When creating a new metric, the transparent image's URL
  field is not present in the metric's form. When the metric is
  initially saved, however, the URL is generated using the analytics
  processor and is available for copying.
\end{enumerate}

Excellent! You've obtained the analytics processor and can create the
transparent image tracking mechanism. The newsletter metric's behavior
is defined and complete. The last thing you need to do is create a JSP
template.

\subsection{Defining the Metric's UI}\label{defining-the-metrics-ui}

The Java code you've added to this point has assumed that there are
three configurable fields for your newsletter metric:

\begin{itemize}
\tightlist
\item
  \emph{Name:} used in reports that count the number of times a metric
  has been triggered. This is also known as the newsletter's alias.
\item
  \emph{Newsletter ID:} used to differentiate between newsletters.
\item
  \emph{Event Type:} used to differentiate several actions on the same
  newsletter, such as opening the newsletter or clicking on a link.
\end{itemize}

To let administrators set these values, you must define a UI so your
metric can be configured during the view/save lifecycle. Remember that
you must also define a field to display the generated transparent
image's URL. Create a \texttt{view.jsp} file in your metric's module
(e.g., \texttt{/src/main/resources/META-INF/resources/view.jsp}) and add
the following logic:

\begin{verbatim}
<%
Map<String, Object> context = (Map<String, Object>)request.getAttribute("context");

String alias = (String)context.get("alias");
String elementId = (String)context.get("elementId");
String eventType = (String)context.get("eventType");
List<String> eventTypes = (List<String>)context.get("eventTypes");
String trackImageHTML = (String)context.get("trackImageHTML");
%>

<aui:input helpMessage="name-help" label="name" name='<%= ContentTargetingUtil.GUID_REPLACEMENT + "alias" %>' type="text" value="<%= alias %>">
    <aui:validator name="required" />
</aui:input>

<aui:input helpMessage="enter-the-id-of-the-newsletter-to-be-tracked" label="newsletter-id" name='<%= ContentTargetingUtil.GUID_REPLACEMENT + "elementId" %>' type="text" value="<%= elementId %>">
    <aui:validator name="required" />
</aui:input>

<c:if test="<%= ListUtil.isNotEmpty(eventTypes) %>">
    <aui:select label="event-type" name='<%= ContentTargetingUtil.GUID_REPLACEMENT + "eventType" %>'>

        <%
        for (String curEventType : eventTypes) {
        %>

            <aui:option label="<%= curEventType %>" selected="<%= curEventType.equals(eventType) %>" value="<%= curEventType %>" />

        <%
        }
        %>

    </aui:select>
</c:if>

<c:if test="<%= !Validator.isBlank(trackImageHTML) %>">
    <span class="h5">
        <liferay-ui:message key="paste-this-code-at-the-beginning-of-your-newsletter" />
    </span>
    <label for='<%= renderResponse.getNamespace() + ContentTargetingUtil.GUID_REPLACEMENT + "trackImageHTML" %>' key="paste-this-code-at-the-beginning-of-your-newsletter" /></label>

    <liferay-ui:input-resource id='<%= renderResponse.getNamespace() + ContentTargetingUtil.GUID_REPLACEMENT + "trackImageHTML" %>' url="<%= trackImageHTML %>" />
</c:if>
\end{verbatim}

First you instantiate the \texttt{context} variable and its attributes
you configured in your Java class's \texttt{populateContext} method.
Then you specify the appropriate fields Name, Newsletter ID, and Event
Type. Finally, you present the generated transparent image URL.

Notice that the input field names in the JSP are prefixed with
\texttt{ContentTargetingUtil.GUID\_REPLACEMENT}. This prefix is required
for multi-instantiable metrics, which are metrics that return
\texttt{true} in the \texttt{isInstantiable} method of their
\texttt{-TrackingAction} class and can be added more than once to the
Metrics form.

\begin{figure}
\centering
\includegraphics{./images-dxp/metric-generated-url.png}
\caption{Once you've saved the metric, you can copy the generated
transparent image URL into your newsletter's HTML to track who views
it.}
\end{figure}

Congratulations! You've created the newsletter metric and can now track
whether users viewed a newsletter. You can test if the metric is working
by copying the generated tracking image HTML into an email HTML editor,
sending it, and opening it as if it were an actual newsletter. Then open
the custom report containing the newsletter metric and select
\emph{Update Report}. A chart and table with the newsletter's view count
is shown.

You can view the finished version of the newsletter metric by
downloading its
\href{https://customer.liferay.com/documents/10738/200086/newsletter.zip/589ea9a1-9473-4409-acc6-c41c6d20728a}{ZIP
file}.

Now you've created and examined a fully functional metric and have the
knowledge to create your own.

\subsection{Related Topics}\label{related-topics-228}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-modules-with-blade-cli}{Creating
Modules with Blade CLI}

\href{/docs/7-0/user/-/knowledge_base/u/managing-campaigns\#defining-metrics}{Defining
Metrics}

\href{/docs/7-0/user/-/knowledge_base/u/audience-targeting-metrics}{Audience
Targeting Metrics}

\section{Best Practices for Metrics}\label{best-practices-for-metrics}

In this tutorial, you'll learn about best practices to keep in mind when
creating Audience Targeting Metrics. Before going through some best
practices, you should understand the four components you can specify for
a metric:

\begin{itemize}
\tightlist
\item
  \emph{Metric Behavior}
\item
  \emph{Tracking Mechanism}
\item
  \emph{UI for Configuration (optional)}
\item
  \emph{Language Keys (optional)}
\end{itemize}

You discuss metric behavior and its UI configuration in great detail in
the
\href{/docs/7-0/tutorials/-/knowledge_base/t/tracking-user-actions-with-audience-targeting}{Tracking
User Actions with Audience Targeting} tutorial. To learn more about
language keys and how to create, use, and generate them, visit the
\href{/docs/7-0/tutorials/-/knowledge_base/t/internationalization}{Internationalization}
tutorials.

Audience Targeting gives you the option to choose whatever frontend
technology you like. In the next section, you'll learn how to use your
preferred technology for displaying content in Audience Targeting
metrics.

\subsection{Selecting a UI Technology}\label{selecting-a-ui-technology}

Since 7.0, JSP is the preferred technology for Audience Targeting
extension views. FreeMarker views, however, are still supported through
their respective base classes (e.g.,
\texttt{BaseFreemarkerTrackingAction}). If you're interested in using a
technology besides JSP or FreeMarker to implement your UI, you can add a
method \texttt{getFormHTML} to your \texttt{-TrackingAction} class.
Here's an example of implementing the \texttt{getFormHTML} method:

\begin{verbatim}
@Override
public String getFormHTML(
    TrackingActionInstance trackingActionInstance,
    Map<String, Object> context, Map<String, String> values) {

    String content = "";

    try {
        populateContext(trackingActionInstance, context, values);

        content = ContentTargetingContextUtil.includeJSP(
            _servletContext, getFormTemplatePath(), context);
    }
    catch (Exception e) {
        _log.error(
            "Error while processing form template " +
                getFormTemplatePath(),
            e);
    }

    return content;
}
\end{verbatim}

The \texttt{getFormHTML} is used to retrieve the HTML created by the
technology you choose, and to return it as a string that is viewable
from your metric's form. If you plan, therefore, on using an alternative
to JSP or FreeMarker, you must override this method by creating and
modifying it in your \texttt{-TrackingAction} class.

\subsection{Related Topics}\label{related-topics-229}

\href{/docs/7-0/tutorials/-/knowledge_base/t/tracking-user-actions-with-audience-targeting}{Tracking
User Actions with Audience Targeting}

\href{/docs/7-0/tutorials/-/knowledge_base/t/internationalization}{Internationalization}

\href{/docs/7-0/tutorials/-/knowledge_base/t/service-builder-persistence}{Service
Builder Persistence}

\section{Best Practices for Rules}\label{best-practices-for-rules}

In this tutorial, you'll learn about best practices to keep in mind when
creating Audience Targeting Rules. Before going through some best
practices, you should understand the three components you can specify
for a rule:

\begin{itemize}
\tightlist
\item
  \emph{Rule Behavior}
\item
  \emph{UI for Configuration (optional)}
\item
  \emph{Language Keys (optional)}
\end{itemize}

You discuss rule behavior and its UI configuration in great detail in
the
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-new-audience-targeting-rule-types}{Creating
New Audience Targeting Rule Types} tutorial. To learn more about
language keys and how to create, use, and generate them, visit the
\href{/docs/7-0/tutorials/-/knowledge_base/t/internationalization}{Internationalization}
tutorials.

Audience Targeting gives you the option to choose whatever frontend
technology you like. In the next section, you'll learn how to use your
preferred technology for displaying content in Audience Targeting rules.

\subsection{Selecting a UI
Technology}\label{selecting-a-ui-technology-1}

Since 7.0, JSP is the preferred technology for Audience Targeting
extension views. FreeMarker views, however, are still supported through
their respective base classes (e.g., \texttt{BaseFreemarkerRule}). If
you're interested in using a technology besides JSP or FreeMarker to
implement your UI, you can add a method \texttt{getFormHTML} to your
\texttt{-Rule} class. Here's an example of implementing the
\texttt{getFormHTML} method:

\begin{verbatim}
@Override
public String getFormHTML(
    RuleInstance ruleInstance, Map<String, Object> context,
    Map<String, String> values) {

    String content = "";

    try {
        populateContext(ruleInstance, context, values);

        content = ContentTargetingContextUtil.parseTemplate(
            getClass(), getFormTemplatePath(), context);
    }
    catch (Exception e) {
        _log.error(
            "Error while processing template " + getFormTemplatePath(), e);
    }

    return content;
}
\end{verbatim}

The \texttt{getFormHTML} is used to retrieve the HTML created by the
technology you choose, and to return it as a string that is viewable
from your rule's form. If you plan, therefore, on using an alternative
to JSP or FreeMarker, you must override this method by creating and
modifying it in your \texttt{-Rule} class.

\subsection{Other Best Practices}\label{other-best-practices}

Here are some things to consider as you implement and deploy Audience
Targeting rules:

\begin{itemize}
\item
  As an alternative to storing complex information in the
  \texttt{typeSettings} field, which is managed by the framework in the
  Rule Instance table, you may want to consider persisting to a database
  by using
  \href{/docs/7-0/tutorials/-/knowledge_base/t/service-builder}{Service
  Builder}, which is supported for Rule plugins.
\item
  If you deploy your rule into a production environment, you may want to
  consider adding your values to the cache (e.g., weather in different
  locations), since obtaining the same value on every request is very
  inefficient and could result in slowing down your portal. For example,
  when the \texttt{evaluate} method is called, you could obtain the
  current user ID, current user's weather forecast, and the time at
  which the user first visited the page. Then you could evaluate the
  rule only when the cached time is over three hours old. This would
  prevent the rule from evaluating every time the user visited the page.
  This is best done using services.
\end{itemize}

\begin{itemize}
\item
  You can override the \texttt{BaseJSPRule.deleteData} method in your
  \texttt{-Rule}, so that it deletes any data associated with the rule
  that is currently being deleted.
\item
  If your rule handles data or references to data that can be staged
  (e.g., a reference to a page or web content article), you may need to
  override the \texttt{BaseRule.exportData} and
  \texttt{BaseRule.importData} methods, to manage the content properly.
\end{itemize}

\subsection{Related Topics}\label{related-topics-230}

\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-new-audience-targeting-rule-types}{Creating
New Audience Targeting Rule Types}

\href{/docs/7-0/tutorials/-/knowledge_base/t/internationalization}{Internationalization}

\href{/docs/7-0/tutorials/-/knowledge_base/t/service-builder-persistence}{Service
Builder Persistence}

\chapter{Customizable Web
Applications}\label{customizable-web-applications}

One of the great strengths of Liferay DXP is the sheer number of out of
the box applications. This gives it great flexibility in what it can do,
which is why Liferay DXP is used to run many different kinds of websites
around the world. For example, if you want users to add Blog posts, you
can configure the Blogs portlet to handle those requests.

But really, that's technology from the last decade. What if you could
define a particular function that users might want to perform and let
Liferay DXP choose an available installed app to perform that function?
That way, if users want to Blog, and you've installed your own
custom-developed app for blogging instead of Liferay's, the Liferay DXP
instance can just use yours instead?

With Liferay DXP 7, you can do just that. You can request an app based
on an entity and action type. Processing the entity type and action,
Liferay uses an available portlet that can handle the request. This
increases the flexibility and modularity of using portlets in Liferay
DXP.

\section{Providing Portlets to Manage
Requests}\label{providing-portlets-to-manage-requests}

In this tutorial, you'll learn how to declare an entity type and action
for a desired function, and you'll create a module that finds the
correct application (portlet) to use based on those given parameters.

\subsection{Specifying a Desired Portlet
Behavior}\label{specifying-a-desired-portlet-behavior}

To find the portlet you need for your particular request, you'll use the
\emph{Portlet Providers} framework. The first thing you'll need to do is
call the
\href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/PortletProviderUtil.html}{PortletProviderUtil}
class and request the framework find a portlet suitable for the current
task. You can request the portlet ID or portlet URL, depending on what
you prefer. Here's an example declaration:

\begin{verbatim}
String portletId = PortletProviderUtil.getPortletId(
    "com.liferay.portlet.trash.model.TrashEntry", PortletProvider.Action.VIEW);
\end{verbatim}

This declaration expects two parameters: the class name of the entity
type you want the portlet to handle and the type of action. The above
code requests a portlet ID for a portlet that can view Recycle Bin
entries.

There are five different kinds of actions supported by the Portlet
Providers framework: \texttt{ADD}, \texttt{BROWSE}, \texttt{EDIT},
\texttt{PREVIEW}, and \texttt{VIEW}. Find the portlet ID or portlet URL
(depending on your needs), and specify the entity type and action you
want the portlet to handle.

\noindent\hrulefill

\textbf{Note:} The \texttt{getPortletURL} methods require an additional
\texttt{HttpServletRequest} or \texttt{PortletRequest} parameter,
depending on which you use. Make sure to account for this additional
parameter when using the \texttt{getPortletURL} method.

\noindent\hrulefill

You've successfully requested the portlet ID/portlet URL of a portlet
that matches your entity and action type. The portal, however, is not
yet configured to handle this request. You'll need to create a module
that can find the correct portlet to handle the request.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/starting-module-development\#creating-a-module}{Create
  an OSGi module}.
\item
  Create a unique package name in the module's \texttt{src} directory
  and create a new Java class in that package. To follow naming
  conventions, name the class based on the element type and action type,
  followed by \emph{PortletProvider} (e.g.,
  \texttt{LanguageEntryViewPortletProvider}). The class should extend
  the
  \href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/BasePortletProvider.html}{\texttt{BasePortletProvider}}
  class and implement the appropriate portlet provider interface based
  on the action type you chose your portlet to handle (e.g.,
  \href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/ViewPortletProvider.html}{ViewPortletProvider},
  \href{@platform-ref@/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/BrowsePortletProvider.html}{BrowsePortletProvider},
  etc.).
\item
  Directly above the class's declaration, insert the following
  annotation:

\begin{verbatim}
 @Component(
     immediate = true,
     property = {"model.class.name=CLASS_NAME"},
     service = INTERFACE.class
 )
\end{verbatim}

  The \texttt{property} element should match the element type you
  specified in your \texttt{getPortletID/getPortletURL} declaration
  (e.g.,
  \texttt{com.liferay.portal.kernel.servlet.taglib.ui.LanguageEntry}).
  Also, your \texttt{service} element should match the interface you're
  implementing (e.g., \texttt{ViewPortletProvider.class}). You can view
  an example of a similar \texttt{@Component} annotation in the
  \href{https://github.com/liferay/liferay-portal/blob/7.0.4-ga5/modules/apps/foundation/roles/roles-selector-web/src/main/java/com/liferay/roles/selector/web/internal/portlet/RolesSelectorEditPortletProvider.java}{RolesSelectorEditPortletProvider}
  class:

\begin{verbatim}
 @Component(
     immediate = true,
     property = {"model.class.name=com.liferay.portal.kernel.model.UserGroupRole"},
     service = EditPortletProvider.class
 )
\end{verbatim}
\item
  In some cases, a default portlet is already in place to handle the
  entity and action type requested. To override the default portlet with
  a custom portlet, you can assign your portlet a higher service
  ranking. You can do this by setting the following property in your
  \texttt{@Component} declaration:

\begin{verbatim}
 property= {"service.ranking:Integer=10"}
\end{verbatim}

  Make sure to replace the integer with a number that is ranked higher
  than the portlet being used by default.
\item
  Specify the methods you'd like to implement. Make sure to retrieve the
  portlet ID/portlet URL that should be provided when this service is
  called.
\end{enumerate}

Lastly, generate the module's JAR file and deploy it to your portal
instance. Now a portlet that can handle the entity and action type you
specified is used when requesting a portlet ID/URL. You can now specify
portlet usage without hardcoding a specific portlet!

\subsection{Related Topics}\label{related-topics-231}

\href{/docs/7-0/tutorials/-/knowledge_base/t/portlets}{Portlets}

\href{/docs/7-0/tutorials/-/knowledge_base/t/embedding-portlets-in-themes}{Embedding
Portlets in Themes}

\href{/docs/7-0/tutorials/-/knowledge_base/t/customizing-liferay-services-service-wrappers}{Customizing
Liferay Services}
