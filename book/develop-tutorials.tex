\chapter{Introduction to Liferay
Development}\label{introduction-to-liferay-development}

How many times have you had to start over from scratch? Probably almost
as many times as you've started a new project, because each time you
have to write not only the code to build the project, but also the
underlying code that supports the project. It's never a good feeling to
have to write the same kind of code over and over again. But each new
project that you do after a while can feel like that: you're writing a
new set of database tables, a new API, a new set of CSS classes and
HTML, a new set of JavaScript functions.

Wouldn't it be great if there was a platform that provided a baseline
set of features that gave you a head start on all that repetitive code?
Something that lets you get right to the features of your app or site,
rather than making you start over every time with the basic building
blocks? There is such a thing, and it's called Liferay DXP.

\begin{figure}
\centering
\includegraphics{./images/dont-start-from-scratch.png}
\caption{With Liferay DXP, you never have to start from scratch.}
\end{figure}

\section{Leveraging a Suite of Products, Frameworks and
Libraries}\label{leveraging-a-suite-of-products-frameworks-and-libraries}

Liferay DXP offers you a complete platform for building web apps, mobile
apps, and web services quickly, using features and frameworks designed
for rapid development, good performance, and ease of use. The base
platform is already there, and it's built as a robust container for
applications that you can put together in far less time than you would
from scratch.

It also ships with a default set of common applications you can make use
of right away: web experience management, collaboration applications
such as forums and wikis, documents and media, blogs, and more. All of
these applications are designed to be customized, as is the system
itself. You can also extend them to include your own functionality, and
this is no hack: because of Liferay's extensible design, customization
is by design.

\begin{figure}
\centering
\includegraphics{./images/liferay-suites.png}
\caption{Liferay DXP ships with suites of applications to get you
started building your site quickly.}
\end{figure}

In short, Liferay was written by developers for developers, to help you
get your work done faster and more easily, to take the drudgery out of
web and mobile app development, so that writing code becomes enjoyable
again.

\section{Build Websites, Intranets, Collaborative Environments, Mobile
Apps, and
More}\label{build-websites-intranets-collaborative-environments-mobile-apps-and-more}

One of the most often cited best characteristics of Liferay is how
versatile it is. It can be used to build websites of all sorts, from
very large websites with hundreds of thousands of articles, to smaller,
highly dynamic and interactive sites. This includes public sites,
internal sites like intranets, or mixed environments like collaboration
platforms.

Developers often choose Liferay for one of these cases and quickly find
that it is a great fit for completely different projects.

\section{Creating Your Own Applications and Extending the Existing
Ones}\label{creating-your-own-applications-and-extending-the-existing-ones}

Liferay DXP is based on the Java platform and can be extended by adding
new applications, customizing existing applications, modifying its
behavior, or creating new themes. You can do this with any programming
language the JVM supports, such as Java itself, Scala, jRuby, Jython,
Groovy, and others. Liferay DXP is lightweight, can be deployed to a
variety of Java EE containers and app servers, and it supports a variety
of databases. Because of its ability to be customized, you can add
support for more app servers or databases without modifying its source
code: just develop and deploy a module with the features you need.

Speaking of code and deploying, here are some of the most common ways of
expanding or customizing Liferay DXP's features:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Developing a new full-blown web application. The most common way to
  develop web applications for Liferay DXP is with
  \href{/docs/7-1/tutorials/-/knowledge_base/t/portlets}{portlets},
  because they integrate well with other existing applications. You are
  not, however, limited to portlets if you don't need to integrate your
  apps with others.
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/customizing}{Customizing
  an existing web application or feature}. Liferay DXP is designed to be
  extended. Many extension points can be leveraged to modify existing
  behavior, and most of these can be developed through a single Java
  class with some annotations (more details later).
\item
  Creating a new
  \href{/docs/7-1/tutorials/-/knowledge_base/t/web-services}{web
  service} for an external system, a mobile app, an IoT device, or
  anything else.
\item
  Developing a
  \href{/docs/7-0/tutorials/-/knowledge_base/t/mobile}{mobile app} that
  leverages Liferay as its back-end, which you can write in a fraction
  of the normal time thanks to Liferay Screens and
  \href{/docs/7-0/tutorials/-/knowledge_base/t/mobile-sdk}{Liferay
  Mobile SDK}.
\item
  Developing a custom
  \href{/docs/7-1/tutorials/-/knowledge_base/t/introduction-to-themes}{theme}
  that adapts the look and feel of the platform to the visual needs of
  your project.
\end{enumerate}

\begin{figure}
\centering
\includegraphics{./images/liferay-developer-roles-diagram.png}
\caption{Developers use Liferay DXP in many ways.}
\end{figure}

The Liferay platform can be used as a headless platform to develop web
or mobile apps with any technology of your choice (Angular, React,
Backbone, Cocoa, Android's Material Design components, Apache Cordova,
etc). It can also be used as a web integration layer, leveraging
technologies such as portlets to allow several applications to coexist
on the same web page.

\section{Fundamentals}\label{fundamentals}

What are the fundamentals that every Liferay developer should know?

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  It's Open Source and puts a strong emphasis on following standards,
  instead of reinventing the wheel.
\item
  It's based on Java EE and heavily leverages OSGi and several other
  popular technologies for the Java Platform.
\item
  It is based on a modular architecture and facilitates following a
  modular development paradigm for your own projects.
\item
  You can build your own web applications, portlets, or mobile apps on
  top of it.
\item
  It provides mature development tools, while staying agnostic so you
  can use tools you prefer.
\item
  It's all about reusing, providing reusable frameworks and libraries
  and allowing you to create your own.
\end{enumerate}

Interested? More details below.

\subsection{Open Source and based on
Standards}\label{open-source-and-based-on-standards}

Liferay DXP is both Open Source and built in the open, following a
collaborative development model. That means that you can follow new
development as it's happening, make comments on it, and contribute! Here
are some tools that you can use to do all this:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Our ticketing system. All product changes, including all bug fixes,
  improvements, and new features start with a ticket created in JIRA. We
  have several projects there, but the main one for tracking Liferay DXP
  work or for reporting bugs you find (with as many details as you can
  and steps to reproduce, of course) is
  \href{https://issues.liferay.com/browse/LPS}{LPS}.
\item
  \href{http://github.com/liferay}{GitHub}: The home of our source code.
  You can use it to see the code changes as they happen and also to send
  pull requests for improvements. There are also many repos, but the
  main one is
  \href{http://github.com/liferay/liferay-portal}{liferay-portal}.
\item
  \href{http://forums.liferay.com}{Forums}: It's where our community
  gets together to share ideas, discuss, and collaborate. Go ahead and
  ask your questions and help others ask theirs.
\item
  \href{http://blogs.liferay.com}{Blogs}: Read the latest news, advice,
  and best practices from key core developers and our most active
  community members.
\item
  \href{https://portal.liferay.dev/participate}{Participate}: Learn how
  to get started participating. There are options for all levels of
  expertise and time availability.
\end{enumerate}

In addition to being Open Source, Liferay is also heavily based on
standards. This is great news for your project, since it significantly
reduces the lock-in on Liferay. That also encourages us to improve
constantly.

Here are some key standards Liferay DXP supports:

\begin{itemize}
\item
  \href{https://jcp.org/en/jsr/detail?id=168}{Portlets 1.0} (JSR-168)
  and \href{https://jcp.org/en/jsr/detail?id=286}{Portlets 2.0}
  (JSR-286): Liferay DXP can run any portlets that follow these two
  versions of the specification. Liferay is also heavily involved in the
  upcoming Portlets 3.0 specification.
\item
  \href{http://www.oracle.com/technetwork/java/javaee/javaserverfaces-139869.html}{JSF}~(JSR-127,
  JSR-314, JSR-344): The Java standard for building component based web
  applications. Liferay is an active contributor to the standard and
  lead of the JSF-Portlet Bridge specification.
\item
  \href{http://www.ecma-international.org/ecma-262/6.0/}{EcmaScript
  2015}: The latest incarnation of the JavaScript standard. Liferay's
  tooling provides the ability to use it in all modern browsers thanks
  to the integration of Babel JS.
\item
  \href{https://www.oasis-open.org/committees/cmis}{Content Management
  Interoperability Services}~(CMIS): Liferay's
  \href{/docs/7-1/user/-/knowledge_base/u/managing-documents-and-media}{Documents
  and Media} can behave as an interface for any external Documents
  Repository that supports this widely adopted standard.
\item
  \href{https://jcp.org/en/jsr/detail?id=170}{Java Content
  Repository}~(JSR-170): Files stored in the internal repository of
  Liferay's
  \href{/docs/7-1/deploy/-/knowledge_base/d/document-repository-configuration}{Documents
  and Media can be configured} to be stored in a JSR-170 compatible
  repository if desired.
\item
  \href{http://www.webdav.org}{WebDAV}: Any Documents \& Media folder
  can be mounted anywhere WebDAV is supported, such as Windows explorer
  or WebDAV-specific clients.
\item
  \href{http://saml.xml.org}{SAML}~and
  \href{http://oauth.net/core/1.1}{OAuth 1.1}: These are the most widely
  adopted security protocols for SSO and application sign in, supported
  through specific Apps that can be installed from
  \href{http://marketplace.liferay.com}{Liferay's Marketplace}.
\item
  JAX-WS and JAX-RS: Incorporated since Liferay 7 as the preferred
  tooling to create web services.
\item
  \href{https://www.osgi.org}{OSGi r6}: Liferay supports a wide range of
  the OSGi family of standards through its own implementations and also
  integrates the high quality implementations of the Apache Felix and
  Eclipse Equinox projects (which we also collaborate). Here are some of
  the most relevant supported standards:

  \begin{itemize}
  \tightlist
  \item
    OSGi runtime: Allowing any OSGi module to run in Liferay DXP
  \item
    Declarative Services: Supports a dynamic component model for Liferay
    development.
  \item
    Configuration Admin: Lets you create highly configurable
    applications that can be reconfigured on the fly. Liferay provides
    an auto-generated UI to change the configuration of any component
    that leverages this standard.
  \end{itemize}
\end{itemize}

\subsection{Technologies}\label{technologies}

Like any open source application, Liferay is built on the shoulders of
giants. When we choose the technology on which to build our platform, it
must have the following characteristics:

\begin{itemize}
\tightlist
\item
  It must balance being modern and being mature enough for demanding and
  critical enterprise environments.
\item
  It should be widely adopted and have a mature community.
\item
  It should be as easy as possible to contribute back, since we love to
  contribute to the Open Source projects we use.
\item
  It should be possible to use only the piece of the project we need if
  we don't need the whole thing. That way, it's easier to replace that
  piece in the future if we find something that works better.
\end{itemize}

The goal, of course, is to give our developers and users the most up to
date, easy-to-use, and stable platform to build services on.

\begin{figure}
\centering
\includegraphics{./images/liferay-technologies.png}
\caption{Liferay is based on popular, well known, and well supported
technologies.}
\end{figure}

At its base, Liferay is a JavaEE application that also includes an OSGi
container. This offers the best of both worlds: access to the world's
most robust and fully featured enterprise platform, along with the
benefits of the world's most fully featured and stable modular
container. Now you can develop and deploy enterprise-ready, scalable web
and mobile-based applications in a dynamic, component-based environment.

With Java EE and OSGi at the bottom of the stack, we build the rest of
our core on well known or widely used products:

\begin{itemize}
\tightlist
\item
  Spring for transactions (and Dependency Injection in the core)
\item
  Hibernate for database access (along with direct JDBC access for
  optimized queries)
\item
  Elasticsearch for indexing and searching
\item
  Ehcache for caching.
\end{itemize}

In the application layer, developers have access to many of the
libraries they're familiar with and have been using for years:

\begin{itemize}
\tightlist
\item
  Xalan
\item
  Xerces
\item
  Apache Commons
\item
  Tika
\item
  dom4j
\end{itemize}

If you're approaching Liferay DXP with the intention of customizing it,
you can know that most if not all of the tools you're familiar with are
there. If you're writing applications on Liferay, the sky's the limit:
you can use any web framework you like, and you can write both servlet
and portlet-based applications. If you're looking for a recommendation,
though, we're happy to point you to our
\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-mvc-portlet}{MVCPortlet}
framework.

On the front-end, Liferay has kept pace with the most recent
progressions in that space. If you've used Liferay in the past, you can
of course continue to use Liferay's venerable Alloy UI, but you are also
free to use the front-end technologies you love the most:

\begin{itemize}
\tightlist
\item
  Bootstrap
\item
  SaSS
\item
  \href{http://www.ecma-international.org/ecma-262/6.0/}{EcmaScript
  2015} (using Babel.js)
\end{itemize}

You can also use any JavaScript library, including

\begin{itemize}
\tightlist
\item
  \href{http://metaljs.com/}{Metal.js} (developed by Liferay)
\item
  \href{https://jquery.com/}{jQuery} (included)
\item
  Lodash (included)
\item
  Angular JS or Angular
\item
  React
\item
  Your library of choice
\end{itemize}

Liferay DXP follows a design language created by our designers at
Liferay called \href{https://lexicondesign.io/}{Lexicon Experience
Language}, which has been implemented for use of the web as
\href{https://liferay.github.io/clay/}{Clay}.

Clay is automatically made available to you through a set of CSS classes
and markup, although it's even easier to use our tag library.

For templating, Java EE's JSP is there as expected as well as
FreeMarker, but the modularity of the platform allows you to use
Google's Soy (aka Closure Templates) or whatever else you like.

Liferay has also chosen build tools that give you freedom to use any
development environment. Gradle along with bnd powers the product's
build, but project layouts are dynamic, which means you can use anything
from Maven to Ant/Ivy to build applications for Liferay.

In short, Liferay has done a lot to make sure its users and developers
have access to the most widely used, robust tools possible--as well as
the freedom to use the tools they like the most. Know that Liferay has
your back and will do everything we can to provide you with the most
flexible technology platform possible, so that you have the freedom to
go and build great things on it--things we never could have expected or
imagined.

\subsection{Architecture}\label{architecture}

Liferay's design goals have from the beginning been to give you all the
tools to create exactly the web presence you have in mind. To achieve
this, the product must do these things:

\begin{itemize}
\tightlist
\item
  Provide a usable default configuration and interface
\item
  Ship with best-of-breed apps that you can use to build sites quickly
\item
  Make the UI customizable at any level of detail from small tweaks to a
  complete replacement
\item
  Make the apps customizable at any level of detail
\item
  Provide a robust development platform upon which you can build and
  share new best-of-breed apps
\end{itemize}

\includegraphics{./images/liferay-architecture.png} These goals are now
achieved to the furthest extent ever in Liferay's history, and it's all
because of our new modular architecture.

Imagine an environment where every piece of functionality is an
independent module. The modules declare three important things:

\begin{itemize}
\tightlist
\item
  The functionality they implement or define
\item
  Their dependency on other modules
\item
  Their priority relative to their functionality
\end{itemize}

Using this information, the container can start all the modules that
fulfill their definitions, implementations, dependencies, and
priorities.

Anything a developer wants to do is implemented as one or more modules.
If it's a new application, that application can depend on existing
modules and
\href{/docs/7-0/tutorials/-/knowledge_base/t/configuring-dependencies}{define
a dependency} on them. This enables you to use functionality that's
already there without rewriting it yourself for your app. If it's a
customization, in many cases it's just a simple matter of defining your
customization with a higher priority than the existing functionality.

This is the power of a modular architecture.

\subsubsection{Modules}\label{modules}

All new applications, extensions, and customizations built on Liferay
are built in a
\href{/docs/7-1/tutorials/-/knowledge_base/t/the-benefits-of-modularity}{modular
way}. A module is the single unit of distribution and deployment in a
modular architecture.

In the spirit of following existing standards, Liferay has leveraged a
set of very powerful standards known as
\href{https://www.osgi.org/developer/}{OSGi}. OSGi defines, among other
things, how modules can depend on each other and communicate. It also
defines the packaging format for modules: OSGi bundles. An OSGi module
is just a typical JAR file, familiar to Java developers as a ZIP file
containing compiled code, templates, resources, and some meta
information.

\subsubsection{Services}\label{services}

One aspect of modern software architecture is the notion of services.
These are independently running pieces of code that provide specific
functionality when called. They operate just like services in the real
world do. For example, you might call a service to come mow your lawn.
You know how to call the service and to give it what it needs (money) in
order to receive the service (a mown lawn). Software-based services work
the same way.

Liferay's services are standard services as defined by the
\href{https://www.osgi.org/about-us/}{OSGi Alliance}. Writing anything,
whether it be an application, an interface to a database, or even a
``service'' as you define it, is easy to implement as an OSGi service,
because they're both incredibly powerful and easy to develop. If you
understand Java interfaces and how they are implemented--which is
introductory Java material--you already understand more than 90\% of
what you need to know. First, you define the interface, or contract for
the service: what it returns, and what it needs to return what it
returns. Next, you define an implementation class that implements the
contract.

In the services model, a class requests the service that provides the
functionality it needs. This functionality is provided (often injected)
with the right implementation automatically. It's similar to Spring or
EJBs with one important addition: implementations can be changed at
runtime, without restarting the system. This is achieved because when
a~service is deployed, it becomes part of a service registry~maintained
by Liferay's OSGi container. The container dynamically manages the
lifecycle of the service and can start and stop services~when
appropriate.

The real power of services shines when they are extended. You can
replace existing implementations or in advanced use cases have several
implementations of a service. The developer can then choose to invoke
all implementations or just the one with the highest priority (specified
with what is called the service ranking).~This means that if Liferay has
a service that does something, you can customize or override that
service by implementing its interface yourself and then deploying it
with a higher ranking than the original service. The container then
instantiates your implementation when the service is called by existing
code. This simple, clean method is how most customizations are made to
Liferay 7.

\subsubsection{Components}\label{components}

In OSGi, possibly the best and certainly the easiest way to create
services is through Declarative Services. In Declarative Services (aka
DS), you create Components. A Component is a Java class (marked with an
\texttt{@Component} annotation) that provides an implementation of a
Service (as described above) and whose instantiation is handled
automatically by DS. This is similar to what you might be used to if you
have used Spring Beans or EJBs. DS also provides dependency injection
using annotations (\texttt{@Reference}). This is convenient because the
``wiring'' of components is done by the container but can be changed
while the server is running (unlike Spring).

Modules may contain as many service declarations and as many components
as desired (or zero, of course).

In software engineering terms, a component is the smallest building
block of a larger application, and that application is itself made up of
many small components. This makes it easier to develop an application
because you only have to deal with small, well-defined, bite-sized
chunks of code at a time.

\subsubsection{Real Life Benefits of Modular
Development}\label{real-life-benefits-of-modular-development}

The next question then becomes, so what? Why is this a big deal? Why
should I have components, and what do I need them for?

It helps to examine two common development scenarios: a customization
task and a full-blown application. Picture this: you have a system that
generates a report in PDF format from data in a database. The data is
captured from a web application running in Liferay. You come in to work
in the morning and something's happened (it doesn't matter what it is;
it could be corrupt data, the company has been bought, or a national
emergency). You need to change that report as fast as possible, either
to insert a new title page, add a warning to the existing title page, or
whatever.

In the monolithic model you'd have to modify the application to change
the report and then you'd have to redeploy the complete application. If
this was a temporary change, to restore the application to its original
state you'd again have to modify the application and redeploy it.

With a modular and component-based application, you'd fix a simple,
small component--probably one Java class--that provides the
functionality you need. You'd then deploy its module to the server. If
you need to roll back that change in the future, you'd just do the same
thing in reverse. In each case, you're only changing and redeploying the
small piece of functionality that needs to change, not the whole
application. At no time would you ever have to redeploy the whole
application or take the server down.

For a full-blown application, the benefits are even greater. Modular
development helps developers be more efficient in three important ways:

\begin{itemize}
\tightlist
\item
  An application made up of components can be written in parallel by
  multiple developers working on different components.
\item
  An existing application can be extended by writing new components to
  implement features in different ways.
\item
  Components can be enabled and disabled, allowing administrators to
  choose which features to enable in production.
\end{itemize}

For example, Liferay's Documents and Media library is a file repository
that supports many back-ends. Each back-end is a component that can be
maintained by different developers. They can be added and removed on the
fly while the server is running.

Similarly, the services provided by the application are independent of
the front-end technology. In fact, there can be multiple front-ends,
from the web-based front-end Liferay provides out of the box, to a new
front-end you might develop for either the web or mobile.

As you can see, many components running inside Liferay's OSGi container
form something of an ecosystem of complementary services. Much of
Liferay's functionality is in components, and when you deploy your code,
it sits in the same ecosystem as Liferay's, with the same extension
points. You can write components to provide new services or to override
existing services with your own implementation, and the container
manages it all. Liferay is an exciting platform that empowers developers
to be more productive.

\section{Liferay as a Development
Platform}\label{liferay-as-a-development-platform}

If you've been reading everything up to this point, you've heard all
about Liferay DXP's architecture, modularity, and technologies. What's
left is to tell you what it's like to use Liferay's platform as a basis
for your site by customizing it or by developing applications on it. The
platform is designed to make this easy and pleasant, and to integrate
with the tools you use every day.

But you're likely not interested in a bunch of prolegomena about it.
Read on to learn the details.

\subsection{Web Applications and
Portlets}\label{web-applications-and-portlets}

Liferay as a development platform has always provided flexibility for
both administrators and developers by making it easy to have more than
one application on a single page. Applications written this way are
called \emph{portlets}, and are a mainstay of Liferay's platform. You
can use
\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-mvc-portlet}{Liferay's
MVC Portlet framework} or common frameworks such as
\href{/docs/7-1/tutorials/-/knowledge_base/t/spring-mvc}{Spring MVC} or
\href{develop/tutorials/-/knowledge_base/7-1/jsf-portlets-with-liferay-faces}{JSF}
to write portlets. If you plan to have a web-based interface to your
application,~and want its administrator to have a lot of flexibility
configuring it, portlets provide a very powerful model. In this model
you can create several portlets instead of a larger application and let
the administrator choose how to combine them with other pre-existing
portlets into a larger interface.

That's not to say you don't have other choices. Since Liferay decouples
its business logic from its UI (which is provided in separate modules),
you have freedom to implement the UI in any other technology.

Because of this, you can use Liferay as a headless platform, because
it's easy to create
\href{/docs/7-1/tutorials/-/knowledge_base/t/web-services}{web services}
based on
\href{/docs/7-1/tutorials/-/knowledge_base/t/service-builder-web-services}{Service
Builder}, JAX-RS, and JAX-WS. Then you can build standalone web
applications using any front-end technology or mobile technology you
like.

\subsection{Extensibility}\label{extensibility}

As you might imagine, the system described above contains all the tools
necessary to make a well designed system that lets you not only create
applications based on modules, but also to extend the existing
functionality of the system. Liferay can benefit from this now because
the platform on which it rests is designed for both application
development and customization.

Components make developing extensions and customizations convenient. If
you compare this model to other products that aren't designed for
customization, you'll see just how convenient it can be.

To customize an existing service, the only thing you need to do is
deploy a component that extends the existing implementation. If you want
to remove your implementation and revert back to the default behavior,
you simply un-deploy your component.

Compare that with the traditional way of customizing software by
downloading its source and maintaining a set of patches against it. Each
time the software is updated, you have to re-download the source,
re-apply your patches, and recompile the software.

With Liferay, your custom code is kept in your own modules, which the
container takes care of applying based on metadata you supply.

\subsection{Developer Tools}\label{developer-tools}

As you learned above, Liferay's OSGi container gives you these benefits:

\begin{itemize}
\tightlist
\item
  The container can start and stop components.
\item
  A component implements~an OSGi service.
\item
  A component may use or consume OSGi services.
\item
  The framework manages~the binding of the services a component consumes
  (just like Spring or EJBs, but dynamically).
\end{itemize}

If all of this sounds great to you (as it does to us), there's only one
thing left: how do you get started developing components? We believe in
providing an easy path for new developers while at the same time
preserving flexibility for experienced developers with strong tooling
preferences. To achieve that, Liferay provides some great tools, and if
you're an experienced developer, these also integrate into what you
likely already use. If you use any of the standard build tools like
Gradle or Maven, any text editor or common Java IDEs like Eclipse,
intelliJ, or NetBeans, or any testing framework like Spock or JUnit, you
can use them with Liferay to develop components.

\href{/docs/7-1/tutorials/-/knowledge_base/t/tooling}{Liferay's tools}
add some important enhancements:

\begin{itemize}
\tightlist
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/blade-cli}{Blade CLI}
  speeds you up by creating Gradle-based Liferay projects from
  \href{/docs/7-1/reference/-/knowledge_base/r/project-templates}{templates}.
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-workspace}{Liferay
  Workspace} is an opinionated SDK based on Gradle that~uses Blade CLI
  to integrate your projects and your runtime into one convenient,
  distributable and sharable place.
\item
  Liferay IDE is an Eclipse-based development environment that
  integrates all the convenience of Blade CLI and Liferay Workspace into
  a best-of-breed graphical environment with all the bells and whistles
  you'd expect.
\item
  Liferay Developer Studio provides all that Liferay IDE provides, plus
  additional tools that enterprise developers need.
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/service-builder}{Liferay
  Service Builder} helps you create your back-end faster by generating
  all your database tables, local services, and web services from a
  single XML file.
\end{itemize}

You can choose to use or ignore Liferay's tools. The point is you have
the freedom to do that, because Liferay provides an open development
framework that's designed to meet you where you are. We hate proprietary
lock-in as much as you do, so our tools are designed to complement the
tools you're using already instead of replacing them.

Beyond build tools and IDEs are the frameworks you'll use to build
applications. Liferay's development frameworks include a lot of
functionality--comments, social relationships, user management, and lots
more--to speed up development of your applications. They help you build
applications out of well-tested, modern, scalable, skinnable building
blocks. You wind up not only with a great, functional application, but
also with one that took less time to develop, looks the way you want it
to, and performs well. This doesn't mean you're limited only to what
Liferay provides; again, you can use third-party frameworks if that's
what you like to use.

To develop portlets, Liferay provides a convenient and easy-to-use
framework called
\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-mvc-portlet}{MVCPortlet}
to make writing portlets easy, but developers are free to use any other
framework, such as Spring MVC, to create portlets. MVCPortlet uses
components to handle requests, benefiting from all the characteristics
described above (lifecycle, extensibility, ease of composition, etc.).
If you don't have a strong opinion on which framework to use, we
recommend that you try it out.

Liferay also includes a utility called
\href{/docs/7-1/tutorials/-/knowledge_base/t/service-builder}{Service
Builder} that makes it easy to create back-end database tables, an
object-relational map in Java for accessing them, and a place to put
your business logic. It can also generate JSON or SOAP web services,
giving developers a full stack for storing and retrieving data using web
or mobile clients. But that doesn't prevent you from using Java
Persistence (JPA) and generating JAX-WS web services.

In addition to the tooling, Liferay also provides many reusable
frameworks.

\subsection{Frameworks and APIs}\label{frameworks-and-apis}

Liferay's development platform provides a great framework for
application development and also offers APIs. Lots of them. You can
create applications by leveraging Liferay's many frameworks that
encapsulate features that today's applications commonly need. For
example, a commenting system lets you attach comments to any asset that
you define, whether they be assets you develop or assets that ship with
the system.
\href{/docs/7-1/tutorials/-/knowledge_base/t/asset-framework}{Assets}
are shared by the system and are represent many common elements, such as
Users, Organizations, Sites, User Groups, blog entries, and even folders
and files.

Liferay also includes many frameworks for operating on assets. A
\href{/docs/7-1/tutorials/-/knowledge_base/t/liferays-workflow-framework}{workflow
system} makes it easy to create applications that require an approval
process for users to follow. The recycle bin stores deleted assets for a
specified period of time, making it easy for users to restore data
without the intervention of an administrator. A file storage API with
multiple available back-ends makes storing and sharing files trivial.
Search is built into the system as well, and it is designed for you to
integrate it with your applications. Many of the frameworks you might
need when developing complex applications are already in Liferay; you
just need to take advantage of them: a Social Networking API,
user-generated forms with data lists, a
\href{/docs/7-1/tutorials/-/knowledge_base/t/message-bus}{message bus},
an audit system, and much more.

\subsection{Example Liferay Projects}\label{example-liferay-projects}

Enough theory. It's time for practice. A good way to get the flavor of
developing on Liferay's platform across is to show you some projects.
First, you'll see a portlet developed with MVCPortlet, showcasing the
use of components as well. Once you've seen that, the next best thing is
to see an extension. Both of these examples show you how easy it is to
build functionality following a modular paradigm.

It would be nice to show you the standard Hello World project, Liferay
style, but that would be too easy: the default template that
\href{/docs/7-1/tutorials/-/knowledge_base/t/blade-cli}{Blade CLI} or
\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-ide}{Liferay IDE}
creates already does that by default. Instead, you'll see the Hello
\emph{You} portlet. This does the same thing as Hello World, except it
adds the first name of the user to the message. If your name therefore
is John, it returns Hello, John.

Here's what the project layout looks like:

\begin{figure}
\centering
\includegraphics{./images/hello-you-portlet-layout.png}
\caption{The Hello You portlet has a simple project structure.}
\end{figure}

No new files were created after this project was generated~by Liferay's
Blade CLI tool, so this is as simple as it gets. You have your portlet
class, which is in the \texttt{.java} file. You also have two different
kinds of resources:
\href{/docs/7-1/tutorials/-/knowledge_base/t/internationalization}{language
properties} and JSP files. Finally, the \texttt{bnd.bnd} file describes
the application's metadata for the OSGi container, and the
\texttt{build.gradle} file builds the project.

Any web developer that's familiar with Java can understand the JSPs, but
some explanation is in order because of the style. Liferay's coding
style defines a single \texttt{init.jsp} that contains all the imports
and tag library initializations necessary for the front-end. This way,
any JSP can simply include \texttt{init.jsp}, and all of its imports are
satisfied. The \texttt{init.jsp} for this project was not modified from
the generated project, and it looks like this:

\begin{verbatim}
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %>

<%@ taglib uri="http://java.sun.com/portlet\_2\_0" prefix="portlet" %>

<%@ taglib uri="http://liferay.com/tld/aui" prefix="aui" %>

<%@ taglib uri="http://liferay.com/tld/portlet" prefix="liferay-portlet" %>

<%@ taglib uri="http://liferay.com/tld/theme" prefix="liferay-theme" %>

<%@ taglib uri="http://liferay.com/tld/ui" prefix="liferay-ui" %>

<liferay-theme:defineObjects />

<portlet:defineObjects />
\end{verbatim}

As you can see, all it does is declare the tag libraries you probably
want to use, and then it calls a couple of tags that makes objects from
the portlet framework available. Since there's nothing really
interesting here, you'll want to look at \texttt{view.jsp} next:

\begin{verbatim}
<%@ include file="/init.jsp" %>

<jsp:useBean id="userName" type="java.lang.String" scope="request" />

<p>

    <b>Hello, <%=userName %>!</b>

</p>
\end{verbatim}

Now we've got something. The portlet class (the Controller, in MVC
terms) has made a \texttt{userName} string available in the request, and
this JSP retrieves it and uses it to say hello to the user. The real
functionality, therefore is in the portlet class:

\begin{verbatim}
@Component(
    immediate = true,
    property = {
        "com.liferay.portlet.display-category=category.sample",
        "com.liferay.portlet.instanceable=true",
        "javax.portlet.display-name=hello-you Portlet",
        "javax.portlet.init-param.template-path=/",
        "javax.portlet.init-param.view-template=/view.jsp",
        "javax.portlet.resource-bundle=content.Language",
        "javax.portlet.security-role-ref=power-user,user"
    },
    service = Portlet.class
)
public class HelloYouPortlet extends MVCPortlet {

    @Override
    public void render(RenderRequest renderRequest, 
                    RenderResponse renderResponse)
            throws IOException, PortletException
    {
        ThemeDisplay themeDisplay = (ThemeDisplay)
                    renderRequest.getAttribute(WebKeys.THEME_DISPLAY);

        User user = themeDisplay.getUser();

        renderRequest.setAttribute("userName", 
                    user.getFirstName());



        super.render(renderRequest, renderResponse);
    }

}
\end{verbatim}

Now we're talking; here's the real stuff. At the top is the
\texttt{@Component} annotation, which tells the OSGi container how it
should treat this module. By specifying \texttt{immediate=true}, you're
saying that when this module is deployed and all of its dependencies are
satisfied, it should be started immediately instead of being
lazy-loaded. Next are several
\href{/docs/7-0/reference/-/knowledge_base/r/portlet-descriptor-to-osgi-service-property-map}{properties
specific to portlets}: the category in which it should appear in
Liferay's UI, its display name, its default view, and more. Finally, the
service--which is just a Java Interface--that it implements is defined,
which is the portlet class.

Next, you have the class itself, which extends Liferay's
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/bridges/mvc/MVCPortlet.html}{\texttt{MVCPortlet}
class} (that extends \texttt{GenericPortlet}, that implements
\texttt{Portlet}). The only method overridden is the \texttt{render()}
method, and Liferay's API is used to get the user's first name and put
it in a request attribute called \texttt{userName}.

So you can see how this works: the portlet runs and retrieves the user's
first name, puts that in the request, and then by the use of the
template path and view template properties specified in the
\texttt{@Component} annotation, forwards processing to
\texttt{view.jsp}, where the user's first name is retrieved and
displayed.

The only other item of interest is the \texttt{bnd.bnd} file:

\begin{verbatim}
Bundle-SymbolicName: com.liferay.docs.hello.you
Bundle-Version: 1.0.0
\end{verbatim}

This declares the name of the module (sometimes also called a bundle).
It's a good practice to namespace it properly to avoid name conflicts in
the container. The version is also declared, which allows the container
to manage dependencies down to the version level of a module. This is
called Semantic Versioning, and is a discussion by itself.

That's all there is to this portlet. Next, you'll see an extension,
which in many cases is even simpler than a portlet.

Liferay's UI is divided up into several areas. There's the control menu
and the product menu, which contains the add menu and the simulation
menu. You can extend the UI by deploying a module that adds what you
want. In this example, you'll add a link to the product menu, which is
the menu that by default sits in the top right of the browser:

\begin{figure}
\centering
\includegraphics{./images/product-menu-unchanged.png}
\caption{The product menu appears beneath the user's profile link.}
\end{figure}

To this, you'll add a link to this website:

\begin{figure}
\centering
\includegraphics{./images/product-menu-with-link.png}
\caption{You can add links to the product menu by deploying a
component.}
\end{figure}

As with the portlet project, this project's layout contains only a few
items that are easy to understand.

\begin{figure}
\centering
\includegraphics{./images/product-menu-project-layout.png}
\caption{The product menu project is simpler than the portlet was.}
\end{figure}

As before, you have a build script, a \texttt{bnd.bnd} file that
declares the module's name and version, and this time, only a Java class
and a language properties file.

The Java class defines only four methods:

\begin{verbatim}
@Component(
    immediate = true,
    property = {
        "product.navigation.control.menu.category.key=" +
                 ProductNavigationControlMenuCategoryKeys.USER,
        "product.navigation.control.menu.entry.order:Integer=1"
    },
    service = ProductNavigationControlMenuEntry.class
)
public class DevProductNavigationControlMenuEntry
    extends BaseProductNavigationControlMenuEntry
    implements ProductNavigationControlMenuEntry {

    @Override
    public String getIcon(HttpServletRequest request) {

        return "link";
    }

    @Override
    public String getLabel(Locale locale) {

        ResourceBundle resourceBundle = ResourceBundleUtil.getBundle(
            "content.Language", locale, getClass());

        return LanguageUtil.get(resourceBundle, "custom-message");
    }

    @Override
    public String getURL(HttpServletRequest request) {

        return "https://liferay.com";

    }

    @Override
    public boolean isShow(HttpServletRequest request) throws 
        PortalException {

        return true;
    }

}
\end{verbatim}

As before, this project was generated using a
\href{/docs/7-1/reference/-/knowledge_base/r/project-templates}{template}
from Blade CLI. The source code is part of the template; the only thing
you'll need to do is provide the link.

The first method gets the Font Awesome icon you want to use in the menu.
The next gets the ``label,'' the text that appears when a user hovers
the mouse over the link. This text is the value of the only property in
the \texttt{Language.properties} file:

\begin{verbatim}
custom-message=Liferay Developer Network
\end{verbatim}

The next method returns the URL that's the destination for this link,
and the final method returns a boolean for showing or hiding the link.

When you
\href{/docs/7-1/reference/-/knowledge_base/r/project-templates}{deploy
this module} and the module starts, the link appears in the menu. You
don't have to mess around looking in Liferay's JSP or JavaScript files
to customize the menu: it's an extension point, and it is designed to be
customized.

This is the modular paradigm for development. It helps you keep a clean
separation of your code, whether it be applications or extensions, from
Liferay's code, and it gives you the power to customize the system
dynamically, while it's running, to avoid downtime. It is a different
way of doing things, but we believe it's a better way. When you start
working with modules and see the benefits you can gain, we think you'll
agree.

\section{Starting Module Development}\label{starting-module-development}

Developing modules for Liferay DXP requires:

\begin{itemize}
\item
  \textbf{Creating a folder structure}: A good folder structure
  facilitates evolving and maintaining code, especially in
  collaboration. Popular tools use pre-defined folder structures you're
  familiar with.
\item
  \textbf{Writing code and configuration files}: A manifest, Java
  classes, and resources. Modules stubbed out with them let you focus on
  implementing logic.
\item
  \textbf{Compilation}:
  \href{/docs/7-1/tutorials/-/knowledge_base/t/configuring-dependencies}{Configuring
  dependencies} and building the module. Common build tools that manage
  dependencies include Gradle, Maven, and Ant/Ivy.
\item
  \textbf{Deployment}: Interacting with the runtime environment to
  install, monitor, and modify modules.
\end{itemize}

There are several good build tools for developing modules. This tutorial
demonstrates starting a new module using
\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-workspace}{Liferay
Workspace}. It's Liferay's opinionated build environment based on Gradle
and bnd that simplifies module development and automates much of it.

\noindent\hrulefill

\textbf{Note}: Liferay lets you develop using your favorite tools. In
addition to providing Liferay Workspace for those who don't already have
a preferred build environment, Liferay provides good support for Maven
and Gradle. The following tutorials and samples demonstrate developing
in these environments.

\begin{itemize}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/using-gradle-in-liferay-ide}{Maven
  in Liferay Dev Studio DXP},
  \href{/docs/7-1/tutorials/-/knowledge_base/t/maven}{Maven tutorials},
  and
  \href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-sample-projects}{samples}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/using-gradle-in-liferay-ide}{Gradle
  in Liferay Dev Studio DXP} and
  \href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-sample-projects}{samples}
\end{itemize}

\noindent\hrulefill

\noindent\hrulefill

\textbf{Note}: Themes and Layout Templates are not built as modules. The
\href{/docs/7-1/tutorials/-/knowledge_base/t/themes-and-layout-templates}{Themes
and Layout Templates tutorials} demonstrate creating them.

\noindent\hrulefill

Here are the steps for starting module development:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \hyperref[setting-up-a-liferay-workspace]{Set up a Liferay Workspace}
\item
  \hyperref[creating-a-module]{Create a module}
\item
  \hyperref[building-and-deploying-a-module]{Build and deploy the
  module}
\end{enumerate}

On completing this tutorial you'll have created a module and deployed it
to a local Liferay DXP bundle.

\subsection{Setting up a Liferay
Workspace}\label{setting-up-a-liferay-workspace}

Creating and configuring a Liferay Workspace (Workspace) is
straightforward using a tool called
\href{/docs/7-1/tutorials/-/knowledge_base/t/blade-cli}{Blade CLI
(Blade)}. Blade is a command line tool that creates Workspaces and
projects and performs common tasks.

\href{/docs/7-1/tutorials/-/knowledge_base/t/installing-blade-cli}{Install
Blade} if you don't already have it.

The \texttt{blade} executable is now in the system path.

You can create a Workspace in the current directory by executing this
command:

\texttt{blade\ init\ {[}workspaceName{]}}

You've created a Workspace! Its folder structure looks like the one
shown in the figure below.

\begin{figure}
\centering
\includegraphics{./images/starting-module-dev-workspace-structure.png}
\caption{Liferay Workspace aggregates projects so they can leverage the
Gradle build environment.}
\end{figure}

Workspace can be configured to use a Liferay DXP installation bundle
anywhere on the local file system. The
\texttt{liferay.workspace.home.dir} property in
\texttt{gradle.properties} sets the default bundle location to a folder
\texttt{{[}workspace{]}/bundles} (not yet created). For convenience it's
suggested to
\href{/docs/7-1/deploy/-/knowledge_base/d/preparing-for-install}{install
a bundle} there. If you install it to a different location, uncomment
the \texttt{liferay.workspace.home.dir} property and set it to that
location.

\noindent\hrulefill

\textbf{Note}: User interfaces in Liferay Dev Studio DXP let you create
and import Liferay Workspace projects.

To create a project, follow the tutorial
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-a-liferay-workspace-with-liferay-ide}{Creating
a Liferay Workspace Project with Liferay Dev Studio DXP}.

To import a project, use the wizard from \emph{File → Import → Liferay →
Liferay Workspace Project}.

\noindent\hrulefill

The Workspace is ready for creating modules.

\subsection{Creating a Module}\label{creating-a-module}

Blade provides project \emph{templates} and \emph{sample} projects. The
templates stub out files for different types of modules. The samples can
be generated in a Workspace and demonstrate many module types. Templates
and samples help you create modules fast.

\subsubsection{Using Module Templates}\label{using-module-templates}

The Blade command \texttt{blade\ create\ -l} lists the project
templates.

\begin{figure}
\centering
\includegraphics{./images/starting-module-dev-blade-templates.png}
\caption{Blade's \texttt{create} command generates a project based on a
template. Executing \texttt{create\ -l} lists the template names.}
\end{figure}

\noindent\hrulefill

\textbf{Note}:
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-modules-with-liferay-ide}{Liferay
Dev Studio DXP's module wizard} lets you select a module project
template.

\noindent\hrulefill

Here's the command syntax for creating a module:

\begin{verbatim}
blade create [options] moduleName
\end{verbatim}

Module templates and their options are described
\href{/docs/7-1/reference/-/knowledge_base/r/project-templates}{here}.

Here's an example of creating a Liferay MVC Portlet module:

\begin{verbatim}
blade create -t mvc-portlet -p com.liferay.docs.mymodule -c MyMvcPortlet my-module
\end{verbatim}

Module projects are created in the \texttt{modules} folder by default.

Here's the module project anatomy:

\begin{itemize}
\item
  \texttt{src/main/java/} → Java package root
\item
  \texttt{src/main/resources/content/} (optional) → Language properties
  root
\item
  \texttt{src/main/resources/META-INF/resources/} (optional) → Root for
  UI templates, such as JSPs
\item
  \texttt{bnd.bnd} → Specifies essential OSGi module manifest headers
\item
  \texttt{build.gradle} →
  \href{/docs/7-1/tutorials/-/knowledge_base/t/configuring-dependencies}{Configures
  dependencies} and more using Gradle
\end{itemize}

The figure below shows an MVC portlet project.

\begin{figure}
\centering
\includegraphics{./images/starting-module-dev-module-structure.png}
\caption{Liferay modules use the standard Maven folder structure.}
\end{figure}

Sample modules are another helpful development resource.

\subsubsection{Using Sample Modules}\label{using-sample-modules}

An alternative to creating a module from a template is to generate a
\emph{sample} module. Examine them or modify them for your purposes.

This command lists the sample names:

\begin{verbatim}
blade samples
\end{verbatim}

The figure below shows the listing.

\begin{figure}
\centering
\includegraphics{./images/starting-module-dev-blade-samples.png}
\caption{The \texttt{blade\ samples} command lists the sample modules
you can create, examine, and modify to meet your needs.}
\end{figure}

Here's the Blade samples command syntax:

\begin{verbatim}
blade samples [sampleName]
\end{verbatim}

It creates the sample project in a subfolder.

Building a module and deploying it to Liferay is easy.

\subsection{Building and Deploying a
Module}\label{building-and-deploying-a-module}

Liferay Workspace provides Gradle tasks for building and deploying
modules. Blade's \texttt{blade\ gw} command lets you invoke the Gradle
wrapper from any project folder. You can use \texttt{blade\ gw} just as
you would invoke \texttt{gradlew}, without having to specify the wrapper
path.

\noindent\hrulefill

\textbf{Note}: For an even simpler Gradle wrapper command, install
\emph{gw}.

\texttt{(sudo)\ jpm\ install\ gw@1.0.1}

Usage: \texttt{gw\ \textless{}task\textgreater{}}

\noindent\hrulefill

In a module folder, execute this command to list the Gradle tasks
available:

\begin{verbatim}
blade gw tasks
\end{verbatim}

Workspace uses bnd to generate the module's OSGi \texttt{MANIFEST.MF}
file and package it in the module JAR. To compile the module and
generate the module JAR, execute the \texttt{jar} Gradle task:

\begin{verbatim}
blade gw jar
\end{verbatim}

The generated JAR is in the module project's \texttt{build/libs} folder
and ready for deployment.

Start your Liferay DXP server, if you haven't already started it.

\noindent\hrulefill

\textbf{Tip}: To open a new terminal window and the Workspace's Liferay
DXP server (bundled with Tomcat or JBoss/Wildfly), execute this command:

\texttt{blade\ server\ start\ -b}

\noindent\hrulefill

Blade deploys modules to the local Liferay server. It communicates with
the OSGi framework using Felix Gogo shell and deploys modules directly
to the OSGi container using Felix File Install commands. The command
above uses the default port \texttt{11311}.

To deploy the module, execute this command:

\begin{verbatim}
blade deploy
\end{verbatim}

It deploys modules in the current folder tree. For example, executing
\texttt{blade\ deploy} in the \texttt{{[}workspace{]}/modules} folder
deploys all the modules in that folder and its subfolders.

Liferay Dev Studio DXP lets you deploy modules by dragging them from the
Package Explorer onto the Liferay server. Dev Studio DXP provides access
to
\href{/docs/7-1/tutorials/-/knowledge_base/t/managing-projects-with-liferay-ide}{Liferay
Workspace Gradle tasks} too.

\begin{figure}
\centering
\includegraphics{./images/starting-module-dev-drag-module.png}
\caption{Liferay Dev Studio DXP lets you deploy modules using
drag-and-drop.}
\end{figure}

\noindent\hrulefill

\textbf{Note:}
\href{/docs/7-1/tutorials/-/knowledge_base/t/deploying-projects-with-blade-cli}{Blade
CLI directly installs modules into the OSGi container}. Blade stores the
module differently in Liferay than if you were to copy the module into
the \texttt{LIFERAY\_HOME/deploy} folder.

\noindent\hrulefill

Once you've deployed a portlet module, it's available in the Liferay UI
under the application category and name you specified via the
\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-mvc-portlet\#liferay-mvc-portlet-component}{portlet
component's \texttt{com.liferay.portlet.display-category} and
\texttt{javax.portlet.display-name} properties}.

\begin{figure}
\centering
\includegraphics{./images/starting-module-dev-portlet.png}
\caption{Here's a bare-bones portlet based on a project template.}
\end{figure}

\subsection{Redeploying Module Changes
Automatically}\label{redeploying-module-changes-automatically}

Blade lets you set a \emph{watch} on changes to a module project's
output files. If they're modified, Blade redeploys the module
automatically. To set a watch on a module at deployment, execute this
command in the module project:

\begin{verbatim}
blade deploy -w
\end{verbatim}

Here's output from deploying (and watching) a module named
\emph{com.liferay.docs.mymodule}:

\begin{verbatim}
E:\workspaces\my-liferay-workspace\modules\my-module-project>blade deploy -w

:modules:my-module-project:compileJava UP-TO-DATE
:modules:my-module-project:buildCSS UP-TO-DATE
:modules:my-module-project:processResources UP-TO-DATE
:modules:my-module-project:transpileJS SKIPPED
:modules:my-module-project:configJSModules SKIPPED
:modules:my-module-project:classes UP-TO-DATE
:modules:my-module-project:jar UP-TO-DATE
:modules:my-module-project:assemble UP-TO-DATE
:modules:my-module-project:build

BUILD SUCCESSFUL

Total time: 2.962 secs
install file:/E:/workspaces/my-liferay-workspace/modules/my-module-project/build/libs/com.liferay.docs.mymodule-1.0.0.jar
Bundle ID: 505
start 505

Scanning E:\workspaces\my-liferay-workspace\modules\my-module-project

...

Waiting for changes to input files of tasks... (ctrl-d then enter to exit)
\end{verbatim}

The command output indicates that the module is installed and started,
reports the module's OSGi bundle ID, and stands ready to deploy changes
to the module.

Congratulations on a great start to developing your module!

\subsection{Related Articles}\label{related-articles}

\href{/docs/7-1/tutorials/-/knowledge_base/t/configuring-dependencies}{Configuring
Dependencies}

\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-workspace}{Liferay
Workspace}

\href{/docs/7-1/tutorials/-/knowledge_base/t/tooling}{Tooling}

\href{/docs/7-1/tutorials/-/knowledge_base/t/osgi-basics-for-liferay-development}{OSGi
Basics for Liferay Development}

\href{/docs/7-1/tutorials/-/knowledge_base/t/portlets}{Portlets}

\section{Configuring Dependencies}\label{configuring-dependencies}

Using external artifacts in your project requires configuring their
dependencies. To do this, look up the artifact's attributes and plug
them into dependency entries for your build system (either
\href{https://gradle.org/}{Gradle},
\href{https://maven.apache.org/}{Maven}, or
\href{http://ant.apache.org/ivy/}{Ant/Ivy}). Your build system downloads
the dependency artifacts your project needs to compile successfully.

Before specifying an artifact as a dependency, you must first find its
attributes. Artifacts have these attributes:

\begin{itemize}
\tightlist
\item
  \emph{Group ID}: Authoring organization
\item
  \emph{Artifact ID}: Name/identifier
\item
  \emph{Version}: Release number
\end{itemize}

\noindent\hrulefill

\textbf{Note:} The
\href{/docs/7-1/user/-/knowledge_base/u/managing-and-configuring-apps}{App
Manager} shows each module's version number.

\noindent\hrulefill

This tutorial shows you how to make sure your projects have the right
dependencies:

\begin{itemize}
\tightlist
\item
  \hyperref[finding-core-artifacts]{Find Core Liferay DXP artifacts}
\item
  \hyperref[finding-liferay-app-and-independent-artifacts]{Find Liferay
  DXP app and independent artifacts}
\item
  \hyperref[configuring-dependencies]{Configure dependencies}
\end{itemize}

\subsection{Finding Core Artifacts}\label{finding-core-artifacts}

Each Liferay artifact is a JAR file whose \texttt{META-INF/MANIFEST.MF}
file contains the artifact's OSGi metadata. The manifest also specifies
the artifact's attributes. For example, these two OSGi headers specify
the artifact ID and version:

\begin{verbatim}
Bundle-SymbolicName:  [artifact ID]
Bundle-Version: [version]
\end{verbatim}

\noindent\hrulefill

\textbf{Important:} Artifacts in Liferay DXP fix packs override Liferay
DXP installation artifacts. Subfolders of a fix pack ZIP file's
\texttt{binaries} folder hold the artifacts. If an installed fix pack
provides an artifact you depend on, specify the version of that fix pack
artifact in your dependency.

\noindent\hrulefill

This table lists the group ID, artifact ID, version, and origin for each
core Liferay DXP artifact:

\emph{Core Liferay DXP Artifacts}:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 8\tabcolsep) * \real{0.2364}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 8\tabcolsep) * \real{0.2909}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 8\tabcolsep) * \real{0.1636}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 8\tabcolsep) * \real{0.1818}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 8\tabcolsep) * \real{0.1273}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
File
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Group ID
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Artifact ID
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Version
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Origin
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{portal-kernel.jar} & \texttt{com.liferay.portal} &
\texttt{com.liferay.portal.kernel} & (see JAR's \texttt{MANIFEST.MF}) &
fix pack ZIP, Liferay DXP installation, or Liferay DXP dependencies
ZIP \\
\texttt{portal-impl.jar} & \texttt{com.liferay.portal} &
\texttt{com.liferay.portal.impl} & (see JAR's \texttt{MANIFEST.MF}) &
fix pack ZIP or Liferay DXP \texttt{.war} \\
\texttt{portal-test.jar} & \texttt{com.liferay.portal} &
\texttt{com.liferay.portal.test} & (see JAR's \texttt{MANIFEST.MF}) &
fix pack ZIP or Liferay DXP \texttt{.war} \\
\texttt{portal-test-integration.jar} & \texttt{com.liferay.portal} &
\texttt{com.liferay.portal.test.integration} & (see JAR's
\texttt{MANIFEST.MF}) & fix pack ZIP or Liferay DXP \texttt{.war} \\
\texttt{util-bridges.jar} & \texttt{com.liferay.portal} &
\texttt{com.liferay.util.bridges} & (see JAR's \texttt{MANIFEST.MF}) &
fix pack ZIP or Liferay DXP \texttt{.war} \\
\texttt{util-java.jar} & \texttt{com.liferay.portal} &
\texttt{com.liferay.util.java} & (see JAR's \texttt{MANIFEST.MF}) & fix
pack ZIP or Liferay DXP \texttt{.war} \\
\texttt{util-slf4j.jar} & \texttt{com.liferay.portal} &
\texttt{com.liferay.util.slf4j} & (see JAR's \texttt{MANIFEST.MF}) & fix
pack ZIP or Liferay DXP \texttt{.war} \\
\texttt{util-taglibs.jar} & \texttt{com.liferay.portal} &
\texttt{com.liferay.util.taglib} & (see JAR's \texttt{MANIFEST.MF}) &
fix pack ZIP or Liferay DXP \texttt{.war} \\
\texttt{com.liferay.*} JAR files & \texttt{com.liferay} & (see JAR's
\texttt{MANIFEST.MF}) & (see JAR's \texttt{MANIFEST.MF}) & fix pack ZIP,
Liferay DXP installation, Liferay DXP dependencies ZIP, or the OSGi
ZIP \\
\end{longtable}

Next, you'll learn how to find artifacts for Liferay DXP apps and
independent modules.

\subsection{Finding Liferay App and Independent
Artifacts}\label{finding-liferay-app-and-independent-artifacts}

Independent modules and modules that make up Liferay DXP's apps aren't
part of the Liferay DXP core. You must still, however, find their
artifact attributes if you want to declare dependencies on them. The
resources below provide the artifact details for Liferay DXP's apps and
independent modules:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.3750}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.6250}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Resource
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Artifact Type
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\hyperref[app-manager]{App Manager} & Deployed modules \\
\hyperref[reference-docs]{Reference Docs} & Liferay DXP modules (per
release) \\
\hyperref[maven-central]{Maven Central} & All artifact types: Liferay
DXP and third party, module and non-module \\
\end{longtable}

\noindent\hrulefill

\textbf{Important}: \texttt{com.liferay} is the group ID for all of
Liferay's apps and independent modules.

\noindent\hrulefill

The App Manager is the best source for information on deployed modules.
You'll learn about it next.

\subsubsection{App Manager}\label{app-manager}

\href{/docs/7-1/user/-/knowledge_base/u/managing-and-configuring-apps\#using-the-app-manager}{The
App Manager} knows what's deployed on your Liferay instance. You can use
it to find whatever modules you're looking for.

Follow these steps to get a deployed module's information:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In Liferay DXP, navigate to \emph{Control Panel} → \emph{Apps} →
  \emph{App Manager}.
\item
  Search for the module by its display name, symbolic name, or related
  keywords. You can also browse for the module in its app. Whether
  browsing or searching, the App Manager shows the module's artifact ID
  and version number.
\end{enumerate}

\begin{figure}
\centering
\includegraphics{./images/intro-configuring-dependencies-search-app-manager-for-module.png}
\caption{You can inspect deployed module artifact IDs and version
numbers.}
\end{figure}

\begin{figure}
\centering
\includegraphics{./images/intro-configuring-dependencies-indep-modules-in-app-manager.png}
\caption{The App Manager aggregates Liferay and independent modules.}
\end{figure}

If you don't know a deployed module's group, use the
\href{/docs/7-1/reference/-/knowledge_base/r/using-the-felix-gogo-shell}{Felix
Gogo Shell} to find it:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Navigate to the Gogo Shell portlet in the Control Panel →
  \emph{Configuration} → \emph{Gogo Shell}. You can enter commands in
  the provided Felix Gogo Shell command prompt.
\item
  Search for the module by its display name (e.g.,
  \texttt{Liferay\ Bookmarks\ API}) or a keyword. In the results, note
  the module's number. You can use it in the next step. For example,
  these results show the Liferay Bookmarks API module's number is
  \texttt{52}:

\begin{verbatim}
g! lb | grep "Liferay Bookmarks API"

   52|Active     |   10|Liferay Bookmarks API (2.0.1)
\end{verbatim}
\item
  To list the module's manifest headers, pass the module number to the
  \texttt{headers} command. In the results, note the
  \texttt{Bundle-Vendor} value: you'll match it with an artifact group
  in a later step:

\begin{verbatim}
g! headers 52

Liferay Bookmarks API (52)
--------------------------
Manifest-Version = 1.0
Bnd-LastModified = 1464725366614
Bundle-ManifestVersion = 2
Bundle-Name = Liferay Bookmarks API
Bundle-SymbolicName = com.liferay.bookmarks.api
Bundle-Vendor = Liferay, Inc.
Bundle-Version = 2.0.1
...
\end{verbatim}
\item
  Disconnect from the Gogo Shell session:

\begin{verbatim}
g! disconnect
\end{verbatim}
\item
  On \href{https://search.maven.org/}{Maven Central} or
  \href{https://mvnrepository.com}{MVNRepository}, search for the module
  by its artifact ID.
\item
  Determine the group ID by matching the \texttt{Bundle-Vendor} value
  from step 3 with a group listed that provides the artifact.
\end{enumerate}

Next, you'll learn how to use Liferay DXP's reference documentation to
find a Liferay DXP app module's attributes.

\subsubsection{Reference Docs}\label{reference-docs}

Liferay DXP's app Javadoc lists each app module's artifact ID, version
number, and display name. This is the best place to look up Liferay DXP
app modules that aren't yet deployed to your Liferay DXP instance.

\noindent\hrulefill

\textbf{Note:} To find artifact information on a Core Liferay DXP
artifact, refer to the previous section
\hyperref[finding-core-artifacts]{Finding Core artifacts}.

\noindent\hrulefill

Follow these steps to find a Liferay DXP app module's attributes in the
Javadoc:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Navigate to Javadoc for an app module class. If you don't have a link
  to the class's Javadoc, find it by browsing
  {[}https://docs.liferay.com/dxp/apps{]}(
\item
  Copy the class's package name.
\item
  Navigate to the \emph{Overview} page.
\item
  On the \emph{Overview} page, search for the package name you copied in
  step 2.
\end{enumerate}

The heading above the package name shows the module's artifact ID,
version number, and display name. Remember, the group ID for all app
modules is \texttt{com.liferay}.

\begin{figure}
\centering
\includegraphics{./images/intro-configuring-dependencies-module-info-in-javadoc-overview.png}
\caption{Liferay DXP app Javadoc overviews list each app module's
display name, followed by its group ID, artifact ID, and version number
in a colon-separated string. It's a Gradle artifact syntax.}
\end{figure}

\noindent\hrulefill

\textbf{Note}: Module version numbers aren't currently included in any
tag library reference docs.

\noindent\hrulefill

Next, you'll learn how to look up artifacts on MVNRepository and Maven
Central.

\subsubsection{Maven Central}\label{maven-central}

Most artifacts, regardless of type or origin, are on
\href{https://mvnrepository.com/}{MVNRepository} and
\href{https://search.maven.org/}{Maven Central}. These sites can help
you find artifacts based on class packages. It's common to include an
artifact's ID in the start of an artifact's package names. For example,
if you depend on the class
\texttt{org.osgi.service.component.annotations.Component}, search for
the package name \texttt{org.osgi.service.component.annotations} on one
of the Maven sites.

\noindent\hrulefill

\textbf{Note:} Make sure to follow the instructions listed earlier to
determine the version of Liferay artifacts you need.

\noindent\hrulefill

Now that you have your artifact's attribute values, you're ready to
configure a dependency on it.

\subsection{Configuring Dependencies}\label{configuring-dependencies-1}

Specifying dependencies to build systems is straightforward. Edit your
project's build file, specifying a dependency entry that includes the
group ID, artifact ID, and version number.

\noindent\hrulefill

\textbf{Note}: To configure third-party libraries in a module, see the
tutorial
\href{/docs/7-1/tutorials/-/knowledge_base/t/adding-third-party-libraries-to-a-module}{Adding
Third Party Libraries to a Module}.

\noindent\hrulefill

Note that different build systems use different artifact attribute
names, as shown below:

\emph{Artifact Terminology}

\begin{longtable}[]{@{}llll@{}}
\toprule\noalign{}
Framework & Group ID & Artifact ID & Version \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Gradle & \texttt{group} & \texttt{name} & \texttt{version} \\
Maven & \texttt{groupId} & \texttt{artifactId} & \texttt{version} \\
Ivy & \texttt{org} & \texttt{name} & \texttt{rev} \\
\end{longtable}

The following examples demonstrate configuring a dependency on Liferay's
Journal API module for Gradle, Maven, and Ivy.

\subsubsection{Gradle}\label{gradle}

Here's the dependency configured in a \texttt{build.gradle} file:

\begin{verbatim}
dependencies {
    compileOnly group: "com.liferay", name: "com.liferay.journal.api", version: "1.0.1"
    ...
}
\end{verbatim}

\subsubsection{Maven}\label{maven}

Here's the dependency configured in a \texttt{pom.xml} file:

\begin{verbatim}
<dependency>
    <groupId>com.liferay</groupId>
    <artifactId>com.liferay.journal.api</artifactId>
    <version>1.0.1</version>
</dependency>
\end{verbatim}

\subsubsection{Ivy}\label{ivy}

Here's the dependency configured in an \texttt{ivy.xml} file:

\begin{verbatim}
<dependency name="com.liferay.journal.api" org="com.liferay" rev="1.0.1" />
\end{verbatim}

\noindent\hrulefill

\textbf{Important:}
\href{/docs/7-1/reference/-/knowledge_base/r/third-party-packages-portal-exports}{Liferay
DXP exports many third-party packages}. If you're developing a WAR,
deploy it to check if the packages you're using are in the OSGi runtime
container already. If they are already in there, specify their
corresponding artifacts as being ``provided''. Here's how to specify a
provided dependency:

Maven:
\texttt{\textless{}scope\textgreater{}provided\textless{}/scope\textgreater{}}

Gradle: \texttt{providedCompile}

Don't deploy a provided package's JAR again or embed the JAR in your
project. Exporting the same package from different JARs leads to ``split
package'' issues, whose side affects differ from case to case. If the
package is in a third-party library (not an OSGi module), refer to
{[}Resolving Third

\noindent\hrulefill Party Library
Dependencies{]}(/docs/7-1/tutorials/-/knowledge\_base/t/adding-third-party-libraries-to-a-module).

\noindent\hrulefill

If you're developing a WAR that requires a different version of a
third-party package that
\href{/docs/7-1/reference/-/knowledge_base/r/third-party-packages-portal-exports}{Liferay
DXP or another module exports}, specify that package in your
\href{/docs/7-1/tutorials/-/knowledge_base/t/importing-packages}{\texttt{Import-Package:}
list}. If the package provider is an OSGi module, publish its exported
packages by deploying that module. Otherwise, follow the instructions
for
\href{/docs/7-1/tutorials/-/knowledge_base/t/adding-third-party-libraries-to-a-module}{adding
a third-party library (not an OSGi module)}.

\noindent\hrulefill

Nice! Now you know how to find artifacts and configure them as
dependencies. Now that's a skill you can depend on!

\subsection{Related Topics}\label{related-topics}

\href{/docs/7-1/user/-/knowledge_base/u/managing-and-configuring-apps}{Using
the App Manager}

\href{/docs/7-1/reference/-/knowledge_base/r/development-reference}{Reference}

\href{/docs/7-1/tutorials/-/knowledge_base/t/adding-third-party-libraries-to-a-module}{Resolving
Third Party Library Package Dependencies}

\href{/docs/7-1/tutorials/-/knowledge_base/t/tooling}{Tooling}

\href{/docs/7-1/tutorials/-/knowledge_base/t/portlets}{Portlets}

\section{Finding Extension Points}\label{finding-extension-points}

Liferay DXP provides many features that help users accomplish their
tasks. Sometimes, however, you may find it necessary to
\href{/docs/7-1/tutorials/-/knowledge_base/t/customizing}{customize a
built-in feature}. It's easy to \textbf{find} an area you want to
customize, but it may seem like a daunting task to figure out
\textbf{how} to customize it. Liferay DXP was developed for easy
customization, meaning it has many extension points you can use to add
your own flavor.

There's a process you can follow that makes finding an extension point a
breeze.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Locate the bundle (module) that provides the functionality you want to
  change.
\item
  Find the components available in the module.
\item
  Discover the extension points for the components you want to
  customize.
\end{enumerate}

This tutorial demonstrates finding an extension point. It steps through
a simple example that locates an extension point for importing LDAP
users. The example includes using Liferay DXP's
\href{/docs/7-1/user/-/knowledge_base/u/managing-and-configuring-apps\#using-the-app-manager}{Application
Manager} and
\href{/docs/7-1/reference/-/knowledge_base/r/using-the-felix-gogo-shell}{Felix
Gogo Shell}.

\subsection{Locate the Related Module and
Component}\label{locate-the-related-module-and-component}

First think of words that describe the application behavior you want to
change. The right keywords can help you easily track down the desired
module and its component. Consider the example for importing LDAP users.
Some candidate keywords for finding the component are \emph{import},
\emph{user}, and \emph{LDAP}.

The easiest way to discover the module responsible for a particular
Liferay feature is to use the Application Manager. The Application
Manager lists app suites and their included modules/components in an
easy-to-use interface. It even lists third party apps! You'll use your
keywords to target the applicable component.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open the App Manager by navigating to \emph{Control Panel} →
  \emph{Apps} → \emph{App Manager}. The top level lists app suites,
  independent apps, and independent modules.
\item
  Navigate the app suites, apps, and modules, or use Search to find
  components that might provide your desired extension point. Remember
  to check for your keywords in element names and descriptions. The
  keyword \emph{LDAP} is found in the Liferay Foundation app suite's
  list of apps and features. Select the app suite.

  \begin{figure}
  \centering
  \includegraphics{./images/ldap-keyword-app-manager.png}
  \caption{The Liferay Foundation app suite contains the LDAP
  Authentication application.}
  \end{figure}
\item
  Select the \emph{LDAP} application from the app listing.
\item
  The LDAP application only has one module, but typically, applications
  have more than one module to inspect. Select the \emph{Liferay Portal
  Security LDAP} module.

  \begin{figure}
  \centering
  \includegraphics{./images/app-manager-breakdown.png}
  \caption{The App Manager lists the module, package name, version, and
  status.}
  \end{figure}
\item
  Search through the components, applying your keywords as a guide. Copy
  the component name you think best fits the functionality you want to
  customize; you'll inspect it later using the Gogo shell.

  \begin{figure}
  \centering
  \includegraphics{./images/usermodellistener-component.png}
  \caption{The component name can be found using the App Manager.}
  \end{figure}
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** When using the Gogo shell later, understand that it can take
 several tries to find the component you're looking for; Liferay's naming
 conventions facilitate finding extension points in a manageable time frame.
\end{verbatim}

\noindent\hrulefill

Next, you'll use the Gogo shell to inspect the component for extension
points.

\subsection{Finding Extension Points in a
Component}\label{finding-extension-points-in-a-component}

Once you have the component that relates to the functionality you want
to extend, you can use the Gogo shell's Service Component Runtime (SCR)
commands to inspect it. You can execute SCR commands using
\href{/docs/7-1/tutorials/-/knowledge_base/t/blade-cli}{Liferay Blade
CLI} or in
\href{/docs/7-1/reference/-/knowledge_base/r/using-the-felix-gogo-shell}{Gogo
shell}. This tutorial assumes you're using the Gogo shell.

Execute the following command:

\begin{verbatim}
scr:info [COMPONENT_NAME]
\end{verbatim}

For the LDAP example component you copied previously, the command would
look like this:

\begin{verbatim}
scr:info com.liferay.portal.security.ldap.internal.messaging.UserImportMessageListener
\end{verbatim}

The output includes a lot of information. For this exercise, you're
interested in services the component references. They are extension
points. For example, here's the reference for the service that imports
LDAP users:

\begin{verbatim}
...
Reference: LdapUserImporter
Interface Name: com.liferay.portal.security.ldap.exportimport.LDAPUserImporter
Cardinality: 1..1
Policy: static
Policy option: reluctant
Reference Scope: bundle
...
\end{verbatim}

The \texttt{LDAPUserImporter} is the extension point for customizing the
LDAP user import process! If none of the references satisfy what you're
looking for, search other components from the App Manager.

If you plan on overriding the referenced service, you'll need to
understand the reference's policy and policy option. If the policy is
\texttt{static} and the policy option is \texttt{reluctant}, binding a
new higher ranking service in place of a bound service requires
reactivating the component or changing the target. For information on
the other policies and policy options, visit the
\href{https://osgi.org/download/r6/osgi.enterprise-6.0.0.pdf}{OSGi
specification}, in particular, sections 112.3.5 and 112.3.6. If you want
to learn how to override a component's service reference, visit the
tutorial
\href{/docs/7-1/tutorials/-/knowledge_base/t/overriding-service-references}{here}.

\textbf{Important} Not all Liferay extension points are available as
referenced services. Service references are common in Declarative
Services (DS) components, but extension points can be exposed in other
ways too. Here's a brief list of other potential extension points in
Liferay DXP:

\begin{itemize}
\tightlist
\item
  Instances of
  \texttt{org.osgi.util.tracker.ServiceTracker\textless{}S,\ T\textgreater{}}
\item
  Uses of Liferay's \texttt{Registry.getServiceTracker}
\item
  Uses of Liferay's \texttt{ServiceTrackerMap} or
  \texttt{ServiceTrackerCollection}
\item
  Any other component framework or whiteboard implementation (e.g.,
  HTTP, JAX-RS) that supports tracking services; Blueprint, Apache
  Dependency Manager, etc. could also introduce extension points.
\end{itemize}

There you have it! In the App Manager, you used keywords to find the
module component whose behavior you wanted to change. Then you used Gogo
shell to find the component extension point for implementing your
customization.

\chapter{Introduction to Front-End
Development}\label{introduction-to-front-end-development}

Liferay DXP offers complete developer front-end freedom. Whether you
like coding JavaScript by hand, have used Liferay's front-end frameworks
in the past, or prefer jQuery, Lodash, or modules, you can use your
front-end framework of choice.

Prior users of Liferay DXP can continue to use Liferay's venerable Alloy
UI, but you can also use the front-end technologies you love the most:

\begin{itemize}
\tightlist
\item
  EcmaScript ES2015+
\item
  \href{https://metaljs.com/}{Metal.js} (developed by Liferay)
\item
  \href{https://alloyui.com/}{AlloyUI} (developed by Liferay)
\item
  jQuery (included)
\item
  Lodash (included)
\end{itemize}

To load modules, you must know when they are needed, where they are at
build time, if you want to bundle them together or load them
independently, and you must assemble them at runtime. Keeping track of
these tasks can be a hassle. Liferay DXP's Loaders (YUI/AUI, AMD, and
npm in AMD format) handle loading for you, so you don't have to worry
about all the details. Just provide a small bit of information about
your module, and Liferay DXP's loaders take care of the rest.

If you want to use npm packages in your applications, you can use
\href{/docs/7-1/reference/-/knowledge_base/r/liferay-npm-bundler}{\texttt{liferay-npm-bundler}}.
It is built for just this purpose, and even provides several presets for
common module types (AMD, React, Angular JS, etc.) to save you time. It
creates an OSGi bundle for you, extracts all npm dependencies, and
transpiles your code for the Liferay AMD Loader.

While developing JavaScript applications for Liferay DXP, you may need
to access Liferay DXP-specific information or web services. The
\texttt{Liferay} global JavaScript Object
\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-javascript-apis}{exposes
this information for you}, letting you harness the power of Liferay DXP
in your JavaScript applications, while still using the front-end
frameworks and technologies that you love.

\section{Lexicon and Clay}\label{lexicon-and-clay}

Liferay DXP uses its own design language, called
\href{https://liferay.design/lexicon}{Lexicon}, to provide a common
framework for building consistent UIs and user experiences across the
Liferay product ecosystem. The web implementation of Lexicon (CSS, JS,
and HTML) is called \href{https://clayui.com/}{Clay}. It is
automatically available to application developers through a set of CSS
classes or our
\href{/docs/7-1/tutorials/-/knowledge_base/t/using-the-clay-taglib-in-your-portlets}{tag
library}.

\section{Templates}\label{templates}

For templating, you can use Java EE's JSP, FreeMarker, Google's
\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-soy-portlet}{Soy
(aka Closure Templates)}, or whatever else you like.

\section{Themes}\label{themes}

A Liferay DXP Theme provides the look and feel for a site. Themes are a
combination of CSS, JavaScript, HTML, and FreeMarker templates. Although
the default themes are nice, you may wish to create your own look and
feel for your site.

From the
\href{/docs/7-1/reference/-/knowledge_base/r/theme-builder-gradle-plugin}{Theme
Builder Gradle Plugin}, to the
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-themes}{Liferay
Theme Generator}, to
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-themes-with-liferay-ide}{Dev
Studio DXP}, to
\href{/docs/7-1/tutorials/-/knowledge_base/t/blade-cli}{Blade CLI}'s
\href{/docs/7-1/reference/-/knowledge_base/r/theme-template}{Theme
Template}, you can choose the development tools you like best, so you
can focus on creating a well designed theme.

\section{Front-End Extensions}\label{front-end-extensions}

Liferay DXP's modularity has many benefits for the front-end developer,
in the form of development customizations and extension points. These
extensions assure the stability, conformity, and future evolution of
your applications.

Below are some of the available front-end extensions:

\begin{itemize}
\tightlist
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/packaging-independent-ui-resources-for-your-site}{Theme
  Contributors}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/injecting-additional-context-variables-into-your-templates}{Context
  Contributors}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/creating-configurable-styles-for-portlet-wrappers}{Creating
  Configurable Styles for Portlet Wrappers}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/adding-new-behavior-to-an-editor}{Dynamic
  Includes}
\end{itemize}

Read on to learn more.

\chapter{From Liferay Portal 6 to 7}\label{from-liferay-portal-6-to-7}

Becoming familiar with a platform as large and fully featured as Liferay
is a big task. You learn the ins and outs of what it can do, the tips
and best practices of the experts, and you work your way through the
APIs. As you do this, you become familiar with how things work,
proficient with the platform, and start to think in terms of how you'd
solve problems most effectively using the platform's tools.

7.0 was designed as an enhancement that builds off of what you already
know. Its Upgrade Planner and this Learning Path help get your existing
plugins running on 7.0 right away. The tool automates much of the
process. After you upgrade your plugins, you can build and deploy them
as you always have.

7.0 has exciting improvements for developers too. Since you already know
previous versions of Liferay Portal, you're several steps ahead of
everybody else.

Here you'll learn about the benefits of 7.0 for developers compared to
previous versions, the architectural improvements, the benefits that
modularity brings, how to develop modules, and how they differ from
traditional plugins. You'll see all the options for leveraging new
developer features, learn the pros and cons of each, and examine steps
for optimizing your existing plugins for 7.0.

\noindent\hrulefill

\textbf{Note}: If you want to learn about 7.0's architectural
improvements, OSGi and modularity, and tooling improvements, read on. If
you're more interested in upgrading your plugins first, skip to
\href{/docs/7-1/tutorials/-/knowledge_base/t/migrating-existing-code-to-liferay-7}{Planning
Plugin Upgrades and Optimizations}.

\noindent\hrulefill

You'll start by seeing the familiar, good things that remain the same
and then examine what's changed the most since Liferay Portal 6.

\section{What Hasn't Changed and What
Has}\label{what-hasnt-changed-and-what-has}

Liferay 7.0 was a new major version of the Liferay platform and as such
it included many improvements over previous versions. Having said that,
most of the characteristics from Liferay Portal 6 that you have learned
to love are preserved, having been changed only slightly or not at all.
Any experienced Liferay developer will be able to reuse most of his/her
existing knowledge to developing for 7.0.

What has not changed? Even though there are many improvements in Liferay
7, there are also many great familiar aspects from previous versions
that have been preserved. Here are some of the most relevant ones:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  The Portal Core and each Liferay app continue to use the three layer
  architecture: presentation, services, and persistence. The
  presentation layer is now always provided as an independent module,
  making it easier to replace with a different presentation, if desired.
\item
  Support remains for previously supported standards such as Portlets
  (JSR-168, JSR-286), CMIS, WebDAV, LDAP, JCP (JSR-170), etc.
\item
  Most Liferay APIs have remained functionally similar to those of 6.2,
  even if many of their classes have moved to new packages, as part of
  the modularization effort.
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-ide}{Liferay Dev
  Studio DXP} is still the preferred tool to develop for Liferay, even
  though you are still free to use tools that best fit your needs.
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/service-builder}{Service
  Builder} and other developer tools and libraries continue to work as
  they have in 6.2.
\item
  Traditional plugins for portlets and hooks still work (once they're
  adapted to 7.0's API) through a
  \href{/docs/7-1/tutorials/-/knowledge_base/t/using-the-wab-generator}{compatibility
  layer}.
\end{enumerate}

Here are some key changes of interest to existing Liferay developers:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Extraction of many features as modules: So far you have been used to
  working with Liferay as a large web application, of which all of it
  had to be deployed or none of it. In 7.0, many out of the box
  portlets, features, and associated APIs have been extracted as OSGi
  modules. You can choose which ones to deploy and use.
\item
  Adoption of modern OSGi standards:
  \href{/docs/7-1/tutorials/-/knowledge_base/t/modularity-and-osgi}{OSGi
  is a set of standards for building modular systems}. It's very
  powerful. Although it was previously difficult to learn and use, its
  modernized standards, such as Declarative Services, have made learning
  and using it much easier.
\item
  Core Public APIs are provided through portal-kernel (previously known
  as portal-service); all other public APIs are provided by their own
  modules.
\item
  You can reuse modules and libraries, and manage the dependencies among
  them.
\item
  Registration of classes implementing extension points is now simpler
  and more consistent; it's based on the standard \texttt{@Component}
  annotation instead of declarations in \texttt{portal.properties} or
  \texttt{portlet.xml}. Note, previous registration mechanisms have been
  preserved where possible. See the
  \href{/docs/7-1/reference/-/knowledge_base/r/breaking-changes}{Breaking
  Changes} article to examine where extensions and configurations that
  have not kept backwards compatibility.
\item
  Third party extensions and applications are now first-class citizens.
  Traditional plugins had some limitations that developments done in the
  core (or done as Ext Plugins) did not have. Modules don't have these
  limitations and are much more powerful than plugins ever were.
\item
  Complete integration of Liferay specific tools (such as Service
  Builder) within
  \href{/docs/7-1/tutorials/-/knowledge_base/t/maven}{Maven} and
  \href{/docs/7-1/reference/-/knowledge_base/r/gradle}{Gradle}.
  Additionally we've adopted some new tools such as bnd.
\item
  The Plugins SDK is no longer available. Visit the
  \href{/docs/7-1/deploy/-/knowledge_base/d/deprecated-apps-in-7-1-what-to-do\#foundation}{Deprecated
  Apps in 7.1: What To Do} article for more information on the Plugins
  SDK removal.
  \href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-workspace}{Liferay
  Workspace}, is now Liferay's opinionated development environment.
\end{enumerate}

Since the modularization of the Liferay web application is the change
most relevant to you as a developer, let's dig deeper into that change
and how it affects Liferay's architecture.

\subsection{Embracing a Modular
Architecture}\label{embracing-a-modular-architecture}

The largest improvement in Liferay's architecture is the adoption of a
modular development paradigm. Within each Liferay module (or group of
modules that form an app), as well as within what remains as Liferay's
core, the existing great characteristics of previous versions of Liferay
prevail.

\subsubsection{Tiered Architecture}\label{tiered-architecture}

Liferay Portal 6's architecture diagrams often focused on the tiers for
the frontend, services layer (for the business logic), and persistence
layer (mostly auto-generated by Service Builder). These layers still
exist and have been embraced throughout the modularization effort.

\begin{figure}
\centering
\includegraphics{./images/from-liferay-6-liferay-6-architecture.png}
\caption{Liferay Portal 6's architecture, shown in this figure, is still
generally valid in 7.0.}
\end{figure}

The most significant change (and improvement) over this architecture is
that the portal is no longer a single large Java EE Web Application.
Liferay Portal has been broken down into many modules to benefit from
the
\href{/docs/7-1/tutorials/-/knowledge_base/t/the-benefits-of-modularity}{Modular
Development Paradigm}. Those benefits are described in the next section.
The modules are often grouped into apps (such as Wiki or Message Boards)
and the main apps are grouped into suites (such as Web Experience,
Collaboration, and Forms \& Workflow).

\subsubsection{Modular Architecture}\label{modular-architecture}

The figure below represents 7.0's architecture from a structural
perspective.

\begin{figure}
\centering
\includegraphics{./images/from-liferay-6-core-suites-and-apps.png}
\caption{7.0 is composed of the Liferay Core, independent application
modules, and App Suites, each with their own set of application and
framework modules.}
\end{figure}

\paragraph{Liferay Core}\label{liferay-core}

As its name implies, it's 7.0's central and most important part. The
Liferay Core is a Java EE application in charge of bootstrapping the
system and receiving and delegating all requests. It also contains
Liferay's OSGi Engine on top of which all applications run.

\paragraph{Foundation}\label{foundation}

The Foundation suite sits on top of the core, providing administrative
interfaces and familiar development building blocks. It includes modules
for user and role administration, LDAP integration, authentication,
licensing, upgrades, clustering, DAO, and front-end mainstays for
themes, CSS, taglibs, and JavaScript. The Foundation suite's modules
depend on Liferay Core, as do all the App Suites and non-core modules.

Most of the apps, frameworks, and APIs you've come to know and love have
been aggregated in App Suites. The suites are available in Liferay
bundles and are also available on the Marketplace. Here are the
different App Suites:

\paragraph{Liferay Web Experience}\label{liferay-web-experience}

Contains apps such as Web Content and Site management, Web Content
Display, Asset Publisher, and Breadcrumbs and features and frameworks
such as Application Display Templates, Tags, and Recycle Bin.

\paragraph{Liferay Collaboration}\label{liferay-collaboration}

Comprises Liferay's social apps and collaboration apps, such as Message
Boards, Wiki, and Blogs. It also contains Liferay's Documents \& Media
Library.

\paragraph{Liferay Forms and Workflow}\label{liferay-forms-and-workflow}

Provides apps such as Forms (New!), Dynamic Data Lists, Kaleo Workflow,
and Calendar. It also contains the Dynamic Data Mapping framework used
by Web Content and Documents \& Media to provide custom form and
templating capabilities.

\paragraph{Independent Apps}\label{independent-apps}

Last but not least, Liferay's independent apps and modules also play a
part. They provide unique functionality and stand on their own; it would
be unnatural to add any one of them to a particular suite. Apps such as
Liferay Sync, the Marketplace Client, Knowledge Base, and many more apps
available on the Marketplace are independent Liferay apps.

The beauty of the Liferay ecosystem is that it is made up of simple
easy-to-use modules that depend on and communicate with each other. And
you as a third-party developer can create and deploy your own modules
into the mix.

You can continue developing traditional WAR-style apps for Liferay too.
The
\href{/docs/7-1/tutorials/-/knowledge_base/t/using-the-wab-generator}{Portlet
Compatibility Layer} converts each plugin WAR to a Web Application
Bundle (WAB), which is a module.

Let's consider the structure of a Liferay DXP modular app.

\subsubsection{The Structure of a Modular
App}\label{the-structure-of-a-modular-app}

As mentioned, each app can be formed by one or more modules. This
section explains the most common way to structure an app.

The best practice for structuring an app is in several modules. In
particular the following modules are the often the best way of
structuring an app:

\begin{itemize}
\item
  \textbf{Service}: Contains the service (business logic) and
  persistence implementations.
\item
  \textbf{API}: Contains the public API of the application. By being
  separate from the service, it's simpler and faster to deploy new
  versions of the implementation without affecting any module using the
  API. It also allows changing the versioning of the implementation
  independent from the versioning of the API.
\item
  \textbf{Web}: Contains the presentation tier, very often the portlets
  provided by this app.
\item
  \textbf{Test}: Contains the tests. These are not included in the app
  for production.
\item
  \textbf{Specific purpose modules}: Other modules are also often
  created for specific purposes or to provide alternative
  implementations of some of the app's features. For example the Wiki
  app has one module for each of the supported Wiki Engines.
\end{itemize}

All the modules in an app usually sit in folders next to each other in
the source to facilitate referencing them.

For deployment to production Liferay provides the LPKG packaging format
that allows bundling a set of modules into a single file and add
additional metadata about it. This format can also be used to upload
apps to \href{http://marketplace.liferay.com}{Liferay's Marketplace}.

Now you have a basic understanding of the architectural changes
introduced in Liferay 7 and have become acquainted with the new
structure used in Liferay's apps. You have learned some key concepts
that are new for Liferay Portal 6 developers and have been assured about
developer features you've used in previous Liferay releases that have
been carried into Liferay 7.

Next, you'll explore how these new concepts and the new modular
architecture benefit you as a developer.

\section{Benefits of 7.1 for Liferay Portal 6
Developers}\label{benefits-of-7.1-for-liferay-portal-6-developers}

More than in any other Liferay release, 7.0 centers on you, the
developer. Liferay's platform was rebuilt in Liferay 7.0, making it
easier to build on and maintain, and providing more new developer
features than any previous Liferay release.

Here are some key benefits of this release for developers:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{Simpler and Leaner}
\item
  \textbf{Modular Development Paradigm}
\item
  \textbf{Enhanced Reusability}
\item
  \textbf{More extensible, easier to maintain}
\item
  \textbf{Optimized for your tooling of choice}
\item
  \textbf{Powerful Configurability}
\end{enumerate}

Let's consider how they make development easier for you.

\subsection{Simpler and Leaner}\label{simpler-and-leaner}

Liferay has always been simple and lean, compared to the proprietary
alternatives; Liferay 7 widens the gap even more.

Liferay 7 is simpler than its predecessors, thanks to a streamlined and
modular architecture. In addition, many Liferay specific ways of
creating extensions and applications have evolved to follow official or
de-facto standards. As a result, you can now more easily reuse your
existing knowledge and use what you learn developing for Liferay outside
of it.

Liferay 7 is also leaner. Its modularized core allows developers and
system administrators to remove parts they don't need or don't want;
this facilitates deployment, reduces startup times and memory
footprints, and results in more efficiencies and performance
improvements.

\subsection{Modular Development
Paradigm}\label{modular-development-paradigm}

If you have been using Liferay, you've already experienced some of the
benefits of modular development, thanks to plugins. 7.0 takes these
benefits to a whole new level.

In addition to building plugins as you have previously, you can take
advantage of a
\href{/docs/7-1/tutorials/-/knowledge_base/t/modularity-and-osgi}{complete
module development and runtime system based on OSGi standards}. 7.0
facilitates creating applications of all types by composing and reusing
modules.

And don't worry, modules are easy to understand. A module is distributed
as a JAR file and can be as small as one Java class or as large as any
application you can think of. An application for Liferay can comprise
one single module or as many modules as you want. The cool thing is that
modules can cooperate, allowing you to build applications by combining
smaller pieces that are easier to develop, deploy, maintain, and reuse.

\subsection{Enhanced Reusability}\label{enhanced-reusability}

If you have worked on large developments on top of Liferay you have
probably experienced situations in which you wanted to share a subset of
classes from from one plugin with another.

Java EE does not provide any standard way to achieve this, but Liferay
provided certain capabilities to achieve it with a mechanism known as
CLP that used class loader \emph{magic} to allow plugins to invoke
services in other plugins created with Service Builder. This mechanism,
however, is still a bit limited (Java EE's class loader doesn't allow
for much more) and doesn't give you the freedom to specify any or all
classes from one module to use from within another module.

7.0 enables greater reusability, both in code and runtime memory,
several folds. For any desired reusable functionality you just
\href{/docs/7-1/tutorials/-/knowledge_base/t/starting-module-development\#creating-a-module}{create
a module} (remember, it's just a JAR file with some metadata) with the
classes you want and deploy it. Other modules need only declare that
they use the classes in that module (by specifying their packages) and
7.0 automatically wires them together. All invocations are regular Java
calls! Try it out; it's beautiful. :)

This mechanism eliminates the dreaded ``JAR/classpath hell'' issue. No
longer do you have to jockey JAR files in classpaths; nor do you have to
implement intricate class loaders. The runtime environment uses separate
class spaces per module; it even accommodates using multiple versions of
libraries in the same application (as long as they can coexist).

\subsection{More Extensible, Easier to
Maintain}\label{more-extensible-easier-to-maintain}

Whenever we ask Liferay developers what is their favorite characteristic
of Liferay, ``Great extensibility'' is one of the top three most popular
responses. You can customize almost every detail and add your own
functionality on top.

Is 7.0 more extensible? You bet! Many more extension points have been
added. But not only that, all new extension points and many existing
ones which have been upgraded, use a new extension mechanism based on
OSGi's service model. Here are some of the mechanism's benefits:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{Simpler}: An implementation of an extension point is now
  always a Java class that implements an interface and has one
  annotation (\texttt{@Component}). That's it; it couldn't be any
  easier.
\item
  \textbf{Easier to maintain}: Extension points are now more strictly
  defined through a Java interface that uses Semantic Versioning rules.
  This means that your extensions can work without changes, even across
  several Liferay versions, as long as the specific extension API is
  backwards compatible.
\item
  \textbf{Dynamic}: Extensions can be loaded and removed at any time
  during development or in production.
\end{enumerate}

But that is not all. Your own developments can now also leverage this
model and become extensible. You can create simple extension points by
just creating an interface and annotating a setter method with an
annotation (\texttt{@Reference}). Implementing extensibility has never
been easier.

\subsection{Optimized for Your Tooling of
Choice}\label{optimized-for-your-tooling-of-choice}

7.0 empowers you to use the tools you like.

If you don't have strong preferences and are open to our suggestions, we
offer
\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-workspace}{Liferay
Workspace}. It provides an opinionated folder structure and build system
based on Gradle and bnd. Liferay Workspace can be used standalone
through the command line or with
\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-ide}{Liferay Dev
Studio DXP}, which runs on Eclipse.

If you have an investment in a specific build tool, such as
\href{/docs/7-1/tutorials/-/knowledge_base/t/maven}{Maven}, developing
on Liferay will be easier than ever before. We have built
\href{/docs/7-1/reference/-/knowledge_base/r/maven}{Maven plugins} for
typical Liferay-specific development tasks (such as using Service
Builder) and provide a collection of new archetypes.

The Plugins SDK is no longer available for 7.0.
\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-workspace}{Liferay
Workspace}, is now Liferay's opinionated development environment. You
can transition from a Plugins SDK by adding it to your workspace and
migrating projects at your own pace. See the
\href{/docs/7-0/tutorials/-/knowledge_base/t/configuring-a-liferay-workspace\#using-a-plugins-sdk-from-your-workspace}{Using
a Plugins SDK from Your Workspace} article for more information.

Finally, we have also developed a lightweight tool called
\href{/docs/7-1/tutorials/-/knowledge_base/t/blade-cli}{Blade CLI},
which facilitates
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-projects-with-blade-cli}{starting
new projects from templates} -- it's especially useful for Gradle which
doesn't have Maven's concept of archetypes. Blade CLI also offers
\href{/docs/7-1/tutorials/-/knowledge_base/t/blade-cli}{commands} to
start/stop the server and deploy and administer modules.

\subsection{Powerful Configurability}\label{powerful-configurability}

Creating
\href{/docs/7-1/tutorials/-/knowledge_base/t/configurable-applications}{configurable
code} is a breeze with 7.0. And applications that use Liferay's new
Configuration API allow administrators to change the configuration on
the fly, through an auto-generated user interface called
\href{/docs/7-1/user/-/knowledge_base/u/system-wide-settings}{System
Settings}.

Now you understand how 7.0 enriches your experience as a developer and
makes developing apps and customizations fun.

Next, we'll take a look at OSGi and modularity to discuss key concepts
and demonstrate how easy and gratifying it is to build modules.

\chapter{OSGi and Modularity for Liferay Portal 6
Developers}\label{osgi-and-modularity-for-liferay-portal-6-developers}

To create a powerful, reliable platform for developing modular
applications, Liferay sought best-of-breed standards-based frameworks
and technologies. It was imperative not only to meet demands for
enterprise digital experiences but also to offer developers, both
experienced with Liferay and new to Liferay, a clear and elegant way to
create apps.

Here were some of the key goals:

\begin{itemize}
\item
  Allow breaking down a large system into smaller pieces of code, whose
  boundaries and relationships could be clearly defined.
\item
  Explicitly differentiate public APIs from private APIs.
\item
  Facilitate extensibility of existing code.
\item
  Modernize the development environment, leveraging more
  state-of-the-art tools to provide a great developer experience.
\end{itemize}

It wasn't long before Liferay discovered that OSGi and its supporting
tools/technologies fit the bill!

Before setting up your tools and upgrading your plugins, you'll learn
how 7.0 uses OSGi to meet the objectives listed above. And equally
important, you'll discover how easy and fun modular development can be.

\section{Modules as an Improvement over Traditional
Plugins}\label{modules-as-an-improvement-over-traditional-plugins}

In 7.0, you can develop applications using OSGi modules or using
traditional Liferay plugins (WAR-style portlets, hooks, EXT, and web
applications). Liferay's Plugin Compatibility Layer (explained later)
makes it possible to deploy traditional plugins to the OSGi runtime
framework. To benefit from all Liferay DXP and OSGi offer, however, you
should use OSGi modules.

Modules offer these benefits:

\begin{itemize}
\item
  \textbf{Better Encapsulation} - The only classes a module exposes
  publicly are those in
  \href{/docs/7-1/tutorials/-/knowledge_base/t/exporting-packages}{packages
  it exports} explicitly. This lets you define internal public classes
  transparent to external clients.
\item
  \textbf{Dependencies by Package} - Dependencies are specified by Java
  package, not by JAR file. In traditional plugins, you had to add
  \emph{all} of a JAR file's classes to the classpath to use \emph{any}
  of its classes. With OSGi, you need only
  \href{/docs/7-1/tutorials/-/knowledge_base/t/importing-packages}{import
  packages} containing the classes you need. Only the classes in those
  packages are added to the module's classpath.
\item
  \textbf{Lightweight} - A module can be as small as you want it to be.
  In contrast to a traditional plugin, which may require several
  descriptor files, a module requires only a single descriptor file--a
  standard JAR manifest. Also, traditional plugins are typically larger
  than modules and deployed on app server startup, which can slow down
  that process considerably. Modules deploy more quickly and require
  minimal overhead cost.
\item
  \textbf{Easy Reuse} - Modules lend themselves well to developing
  small, highly cohesive chunks of code. They can be combined to create
  applications that are easier to test and maintain. Modules can be
  distributed publicly (e.g., on \href{https://search.maven.org/}{Maven
  Central}) or privately. And since modules are versioned, you can
  specify precisely the modules you want to use.
\item
  \textbf{In-Context Descriptors} - Where plugins use descriptor files
  (e.g., \texttt{web.xml}, \texttt{portlet.xml}, etc.) to describe
  classes, module classes use OSGi annotations to describe themselves.
  For example, a module portlet class can use
  \href{/docs/7-1/reference/-/knowledge_base/r/portlet-descriptor-to-osgi-service-property-map}{OSGi
  Service annotation properties} to specify its name, display name,
  resource bundle, public render parameters, and much more. Instead of
  specifying that information in descriptor files separate from the
  code, you specify them in context in the code.
\end{itemize}

These are just a few ways modules outshine traditional plugins. Note,
however, that developers experienced with Liferay plugins have the best
of both worlds. 7.0 supports traditional plugins \emph{and} modules.
Existing Liferay developers can find comfort in the simplicity of
modules and their similarities with plugins.

Here are some fundamental characteristics modules share with plugins:

\begin{itemize}
\item
  Developers use them to create applications (portlets for Liferay)
\item
  They're zipped up packages of classes and resources
\item
  They're packaged as a standard Java JARs
\end{itemize}

Now that you've compared and contrasted modules with plugins, it's time
to tour the module anatomy.

\subsection{Module Structure: A JAR File with a
Manifest}\label{module-structure-a-jar-file-with-a-manifest}

A module's structure is extremely simple. It has one mandatory file:
\texttt{META-INF/MANIFEST.MF}. You add code and resources to the module
and organize them as desired.

Here's the essential structure of a module JAR file:

\begin{itemize}
\tightlist
\item
  \texttt{{[}Project\ root{]}}

  \begin{itemize}
  \tightlist
  \item
    \texttt{{[}Module\textquotesingle{}s\ files{]}}
  \item
    \texttt{META-INF}

    \begin{itemize}
    \tightlist
    \item
      \texttt{MANIFEST.MF}
    \end{itemize}
  \end{itemize}
\end{itemize}

The \texttt{MANIFEST.MF} file describes the module to the system. The
manifest's \href{https://www.osgi.org/bundle-headers-reference/}{OSGi
headers} identify the module and its relationship to other modules.

Here are some of the most commonly used headers:

\begin{itemize}
\item
  \texttt{Bundle-Name}: User friendly name of the module.
\item
  \texttt{Bundle-SymbolicName}: Globally unique identifier for the
  module. Java package conventions (e.g.,
  \texttt{com.liferay.journal.api}) are commonly used.
\item
  \texttt{Bundle-Version}: Version of the module.
\item
  \texttt{Export-Package}: Packages from this module to make accessible
  to other modules.
\item
  \texttt{Import-Package}: Packages this module requires that other
  modules provide.
\end{itemize}

Other headers can be used to specify more characteristics, such as how
the module was built, development tools used, etc.

For example, here are some headers from the Liferay Journal Web module
manifest:

\begin{verbatim}
Manifest-Version: 1.0
Bundle-ManifestVersion: 2
Bundle-Name: Liferay Journal Web
Bundle-SymbolicName: com.liferay.journal.web
Bundle-Vendor: Liferay, Inc.
Bundle-Version: 1.1.2
Export-Package:\
    com.liferay.journal.web.asset,\
    com.liferay.dynamic.data.mapping.util,\
    com.liferay.journal.model,
    com.liferay.journal.service,com.liferay.journal.util, [..]
Import-Package:\
    aQute.bnd.annotation.metatype,\
    com.liferay.announcements.kernel.model,
    com.liferay.application.list,\
    com.liferay.asset.kernel,\
    com.liferay.asset.kernel.exception, [..]
\end{verbatim}

Note: to remove unnecessary ``noise'' from this example, some headers
have been abbreviated (\texttt{{[}..{]}}) and some have been removed.

You can organize and build a module's Java code and resources however
you like. You're free to use any folder structure conventions, such as
those used in Maven or by your development team. And you can use any
build tool, such as Gradle or Maven, to
\href{/docs/7-1/tutorials/-/knowledge_base/t/configuring-dependencies}{manage
dependencies}.

\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-workspace}{Liferay
Workspace} is an environment for managing module projects (and theme
projects). A default Workspace provides Gradle build scripts and a
Workspace created from the Liferay Project Templates Workspace archetype
provides Maven build scripts for developing on Liferay. Workspace can be
used \href{/docs/7-1/tutorials/-/knowledge_base/t/blade-cli}{from the
command line} or from within
\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-ide}{Liferay Dev
Studio DXP}. Note also that Liferay Dev Studio DXP provides plugins for
Gradle, Maven, and BndTools. Tooling details are covered later in this
series.

Now that you're familiar with the module structure and manifest, it's
time to explore how to build modules.

\subsection{Building Modules with bnd}\label{building-modules-with-bnd}

The most common way to build modules is with a little tool called
\href{http://bnd.bndtools.org/}{bnd}. It's an engine that, among other
things, simplifies generating manifest metadata. Instead of manually
creating a \texttt{MANIFEST.MF} file, developers use bnd to generate it.
bnd can be used on its own or along with other build tools, such as
Gradle or Maven. Liferay Workspace uses bnd together with Gradle or
Maven.

One of bnd's best features is that it automatically transverses a
module's code to identify external classes the module uses and adds them
to the manifest's list of packages to import. bnd also provides several
OSGi-specific operations that simplify module development.

bnd generates the manifest based on a file called \texttt{bnd.bnd} in
the project root. This file's header list is similar to (but shorter
than) that of the \texttt{MANIFEST.MF}. Compare the Liferay Journal Web
module's \texttt{bnd.bnd} file content (simplified a bit) below to its
\texttt{MANIFEST.MF} file content that was listed earlier:

\begin{verbatim}
Bundle-Name: Liferay Journal Web
Bundle-SymbolicName: com.liferay.journal.web
Bundle-Version: 1.1.2
Export-Package:\
    com.liferay.journal.web.asset,\
    com.liferay.journal.web.dynamic.data.mapping.util,\
    com.liferay.journal.web.social,\
    com.liferay.journal.web.util
\end{verbatim}

The main difference is that the \texttt{bnd.bnd} file doesn't specify an
\texttt{Import-Package} header. It's unnecessary because bnd generates
it in the \texttt{MANIFEST.MF} file automatically. It's metadata made
easy!

bnd plugins are available to use with Gradle and Maven. And since
Liferay Workspace includes bnd, you can use bnd from the command line
and from Liferay @ide@.

It's time to get hands-on experience creating and deploying an OSGi
module. That's next.

\section{Example: Building an OSGi
Module}\label{example-building-an-osgi-module}

The previous sections explained some of the most important concepts for
Liferay Portal 6 developers to understand about OSGi and modularity. Now
it's time to put this knowledge to practice by creating and deploying a
module.

The module includes a Java class that implements an OSGi service using
Declarative Services. The project uses Gradle and bnd, and can be built
and deployed from within a
\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-workspace}{Liferay
Workspace}.

Here's the module project's anatomy:

\begin{itemize}
\item
  \texttt{bnd.bnd}
\item
  \texttt{build.gradle}
\item
  \texttt{src/main/java/com/liferay/docs/service/MyService.java}
\end{itemize}

On building the module JAR, bnd generates the module manifest
automatically.

Here's the Java class:

\begin{verbatim}
package com.liferay.docs.service;

import org.osgi.service.component.annotations.Activate;
import org.osgi.service.component.annotations.Component;

@Component(
    immediate = true,
    service = MyService.class
)
public class MyService {

    @Activate
    void activate() throws Exception {

        System.out.println("Activating " + this.getDescription());
    }

    public String getDescription() {

        return this.getClass().getSimpleName();
    }

}
\end{verbatim}

It contains these methods:

\begin{itemize}
\item
  \texttt{getDescription} - returns the class's name
\item
  \texttt{activate} - prints the console message \emph{Activating
  MyService}. The \texttt{@Activate} annotation signals the OSGi runtime
  environment to invoke this method on component activation.
\end{itemize}

The \texttt{@Component} annotation defines the class as an OSGi service
component. The following properties specify its details:

\begin{itemize}
\item
  \texttt{service=MyService.class} - designates the component to be a
  service component for registering under the type \texttt{MyService}.
  In this example, the class implements a service of itself. Note,
  service components typically implement services for interface classes.
\item
  \texttt{immediate=true} - signals the Service Component Runtime to
  activate the component immediately after the component's dependencies
  are resolved.
\end{itemize}

The \texttt{bnd.bnd} file is next:

\begin{verbatim}
Bundle-SymbolicName: my.service.project
Bundle-Version: 1.0.0
\end{verbatim}

The \texttt{Bundle-SymbolicName} is the arbitrary name for the module.
The module's version value \texttt{1.0.0} is appropriate.

bnd generates the module's OSGi manifest to the file
\texttt{META-INF/MANIFEST.MF} in the module's JAR. In this project, the
JAR is created in the \texttt{build/libs} folder.

The last file to create is the Gradle build file \texttt{build.gradle}:

\begin{verbatim}
dependencies {
    compileOnly group: "org.osgi", name: "org.osgi.service.component.annotations", version: "1.3.0"
}
\end{verbatim}

Since the \texttt{MyService} class uses the \texttt{@Component}
annotation, the project depends on the OSGi service component
annotations module. The build script is so simple because Liferay
Workspace module projects leverage the Workspace's Gradle build
infrastructure.

Although this module project was created for development in a
\href{/docs/7-1/tutorials/-/knowledge_base/t/installing-liferay-workspace}{Liferay
Workspace}, it can easily be modified to use in other build
environments.

Place the project files in a subfolder of your Liferay Workspace's
\texttt{modules} folder (e.g.,
\texttt{{[}Liferay\_Workspace{]}/modules/my.service.project}).

To build the module JAR and deploy it to Liferay DXP, execute the
\texttt{deploy} Gradle task:

\begin{verbatim}
../../gradlew deploy
\end{verbatim}

\noindent\hrulefill

\textbf{Note}: If Blade is installed (recommended), Gradle can be
executed by entering \texttt{blade\ gw} followed by a task name (e.g.,
\texttt{blade\ gw\ deploy}). For details on Blade commands, see
\href{/docs/7-1/tutorials/-/knowledge_base/t/blade-cli}{Blade CLI}.

\noindent\hrulefill

On deploying the module, the following message is printed to the server
console:

\texttt{Activating\ MyService}

Congratulations! You've successfully built and deployed an OSGi module
to Liferay DXP.

Now that you've seen an OSGi module in action, you can appreciate more
of the ways modularity and OSGi improves development on Liferay. They're
explained next.

\section{More Ways OSGi Improves Development on
Liferay}\label{more-ways-osgi-improves-development-on-liferay}

Here are more ways OSGi meets the
\href{/docs/7-1/tutorials/-/knowledge_base/t/osgi-and-modularity-for-liferay-6-developers}{developer
experience goals} mentioned earlier. These topics apply to both new and
veteran Liferay developers, so you should become familiar with them.
After reading each one, make sure to COME BACK HERE to continue with the
next tutorial listed or, when you've finished reading all of them,
continue this Learning Path.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/leveraging-dependencies}{Leveraging
  Dependencies}: In 7.0, you can both declare dependencies among modules
  and combine modules to create applications. Since leveraging
  dependencies provides huge benefits, there's an entire tutorial for
  it.
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/osgi-services-and-dependency-injection-with-declarative-services}{OSGi
  Services and Dependency Injection}: OSGi includes a powerful concept
  called OSGi Services (also known as microservices). OSGi's Declarative
  Services standard provides a clean way to inject dependencies in a
  dynamic environment. It's similar to Spring DI, except the changes
  happen while the system is running. It also offers an elegant
  extensibility model that 7.0 leverages extensively.
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/dynamic-deployment}{Dynamic
  Deployment}: Module deployment is managed by 7.0 (not the application
  server). This section demonstrates how to use dynamic deployment for
  better control and efficiency.
\end{enumerate}

Liferay's developer tooling for 7.0 compliments module development. It
supports traditional plugin development and facilitates moving
applications to modules. There are improvements for developing themes
and using Maven and Gradle build systems, and there's even a Upgrade
Planner tool that adapts existing code to 7.0's API and automates much
of the plugin upgrade process. Developer tooling improvements are next.

\chapter{Improved Developer Tooling: Liferay Workspace, Maven Plugins
and
More}\label{improved-developer-tooling-liferay-workspace-maven-plugins-and-more}

Creating applications is fun when you have the right tools. Here are
some key ingredients:

\begin{itemize}
\tightlist
\item
  Rich templates for stubbing out projects
\item
  Extensible build environments that offer state-of-the-art plugins
\item
  Deployment and runtime management tools
\item
  Application upgrade automation
\end{itemize}

\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-workspace}{Liferay
Workspace} (Workspace) has all these things. It's a Gradle-based
development environment that integrates with
\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-ide}{Liferay Dev
Studio DXP} and can be used in conjunction with other IDEs, such as a
``vanilla'' Eclipse, IntelliJ, or NetBeans. You can extend Workspace's
Gradle environment with additional
\href{/docs/7-1/reference/-/knowledge_base/r/gradle}{Gradle plugins} for
testing, code coverage analysis, and more.

If you prefer \href{/docs/7-1/tutorials/-/knowledge_base/t/maven}{Maven}
over Gradle, you can use the
\href{/docs/7-1/tutorials/-/knowledge_base/t/maven-workspace}{Maven-based
Workspace} instead. 7.0's' lean artifacts and new project
\href{/docs/7-1/tutorials/-/knowledge_base/t/generating-new-projects-using-archetypes}{archetypes}
and \href{/docs/7-1/reference/-/knowledge_base/r/maven}{Maven plugins}
make Liferay DXP development with Maven easier than ever.

Workspace comes with
\href{/docs/7-1/tutorials/-/knowledge_base/t/blade-cli}{Blade CLI}: a
command line tool for creating and deploying projects, managing the
runtime environment, and more. It provides all kinds of
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-projects-with-blade-cli\#project-templates}{project
templates}, to create modules for developing in any Gradle or Maven
environment.

Liferay's tools also streamline the application upgrade process. Liferay
Dev Studio DXP's
\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-upgrade-planner}{Upgrade
Planner} adapts traditional plugins to 7.0 APIs. The
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-themes}{Liferay
Theme Generator}
\href{/docs/7-0/tutorials/-/knowledge_base/t/migrating-a-6-2-theme-to-liferay-7}{migrates}
themes and layout templates to use the new Liferay JS Theme Toolkit and
\href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-6-2-themes-intro}{adapts}
them to 7.0.

Here are the tooling improvement topics:

\begin{itemize}
\tightlist
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/from-the-plugins-sdk-to-liferay-workspace}{Moving
  from the Plugins SDK to Liferay Workspace}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/developing-modules-with-liferay-workspace}{Developing
  projects with Liferay Workspace}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/whats-new-for-maven-users}{What's
  new for Maven Users}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/using-other-build-systems-and-ides}{Using
  other build systems and IDEs}
\end{itemize}

\section{From the Plugins SDK to Liferay
Workspace}\label{from-the-plugins-sdk-to-liferay-workspace}

The Liferay Plugins SDK is not available for 7.0. Visit the
\href{/docs/7-1/deploy/-/knowledge_base/d/deprecated-apps-in-7-1-what-to-do\#foundation}{Deprecated
Apps in 7.1: What To Do} article for more information on the Plugins SDK
removal.
\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-workspace}{Liferay
Workspace} succeeds the Plugins SDK as Liferay's opinionated development
environment. You should use it if you're not using an alternative build
system like Gradle or Maven.

Here are Workspace's key features:

\begin{itemize}
\tightlist
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/creating-projects-with-blade-cli\#project-templates}{Module
  and component templates}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-sample-projects}{Sample
  projects}
\item
  Portal server configurations
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/validating-modules-against-the-target-platform}{Project
  validation}
\item
  Integration testing
\item
  Folder structure flexibility
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/blade-cli}{Commands} to
  migrate plugins, install Liferay DXP bundles, and start/stop Portal
  instances
\end{itemize}

The
\href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-plugins-to-liferay-7}{plugin
upgrade} tutorials later in this series show how
\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-ide}{Liferay Dev
Studio} automatically adapts existing plugins to 7.0. There's also a
tutorial that demonstrates how you can optionally
\href{/docs/7-1/tutorials/-/knowledge_base/t/migrating-traditional-plugins-to-workspace-web-applications}{migrate
traditional plugins to Workspace}.

\begin{figure}
\centering
\includegraphics{./images/improved-tooling-code-upgrade-configure-proj.png}
\caption{Liferay Dev Studio DXP's Upgrade Planner automates many aspects
of the plugin upgrade process.}
\end{figure}

Here's an example Workspace folder structure:

\begin{figure}
\centering
\includegraphics{./images/improved-tooling-workspace-structure.png}
\caption{Liferay Workspace aggregates projects to use the same server
configurations and Gradle build environment.}
\end{figure}

Here's the Workspace anatomy:

\begin{itemize}
\tightlist
\item
  \texttt{bundles/} (generated) → default folder for Liferay DXP bundles
\item
  \texttt{configs/} → holds Portal server configurations
\item
  \texttt{ext/} → holds Ext modules and Ext WAR files
\item
  \texttt{gradle/} → holds the Gradle wrapper files
\item
  \texttt{modules/} → holds module projects
\item
  \texttt{plugins-sdk/} (generated) → holds plugins from previous
  releases
\item
  \texttt{themes/} → holds theme projects created with the Liferay Theme
  Generator, which use the Liferay JS Theme Toolkit
\item
  \texttt{wars/} → holds traditional web application projects
\item
  \texttt{build.gradle} → common Gradle build file
\item
  \texttt{gradle-local.properties} → sets user-specific properties for
  your workspace
\item
  \texttt{gradle.properties} → specifies the Portal server configuration
  and project locations
\item
  \texttt{gradlew\ /\ gradlew.bat} → executes the Gradle command wrapper
\item
  \texttt{pom.xml} (only in Workspaces generated by Maven) → common
  Maven build file
\item
  \texttt{settings.gradle} → applies plugins to the Workspace and
  configures its dependencies
\end{itemize}

Workspace module, theme, and WAR projects use the same Portal server
configurations. Developers can create configurations for module
development, user acceptance testing, production, and more.

Each subfolder under \texttt{configs} holds a Portal server
configuration defined by its \texttt{portal-ext.properties} file. The
Gradle property \texttt{liferay.workspace.environment} in Workspace's
\texttt{gradle.properties} file specifies the configuration to use. See
the
\href{/docs/7-1/tutorials/-/knowledge_base/t/development-lifecycle-for-a-liferay-workspace\#testing-projects}{Testing
Projects} section for more details.

Other Gradle properties set root locations for the Liferay DXP bundle,
modules, themes, and a Plugins SDK. See the
\href{/docs/7-1/tutorials/-/knowledge_base/t/configuring-a-liferay-workspace\#gradle-workspace-properties}{Gradle
Workspace Properties} section for a list of all available Workspace
properties.

\subsubsection{Workspace Folder Structure
Properties}\label{workspace-folder-structure-properties}

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.4167}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.5833}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Property
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Description
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{liferay.workspace.environment} & Name of a \texttt{configs}
subfolder holding the Portal server configuration to use \\
\texttt{liferay.workspace.ext.dir} & Ext projects root folder \\
\texttt{liferay.workspace.home.dir} & Liferay DXP bundle root folder \\
\texttt{liferay.workspace.modules.dir} & Module projects root folder \\
\texttt{liferay.workspace.plugins.sdk.dir} & Plugins SDK root folder \\
\texttt{liferay.workspace.themes.dir} & Theme projects root folder \\
\texttt{liferay.workspace.wars.dir} & WAR-style projects root folder \\
\end{longtable}

Workspace has Gradle tasks equivalent to the Plugins SDK Ant targets.

\subsubsection{Plugins SDK to Workspace Task
Map}\label{plugins-sdk-to-workspace-task-map}

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.3889}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.3750}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.2361}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Plugins SDK Ant Target
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Workspace Gradle Task
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Task Description
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{build-css} & \texttt{buildCSS} & Builds CSS files \\
\texttt{build-lang} & \texttt{buildLang} & Translates language keys
using Language Builder \\
\texttt{build-service} & \texttt{buildService} & Runs Service Builder \\
\texttt{clean} & \texttt{clean} & Deletes all build outputs \\
\texttt{compile} & \texttt{classes} & Compiles classes \\
\texttt{deploy} & \texttt{deploy} (or \texttt{blade\ deploy}) & Installs
the current project to Liferay DXP's OSGi framework \\
\texttt{jar} & \texttt{jar} & Compiles the project and packages it as a
JAR file \\
\texttt{war} & \texttt{assemble} & Assembles project output \\
\end{longtable}

Other Workspace Gradle tasks provide additional functionality.

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.5870}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.4130}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Workspace Gradle Task
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Task Description
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{buildDB} & Builds database SQL scripts from the generic SQL
scripts \\
\texttt{buildSoy} & Compiles Closure Templates in JavaScript
functions \\
\texttt{components} & Lists the project's components \\
\texttt{configJSModules} & Generates the config file needed to load AMD
files via combo loader in Liferay DXP \\
\texttt{dependencies} & Lists the project's declared dependencies \\
\texttt{formatSource} & Runs Liferay Source Formatter to format project
files \\
\texttt{initBundle} & Downloads and installs a Liferay DXP bundle \\
\texttt{model} & Lists the project's configuration model \\
\texttt{projects} & Lists the project's sub-projects \\
\texttt{properties} & Lists the project's \\
\texttt{replaceSoyTranslation} & Replaces \texttt{goog.getMsg}
definitions \\
\texttt{transpileJS} & Transpiles the project's JavaScript files \\
\end{longtable}

This is just a subset of available Gradle commands in a Liferay
Workspace. Run \texttt{gradlew\ tasks} from a project in workspace for a
full list of Gradle commands.

\section{Developing Modules with Liferay
Workspace}\label{developing-modules-with-liferay-workspace}

Workspace is a great Liferay module development environment because of
these features:

\begin{itemize}
\tightlist
\item
  Templates that bootstrap module creation
\item
  Gradle and Maven build systems for managing dependencies and
  assembling modules
\item
  Module deployment and runtime management capabilities
\end{itemize}

\href{/docs/7-1/tutorials/-/knowledge_base/t/blade-cli}{Blade CLI}
(Blade), which is a part of Workspace, has over thirty templates for
Gradle and Maven-based module projects--and more are being added. The
templates stub out classes and resource files for you to fill in with
business logic and key information.

Here are some of the template's names:

\begin{itemize}
\tightlist
\item
  Activator
\item
  API
\item
  Content Targeting Report
\item
  Content Targeting Rule
\item
  Content Targeting Tracking Action
\item
  Control Menu Entry
\item
  MVC Portlet
\item
  Panel App
\item
  Portlet
\item
  Portlet Configuration Icon
\item
  Portlet Provider
\item
  Portlet Toolbar Contributor
\item
  Service
\item
  Service Builder
\item
  Service Wrapper
\item
  Simulation Panel Entry
\item
  Template Context Contributor
\item
  etc..
\end{itemize}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-projects-with-blade-cli}{Blade
creates modules} based on these templates. For a full list of these
templates, visit the
\href{/docs/7-1/reference/-/knowledge_base/r/project-templates}{Project
Templates} reference section.

For example, the following Blade command creates a Liferay MVC Portlet
module called \texttt{my-module}:

\begin{verbatim}
blade create -t mvc-portlet -p com.liferay.docs.mymodule -c MyMvcPortlet my-module
\end{verbatim}

Liferay Dev Studio DXP's
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-modules-with-liferay-ide}{module
project wizard} creates Workspace modules from the templates too.

\begin{figure}
\centering
\includegraphics{./images/improved-tooling-module-wizard.png}
\caption{Liferay Dev Studio DXP lets developers select templates to stub
out modules.}
\end{figure}

Liferay Dev Studio DXP's component wizard facilitates
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-modules-with-liferay-ide\#creating-component-classes}{creating
component classes} for portlets, service wrappers, Struts actions, and
more.

\begin{figure}
\centering
\includegraphics{./images/improved-tooling-component-wizard.png}
\caption{Liferay Dev Studio DXP's component wizard facilitates creating
component classes.}
\end{figure}

Building and deploying modules in a Workspace is a snap using
\href{/docs/7-1/tutorials/-/knowledge_base/t/deploying-projects-with-liferay-ide}{Liferay
Dev Studio DXP} and
\href{/docs/7-1/tutorials/-/knowledge_base/t/deploying-projects-with-blade-cli}{Blade}.
Workspace uses BndTools to generate each module's OSGi headers in a
\texttt{META-INF/MANIFEST.MF} file. Workspace deploys modules to the
OSGi container using Felix File Install commands.

Liferay Dev Studio DXP lets you deploy modules by dragging them onto
your Portal server.

\begin{figure}
\centering
\includegraphics{./images/improved-tooling-drag-n-drop-onto-server.png}
\caption{Liferay Dev Studio DXP lets you deploy modules using
drag-and-drop.}
\end{figure}

To learn more about Workspace and using it in Liferay Dev Studio DXP,
see
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-a-liferay-workspace-with-liferay-ide}{this
tutorial}.

In a terminal, you can deploy modules using Blade's \texttt{deploy}
command. For example, the following command deploys the current module
and
\href{/docs/7-1/tutorials/-/knowledge_base/t/starting-module-development\#redeploying-module-changes-automatically}{``watches''
for module changes to redeploy automatically}.

\begin{verbatim}
blade deploy -w
\end{verbatim}

Make sure to check out the tutorial
\href{/docs/7-1/tutorials/-/knowledge_base/t/starting-module-development}{Starting
Module Development} for even more information on module development.

\section{What's New for Maven Users}\label{whats-new-for-maven-users}

Liferay Portal 7.0+ and Liferay DXP fully support Maven development and
offers several new and improved features:

\begin{itemize}
\tightlist
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/maven-workspace}{Liferay
  Workspace for Maven}
\item
  New archetypes
\item
  New Maven plugins
\item
  More granular dependency management
\end{itemize}

The new archetype \texttt{com.liferay.project.templates.workspace}
generates a Liferay Workspace that includes a POM file for developing in
Workspace using Maven. You can develop modules and themes in the
Workspace subfolders.

7.0 provides many new Maven archetypes for various Liferay module
projects. There are over thirty
\href{/docs/7-1/reference/-/knowledge_base/r/project-templates}{Maven
archetypes} for 7.0, and more are in development. Here are some popular
ones:

\begin{itemize}
\tightlist
\item
  Configuration Icons
\item
  Fragments
\item
  Menu Buttons
\item
  Portlets

  \begin{itemize}
  \tightlist
  \item
    MVC
  \item
    npm
  \item
    Soy
  \item
    Spring MVC
  \end{itemize}
\item
  Service Builder
\item
  Themes
\item
  etc\ldots{}
\end{itemize}

Liferay's Maven archetypes cover many different Liferay frameworks and
service types. These make Maven a first-class tool for creating Liferay
modules and themes. Visit the
\href{/docs/7-1/tutorials/-/knowledge_base/t/generating-new-projects-using-archetypes}{Generating
New Projects Using Archetypes} tutorial to learn more about Liferay's
Maven archetypes and how to use them.

Liferay also provides several new and updated
\href{/docs/7-1/reference/-/knowledge_base/r/maven}{Maven plugins} that
simplify the build process. For example, the following plugins build
style sheets, services, and themes respectively:

\begin{itemize}
\tightlist
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/compiling-sass-files-in-a-maven-project}{CSS
  Builder}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/using-service-builder-in-a-maven-project}{Service
  Builder}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/building-themes-in-a-maven-project}{Theme
  Builder}
\end{itemize}

7.0's modularity provides a more granular dependency management
experience. You no longer need to depend on \texttt{portal-impl} or
\texttt{portal-service} (now \texttt{portal-kernel}) for everything. For
example, to use Liferay DXP's Wiki framework, you need only depend on
the Wiki module. You set dependencies on concise modules that provide
the functionality you want without inheriting extra baggage.

Liferay's new Workspace environment, Maven archetypes, Maven plugins,
and streamlined modules make developing on Liferay DXP easier than ever.
To learn more, see the
\href{/docs/7-1/tutorials/-/knowledge_base/t/maven}{Maven tutorials}.

\section{Using Other Build Systems and
IDEs}\label{using-other-build-systems-and-ides}

Liferay DXP is tool agnostic--you can use whatever tools you like to
develop on it. You can use any IDE and even use Gradle, Bnd, or BndTools
if you don't want to use Workspace. The drawback is you lose the
Liferay-specific project templates that you get with Blade and
Workspace.

Blade lets you create modules to develop anywhere, not only in Liferay
Workspace.

Here are some new Gradle features Liferay provides that are independent
of Workspace:

\begin{itemize}
\tightlist
\item
  Liferay's \href{/docs/7-1/reference/-/knowledge_base/r/gradle}{Gradle
  plugins}
\item
  Buildship plugins in Liferay Dev Studio DXP
\item
  Liferay Dev Studio DXP's
  \href{/docs/7-1/tutorials/-/knowledge_base/t/using-gradle-in-liferay-ide}{new
  Gradle views} for developing modules and working with Gradle tasks
\end{itemize}

Liferay has worked hard to make Liferay DXP IDE-agnostic. There are
Liferay module developers who use IntelliJ and some enjoy using
NetBeans.

Finally, you can copy and modify
\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-sample-projects}{Liferay
sample projects} to serve as templates in place of the Blade templates.
They're available for these build systems:

\begin{itemize}
\tightlist
\item
  Gradle
\item
  Liferay Workspace
\item
  Maven
\end{itemize}

Liferay's approach to tooling has vastly improved for 7.0. Our tools
help you upgrade to 7.0, continue developing traditional plugins the way
you have been, and migrate to optimal development environments. Liferay
Workspace and the improved Maven support facilitate module development.
And developing on Liferay DXP using other tools is easier than ever.
Your tool options are wide open.

\chapter{Planning Plugin Upgrades and
Optimizations}\label{planning-plugin-upgrades-and-optimizations}

If you've explored 7.0's features and possibly created new portlet
modules themes with Liferay's new
\href{/docs/7-1/tutorials/-/knowledge_base/t/improved-developer-tooling-liferay-workspace-maven-plugins-and-more}{tooling}
and
\href{/docs/7-1/tutorials/-/knowledge_base/t/osgi-and-modularity-for-liferay-6-developers}{techniques},
you may be wondering how you'd upgrade existing plugins. The great thing
is that Liferay has automated much of the upgrade process. In addition,
you can continue developing plugins in traditional ways and adopt new
development tooling and techniques when you're ready.

This tutorial guides you through phases of \emph{upgrading} plugins and
optionally \emph{optimizing} them.

\textbf{Upgrade}: A process for deploying an existing plugin on 7.0 with
minimal changes.

\textbf{Optimization}: An optional but recommended process for modifying
a plugin or migrating it to a new environment to improve the plugin or
facilitate developing it.

Importantly, you should \emph{upgrade} a plugin before applying any
optimizations to it.

The good news is that upgrading plugins to 7.0 is straightforward. For
Plugins SDK and Maven projects, Liferay Dev Studio DXP's
\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-upgrade-planner}{Upgrade
Planner} automates much of the process. In addition, the
\href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-plugins-to-liferay-7}{upgrade
tutorials} demonstrate any remaining upgrade steps.

You can deploy plugins to 7.0 as you have for previous releases (e.g.,
\texttt{ant\ clean\ deploy}). Since everything in 7.0 runs as OSGi
modules, however, you might wonder how traditional WAR-style plugins can
run on it. The answer: Liferay's Plugin Compatibility Layer.

The Plugin Compatibility Layer converts standard WARs to Web Application
Bundles (WABs). WABs are full-fledged OSGi modules. The Plugin
Compatibility Layer's
\href{/docs/7-1/tutorials/-/knowledge_base/t/using-the-wab-generator}{WAB
Generator} supports deploying traditional plugins and web applications
that contain Servlets, JSPs, and other Java web technologies without
making any OSGi specific changes to them.

Note, you can still use an application server's mechanisms to deploy
regular web applications along with Liferay DXP, without using the
Plugin Compatibility Layer.

After upgrading your plugins you can consider optimizations such as
these:

\begin{itemize}
\tightlist
\item
  Migrating plugins to
  \href{/docs/7-1/tutorials/-/knowledge_base/t/migrating-traditional-plugins-to-workspace-web-applications}{Gradle}
  or Maven to leverage their development commands and rich
  \href{/docs/7-1/tutorials/-/knowledge_base/t/developing-modules-with-liferay-workspace}{Liferay
  plugin templates}.
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/migrating-a-6-2-theme-to-liferay-7}{Migrating
  themes to the Liferay Theme Generator} to add
  \href{/docs/7-1/tutorials/-/knowledge_base/t/creating-reusable-pieces-of-code-for-your-themes}{Themelets}
  (new) and to leverage
  \href{/docs/7-1/tutorials/-/knowledge_base/t/creating-themes}{Node.js,
  Yeoman, and Gulp}.
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/modularizing-an-existing-portlet}{Converting
  plugins to modules} to leverage Declarative Services, extendability,
  and more
  \href{/docs/7-1/tutorials/-/knowledge_base/t/osgi-and-modularity-for-liferay-6-developers}{modularity
  benefits}.
\item
  Using the
  \href{/docs/7-1/tutorials/-/knowledge_base/t/applying-clay-styles-to-your-app}{Clay},
  to apply a clean consistent application user experience.
\end{itemize}

See the
\href{/docs/7-1/tutorials/-/knowledge_base/t/optimizing-plugins-for-liferay-7}{optimization
tutorials} for more options and details.

The Plugins SDK is no longer available to develop plugins for 7.0. Visit
the
\href{/docs/7-1/deploy/-/knowledge_base/d/deprecated-apps-in-7-1-what-to-do\#foundation}{Deprecated
Apps in 7.1: What To Do} article for more information on the Plugins SDK
removal.

In light of the removal, you should consider migrating plugins from the
Plugins SDK to one of the new environments:

\begin{itemize}
\tightlist
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/from-the-plugins-sdk-to-liferay-workspace}{Liferay
  Workspace} is a Gradle environment that supports developing modules
  and traditional plugins.
  \href{/docs/7-1/tutorials/-/knowledge_base/t/migrating-traditional-plugins-to-workspace-web-applications}{Blade's}
  \href{/docs/7-1/tutorials/-/knowledge_base/t/migrating-traditional-plugins-to-workspace-web-applications}{\texttt{migrateWar\ \ command}}
  moves Plugins SDK portlets to Liferay Workspace (Workspace) in a snap.
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/whats-new-for-maven-users}{Liferay's
  Maven} plugins and archetypes support developing modules and
  traditional plugins. There's also a Liferay Workspace archetype for
  generating a Workspace that uses Maven.
\end{itemize}

\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-ide}{Liferay Dev
Studio DXP} supports developing in Workspaces using Gradle or
\href{/docs/7-1/tutorials/-/knowledge_base/t/using-maven-in-liferay-ide}{Maven}.

Properly planned upgrades and optimizations reduce the time and effort
they take. To help guide you through the upgrade and optimization
tutorials, you get these things:

\begin{itemize}
\tightlist
\item
  Upgrade and optimization phase descriptions
\item
  Upgrade and optimization paths
\end{itemize}

\section{Upgrade and Optimization
Phases}\label{upgrade-and-optimization-phases}

Follow these upgrade and optimization phases:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Read the applicable
  \href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-plugins-to-liferay-7}{upgrade
  tutorials} for your plugin. Examine the upgrade and optimization
  paths.
\item
  Upgrade the plugin, making only the minimal changes necessary for it
  to work on 7.0.
\item
  (Optional) Identify and apply only the most beneficial
  \href{/docs/7-1/tutorials/-/knowledge_base/t/optimizing-plugins-for-liferay-7}{optimizations}
  for your plugin.
\item
  (Optional) Apply additional optimizations as desired.
\end{enumerate}

\subsection{Plugin Upgrade and Optimization
Paths}\label{plugin-upgrade-and-optimization-paths}

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.2222}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.4444}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Plugin
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Upgrade path
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Optimizations (optional)
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Ext &
\href{/docs/7-0/tutorials/-/knowledge_base/t/advanced-customization-with-ext-plugins}{Customization
with Ext Plugins} & None \\
Hook - Language files & -
\href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-core-language-key-hooks}{Upgrading
Core Language Key Hooks}-
\href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-portlet-language-key-hooks}{Upgrading
Portlet Language Key Hooks} & Same \\
Hook - Override a Liferay DXP Core JSP &
\href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-core-jsp-hooks}{Upgrading
Core JSP Hooks} & Same \\
Hook - Override an app's JSP &
\href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-app-jsp-hook-plugins}{Upgrading
App JSP Hooks} & Same \\
Hook - Event Actions (Portal/Session/Servlet Service/Shutdown/Startup) &
\href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-portal-property-and-event-action-hooks}{Upgrading
Portal Property and Event Action Hooks} & None \\
Hook - Model Listeners &
\href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-model-listener-hooks}{Upgrading
Model Listener Hooks} & Same \\
Hook - Portal Properties &
\href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-portal-property-and-event-action-hooks}{Upgrading
Portal Property and Event Action Hooks} & Same \\
Hook - Properties & - If the property is now a
\href{/docs/7-1/user/-/knowledge_base/u/system-settings}{System
Setting}, edit it there and/or use a \texttt{.config} file- If the
property is in the
\href{https://docs.liferay.com/dxp/portal/7.1-latest/definitions/liferay-hook_7_1_0.dtd.html}{liferay-hook.xml's
DTD}, then
\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-upgrade-planner}{adapt
code to API} and
\href{/docs/7-1/tutorials/-/knowledge_base/t/resolving-a-plugins-dependencies}{resolve
dependencies} & None \\
Hook - Service Wrappers &
\href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-service-wrappers}{Upgrading
Service Wrappers} & None \\
Hook - Servlet Filter &
\href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-servlet-filter-hooks}{Upgrading
Servlet Filter Hooks} & None \\
Hook - Struts actions & -
\href{/docs/7-1/tutorials/-/knowledge_base/t/converting-strutsactionwrappers-to-mvccommands}{StrutsAction
→ StrutsActionWrapper} -
\href{/docs/7-1/tutorials/-/knowledge_base/t/overriding-mvcactioncommand}{processAction
→ MVCActionCommand} -
\href{/docs/7-1/tutorials/-/knowledge_base/t/overriding-mvcrendercommand}{render
→ MVCRenderCommand} -
\href{/docs/7-1/tutorials/-/knowledge_base/t/overriding-mvcresourcecommand}{serveResource
→ MVCResourceCommand} & Same \\
Layout Template & 1.
\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-upgrade-planner}{Adapt
code to API}2.
\href{/docs/7-1/tutorials/-/knowledge_base/t/resolving-a-plugins-dependencies}{Resolve
dependencies}3.
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-layout-templates-manually}{Update
Layout Template} & -
\href{/docs/7-0/tutorials/-/knowledge_base/t/migrating-a-6-2-theme-to-liferay-7}{Migrate
to Liferay Theme Generator} (Node.js/Gulp/Yeoman) \\
Portlet - GenericPortlet &
\href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-a-genericportlet}{Upgrading
a GenericPortlet} & -
\href{/docs/7-1/tutorials/-/knowledge_base/t/migrating-traditional-plugins-to-workspace-web-applications}{Migrate
to Workspace/Gradle}-
\href{/docs/7-1/tutorials/-/knowledge_base/t/applying-clay-styles-to-your-app}{Apply
Clay}-
\href{/docs/7-1/tutorials/-/knowledge_base/t/modularizing-an-existing-portlet}{Convert
to OSGi modules} \\
Portlet - JSF &
\href{develop/tutorials/-/knowledge_base/7-1/upgrading-a-liferay-jsf-portlet}{Upgrading
a Liferay JSF Portlet} & None \\
Portlet - Liferay MVC &
\href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-a-liferay-mvc-portlet}{Upgrading
a Liferay MVC Portlet} & -
\href{/docs/7-1/tutorials/-/knowledge_base/t/migrating-traditional-plugins-to-workspace-web-applications}{Migrate
to Workspace/Gradle}-
\href{/docs/7-1/tutorials/-/knowledge_base/t/applying-clay-styles-to-your-app}{Apply
Clay}-
\href{/docs/7-1/tutorials/-/knowledge_base/t/modularizing-an-existing-portlet}{Convert
to OSGi modules} \\
Portlet - Servlet/JSP &
\href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-a-servlet-based-portlet}{Upgrading
a Servlet-based Portlet} & None \\
Portlet - Spring MVC &
\href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-a-spring-mvc-portlet}{Upgrading
a Spring MVC Portlet} & None \\
Portlet - Struts 1 &
\href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-a-struts-portlet}{Upgrading
a Struts Portlet} &
\href{/docs/7-1/tutorials/-/knowledge_base/t/converting-strutsactionwrappers-to-mvccommands}{Converting
StrustActionWrappers to MVCCommands} \\
Theme & 1.
\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-upgrade-planner}{Adapt
code to API}2.
\href{/docs/7-1/tutorials/-/knowledge_base/t/resolving-a-plugins-dependencies}{Resolve
dependencies}3.
\href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-6-2-themes-intro}{Upgrade
Theme} & -
\href{/docs/7-0/tutorials/-/knowledge_base/t/migrating-a-6-2-theme-to-liferay-7}{Migrate
to Liferay Theme Generator} (Node.js/Gulp/Yeoman)-
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-reusable-pieces-of-code-for-your-themes}{Use
Themelets} \\
Web plugin & 1.
\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-upgrade-planner}{Adapt
code to API}2.
\href{/docs/7-1/tutorials/-/knowledge_base/t/resolving-a-plugins-dependencies}{Resolve
dependencies} &
\href{/docs/7-1/tutorials/-/knowledge_base/t/modularizing-an-existing-portlet}{Convert
to OSGi module}, e.g., \texttt{portlet-x-web} \\
\end{longtable}

\subsection{Feature Upgrade and Optimization
Paths}\label{feature-upgrade-and-optimization-paths}

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.2222}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.4444}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Feature
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Upgrade path
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Optimizations (optional)
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
JNDI data source &
\href{/docs/7-1/tutorials/-/knowledge_base/t/connecting-to-data-sources-using-jndi}{Use
Liferay DXP's classloader to access the app server's JNDI API} & None \\
Services - Invoke a service from Liferay DXP Core or another portlet or
module &
\href{/docs/7-1/tutorials/-/knowledge_base/t/service-trackers}{Implement
a Service Tracker} &
\href{/docs/7-1/tutorials/-/knowledge_base/t/invoking-local-services}{Invoke
Liferay services from a module} \\
Services - Module dependency & Copy \texttt{x-service.jar} to
\texttt{WEB-INF/lib} & -
\href{/docs/7-1/tutorials/-/knowledge_base/t/migrating-traditional-plugins-to-workspace-web-applications}{Migrate
to Gradle/Maven} and
\href{/docs/7-1/tutorials/-/knowledge_base/t/configuring-dependencies}{add
dependency} on the OSGi service \\
Services - Service Builder &
\href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-portlets-that-use-service-builder}{Upgrading
Portlets that use Service Builder} &
\href{/docs/7-1/tutorials/-/knowledge_base/t/modularizing-an-existing-portlet}{Convert
to OSGi modules}, e.g., \texttt{x-api} and \texttt{x-service} \\
Services - Web services & 1.
\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-upgrade-planner}{Adapt
code to API}2.
\href{/docs/7-1/tutorials/-/knowledge_base/t/resolving-a-plugins-dependencies}{Resolve
dependencies} & Use a Service Builder service with JAX-RS with a REST
service in front \\
Template - FreeMarker & -
\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-upgrade-planner}{Adapt
code to API}-
\href{/docs/7-1/tutorials/-/knowledge_base/t/updating-theme-templates}{Adapt
Theme templates} & None \\
Template - Velocity (deprecated) &
\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-upgrade-planner}{Adapt
code to API} &
\href{/docs/7-1/tutorials/-/knowledge_base/t/updating-theme-templates}{Convert
to FreeMarker} \\
\end{longtable}

Now you have a game plan and a cheat sheet for upgrading and optimizing
plugins with confidence.

\section{Upgrading Code to 7.0}\label{upgrading-code-to-7.0}

Upgrading to 7.0 involves migrating your installation and code (your
custom apps) to the new version. You'll learn how to upgrade your code
in this section.

The first upgrade process step is to adapt your existing plugin's code
to 7.0's APIs. The great news is that Liferay's Upgrade Planner makes
this easier than ever. It identifies Liferay API changes affecting your
code, explains the API changes, and offers resolution steps. And the
tool offers auto-correction where it can.

You might be tempted to optimize your existing plugins right away to
benefit from the new things Liferay DXP offers, but you shouldn't. It's
much better to upgrade your plugins according to these tutorials. In
this way, you'll get your plugins running in Liferay DXP as fast as
possible, and at the same time you'll have prepared the plugins for the
optimizations you can implement later.

These tutorials assume you're using the
\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-upgrade-planner}{Liferay
Upgrade Planner}. To follow along with this section, install the planner
and step through the upgrade instructions.

For convenience, this tutorial section also references documentation and
outlined steps to aid those opting to upgrade their code manually.

Here are the code upgrade steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-your-development-environment}{Upgrade
  Your Development Environment}

  Legacy project environments should be upgraded to the latest version
  of Liferay Workspace to ensure you leverage all available features.

  \begin{enumerate}
  \def\labelenumii{\arabic{enumii}.}
  \item
    \href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-your-development-environment\#setting-up-liferay-workspace}{Set
    Up Liferay Workspace}

    A Liferay Workspace is a generated environment that is built to hold
    and manage your Liferay projects. Create/import a workspace to get
    started.

    \begin{enumerate}
    \def\labelenumiii{\arabic{enumiii}.}
    \item
      \href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-your-development-environment\#creating-new-liferay-workspace}{Create
      New Liferay Workspace}

      If you don't have an existing 7.x Liferay Workspace, you must
      create one. Skip to the next step if you have an existing
      workspace.
    \item
      \href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-your-development-environment\#importing-existing-liferay-workspace}{Import
      Existing Liferay Workspace}

      Import an existing Liferay Workspace. If you don't have one,
      revisit the previous step.
    \end{enumerate}
  \item
    \href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-your-development-environment\#configuring-liferay-workspace-settings}{Configure
    Liferay Workspace Settings}

    Set the Liferay DXP version in workspace's configuration you intend
    to upgrade to.

    \begin{enumerate}
    \def\labelenumiii{\arabic{enumiii}.}
    \item
      \href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-your-development-environment\#configuring-bundle-url}{Configure
      Bundle URL}

      Configure your bundle URL that the Liferay DXP bundle is
      downloaded from.
    \item
      \href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-your-development-environment\#configuring-target-platform-version}{Configure
      Target Platform Version}

      Configure your Target Platform version, which provides the
      specific artifacts associated with a Liferay DXP release.
    \item
      \href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-your-development-environment\#initializing-server-bundle}{Initialize
      Server Bundle}

      Download the Liferay DXP bundle you're upgrading to.
    \end{enumerate}
  \end{enumerate}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/migrating-plugins-sdk-projects-to-liferay-workspace}{Migrate
  Plugins SDK Projects}

  Copy your Plugins SDK projects into workspace and convert them to
  Gradle/Maven projects.

  \begin{enumerate}
  \def\labelenumii{\arabic{enumii}.}
  \item
    \href{/docs/7-1/tutorials/-/knowledge_base/t/migrating-plugins-sdk-projects-to-liferay-workspace\#importing-existing-plugins-sdk-projects}{Import
    Existing Plugins SDK Projects}

    Import your existing Plugins SDK projects.
  \item
    \href{/docs/7-1/tutorials/-/knowledge_base/t/migrating-plugins-sdk-projects-to-liferay-workspace\#migrating-existing-plugins-to-workspace}{Migrate
    Existing Plugins to Workspace}

    Migrate your existing plugins to workspace. This involves moving the
    plugin to workspace and converting it to the workspace's build
    environment.
  \end{enumerate}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-build-dependencies}{Upgrade
  Build Dependencies}

  Optimize your workspace's build environment for the most efficient
  code upgrade experience.

  \begin{enumerate}
  \def\labelenumii{\arabic{enumii}.}
  \item
    \href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-build-dependencies\#updating-the-repository-url}{Update
    Repository URL}

    Update your repository URL to Liferay's frequently updated CDN
    repository.
  \item
    \href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-build-dependencies\#updating-the-workspace-plugin-version}{Update
    Workspace Plugin Version}

    Update your Workspace plugin version to leverage the latest features
    of Liferay Workspace.
  \item
    \href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-build-dependencies\#removing-your-projects-build-dependency-versions}{Remove
    Dependency Versions}

    Remove the project's dependency versions since it's leveraging
    target platform.
  \end{enumerate}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/fixing-upgrade-problems}{Fix
  Upgrade Problems}

  Fix common upgrade problems dealing with your project's dependencies
  and breaking changes.

  \begin{enumerate}
  \def\labelenumii{\arabic{enumii}.}
  \item
    \href{/docs/7-1/tutorials/-/knowledge_base/t/fixing-upgrade-problems\#auto-correcting-upgrade-problems}{Auto-Correct
    Upgrade Problems}

    Auto-correct straightforward upgrade problems.
  \item
    \href{/docs/7-1/tutorials/-/knowledge_base/t/fixing-upgrade-problems\#finding-upgrade-problems}{Find
    Upgrade Problems}

    Find upgrade problems. These are problems that cannot be
    auto-corrected; you can update them manually according to the
    breaking changes documentation.
  \item
    \href{/docs/7-1/tutorials/-/knowledge_base/t/fixing-upgrade-problems\#resolving-upgrade-problems}{Resolve
    Upgrade Problems}

    Mark upgrade problems as resolved after addressing them.
  \item
    \href{/docs/7-1/tutorials/-/knowledge_base/t/fixing-upgrade-problems\#removing-problem-markers}{Remove
    Problem Markers}

    After fixing your upgrade problems, remove the problem markers.
  \item
    \href{/docs/7-1/tutorials/-/knowledge_base/t/resolving-a-plugins-dependencies}{Resolving
    a Plugin's Dependencies}
  \item
    \href{/docs/7-1/tutorials/-/knowledge_base/t/resolving-breaking-changes}{Resolving
    Breaking Changes}
  \end{enumerate}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-hook-plugins}{Upgrade
  Customization Plugins}

  Upgrade your customization plugins so they're deployable to 7.0.

  \begin{enumerate}
  \def\labelenumii{\arabic{enumii}.}
  \item
    \href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-customization-modules}{Upgrade
    Customization Modules}
  \item
    \href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-core-jsp-hooks}{Upgrade
    Core JSP Hooks}
  \item
    \href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-app-jsp-hook-plugins}{Upgrade
    Portlet JSP Hooks}
  \item
    \href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-service-wrappers}{Upgrade
    Service Wrapper Hooks}
  \item
    \href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-core-language-key-hooks}{Upgrade
    Core Language Key Hooks}
  \item
    \href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-portlet-language-key-hooks}{Upgrade
    Portlet Language Key Hooks}
  \item
    \href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-model-listener-hooks}{Upgrade
    Model Listener Hooks}
  \item
    \href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-portal-property-and-event-action-hooks}{Upgrade
    Event Action Hooks}
  \item
    \href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-servlet-filter-hooks}{Upgrade
    Servlet Filter Hooks}
  \item
    \href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-portal-property-and-event-action-hooks}{Upgrade
    Portal Properties Hooks}
  \item
    \href{/docs/7-1/tutorials/-/knowledge_base/t/converting-strutsactionwrappers-to-mvccommands}{Upgrade
    Struts Action Hooks}
  \end{enumerate}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-6-2-themes-intro}{Upgrade
  Themes}

  Upgrade your themes so they're deployable to 7.0.
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-6-2-layout-templates}{Upgrade
  Layout Templates}

  Upgrade your layout templates so they're deployable to 7.0.
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-frameworks-and-features}{Upgrade
  Frameworks \& Features}

  \begin{enumerate}
  \def\labelenumii{\arabic{enumii}.}
  \item
    \href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-jndi-data-source-usage}{Upgrade
    JNDI Data Source Usage}

    Use Liferay DXP's class loader to access the app server's JNDI API.
  \item
    \href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-service-builder-service-invocation}{Upgrade
    Service Builder Service Invocation}

    For Service Builder logic remaining in a WAR, you must implement a
    service tracker to call services. For logic divided into OSGi
    modules, you can leverage Declarative Services.
  \item
    \href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-service-builder}{Upgrade
    Service Builder}

    Adapt your app to account for Service Builder-specific changes.
  \item
    \href{/docs/7-1/tutorials/-/knowledge_base/t/migrating-off-of-velocity-templates}{Migrate
    Off of Velocity Templates}

    Velocity template usage is deprecated for 7.0. You should convert
    your template to FreeMarker.
  \end{enumerate}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-portlet-plugins}{Upgrade
  Portlets}

  Upgrade your portlets so they're deployable to 7.0.

  \begin{enumerate}
  \def\labelenumii{\arabic{enumii}.}
  \item
    \href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-a-genericportlet}{Upgrade
    Generic Portlets}
  \item
    \href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-a-liferay-mvc-portlet}{Upgrade
    Liferay MVC Portlets}
  \item
    \href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-a-liferay-jsf-portlet}{Upgrade
    JSF Portlets}
  \item
    \href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-a-servlet-based-portlet}{Upgrade
    Servlet-based Portlets}
  \item
    \href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-a-spring-mvc-portlet}{Upgrading
    Spring MVC Portlets}
  \item
    \href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-a-struts-1-portlet}{Upgrade
    Struts 1 Portlets}
  \end{enumerate}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-web-plugins}{Upgrade
  Web Plugins}

  Upgrade web plugins previously stored in the \texttt{webs} folder of
  your legacy Plugins SDK.
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-ext-plugins}{Upgrade
  Ext Plugins}

  Attempt to leverage an extension point instead of upgrading your Ext
  plugin. If an Ext plugin is necessary, you must review all changes
  between the previous Liferay Portal instance you were using and 7.0,
  and then manually modify your Ext plugin to merge your changes with
  Liferay DXP's.
\end{enumerate}

Once you've finished the code upgrade steps, your custom apps will be
compatible with 7.0!

\section{Upgrading Your Development
Environment}\label{upgrading-your-development-environment}

A
\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-workspace}{Liferay
Workspace} is a generated environment that is built to hold and manage
your Liferay projects. It is intended to aid in the management of
Liferay projects by providing various build scripts and configured
properties.

Liferay Workspace is the recommended environment for your code
migration; therefore, it will be the assumed development environment in
this section.

Continue on to set up a workspace.

\subsection{Setting Up Liferay
Workspace}\label{setting-up-liferay-workspace}

You must set up your workspace development environment before you begin
upgrading your custom apps. If you don't have an existing workspace,
follow the step for creating one. If you have an existing workspace,
follow the step on importing it into the Upgrade Planner.

\subsubsection{Creating New Liferay
Workspace}\label{creating-new-liferay-workspace}

Initiating this step in the Upgrade Planner loads the Liferay Workspace
Project wizard.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Give your new workspace a name.
\item
  Choose the build type (Gradle or Maven) you prefer for your workspace
  environment and future Liferay projects.
\item
  Click Finish.
\end{enumerate}

You now have a new Liferay Workspace available in the Upgrade Planner!

For more information on creating a Liferay Workspace outside the
planner, see the
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-a-liferay-workspace-with-blade-cli}{Creating
a Liferay Workspace} section.

\subsubsection{Importing Existing Liferay
Workspace}\label{importing-existing-liferay-workspace}

If you already have an existing 7.x Liferay Workspace, you should import
it into the planner. Once you initiate this step, you're given a File
Explorer/Manager to select your existing workspace. After selecting it,
the workspace is imported into the Project Explorer.

For more information importing a workspace into your IDE, see
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-modules-with-liferay-ide\#importing-existing-module-projects}{this
article}.

\subsection{Configuring Liferay Workspace
Settings}\label{configuring-liferay-workspace-settings}

You must configure your workspace with the Liferay DXP version you
intend to upgrade to. You should verify the workspace's

\begin{itemize}
\tightlist
\item
  Bundle URL
\item
  Target Platform Version
\end{itemize}

The bundle URL version and target platform version must match.

Visit these steps to begin.

\subsubsection{Configuring Bundle URL}\label{configuring-bundle-url}

The bundle URL points to the Liferay DXP version you want workspace to
download. When initiating this step, your workspace's Bundle URL
property is updated to the latest release of 7.0.

For more information on configuring a workspace's bundle URL, see the
\href{/docs/7-1/tutorials/-/knowledge_base/t/configuring-a-liferay-workspace\#adding-a-liferay-bundle-to-a-workspace}{Adding
a Liferay Bundle to Liferay Workspace} article.

\subsubsection{Configuring Target Platform
Version}\label{configuring-target-platform-version}

The target platform is the Liferay DXP version you intend to develop for
in your workspace. This is used to specify dependencies associated with
a specific release. You set the target platform, define your
dependencies, and workspace automatically assigns the dependency
versions based on the set Liferay DXP version. When initiating this
step, your workspace's Target Platform property is updated to the latest
release of 7.0.

For more information on this, see the
\href{/docs/7-1/tutorials/-/knowledge_base/t/managing-the-target-platform-for-liferay-workspace}{Managing
the Target Platform} article.

\subsection{Initializing Server
Bundle}\label{initializing-server-bundle}

Once your workspace is configured for the Liferay DXP version you're
upgrading to, you can initialize the server bundle. This involves
downloading the bundle and extracting it into its folder (e.g.,
\texttt{bundles}). If you have an existing workspace already equipped
with an older Liferay bundle, this deletes the old bundle and
initializes the new one.

If you're upgrading your code manually and working in Dev Studio, you
can do this by right-clicking the workspace project and selecting
\emph{Liferay} → \emph{Initialize Server Bundle}. See the
\href{/docs/7-1/tutorials/-/knowledge_base/t/installing-a-server-in-intellij-idea}{Installing
a Server in IntelliJ} article if you use IntelliJ instead. Visit the
\href{/docs/7-1/tutorials/-/knowledge_base/t/managing-module-projects-with-blade-cli}{Managing
Your Liferay Server with Blade CLI} article for information on how to do
this via the command line.

\section{Migrating Plugins SDK Projects to Liferay
Workspace}\label{migrating-plugins-sdk-projects-to-liferay-workspace}

The Plugins SDK was deprecated for Liferay DXP 7.0 and removed for
Liferay DXP 7.1. Therefore, to upgrade your custom apps to 7.0, you must
migrate them to a new environment.
\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-workspace}{Liferay
Workspace} is the recommended environment for your code migration and
will be the assumed choice in this section.

There are two steps you must follow to migrate your custom code to
workspace:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Import the Plugins SDK project into the Upgrade Planner.
\item
  Convert the Plugins SDK project to a supported workspace build type.
\end{enumerate}

You'll step through importing a Plugins SDK project first.

\subsection{Importing Existing Plugins SDK
Projects}\label{importing-existing-plugins-sdk-projects}

Initiating this step in the Upgrade Planner imports your Plugins SDK
projects into the Upgrade Planner. These projects originate from the
Plugins SDK you set when the Upgrade Planner process was started.

If you're manually upgrading your code, you can skip this step.

You're now ready to migrate your Plugins SDK projects to your new
workspace!

\subsection{Migrating Existing Plugins to
Workspace}\label{migrating-existing-plugins-to-workspace}

Liferay Workspace can be generated as a Gradle or Maven environment, but
it does not support the Plugins SDK's Ant build. Because of this, you
must convert your projects to one of the supported build tools:

\begin{itemize}
\tightlist
\item
  Gradle
\item
  Maven
\end{itemize}

When initiating this step for a Gradle-based workspace, your Ant-based
Plugins SDK project is copied to the applicable workspace folder based
on its project type (e.g., \texttt{wars}) and is converted to a Gradle
project. There is also a Blade CLI command that completes this via the
command line. Visit the
\href{/docs/7-1/tutorials/-/knowledge_base/t/converting-plugins-sdk-projects-with-blade-cli}{Converting
Plugins SDK Projects with Blade CLI} article for more information.

If you're migrating your Ant project to a Maven workspace, you must
manually copy the project to the applicable folder based on the project
type (e.g., \texttt{wars}). The majority of Plugins SDK projects belong
in the workspace's \texttt{wars} folder. You can consult the
\href{/docs/7-1/tutorials/-/knowledge_base/t/configuring-a-liferay-workspace}{Workspace
Anatomy} section for a full overview of a workspace's folder structure
and choose where your custom app should reside. Once you've made the
decision, copy your custom app to the applicable workspace folder.

Then you must convert your project from Ant to Maven. You'll have to
complete this conversion manually.

Once you're finished, you should have your project(s) residing in the
applicable workspace folders as Gradle/Maven projects.

\section{Upgrading Build
Dependencies}\label{upgrading-build-dependencies}

Now that your projects are readily available in a workspace, you must
ensure your project build dependencies are upgraded. Your workspace
streamlines the build dependency upgrade process by only requiring three
modifications:

\begin{itemize}
\tightlist
\item
  \hyperref[updating-the-repository-url]{Update the repository URL}
  (Gradle only)
\item
  \hyperref[updating-the-workspace-plugin-version]{Update the workspace
  plugin version}
\item
  \hyperref[removing-your-projects-build-dependency-versions]{Remove
  your project's build dependency versions} (Gradle only)
\end{itemize}

If you're upgrading a recently created workspace, only a subset of these
tasks may be required.

You'll start by updating the repository URL.

\subsection{Updating the Repository
URL}\label{updating-the-repository-url}

Initiating this step in the Upgrade Planner updates the repository URL
used to download artifacts for your workspace.

If you're using a Gradle-based workspace, the repository URL is updated
to point to the latest Liferay CDN repository. This is set in your
workspace's \texttt{settings.gradle} file within the
\texttt{buildscript} block like this:

\begin{verbatim}
repositories {
    maven {
        url "https://repository-cdn.liferay.com/nexus/content/groups/public"
    }
}
\end{verbatim}

Once the repository URL is set to the proper CDN repository, your build
dependencies will be downloaded from Liferay's own managed repo.

For Maven-based workspaces, Maven Central is the default repository, so
no action is required.

\subsection{Updating the Workspace Plugin
Version}\label{updating-the-workspace-plugin-version}

For the best upgrade experience, you should ensure you're leveraging the
latest Liferay Workspace version so all the latest features are
available to you. Initiate this step to upgrade the appropriate plugin.

See the
\href{/docs/7-1/tutorials/-/knowledge_base/t/updating-liferay-workspace}{Updating
Liferay Workspace} article to do this for Gradle-based workspaces
manually. For Maven-based workspaces, make sure you set the latest
\href{/docs/7-1/reference/-/knowledge_base/r/bundle-support-plugin}{Bundle
Support plugin} version in your root \texttt{pom.xml} file.

\subsection{Removing Your Project's Build Dependency
Versions}\label{removing-your-projects-build-dependency-versions}

\noindent\hrulefill

\textbf{Note:} This step only applies to Gradle-based workspaces since
the target platform feature is only available for Gradle projects at
this time.

\noindent\hrulefill

Since your workspace is leveraging the target platform feature, there is
no need to set your plugin's dependency versions in its
\texttt{build.gradle} file. This is because the target platform version
you set already defines the artifact versions your project uses.
Therefore, if dependency versions are present in any of your projects'
\texttt{build.gradle} files, you must remove them.

Initiate this step to remove your dependency versions from your
project's \texttt{build.gradle} file

As an example of what a \texttt{build.gradle}'s \texttt{dependencies}
block should look like, see the below snippet:

\begin{verbatim}
dependencies {
    compileOnly group: "com.liferay.portal", name: "com.liferay.portal.kernel"
    compileOnly group: "com.liferay.portal", name: "com.liferay.util.taglib"
    compileOnly group: "javax.portlet", name: "portlet-api"
    compileOnly group: "javax.servlet", name: "javax.servlet-api"
    compileOnly group: "jstl", name: "jstl"
    compileOnly group: "org.osgi", name: "osgi.cmpn"
}
\end{verbatim}

If you have not set the target platform feature in your workspace, see
the
\href{/docs/7-1/tutorials/-/knowledge_base/t/managing-the-target-platform-for-liferay-workspace}{Managing
the Target Platform} article for more information.

Great! You've successfully upgraded your build dependencies! You likely
have compile errors in your project; this is because your dependencies
may have changed. You'll learn how to update that and more next.

\section{Fixing Upgrade Problems}\label{fixing-upgrade-problems}

Now that your development environment build configuration is settled,
you can start upgrading your project(s). The two most common upgrade
problems are

\begin{itemize}
\tightlist
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/resolving-a-plugins-dependencies}{Broken
  project dependencies}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/resolving-breaking-changes}{Breaking
  changes}
\end{itemize}

Visit these upgrade problem tutorials for tips on how to fix them.

This tutorial is heavily focused on the Liferay Upgrade Planner. If
you're upgrading your code manually, continue to the listed tutorials
above to fix your code upgrade problems.

You'll begin auto-correcting upgrade problems first.

\subsection{Auto-Correcting Upgrade
Problems}\label{auto-correcting-upgrade-problems}

Initiate this step to auto-correct straightforward updates like

\begin{itemize}
\tightlist
\item
  package imports
\item
  JSP tag names
\item
  Liferay descriptor versions
\item
  XML descriptor content
\item
  etc.
\end{itemize}

If you choose to preview the auto-correct upgrade problems first, you
can view them in the Project Explorer under the \emph{Liferay Upgrade
Problems} dropdown. If you click one of the upgrade problems listed with
the preview, you're offered documentation in the \emph{Liferay Upgrade
Plan Info} window on the proposed change.

Once you've performed this step, the result list is removed.

\subsection{Finding Upgrade Problems}\label{finding-upgrade-problems}

Initiating this step finds the upgrade problems that were not eligible
for auto-correction. The problems are listed under the \emph{Liferay
Upgrade Problems} dropdown. If you click one of the upgrade problems
listed with the preview, you're offered documentation in the
\emph{Liferay Upgrade Plan Info} window on the proposed change.

These upgrade problems are available in the
\href{/docs/7-1/tutorials/-/knowledge_base/t/resolving-breaking-changes}{breaking
changes} for the version upgrade you're performing.

The next step is resolving the reported upgrade problems.

\subsection{Resolving Upgrade
Problems}\label{resolving-upgrade-problems}

Now that the upgrade problems have been located, you must resolve them.
As you select each upgrade problem, the documentation for how to adapt
your code is displayed in the \emph{Liferay Upgrade Plan Info} window.

For each upgrade problem node, you're also given the version the upgrade
problem applies to (e.g., when upgrading to Liferay DXP 7.2 from Liferay
Portal 6.2, you could have upgrade problems from the 7.0, 7.1, or 7.2
upgrade). As you step through the reported problems, mark them as
resolved/skipped using the context menu. You can right-click on the
problem in the Project Explorer and choose from four options:

\begin{itemize}
\tightlist
\item
  Mark done
\item
  Mark undone
\item
  Ignore
\item
  Ignore all problems of this type
\end{itemize}

Leave this step marked as \emph{Incomplete} until you have resolved all
upgrade problems accordingly.

\subsection{Removing Problem Markers}\label{removing-problem-markers}

After resolving all the reported upgrade problems, you must remove all
previously found markers because, in most cases, the line number and
other accompanying marker information are out of date and must be
removed before continuing. Initiate this step to remove all the problem
markers.

Great! You've fixed all the upgrade problems that could be automatically
detected by the Upgrade Planner. Next, you'll take a deeper look at
resolving project dependency errors.

\section{Resolving a Plugin's
Dependencies}\label{resolving-a-plugins-dependencies}

Now that you've imported your plugin project to Liferay Dev Studio DXP,
you probably see compile errors for some of the Liferay classes it uses.
These classes are listed as undefined classes or unresolved symbols
because they've been moved, renamed, or removed. As a part of
modularization in Liferay DXP, many of these classes reside in new
modules.

You must resolve all of these Liferay classes for your plugin. Some of
the class changes are quick and easy to fix. Changes involving the new
modules require more effort to resolve, but doing so is still
straightforward.

Liferay class changes and required adaptations are described here:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{Class moved to a package that's in the classpath}: This change
  is common and easy to fix. Since the module is already on your
  classpath, you need only update the class import. You can do this by
  using the Liferay Code Upgrade Tool or by organizing imports in Dev
  Studio DXP. The Upgrade Planner reports each moved class for you to
  address one by one. Organizing imports in Dev Studio DXP automatically
  resolves multiple classes at once.

  It's typically faster to resolve moved classes using the mentioned
  Eclipse feature. Since Liferay Dev Studio DXP is based on Eclipse, you
  can generate imports of classes in your classpath with the
  \emph{Organize Imports} keyboard sequence \emph{Ctrl-Shift-o}. Comment
  out or remove any imports marked as errors, then press
  \emph{Ctrl-Shift-o}. If there's only one match for the import, Dev
  Studio DXP automatically generates its import statement. Otherwise, a
  wizard appears that lets you select the correct import.
\item
  \textbf{Class moved to a module that's \emph{not} in the classpath}:
  You must resolve the new module as a dependency for your project. This
  requires identifying the module and specifying your project's
  dependency on it.
\item
  \textbf{Class replaced or removed}: The class has been replaced by
  another class or removed from the product. The Upgrade Planner
  (discussed later) explains what happened to the class, how to handle
  the change, and why the change was made.
\end{enumerate}

Resolving a class that's moved within your classpath is straightforward.
Consider resolving such classes first. The remainder of this tutorial
explains how to resolve the last two cases and starts with configuring
your plugin project to declare the modules it needs.

\subsection{Identifying Module
Dependencies}\label{identifying-module-dependencies}

Before 7.0, all the platform APIs were in \texttt{portal-service.jar}.
Many of these APIs are now in independent modules. Modularization has
resulted in many benefits, as described in the article
\href{/docs/7-1/tutorials/-/knowledge_base/t/benefits-of-liferay-7-for-liferay-6-developers\#modular-development-paradigm}{Benefits
of 7.0 for Liferay Portal 6 Developers}. One such advantage is that
these API modules can evolve separately from the platform kernel. They
also simplify future upgrades. For example, instead of having to check
all of Liferay's APIs, each module's \href{http://semver.org}{Semantic
Versioning} indicates whether the module contains any
backwards-incompatible changes. You need only adapt your code to such
modules (if any).

As part of the modularization, \texttt{portal-service.jar} has been
renamed appropriately to \texttt{portal-kernel.jar}, as it continues to
hold the portal kernel's APIs.

\begin{figure}
\centering
\includegraphics{./images/from-liferay-6-portal-apis-before-after.png}
\caption{Liferay refactored the portal-service JAR for 7.0. Application
APIs now exist in their own modules, and the portal-service JAR is now
\emph{portal-kernel}.}
\end{figure}

Each app module consists of a set of classes that are highly cohesive
and have a specific purpose, such as providing the app's API,
implementation, or UI. The app modules are therefore much easier to
understand. Next, you'll track down the modules that now hold the
classes referenced by your plugin.

The reference article
\href{/docs/7-1/reference/-/knowledge_base/r/classes-moved-from-portal-service-jar}{Classes
Moved from \texttt{portal-service.jar}} contains a table that maps each
class moved from \texttt{portal-service.jar} to its new module. The
table includes each class's new package and symbolic name (artifact ID).
You'll use this information to configure your plugin's dependencies on
these modules.

Your plugin might reference classes that are in Liferay utility modules
formerly known as \texttt{util-java}, \texttt{util-bridges},
\texttt{util-taglib}, or \texttt{util-slf4j}.

The following table shows each Liferay utility module's symbolic name.

\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
\textbf{Liferay Utility} & ~\textbf{Symbolic Name (Artifact ID)} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
util-bridges & \texttt{com.liferay.util.bridges} \\
util-java & \texttt{com.liferay.util.java} \\
util-slf4j & \texttt{com.liferay.util.slf4j} \\
util-taglib & \texttt{com.liferay.util.taglib} \\
\end{longtable}

You can use Liferay DXP's
\href{/docs/7-1/tutorials/-/knowledge_base/t/configuring-dependencies\#finding-liferay-app-and-independent-artifacts}{App
Manager},
\href{/docs/7-1/reference/-/knowledge_base/r/using-the-felix-gogo-shell}{Felix
Gogo Shell}, or
\href{/docs/7-1/tutorials/-/knowledge_base/t/configuring-dependencies\#finding-core-artifacts}{module
JAR file manifests} to find versions of modules deployed on your Liferay
DXP instance.

\noindent\hrulefill

\textbf{Note:} Previous versions of the Plugins SDK made
\texttt{portal-service.jar} available to projects. The Liferay Portal
7.0 Plugins SDK similarly makes \texttt{portal-kernel.jar} available. If
you're using a Liferay DXP bundle (Liferay DXP pre-installed on an app
server), the Liferay utility modules are already on your classpath. If
you manually installed Liferay DXP on your app server, the Liferay
utility modules might not be on your classpath. If a utility module you
need is not on your classpath, note its symbolic name (artifact ID) and
version.

\noindent\hrulefill

\subsection{Resolving Dependencies}\label{resolving-dependencies}

Now that you have the module artifact IDs and versions, you can make the
modules available to your plugin project. The modules your plugin uses
must be available to it at compile time and run time. Here are two
options for resolving module dependencies in your traditional plugin
project:

\hyperref[using-a-dependency-management-tool]{\textbf{Option 1: Use a
dependency management tool}}

\hyperref[managing-plugin-dependencies-manually]{\textbf{Option 2:
Manage dependencies manually}}

The next sections explain and demonstrate these options.

\subsubsection{Using a Dependency Management
Tool}\label{using-a-dependency-management-tool}

Dependency management tools such as
\href{http://ant.apache.org/ivy/}{Ant/Ivy},
\href{/docs/7-1/tutorials/-/knowledge_base/t/maven}{Maven}, and
\href{https://gradle.org/}{Gradle} facilitate acquiring Java artifacts
that provide packages your plugins need. They can download artifacts
from public repositories or from internal repositories you configure as
a proxies. From internal repositories you can audit dependencies.

\noindent\hrulefill

The following links provide proxy details:

\begin{itemize}
\tightlist
\item
  \href{http://ant.apache.org/ivy/}{Ant/Ivy} - See documentation on
  proxy configuration, the \texttt{Setproxy} task, and
  \href{http://ant.apache.org/ivy/history/latest-milestone/settings/resolvers.html}{resolvers}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/creating-a-maven-repository}{Maven}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/setting-proxy-requirements-for-liferay-workspace}{Liferay
  Workspace (Gradle)}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/setting-proxy-requirements-for-liferay-ide}{Setting
  proxies in Liferay Dev Studio DXP}
\end{itemize}

\noindent\hrulefill

The Liferay Plugins SDK provides an Ant/Ivy infrastructure. You declare
your dependencies in an \texttt{ivy.xml} file in your plugin project's
root folder. The Plugins SDK's Ant tasks leverage the \texttt{ivy.xml}
file and the Plugins SDK's Ivy scripts to download the specified modules
and their dependencies and make them available to your plugin.

\noindent\hrulefill

\textbf{Note}: You can use Gradle or Maven in place of Ivy for
dependency management, but this isn't in this tutorial's scope.
Liferay's \href{/docs/7-1/tutorials/-/knowledge_base/t/maven}{Maven} and
\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-workspace}{Liferay
Workspace} tutorials demonstrate using these tools.

Additionally, Liferay Workspace provides a command for migrating Ant/Ivy
projects to Gradle-based Liferay Workspace projects. See the tutorial
\href{/docs/7-1/tutorials/-/knowledge_base/t/migrating-traditional-plugins-to-workspace-web-applications}{Migrating
Traditional Plugins to Workspace Web Applications}.

\noindent\hrulefill

Here's an example dependency element for the Liferay Journal API module,
version 2.0.1:

\begin{verbatim}
<dependency name="com.liferay.journal.api" org="com.liferay" rev="2.0.1" />
\end{verbatim}

Each dependency includes the module's name (\texttt{name}), organization
(\texttt{org}), and revision number (\texttt{rev}). The
\href{/docs/7-1/tutorials/-/knowledge_base/t/configuring-dependencies}{Configuring
Dependencies} tutorial explains how to determine the module's
organization (\texttt{org}).

At compile time, Ivy downloads the dependency JAR files to a cache
folder so you can compile against them.

At deployment,
\href{/docs/7-1/tutorials/-/knowledge_base/t/using-the-wab-generator}{Liferay
DXP's WAB Generator} creates an OSGi Web Application Bundle (WAB) for
the plugin. The WAB generator detects the Java packages your plugin uses
and declares dependencies on them. Your plugin can use the packages once
a registered OSGi service provides them.

If your project doesn't already have an \texttt{ivy.xml} file, you can
get one by creating a new plugin project in Liferay Dev Studio DXP and
copying the \texttt{ivy.xml} file it generates.

Here's an example of an \texttt{ivy.xml} file from the Liferay Portal
6.2 Knowledge Base portlet:

\begin{verbatim}
<?xml version="1.0"?>

<ivy-module
    version="2.0"
    xmlns:m2="http://ant.apache.org/ivy/maven"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:noNamespaceSchemaLocation="http://ant.apache.org/ivy/schemas/ivy.xsd"
>
    <info module="knowledge-base-portlet" organisation="com.liferay">
        <extends extendType="configurations,description,info" location="${sdk.dir}/ivy.xml" module="com.liferay.sdk" organisation="com.liferay" revision="latest.integration" />
    </info>

    <dependencies defaultconf="default">
        <dependency org="com.liferay" name="com.liferay.markdown.converter" rev="1.0.2" />
    </dependencies>
</ivy-module>
\end{verbatim}

The Plugins SDK works with project Ivy files to store artifacts and make
them accessible to your plugin projects.

If you don't want to use Ivy or some other dependency management
framework, you can store dependency JARs within your plugin project
manually. You'll learn about this next.

\subsubsection{Managing Plugin Dependencies
Manually}\label{managing-plugin-dependencies-manually}

Plugins rely on their dependencies' availability at compile time and run
time. To compile your plugin, you must make sure the dependencies are
available in the plugin's \texttt{WEB-INF/lib} folder. To run your
plugin, the container must be able to find them: either 1) the
dependency Java packages must already be active in Liferay DXP's OSGi
framework or 2) the dependency JARs must be included in the WAB
generated for the plugin. Your plugin can use both the JARs it currently
has and the packages Liferay DXP exports.

\paragraph{Using Packages Portal
Exports}\label{using-packages-portal-exports}

The Plugins SDK for Liferay Portal 6 provided a way to compile against
JARs it had. You'd specify these JARs in the
\texttt{portal-dependency-jars} property in your
\href{https://docs.liferay.com/dxp/portal/7.1-latest/propertiesdoc/liferay-plugin-package_7_1_0.properties.html}{\texttt{liferay-plugin-package.properties}}
file. On seeing a plugin's \texttt{portal-dependency-jars} list, the
Liferay Plugins SDK copied the JARs into the plugin's
\texttt{WEB-INF/lib}. The Plugins SDK refrained from adding the JARs to
the plugin WAR. This kept the WARs small for deploying faster. It was
especially useful for deploying WARs remotely or to cluster nodes.

In 7.0, the \texttt{portal-dependency-jars} property is deprecated and
behaves differently from previous versions. Because importing and
exporting Java packages has replaced wholesale use of JARs, modules and
WABs can import packages without concerning themselves with JARs. This
means that Liferay DXP can't make available to plugins the same Java
classes it did in the past.

These files list the packages that the portal exports:

\begin{itemize}
\tightlist
\item
  \texttt{modules/core/portal-bootstrap/system.packages.extra.bnd} file
  in the
  \href{https://github.com/liferay/liferay-portal/blob/7.1.x/modules/core/portal-bootstrap/system.packages.extra.bnd}{GitHub
  repository}. It lists exported packages on separate lines, making them
  easy to read.
\item
  \texttt{META-INF/system.packages.extra.mf} file in
  \texttt{{[}LIFERAY\_HOME{]}/osgi/core/com.liferay.portal.bootstrap.jar}.
  The file is available in Liferay DXP bundles. It lists exported
  packages in a paragraph wrapped at 70 columns--they're harder to read
  here than in the \texttt{system.packages.extra.bnd} file.
\end{itemize}

If you're still using the \texttt{portal-dependency-jars} property, you
may run into one of the scenarios below. Follow the instructions below
the scenario to fix the issue.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{I've specified a JAR, but in 7.0 none of the classes are
  available to my plugin.}

  Some JARs that Liferay Portal 6.2 used were removed in 7.0. If you
  specify them in your \texttt{portal-dependency-jars}, Liferay DXP
  can't provide them. If you still need them, remove them from the
  \texttt{portal-dependency-jars} property and add the JARs you need to
  your plugin's \texttt{WEB-INF/lib} folder.
\item
  \textbf{I've specified JARs, and 7.0 also exports all the JAR's
  packages my plugin imports}

  Keep the JAR in your \texttt{portal-dependency-jars} list. The Plugins
  SDK copies the JAR to your plugin's \texttt{WEB-INF/lib} folder at
  compile time but refrains from adding the JAR to the plugin WAB. The
  WAB generated for the plugin imports the packages from a registered
  provider at run time.
\item
  \textbf{7.0 provides the JAR but doesn't export a package my plugin
  imports}

  Keep the JAR in your \texttt{portal-dependency-jars} property. The
  Plugins SDK copies the JAR to your plugin's \texttt{WEB-INF/lib}
  folder at compile time and adds the JAR to the plugin WAB at
  deployment.
\end{enumerate}

\paragraph{Understanding Excluded
JARs}\label{understanding-excluded-jars}

\href{https://docs.liferay.com/dxp/portal/7.1-latest/propertiesdoc/portal.properties.html\#Module\%20Framework}{Portal
property \texttt{module.framework.web.generator.excluded.paths}}
declares JARs that are stripped from all Liferay DXP generated WABs.
These JARs are excluded from WABs because Liferay DXP provides them
already. All JARs listed for this property are excluded from the WABs,
even if the plugins listed the JAR in their
\texttt{portal-dependency-jars} property.

If your plugin requires different versions of the packages Liferay DXP
exports, you must include them in JARs named differently from the ones
\texttt{module.framework.web.generator.excluded.paths} excludes.

For example, Liferay DXP's
\href{https://github.com/liferay/liferay-portal/blob/7.1.1-ga2/modules/core/portal-bootstrap/system.packages.extra.bnd}{\texttt{system.packages.extra.bnd}
file} exports Spring Framework version 4.1.9 packages:

\begin{verbatim}
Export-Package:\
    ...
    org.springframework.*;version='4.1.9',\
    ...
\end{verbatim}

Liferay DXP uses the
\texttt{module.framework.web.generator.excluded.paths} portal property
to exclude their JARs.

\begin{verbatim}
module.framework.web.generator.excluded.paths=\
    ...
    WEB-INF/lib/spring-aop.jar,\
    WEB-INF/lib/spring-aspects.jar,\
    WEB-INF/lib/spring-beans.jar,\
    WEB-INF/lib/spring-context.jar,\
    WEB-INF/lib/spring-context-support.jar,\
    WEB-INF/lib/spring-core.jar,\
    WEB-INF/lib/spring-expression.jar,\
    WEB-INF/lib/spring-jdbc.jar,\
    WEB-INF/lib/spring-jms.jar,\
    WEB-INF/lib/spring-orm.jar,\
    WEB-INF/lib/spring-oxm.jar,\
    WEB-INF/lib/spring-tx.jar,\
    WEB-INF/lib/spring-web.jar,\
    WEB-INF/lib/spring-webmvc.jar,\
    WEB-INF/lib/spring-webmvc-portlet.jar,\
    ...
\end{verbatim}

To use a different Spring Framework version in your WAB, you must name
the corresponding Spring Framework JARs differently from the
glob-patterned JARs
\texttt{module.framework.web.generator.excluded.paths} lists.

For example, to use Spring Framework version 3.0.7's Spring AOP JAR,
include it in your plugin's \texttt{WEB-INF/lib} but name it something
other than \texttt{spring-aop.jar}. Adding the version to the JAR name
(i.e., \texttt{spring-aop-3.0.7.RELEASE.jar}) differentiates it from the
excluded JAR and prevents it from being stripped from the WAB.

\paragraph{Using Packages Portal Doesn't
Export}\label{using-packages-portal-doesnt-export}

You must download and install to your plugin's \texttt{WEB-INF/lib}
folder JARs that provide packages Liferay DXP doesn't export that your
plugin requires.

Follow these steps to do this:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Go to Maven Central at \url{https://search.maven.org/}.
\item
  Search for the module by its artifact ID and group ID.
\item
  Navigate the search results to find the version of the module you
  want.
\item
  Click the \emph{jar} link to download the module's JAR file.
\item
  Add the JAR to your project's \texttt{WEB-INF/lib} folder.
\end{enumerate}

\begin{figure}
\centering
\includegraphics{./images/resolving-plugin-dependencies-using-maven-central.png}
\caption{After searching Maven Central, download an artifact's JAR file
by clicking the \emph{jar} link.}
\end{figure}

As you manage module JARs, make sure \textbf{not} to deploy any OSGi
framework JARs or Liferay module JARs (e.g.,
\texttt{com.liferay.journal.api.jar}). If you deploy these, they'll
conflict with the JARs already installed in the OSGi framework.
Identical JARs in two different classloaders can cause class cast
exceptions. The easiest way to exclude such JARs from your plugin's
deployment is to list them in a \texttt{deploy-excludes} property in
your plugin's \texttt{liferay-plugin-package.properties}. You must
otherwise remove the JARs manually from the plugin WAR file. To exclude
JARs in your plugin's \texttt{liferay-plugin-package.properties} file,
add an entry like the one below, replacing the square-bracketed items
with the names of JAR files to exclude:

\begin{verbatim}
deploy-excludes=\
    **/WEB-INF/lib/[module-artifact.jar],\
    **/WEB-INF/lib/[another-module-artifact.jar]
\end{verbatim}

For example, here's an example property that excludes the OSGi framework
JAR \texttt{osgi.core.jar} and the Liferay app module JAR
\texttt{com.liferay.journal.api.jar}:

\begin{verbatim}
deploy-excludes=\
    **/WEB-INF/lib/com.liferay.portal.journal.api.jar,\
    **/WEB-INF/lib/org.osgi.core.jar
\end{verbatim}

How do you know what modules are already installed in Liferay DXP? If
your Liferay DXP instance has a particular Liferay app suite installed,
then don't deploy module JARs you know are in that app suite. For
example, if the Web Experience Management App Suite is already installed
(which is the case for a Liferay DXP bundle), then don't deploy Web
Content module JARs such as \texttt{com.liferay.journal.api.jar}.
Searching for a module in Liferay DXP's
\href{/docs/7-1/user/-/knowledge_base/u/managing-and-configuring-apps}{App
Manager} is a sure-fire way to verify existing module installations.

\section{Resolving Breaking Changes}\label{resolving-breaking-changes}

Liferay goes to great lengths to maintain backwards compatibility.
Sometimes, breaking changes are necessary to improve Liferay DXP. There
may be cases where breaking changes affect your code upgrade process and
must be resolved. A breaking change can include

\begin{itemize}
\tightlist
\item
  Functionality that is removed or replaced
\item
  API incompatibilities: Changes to public Java or JavaScript APIs
\item
  Changes to context variables available to templates
\item
  Changes in CSS classes available to Liferay themes and portlets
\item
  Configuration changes: Changes in configuration files, like
  \texttt{portal.properties}, \texttt{system.properties}, etc.
\item
  Execution requirements: Java version, J2EE Version, browser versions,
  etc.
\item
  Deprecations or end of support: For example, warning that a certain
  feature or API will be dropped in an upcoming version.
\item
  Recommendations: For example, recommending using a newly introduced
  API that replaces an old API, in spite of the old API being kept in
  Liferay Portal for backwards compatibility.
\end{itemize}

Liferay provides a list of breaking changes for every major release to
ensure you can easily adapt your code during the upgrade process.

\begin{itemize}
\tightlist
\item
  \href{/docs/7-0/reference/-/knowledge_base/r/breaking-changes}{Liferay
  DXP 7.0 Breaking Changes}
\item
  \href{/docs/7-1/reference/-/knowledge_base/r/breaking-changes}{7.0
  Breaking Changes}
\item
  \href{/docs/7-2/reference/-/knowledge_base/r/breaking-changes}{Liferay
  DXP 7.2 Breaking Changes}
\end{itemize}

The easiest way to resolve breaking changes is by using the
\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-upgrade-planner}{Liferay
Upgrade Planner}. It automatically finds all documented breaking changes
and can automatically resolve some of them on its own.

If you're resolving breaking changes manually, make sure to investigate
each breaking change document if you're upgrading code across multiple
versions. For example, if you're upgrading from Liferay Portal 6.2 to
7.0, you must resolve all the breaking changes listed in the three
documents listed above.

Now that you've resolved your breaking changes, you'll learn how to
upgrade service builder services next.

\chapter{Upgrading Hook Plugins}\label{upgrading-hook-plugins}

Liferay DXP has more extension points than ever, and connecting existing
hook plugins to them takes very few steps. In most cases, after you
upgrade your hook using the Liferay Upgrade Planner, it's ready to run
on Liferay DXP. The following tutorials show you how to upgrade each
type of hook plugin.

\begin{itemize}
\tightlist
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-customization-modules}{Override/Extension
  Modules}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-core-jsp-hooks}{Core
  JSP Hooks}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-app-jsp-hook-plugins}{App
  JSP Hooks}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-service-wrappers}{Service
  Wrapper Hooks}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-core-language-key-hooks}{Core
  Language Key Hooks}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-portlet-language-key-hooks}{Portlet
  Language Key Hooks}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-model-listener-hooks}{Model
  Listener Hooks}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-servlet-filter-hooks}{Servlet
  Filter Hooks}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-portal-property-and-event-action-hooks}{Portal
  Property and Event Action Hooks}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/converting-strutsactionwrappers-to-mvccommands}{Struts
  Action Hooks}
\end{itemize}

Continue on to get started!

\section{Upgrading Customization
Modules}\label{upgrading-customization-modules}

Customization modules include any module extension or override used to
customize another module. For examples of these types of modules, visit
the
\href{https://github.com/liferay/liferay-blade-samples/tree/7.1/liferay-workspace/extensions}{\texttt{extensions}}
and
\href{https://github.com/liferay/liferay-blade-samples/tree/7.1/liferay-workspace/overrides}{\texttt{overrides}}
sample projects.

Getting a customization module running on 7.0 takes two steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Adapt your code to 7.0's API using the Liferay Upgrade Planner. When
  you ran the planner's \emph{Fix Upgrade Problems} step, many of the
  existing issues were autocorrected or flagged. For any remaining
  errors, consult the
  \href{/docs/7-1/tutorials/-/knowledge_base/t/resolving-a-plugins-dependencies}{Resolving
  a Plugin's Dependencies} article.
\item
  Deploy your module.
\end{enumerate}

\noindent\hrulefill

\textbf{Note:} A fragment was a common customization module in past
versions of Liferay DXP. Fragments are no longer recommended; you should
upgrade a fragment to a dynamic include or portlet filter. For more
information on recommended ways of customizing JSPs in 7.0, see the
\href{/docs/7-1/tutorials/-/knowledge_base/t/customizing-jsps}{Customizing
JSPs} section.

\noindent\hrulefill

Great! Your customization module is upgraded for 7.0!

\section{Upgrading Core JSP Hooks}\label{upgrading-core-jsp-hooks}

Getting a core JSP hook running on 7.0 takes two steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Adapt your code to 7.0's API using the Liferay Upgrade Planner. When
  you ran the planner's \emph{Fix Upgrade Problems} step, many of the
  existing issues were autocorrected or flagged. For any remaining
  errors, consult the
  \href{/docs/7-1/tutorials/-/knowledge_base/t/resolving-a-plugins-dependencies}{Resolving
  a Plugin's Dependencies} article.
\item
  Deploy your hook plugin.
\end{enumerate}

Liferay DXP's Plugin Compatibility Layer converts the plugin WAR to a
Web Application Bundle (WAB) and installs it to Liferay's OSGi Runtime.

It's just that easy!

\subsection{Related Topics}\label{related-topics-1}

\href{/docs/7-1/tutorials/-/knowledge_base/t/customizing-jsps}{Customizing
JSPs}

\href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-app-jsp-hook-plugins}{Upgrading
App JSP Hooks}

\href{/docs/7-1/tutorials/-/knowledge_base/t/resolving-a-plugins-dependencies}{Resolving
a Plugin's Dependencies}

\href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-the-liferay-maven-build}{Upgrading
the Liferay Maven Build}

\section{Upgrading App JSP Hooks}\label{upgrading-app-jsp-hooks}

JSPs in OSGi modules can be customized using module fragments. The
module fragment attaches to the host module to alter the JSPs. To the
OSGi runtime, the fragment is part of the host module. Section 3.14 of
the \href{https://www.osgi.org/developer/downloads/release-6/}{OSGi
Alliance's core specification document} explains module fragments in
detail. This tutorial shows you how to upgrade your app JSP hooks to
7.0.

Liferay Upgrade Planner's
\href{/docs/7-1/tutorials/-/knowledge_base/t/fixing-upgrade-problems}{\emph{Fixing
Upgrade Problems} step} generates module fragments from app JSP hook
plugins. The tool creates module fragments in the same folder as your
Plugins SDK root if your hook is in a Plugins SDK or in the
\texttt{{[}liferay\_workspace{]}/modules} folder if your hook is in a
Liferay Workspace.

Module fragments follow this name convention:
\texttt{{[}plugin\_name{]}-{[}app{]}-fragment}. For example, if the
plugin's name is \texttt{app-jsp-hook} and it modifies a JSP in the
Blogs app, the Upgrade Planner generates a module fragment named
\texttt{app-jsp-hook-blogs-fragment}.

Here are the steps for upgrading app JSP hook plugins:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \hyperref[declare-the-fragment-host]{Declare the Fragment Host}
\item
  \hyperref[update-the-jsp]{Update the JSP}
\end{enumerate}

\subsection{Declare the Fragment Host}\label{declare-the-fragment-host}

The module fragment's \texttt{bnd.bnd} file must specify an OSGi header
\texttt{Fragment-Host} set to the host module name and version.

If the host module belongs to one of Liferay DXP's app suites, the Code
Upgrade Tool generates a \texttt{bnd.bnd} file that specifies an
appropriate \texttt{Fragment-Host} header automatically.

For example, here's a \texttt{Fragment-Host} that attaches a module
fragment to the Blogs Web module.

\begin{verbatim}
Fragment-Host: com.liferay.blogs.web;bundle-version="1.1.9"
\end{verbatim}

Updating the JSP is straightforward too.

\subsection{Update the JSP}\label{update-the-jsp}

The Upgrade Planner creates a module fragment that contains an upgraded
version of your custom app JSP.

The following table shows the old and new JSP paths.

Liferay Portal version \textbar{} JSP File Path \textbar{} \textbf{6.2}
\textbar{}
\texttt{docroot/META-INF/custom\_jsps/html/portlet/{[}jsp\_file\_path{]}}
\textbf{7.1} \textbar{}
\texttt{src/main/resources/META-INF/resources/{[}jsp\_file\_path{]}}

For example, the Upgrade Planner generates a customized version of the
Blogs app's \texttt{init-ext.jsp} file here:

\begin{verbatim}
src/main/resources/META-INF/resources/blogs/init-ext.jsp
\end{verbatim}

The tool's
\href{/docs/7-1/tutorials/-/knowledge_base/t/fixing-upgrade-problems}{\emph{Fixing
Upgrade Problems} step} lets you compare custom JSPs with originals:

\begin{itemize}
\tightlist
\item
  Compare your custom 6.2 JSP with the original 6.2 JSP.
\item
  Compare your custom 7.1 JSP with your custom 6.2 JSP.
\end{itemize}

Make any additional needed changes in your 7.1 custom JSP. Then
\href{/docs/7-1/tutorials/-/knowledge_base/t/starting-module-development\#building-and-deploying-a-module}{deploy}
your module fragment. This stops the host module momentarily, attaches
the fragment to the host, and then restarts the host module. The console
output reflects this process.

Here's output from deploying a module fragment that attaches to the
Blogs web module.

\begin{verbatim}
19:23:11,740 INFO  [Refresh Thread: Equinox Container: 00ce6547-2355-0017-1884-846599e789c4][BundleStartStopLogger:38] STOPPED com.liferay.blogs.web_1.1.9 [535]
19:23:12,910 INFO  [Refresh Thread: Equinox Container: 00ce6547-2355-0017-1884-846599e789c4][BundleStartStopLogger:35] STARTED com.liferay.blogs.web_1.1.9 [535]
\end{verbatim}

Your custom JSP is live.

\subsection{Related Topics}\label{related-topics-2}

\href{/docs/7-1/tutorials/-/knowledge_base/t/customizing-jsps}{Customizing
JSPs}

\href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-core-jsp-hooks}{Upgrading
Core JSP Hooks}

\href{/docs/7-1/tutorials/-/knowledge_base/t/resolving-a-plugins-dependencies}{Resolving
a Plugin's Dependencies}

\href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-the-liferay-maven-build}{Upgrading
the Liferay Maven Build}

\section{Upgrading Service Wrappers}\label{upgrading-service-wrappers}

Upgrading traditional
\href{/docs/6-2/tutorials/-/knowledge_base/t/overriding-a-portal-service-using-a-hook}{service
wrapper hook plugins} to 7.0 is quick and easy.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Adapt your code to 7.0's API using the Liferay Upgrade Planner. When
  you ran the planner's \emph{Fix Upgrade Problems} step, many of the
  existing issues were autocorrected or flagged. For any remaining
  errors, consult the
  \href{/docs/7-1/tutorials/-/knowledge_base/t/resolving-a-plugins-dependencies}{Resolving
  a Plugin's Dependencies} article.
\item
  Deploy the plugin.
\end{enumerate}

Liferay DXP's Plugin Compatibility Layer converts the plugin WAR to a
Web Application Bundle (WAB) and installs it to Liferay's OSGi Runtime.

\subsection{Related Articles}\label{related-articles-1}

\href{/docs/7-1/tutorials/-/knowledge_base/t/customizing-liferay-services-service-wrappers}{Overriding
Liferay Services (Service Wrappers)}

\href{/docs/7-1/tutorials/-/knowledge_base/t/resolving-a-plugins-dependencies}{Resolving
a Plugin's Dependencies}

\href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-the-liferay-maven-build}{Upgrading
the Liferay Maven Build}

\section{Upgrading Core Language Key
Hooks}\label{upgrading-core-language-key-hooks}

Here are the steps for upgrading a core language key hook to 7.0.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a new module based on the Blade sample \texttt{resource-bundle}
  in
  \href{https://github.com/liferay/liferay-blade-samples/tree/7.1/gradle/extensions/resource-bundle}{Gradle}
  or
  \href{https://github.com/liferay/liferay-blade-samples/tree/7.1/maven/extensions/resource-bundle}{Maven}.

  Here are the main parts of the module folder structure:

  \begin{itemize}
  \tightlist
  \item
    \texttt{src/main/java/{[}resource\ bundle\ path{]}} → Custom
    resource bundle class goes here
  \item
    \texttt{src/main/resources/content}

    \begin{itemize}
    \tightlist
    \item
      \texttt{Language.properties}
    \item
      \texttt{Language\_xx.properties}
    \item
      \ldots{}
    \end{itemize}
  \end{itemize}
\item
  Copy all your plugin's language properties files into the module
  folder \texttt{src/main/resources/content/}.
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/overriding-global-language-keys\#create-a-resource-bundle-service-component}{Create
  a resource bundle loader}.
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/starting-module-development\#building-and-deploying-a-module}{Deploy
  your module}.
\end{enumerate}

Your core language key customizations are deployed to 7.0.

\subsection{Related Topics}\label{related-topics-3}

\href{/docs/7-1/tutorials/-/knowledge_base/t/overriding-global-language-keys}{Overriding
Global Language Keys}

\href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-portlet-language-key-hooks}{Upgrading
Portlet Language Key Hooks}

\href{/docs/7-1/tutorials/-/knowledge_base/t/resolving-a-plugins-dependencies}{Resolving
a Plugin's Dependencies}

\href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-the-liferay-maven-build}{Upgrading
the Liferay Maven Build}

\section{Upgrading Portlet Language Key
Hooks}\label{upgrading-portlet-language-key-hooks}

You can upgrade your portlet language key hooks to 7.0 by following
these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a new module based on the Blade sample \texttt{resource-bundle}
  (\href{https://github.com/liferay/liferay-blade-samples/tree/7.1/gradle/extensions/resource-bundle}{Gradle}
  or
  \href{https://github.com/liferay/liferay-blade-samples/tree/7.1/maven/extensions/resource-bundle}{Maven}
  project).

  Here are the module folder structure's main files:

  \begin{itemize}
  \tightlist
  \item
    \texttt{src/main/java/{[}resource\ bundle\ path{]}} →
    \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/}{\texttt{ResourceBundleLoader}
    extension} goes here
  \item
    \texttt{src/main/resources/content}

    \begin{itemize}
    \tightlist
    \item
      \texttt{Language.properties}
    \item
      \texttt{Language\_xx.properties}
    \item
      \ldots{}
    \end{itemize}
  \end{itemize}
\item
  Copy your language properties files into module folder
  \texttt{src/main/resources/content/}.
\item
  In your \texttt{bnd.bnd} file,
  \href{/docs/7-1/tutorials/-/knowledge_base/t/overriding-a-modules-language-keys}{specify
  OSGi manifest headers} that target the portlet module's resource
  bundle, but prioritize yours.
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/starting-module-development\#building-and-deploying-a-module}{Deploy
  your module}.
\end{enumerate}

Your portlet language key customizations are deployed in your new module
on 7.0.

\subsection{Related Topics}\label{related-topics-4}

\href{/docs/7-1/tutorials/-/knowledge_base/t/overriding-a-modules-language-keys}{Overriding
a Module's Language Keys}

\href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-core-language-key-hooks}{Upgrading
Core Language Key Hooks}

\href{/docs/7-1/tutorials/-/knowledge_base/t/resolving-a-plugins-dependencies}{Resolving
a Plugin's Dependencies}

\href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-the-liferay-maven-build}{Upgrading
the Liferay Maven Build}

\section{Upgrading Model Listener
Hooks}\label{upgrading-model-listener-hooks}

Developers have been creating model listeners for several Liferay Portal
versions. Upgrading Model Listener Hooks from previous portal versions
has never been easier.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Adapt your code to 7.0's API using the Liferay Upgrade Planner. When
  you ran the planner's \emph{Fix Upgrade Problems} step, many of the
  existing issues were autocorrected or flagged. For any remaining
  errors, consult the
  \href{/docs/7-1/tutorials/-/knowledge_base/t/resolving-a-plugins-dependencies}{Resolving
  a Plugin's Dependencies} article.
\item
  Deploy the plugin.
\end{enumerate}

Liferay DXP's Plugin Compatibility Layer converts the plugin WAR to a
Web Application Bundle (WAB) and installs it to Liferay's OSGi Runtime.

Your model listener hook is ``all ears'' and ready to act.

\subsection{Related Topics}\label{related-topics-5}

\href{/docs/7-1/tutorials/-/knowledge_base/t/model-listeners}{Creating
Model Listeners}

\href{/docs/7-1/tutorials/-/knowledge_base/t/resolving-a-plugins-dependencies}{Resolving
a Plugin's Dependencies}

\href{/docs/7-1/tutorials/-/knowledge_base/t/configuring-dependencies}{Configuring
Dependencies}

\href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-the-liferay-maven-build}{Upgrading
the Liferay Maven Build}

\section{Upgrading Servlet Filter
Hooks}\label{upgrading-servlet-filter-hooks}

If you have Servlet Filter Hooks ready to be upgraded, this tutorial's
for you. The process is quite simple:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Adapt your code to 7.0's API using the Liferay Upgrade Planner. When
  you ran the planner's \emph{Fix Upgrade Problems} step, many of the
  existing issues were autocorrected or flagged. For any remaining
  errors, consult the
  \href{/docs/7-1/tutorials/-/knowledge_base/t/resolving-a-plugins-dependencies}{Resolving
  a Plugin's Dependencies} article.
\item
  Deploy the plugin.
\end{enumerate}

Liferay DXP's Plugin Compatibility Layer converts the plugin WAR to a
Web Application Bundle (WAB) and installs it to Liferay's OSGi Runtime.

Your Servlet Filter is running on 7.0!

\subsection{Related Topics}\label{related-topics-6}

\href{/docs/7-1/tutorials/-/knowledge_base/t/resolving-a-plugins-dependencies}{Resolving
a Plugin's Dependencies}

\href{/docs/7-1/tutorials/-/knowledge_base/t/configuring-dependencies}{Configuring
Dependencies}

\href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-the-liferay-maven-build}{Upgrading
the Liferay Maven Build}

\section{Upgrading Portal Property and Event Action
Hooks}\label{upgrading-portal-property-and-event-action-hooks}

All portal properties in Liferay Portal 6.2 that are also used in 7.0
can be overridden. Portal property and portal event action hooks that
use these properties can be upgraded by following these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Adapt your code to 7.0's API using the Liferay Upgrade Planner. When
  you ran the planner's \emph{Fix Upgrade Problems} step, many of the
  existing issues were autocorrected or flagged. For any remaining
  errors, consult the
  \href{/docs/7-1/tutorials/-/knowledge_base/t/resolving-a-plugins-dependencies}{Resolving
  a Plugin's Dependencies} article.
\item
  Deploy your hook plugin.
\end{enumerate}

Liferay DXP's Plugin Compatibility Layer converts the plugin WAR to a
Web Application Bundle (WAB) and installs it to Liferay's OSGi Runtime.

Your custom property values and actions are live.

\subsection{Related Topics}\label{related-topics-7}

\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-ide}{Liferay Dev
Studio DXP}

\href{/docs/7-1/tutorials/-/knowledge_base/t/resolving-a-plugins-dependencies}{Resolving
a Plugin's Dependencies}

\href{/docs/7-1/tutorials/-/knowledge_base/t/configuring-dependencies}{Configuring
Dependencies}

\href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-the-liferay-maven-build}{Upgrading
the Liferay Maven Build}

\section{Converting StrutsAction Wrappers to
MVCCommands}\label{converting-strutsaction-wrappers-to-mvccommands}

In Liferay Portal 6.1 and 6.2, developers could customize the Portal and
Portlet Struts Actions using a Hook and \texttt{StrutsAction} wrapper.
For example, the \texttt{liferay-hook.xml} file for a hook that overrode
the login portlet's login action had this entry:

\begin{verbatim}
<struts-action>
    <struts-action-path>/login/login</struts-action-path>
    <struts-action-impl>
    com.liferay.sample.hook.action.ExampleStrutsPortletAction
    </struts-action-impl>
</struts-action>
\end{verbatim}

The \texttt{liferay-hook.xml} contains the Struts mapping and the new
class that overrides the default login action.

The wrapper could extend either \texttt{BaseStrutsAction} or
\texttt{BaseStrutsPortletAction}, depending on whether the Struts Action
was a portal or portlet action respectively.

Since 7.0, this mechanism no longer applies for most portlets because
they no longer use Struts Actions, but instead use Liferay
\texttt{MVCCommand}s.

This tutorial demonstrates how to convert your existing
\texttt{StrutsAction} wrappers to \texttt{MVCCommand}s.

\subsection{Converting Your old wrapper to
MVCCommands}\label{converting-your-old-wrapper-to-mvccommands}

Converting \texttt{StrutsAction} wrappers to \texttt{MVCCommand}s is
easier than you may think.

As a review, legacy \texttt{StrutsAction} wrappers implemented all
methods, such as \texttt{processAction}, \texttt{render}, and
\texttt{serveResource}, even if only one method was being customized.
Each of these methods can now be customized independently using
different classes, making the logic simpler and easier to maintain.
Depending on the method you customized in your \texttt{StrutsAction}
wrapper, you need to use the matching
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/bridges/mvc/MVCCommand.html}{\texttt{MVCCommand}
interface} shown below:

\begin{itemize}
\tightlist
\item
  processAction →
  ~\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/bridges/mvc/MVCActionCommand.html}{MVCActionCommand}
\item
  render →
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/bridges/mvc/MVCRenderCommand.html}{MVCRenderCommand}
\item
  serveResource →
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/bridges/mvc/MVCResourceCommand.html}{MVCResourceCommand}
\end{itemize}

Look at the
\href{/docs/6-2/tutorials/-/knowledge_base/t/overriding-and-adding-struts-actions}{\texttt{ExampleStrutsPortletAction}
class} for a \texttt{StrutsAction} wrapper example. Depending on the
actions overridden, the user must use different \texttt{MVCCommand}s. In
this example, the action and render were overridden, so to migrate to
the new pattern, you would create two classes: an
\texttt{MVCActionCommand} and \texttt{MVCRenderCommand}.

Next you'll determine the mapping the \texttt{MVCCommand} uses.

\subsection{Mapping Your MVCCommand
URLs}\label{mapping-your-mvccommand-urls}

For most cases, the \texttt{MVCCommand} mapping is the same mapping
defined in the legacy Struts Action.

Using the beginning login example once again, the
\texttt{struts-action-path} mapping, \texttt{/login/login}, remains the
same for the \texttt{MVCCommand} mapping in 7.0, but some of the
mappings may have changed. It's best to check Liferay DXP's source code
to determine the correct mapping.

Map to your MVCCommand URLs using portlet URL tags:

\begin{itemize}
\item
  \texttt{MVCRenderCommand} URLs go in \texttt{mvcRenderCommandName}
  parameters. For example:

\begin{verbatim}
<portlet:renderURL var="editEntryURL">
    <portlet:param name="mvcRenderCommandName" value="/hello/edit_entry" 
    />
    <portlet:param name="entryId" value="<%= String.valueOf(
    entry.getEntryId()) %>" />
</portlet:renderURL>    
\end{verbatim}
\item
  \texttt{MVCActionCommand} URLs go in \texttt{actionURL} tag
  \texttt{name} attributes or in a parameter
  \texttt{ActionRequest.ACTION\_NAME}. For example:

\begin{verbatim}
<portlet:actionURL name="/blogs/edit_entry" var="editEntryURL" />
\end{verbatim}
\item
  \texttt{MVCResourceCommand} URLs go in \texttt{resourceURL} tag
  \texttt{id} attributes. For example:

\begin{verbatim}
<portlet:resourceURL id="/login/captcha" var="captchaURL" />
\end{verbatim}
\end{itemize}

Once you have this information, you can override the \texttt{MVCCommand}
by following the instructions found in these \texttt{MVCCommand}
tutorials:

\begin{itemize}
\tightlist
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/adding-logic-to-mvc-commands}{Adding
  Logic to MVCCommands}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/overriding-mvcrendercommand}{Overriding
  MVCRenderCommands}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/overriding-mvcactioncommand}{Overriding
  MVCActionCommands}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/overriding-mvcresourcecommand}{Overriding
  MVCResourceCommands}
\end{itemize}

Now you know how to convert your \texttt{StrutsActionWrapper}s to
\texttt{MVCCommand}s!

\subsection{Related Topics}\label{related-topics-8}

\href{/docs/7-1/tutorials/-/knowledge_base/t/overriding-mvc-commands}{Overriding
MVC Commands}

\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-mvc-portlet}{Liferay
MVC Portlet}

\href{/docs/7-1/tutorials/-/knowledge_base/t/resolving-a-plugins-dependencies}{Resolving
a Plugin's Dependencies}

\href{/docs/7-1/tutorials/-/knowledge_base/t/configuring-dependencies}{Configuring
Dependencies}

\href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-the-liferay-maven-build}{Upgrading
the Liferay Maven Build}

\chapter{Upgrading 6.2 Themes}\label{upgrading-6.2-themes}

If you've developed themes in Liferay DXP 6.2, as part of your upgrade
you'll want to use them in 7.0. The upgrade process requires several
modifications. The
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-themes}{Liferay
Theme Generator} helps automate this process.

The following tutorials show you how to upgrade your Liferay Portal 6.2
themes to 7.0:

\begin{itemize}
\tightlist
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-6-2-themes-to-7-1}{Upgrading
  6.2 Themes to 7.1}
\end{itemize}

\section{Upgrading 6.2 Layout
Templates}\label{upgrading-6.2-layout-templates}

If you've developed layout templates in Liferay DXP 6.2, you can upgrade
them for 7.0. The upgrade process requires minimal changes.

The following tutorial shows you how to upgrade your Liferay Portal 6.2
layout templates to 7.0:

\begin{itemize}
\tightlist
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-6-2-layout-templates-to-7-1}{Upgrading
  6.2 Layout Templates to 7.1}
\end{itemize}

\section{Upgrading Frameworks and
Features}\label{upgrading-frameworks-and-features}

Your upgrade process not only relies on portlet technology, themes, and
customization plugins, but also the frameworks your project leverages.
The following frameworks and their upgrade processes are discussed in
this section:

\begin{itemize}
\tightlist
\item
  JNDI data source usage
\item
  Service Builder service invocation
\item
  Service Builder
\item
  Velocity templates
\end{itemize}

Continue on to learn more about upgrading these frameworks.

\section{Upgrading JNDI Data Source
Usage}\label{upgrading-jndi-data-source-usage}

In Liferay DXP's OSGi environment, you must use the portal's class
loader to load the application server's JNDI classes. An OSGi bundle's
attempt to connect to a JNDI data source without using Liferay DXP's
class loader results in a \texttt{java.lang.ClassNotFoundException}.

For more information on how to do this, see the
\href{/docs/7-1/tutorials/-/knowledge_base/t/connecting-to-data-sources-using-jndi}{Connecting
to JNDI Data Sources} article.

\section{Upgrading Service Builder Service
Invocation}\label{upgrading-service-builder-service-invocation}

When upgrading a portlet leveraging
\href{/docs/7-1/tutorials/-/knowledge_base/t/service-builder}{Service
Builder}, you must first decide if you're building your Service Builder
logic as a WAR or modularizing it.

\noindent\hrulefill

\textbf{Note:} Service Builder portlets automatically migrated to
Liferay Workspace using the Upgrade Planner or Blade CLI's
\texttt{convert} command automatically have its Service Builder logic
converted to API and implementation modules. This is a best practice for
7.0.

\noindent\hrulefill

If you prefer keeping your Service Builder logic as a WAR, you must
implement a service tracker to call services. See the
\href{/docs/7-1/tutorials/-/knowledge_base/t/service-trackers}{Service
Trackers} article for more information.

If you're optimizing your Service Builder logic to invoke Liferay
services from a module, see the
\href{/docs/7-1/tutorials/-/knowledge_base/t/invoking-local-services}{Invoking
Local Services} article for more information.

\section{Upgrading Service Builder}\label{upgrading-service-builder}

7.0 continues to use
\href{/docs/7-1/tutorials/-/knowledge_base/t/service-builder}{Service
Builder}, so you can focus on your application's business logic instead
of its persistence details. It still generates model classes, local and
remote services, and persistence.

Upgrading most Service Builder portlets involves these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \hyperref[step-1-adapt-the-code-to-product-vers-api]{Adapt the code to
  7.0's API}
\item
  \hyperref[step-2-resolve-dependencies]{Resolve dependencies}
\item
  \hyperref[step-3-build-the-services]{Build the services}
\end{enumerate}

Start by adapting the code.

\subsection{Step 1: Adapt the Code to 7.0's
API}\label{step-1-adapt-the-code-to-7.0s-api}

Adapt the portlet to 7.0's API using the Upgrade Planner. When running
the planner's \emph{Fix Upgrade Problems} step, many of the existing
issues are autocorrected. For remaining issues, the planner identifies
code affected by the new API and ways to adapt it.

For example, consider an example portlet with the following compilation
error:

\begin{verbatim}
/html/guestbook/view.jsp(58,1) PWC6131: Attribute total invalid for tag search-container-results according to TLD
\end{verbatim}

The \texttt{view.jsp} file specifies a tag library attribute
\texttt{total} that doesn't exist in 7.0's \texttt{liferay-ui} tag
library. Notice the second attribute \texttt{total}.

\begin{verbatim}
<liferay-ui:search-container-results
    results="<%=EntryLocalServiceUtil.getEntries(scopeGroupId,
                    guestbookId, searchContainer.getStart(),
                    searchContainer.getEnd())%>"
    total="<%=EntryLocalServiceUtil.getEntriesCount(scopeGroupId,
                    guestbookId)%>" />
\end{verbatim}

Remove the \texttt{total} attribute assignment to make the tag like
this:

\begin{verbatim}
<liferay-ui:search-container-results
    results="<%=EntryLocalServiceUtil.getEntries(scopeGroupId,
                    guestbookId, searchContainer.getStart(),
                    searchContainer.getEnd())%>" />
\end{verbatim}

Resolve these error types and others until your code is adapted to the
new API.

\subsection{Step 2: Resolve
Dependencies}\label{step-2-resolve-dependencies}

To adapt your app's dependencies, refer to the
\href{/docs/7-1/tutorials/-/knowledge_base/t/resolving-a-plugins-dependencies}{Resolving
a Plugin's Dependencies} tutorial. Once your dependencies are upgraded,
rebuild your services!

\subsection{Step 3: Build the Services}\label{step-3-build-the-services}

To rebuild your portlet's services, see the
\href{/docs/7-1/tutorials/-/knowledge_base/t/running-service-builder}{Running
Service Builder} article.

An example change where upgrading legacy Service Builder code can
produce differing results is explained below.

A Liferay Portal 6.2 portlet's \texttt{service.xml} file specifies
exception class names in \texttt{exception} elements like this:

\begin{verbatim}
<service-builder package-path="com.liferay.docs.guestbook">
    ...
    <exceptions>
        <exception>GuestbookName</exception>
        <exception>EntryName</exception>
        <exception>EntryMessage</exception>
        <exception>EntryEmail</exception>
    </exceptions>
</service-builder>
\end{verbatim}

In Liferay Portal 6.2, Service Builder generates exception classes to
the path attribute \texttt{package-path} specifies. In 7.0, Service
Builder generates them to \texttt{{[}package-path{]}/exception}.

Old path:

\begin{verbatim}
[package-path]
\end{verbatim}

New path:

\begin{verbatim}
[package-path]/exception 
\end{verbatim}

For example, the example portlet's package path is
\texttt{com.liferay.docs.guestbook}. Its exception class for
\texttt{exception} element \texttt{GuestbookName} is generated to
\texttt{docroot/WEB-INF/service/com/liferay/docs/guestbook/exception}.
Classes that use the exception must import
\texttt{com.liferay.docs.guestbook.exception.GuestbookNameException}. If
this upgrade is required in your Service Builder project, you must
update the references to your portlet's exception classes.

Once your Service Builder portlet is upgraded, deploy it.

\noindent\hrulefill

\textbf{Note:} Service Builder portlets automatically migrated to
Liferay Workspace using the Upgrade Planner or Blade CLI's
\texttt{convert} command automatically has its Service Builder logic
converted to API and implementation modules. This is a best practice for
7.0.

\noindent\hrulefill

The portlet is now available on Liferay DXP. Congratulations on
upgrading a portlet that uses Service Builder!

\section{Migrating Off of Velocity
Templates}\label{migrating-off-of-velocity-templates}

Velocity templates were deprecated in Liferay Portal 7.0 and are now
removed in favor of FreeMarker templates in 7.0. Below are the key
reasons for this move:

\begin{itemize}
\item
  FreeMarker is developed and maintained regularly, while Velocity is no
  longer actively being developed.
\item
  FreeMarker is faster and supports more sophisticated macros.
\item
  FreeMarker supports using taglibs directly rather than requiring a
  method to represent them. You can pass body content to them,
  parameters, etc.
\end{itemize}

Although Velocity templates still work in 7.0, we highly recommend
migrating to FreeMarker templates. For more information on this topic,
see the
\href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-6-2-layout-templates}{Upgrading
Layout Templates} section.

\chapter{Upgrading Portlet Plugins}\label{upgrading-portlet-plugins}

All portlet plugin types developed for Liferay Portal 6 can be upgraded
and deployed to 7.0.

Upgrading most portlets involves these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Adapt the code to 7.0's API
\item
  Resolve dependencies
\end{enumerate}

Liferay's Upgrade Planner helps you adapt your code to 7.0's API. And
resolving a portlet's dependencies is straightforward. In most cases,
after you finish the above steps, you can deploy your portlet to Liferay
DXP.

The portlet upgrade tutorials show you how to upgrade the following
common portlets:

\begin{itemize}
\tightlist
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-a-genericportlet}{GenericPortlet}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-a-liferay-mvc-portlet}{Liferay
  MVC Portlet}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-portlets-that-use-service-builder}{Portlet
  that uses Service Builder}
\item
  \href{develop/tutorials/-/knowledge_base/7-1/upgrading-a-liferay-jsf-portlet}{Liferay
  JSF Portlet}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-a-servlet-based-portlet}{Servlet-based
  portlet}
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/upgrading-a-struts-portlet}{Struts
  Portlet}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-a-spring-mvc-portlet}{Spring
  MVC Portlet}
\end{itemize}

The tutorials provide example portlet source code from before and after
upgrading the example portlet. Each tutorial's steps were applied to the
example portlet. You can refer to example code as you upgrade your
portlet.

Let's get your portlet running on 7.0!

\section{Upgrading a GenericPortlet}\label{upgrading-a-genericportlet}

It's common to create portlets that extend
\texttt{javax.portlet.GenericPortlet}. After all,
\texttt{GenericPortlet} provides a default
\texttt{javax.portlet.Portlet} interface implementation. Upgrading a
\texttt{GenericPortlet} is straightforward and takes only two steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Adapt the portlet to 7.0's API using the Liferay Upgrade Planner.
\item
  Resolve its dependencies.
\end{enumerate}

This tutorial demonstrates upgrading a Liferay Plugins SDK 6.2 sample
portlet called \emph{Sample DAO} (project \texttt{sample-dao-portlet}).

\begin{figure}
\centering
\includegraphics{./images/upgrading-portlets-sample-dao-portlet.png}
\caption{The \texttt{sample-dao-portlet} lets users manage food items.}
\end{figure}

The sample portlet lets users view, add, edit, and delete food items
from a listing. For reference, you can download the
\href{https://portal.liferay.dev/documents/113763090/114000186/sample-dao-portlet-pre-7-0-upgrade.zip}{pre-upgraded
portlet code} and the
\href{https://portal.liferay.dev/documents/113763090/114000653/sample-dao-portlet-post-7-1-upgrade.zip}{upgraded
code}.

The sample portlet has the following characteristics:

\begin{itemize}
\tightlist
\item
  Extends \texttt{GenericPortlet}
\item
  View layer implemented by JSPs
\item
  Persists models using the Data Access Object (DAO) design pattern
\item
  Specifies database connection information in a properties file
\item
  Manages dependencies via Ant/Ivy
\item
  Developed in a Liferay Plugins SDK 6.2
\end{itemize}

The portlet uses a traditional Plugins SDK portlet project folder
structure.

\begin{figure}
\centering
\includegraphics{./images/upgrading-a-genericportlet-folder-structure.png}
\caption{The \texttt{sample-dao-portlet} project uses a typical Plugins
SDK portlet folder structure}
\end{figure}

Upgrading most \texttt{GenericPortlet} portlets involves these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/fixing-upgrade-problems}{Adapt
  the code to 7.0's API}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/resolving-a-plugins-dependencies}{Resolve
  dependencies}
\end{enumerate}

Since the sample portlet's dependencies haven't changed, upgrading it
involves only adapting the code to 7.0's API. The
\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-upgrade-planner}{Liferay
Upgrade Planner} facilitates updating the code and resolving compilation
issues quickly.

\noindent\hrulefill

\textbf{Note}: Refer to tutorial
\href{/docs/7-1/tutorials/-/knowledge_base/t/resolving-a-plugins-dependencies}{Resolving
a Plugin's Dependencies} if you need to adapt to dependency changes.

\noindent\hrulefill

You deploy a \texttt{GenericPortlet} to 7.0 in the same way you deploy
to Portal 6.x. When the plugin WAR file lands in the
\texttt{{[}Liferay\_Home{]}/deploy} folder, Liferay DXP's Plugin
Compatibility Layer converts the WAR to a Web Application Bundle (WAB)
and installs the portlet as a WAB to Liferay DXP's OSGi runtime.

On deploying an upgraded portlet, the server prints messages that
indicate the following portlet status:

\begin{itemize}
\tightlist
\item
  WAR processing
\item
  WAB startup
\item
  Availability to users
\end{itemize}

Deploying the sample portlet produces messages like these:

\begin{verbatim}
2018-03-21 17:44:59.179 INFO  [com.liferay.portal.kernel.deploy.auto.AutoDeployScanner][AutoDeployDir:262] Processing sample-dao-portlet-7.1.0.1.war
...
2018-03-21 17:45:09.959 INFO  [Refresh Thread: Equinox Container: 0012cbb0-7e2c-0018-146e-95a4d71cdf95][PortletHotDeployListener:298] 1 portlet for sample-dao-portlet is available for use 
...
2018-03-21 17:45:10.151 INFO  [Refresh Thread: Equinox Container: 0012cbb0-7e2c-0018-146e-95a4d71cdf95][BundleStartStopLogger:35] STARTED sample-dao-portlet_7.1.0.1 [655]
\end{verbatim}

The portlet is now available on Liferay DXP.

You've learned how to upgrade and deploy a portlet that extends
\texttt{GenericPortlet}. You adapt the code, resolve dependencies, and
deploy the portlet as you always have. It's just that easy!

\textbf{Related Topics}

\href{/docs/7-1/tutorials/-/knowledge_base/t/migrating-traditional-plugins-to-workspace-web-applications}{Migrating
Plugins SDK Projects to Workspace and Gradle}

\href{/docs/7-1/tutorials/-/knowledge_base/t/resolving-a-plugins-dependencies\#using-a-dependency-management-tool}{Using
Dependency Management Tools}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-the-wab-generator}{Using
the WAB Generator}

\href{/docs/7-1/tutorials/-/knowledge_base/t/optimizing-app-upgrade-processes}{Migrating
Data Upgrade Processes}

\section{Upgrading a Liferay MVC
Portlet}\label{upgrading-a-liferay-mvc-portlet}

Liferay's MVC Portlet framework is used extensively in Liferay's
portlets and is a popular choice for Liferay Portal 6.2 portlet
developers. The
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/bridges/mvc/MVCPortlet.html}{\texttt{MVCPortlet}
class} is a lightweight extension of
\texttt{javax.portlet.GenericPortlet}. Its \texttt{init} method saves
you from writing a lot of boilerplate code. MVC portlets can upgraded to
7.0 without a hitch.

To upgrade a Liferay MVC Portlet, adapt your code to 7.0's API using the
Liferay Upgrade Planner. When you ran the planner's \emph{Fix Upgrade
Problems} step, many of the existing issues were autocorrected or
flagged. For any remaining errors, consult the
\href{/docs/7-1/tutorials/-/knowledge_base/t/resolving-a-plugins-dependencies}{Resolving
a Plugin's Dependencies} article.

Liferay's
\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-upgrade-planner}{Upgrade
Planner} identifies code affected by the new API, explains the API
changes and how to adapt to them, and in many cases, provides options
for adapting the code automatically.

After you upgrade your portlet, deploy it the same way you always do.

The server prints messages that indicate the following portlet status:

\begin{itemize}
\tightlist
\item
  WAR processing
\item
  WAB startup
\item
  Availability to users
\end{itemize}

You've upgraded and deployed your Liferay MVC Portlet on your 7.0
instance. Have fun showing off your upgraded portlet!

\textbf{Related Topics}

\href{/docs/7-1/tutorials/-/knowledge_base/t/migrating-traditional-plugins-to-workspace-web-applications}{Migrating
Plugins SDK Projects to Workspace and Gradle}

\href{/docs/7-1/tutorials/-/knowledge_base/t/resolving-a-plugins-dependencies\#using-a-dependency-management-tool}{Using
Dependency Management Tools}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-the-wab-generator}{Using
the WAB Generator}

\href{/docs/7-1/tutorials/-/knowledge_base/t/optimizing-app-upgrade-processes}{Migrating
Data Upgrade Processes}

\section{Upgrading Portlets that use Service
Builder}\label{upgrading-portlets-that-use-service-builder}

7.0 continues to use
\href{/docs/7-1/tutorials/-/knowledge_base/t/service-builder}{Service
Builder}, so you can focus on your application's business logic instead
of its persistence details. It still generates model classes, local and
remote services, and persistence.

This tutorial demonstrates upgrading a Liferay Plugins SDK 6.2 portlet
called Guestbook portlet (project \texttt{guestbook-portlet}). It's from
the
\href{/docs/6-2/tutorials/-/knowledge_base/t/writing-a-data-driven-application}{Writing
a Data-Driven Application} section of the Liferay Portal 6.2 Learning
Path
\href{/docs/6-2/tutorials/-/knowledge_base/t/writing-a-liferay-mvc-application}{Writing
a Liferay MVC Application}.

\begin{figure}
\centering
\includegraphics{./images/upgrade-service-builder-portlet-guestbook.png}
\caption{The Guestbook portlet models guestbooks and guestbook entries.}
\end{figure}

To get the most from this tutorial, you can download and refer to the
\href{https://portal.liferay.dev/documents/113763090/114000186/guestbook-portlet-pre-7-0-upgrade.zip}{original
portlet source code} and the
\href{https://portal.liferay.dev/documents/113763090/114000653/guestbook-portlet-post-7-1-upgrade.zip}{upgraded
source code}.

The Guestbook portlet has the following characteristics:

\begin{itemize}
\tightlist
\item
  Extends \texttt{MVCPortlet}
\item
  Separate Model, View, and Controller layers
\item
  Persistence by Hibernate under Service Builder
\item
  View layer implemented by JSPs
\item
  Relies on manual dependency management
\item
  Developed in a Liferay Plugins SDK 6.2
\end{itemize}

Upgrading most Service Builder Portlets involves these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \hyperref[1-adapt-the-code-to-product-vers-api]{Adapt the code to
  7.0's API}
\item
  \hyperref[2-resolve-dependencies]{Resolve dependencies}
\item
  \hyperref[3-build-the-services]{Build the services}
\end{enumerate}

Start by adapting the code.

\subsection{1. Adapt the code to 7.0's
API}\label{adapt-the-code-to-7.0s-api}

Use the
\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-upgrade-planner}{Liferay
Upgrade Planner} to update the code and resolve compilation issues
quickly. Then fix any remaining compilation errors manually.

The Guestbook portlet has the following compilation error:

\begin{verbatim}
/html/guestbook/view.jsp(58,1) PWC6131: Attribute total invalid for tag search-container-results according to TLD
\end{verbatim}

The \texttt{view.jsp} file specifies a tag library attribute
\texttt{total} that doesn't exist in 7.0's \texttt{liferay-ui} tag
library. Notice the second attribute \texttt{total}.

\begin{verbatim}
<liferay-ui:search-container-results
    results="<%=EntryLocalServiceUtil.getEntries(scopeGroupId,
                    guestbookId, searchContainer.getStart(),
                    searchContainer.getEnd())%>"
    total="<%=EntryLocalServiceUtil.getEntriesCount(scopeGroupId,
                    guestbookId)%>" />
\end{verbatim}

Remove the \texttt{total} attribute assignment to make the tag like
this:

\begin{verbatim}
<liferay-ui:search-container-results
    results="<%=EntryLocalServiceUtil.getEntries(scopeGroupId,
                    guestbookId, searchContainer.getStart(),
                    searchContainer.getEnd())%>" />
\end{verbatim}

That's the Guestbook portlet's only compilation error you need to fix
manually.

\subsection{2. Resolve dependencies}\label{resolve-dependencies}

Since the Guestbook portlet's dependencies haven't changed, there aren't
any dependencies to resolve.

If you need to adapt a portlet's dependencies, refer to tutorial
\href{/docs/7-1/tutorials/-/knowledge_base/t/resolving-a-plugins-dependencies}{Resolving
a Plugin's Dependencies}.

\subsection{3. Build the services}\label{build-the-services}

\href{/docs/7-1/tutorials/-/knowledge_base/t/running-service-builder}{Build
the services} as you did in Liferay Portal 6.2.

The Guestbook portlet's \texttt{service.xml} file specifies exception
class names in \texttt{exception} elements.

\begin{verbatim}
<service-builder package-path="com.liferay.docs.guestbook">
    ...
    <exceptions>
        <exception>GuestbookName</exception>
        <exception>EntryName</exception>
        <exception>EntryMessage</exception>
        <exception>EntryEmail</exception>
    </exceptions>
</service-builder>
\end{verbatim}

In Liferay Portal 6.2, Service Builder generates exception classes to
the path attribute \texttt{package-path} specifies. In 7.0, Service
Builder generates them to \texttt{{[}package-path{]}/exception}.

Old path:

\begin{verbatim}
[package-path]
\end{verbatim}

New path:

\begin{verbatim}
[package-path]/exception 
\end{verbatim}

For example, the Guestbook portlet's package path is
\texttt{com.liferay.docs.guestbook}. Its exception class for
\texttt{exception} element \texttt{GuestbookName} is generated to
\texttt{docroot/WEB-INF/service/com/liferay/docs/guestbook/exception}.
Classes that use the exception must import
\texttt{com.liferay.docs.guestbook.exception.GuestbookNameException}.

Update references to your portlet's exception classes.

Deploy the portlet as you normally would. The server prints messages
indicating the following portlet status:

\begin{itemize}
\tightlist
\item
  WAR processing
\item
  WAB startup
\item
  Availability to users
\end{itemize}

Deploying the Guestbook portlet produces these messages:

\begin{verbatim}
2018-03-21 18:23:10.032 INFO  [com.liferay.portal.kernel.deploy.auto.AutoDeployScanner][AutoDeployDir:262] Processing guestbook-portlet-7.1.0.1.war
2018-03-21 18:23:15.355 INFO  [fileinstall-C:/portals/liferay-ce-portal-7.1-m1/osgi/war][BaseAutoDeployListener:43] Copying portlets for C:\portals\liferay-ce-portal-7.1-m1\tomcat-8.0.32\temp\20180321182315333UGEPAGTR\guestbook-portlet.war
2018-03-21 18:23:15.829 INFO  [fileinstall-C:/portals/liferay-ce-portal-7.1-m1/osgi/war][BaseDeployer:876] Deploying guestbook-portlet.war
2018-03-21 18:23:17.797 INFO  [fileinstall-C:/portals/liferay-ce-portal-7.1-m1/osgi/war][BaseAutoDeployListener:50] Portlets for C:\portals\liferay-ce-portal-7.1-m1\tomcat-8.0.32\temp\20180321182315333UGEPAGTR\guestbook-portlet.war copied successfully
2018-03-21 18:23:19.621 INFO  [fileinstall-C:/portals/liferay-ce-portal-7.1-m1/osgi/war][HotDeployImpl:226] Deploying guestbook-portlet from queue
2018-03-21 18:23:19.621 INFO  [fileinstall-C:/portals/liferay-ce-portal-7.1-m1/osgi/war][PluginPackageUtil:1003] Reading plugin package for guestbook-portlet
2018-03-21 18:23:19.642 INFO  [fileinstall-C:/portals/liferay-ce-portal-7.1-m1/osgi/war][ServiceComponentLocalServiceImpl:598] Running GB SQL scripts
21-Mar-2018 18:23:19.669 INFO [fileinstall-C:/portals/liferay-ce-portal-7.1-m1/osgi/war] org.apache.catalina.core.ApplicationContext.log Initializing Spring root WebApplicationContext
2018-03-21 18:23:20.066 INFO  [fileinstall-C:/portals/liferay-ce-portal-7.1-m1/osgi/war][PortletHotDeployListener:186] Registering portlets for guestbook-portlet
2018-03-21 18:23:20.271 INFO  [fileinstall-C:/portals/liferay-ce-portal-7.1-m1/osgi/war][PortletHotDeployListener:298] 1 portlet for guestbook-portlet is available for use
2018-03-21 18:23:20.468 INFO  [fileinstall-C:/portals/liferay-ce-portal-7.1-m1/osgi/war][BundleStartStopLogger:35] STARTED guestbook-portlet_7.1.0.1 [657]
\end{verbatim}

The portlet is now available on Liferay DXP.

Congratulations on upgrading and deploying a portlet that uses Service
Builder.

\subsection{Related Topics}\label{related-topics-9}

\href{/docs/7-1/tutorials/-/knowledge_base/t/migrating-traditional-plugins-to-workspace-web-applications}{Migrating
Plugins SDK Projects to Workspace and Gradle}

\href{/docs/7-1/tutorials/-/knowledge_base/t/resolving-a-plugins-dependencies\#using-a-dependency-management-tool}{Using
Dependency Management Tools}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-the-wab-generator}{Using
the WAB Generator}

\href{/docs/7-1/tutorials/-/knowledge_base/t/optimizing-app-upgrade-processes}{Migrating
Data Upgrade Processes}

\section{Upgrading a Liferay JSF
Portlet}\label{upgrading-a-liferay-jsf-portlet}

Liferay JSF portlets are easy to upgrade and require few changes. They
interface with the
\href{/docs/7-1/reference/-/knowledge_base/r/liferay-faces}{Liferay
Faces} project, which encapsulates Liferay DXP's Java API and JavaScript
code. Because of this, upgrading JSF portlets to 7.0 requires only
updating dependencies.

There are two ways to find a JSF portlet's dependencies for 7.0:

\begin{itemize}
\tightlist
\item
  The \url{http://liferayfaces.org/} home page lets you look up the
  dependencies (Gradle or Maven) by Liferay DXP version, JSF version,
  and component suites.
\item
  The
  \href{/docs/7-1/reference/-/knowledge_base/r/liferay-faces-version-scheme}{Liferay
  Faces Version Scheme} article's tables list artifacts by Liferay DXP
  version, JSF version, portlet version, and AlloyUI and Metal component
  suite version.
\end{itemize}

In this tutorial, you'll see how easy it is to upgrade a Liferay Portal
6.2 JSF portlet (JSF 2.2) to 7.0 by upgrading the sample JSF Applicant
portlet. This portlet provides a job application users can submit.

\begin{figure}
\centering
\includegraphics{./images/jsf-applicant-6-2.png}
\caption{The JSF Applicant portlet provides a job application for users
to submit.}
\end{figure}

For reference, you can download the
\href{https://portal.liferay.dev/documents/113763090/114000186/jsf-applicant-portlet-6.2.zip}{pre-upgraded
portlet code} and the
\href{https://portal.liferay.dev/documents/113763090/114000653/jsf-applicant-portlet-7.1.zip}{upgrade
portlet code}. This sample project uses Maven.

Follow these steps to upgrade your Liferay JSF portlet.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open your Liferay JSF portlet's build file (e.g., \texttt{pom.xml},
  \texttt{build.gradle}) to where the dependencies are configured.
\item
  Navigate to the \url{http://liferayfaces.org/} site and generate a
  dependency list by choosing the environment to which you want to
  upgrade your portlet.

  \begin{figure}
  \centering
  \includegraphics{./images/jsf-dependency-generation.png}
  \caption{The Liferay Faces site gives you options to generate
  dependencies for many environments.}
  \end{figure}
\item
  Compare the generated dependencies with your portlet's dependencies
  and make any necessary updates. For the sample JSF Applicant portlet,
  the Mojarra dependency and two Liferay Faces dependencies require
  updating:

\begin{verbatim}
<dependency>
    <groupId>org.glassfish</groupId>
    <artifactId>javax.faces</artifactId>
    <version>2.2.13</version>
    <scope>runtime</scope>
</dependency>
<dependency>
    <groupId>com.liferay.faces</groupId>
    <artifactId>com.liferay.faces.bridge.ext</artifactId>
    <version>3.0.0</version>
</dependency>
<dependency>
    <groupId>com.liferay.faces</groupId>
    <artifactId>com.liferay.faces.bridge.impl</artifactId>
    <version>4.0.0</version>
</dependency>
\end{verbatim}

  Update the dependencies according to the
  \url{http://liferayfaces.org/} dependency list. For example,

\begin{verbatim}
<dependency>
    <groupId>org.glassfish</groupId>
    <artifactId>javax.faces</artifactId>
    <version>2.2.18</version>
    <scope>runtime</scope>
</dependency>
<dependency>
    <groupId>com.liferay.faces</groupId>
    <artifactId>com.liferay.faces.bridge.ext</artifactId>
    <version>5.0.3</version>
</dependency>
<dependency>
    <groupId>com.liferay.faces</groupId>
    <artifactId>com.liferay.faces.bridge.impl</artifactId>
    <version>4.1.2</version>
</dependency>
\end{verbatim}
\end{enumerate}

That's it! Your Liferay JSF portlet is upgraded and deployable to 7.0!

You deploy a Liferay JSF portlet to 7.0 the same way you deploy to
Portal 6.x. When the plugin WAR file lands in the
\texttt{{[}Liferay\_Home{]}/deploy} folder, Liferay DXP's Plugin
Compatibility Layer converts the WAR to a Web Application Bundle (WAB)
and installs the portlet as a WAB to Liferay DXP's OSGi runtime.

On deploying an upgraded portlet, the server prints messages that
indicate the following portlet status:

\begin{itemize}
\tightlist
\item
  WAR processing
\item
  WAB startup
\item
  Availability to users
\end{itemize}

Deploying a Liferay JSF portlet produces messages like these:

\begin{verbatim}
13:41:43,690 INFO ... [com.liferay.portal.kernel.deploy.auto.AutoDeployScanner][AutoDeployDir:252] Processing com.liferay.faces.demo.jsf.applicant.portlet-1.0.war
...
13:42:03,522 INFO  [fileinstall-C:/liferay-ce-portal-7.1-ga1/osgi/war][BundleStartStopLogger:35] STARTED com.liferay.faces.demo.jsf.applicant.portlet-1.0_4.1.0 [503]
...
13:42:05,169 INFO  [fileinstall-C:/liferay-ce-portal-7.1-ga1/osgi/war][PortletHotDeployListener:293] 1 portlet for com.liferay.faces.demo.jsf.applicant.portlet-1.0 is available for use
\end{verbatim}

After the portlet deployment is complete, it's available on Liferay DXP.

\begin{figure}
\centering
\includegraphics{./images/jsf-applicant-7-1.png}
\caption{You've successfully updated the JSF Applicant portlet for 7.0!}
\end{figure}

You've learned how to upgrade and deploy a Liferay JSF portlet. You
resolved dependencies and deployed the portlet as you always have. It's
just that easy!

\section{Upgrading a Servlet-based
Portlet}\label{upgrading-a-servlet-based-portlet}

This tutorial shows you how to upgrade servlet-based portlets. It refers
to code from before and after upgrading a sample servlet-based portlet
called \emph{Sample JSON} (project \texttt{sample-json-portlet}). The
portlet shows a \emph{Click me} link. When users click the link, the
Liferay logo appears.

\begin{figure}
\centering
\includegraphics{./images/upgrading-portlets-sample-servlet-json-initial-view.png}
\caption{The Sample JSON portlet displays text stating \emph{Click me}
that you can click to initiate an action.}
\end{figure}

To get the most from this tutorial, download and refer to the
\href{https://portal.liferay.dev/documents/113763090/114000186/sample-json-portlet-pre-7-0-upgrade.zip}{original
sample portlet source code} and the
\href{https://portal.liferay.dev/documents/113763090/114000653/sample-json-portlet-post-7-1-upgrade.zip}{upgraded
source code}.

Here are the sample portlet's characteristics:

\begin{itemize}
\tightlist
\item
  Processes requests using a servlet that extends
  \texttt{javax.servlet.HttpServlet}
\item
  View layer implemented by JSPs
\item
  Processes data using JSON objects
\item
  Relies on manual dependency management
\item
  Depends on third-party libraries that Liferay Portal 6.2 provides
\item
  Embeds additional dependencies in its \texttt{WEB-INF/lib} folder
\item
  Developed in a Liferay Plugins SDK 6.2
\end{itemize}

To upgrade a servlet-base Portlet, adapt your code to 7.0's API using
the Liferay Upgrade Planner. When you ran the planner's \emph{Fix
Upgrade Problems} step, many of the existing issues were autocorrected
or flagged. For any remaining errors, consult the
\href{/docs/7-1/tutorials/-/knowledge_base/t/resolving-a-plugins-dependencies}{Resolving
a Plugin's Dependencies} article.

Liferay's
\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-upgrade-planner}{Upgrade
Planner} identifies code affected by the new API, explains the API
changes and how to adapt to them, and in many cases, provides options
for adapting the code automatically.

The sample portlet relied on Liferay Portal to provide several
dependency JAR files. Here's the \texttt{portal-dependency-jars}
property from the portlet's \texttt{liferay-plugin-package.properties}
file:

\begin{verbatim}
portal-dependency-jars=\
    dom4j.jar,\
    jabsorb.jar,\
    json-java.jar
\end{verbatim}

Instructions for using packages that Liferay DXP exports are found
\href{/docs/7-1/tutorials/-/knowledge_base/t/resolving-a-plugins-dependencies\#using-packages-portal-exports}{here}.
7.0's core system exports the package this portlet needs from each of
the above dependency JARs.

The upgraded sample portlet continues to specify these JARs in the
\texttt{portal-dependency-jars} property. They're made available to the
portlet at compile time. But to keep compile time packages from
conflicting with the core system's exported packages, the Liferay
Plugins SDK 7.0 excludes the JARs from the plugin WAR.

Next, deploy your portlet as you always have.

The server prints messages that indicate the following portlet status:

\begin{itemize}
\tightlist
\item
  WAR processing
\item
  WAB startup
\item
  Availability to users
\end{itemize}

\noindent\hrulefill

Note: On deploying the sample upgraded portlet, the
\href{/docs/7-1/tutorials/-/knowledge_base/t/using-the-wab-generator}{WAB
processor} warns that the \texttt{portal-dependency-jars} property is
deprecated.

\begin{verbatim}
 21:40:25,347 WARN  [fileinstall-...][WabProcessor:564] The property "portal-dependency-jars" is deprecated. Specified JARs may not be included in the class path.
\end{verbatim}

For running on 7.0, it's fine to specify
the\texttt{portal-dependency-jars} property per the
\href{resolving-a-plugins-dependencies\#using-packages-liferay-portal-exports}{instructions}
for using packages that Liferay DXP exports. After upgrading, consider
\href{/docs/7-1/tutorials/-/knowledge_base/t/resolving-a-plugins-dependencies\#using-a-dependency-management-tool}{using
a dependency management tool} in your project. This helps prepare it for
future Liferay DXP versions and facilitates managing dependencies.

\noindent\hrulefill

The portlet is installed to Liferay's OSGi runtime and is available to
users.

\begin{figure}
\centering
\includegraphics{./images/upgrading-portlets-sample-servlet-json.png}
\caption{Clicking on the sample portlet's \emph{Click me} link shows the
Liferay logo.}
\end{figure}

Congratulations! You've upgraded and deployed your servlet-based portlet
to 7.0.

\textbf{Related Topics}

\href{/docs/7-1/tutorials/-/knowledge_base/t/migrating-traditional-plugins-to-workspace-web-applications}{Migrating
Plugins SDK Projects to Workspace and Gradle}

\href{/docs/7-1/tutorials/-/knowledge_base/t/resolving-a-plugins-dependencies\#using-a-dependency-management-tool}{Using
Dependency Management Tools}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-the-wab-generator}{Using
the WAB Generator}

\href{/docs/7-1/tutorials/-/knowledge_base/t/optimizing-app-upgrade-processes}{Migrating
Data Upgrade Processes}

\section{Upgrading a Spring MVC
portlet}\label{upgrading-a-spring-mvc-portlet}

The
\href{https://docs.spring.io/spring/docs/current/spring-framework-reference/html/portlet.html}{Spring
Portlet MVC framework} facilitates injecting dependencies and
implementing the Model View Controller pattern in portlets. If you use
this framework in a portlet for Liferay Portal 6.x, you can upgrade it
to 7.0.

This tutorial demonstrates upgrading a Spring MVC portlet called My
Spring MVC (project \texttt{my-spring-mvc-portlet}). It's a bare-bones
portlet created from the Plugins SDK's \texttt{spring\_mvc} template.

\begin{figure}
\centering
\includegraphics{./images/upgraded-spring-mvc-portlet.png}
\caption{My Spring MVC portlet shows its name and Liferay DXP's
information.}
\end{figure}

To follow along, download and refer to the
\href{https://portal.liferay.dev/documents/113763090/114000186/my-spring-mvc-portlet-pre-7-0-upgrade.zip}{original
source code} and the
\href{https://portal.liferay.dev/documents/113763090/114000653/my-spring-mvc-portlet-post-7-1-upgrade.zip}{upgraded
source code}.

The figure below shows the \texttt{my-spring-mvc-portlet} project.

\begin{figure}
\centering
\includegraphics{./images/upgrading-spring-mvc-portlets-folder-structure.png}
\caption{The \texttt{my-spring-mvc-portlet} project has traditional
Liferay plugin files, Spring Portlet MVC application contexts (in
\texttt{spring-context/}), and a controller class
\texttt{MySpringMVCPortletviewController}.}
\end{figure}

These files have Spring-related content:

\begin{itemize}
\tightlist
\item
  \texttt{view.jsp} → Shows the portlet's name and Liferay DXP's release
  information.
\item
  \texttt{my-spring-mvc-portlet.xml} → Liferay DXP uses this context
  file for the portlet.
\item
  \texttt{portlet-applications-context.xml} → Spring's
  \texttt{SpringContextLoaderListener} class uses this context file.
\item
  \texttt{MySpringMVCPortletviewController} → Maps \texttt{VIEW}
  requests to the \texttt{view.jsp} and assigns Liferay DXP release
  information to a model attribute.
\item
  \texttt{portlet.xml} → References context configuration file
  \texttt{my-spring-mvc-portlet.xml} and specifies a dispatcher for
  registered portlet request handlers.
\item
  \texttt{web.xml} → References context configuration file
  \texttt{portlet-application-context.xml} and specifies a
  \texttt{ViewRendererServlet} to convert portlet requests and responses
  to HTTP servlet requests and responses.
\end{itemize}

Here are the Spring MVC portlet upgrade steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \hyperref[adapt-the-code-to-liferays-api]{Adapt the code to 7.0's API}
\item
  \hyperref[resolve-dependencies]{Resolve dependencies}
\end{enumerate}

\subsection{Adapt the code to liferay's
API}\label{adapt-the-code-to-liferays-api}

The
\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-upgrade-planner}{Liferay
Upgrade Planner} facilitates updating the code and resolving compilation
issues quickly.

The Upgrade Planner detects if the value of the
\texttt{liferay-versions} property in your plugin's
\texttt{liferay-plugin-package.properties} file needs updating, and it
provides an option to fix it automatically. This is the only code
adaptation required by \texttt{my-spring-mvc-portlet}.

\subsection{Resolve Dependencies}\label{resolve-dependencies-1}

In Liferay Portal 6.2, \texttt{my-spring-mvc-portlet} leveraged Portal's
JARs by specifying them in the
\texttt{liferay-plugin-package.properties} file's
\texttt{portal-dependency-jars} property. Since the property is
deprecated in 7.0, you should acquire dependencies using a dependency
management framework, such as Gradle, Maven, or Apache Ant/Ivy.

\href{/docs/7-1/tutorials/-/knowledge_base/t/migrating-traditional-plugins-to-workspace-web-applications}{Converting
the sample portlet plugin from a traditional plugin to a Liferay
Workspace web application} facilitated resolving its dependencies.

Here's the updated \texttt{my-spring-mvc-portlet}'s
\texttt{build.gradle} file:

\begin{verbatim}
dependencies {
    compileOnly group: 'aopalliance', name: 'aopalliance', version: '1.0'
    compileOnly group: 'commons-logging', name: 'commons-logging', version: '1.2'
    compileOnly group: "com.liferay.portal", name: "com.liferay.portal.kernel", version: "2.0.0"
    compileOnly group: "javax.portlet", name: "portlet-api", version: "2.0"
    compileOnly group: "javax.servlet", name: "javax.servlet-api", version: "3.0.1"
    compile group: 'org.jboss.arquillian.junit', name: 'arquillian-junit-container', version: '1.1.3.Final'
    compile group: 'org.jboss.arquillian.container', name: 'arquillian-tomcat-remote-7', version: '1.0.0.CR6'
    compile group: 'com.liferay', name: 'com.liferay.ant.arquillian', version: '1.0.0-SNAPSHOT'
    compile group: 'org.springframework', name: 'spring-aop', version: '4.1.9.RELEASE'
    compile group: 'org.springframework', name: 'spring-beans', version: '4.1.9.RELEASE'
    compile group: 'org.springframework', name: 'spring-context', version: '4.1.9.RELEASE'
    compile group: 'org.springframework', name: 'spring-core', version: '4.1.9.RELEASE'
    compile group: 'org.springframework', name: 'spring-expression', version: '4.1.9.RELEASE'
    compile group: 'org.springframework', name: 'spring-web', version: '4.1.9.RELEASE'
    compile group: 'org.springframework', name: 'spring-webmvc', version: '4.1.9.RELEASE'
    compile group: 'org.springframework', name: 'spring-webmvc-portlet', version: '4.1.9.RELEASE'
}
\end{verbatim}

Some of \texttt{my-spring-mvc-portlet}'s dependency artifacts have new
names.

\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Old name & New name \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{spring-web-portlet} & \texttt{spring-webmvc-portlet} \\
\texttt{spring-web-servlet} & \texttt{spring-webmvc} \\
\end{longtable}

\href{https://search.maven.org/}{Maven Central} provides artifact
dependency information.

\noindent\hrulefill

\textbf{Note}: If the Spring Framework version you're using differs from
the version Liferay DXP uses, you must name your Spring Framework JARs
differently from Liferay DXP's Spring Framework JARs. If you don't
rename your JARs, Liferay DXP assumes you're using its Spring Framework
JARs and excludes yours from the generated WAB (Web Application Bundle).
\href{https://docs.liferay.com/ce/portal/7.1-latest/propertiesdoc/portal.properties.html\#Module\%20Framework}{Portal
property \texttt{module.framework.web.generator.excluded.paths}} lists
Liferay DXP's Spring Framework JARs.
\href{/docs/7-1/tutorials/-/knowledge_base/t/resolving-a-plugins-dependencies\#understanding-excluded-jars}{Understanding
Excluded JARs} explains how to detect the Spring Framework version
Liferay DXP uses.

\noindent\hrulefill

\noindent\hrulefill

\textbf{Note}: If a dependency is an OSGi module JAR and Liferay DXP
already exports your plugin's required packages, \emph{exclude} the JAR
from your plugin's WAR file. This prevents your plugin from exporting
the same package(s) that Liferay is already exporting. This prevents
class loader collisions. To exclude a JAR from deployment, add its name
to the your project's \texttt{liferay-plugin-package.properties} file's
\texttt{deploy-excludes} property.

\begin{verbatim}
 deploy-excludes=\
     **/WEB-INF/lib/module-a.jar,\
     **/WEB-INF/lib/module-b.jar
\end{verbatim}

Since \texttt{my-spring-mvc-portlet}'s dependencies aren't OSGi modules,
no JARs must be excluded.

\noindent\hrulefill

To import class packages referenced by your portlet's descriptor files,
add the packages to an \texttt{Import-Package} header in the
\texttt{liferay-plugin-package.properties} file. See
\href{/docs/7-1/tutorials/-/knowledge_base/t/deploying-a-spring-mvc-portlet}{Deploying
a Spring MVC Portlet} for details.

If you depend on a package from Java's \texttt{rt.jar} other than its
\texttt{java.*} packages, override
\href{https://docs.liferay.com/dxp/portal/7.1-latest/propertiesdoc/portal.properties.html\#Module\%20Framework}{portal
property \texttt{org.osgi.framework.bootdelegation}} and add it to the
property's list. Go
\href{/docs/7-1/tutorials/-/knowledge_base/t/resolving-classnotfoundexception-and-noclassdeffounderror-in-osgi-bundles\#case-4-the-missing-class-belongs-to-a-java-runtime-package}{here}
for details.

\noindent\hrulefill

\textbf{Note}: Spring MVC portlets whose embedded JARs contain
properties files (e.g., \texttt{spring.handlers},
\texttt{spring.schemas}, \texttt{spring.tooling}) might be affected by
issue \href{https://issues.liferay.com/browse/LPS-75212}{LPS-75212}. The
last JAR that has properties files is the only JAR whose properties are
added to the resulting WAB's classpath. Properties in other JARs aren't
added.

\href{/docs/7-1/tutorials/-/knowledge_base/t/deploying-a-spring-mvc-portlet}{Depploying
a Spring MVC Portlet} explains how to add all the embedded JAR
properties.

\noindent\hrulefill

The portlet is ready to deploy. Deploy it as you always have.

Liferay DXP's
\href{/docs/7-1/tutorials/-/knowledge_base/t/using-the-wab-generator}{WAB
Generator} converts the portlet WAR to a Web Application Bundle (WAB)
and installs the WAB to Liferay's OSGi Runtime Framework.

\begin{verbatim}
2018-04-12 19:28:36.810 INFO  [com.liferay.portal.kernel.deploy.auto.AutoDeployScanner][AutoDeployDir:262] Processing my-spring-mvc-portlet.war
2018-04-12 19:28:42.182 INFO  [fileinstall-C:/portals/liferay-ce-portal-7.1-m1/osgi/war][BaseAutoDeployListener:43] Copying portlets for C:\portals\liferay-ce-portal-7.1-m1\tomcat-8.0.32\temp\20180412192842100ZSINUETA\my-spring-mvc-portlet.war
2018-04-12 19:28:42.706 INFO  [fileinstall-C:/portals/liferay-ce-portal-7.1-m1/osgi/war][BaseDeployer:876] Deploying my-spring-mvc-portlet.war
2018-04-12 19:28:47.708 INFO  [fileinstall-C:/portals/liferay-ce-portal-7.1-m1/osgi/war][BaseAutoDeployListener:50] Portlets for C:\portals\liferay-ce-portal-7.1-m1\tomcat-8.0.32\temp\20180412192842100ZSINUETA\my-spring-mvc-portlet.war copied successfully
2018-04-12 19:28:56.600 INFO  [fileinstall-C:/portals/liferay-ce-portal-7.1-m1/osgi/war][HotDeployImpl:226] Deploying my-spring-mvc-portlet from queue
2018-04-12 19:28:56.601 INFO  [fileinstall-C:/portals/liferay-ce-portal-7.1-m1/osgi/war][PluginPackageUtil:1003] Reading plugin package for my-spring-mvc-portlet
2018-04-12 19:28:56.700 INFO  [fileinstall-C:/portals/liferay-ce-portal-7.1-m1/osgi/war][PortletHotDeployListener:186] Registering portlets for my-spring-mvc-portlet
2018-04-12 19:28:56.955 INFO  [fileinstall-C:/portals/liferay-ce-portal-7.1-m1/osgi/war][PortletHotDeployListener:298] 1 portlet for my-spring-mvc-portlet is available for use
2018-04-12 19:28:57.114 INFO  [fileinstall-C:/portals/liferay-ce-portal-7.1-m1/osgi/war][BundleStartStopLogger:35] STARTED my-spring-mvc-portlet_7.1.0.1 [658]
\end{verbatim}

You've upgraded a Spring MVC portlet to 7.0. Way to go!

\subsection{Related Topics}\label{related-topics-10}

\href{/docs/7-1/tutorials/-/knowledge_base/t/spring-mvc}{Spring MVC}

\href{/docs/7-1/tutorials/-/knowledge_base/t/migrating-traditional-plugins-to-workspace-web-applications}{Migrating
Plugins SDK Projects to Workspace and Gradle}

\href{/docs/7-1/tutorials/-/knowledge_base/t/resolving-a-plugins-dependencies\#using-a-dependency-management-tool}{Using
Dependency Management Tools}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-the-wab-generator}{Using
the WAB Generator}

\section{Upgrading a Struts 1
Portlet}\label{upgrading-a-struts-1-portlet}

Struts is a stable, widely adopted framework that implements the Model
View Controller (MVC) design pattern. If you have a Struts portlet for
previous versions of Liferay Portal, you can upgrade it to 7.0.

Upgrading Struts portlets to 7.0 is easier than you might think. Liferay
DXP lets you continue working with Struts portlets as Java EE web
applications.

This tutorial demonstrates how to upgrade a portlet that uses the Struts
1 Framework.

Here's a sample Struts portlet's folder structure with file/folder
descriptions:

\begin{itemize}
\tightlist
\item
  \texttt{sample-struts-portlet}

  \begin{itemize}
  \tightlist
  \item
    \texttt{docroot/}

    \begin{itemize}
    \tightlist
    \item
      \texttt{html/portlet/sample\_struts\_portlet/} → JSPs
    \item
      \texttt{WEB-INF/}

      \begin{itemize}
      \tightlist
      \item
        \texttt{lib/} → Required third-party libraries unavailable in
        the Liferay DXP system
      \item
        \texttt{src/}

        \begin{itemize}
        \tightlist
        \item
          \texttt{com/liferay/samplestruts/model/} → Model classes
        \item
          \texttt{com/liferay/samplestruts/servlet/} → Test servlet and
          servlet context listener
        \item
          \texttt{com/liferay/samplestruts/struts/}

          \begin{itemize}
          \tightlist
          \item
            \texttt{action/} → \texttt{Action} classes that return View
            pages to the client
          \item
            \texttt{form/} → \texttt{ActionForm} classes for model
            interaction
          \item
            \texttt{render/} → \texttt{Action} classes that present
            additional pages and handle input
          \item
            \texttt{SampleException.java} → Exception class
          \end{itemize}
        \item
          \texttt{content/test/} → Resource bundles
        \item
          \texttt{META-INF/} → Javadoc
        \end{itemize}
      \item
        \texttt{tld/} → Tag library definitions
      \item
        \texttt{liferay-display.xml} → Sets the application category
      \item
        \texttt{liferay-plugin-package.properties} → Sets metadata and
        portal dependencies
      \item
        \texttt{liferay-portlet.xml} → Maps descriptive role names to
        roles
      \item
        \texttt{liferay-releng.properties} → (internal) Release
        properties
      \item
        \texttt{portlet.xml} → Defines the portlet and its
        initialization parameters and security roles
      \item
        \texttt{struts-config.xml} → Struts configuration
      \item
        \texttt{tiles-defs.xml} → Struts Tile definitions
      \item
        \texttt{validation.xml} → Defines form inputs for validation
      \item
        \texttt{validation-rules.xml} → Struts validation rules
      \item
        \texttt{web.xml} → Web application descriptor
      \end{itemize}
    \end{itemize}
  \item
    \texttt{build.xml} → Apache Ant build file
  \end{itemize}
\end{itemize}

Upgrading a Struts 1 portlet involves these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Adapt the portlet to 7.0's API using the Liferay Upgrade Planner. When
  running the planner's \emph{Fix Upgrade Problems} step, many of the
  existing issues are autocorrected. For remaining issues, the planner
  identifies code affected by the new API and ways to adapt it.
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/resolving-a-plugins-dependencies}{Resolve
  its dependencies}
\end{enumerate}

You've resolved the Sample Struts portlet's dependencies. It's ready to
deploy.

\noindent\hrulefill

\textbf{Important}: Setting Portal property
\texttt{jsp.page.context.force.get.attribute} (described in the
\href{https://docs.liferay.com/dxp/portal/7.1-latest/propertiesdoc/portal.properties.html\#JSP}{JSP
section}) to \texttt{true} (default) forces calls to
\texttt{com.liferay.taglib.servlet.PageContextWrapper\#findAttribute(String)}
to use \texttt{getAttribute(String)}. Although this improves performance
by avoiding unnecessary fall-backs, it can cause attribute lookup
problems in Struts portlets. To use Struts portlets in your sites, makes
sure to set the Portal property
\texttt{jsp.page.context.force.get.attribute} to \texttt{false} in a
file \texttt{{[}Liferay-Home{]}/portal-ext.properties}.

\begin{verbatim}
jsp.page.context.force.get.attribute=false
\end{verbatim}

\noindent\hrulefill

On deploying a Struts portlet Web Application aRchive (WAR), Liferay
DXP's Web Application Bundle (WAB) Generator creates an OSGi module
(bundle) for the portlet and installs it to Liferay's OSGi framework.
The server prints messages indicating the following portlet status:

\begin{itemize}
\tightlist
\item
  WAR processing
\item
  WAB startup
\item
  Availability to users
\end{itemize}

The Struts portlet is now available on your Liferay DXP instance. The
Struts portlet behaves just as it did on previous versions on your 7.0
site.

Congratulations on upgrading your Struts portlet to 7.0!

\section{Upgrading Web Plugins}\label{upgrading-web-plugins}

Web plugins are regular
\href{https://docs.oracle.com/cd/E19226-01/820-7627/bnadx/index.html}{Java
EE web modules} designed to work with Liferay DXP. These plugins were
stored in the \texttt{webs} folder of the legacy Plugins SDK.

Upgrading a Liferay web plugin involves these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Adapt the plugin to 7.0's API using the Liferay Upgrade Planner. When
  running the planner's \emph{Fix Upgrade Problems} step, many of the
  existing issues are autocorrected. For remaining issues, the planner
  identifies code affected by the new API and ways to adapt it.
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/resolving-a-plugins-dependencies}{Resolve
  its dependencies}
\item
  Deploy it.
\end{enumerate}

After deploying the upgraded portlet, the server prints messages that
indicate the following portlet status:

\begin{itemize}
\tightlist
\item
  WAR processing
\item
  WAB startup
\item
  Availability to users
\end{itemize}

You've upgraded and deployed your Liferay web plugin on your 7.0
instance. Great job!

\section{Upgrading Ext Plugins}\label{upgrading-ext-plugins}

Ext plugins let you use internal APIs and even let you overwrite Liferay
DXP core files. This puts your deployment at risk of being incompatible
with security, performance, or feature updates released by Liferay. When
upgrading to a new version of Liferay DXP, you must review all changes
and manually modify your Ext projects to merge your changes with Liferay
DXP's.

During your upgrade to 7.0, it's highly recommended to leverage an
extension point to customize Liferay DXP instead of using you existing
Ext plugin, if possible. 7.0 provides many extension points that let you
customize almost every detail of Liferay DXP. If there's a way to
customize what you want with an extension point, do it that way instead.
See the
\href{/docs/7-1/tutorials/-/knowledge_base/t/benefits-of-liferay-7-for-liferay-6-developers\#more-extensible-easier-to-maintain}{More
Extensible, Easier to Maintain} section for more details on the
advantages of using Liferay DXP's extension points.

For more information on Ext projects, how to decide if you need one, and
how to manage them, see the
\href{/docs/7-1/reference/-/knowledge_base/r/customization-with-ext}{Customization
with Ext} section.

\section{Upgrading the Liferay Maven
Build}\label{upgrading-the-liferay-maven-build}

If you're an avid Maven user and have been using it for Liferay Portal
6.2 project development, you must upgrade your Maven build to be
compatible with 7.0 development. There are two main parts of the Maven
environment upgrade process that you must address:

\begin{itemize}
\tightlist
\item
  \hyperref[upgrading-to-new-product-ver-maven-plugins]{Upgrading to new
  7.0 Maven plugins}
\item
  \hyperref[updating-liferay-maven-artifact-dependencies]{Updating
  Liferay Maven artifact dependencies}
\end{itemize}

For more information on using Maven with 7.0, see the
\href{/docs/7-1/tutorials/-/knowledge_base/t/maven}{Maven tutorial
section}. For a guided and expedited upgrade process for your Maven
build, try the
\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-upgrade-planner}{Liferay
Upgrade Planner}.

Liferay also offers a Maven development environment tailored
specifically for 7.0 development. Learn more about this in the
\href{/docs/7-1/tutorials/-/knowledge_base/t/maven-workspace}{Maven
Workspace} tutorial.

You'll start off by upgrading your Maven environment's Liferay Maven
plugins.

\subsection{Upgrading to New 7.0 Maven
Plugins}\label{upgrading-to-new-7.0-maven-plugins}

The biggest change for your project's build plugins is the removal of
the \texttt{liferay-maven-plugin}. Liferay now provides several
individual Maven plugins that accomplish specific tasks. For example,
you can configure Maven plugins for Liferay's CSS Builder, Service
Builder, Theme Builder, etc. With smaller plugins available to
accomplish specific tasks in your project, you no longer have to rely on
one large plugin that provides many things you may not want.

For example, suppose your Liferay Portal 6.2 project was using the
\texttt{liferay-maven-plugin} for Liferay CSS Builder only. First, you
should remove the legacy \texttt{liferay-maven-plugin} plugin dependency
from your project's \texttt{pom.xml} file:

\begin{verbatim}
<plugin>
    <groupId>com.liferay.maven.plugins</groupId>
    <artifactId>liferay-maven-plugin</artifactId>
    <version>${liferay.version}</version>
    <configuration>
        <autoDeployDir>${liferay.auto.deploy.dir}</autoDeployDir>
        <liferayVersion>${liferay.version}</liferayVersion>
        <pluginType>portlet</pluginType>
    </configuration>
</plugin>
\end{verbatim}

Then, add the CSS Builder plugin dependency to your project's
\texttt{pom.xml} file:

\begin{verbatim}
<plugin>
    <groupId>com.liferay</groupId>
    <artifactId>com.liferay.css.builder</artifactId>
    <version>1.0.21</version>
    <executions>
        <execution>
            <id>default-build</id>
            <phase>generate-sources</phase>
            <goals>
                <goal>build</goal>
            </goals>
        </execution>
    </executions>
        <configuration>
            <docrootDirName>src/main/webapp</docrootDirName>
        </configuration>
</plugin>
\end{verbatim}

Some common Liferay Maven plugins are listed below, with their
corresponding artifact IDs and tutorials explaining how to configure
them:

\textbf{Common Liferay Maven Plugins}

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.2083}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.4583}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.3333}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Name
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Artifact ID
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Tutorial
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Bundle Support &
\href{https://search.maven.org/\#search\%7Cga\%7C1\%7Ccom.liferay.portal.tools.bundle.support}{com.liferay.portal.tools.bundle.support}
& Coming Soon \\
CSS Builder &
\href{https://search.maven.org/\#search\%7Cga\%7C1\%7Ccom.liferay.css.builder}{com.liferay.css.builder}
&
\href{/docs/7-1/tutorials/-/knowledge_base/t/compiling-sass-files-in-a-maven-project}{Compiling
SASS Files in a Maven Project} \\
DB Support &
\href{https://search.maven.org/\#search\%7Cga\%7C1\%7Ccom.liferay.portal.tools.db.support}{com.liferay.portal.tools.db.support}
& \href{/docs/7-1/reference/-/knowledge_base/r/db-support-plugin}{DB
Support Plugin} \\
Deployment Helper &
\href{https://search.maven.org/\#search\%7Cga\%7C1\%7Ccom.liferay.deployment.helper}{com.liferay.deployment.helper}
& Coming Soon \\
Javadoc Formatter &
\href{https://search.maven.org/\#search\%7Cga\%7C1\%7Ccom.liferay.javadoc.formatter}{com.liferay.javadoc.formatter}
& Coming Soon \\
Lang Builder &
\href{https://search.maven.org/\#search\%7Cga\%7C1\%7Ccom.liferay.lang.builder}{com.liferay.lang.builder}
& Coming Soon \\
Service Builder &
\href{https://search.maven.org/\#search\%7Cga\%7C1\%7Ccom.liferay.portal.tools.service.builder}{com.liferay.portal.tools.service.builder}
&
\href{/docs/7-1/reference/-/knowledge_base/r/service-builder-with-maven}{Service
Builder Plugin} \\
Source Formatter &
\href{https://search.maven.org/\#search\%7Cga\%7C1\%7Ccom.liferay.source.formatter}{com.liferay.source.formatter}
&
\href{/docs/7-0/reference/-/knowledge_base/r/source-formatter-plugin}{Source
Formatter Plugin} \\
Theme Builder &
\href{https://search.maven.org/\#search\%7Cga\%7C1\%7Ccom.liferay.portal.tools.theme.builder}{com.liferay.portal.tools.theme.builder}
&
\href{/docs/7-1/reference/-/knowledge_base/r/theme-builder-plugin}{Theme
Builder Plugin} \\
TLD Formatter &
\href{https://search.maven.org/\#search\%7Cga\%7C1\%7Ccom.liferay.tld.formatter}{com.liferay.tld.formatter}
& Coming Soon \\
WSDD Builder &
\href{https://search.maven.org/\#search\%7Cga\%7C1\%7Ccom.liferay.portal.tools.wsdd.builder}{com.liferay.portal.tools.wsdd.builder}
& Coming Soon \\
XML Formatter &
\href{https://search.maven.org/\#search\%7Cga\%7C1\%7Ccom.liferay.xml.formatter}{com.liferay.xml.formatter}
& Coming Soon \\
\end{longtable}

In Liferay Portal 6.2, you were also required to specify all your app
server configuration settings. For example, your parent POM probably
contained settings similar to these:

\begin{verbatim}
<properties>
    <liferay.app.server.deploy.dir>
        E:\liferay-portal-6.2.0-ce-ga1\tomcat-7.0.42\webapps
    </liferay.app.server.deploy.dir>

    <liferay.app.server.lib.global.dir>
        E:\liferay-portal-6.2.0-ce-ga1\tomcat-7.0.42\lib\ext
    </liferay.app.server.lib.global.dir>

    <liferay.app.server.portal.dir>
        E:\liferay-portal-6.2.0-ce-ga1\tomcat-7.0.42\webapps\root
    </liferay.app.server.portal.dir> 

    <liferay.auto.deploy.dir>
        E:\liferay-portal-6.2.0-ce-ga1\deploy
    </liferay.auto.deploy.dir>

    <liferay.version>
        6.2.0
    </liferay.version>

    <liferay.maven.plugin.version>
        6.2.0
    </liferay.maven.plugin.version

</properties>
\end{verbatim}

This is no longer required in 7.0 because Liferay's Maven tools no
longer rely on your Liferay DXP installation's specific versions. You
should remove them from your POM file.

Awesome! You've learned about the new Maven plugins available to you for
7.0 development. Next, you'll learn about updating your Liferay Maven
artifacts.

\subsection{Updating Liferay Maven Artifact
Dependencies}\label{updating-liferay-maven-artifact-dependencies}

Many Liferay Portal 6.2 artifact dependencies you were using have
changed in 7.0. See the table below for popular Liferay Maven artifacts
that have changed:

\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Liferay Portal 6.2 Artifact ID & 7.0 Artifact ID \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{portal-service} & \texttt{com.liferay.portal.kernel} \\
\texttt{util-bridges} & \texttt{com.liferay.util.bridges} \\
\texttt{util-java} & \texttt{com.liferay.util.java} \\
\texttt{util-slf4j} & \texttt{com.liferay.util.slf4j} \\
\texttt{util-taglib} & \texttt{com.liferay.util.taglib} \\
\end{longtable}

For more information on resolving dependencies in 7.0, see the
\href{/docs/7-1/tutorials/-/knowledge_base/t/resolving-a-plugins-dependencies}{Resolving
a Plugin's Dependencies} tutorial.

Of course, you must also update the artifacts you're referencing for
your projects. If you're using the Central Repository to install Liferay
Maven artifacts, you won't need to do anything more than update the
artifacts in your POMs. If, however, you're working behind a proxy or
don't have Internet access, you must update your company-shared or local
repository with the latest 7.0 Maven artifacts. See the
\href{/docs/7-1/tutorials/-/knowledge_base/t/installing-liferay-maven-artifacts}{Installing
Liferay Maven Artifacts} tutorial for instructions.

With these updates, you can easily upgrade your Liferay Maven build so
you can begin developing traditional plugin projects for 7.0.

\chapter{Optimizing Plugins for 7.0}\label{optimizing-plugins-for-7.0}

Once you've
\href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-plugins-to-liferay-7}{upgraded
your plugin}, you can optimize it to take advantage of all 7.0 offers.
If you haven't yet familiarized yourself with
\href{/docs/7-1/tutorials/-/knowledge_base/t/whats-changed-and-what-hasnt}{what's
changed from Liferay Portal 6}, the
\href{/docs/7-1/tutorials/-/knowledge_base/t/benefits-of-liferay-7-for-liferay-6-developers}{new
benefits for developers},
\href{/docs/7-1/tutorials/-/knowledge_base/t/osgi-and-modularity-for-liferay-6-developers}{OSGi
and modularity}, and the
\href{/docs/7-1/tutorials/-/knowledge_base/t/improved-developer-tooling-liferay-workspace-maven-plugins-and-more}{improved
tooling}, make sure to do so as they'll help you understand and
appreciate the optional improvements for plugins and plugin development
these tutorials demonstrate.

Here are some common optimizations to consider:

\begin{itemize}
\tightlist
\item
  Migrating to environments that help you develop and test more quickly,
  such as the
  \href{/docs/7-0/tutorials/-/knowledge_base/t/migrating-a-6-2-theme-to-liferay-7}{Liferay
  Theme Generator} for themes and
  \href{/docs/7-1/tutorials/-/knowledge_base/t/from-the-plugins-sdk-to-liferay-workspace}{Liferay
  Workspace} for modules and web applications.
\item
  Adapting plugins to
  \href{/docs/7-1/tutorials/-/knowledge_base/t/whats-changed-and-what-hasnt\#embracing-a-modular-architecture}{Liferay's
  modular architecture} and updated frameworks, such as Service Builder.
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/applying-clay-styles-to-your-app}{Styling
  your app consistently using Clay} --the web implementation of Lexicon,
  Liferay's design language.
\item
  Modularizing apps to reap the
  \href{/docs/7-1/tutorials/-/knowledge_base/t/benefits-of-liferay-7-for-liferay-6-developers}{benefits
  of modularity}.
\end{itemize}

\section{Migrating Traditional Plugins to Workspace Web
Applications}\label{migrating-traditional-plugins-to-workspace-web-applications}

After you've
\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-upgrade-planner}{adapted
your traditional plugin} to Liferay DXP's API, you can continue
maintaining it in the Plugins SDK 7.0. The Plugins SDK, however, is no
longer available for 7.0. Visit the
\href{/docs/7-1/deploy/-/knowledge_base/d/deprecated-apps-in-7-1-what-to-do\#foundation}{Deprecated
Apps in 7.1: What To Do} article for more information on the Plugins SDK
removal.
\href{/docs/7-1/tutorials/-/knowledge_base/t/from-the-plugins-sdk-to-liferay-workspace}{Liferay
Workspace replaces the Plugins SDK}, providing a comprehensive Gradle
development environment and more. A simple command migrates traditional
plugins (such as portlets) to Gradle-based web application projects.
From there you can build and deploy them to Liferay DXP as Web ARchives
(WARs).

\subsection{Running the Migration
Command}\label{running-the-migration-command}

\href{/docs/7-1/tutorials/-/knowledge_base/t/blade-cli}{Blade CLI's}
\texttt{convert} command migrates Plugins SDK plugins to web application
projects in Workspace's \texttt{wars} folder. Plugin files are
re-organized to follow the standard web application folder structure.

\textbf{Standard Web Application Anatomy:}

\begin{itemize}
\tightlist
\item
  \texttt{{[}project\ root{]}}

  \begin{itemize}
  \tightlist
  \item
    \texttt{src}

    \begin{itemize}
    \tightlist
    \item
      \texttt{main}

      \begin{itemize}
      \tightlist
      \item
        \texttt{webapp}

        \begin{itemize}
        \tightlist
        \item
          \texttt{WEB-INF}

          \begin{itemize}
          \tightlist
          \item
            \texttt{classes}
          \item
            \texttt{lib} → Libraries
          \item
            descriptor files
          \end{itemize}
        \end{itemize}
      \item
        \texttt{css} → CSS files
      \item
        \texttt{js} → JavaScript files
      \item
        \texttt{icons}
      \item
        JSP files
      \end{itemize}
    \item
      \texttt{java} → Java source
    \end{itemize}
  \item
    build files
  \end{itemize}
\end{itemize}

From the command line, navigate to the Liferay Workspace root folder.
Then pass your Plugins SDK project's name to Blade's \texttt{convert}
command:

\begin{verbatim}
blade convert [PLUGIN_PROJECT_NAME]
\end{verbatim}

Blade extracts the plugin from the Plugins SDK and reorganizes it in a
standard web application project in Workspace's \texttt{wars} folder.

\textbf{Note:} Executing \texttt{blade\ convert\ -l} lists Plugins SDK
projects that can be migrated to Workspace web apps. Run
\texttt{blade\ convert\ -\/-all} to migrate all the plugin projects.

The image below shows the plugin files before and after they're migrated
to Workspace web apps.

\begin{figure}
\centering
\includegraphics{./images/migrate-war-compare-folder-structure.png}
\caption{The \texttt{convert} command migrates a Plugins SDK project to
a Workspace web application project. It moves Java source files to
\texttt{src/main/java} and all other files/folders to
\texttt{src/main/webapp}.}
\end{figure}

The following table maps traditional plugin source files to the standard
web application folder structure Workspace uses.

\textbf{Plugins SDK folders to web application folders:}

\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Files & Plugins SDK folder (old) & Web app folder (new) \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Java & \texttt{docroot/WEB-INF/src} & \texttt{src/main/java} \\
JSPs & \texttt{docroot} & \texttt{src/main/webapp} \\
icons & \texttt{docroot} & \texttt{src/main/webapp} \\
CSS & \texttt{docroot/css} & \texttt{src/main/webapp/css} \\
JS & \texttt{docroot/js} & \texttt{src/main/webapp/js} \\
descriptors & \texttt{docroot/WEB-INF} &
\texttt{src/main/webapp/WEB-INF} \\
libraries & \texttt{docroot/WEB-INF/lib} &
\texttt{src/main/webapp/lib} \\
\end{longtable}

From your plugin's new location, you can invoke
\href{/docs/7-1/tutorials/-/knowledge_base/t/from-the-plugins-sdk-to-liferay-workspace\#plugins-sdk-to-workspace-task-map}{Workspace
Gradle tasks} on it and build its \texttt{.war} file.

blade gw war

To deploy the \texttt{.war}, copy it from the plugin's
\texttt{build/libs} folder to the \texttt{{[}LIFERAY\_HOME{]}/deploy}
folder.

Welcome to your plugin's new home in Workspace!

\subsection{Related Topics}\label{related-topics-11}

\href{/docs/7-1/tutorials/-/knowledge_base/t/development-lifecycle-for-a-liferay-workspace\#building-projects}{Workspace
Development lifecycle}

\href{/docs/7-1/tutorials/-/knowledge_base/t/from-the-plugins-sdk-to-liferay-workspace\#plugins-sdk-to-workspace-task-map}{Workspace
Gradle Tasks}

\chapter{Modularizing Plugins}\label{modularizing-plugins}

As described in
\href{/docs/7-1/tutorials/-/knowledge_base/t/benefits-of-liferay-7-for-liferay-6-developers}{Benefits
of Liferay 7 for Liferay 6 Developers}, applications that comprise OSGi
modules offer considerable advantages over monolithic applications.

The main benefit is that modular development practices structure code in
ways that reduce maintenance costs. These practices involve, for
example, defining contracts (such as APIs) more clearly, hiding internal
classes, and handling dependencies more carefully. Related to this, Java
package dependencies are explicitly listed within a module. Modules run
only when all their dependencies are met. This eliminates many obscure
run time errors.

Splitting large applications into small independent modules lets you
focus on smaller release cycles for those modules. Individual modules
can be updated independently of the others. For instance, you might fix
a JSP's security issue in an application's web (client) module. The
issue only affects that module--none of the application's other modules
need change.

The scenarios described below can help you decide whether to convert an
application to modules.

\textbf{When not to convert?}

\begin{itemize}
\tightlist
\item
  You have a portlet that's JSR-168/286 compatible and you still want to
  be able to deploy it to another portlet container. In this case, it's
  best to stay with the traditional WAR model. (To eliminate this reason
  for not converting, Liferay is discussing with other vendors the
  possibility of making modular portlets a standard.)
\item
  You're using a complex web framework that is heavily tied to the Java
  EE programming model and the amount of effort necessary to make it
  work with OSGi is more than you feel is necessary or warranted.
\item
  You want to minimize effort to get your application working on 7.0.
\end{itemize}

\textbf{When to convert?}

\begin{itemize}
\tightlist
\item
  You have a very large application with many lines of code. If you have
  lots of developers making changes, separating the code into modules
  can make it easier and faster to get releases out.
\item
  Your application has reusable parts that you want to consume outside
  of it. For instance, your application has business logic that you're
  reusing in different projects. Modules let you consume their services
  from other modules.
\item
  In general, you want to start reaping the benefits of modular
  development.
\end{itemize}

You can now make an informed decision on whether to stick with your
\href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-plugins-to-liferay-7}{upgraded
traditional application} as is or modularize it to leverage modularity.

\chapter{Modularizing an Existing
Portlet}\label{modularizing-an-existing-portlet}

An application with properly modularized plugins offers several
benefits. You can release individually its plugins without releasing the
entire application. External clients can consume services from
particular plugins without having to depend on an entire application.
And by splitting up large amounts of code into concise modules, teams
can more easily focus on particular areas of the application. These are
just a few reasons to modularize application plugins.

In these tutorials, you'll learn how to convert your traditional
application into modules. Before getting started, it's important to
reiterate that the module structure shown in these tutorials is just one
of many ways for structuring your application's modules. Also
applications come in all different shapes and sizes. There may be
special actions that some applications require. These tutorials provide
the general process for converting to modules using Liferay's module
structure.

Here's what's involved:

\begin{itemize}
\tightlist
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/converting-your-applications-portlet-classes-and-ui}{Converting
  portlet classes and the UI}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/converting-your-applications-service-builder-api-and-implementation}{Converting
  Service Builder interfaces and implementations}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/building-your-module-jars-for-deployment}{Building
  and deploying modules}
\end{itemize}

The instructions apply to portlets for both Liferay DXP Digital
Enterprise and Liferay Portal CE.

The first thing you'll do is create your application's web (client)
module.

\section{Converting Your Application's Portlet Classes and
UI}\label{converting-your-applications-portlet-classes-and-ui}

The first thing you'll do is create your application's root folder and
the folder structure for its \emph{web} client module. This module holds
portlet classes and the web UI. Before you start creating a skeleton
structure for the modules, determine the modules that comprise this
version of your application. If your application provides service API
and implementation classes (which is the case for all Liferay Service
Builder applications), you'll create separate modules for them. This
tutorial assumes the Maven project model, although any build tools or
folder structure is permissible.

\noindent\hrulefill

\textbf{Note:} You should use the build plugin versions that support the
latest OSGi features. The following Gradle or Maven build plugin
versions should be used in their respective build frameworks:

\textbf{Gradle}

\begin{itemize}
\tightlist
\item
  biz.aQute.bnd:biz.aQute.bnd.gradle:3.2.0 \textbf{or}
\item
  org.dm.gradle:gradle-bundle-plugin:0.9.0
\end{itemize}

\textbf{Maven}

\begin{itemize}
\tightlist
\item
  biz.aQute.bnd:bnd-maven-plugin:3.2.0
\end{itemize}

\noindent\hrulefill

Here are the steps for creating the folder structure:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create the root folder. It is the new home for your application's
  independent modules and configuration files. For example, if your
  application's name is \emph{Tasks}, then your root folder could be
  \emph{tasks}.

  If your application uses Liferay Service Builder, use the following
  \href{/docs/7-1/tutorials/-/knowledge_base/t/blade-cli}{Blade CLI}
  command to generate the parent folder and service implementation and
  service API modules in it. If the parent folder already exists, it
  must be empty. This command names the parent folder after the
  \texttt{APPLICATION\_NAME}:

\begin{verbatim}
blade create -t service-builder -p [ROOT_PACKAGE] [APPLICATION_NAME]
\end{verbatim}

  The \texttt{*-service} and \texttt{*-api} module folders are described
  later in this tutorial.
\item
  Create the folder structure for your web client module.
  \href{/docs/7-1/tutorials/-/knowledge_base/t/blade-cli}{Blade CLI} and
  \href{/docs/7-1/reference/-/knowledge_base/r/maven}{Maven} generate
  project folder structures based on
  \href{/docs/7-1/reference/-/knowledge_base/r/project-templates}{project
  templates}.

  For example, navigate to the root folder (e.g., \texttt{tasks}) and
  run the following Blade CLI command to generate a generic web client
  module structure:

\begin{verbatim}
blade create -t mvc-portlet [APPLICATION_NAME]-web
\end{verbatim}
\item
  In your \texttt{*-web} module, replace the
  \texttt{/src/main/java/{[}APPLICATION\_NAME{]}} folder with your root
  Java package. For example, if your application's root package name is
  \texttt{com.liferay.tasks.web}, your class's folder should be
  \texttt{/src/main/java/com/liferay/tasks/web}. Also, remove the
  \texttt{init.jsp} and \texttt{view.jsp} files from the
  \texttt{src/main/resources/META-INF/resources} folder. You'll use your
  existing application's JSPs instead of these generated default JSPs.
\item
  Verify that your \texttt{*-web} module folder resides in your
  application's root folder (marked by \texttt{{[}APPLICATION\_NAME{]}}
  below)'s and your \texttt{*-web} module's folder structure looks like
  this:

  \begin{itemize}
  \tightlist
  \item
    \texttt{{[}APPLICATION\_NAME{]}}

    \begin{itemize}
    \tightlist
    \item
      \texttt{{[}APPLICATION\_NAME{]}-web}

      \begin{itemize}
      \tightlist
      \item
        \texttt{src}

        \begin{itemize}
        \tightlist
        \item
          \texttt{main}

          \begin{itemize}
          \tightlist
          \item
            \texttt{java}

            \begin{itemize}
            \tightlist
            \item
              \texttt{{[}ROOT\_PACKAGE{]}}
            \end{itemize}
          \item
            \texttt{resources}

            \begin{itemize}
            \tightlist
            \item
              \texttt{content}

              \begin{itemize}
              \tightlist
              \item
                \texttt{Language.properties}
              \end{itemize}
            \item
              \texttt{META-INF}

              \begin{itemize}
              \tightlist
              \item
                \texttt{resources}
              \end{itemize}
            \end{itemize}
          \end{itemize}
        \end{itemize}
      \item
        \texttt{bnd.bnd}
      \item
        \texttt{build.gradle}
      \end{itemize}
    \end{itemize}
  \end{itemize}

  The remaining steps affect the web client module (\texttt{*-web}
  module).
\item
  The \texttt{bnd.bnd} file is used to generate your module's
  \texttt{MANIFEST.MF} file when you build your project. Open it and
  change it to fit your application. There's
  \href{http://bnd.bndtools.org/}{further documentation} about
  configuring your module's \texttt{bnd.bnd}. For example, here's the
  Liferay \texttt{dictionary-web} module's \texttt{bnd.bnd}:

\begin{verbatim}
Bundle-Name: Liferay Dictionary Web
Bundle-SymbolicName: com.liferay.dictionary.web
Bundle-Version: 1.0.6
\end{verbatim}

  For a more advanced example, examine the \texttt{journal-web} module's
  \texttt{bnd.bnd}:

\begin{verbatim}
Bundle-Name: Liferay Journal Web
Bundle-SymbolicName: com.liferay.journal.web
Bundle-Version: 2.0.0
Export-Package:\
    com.liferay.journal.web.asset,\
    com.liferay.journal.web.dynamic.data.mapping.util,\
    com.liferay.journal.web.social,\
    com.liferay.journal.web.util
Liferay-JS-Config: /META-INF/resources/js/config.js
Liferay-Releng-Module-Group-Description:
Liferay-Releng-Module-Group-Title: Web Content
Web-ContextPath: /journal-web
\end{verbatim}
\item
  Open the \texttt{build.gradle} file.
  \href{/docs/7-0/tutorials/-/knowledge_base/t/configuring-dependencies}{Specify
  all your module's dependencies} here. The one generated for you is
  pre-populated with content and default dependencies. Add your module's
  dependencies in the \texttt{dependencies\ \{...\}} block.

  \href{/docs/7-0/reference/-/knowledge_base/r/finding-liferay-api-modules}{Finding
  Liferay API Modules} lists common Liferay API module's symbolic names.
  The Javadoc overviews for
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/}{7.0}
  and
  \href{https://docs.liferay.com/dxp/apps/7.1-latest/javadocs}{Liferay
  apps} list each module's symbolic name and version. The
  \href{/docs/7-0/tutorials/-/knowledge_base/t/configuring-dependencies}{Configuring
  Dependencies tutorial} demonstrates finding artifact information and
  specifying dependencies.
  \href{/docs/7-0/reference/-/knowledge_base/r/third-party-packages-portal-exports}{Liferay
  DXP provides many Java packages and entire artifacts} at runtime in
  the OSGi container. Your module is activated after installation once
  all its dependencies resolve. Unresolved dependencies appear in the
  log. Here's an example message:

\begin{verbatim}
! could not resolve the bundles: ... Unresolved requirement: Import-Package: ... Unresolved requirement: Require-Capability ...
\end{verbatim}
\item
  Copy your traditional application's JSP files into the
  \texttt{/src/main/resources/META-INF/resources} folder. In most cases,
  all of your application's JSP files belong in the web client module.
\item
  Copy your portlet classes and supporting classes that aren't related
  to
  \href{/docs/7-0/tutorials/-/knowledge_base/t/running-service-builder-and-understanding-the-generated-code}{Service
  Builder} into their respective package folders in the web client
  module. Organizing classes into sub-packages can make them easier to
  manage.

  For example, here's the \texttt{journal-web} module's Java source
  folder structure:

  \begin{itemize}
  \tightlist
  \item
    \texttt{journal-web}

    \begin{itemize}
    \tightlist
    \item
      \ldots{}
    \item
      \texttt{src/main/java/com/liferay/journal/web/}

      \begin{itemize}
      \tightlist
      \item
        \texttt{asset}

        \begin{itemize}
        \tightlist
        \item
          {[}classes{]}
        \end{itemize}
      \item
        \texttt{configuration}

        \begin{itemize}
        \tightlist
        \item
          {[}classes{]}
        \end{itemize}
      \item
        \texttt{dynamic/data/mapping/util}

        \begin{itemize}
        \tightlist
        \item
          {[}classes{]}
        \end{itemize}
      \item
        \texttt{internal}

        \begin{itemize}
        \tightlist
        \item
          \texttt{application/list}

          \begin{itemize}
          \tightlist
          \item
            {[}classes{]}
          \end{itemize}
        \item
          \texttt{custom/attributes}

          \begin{itemize}
          \tightlist
          \item
            {[}classes{]}
          \end{itemize}
        \item
          \texttt{dao/search}

          \begin{itemize}
          \tightlist
          \item
            {[}classes{]}
          \end{itemize}
        \item
          \ldots{}
        \end{itemize}
      \item
        \texttt{social}

        \begin{itemize}
        \tightlist
        \item
          {[}classes{]}
        \end{itemize}
      \item
        \texttt{util}

        \begin{itemize}
        \tightlist
        \item
          {[}classes{]}
        \end{itemize}
      \end{itemize}
    \item
      \ldots{}
    \end{itemize}
  \end{itemize}
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** Many applications have API and implementation classes. These
 classes belong in API and implementation modules. The next tutorial
 demonstrates copying those classes into modules.
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{8}
\item
  Now that the necessary classes are in your client module, you must
  make them comply with OSGi. If you're a beginner, we recommend using
  the
  \href{https://osgi.org/specification/osgi.cmpn/7.0.0/service.component.html}{Declarative
  Services} component framework because Liferay DXP uses it. This
  tutorial assumes that you're using Declarative Services. You can,
  however, use any other OSGi component framework.

  Review your traditional application's XML files and migrate the
  configuration and metadata information to the portlet class as
  component properties. You can do this by adding the
  \texttt{@Component} annotation to your portlet class and adding the
  necessary properties to that annotation. Examine the
  \href{/docs/7-0/reference/-/knowledge_base/r/portlet-descriptor-to-osgi-service-property-map}{mapping
  of the portlet descriptors to component properties}. The end result
  should look similar to the following example:

\begin{verbatim}
@Component(
    immediate = true,
    property = {
        "com.liferay.portlet.display-category=category.sample",
        "com.liferay.portlet.icon=/icon.png",
        "javax.portlet.name=1",
        "javax.portlet.display-name=Tasks Portlet",
        "javax.portlet.security-role-ref=administrator,guest,power-user",
        "javax.portlet.init-param.clear-request-parameters=true",
        "javax.portlet.init-param.view-template=/view.jsp",
        "javax.portlet.expiration-cache=0",
        "javax.portlet.supports.mime-type=text/html",
        "javax.portlet.resource-bundle=content.Language",
        "javax.portlet.info.title=Tasks Portlet",
        "javax.portlet.info.short-title=Tasks",
        "javax.portlet.info.keywords=Tasks",
    },
    service = Portlet.class
)
public class TasksPortlet extends MVCPortlet {
    ...
}
\end{verbatim}
\item
  Convert all references of the \texttt{portletId} (e.g.,
  \texttt{58\_INSTANCE\_4gtH}) to the class name of the portlet,
  replacing all periods with underscores (e.g.,
  \texttt{com\_liferay\_web\_proxy\_portlet\_WebProxyPortlet}).
\item
  Migrate your traditional application's resource actions (if it has
  any), into your client module. Create the
  \texttt{/src/main/resources/resource-actions/default.xml} file, and
  copy your resource actions there. Make sure to create the
  \texttt{src/portlet.properties} file and add the following property:

\begin{verbatim}
resource.actions.configs=resource-actions/default.xml
\end{verbatim}

  As an example, see the Directory application's
  \href{https://github.com/liferay/liferay-portal/blob/master/modules/apps/directory/directory-web/src/main/resources/resource-actions/default.xml}{\texttt{default.xml}}.

  Note that
  \href{/docs/7-1/tutorials/-/knowledge_base/t/defining-application-permissions}{the
  permissions API has changed in 7.1}; adapt your permissions helpers
  accordingly.
\item
  Add your language keys to the
  \texttt{src/main/resources/content/Language.properties} file. Only
  include the language keys unique to your application. Liferay DXP's
  language keys are available to all portlet applications.
\end{enumerate}

Awesome! You've created your application's web client module and
completed some of the most common tasks for modularizing your portlet
classes and UI. To convert other parts of your application this tutorial
hasn't covered, examine the
\href{/docs/7-1/tutorials/-/knowledge_base/t/introduction-to-liferay-development}{Liferay
DXP developer tutorials} to see how those parts fit into application
modules. The tutorials are divided into popular areas so you can easily
find the topical information you need.

Lastly, the table below is a quick reference guide that maps files and
Java packages from a traditional portlet plugin to a module for a
fictitious application called \texttt{tasks-portlet}.

\noindent\hrulefill

Traditional Plugin \textbar{} Module \textbar{}
\texttt{tasks-portlet/docroot/WEB-INF/src/com.liferay.tasks.asset}
\textbar{} \texttt{tasks-web/src/main/java/com.liferay.tasks.asset}
\textbar{}
\texttt{tasks-portlet/docroot/WEB-INF/src/com.liferay.tasks.portlet}
\textbar{} \texttt{tasks-web/src/main/java/com.liferay.tasks.portlet}
\textbar{} \texttt{tasks-portlet/docroot/WEB-INF/src/content} \textbar{}
\texttt{tasks-web/src/main/resources/content} \textbar{}
\texttt{tasks-portlet/docroot/WEB-INF/src/resource-actions} \textbar{}
\texttt{tasks-web/src/main/resources/resource-actions} \textbar{}
\texttt{tasks-portlet/docroot/WEB-INF/src/portlet.properties} \textbar{}
\texttt{tasks-web/src/main/resources/portlet.properties} \textbar{}
\texttt{tasks-portlet/docroot/init.jsp} \textbar{}
\texttt{tasks-web/src/main/resources/META-INF/resources/init.jsp}
\textbar{} \texttt{tasks-portlet/docroot/tasks} \textbar{}
\texttt{tasks-web/src/main/resources/META-INF/resources/tasks}
\textbar{} \texttt{tasks-portlet/docroot/upcoming\_tasks} \textbar{}
\texttt{tasks-web/src/main/resources/META-INF/resources/upcoming\_tasks}
\textbar{}

\noindent\hrulefill

Many applications only have a web client module. Larger, more complex
applications, such as Liferay Service Builder applications, require
additional modules to hold their service API and service implementation
logic. You'll learn how to create these modules next.

\section{Converting Your Application's Service Builder API and
Implementation}\label{converting-your-applications-service-builder-api-and-implementation}

In this tutorial, you'll learn about converting a Liferay Portal 6
Service Builder application to a 7.0 style application. In the
\href{/docs/7-1/tutorials/-/knowledge_base/t/converting-your-applications-portlet-classes-and-ui}{previous
tutorial}, you learned how to generate your implementation and API
modules. If you haven't yet run the \texttt{service-builder} Blade CLI
command outlined in step 2 of the previous tutorial, run it now. The API
module holds your application's Service Builder-generated API and the
implementation module holds your application's Service Builder
implementation.

Before you begin editing the API and implementation modules, you must
configure your root project (e.g., \texttt{tasks}) to recognize the
multiple modules residing there. A multi-module Gradle project must have
a \texttt{settings.gradle} file in the root project for building
purposes. When you generated your Service Builder project's modules
using Blade CLI, the \texttt{settings.gradle} file was inserted and
pre-configured for the \texttt{api} and \texttt{service} modules. You
should add your \texttt{web} module into the Service Builder project's
generated parent folder and define it in the \texttt{settings.gradle}
file too. You'll configure your \texttt{web} module via Gradle settings
later, but for now, copy the module into the project generated by the
\texttt{service-builder} template. An example \texttt{tasks} project's
root folder would look like this:

\begin{itemize}
\tightlist
\item
  \texttt{tasks}

  \begin{itemize}
  \tightlist
  \item
    \texttt{gradle}
  \item
    \texttt{tasks-api}
  \item
    \texttt{tasks-service}
  \item
    \texttt{tasks-web}
  \item
    \texttt{build.gradle}
  \item
    \texttt{gradlew}
  \item
    \texttt{settings.gradle}
  \end{itemize}
\end{itemize}

Your root project folder should now be in good shape. Next, use Service
Builder to generate your application's service API and service
implementation code.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Copy your traditional application's \texttt{service.xml} file into the
  implementation module's root folder (e.g.,
  \texttt{tasks/tasks-service}).
\item
  Blade CLI generated a \texttt{bnd.bnd} file for your service
  implementation module. Edit this \texttt{bnd.bnd} file to fit your
  application. For an example of a service implementation module's bnd
  file, examine the \texttt{export-import-service} module's bnd below:

\begin{verbatim}
Bundle-Name: Liferay Export Import Service
Bundle-SymbolicName: com.liferay.exportimport.service
Bundle-Version: 4.0.0
Export-Package:\
    com.liferay.exportimport.content.processor.base,\
    com.liferay.exportimport.controller,\
    com.liferay.exportimport.data.handler.base,\
    com.liferay.exportimport.lar,\
    com.liferay.exportimport.lifecycle,\
    com.liferay.exportimport.messaging,\
    com.liferay.exportimport.portlet.preferences.processor.base,\
    com.liferay.exportimport.portlet.preferences.processor.capability,\
    com.liferay.exportimport.search,\
    com.liferay.exportimport.staged.model.repository.base,\
    com.liferay.exportimport.staging,\
    com.liferay.exportimport.xstream
Liferay-Releng-Module-Group-Description:
Liferay-Releng-Module-Group-Title: Data Management
Liferay-Require-SchemaVersion: 1.0.0
-includeresource: content=../../staging/staging-lang/src/main/resources/content
\end{verbatim}
\item
  Blade CLI also generated your service implementation module's
  \texttt{build.gradle} file. In this file, Service Builder is already
  configured to generate code both in this module and in your service
  API module. When you run Service Builder,
  \href{/docs/7-1/tutorials/-/knowledge_base/t/running-service-builder}{Java
  classes, interfaces, and related files are generated} in your
  \texttt{*api} and \texttt{*service} modules. Open your service
  implementation module's \texttt{build.gradle} file to view the default
  configuration.

  As you've learned already, you don't have to accept the generated
  build files' defaults. Blade CLI simply generated some standard OSGi
  and Liferay configurations.

  For example, Service Builder is already available for you by default.
  Blade CLI applies the Service Builder plugin automatically when a
  project contains the \texttt{service.xml} file. With the Service
  Builder plugin already available, you don't have to worry about
  configuring it in your project.
\item
  Another important part of your service implementation module's
  \texttt{build.gradle} file is the \texttt{buildService\{...\}} block.
  This block configures how Service Builder runs for your project. The
  current configuration generates your API module successfully, but
  extra configuration might be necessary in certain cases.
\item
  Navigate to your root project folder. Then run
  \texttt{gradlew\ buildService}.

  Your service API, implementation classes, and configuration (SQL,
  Hibernate, Spring, etc.) are generated from your \texttt{service.xml}
  file in their respective modules. The
  \href{/docs/7-1/reference/-/knowledge_base/r/service-builder-gradle-plugin}{Service
  Builder Gradle Plugin} has multiple options.
\item
  Now that you've run Service Builder, copy your business logic classes
  into your implementation module. The table below highlights popular
  Liferay Portal 6 classes and packages and where to place them in your
  application. This table suggests how to organize your classes and
  configuration files; however, remember to follow the organizational
  methodologies that make the most sense for your application. One size
  does not fit all with your modules' folder schemes.
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 Plugin Package | Module Package |
----------------|----------------|
 `tasks-portlet/docroot/WEB-INF/src/com.liferay.tasks.model.impl` | `tasks-service/src/main/java/com.liferay.tasks.model.impl` | 
 `tasks-portlet/docroot/WEB-INF/src/com.liferay.tasks.service.impl` | `tasks-service/src/main/java/com.liferay.tasks.service.impl` |
 `tasks-portlet/docroot/WEB-INF/src/com.liferay.tasks.service.permission` | `tasks-service/src/main/java/com.liferay.tasks.service.permission` |
 `tasks-portlet/docroot/WEB-INF/src/com.liferay.tasks.service.persistence.impl` | `tasks-service/src/main/java/com.liferay.tasks.service.persistence.impl` |
 `tasks-portlet/docroot/WEB-INF/src/com.liferay.tasks.social` | `tasks-service/src/main/java/com.liferay.tasks.social` |
 `tasks-portlet/docroot/WEB-INF/src/com.liferay.tasks.util` | `tasks-service/src/main/java/com.liferay.tasks.util` |
 `tasks-portlet/docroot/WEB-INF/src/custom-sql` | `tasks-service/src/main/resources/META-INF/custom-sql` |
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{6}
\tightlist
\item
  Once you've copied your business logic, run
  \texttt{gradlew\ buildService} again to generate the remaining
  services.
\end{enumerate}

Now that your services are generated, you must wire up your modules so
they can reference each other when deployed to Liferay's OSGi container.
Blade CLI has already partially completed this task. For example, it
assumes that the service implementation module depends on the service
API module.

You still need to associate the client module with the \texttt{api} and
\texttt{service} modules, since they were generated separately. To do
this, follow the steps below:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In your root project's \texttt{settings.gradle} file, add the
  \texttt{web} module with the \texttt{api} and \texttt{service} modules
  so it's included in the Gradle build lifecycle:

\begin{verbatim}
include "tasks-api", "tasks-service", "tasks-web"
\end{verbatim}
\item
  Add the \texttt{api} and \texttt{service} modules as dependencies in
  you client module:

\begin{verbatim}
dependencies {
    compileOnly  project(':tasks-api')
    compileOnly  project(':tasks-service')
}
\end{verbatim}
\end{enumerate}

Excellent! You've successfully generated your application's services
using Service Builder. They now reside in modules, and can be deployed
to 7.0.

\section{Building Your Application's Module JARs for
Deployment}\label{building-your-applications-module-jars-for-deployment}

Now it's time to build and deploy your modules. To build your project,
run \texttt{gradlew\ build} from your application project's root folder.

Now check all of your modules' \texttt{/build/libs} folders. There
should be a newly generated JAR file in each, which is the file to
deploy. You can deploy each JAR by running \texttt{blade\ deploy} from
each module's root folder.

\noindent\hrulefill

\textbf{Note:} If you deploy your modules out of order, you might
receive error messages. For instance, if you try deploying your web
client module first, errors occur if it relies on the service
implementation and service API modules. Once each module's dependencies
are met, they deploy in Liferay.
\href{/docs/7-1/reference/-/knowledge_base/r/using-the-felix-gogo-shell}{Felix
Gogo Shell commands} let you check module dependencies.

\noindent\hrulefill

Once you've successfully deployed your modules, you can list them from
the Gogo shell as shown below.

\begin{figure}
\centering
\includegraphics{./images/deploy-converted-modules.png}
\caption{Once you've connected to your Liferay instance in your Gogo
shell prompt, run \emph{lb} to list your new converted modules.}
\end{figure}

These tutorials explained how to convert your traditional application
into the modular format of a 7.0 style application. Specifically, you
learned how to

\begin{itemize}
\tightlist
\item
  Create a web client (\texttt{*-web}) module that holds your
  application's portlet classes and UI.
\item
  Create a service implementation module (\texttt{*-service}) and a
  service API module (\texttt{*-api}).
\item
  Run Service Builder to generate code for your application's service
  and API modules.
\item
  Wire your modules together by declaring their dependencies on each
  another.
\item
  Build your modules and deploy them to your Liferay DXP installation.
\end{itemize}

Great job!

\textbf{Related Topics}

\href{/docs/7-1/tutorials/-/knowledge_base/t/portlets}{Portlets}

\href{/docs/7-1/tutorials/-/knowledge_base/t/service-builder}{Service
Builder}

\section{Migrating Data Upgrade Processes to the New Framework for
Modules}\label{migrating-data-upgrade-processes-to-the-new-framework-for-modules}

When you make database changes to your application, you must use a
\emph{data upgrade process} to migrate users' existing data to the new
database schema. While the old framework required several classes, the
new framework can orchestrate the upgrade steps from a single class.
Managing the steps from one class facilitates developing upgrade
processes. The data upgrade framework you use depends on your
development framework. This tutorial shows you how to migrate to the new
framework.

\begin{itemize}
\item
  If your
  \href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-plugins-to-liferay-7}{upgraded
  plugin} is a traditional WAR, you don't need to do anything special;
  existing upgrade processes
  \href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-upgrade-planner}{adapted
  to 7.0's API} work as is. The new data upgrade framework is for
  modules only.
\item
  If you converted your upgraded plugin to a module or you have an
  upgraded module, you must migrate any upgrade processes you want to
  continue using to the new data upgrade framework.
\end{itemize}

You can migrate any number of old upgrade processes (starting with the
most recent ones) to the new framework. For example, if your module has
versions 1.0, 1.1, 1.2, and 1.3, but you only expect customers on
versions 1.2 and newer to upgrade, you might migrate upgrade processes
for versions 1.2 and 1.3 only.

Before beginning, make sure
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-an-upgrade-process-for-your-app}{you
know how} to create an upgrade process that uses the new framework.

\noindent\hrulefill

\textbf{Note:} Liferay Portal 6 plugins may also include verify
processes. Although you can migrate the verify processes to 7.0 without
any changes, it's a best practice to perform verification in your
upgrade processes instead.

\noindent\hrulefill

First, you'll review how Liferay Portal 6 upgrade processes work.

\subsection{Understanding Liferay Portal 6 Upgrade
Processes}\label{understanding-liferay-portal-6-upgrade-processes}

Before getting started, it's important to understand how Liferay Portal
6 upgrade processes are structured. As an example, you'll use
\href{https://github.com/liferay/liferay-plugins/tree/6.2.x/portlets/knowledge-base-portlet/docroot/WEB-INF/src/com/liferay/knowledgebase/hook/upgrade}{the
Liferay Portal 6.2 upgrade process} for the Knowledge Base Portlet.

In Liferay Portal 6 upgrade processes, the upgrade step classes for each
schema version are in folders named after their schema version. For
example, the Knowledge Base Portlet's upgrade step classes are in
folders named \texttt{v1\_0\_0}, \texttt{v1\_1\_0}, \texttt{v1\_2\_0},
and so on. Each upgrade step class extends \texttt{UpgradeProcess} and
overrides the \texttt{doUpgrade} method. The code in \texttt{doUpgrade}
performs the upgrade. For example, the Knowledge Base Portlet's
\href{https://github.com/liferay/liferay-plugins/blob/6.2.x/portlets/knowledge-base-portlet/docroot/WEB-INF/src/com/liferay/knowledgebase/hook/upgrade/v1_0_0/UpgradeRatingsEntry.java}{\texttt{v1\_0\_0/UpgradeRatingsEntry}
upgrade step} extends \texttt{UpgradeProcess} and performs the upgrade
via the \texttt{updateRatingsEntries()} call in its \texttt{doUpgrade}
method:

\begin{verbatim}
public class UpgradeRatingsEntry extends UpgradeProcess {

    @Override
    protected void doUpgrade() throws Exception {
        updateRatingsEntries();
    }

    ...

    protected void updateRatingsEntries() throws Exception {
        // Upgrade code
    }

    ...

}
\end{verbatim}

The upgrade process classes are on the same level as the folders
containing the upgrade steps and are also named after their schema
version. For example, the Knowledge Base Portlet's upgrade process
classes are named \texttt{UpgradeProcess\_1\_0\_0},
\texttt{UpgradeProcess\_1\_1\_0}, \texttt{UpgradeProcess\_1\_2\_0}, and
so on. Each upgrade process class also extends \texttt{UpgradeProcess}
and runs the upgrade process in the \texttt{doUpgrade} method. It runs
the upgrade process by passing the appropriate upgrade step to the
\texttt{upgrade} method. For example, the \texttt{doUpgrade} method in
the Knowledge Base Portlet's
\href{https://github.com/liferay/liferay-plugins/blob/6.2.x/portlets/knowledge-base-portlet/docroot/WEB-INF/src/com/liferay/knowledgebase/hook/upgrade/UpgradeProcess_1_0_0.java}{\texttt{UpgradeProcess\_1\_0\_0}
class} runs the upgrade steps \texttt{UpgradeRatingsEntry} and
\texttt{UpgradeRatingsStats} via the \texttt{upgrade} method:

\begin{verbatim}
@Override
protected void doUpgrade() throws Exception {
    upgrade(UpgradeRatingsEntry.class);
    upgrade(UpgradeRatingsStats.class);
}
\end{verbatim}

Now that you know how Liferay Portal 6 upgrade processes are defined,
you'll learn how to convert them to the new upgrade process framework in
7.0.

\subsection{Converting your Liferay Portal 6 Upgrade Process to
7.0}\label{converting-your-liferay-portal-6-upgrade-process-to-7.0}

So how do Liferay Portal 6 upgrade processes compare to those that use
the new upgrade process framework? First, the upgrade step classes are
the same, so you can leave them unchanged. Here are the big changes in
the new upgrade processes:

\begin{itemize}
\tightlist
\item
  \hyperref[create-a-registrator-class]{A single registrator class
  replaces upgrade process classes.}
\item
  \hyperref[create-a-bundle-activator]{Service Builder services require
  a Bundle Activator.}
\end{itemize}

Start your conversion by creating a registrator class.

\subsubsection{Create a Registrator
Class}\label{create-a-registrator-class}

The new data upgrade framework requires using registrator class instead
of upgrade process classes. You must combine your upgrade process
classes' functionality into a single registrator class. Recall from
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-an-upgrade-process-for-your-app\#writing-the-upgrade-step-registrator}{the
data upgrade process tutorial} that registrators define an upgrade
process that the upgrade process framework executes. Each
\texttt{registry.register} call in the registrator registers the
appropriate upgrade steps for each schema version. You must therefore
transfer the functionality of your old upgrade process classes'
\texttt{doUpgrade} methods into a registrator's
\texttt{registry.register} calls.

For example,
\href{https://github.com/liferay/liferay-portal/tree/7.1.x/modules/apps/knowledge-base/knowledge-base-service/src/main/java/com/liferay/knowledge/base/internal/upgrade}{click
here} to see the Knowledge Base Portlet's new 7.0 upgrade process in
GitHub.

Besides some additional upgrade step classes to handle changes made to
the portlet for 7.0, the only difference in this upgrade process is that
it contains a single registrator class,
\texttt{KnowledgeBaseServiceUpgrade}, instead of multiple upgrade
process classes.
\href{https://github.com/liferay/liferay-portal/blob/7.1.x/modules/apps/knowledge-base/knowledge-base-service/src/main/java/com/liferay/knowledge/base/internal/upgrade/KnowledgeBaseServiceUpgrade.java}{The
\texttt{KnowledgeBaseServiceUpgrade} class}, like all registrators,
calls the appropriate upgrade steps for each schema version in its
\texttt{registry.register} calls. For example, the first
\texttt{registry.register} call registers the upgrade process for the
\texttt{1.0.0} schema version:

\begin{verbatim}
registry.register(
        "com.liferay.knowledge.base.service", "0.0.1", "1.0.0",
        new com.liferay.knowledge.base.internal.upgrade.v1_0_0.
            UpgradeRatingsEntry(),
        new com.liferay.knowledge.base.internal.upgrade.v1_0_0.
            UpgradeRatingsStats());
\end{verbatim}

Compare this to the above \texttt{doUpgrade} method from
\href{https://github.com/liferay/liferay-plugins/blob/6.2.x/portlets/knowledge-base-portlet/docroot/WEB-INF/src/com/liferay/knowledgebase/hook/upgrade/UpgradeProcess_1_0_0.java}{the
corresponding Liferay Portal 6 upgrade process class
\texttt{UpgradeProcess\_1\_0\_0}}. Both call the same upgrade steps.

Next, create a Bundle Activator if your modularized plugin uses Service
Builder.

\subsubsection{Create a Bundle
Activator}\label{create-a-bundle-activator}

If your module implements Service Builder services, it needs a Bundle
Activator to initialize a record in the release table.
\href{/docs/7-1/tutorials/-/knowledge_base/t/upgrade-processes-for-former-service-builder-plugins}{Creating
a Bundle Activator} is straightforward.

That's it! For instructions on creating new upgrade processes for 7.0,
including complete steps on creating a registrator,
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-an-upgrade-process-for-your-app}{click
here}.

\subsection{Related Topics}\label{related-topics-12}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-an-upgrade-process-for-your-app}{Creating
Data Upgrade Processes for Modules}

\href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-plugins-to-liferay-7}{Upgrading
Plugins to 7.0}

\href{/docs/7-1/tutorials/-/knowledge_base/t/from-liferay-6-to-liferay-7}{From
Liferay Portal 6 to 7}

\chapter{From Liferay DXP 7.0 to 7.1}\label{from-liferay-dxp-7.0-to-7.1}

7.0 offers new and improved frameworks and APIs that make your plugins
faster, more secure, and easier to maintain. Upgrading plugins from
Liferay DXP 7.0 to 7.1 is easier than ever too. These tutorials show you
how:

\begin{itemize}
\tightlist
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-plugins-from-liferay-7-0-to-7-1}{Upgrading
  Plugins}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-7-0-themes-to-7-1}{Upgrading
  Themes}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-7-0-layout-templates-to-7-1}{Upgrading
  Layout Templates}
\end{itemize}

Upgrading plugins (portlets, customizations, and extensions) is up
first.

\chapter{Upgrading plugins from Liferay DXP 7.0 to
7.1}\label{upgrading-plugins-from-liferay-dxp-7.0-to-7.1}

Liferay Workspace's Target Platform feature and Upgrade Planner take a
lot of manual intervention out of upgrading to 7.0. Target Platform
facilitates updating dependencies to 7.0, and the Upgrade Planner helps
you adapt plugins to 7.0's API. This tutorial explains the plugin
upgrade steps.

\noindent\hrulefill

\textbf{Note:} Blade CLI's \texttt{convert} command
\href{/docs/7-1/tutorials/-/knowledge_base/t/migrating-traditional-plugins-to-workspace-web-applications}{migrates
traditional plugins to Liferay Workspace}, so you can leverage
Workspace's upgrade features.

\noindent\hrulefill

Here are the plugin upgrade steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/updating-liferay-workspace}{Update
  your Liferay Workspace} to that latest version.
\item
  Update your Liferay DXP-related dependencies by
  \href{/docs/7-1/tutorials/-/knowledge_base/t/managing-the-target-platform-for-liferay-workspace}{setting
  your Target Platform} to the latest version of 7.0. (Optional)
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/configuring-dependencies}{Update
  your plugin's remaining dependencies}.
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-upgrade-planner}{Adapt
  your code to 7.0's API using the Upgrade Planner}. The Upgrade Tool
  shows you where
  \href{/docs/7-1/reference/-/knowledge_base/r/breaking-changes}{breaking
  changes} affect your code and addresses many of them automatically.
\end{enumerate}

Congratulations! Your upgraded plugin is ready to
\href{/docs/7-1/tutorials/-/knowledge_base/t/starting-module-development\#building-and-deploying-a-module}{deploy
to 7.0}.

\noindent\hrulefill

\textbf{Note:} If your plugin resides outside of a Workspace,
\href{/docs/7-1/tutorials/-/knowledge_base/t/managing-the-target-platform-for-liferay-workspace\#targeting-a-platform-outside-of-workspace}{apply
the Target Platform Gradle plugin to your project} so you can set that
project's Target Platform.

\noindent\hrulefill

\section{Related Topics}\label{related-topics-13}

\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-workspace}{Liferay
Workspace}

\href{/docs/7-1/tutorials/-/knowledge_base/t/managing-the-target-platform-for-liferay-workspace}{Managing
Target Platforms for Workspace}

\href{/docs/7-1/tutorials/-/knowledge_base/t/managing-the-target-platform-for-liferay-workspace}{Configuring
Dependencies}

\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-ide}{Liferay Dev
Studio}

\chapter{Upgrading 7.0 Themes}\label{upgrading-7.0-themes}

If you've developed themes in Liferay DXP 7.0, as part of your upgrade
you'll want to use them in 7.0. The upgrade process requires several
modifications. The
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-themes}{Liferay
Theme Generator} helps automate this process.

The following tutorials show you how to upgrade your Liferay Portal 7.0
themes to 7.0:

\begin{itemize}
\tightlist
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-7-0-themes-to-7-1}{Upgrading
  7.0 Themes to 7.1}
\end{itemize}

\section{Upgrading 7.0 Layout
Templates}\label{upgrading-7.0-layout-templates}

If you've developed layout templates in Liferay DXP 7.0, you can upgrade
them for 7.0. The upgrade process requires minimal changes.

The following tutorial shows you how to upgrade your Liferay Portal 7.0
layout templates to 7.0:

\begin{itemize}
\tightlist
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-7-0-layout-templates-to-7-1}{Upgrading
  7.0 Layout Templates to 7.1}
\end{itemize}

\chapter{Developing a Web
Application}\label{developing-a-web-application}

In this Learning Path, you'll create the Liferay Guestbook Web
Application from scratch using tools like Liferay Dev Studio DXP and
Blade tools. As you create this application, you'll learn how to create
a back-end database, web services, a security model, UI, and more using
all the best practices and standards. Completing this Learning Path
prepares you to write your own application and further explore Liferay's
APIs.

To develop a web application with Liferay, start at the beginning:
setting up a Liferay development environment. Though you can use
anything from a text editor and the command line to your Java IDE of
choice, Liferay Dev Studio DXP optimizes development on Liferay's
platform. It integrates Liferay's Blade tools for modular development.

Once you set up your development environment, you can create the
application. From modeling data to Service Builder, you'll learn
everything you need to know to create and run your application.

From there you'll see everything from UI standards to providing remote
services. Once everything is completed and wrapped up with a bow, you
can distribute the application on Marketplace.

Let's Go!{}

\section{Development Setup Overview}\label{development-setup-overview}

Liferay's development tools help you get started fast. The basic steps
for installing Liferay Dev Studio DXP are

\begin{itemize}
\item
  Download a Liferay Dev Studio DXP bundle.
\item
  Unzip the downloaded package to a location on your system.
\item
  Start Dev Studio DXP.
\end{itemize}

You'll follow these steps and then generate an environment for
developing your first Liferay DXP application.

\subsection{Installing a Liferay Dev Studio DXP
Bundle}\label{installing-a-liferay-dev-studio-dxp-bundle}

Follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Download and install
  \href{http://www.oracle.com/technetwork/java/javase/downloads/index.html}{the
  Java Development Kit (JDK)}. Liferay DXP runs on Java. The JDK is
  required because you'll be developing Liferay DXP apps in Liferay Dev
  Studio DXP. The JDK is an enhanced version of the Java Environment
  used for developing new Java technology. Use JDK 8 or JDK 11.
\item
  Download and install
  \href{/docs/7-1/tutorials/-/knowledge_base/t/installing-liferay-ide}{Liferay
  Dev Studio DXP} Installing it is easy: unzip it to a convenient
  location on your system.
\item
  To run Liferay Dev Studio DXP, run the \texttt{LiferayDeveloperStudio}
  executable.
\end{enumerate}

The first time you start Liferay Dev Studio DXP, it prompts you to
select an Eclipse workspace. If you specify an empty folder, Liferay Dev
Studio DXP creates a new workspace in that folder. Follow these steps to
create a new workspace:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  When prompted, indicate your workspace's path. Name your new workspace
  \texttt{guestbook-workspace} and click \emph{OK}.
\item
  When Liferay Dev Studio DXP first launches, it presents a welcome
  page. Click the \emph{Workbench} icon to continue.
\end{enumerate}

Nice job! Your development environment is installed and your workspace
is set up.

\subsection{Creating a Liferay
Workspace}\label{creating-a-liferay-workspace}

Now you'll create another kind of workspace---a
\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-workspace}{Liferay
Workspace}. By holding and managing your Liferay DXP projects, a Liferay
Workspace provides a simplified, straightforward way to develop Liferay
DXP applications. In the background, a Liferay Workspace uses
\href{/docs/7-1/tutorials/-/knowledge_base/t/blade-cli}{Blade CLI} and
\href{https://gradle.org/}{Gradle} to manage dependencies and organize
your build environment. Note that to avoid configuration issues, you can
only create one Liferay Workspace for each Eclipse Workspace.

Follow these steps to create a Liferay Workspace in Liferay Dev Studio
DXP:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Select \emph{File} → \emph{New} → \emph{Liferay Workspace Project}.
  Note: you may have to select \emph{File} → \emph{New} → \emph{Other},
  then choose \emph{Liferay Workspace Project} in the \emph{Liferay}
  category.

  \begin{figure}
  \centering
  \includegraphics{./images/selecting-liferay-workspace.png}
  \caption{By selecting \emph{Liferay Workspace}, you begin the process
  of creating a new workspace for your Liferay DXP projects.}
  \end{figure}

  A \emph{New Liferay Workspace} dialog appears, which presents several
  configuration options.
\item
  Give your workspace the name \texttt{com-liferay-docs-guestbook}.
\item
  Next, choose your workspace's location. Leave the default setting
  checked. This places your Liferay Workspace inside your Eclipse
  workspace.
\item
  For \emph{Liferay Version} select \emph{7.1}.
\item
  Check the \emph{Download Liferay bundle} checkbox to download and
  unzip a Liferay DXP instance in your workspace automatically. When
  prompted, name the server \texttt{liferay-tomcat-bundle}.
\item
  Click \emph{Finish} to create your Liferay Workspace. This may take a
  while because Liferay Liferay DXP downloads the Liferay DXP bundle in
  the background.

  \begin{figure}
  \centering
  \includegraphics{./images/guestbook-workspace-menu.png}
  \caption{Liferay Dev Studio DXP provides an easy-to-follow menu to
  create your Liferay Workspace.}
  \end{figure}
\end{enumerate}

A dialog appears prompting you to open the Liferay Workspace
perspective. Click \emph{Yes}, and your perspective switches to Liferay
Workspace.

Congratulations! Your development environment is ready! Next, you'll get
started developing your first Liferay DXP application.

\chapter{Creating a Working
Prototype}\label{creating-a-working-prototype}

So far, you've installed Liferay Dev Studio DXP and created a Liferay
Workspace. Next, you'll create your application and start adding
features to it. Here's what you'll do:

\begin{itemize}
\tightlist
\item
  Create your application and deploy it to your Liferay DXP instance.
\item
  Create a functional button for adding and removing guestbook entries.
\item
  Create a form for users to create and edit guestbook entries.
\item
  Create a UI for displaying guestbook entries.
\item
  Implement a prototype storage system (to be replaced later) for
  storing guestbook entries.
\end{itemize}

At the end, you'll have a fully functional prototype application ready
to be enhanced later! There's no time like now to get started.

Let's Go!{}

\section{Writing Your First Liferay DXP
Application}\label{writing-your-first-liferay-dxp-application}

\begin{verbatim}
<p id="stepTitle">Developing Your First Portlet</p><p>Step 1 of 8</p>
\end{verbatim}

Now you'll learn step-by-step how to create your project and deploy your
application to Liferay DXP. Before you know it, you'll have your
application deployed alongside those that come with Liferay DXP.

Your first application is simple: you'll build a guestbook application
that looks like this:

\begin{figure}
\centering
\includegraphics{./images/first-guestbook-portlet.png}
\caption{You'll create this simple application.}
\end{figure}

By default, it shows guestbook messages that users leave on your
website. To add a message, you click the \emph{Add Entry} button to show
a form for entering and saving a message.

Ready to write your first Liferay DXP application?

\subsection{Creating Your First Liferay DXP
Application}\label{creating-your-first-liferay-dxp-application}

Your first step is to create a \emph{Liferay Module Project}. Modules
are the core building blocks of Liferay DXP applications. Every
application is made from one or more modules. Each module encapsulates a
functional piece of an application. Multiple modules form a complete
application.

These modules are \href{https://www.osgi.org/}{OSGi} modules. The OSGi
container in Liferay DXP can run any OSGi module. Each module is
packaged as a JAR file that contains a manifest file. The manifest is
needed for the container to recognize the module. Technically, a module
that contains only a manifest is still valid. Of course, such a module
wouldn't be very interesting.

Now you'll create your first module. For the purpose of this Learning
Path, you'll create your modules inside your Liferay Workspace. Follow
these instructions to create your first Liferay Module Project:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In the Project Explorer in Liferay Dev Studio DXP, right click on your
  Liferay Workspace and select \emph{New} → \emph{Liferay Module
  Project}.
\item
  Complete the first screen of the wizard with the following
  information:

  \begin{itemize}
  \tightlist
  \item
    Enter \texttt{guestbook-web} for the Project name.
  \item
    Use the \emph{Gradle} Build type.
  \item
    Select \texttt{mvc-portlet} for the Project Template.
  \end{itemize}

  Click \emph{Next}.
\item
  On the second screen of the wizard, enter \texttt{Guestbook} for the
  component class name, and \texttt{com.liferay.docs.guestbook.portlet}
  for the package name. Click \emph{Finish}.
\end{enumerate}

Note that it may take a while for Dev Studio DXP to create your project,
because Gradle downloads your project's dependencies for you during
project creation. Once this is done, you have a module project named
\texttt{guestbook-web}. The \texttt{mvc-portlet} template configured the
project with the proper dependencies and generated all the files you
need to get started:

\begin{itemize}
\tightlist
\item
  The portlet class (in the package you specified)
\item
  JSP files (in \texttt{/src/main/resources})
\item
  Language properties (also in \texttt{/src/main/resources})
\end{itemize}

\begin{figure}
\centering
\includegraphics{./images/guestbook-web-project.png}
\caption{Your new module project appears in your Liferay Workspace's
\texttt{modules} folder.}
\end{figure}

Your new module project is a \emph{portlet} application. Next, you'll
learn exactly what a portlet is.

\subsection{What is a Portlet?}\label{what-is-a-portlet}

Web applications can be simple: they might show you one piece of
information, such as an article. A complex application might track your
taxes as you enter lots of data into an application that calculates
whether you owe or are due a refund. These applications run on a
\emph{platform} that provides application developers the building blocks
they need to make applications.

\begin{figure}
\centering
\includegraphics{./images/portlet-applications.png}
\caption{Many Liferay applications can run at the same time on the same
page.}
\end{figure}

Liferay DXP provides a platform that contains common features needed by
today's applications, including user management, security, user
interfaces, services, and more. Portlets are one of those basic building
blocks. Often a web application takes up the entire page. If you want,
you can do this with applications in Liferay DXP as well. Portlets,
however, let you serve many applications on the same page at the same
time. Liferay DXP's framework takes this into account at every step. For
example, features like platform-generated URLs exist to support
Liferay's ability to serve multiple applications on the same page.

\subsection{What is a Component?}\label{what-is-a-component}

Portlets created in Liferay Module Projects are generated as
\emph{Components}. If a module (sometimes also called a \emph{bundle})
encapsulates pieces of your application, a component is the object that
contains the core functionality. A Component is managed by a component
framework or container. Components are deployed inside modules, and
they're created, started, stopped, and destroyed as needed by the
container. What a perfect model for a web application! It can be made
available only when needed, and when it's not, the container can make
sure it doesn't use resources needed by other components.

In this case, you created a Declarative Services (DS) component. With
Declarative Services, you declare that an object is a component, and you
define data about the component so the container knows how to manage it.
A default configuration was created for you; you'll examine it later.

\subsection{Deploying the Application}\label{deploying-the-application}

Even though all you've done is generate it, the \texttt{guestbook-web}
project is ready to be built and deployed.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Make sure that your server is running, and if it isn't, select it in
  Dev Studio DXP's Servers pane and click the start button
  (\includegraphics{./images/icon-start-server.png}).
\item
  After it starts, drag and drop the \texttt{guestbook-web} project from
  the Project Explorer to the server.

  \begin{figure}
  \centering
  \includegraphics{./images/deploy-module.gif}
  \caption{Drag and drop the module.}
  \end{figure}
\item
  Open a browser and navigate to Liferay DXP
  (\url{http://localhost:8080} by default).

  If this is your first time starting Liferay DXP, you'll go through a
  short wizard to set up your server. In this wizard, make sure you use
  the default database (Hypersonic). Although this database isn't
  intended for production use, it works fine for development and
  testing.
\item
  To add an application to a page, click \emph{Add}
  (\includegraphics{./images/icon-add-app.png}) in the upper right hand
  corner.
\item
  Select \emph{Widgets}. In the Applications list, your application
  should appear in the Sample category. Its name is \texttt{Guestbook}.
\end{enumerate}

\begin{figure}
\centering
\includegraphics{./images/default-portlet-application.png}
\caption{This is the default Liferay home page. It contains the Hello
World widget and the initial version of the Guestbook application that
you created.}
\end{figure}

Now you're ready to jump in and start developing your Guestbook portlet.

\section{Creating an Add Entry
Button}\label{creating-an-add-entry-button}

\begin{verbatim}
<p id="stepTitle">Developing Your First Portlet</p><p>Step 2 of 8</p>
\end{verbatim}

A guestbook application is pretty simple, right? People come to your
site and post their names and brief messages. Other users can read these
entries and post their own.

When you created your project, it generated a file named
\texttt{view.jsp} in your project's
\texttt{src/main/resources/META-INF/resources} folder. This file
contains the default view for users when the portlet is added to the
page. Right now it contains sample content:

\begin{verbatim}
<%@ include file="/init.jsp" %>

<p>
    <b><liferay-ui:message key="guestbook-web.caption"/></b>
</p>
\end{verbatim}

First, \texttt{view.jsp} imports \texttt{init.jsp}. By convention,
imports and tag library declarations are in an \texttt{init.jsp} file.
The other JSP files in the application import \texttt{init.jsp}. This
lets you handle JSP dependency management in a single file.

Besides importing \texttt{init.jsp}, \texttt{view.jsp} displays a
message defined by a language key. This key and its value are declared
in your project's
\texttt{src/main/resources/content/Language.properties} file.

It's time to start developing the Guestbook application. First, users
need a way to add a guestbook entry. In \texttt{view.jsp}, follow these
steps to add this button:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Remove everything under the include for \texttt{init.jsp}.
\item
  Below the include, add the following
  \href{http://alloyui.com/}{AlloyUI} tags to display an Add Entry
  button inside of a button row:

\begin{verbatim}
<aui:button-row>
    <aui:button value="Add Entry"></aui:button>
</aui:button-row>
\end{verbatim}
\end{enumerate}

You can use \texttt{aui} tags in \texttt{view.jsp} since
\texttt{init.jsp} declares the AlloyUI tag library by default (as well
as other important imports and tags):

\begin{verbatim}
    <%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %>
    <%@ taglib uri="http://java.sun.com/portlet_2_0" prefix="portlet" %>

    <%@ taglib uri="http://liferay.com/tld/aui" prefix="aui" %>
    <%@ taglib uri="http://liferay.com/tld/portlet" prefix="liferay-portlet" %>
    <%@ taglib uri="http://liferay.com/tld/theme" prefix="liferay-theme" %>
    <%@ taglib uri="http://liferay.com/tld/ui" prefix="liferay-ui" %>

    <portlet:defineObjects />

    <liferay-theme:defineObjects />
\end{verbatim}

Your application now displays a button instead of a message, but the
button doesn't do anything. Next, you'll create a URL for your button.

\begin{figure}
\centering
\includegraphics{./images/guestbook-new-button.png}
\caption{Your new button is awesome, but it doesn't work yet.}
\end{figure}

\section{Generating Portlet URLs}\label{generating-portlet-urls}

\begin{verbatim}
<p id="stepTitle">Developing Your First Portlet</p><p>Step 3 of 8</p>
\end{verbatim}

Recall that users can place multiple portlets on a single page. As a
developer, you have no idea what other portlets may share a page with
yours. This means that you can't define URLs for various functions in
your application like you otherwise would.

For example, consider a Calendar application that a user puts on the
same page as a Blog application. To implement the functionality for
deleting calendar events and blog entries in the respective application,
both application developers append the \texttt{del} parameter to the URL
and give it a primary key value so the application can look up and
delete the calendar event or blog entry. Since both applications read
this parameter, their delete functionality clashes.

System-generated URLs prevent this. If the system generates a unique URL
for each piece of functionality, multiple applications can coexist in
perfect harmony.

In \texttt{view.jsp}, follow these steps to create system-generated URLs
in your portlet:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add these tags below
  \texttt{\textless{}\%@\ include\ file="/init.jsp"\ \%\textgreater{}},
  but above the \texttt{\textless{}aui:button-row\textgreater{}} tag:

\begin{verbatim}
<portlet:renderURL var="addEntryURL">
    <portlet:param name="mvcPath" value="/edit_entry.jsp"></portlet:param>
</portlet:renderURL>
\end{verbatim}
\item
  Add this attribute to the \texttt{\textless{}aui:button\textgreater{}}
  tag, before \texttt{value="Add\ Entry"}:

\begin{verbatim}
onClick="<%= addEntryURL.toString() %>"
\end{verbatim}

  Your \texttt{view.jsp} page should now look like this:

\begin{verbatim}
<%@ include file="/init.jsp" %>

<portlet:renderURL var="addEntryURL">
    <portlet:param name="mvcPath" value="/edit_entry.jsp"></portlet:param>
</portlet:renderURL>

<aui:button-row>
    <aui:button onClick="<%= addEntryURL.toString() %>" value="Add Entry"></aui:button>
</aui:button-row>
\end{verbatim}
\end{enumerate}

The \texttt{\textless{}portlet:renderURL\textgreater{}} tag's
\texttt{var} attribute creates the \texttt{addEntryURL} variable to hold
the system-generated URL. The
\texttt{\textless{}portlet:param\textgreater{}} tag defines a URL
parameter to append to the URL. In this example, a URL parameter named
\texttt{mvcPath} with a value of \texttt{/edit\_entry.jsp} is appended
to the URL.

Note that your \texttt{GuestbookPortlet} class (located in your
\texttt{guestbook-web} module's
\texttt{com.liferay.docs.guestbook.portlet} package) extends Liferay's
\texttt{MVCPortlet} class. In a
\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-mvc-portlet}{Liferay
MVC portlet}, the \texttt{mvcPath} URL parameter indicates a page within
your portlet. To navigate to another page in your portlet, use a portal
URL with the parameter \texttt{mvcPath} to link to the specific page.

In the example above, you created a \texttt{renderURL} that points to
your application's \texttt{edit\_entry.jsp} page, which you haven't yet
created. Note that using an AlloyUI button to follow the generated URL
isn't required. You can use any HTML construct that contains a link.
Users can click your button to access your application's
\texttt{edit\_entry.jsp} page. This currently produces an error since no
\texttt{edit\_entry.jsp} exists yet. Creating \texttt{edit\_entry.jsp}
is your next step.

\section{Linking to Another Page}\label{linking-to-another-page}

\begin{verbatim}
<p id="stepTitle">Developing Your First Portlet</p><p>Step 4 of 8</p>
\end{verbatim}

In the same folder your \texttt{view.jsp} is in, create the
\texttt{edit\_entry.jsp} file:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Right-click your project's
  \texttt{src/main/resources/META-INF/resources} folder and choose
  \emph{New} → \emph{File}.
\item
  Name the file \texttt{edit\_entry.jsp} and click \emph{Finish}.
\item
  Add this line to the top of the file:

\begin{verbatim}
<%@ include file="init.jsp" %>
\end{verbatim}

  Remember, it's a best practice to add all JSP imports and tag library
  declarations to a single file that's imported by your application's
  other JSP files. For \texttt{edit\_entry.jsp}, you need these imports
  to access the portlet tags that create URLs and the Alloy tags that
  create the form.
\item
  You'll create two URLs: one to submit the form and one to go back to
  the \texttt{view.jsp}. To create the URL to go back to
  \texttt{view.jsp}, add the following tag below the first line you
  added:

\begin{verbatim}
<portlet:renderURL var="viewURL">
    <portlet:param name="mvcPath" value="/view.jsp"></portlet:param>
</portlet:renderURL>
\end{verbatim}
\end{enumerate}

Next, you must create a new URL for submitting the form. Before you do,
you must learn about portlet actions.

\section{Triggering Portlet Actions}\label{triggering-portlet-actions}

\begin{verbatim}
<p id="stepTitle">Developing Your First Portlet</p><p>Step 5 of 8</p>
\end{verbatim}

Recall that portlets run in a portion of a page, and a page can contain
multiple portlets. Because of this, portlets have \emph{phases} of
operation. Here, you'll learn about the most important two. The first
phase is the one you've already used: the \emph{render} phase. All this
means is that the portlet draws itself, using the JSPs you write for it.

The other phase is called the \emph{action} phase. This phase runs once,
when a user triggers a portlet action. The portlet performs whatever
action the user triggered, such as performing a search or adding a
record to a database. Then the portlet goes back to the render phase and
re-renders itself according to its new state.

To save a guestbook entry, you must trigger a portlet action. For this,
you'll create an action URL.

Add the following tag in \texttt{edit\_entry.jsp} after the closing
\texttt{\textless{}/portlet:renderURL\textgreater{}} tag:

\begin{verbatim}
<portlet:actionURL name="addEntry" var="addEntryURL"></portlet:actionURL>
\end{verbatim}

You now have the two required URLs for your form.

\section{Creating a Form}\label{creating-a-form}

\begin{verbatim}
<p id="stepTitle">Developing Your First Portlet</p><p>Step 6 of 8</p>
\end{verbatim}

The form for creating guestbook entries has two fields: one for the name
of the person submitting the entry and one for the entry itself.

Add the following tags to the end of your \texttt{edit\_entry.jsp} file:

\begin{verbatim}
<aui:form action="<%= addEntryURL %>" name="<portlet:namespace />fm">
        <aui:fieldset>
            <aui:input name="name"></aui:input>
            <aui:input name="message"></aui:input>
        </aui:fieldset>

        <aui:button-row>
            <aui:button type="submit"></aui:button>
            <aui:button type="cancel" onClick="<%= viewURL.toString() %>"></aui:button>
        </aui:button-row>
</aui:form>
\end{verbatim}

Save \texttt{edit\_entry.jsp} and redeploy your application. If you
refresh the page and click the \emph{Add Entry} button, your form
appears. If you click the \emph{Cancel} button, you go back to
\texttt{view.jsp}, but don't try the \emph{Save} button yet. You haven't
yet created the action that saves a guestbook entry, so clicking
\emph{Save} produces an error.

\begin{figure}
\centering
\includegraphics{./images/first-guestbook-portlet-edit-entry.png}
\caption{This is the Guestbook application's form for adding entries.}
\end{figure}

Implementing the portlet action (what happens when the user clicks
\emph{Save}) is your next task.

\section{Implementing Portlet
Actions}\label{implementing-portlet-actions}

\begin{verbatim}
<p id="stepTitle">Developing Your First Portlet</p><p>Step 7 of 8</p>
\end{verbatim}

When users submit the form, your application stores the form data for
display in the guestbook. To keep this first application simple, you'll
implement this using a part of the Portlet API called Portlet
Preferences. Normally, of course, you'd use a database, and you'll
refactor this into a database later. For now, however, you can create
the first iteration of your guestbook application using portlet
preferences.

To make your portlet do anything other than re-render itself, you must
implement portlet actions. An action defines some processing, usually
based on user input, that the portlet must perform before it renders
itself. In the case of the guestbook portlet, the action you'll
implement next saves a guestbook entry that a user typed into the form.
Saved guestbook entries can be retrieved and displayed later.

Since you're using Liferay's MVC Portlet framework, you have an easy way
to implement actions. Portlet actions are implemented in the portlet
class, which acts as the controller. In the form you just created, you
made an action URL, and you called it \texttt{addEntry}. To create a
portlet action, you create a method in the portlet class with the same
name. \texttt{MVCPortlet} calls that method when a user triggers its
matching URL.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open \texttt{GuestbookPortlet}. The project template generated this
  class when you created the portlet project.
\item
  Create a method with the following signature:

\begin{verbatim}
public void addEntry(ActionRequest request, ActionResponse response) {

}
\end{verbatim}
\item
  Press {[}CTRL{]}+{[}SHIFT{]}+O to organize imports and import the
  required \texttt{javax.portlet.ActionRequest} and
  \texttt{javax.portlet.ActionResponse} classes.
\end{enumerate}

You've now created a portlet action. It doesn't do anything, but at
least you won't get an error now if you submit your form. Next, you
should make the action save the form data.

Because of the limitations of the portlet preferences API, you must
store each guestbook entry as a \texttt{String} in a string array. Since
your form has two fields, you must use a delimiter to determine where
the user name ends and the guestbook entry begins. The caret symbol
(\texttt{\^{}}) makes a good delimiter because users are highly unlikely
to use that symbol in a guestbook entry.

\noindent\hrulefill

\textbf{Note:} The portlet preferences API is used here for prototyping
purposes only. In most cases, you'll need a more robust solution for
storing data. You'll learn how to implement such a solution later in the
\emph{Service Builder} section.

\noindent\hrulefill

The following method implements adding a guestbook entry to a portlet
preference called \texttt{guestbook-entries}:

\begin{verbatim}
public void addEntry(ActionRequest request, ActionResponse response) {
    try {
        PortletPreferences prefs = request.getPreferences();

        String[] guestbookEntries = prefs.getValues("guestbook-entries",
                new String[1]);

        ArrayList<String> entries = new ArrayList<String>();

        if (guestbookEntries[0] != null) {
            entries = new ArrayList<String>(Arrays.asList(prefs.getValues(
                    "guestbook-entries", new String[1])));
        }

        String userName = ParamUtil.getString(request, "name");
        String message = ParamUtil.getString(request, "message");
        String entry = userName + "^" + message;

        entries.add(entry);

        String[] array = entries.toArray(new String[entries.size()]);

        prefs.setValues("guestbook-entries", array);

        try {
            prefs.store();
        }
        catch (IOException ex) {
            Logger.getLogger(GuestbookPortlet.class.getName()).log(
                    Level.SEVERE, null, ex);
        }
        catch (ValidatorException ex) {
            Logger.getLogger(GuestbookPortlet.class.getName()).log(
                    Level.SEVERE, null, ex);
        }

    }
    catch (ReadOnlyException ex) {
        Logger.getLogger(GuestbookPortlet.class.getName()).log(
                Level.SEVERE, null, ex);
    }
}
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Replace your existing \texttt{addEntry} method with the above method.
\item
  Press {[}CTRL{]}+{[}SHIFT{]}+O to organize imports and select the
  \texttt{javax.portlet.PortletPreferences},
  \texttt{java.util.logging.Logger}, and
  \texttt{java.util.logging.Level} when prompted (not their Liferay
  equivalents).
\end{enumerate}

First, the preferences are retrieved. Then the
\texttt{guestbook-entries} preference is retrieved and converted to an
\texttt{ArrayList} so that you can add an entry without worrying about
exceeding the size of the array. Next, the name and message fields from
your form are retrieved. Notice how Liferay's \texttt{ParamUtil} class
makes it easy to retrieve URL parameters.

Finally, the fields are combined into a \texttt{String} delimited by a
caret, and the new entry is added to the \texttt{ArrayList}, which is
then converted back to an array so it can be stored as a preference. The
try/catch blocks are required by the portlet preferences API.

This isn't the normal way to use portlet preferences, but it provides a
quick and easy way for you to store guestbook entries in this first
version of your application. In a later step, you'll implement a robust
way to store guestbook entries in a database.

The next and final feature to implement is a mechanism for viewing
guestbook entries.

\section{Displaying Guestbook
Entries}\label{displaying-guestbook-entries}

\begin{verbatim}
<p id="stepTitle">Developing Your First Portlet</p><p>Step 8 of 8</p>
\end{verbatim}

To display guestbook entries, you must do the reverse of what you did to
store them: retrieve them from portlet preferences, loop through them,
and present them on the page. The best way to do this with MVC Portlet
is to use the
\href{https://en.wikipedia.org/wiki/Model\%E2\%80\%93view\%E2\%80\%93controller}{Model-View-Controller}
paradigm. You already have the view (your JSP files) and your controller
(your portlet class). Now you need your model.

\subsection{Creating Your Model}\label{creating-your-model}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a new package called \texttt{com.liferay.docs.guestbook.model}.
  To do this, right-click your \texttt{src/main/java} folder and select
  \emph{New} → \emph{Package}. Then enter the package name in the dialog
  box that appears.
\item
  Next, create your model class. This class models a guestbook entry. To
  do this, right-click your new package and select \emph{New} →
  \emph{Class}. Name the class \texttt{Entry}, and click \emph{Finish}.

  You now have a Java class for your guestbook entries. Next, you'll
  give it the fields you need to store entries.
\item
  Create two private String variables: \texttt{name} and
  \texttt{message}.

\begin{verbatim}
private String name;
private String message;
\end{verbatim}
\item
  Right-click a blank area of the editor and select \emph{Source} →
  \emph{Generate Getters and Setters}. Click \emph{Select All} in the
  dialog that pops up, and then click \emph{Generate}.
\item
  Next, provide two constructors: one that initializes the class with no
  values for the two fields, and one that takes the two fields as
  parameters and sets their values:

\begin{verbatim}
public Entry() {
   this.name = null;
   this.message = null;
}

public Entry(String name, String message) {
   setName(name);
   setMessage(message);
}
\end{verbatim}
\end{enumerate}

Your completed model class looks like this:

\begin{verbatim}
package com.liferay.docs.guestbook.model;

public class Entry {

    private String name;
    private String message;

    public Entry() {
        this.name = null;
        this.message = null;
    }

    public Entry(String name, String message) {
        setName(name);
        setMessage(message);
    }

    public String getName() {
        return name;
    }

    public String getMessage() {
        return message;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void setMessage(String message) {
        this.message = message;
    }

}
\end{verbatim}

Now that you have your model, you have an easy way of encapsulating
guestbook entries so they can be processed by the controller layer and
displayed by the view layer. Your next step is to enhance the controller
(your portlet class) so that guestbook entries are processed and ready
to display when users see the guestbook application.

\subsection{Customizing How Your Application is
Rendered}\label{customizing-how-your-application-is-rendered}

As mentioned earlier, your application uses two portlet phases: render
and action. To make the guestbook show the saved guestbook entries when
users view the application, you must customize your portlet's render
functionality, which it's currently inheriting from its parent class,
\texttt{MVCPortlet}.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add the following method that converts the array to a \texttt{List} of
  your model objects:

\begin{verbatim}
private List<Entry> parseEntries(String[] guestbookEntries) {
    List<Entry> entries = new ArrayList<Entry>();

    for (String entry : guestbookEntries) {
        String[] parts = entry.split("\\^", 2);
        Entry gbEntry = new Entry(parts[0], parts[1]);
        entries.add(gbEntry);
    }

    return entries;
}
\end{verbatim}

  As you can see, this method splits the entries in the \texttt{String}
  array into two parts based on the caret (\texttt{\^{}}) character.
\item
  Open \texttt{GuestbookPortlet} and add the following method below your
  \texttt{addEntry} method:

\begin{verbatim}
@Override
public void render(RenderRequest renderRequest, RenderResponse renderResponse)
    throws PortletException, IOException {

    PortletPreferences prefs = renderRequest.getPreferences();
    String[] guestbookEntries = prefs.getValues("guestbook-entries", new String[1]);

    if (guestbookEntries[0] != null) {
        List<Entry> entries = parseEntries(guestbookEntries);
        renderRequest.setAttribute("entries", entries);
    }

    super.render(renderRequest, renderResponse);
}
\end{verbatim}

  This method retrieves the guestbook entries from the configuration,
  calls \texttt{parsEntries} to convert it to a \texttt{List} of
  \texttt{Entry} objects, and places that \texttt{List} into the request
  object. It then calls the parent class's \texttt{render} method.
\item
  Press {[}CTRL{]}+{[}SHIFT{]}+O to organize imports.
\end{enumerate}

\noindent\hrulefill

Note: When you are prompted to choose imports, here are some guidelines:

\begin{itemize}
\item
  Always use \texttt{org.osgi...} packages instead of
  \texttt{aQute.bnd...}
\item
  Generally use \texttt{java.util...} or \texttt{javax.portlet...}
  packages.
\item
  You never use \texttt{java.awt...} in this project.
\item
  Only use \texttt{com.liferay...} when it is for a Liferay specific
  implementation or your custom implementation of a concept.
\end{itemize}

For example:

\begin{itemize}
\item
  If you are given the choice between \texttt{javax.portlet.Portlet} and
  \texttt{com.liferay.portlet.Portlet} choose
  \texttt{javax.portlet.Portlet}.
\item
  If you are given the choice between \texttt{org.osgi.component} and
  \texttt{aQute.bnd.annotation.component} choose
  \texttt{org.osgi.component}
\item
  However, if you are given the choice between
  \texttt{java.util.Map.Entry} and
  \texttt{com.liferay.docs.guestbook.model.Entry} (the custom class you
  created) choose \texttt{com.liferay.docs.guestbook.model.Entry}
\end{itemize}

If at some point you think you chose an incorrect import, but you're not
sure what it might be, you can erase all of the imports from the file
and press {[}CTRL{]}+{[}SHIFT{]}+O again and see if you can identify
where you went wrong.

\noindent\hrulefill

Now that you have your controller preparing your data for display, your
next step is to implement the view so users can see guestbook entries.

\subsection{Displaying Guestbook
Entries}\label{displaying-guestbook-entries-1}

Liferay's development framework makes it easy to loop through data and
display it nicely to the end user. You'll use a Liferay UI construct
called \emph{Search Container} to make this happen.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add these tags to your \texttt{view.jsp} in between the
  \texttt{\textless{}/portlet:renderURL\textgreater{}} and
  \texttt{\textless{}aui:button-row\textgreater{}} tags:

\begin{verbatim}
<jsp:useBean id="entries" class="java.util.ArrayList" scope="request"/>

<liferay-ui:search-container>
    <liferay-ui:search-container-results results="<%= entries %>" />

    <liferay-ui:search-container-row
        className="com.liferay.docs.guestbook.model.Entry"
        modelVar="entry"
    >
        <liferay-ui:search-container-column-text property="message" />

        <liferay-ui:search-container-column-text property="name" />
    </liferay-ui:search-container-row>

    <liferay-ui:search-iterator />
</liferay-ui:search-container>
\end{verbatim}
\end{enumerate}

Save your work, deploy your application, and try adding some guestbook
entries.

\begin{figure}
\centering
\includegraphics{./images/guestbook-prototype-form.png}
\caption{You have a form to enter information.}
\end{figure}

\begin{figure}
\centering
\includegraphics{./images/guestbook-prototype-container.png}
\caption{Submitted entries are displayed here..}
\end{figure}

Awesome! You've finished your prototype! You have a working application
that adds and saves guestbook entries.

The way you're saving the entries isn't the best way to persist data in
your application. Next, you'll use Service Builder to generate your
persistence classes and the methods you need to store your application
data in the database.

\chapter{Generating the Back-end}\label{generating-the-back-end}

So far, you have a prototype application that uses Liferay's
Model-View-Controller (MVC) portlet framework. MVC is a great design
pattern for web applications because it splits your application into
three parts (the model, the view, and the controller). This lets you
swap out those parts if necessary.

A \emph{persistence} layer and a \emph{service} layer are added to these
three parts of your application. To get the prototype working, you used
Portlet Properties to create a rudimentary persistence layer. Since this
isn't a long-term solution, you'll now replace that layer by persisting
your guestbooks and their entries to a database.

\begin{figure}
\centering
\includegraphics{./images/application-layers.png}
\caption{Service Builder generates the shaded layers of your
application.}
\end{figure}

\emph{Service Builder} is Liferay's code generation tool for defining
object models and mapping those models to SQL databases. By defining
your model in a single XML file, you can generate your object model (the
M in MVC), your service layer, and your persistence layer all in one
shot. At the same time, you can generate web services (more on that
later) and support every database Liferay DXP supports.

Ready to begin?

Let's Go!{}

\section{What is Service Builder?}\label{what-is-service-builder}

\begin{verbatim}
<p id="stepTitle">Generating the Back-end</p><p>Step 1 of 3</p>
\end{verbatim}

Now you'll use Service Builder to generate create, read, update, delete,
and find operations for your application. You'll also use Service
Builder to generate the necessary model, persistence, and service layers
for your application. Then you can add your application's necessary
business logic.

\subsection{Guestbook Application
Design}\label{guestbook-application-design}

In the prototype application, you defined a single guestbook's entries
and displayed them in a list. The full application will handle multiple
Guestbooks and their entries. To make this work, you'll create two
tables in the database: one for guestbooks and one for guestbook
entries.

\begin{figure}
\centering
\includegraphics{./images/guestbook-final.png}
\caption{When you're done, the Guestbook supports multiple guestbooks
and makes use of many Liferay features.}
\end{figure}

\subsection{Service Layer}\label{service-layer}

This application is data-driven. It uses services for storing and
retrieving data. The application asks for data, and the service fetches
it from the persistence layer. The application can then display this
data to the user, who reads or modifies it. If the data is modified, the
application passes it back to the service, and which calls the
persistence layer to store it. The application doesn't need to know
anything about how the service does what it does.

To get started, you'll create a Service Builder project and populate its
\texttt{service.xml} file with all the necessary entities to generate
this code:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In Liferay Dev Studio DXP, click \emph{File} → \emph{New} →
  \emph{Liferay Module Project}.
\item
  Name the project \texttt{guestbook}.
\item
  Select \texttt{service-builder} for the Project Template Name.
\item
  Click \emph{Next}.
\item
  Enter \texttt{com.liferay.docs.guestbook} for the \emph{Package Name}.
\item
  Click \emph{Finish}.
\end{enumerate}

This creates two modules: an API module (\texttt{guestbook-api}) and a
service module (\texttt{guestbook-service}). Next, you'll learn how to
use them.

\begin{figure}
\centering
\includegraphics{./images/guestbook-service-project.png}
\caption{Your current project structure.}
\end{figure}

\section{Generating Model, Service, and Persistence
Layers}\label{generating-model-service-and-persistence-layers}

\begin{verbatim}
<p id="stepTitle">Generating the Back-end</p><p>Step 2 of 3</p>
\end{verbatim}

The persistence layer saves and retrieves your model data. The service
layer is a buffer between your application and persistence layers:
having it lets you swap out your persistence layer for a different
implementation without modifying anything but the calls in the service
layer.

To model the guestbooks and entries, you'll create guestbook and entry
model classes. But you won't do this directly in Java. Instead, you'll
define them in Service Builder, which generates your object model and
maps it to all the SQL databases Liferay DXP supports.

This application's design allows for multiple guestbooks, each
containing different sets of entries. All users with permission to
access the application can add entries, but only administrative users
can add guestbooks.

It's time to get started. You'll create the \texttt{Guestbook} entity
first:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In your \texttt{guestbook-service} project, open \texttt{service.xml}.
  Make sure the \emph{Source} tab is selected.
\item
  When Liferay Dev Studio DXP generated your project, it filled this
  file with dummy entities, which you'll replace. First replace the
  file's opening contents (below the \texttt{DOCTYPE}) with the
  following code:

\begin{verbatim}
<service-builder auto-namespace-tables="true" package-path="com.liferay.docs.guestbook">
    <author>liferay</author>
    <namespace>GB</namespace>
    <entity name="Guestbook" local-service="true" uuid="true">
\end{verbatim}

  This defines the author, namespace, and the entity name. The namespace
  keeps the database field names from conflicting. The last tag is the
  opening tag for the \texttt{Guestbook} entity definition. In this tag,
  you enable local services for the entity, define its name, and specify
  that it should have a
  \href{https://en.wikipedia.org/wiki/Universally_unique_identifier}{universally
  unique identifier (UUID)}.
\item
  Next, replace the PK fields section:

\begin{verbatim}
<column name="guestbookId" primary="true" type="long" />
\end{verbatim}

  This defines \texttt{guestbookId} as the entity's primary key of the
  type \texttt{long}.
\item
  The group instance can be left alone.

\begin{verbatim}
<column name="groupId" type="long" />
\end{verbatim}

  This defines the ID of the Site in Liferay DXP that the entity
  instance belongs to (more on this in a moment).
\item
  Leave the Audit Fields section alone. Add status fields:

\begin{verbatim}
<!-- Status fields -->

<column name="status" type="int" />
<column name="statusByUserId" type="long" />
<column name="statusByUserName" type="String" />
<column name="statusDate" type="Date" />
\end{verbatim}

  The Audit section defines Liferay DXP metadata. The \texttt{companyId}
  is the primary key of a
  \href{/docs/7-1/user/-/knowledge_base/u/setting-up}{portal instance}.
  The \texttt{userId} is the primary key of a user. The
  \texttt{createDate} and \texttt{modifiedDate} store the respective
  dates on which the entity instance is created and modified. The Status
  section is used later to implement workflow.
\item
  In the Other fields section, replace the generated fields with this
  one:

\begin{verbatim}
 <column name="name" type="String" />
\end{verbatim}
\item
  Next, remove everything else from the Guestbook entity. Before the
  closing \texttt{\textless{}/entity\textgreater{}} tag, add this finder
  definition:

\begin{verbatim}
    <finder name="GroupId" return-type="Collection">
        <finder-column name="groupId" />
    </finder>
\end{verbatim}

  A finder generates a \texttt{get} method you'll use to retrieve
  Guestbook entities. The fields used by the finder define the scope of
  the data retrieved. This finder gets all Guestbooks by their
  \texttt{groupId}, which corresponds to the
  \href{/docs/7-1/user/-/knowledge_base/u/building-a-site}{Site} the
  application is on. This lets administrators put Guestbooks on multiple
  Sites, and each \texttt{Guestbook} has its own data scoped to its
  Site.
\end{enumerate}

The \texttt{Guestbook} entity is finished for now. Next, you'll create
the \texttt{Entry} entity:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add the opening entity tag:

\begin{verbatim}
<entity name="Entry" local-service="true" uuid="true">
\end{verbatim}

  As with the \texttt{Guestbook} entity, you enable local services,
  define the entity's name, and specify that it should have a UUID.
\item
  Add the tag to define the primary key and the \texttt{groupId}:

\begin{verbatim}
<column name="entryId" primary="true" type="long" />

<column name="groupId" type="long" />
\end{verbatim}
\item
  Add audit fields to match the fields in the \texttt{Guestbook} entity:

\begin{verbatim}
<column name="companyId" type="long" />
<column name="userId" type="long" />
<column name="userName" type="String" />
<column name="createDate" type="Date" />
<column name="modifiedDate" type="Date" />
\end{verbatim}
\item
  Add status fields like you did for the guestbook:

\begin{verbatim}
 <!-- Status fields -->

 <column name="status" type="int" />
 <column name="statusByUserId" type="long" />
 <column name="statusByUserName" type="String" />
 <column name="statusDate" type="Date" />
\end{verbatim}
\item
  Add the fields that define an \texttt{Entry}:

\begin{verbatim}
<column name="name" type="String" />
<column name="email" type="String" />
<column name="message" type="String" />
<column name="guestbookId" type="long" />
\end{verbatim}

  The \texttt{name}, \texttt{email}, and \texttt{message} fields
  comprise an \texttt{Entry}. These fields define the name of the person
  creating the entry, an email address, and the Guestbook message,
  respectively. The \texttt{guestbookId} is assigned automatically by
  code you'll write, and is a \texttt{Guestbook} foreign key. This ties
  the \texttt{Entry} to a specific \texttt{Guestbook}.
\item
  Add your finder and closing entity tag:

\begin{verbatim}
    <finder name="G_G" return-type="Collection">
        <finder-column name="groupId" />
        <finder-column name="guestbookId" />
    </finder>
</entity>
\end{verbatim}

  Here, you define a finder that gets guestbook entries by
  \texttt{groupId} and \texttt{guestbookId}. As before, the
  \texttt{groupId} corresponds to the
  \href{/docs/7-1/user/-/knowledge_base/u/building-a-site}{Site} the
  application is on. The \texttt{guestbookId} defines the guestbook the
  entries come from. This finder returns a \texttt{Collection} of
  entries.
\item
  Define your exception types outside the
  \texttt{\textless{}entity\textgreater{}} tags, just before the closing
  \texttt{\textless{}/service-builder\textgreater{}} tag:

\begin{verbatim}
<exceptions>
    <exception>EntryEmail</exception>
    <exception>EntryMessage</exception>
    <exception>EntryName</exception>
    <exception>GuestbookName</exception>
</exceptions>
\end{verbatim}

  These generate exception classes you'll use later in try/catch
  statements.
\item
  Save your \texttt{service.xml} file.
\end{enumerate}

Now you're ready to run Service Builder to generate your model, service,
and persistence layers!

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In the Gradle Tasks pane on the right side of Dev Studio DXP, open
  \texttt{guestbook-service} → \texttt{build}.
\item
  Run \texttt{buildService} by right-clicking it and selecting \emph{Run
  Gradle Tasks}. Make sure you're connected to the Internet, as Gradle
  downloads dependencies the first time you run it.
\item
  In the Project Explorer, right-click the \texttt{guestbook-service}
  module and select \emph{Refresh}. Repeat this step for the
  \texttt{guestbook-api} module. This ensures that the new classes and
  interfaces generated by Service Builder show up in Dev Studio DXP.
\item
  In the Project Explorer, right-click the \texttt{guestbook-service}
  module and select \emph{Gradle} → \emph{Refresh Gradle Project}.
  Repeat this step for the \texttt{guestbook-api} module. This ensures
  that your modules' Gradle dependencies are up to date.
\end{enumerate}

Service Builder is based on a design philosophy called loose coupling.
It generates three layers of your application: the model, the service,
and the persistence layers. Loose coupling means you can swap out the
persistence layer with little to no change in the model and service
layers. The model is in the \texttt{-api} module, and the service and
persistence layers are in the \texttt{-service} module.

\begin{figure}
\centering
\includegraphics{./images/model-service-persistence.png}
\caption{The Model, Service, and Persistence Layer comprise a loose
coupling design.}
\end{figure}

Each layer is implemented using Java Interfaces and implementations of
those interfaces. Rather than have one \texttt{Entry} class that
represents your model, Service Builder generates a system of classes
that include a \texttt{Guestbook} interface, a
\texttt{GuestbookBaseImpl} abstract class that Service Builder manages,
and a \texttt{GuestbookImpl} class that you can customize. This design
lets you customize your model, while Service Builder generates code
that's tedious to write. That's why Service Builder is a code generator
for code generator haters.

Next, you'll create the service implementations.

\section{Implementing Service
Methods}\label{implementing-service-methods}

\begin{verbatim}
<p id="stepTitle">Generating the Back-end</p><p>Step 3 of 3</p>
\end{verbatim}

When you use Service Builder, you implement the services in the service
module. Because your application's projects are
\href{/docs/7-1/tutorials/-/knowledge_base/t/fundamentals\#components}{components},
you can reference your service layer from your web module.

You'll implement services for guestbooks and entries in the
\texttt{guestbook-service} module's \texttt{GuestbookLocalServiceImpl}
and \texttt{EntryLocalServiceImpl}, respectively.

Follow these steps to implement services for guestbooks in
\texttt{GuestbookLocalServiceImpl}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In the \texttt{com.liferay.docs.guestbook.service.impl} package, open
  \texttt{GuestbookLocalServiceImpl}. Then add this
  \texttt{addGuestbook} method:

\begin{verbatim}
public Guestbook addGuestbook(
    long userId, String name, ServiceContext serviceContext)
    throws PortalException {

    long groupId = serviceContext.getScopeGroupId();

    User user = userLocalService.getUserById(userId);

    Date now = new Date();

    validate(name);

    long guestbookId = counterLocalService.increment();

    Guestbook guestbook = guestbookPersistence.create(guestbookId);

    guestbook.setUuid(serviceContext.getUuid());
    guestbook.setUserId(userId);
    guestbook.setGroupId(groupId);
    guestbook.setCompanyId(user.getCompanyId());
    guestbook.setUserName(user.getFullName());
    guestbook.setCreateDate(serviceContext.getCreateDate(now));
    guestbook.setModifiedDate(serviceContext.getModifiedDate(now));
    guestbook.setName(name);
    guestbook.setExpandoBridgeAttributes(serviceContext);

    guestbookPersistence.update(guestbook);

    return guestbook;

}
\end{verbatim}

  This method adds a guestbook to the database. It retrieves metadata
  from the environment (such as the current user's ID, the group ID,
  etc.), along with data passed from the user. It validates this data
  and uses it to construct a \texttt{Guestbook} object. The method then
  persists this object to the database and returns the object. You only
  implement the business logic here because Service Builder already
  generated the model and all the code that maps that model to the
  database.
\item
  Add the methods for getting \texttt{Guestbook} objects:

\begin{verbatim}
public List<Guestbook> getGuestbooks(long groupId) {

    return guestbookPersistence.findByGroupId(groupId);
}

public List<Guestbook> getGuestbooks(long groupId, int start, int end, 
    OrderByComparator<Guestbook> obc) {

    return guestbookPersistence.findByGroupId(groupId, start, end, obc);
}

public List<Guestbook> getGuestbooks(long groupId, int start, int end) {

    return guestbookPersistence.findByGroupId(groupId, start, end);
}

public int getGuestbooksCount(long groupId) {

    return guestbookPersistence.countByGroupId(groupId);
}
\end{verbatim}

  These call the finders you generated with Service Builder. The first
  method retrieves a list of guestbooks from the Site specified by
  \texttt{groupId}. The next two methods get paginated lists, optionally
  in a particular order. The final method gives you the total number of
  guestbooks for a given site.
\item
  Finally, add the guestbook validator method:

\begin{verbatim}
protected void validate(String name) throws PortalException {
    if (Validator.isNull(name)) {
        throw new GuestbookNameException();
    }
}
\end{verbatim}

  This method uses Liferay DXP's \texttt{Validator} to make sure the
  user entered text for the guestbook name.
\item
  Press {[}CTRL{]}+{[}SHIFT{]}+O to organize imports and select the
  following classes when prompted:

  \begin{itemize}
  \tightlist
  \item
    \texttt{java.util.Date}
  \item
    \texttt{com.liferay.portal.kernel.service.ServiceContext}
  \item
    \texttt{com.liferay.docs.guestbook.model.Entry}
  \item
    \texttt{com.liferay.portal.kernel.util.Validator}
  \end{itemize}
\end{enumerate}

Now you're ready to implement services for entries in
\texttt{EntryLocalServiceImpl}. Do so now by following these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In the \texttt{com.liferay.docs.guestbook.service.impl} package, open
  \texttt{EntryLocalServiceImpl}. Add this \texttt{addEntry} method:

\begin{verbatim}
public Entry addEntry(
    long userId, long guestbookId, String name, String email,
    String message, ServiceContext serviceContext)
    throws PortalException {

    long groupId = serviceContext.getScopeGroupId();

    User user = userLocalService.getUserById(userId);

    Date now = new Date();

    validate(name, email, message);

    long entryId = counterLocalService.increment();

    Entry entry = entryPersistence.create(entryId);

    entry.setUuid(serviceContext.getUuid());
    entry.setUserId(userId);
    entry.setGroupId(groupId);
    entry.setCompanyId(user.getCompanyId());
    entry.setUserName(user.getFullName());
    entry.setCreateDate(serviceContext.getCreateDate(now));
    entry.setModifiedDate(serviceContext.getModifiedDate(now));
    entry.setExpandoBridgeAttributes(serviceContext);
    entry.setGuestbookId(guestbookId);
    entry.setName(name);
    entry.setEmail(email);
    entry.setMessage(message);

    entryPersistence.update(entry);

    return entry;
}
\end{verbatim}

  Like the \texttt{addGuestbook} method, \texttt{addEntry} takes data
  from the current context along with data the user entered, validates
  it, and creates a model object. That object is then persisted to the
  database and returned.
\item
  Add this \texttt{updateEntry} method:

\begin{verbatim}
public Entry updateEntry (
    long userId, long guestbookId, long entryId, String name, String email,
    String message, ServiceContext serviceContext)
    throws PortalException, SystemException {

    Date now = new Date();

    validate(name, email, message);

    Entry entry = getEntry(entryId);

    User user = userLocalService.getUserById(userId);

    entry.setUserId(userId);
    entry.setUserName(user.getFullName());
    entry.setModifiedDate(serviceContext.getModifiedDate(now));
    entry.setName(name);
    entry.setEmail(email);
    entry.setMessage(message);
    entry.setExpandoBridgeAttributes(serviceContext);

    entryPersistence.update(entry);

    return entry;
}
\end{verbatim}

  This method first retrieves the entry and updates its data to reflect
  what the user submitted, including its date modified.
\item
  Add this \texttt{deleteEntry} method:

\begin{verbatim}
public Entry deleteEntry (long entryId, ServiceContext serviceContext)
    throws PortalException {

    Entry entry = getEntry(entryId);

    entry = deleteEntry(entryId);

    return entry;
}
\end{verbatim}

  This method retrieves the \texttt{entry} object defined by
  \texttt{entryId}, deletes it from the database, and then returns the
  deleted object.
\item
  Add the methods for getting \texttt{Entry} objects:

\begin{verbatim}
public List<Entry> getEntries(long groupId, long guestbookId) {
    return entryPersistence.findByG_G(groupId, guestbookId);
}

public List<Entry> getEntries(long groupId, long guestbookId, int start, int end)
    throws SystemException {

    return entryPersistence.findByG_G(groupId, guestbookId, start, end);
}

public List<Entry> getEntries(
    long groupId, long guestbookId, int start, int end, OrderByComparator<Entry> obc) {

    return entryPersistence.findByG_G(groupId, guestbookId, start, end, obc);
}

public int getEntriesCount(long groupId, long guestbookId) {
    return entryPersistence.countByG_G(groupId, guestbookId);
}
\end{verbatim}

  These methods, like the getters in \texttt{GuestbookLocalServiceImpl},
  call the finders you generated with Service Builder. These
  \texttt{getEntries*} methods, however, retrieve entries from a
  specified guestbook and Site. The first method gets a list of entries.
  The next method gets a paginated list. The third method sorts the
  paginated list, and the last method gets the total number of entries
  as an integer.
\item
  Add the \texttt{validate} method:

\begin{verbatim}
protected void validate(String name, String email, String entry)
    throws PortalException {

    if (Validator.isNull(name)) {
        throw new EntryNameException();
    }

    if (!Validator.isEmailAddress(email)) {
        throw new EntryEmailException();
    }

    if (Validator.isNull(entry)) {
        throw new EntryMessageException();
    }
}
\end{verbatim}

  This method makes sure the user entered relevant data when creating an
  entry.
\item
  Press {[}CTRL{]}+{[}SHIFT{]}+O to organize imports and select the
  following classes when prompted:

  \begin{itemize}
  \tightlist
  \item
    \texttt{java.util.Date}
  \item
    \texttt{com.liferay.portal.kernel.service.ServiceContext}
  \item
    \texttt{com.liferay.docs.guestbook.model.Entry}
  \item
    \texttt{com.liferay.portal.kernel.util.Validator}
  \end{itemize}
\end{enumerate}

Nice work! These local service methods implement the services that are
referenced in the portlet class.

\subsection{Updating Generated
Classes}\label{updating-generated-classes}

Now that you've implemented the service methods, you must make them
available to the rest of your application. To do this, run
\texttt{buildService} again:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In \emph{Gradle Tasks} → \emph{guestbook-service} → \emph{build},
  right-click \texttt{buildService} and select \emph{Run Gradle Tasks}.
  In the utility classes, Service Builder populates calls to your newly
  created service methods.
\item
  In the Project Explorer, right-click the \texttt{guestbook-service}
  module and select \emph{Refresh}. Repeat this step for the
  \texttt{guestbook-api} module. This ensures that the changes made by
  Service Builder show up in Liferay Dev Studio DXP.
\item
  In the Project Explorer, right-click the \texttt{guestbook-service}
  module and select \emph{Gradle} → \emph{Refresh Gradle Project}.
  Repeat this step for the \texttt{guestbook-api} module. This ensures
  that your modules' Gradle dependencies are up to date.
\end{enumerate}

\noindent\hrulefill

\textbf{Tip:} If something goes awry when working with Service Builder,
repeat these steps to run Service Builder again and refresh your API and
service modules.

\noindent\hrulefill

Excellent! Your new back-end has been generated. Now it's time to
refactor your prototype to use it.

\chapter{Refactoring the Prototype}\label{refactoring-the-prototype}

Earlier, you created a Guestbook portlet prototype. Then you wrote a
\texttt{service.xml} file to define your application's data model, and
used Service Builder to generate the back-end code (the model, service,
and persistence layers). You also added service methods using the
appropriate extension points: your entities' \texttt{*LocalServiceImpl}
classes. Now you must integrate the original prototype with the new
back-end to create a fully functional application.

There are many differences between the prototype and the application
you'll create. In the back-end, you've already accounted for one big
difference: users can create multiple Guestbooks that each have their
own entries. In the front-end, however, only Site administrators should
be able to create guestbooks. Therefore, you'll create another portlet
called Guestbook Admin and place it in the Content menu for Sites.

To turn this application from a prototype into a full-fledged Liferay
web application, you'll make these changes:

\begin{itemize}
\tightlist
\item
  Modify your view layer's folder structure to account for the
  administrative portlet
\item
  Set the Display Category so users can find the application more easily
\item
  Create a file to store the application's text keys
\item
  Change the controller to call your new Service Builder-based back-end
\item
  Update the view so it can display multiple Guestbooks in tabs
\end{itemize}

Ready to begin?

Let's Go!{}

\section{Organizing Folders for Larger
Applications}\label{organizing-folders-for-larger-applications}

\begin{verbatim}
<p id="stepTitle">Refactoring the Prototype</p><p>Step 1 of 6</p>
\end{verbatim}

In larger projects, it is important to have all of your files and
modules well organized. You'll make two changes to help better organize
your project:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Move the \texttt{guestbook-web} module into the \texttt{guestbook}
  folder so that it's in the same place as the
  \texttt{guestbook-service} and \texttt{guestbook-api} modules that you
  created.
\item
  Since you'll now have two portlets, reorganize your JSPs to group them
  by portlet.
\end{enumerate}

\subsection{Moving guestbook-web}\label{moving-guestbook-web}

The best way to move modules around is to use Dev Studio DXP's
\emph{Refactor} function. The refactor function scans for and updates
project dependencies and links.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In the \emph{Project Explorer}, right-click on \texttt{guestbook-web}
  and select \emph{Refactor} → \emph{Move}.
\item
  In the window that appears, click \emph{Browse}, navigate to the
  \texttt{guestbook} folder and then click \emph{New Folder}.
\item
  Name the new folder \texttt{guestbook-web}.
\item
  Click \emph{Open} and then \emph{OK} to confirm.
\end{enumerate}

Your \texttt{guestbook-web} folder now appears in the structure with the
other modules.

\begin{figure}
\centering
\includegraphics{./images/guestbook-refactor.png}
\caption{After you move it using the Refactor function, all of your
modules are in the same folder..}
\end{figure}

\subsection{Reorganizing JSPs}\label{reorganizing-jsps}

Currently, all your JSPs sit in your web module's
\texttt{src/main/resources/META-INF/resources} folder, which serves as
the context root folder. To make a clear separation between the
Guestbook portlet and the Guestbook Admin portlet, you must place the
files that make up their view layers in separate folders:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In the \texttt{guestbook-web} project, right click the
  \texttt{src/main/resources/META-INF/resources} folder and select
  \emph{New} → \emph{Folder}. Name the new folder
  \texttt{guestbookwebportlet} and click \emph{Finish}.
\item
  Copy \texttt{view.jsp} and \texttt{edit\_entry.jsp} into the new
  folder by dragging and dropping them there.
\item
  Open both files and change the \texttt{init.jsp} location at the top
  of the file:

\begin{verbatim}
<%@include file="../init.jsp"%>        
\end{verbatim}
\item
  Check the other references to JSPs within the files to make sure that
  they point to the new locations.
\end{enumerate}

As you update your view layer to take full advantage of the new
back-end, you'll update any references to the old paths. In addition,
you must update the resource location in your component properties. In
the next step, you'll update all of those properties, including the one
that defines the resource location.

\section{Defining the Component Metadata
Properties}\label{defining-the-component-metadata-properties}

\begin{verbatim}
<p id="stepTitle">Refactoring the Prototype</p><p>Step 2 of 6</p>
\end{verbatim}

When users add applications to a page, they pick them from a list of
\emph{display categories}.

\begin{figure}
\centering
\includegraphics{./images/display-categories.png}
\caption{Users choose applications from a list of display categories.}
\end{figure}

A portlet's display category is defined in its component class as a
metadata property. Since the Guestbook portlet lets users communicate
with each other, you'll add it to the Social category. Only one
Guestbook portlet should be added to a page, so you'll also define it as
a \emph{non-instanceable} portlet. Such a portlet can appear only once
on a page or Site, depending on its scope.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open the \texttt{GuestbookPortlet} class and update the component
  class metadata properties to match this configuration:

\begin{verbatim}
@Component(
    immediate = true,
    property = {
      "com.liferay.portlet.display-category=category.social",
      "com.liferay.portlet.instanceable=false",
      "com.liferay.portlet.scopeable=true",
      "javax.portlet.display-name=Guestbook",
      "javax.portlet.expiration-cache=0",
      "javax.portlet.init-param.template-path=/",
      "javax.portlet.init-param.view-template=/guestbookwebportlet/view.jsp",
      "javax.portlet.resource-bundle=content.Language",
      "javax.portlet.security-role-ref=power-user,user",
      "javax.portlet.supports.mime-type=text/html"
    },
    service = Portlet.class
)
\end{verbatim}
\end{enumerate}

The \texttt{com.liferay.portlet.display-category=category.social}
property sets the Guestbook portlet's display category to \emph{Social}.
The \texttt{com.liferay.portlet.instanceable=false} property specifies
that the Guestbook portlet is non-instanceable, so only one instance of
the portlet can be added to a page. In the property
\texttt{javax.portlet.init-param.view-template}, you also update the
location of the main \texttt{view.jsp} to its new location in
\texttt{/guestbookwebportlet}.

Since you edited the portlet's metadata, you must remove and re-add the
portlet to the page before continuing:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Go to \texttt{localhost:8080} in your web browser.
\item
  Sign in to your administrative account.
\item
  The Guestbook portlet now shows an error on the page. Click its
  portlet menu (at the top-right of the portlet), then select
  \emph{Remove} and click \emph{OK} to confirm.
\item
  Open the \emph{Add} menu and select \emph{Applications}.
\item
  Open the \emph{Social} category and drag and drop the \emph{Guestbook}
  application onto the page.
\end{enumerate}

Great! Now the Guestbook portlet appears in an appropriate category.
Though you were able to add it to the page before, the user experience
is better.

\section{Creating Portlet Keys}\label{creating-portlet-keys}

\begin{verbatim}
<p id="stepTitle">Refactoring the Prototype</p><p>Step 3 of 6</p>
\end{verbatim}

\texttt{PortletKeys} manage important things like the portlet name or
other repeatable, commonly used variables in one place. This way, if you
need to change the portlet's name, you can do it in one place, and then
reference it in every class that needs it. Keys must be referenced first
as a component property, and then as a class.

Follow these steps to create your application's \texttt{PortletKeys}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In your \texttt{guestbook-web} module, open the
  \texttt{GuestbookPortlet} class and update the component class
  metadata properties by adding one new property:

\begin{verbatim}
"javax.portlet.name=" + GuestbookPortletKeys.GUESTBOOK,
\end{verbatim}

  Note that you need the trailing comma if you've added the property to
  the middle of the list. If you've added it to the end of the last,
  leave it off (but add a trailing comma to the prior property!).
\item
  Save \texttt{GuestbookPortlet}. It now shows an error because you
  haven't added the key to the class.
\item
  Open the \texttt{com.liferay.docs.guestbook.constants} package.
\item
  Open \texttt{GuestbookPortletKeys} and create a public, static, final
  String called \texttt{GUESTBOOK} with a value of
  \texttt{com\_liferay\_docs\_guestbook\_portlet\_GuestbookPortlet}:

\begin{verbatim}
public static final String GUESTBOOK =
         "com_liferay_docs_guestbook_portlet_GuestbookPortlet";
\end{verbatim}
\item
  Save the file.
\end{enumerate}

Now \texttt{GuestbookPortlet}'s error has disappeared, and your
application can be deployed again. Nice job!

Next, you'll integrate your application with the new back-end you
generated with Service Builder.

\section{Integrating the New
Back-end}\label{integrating-the-new-back-end}

\begin{verbatim}
<p id="stepTitle">Refactoring the Prototype</p><p>Step 4 of 6</p>
\end{verbatim}

It's a good practice to start with a working prototype as a proof of
concept, but eventually that prototype must transform into a real
application. Up to this point, you've made all the preparations to do
that, and now it's time to replace the prototype back-end with the real,
database-driven back-end you created with Service Builder.

For the prototype, you manually created the application's model. The
first thing you want to do is remove it, because Service Builder
generated a new one:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Find the \texttt{com.liferay.docs.guestbook.model} package in the
  \texttt{guestbook-web} module.
\item
  Delete it. You'll see errors in your project, but that's because you
  haven't replaced the model yet.
\end{enumerate}

Now you get to do some dependency management. For the web module to
access the generated services, you must make it aware of the API and
service modules. Then you can update the \texttt{addEntry} method in
\texttt{GuestbookPortlet} to use the new services:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  First, open \texttt{guestbook-web}'s \texttt{build.gradle} file and
  add these dependencies:

\begin{verbatim}
compileOnly project(":modules:guestbook:guestbook-api")
compileOnly project(":modules:guestbook:guestbook-service")
\end{verbatim}
\item
  Right-click on the \texttt{guestbook-web} project and select
  \emph{Gradle} → \emph{Refresh Gradle Project}.
\item
  Now you must add \emph{references} to the Service Builder services you
  need. To do this, add them as class variables with \texttt{@Reference}
  annotations on their setter methods. Open \texttt{GuestbookPortlet}
  and add these references to the bottom of the file:

\begin{verbatim}
    @Reference(unbind = "-")
    protected void setEntryService(EntryLocalService entryLocalService) {
        _entryLocalService = entryLocalService;
    }

    @Reference(unbind = "-")
    protected void setGuestbookService(GuestbookLocalService guestbookLocalService) {
        _guestbookLocalService = guestbookLocalService;
    }

    private EntryLocalService _entryLocalService;
    private GuestbookLocalService _guestbookLocalService;
\end{verbatim}

  Note that it's Liferay's code style to add class variables this way.
  The \texttt{@Reference} annotation on the setters allows Liferay's
  OSGi container to inject references to your generated services so you
  can use them. The \texttt{unbind} parameter tells the container
  there's no method for unbinding these services: the references can die
  with the class during garbage collection when they're no longer
  needed.
\item
  Now you can modify the \texttt{addEntry} method to use these service
  references:

\begin{verbatim}
public void addEntry(ActionRequest request, ActionResponse response)
            throws PortalException {

        ServiceContext serviceContext = ServiceContextFactory.getInstance(
            Entry.class.getName(), request);

        String userName = ParamUtil.getString(request, "name");
        String email = ParamUtil.getString(request, "email");
        String message = ParamUtil.getString(request, "message");
        long guestbookId = ParamUtil.getLong(request, "guestbookId");
        long entryId = ParamUtil.getLong(request, "entryId");

    if (entryId > 0) {

        try {

            _entryLocalService.updateEntry(
                serviceContext.getUserId(), guestbookId, entryId, userName,
                email, message, serviceContext);

            response.setRenderParameter(
                "guestbookId", Long.toString(guestbookId));

        }
        catch (Exception e) {
            System.out.println(e);

            PortalUtil.copyRequestParameters(request, response);

            response.setRenderParameter(
                "mvcPath", "/guestbookwebportlet/edit_entry.jsp");
        }

    }
    else {

        try {
            _entryLocalService.addEntry(
                serviceContext.getUserId(), guestbookId, userName, email,
                message, serviceContext);

            SessionMessages.add(request, "entryAdded");

            response.setRenderParameter(
                "guestbookId", Long.toString(guestbookId));

        }
        catch (Exception e) {
            SessionErrors.add(request, e.getClass().getName());

            PortalUtil.copyRequestParameters(request, response);

            response.setRenderParameter(
                "mvcPath", "/guestbookwebportlet/edit_entry.jsp");
        }
    }
}
\end{verbatim}

  This \texttt{addEntry} method gets the name, message, and email fields
  that the user submits in the JSP and passes them to the service to be
  stored as entry data. The \texttt{if-else} logic checks whether
  there's an existing \texttt{entryId}. If there is, the \texttt{update}
  service method is called, and if not, the \texttt{add} service method
  is called. In both cases, it sets a render parameter with the
  Guestbook ID so the application can display the guestbook's entries
  after this one has been added. This is all done in
  \texttt{try...catch} statements.
\item
  Now add \texttt{deleteEntry}, which you didn't have before:

\begin{verbatim}
public void deleteEntry(ActionRequest request, ActionResponse response) throws PortalException {
        long entryId = ParamUtil.getLong(request, "entryId");
        long guestbookId = ParamUtil.getLong(request, "guestbookId");

        ServiceContext serviceContext = ServiceContextFactory.getInstance(
            Entry.class.getName(), request);

        try {

            response.setRenderParameter(
                "guestbookId", Long.toString(guestbookId));

            _entryLocalService.deleteEntry(entryId, serviceContext);
        }

        catch (Exception e) {
            Logger.getLogger(GuestbookPortlet.class.getName()).log(
                Level.SEVERE, null, e);
        }
}
\end{verbatim}

  This method retrieves the entry object (using its ID from the request)
  and calls the service to delete it.
\item
  Next you must replace the \texttt{render} method:

\begin{verbatim}
@Override
public void render(RenderRequest renderRequest, RenderResponse renderResponse)
        throws IOException, PortletException {

        try {
            ServiceContext serviceContext = ServiceContextFactory.getInstance(
                Guestbook.class.getName(), renderRequest);

            long groupId = serviceContext.getScopeGroupId();

            long guestbookId = ParamUtil.getLong(renderRequest, "guestbookId");

            List<Guestbook> guestbooks = _guestbookLocalService.getGuestbooks(
                groupId);

            if (guestbooks.isEmpty()) {
                Guestbook guestbook = _guestbookLocalService.addGuestbook(
                    serviceContext.getUserId(), "Main", serviceContext);

                guestbookId = guestbook.getGuestbookId();
            }

            if (guestbookId == 0) {
                guestbookId = guestbooks.get(0).getGuestbookId();
            }

            renderRequest.setAttribute("guestbookId", guestbookId);
        }
        catch (Exception e) {
            throw new PortletException(e);
        }

        super.render(renderRequest, renderResponse);
}
\end{verbatim}

  This new \texttt{render} method checks for any guestbooks in the
  current Site. If there aren't any, it creates one. Either way, it
  grabs the first guestbook so its entries can be displayed by your view
  layer.
\item
  Remove the \texttt{parseEntries} method. It's a remnant of the
  prototype application.
\item
  Hit Ctrl-Shift-O to organize your imports.
\end{enumerate}

Awesome! You've updated your controller to use services. Next, you'll
tackle the view.

\section{Updating the View}\label{updating-the-view}

\begin{verbatim}
<p id="stepTitle">Refactoring the Prototype</p><p>Step 5 of 6</p>
\end{verbatim}

You updated more than just the mechanism behind creating entries: you
completely changed the method and structure. You must, therefore, update
the UI as well. To do that, you must create a new JSP for managing
guestbooks and update the existing JSPs.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  First, you must update your dependencies. In your
  \texttt{guestbook-web} module, open \texttt{init.jsp} from
  \texttt{/src/main/resources/META-INF/resources/}. In this file, add
  the following additional dependencies:

\begin{verbatim}
<%@ taglib uri="http://liferay.com/tld/frontend" prefix="liferay-frontend" %>
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %>
<%@ taglib uri="http://liferay.com/tld/security" prefix="liferay-security" %>
<%@ page import="java.util.List" %>
<%@ page import="com.liferay.portal.kernel.util.ParamUtil" %>
<%@ page import="com.liferay.portal.kernel.util.HtmlUtil" %>
<%@ page import="com.liferay.petra.string.StringPool" %>
<%@ page import="com.liferay.portal.kernel.model.PersistedModel" %>
<%@ page import="com.liferay.portal.kernel.dao.search.SearchEntry" %>
<%@ page import="com.liferay.portal.kernel.dao.search.ResultRow" %>
<%@ page import="com.liferay.docs.guestbook.model.Guestbook" %>
<%@ page import="com.liferay.docs.guestbook.service.EntryLocalServiceUtil" %>
<%@ page import="com.liferay.docs.guestbook.service.GuestbookLocalServiceUtil" %>
<%@ page import="com.liferay.docs.guestbook.model.Entry" %> 
\end{verbatim}
\item
  Open the \texttt{view.jsp} file found in
  \texttt{/resources/META-INF/resources/guestbookwebportlet}. Replace
  this file's contents with the following code:

\begin{verbatim}
<%@include file="../init.jsp"%>

<%
long guestbookId = Long.valueOf((Long) renderRequest
        .getAttribute("guestbookId"));
%>

<aui:button-row cssClass="guestbook-buttons">

    <portlet:renderURL var="addEntryURL">
        <portlet:param name="mvcPath" value="/guestbookwebportlet/edit_entry.jsp" />
        <portlet:param name="guestbookId"
            value="<%=String.valueOf(guestbookId)%>" />
    </portlet:renderURL>

    <aui:button onClick="<%=addEntryURL.toString()%>" value="Add Entry"></aui:button>

</aui:button-row>

<liferay-ui:search-container total="<%=EntryLocalServiceUtil.getEntriesCount()%>">
<liferay-ui:search-container-results
    results="<%=EntryLocalServiceUtil.getEntries(scopeGroupId.longValue(),
                    guestbookId, searchContainer.getStart(),
                    searchContainer.getEnd())%>" />

<liferay-ui:search-container-row
    className="com.liferay.docs.guestbook.model.Entry" modelVar="entry">

    <liferay-ui:search-container-column-text property="message" />

    <liferay-ui:search-container-column-text property="name" />

</liferay-ui:search-container-row>

<liferay-ui:search-iterator />

</liferay-ui:search-container>
\end{verbatim}
\end{enumerate}

This \texttt{view.jsp} now retrieves the entries from the guestbook it
gets from the \texttt{render} method. It does this inside a Liferay DXP
construct called a \emph{Search Container}. This is a front-end
component that makes it easy to display data in rows and columns. The
\texttt{EntryLocalServiceUtil} call retrieves the data from your new
Service Builder-based back-end. Otherwise, this JSP is much the same:
you still have an \emph{Add Entry} button with its corresponding URL.

Next, you need to edit the \texttt{edit\_entry.jsp}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open \texttt{edit\_entry.jsp} and replace the existing code with this:

\begin{verbatim}
<%@include file="../init.jsp" %>

<% 

long entryId = ParamUtil.getLong(renderRequest, "entryId");

Entry entry = null;
if (entryId > 0) {
  entry = EntryLocalServiceUtil.getEntry(entryId);
}

long guestbookId = ParamUtil.getLong(renderRequest, "guestbookId");

%>

<portlet:renderURL var="viewURL">

<portlet:param name="mvcPath" value="/guestbookwebportlet/view.jsp"></portlet:param>

</portlet:renderURL>

<portlet:actionURL name="addEntry" var="addEntryURL"></portlet:actionURL>

<aui:form action="<%= addEntryURL %>" name="<portlet:namespace />fm">

<aui:model-context bean="<%= entry %>" model="<%= Entry.class %>" />

    <aui:fieldset>

        <aui:input name="name" />
        <aui:input name="email" />
        <aui:input name="message" />
        <aui:input name="entryId" type="hidden" />
        <aui:input name="guestbookId" type="hidden" value='<%= entry == null ? guestbookId : entry.getGuestbookId() %>'/>

    </aui:fieldset>

    <aui:button-row>

        <aui:button type="submit"></aui:button>
        <aui:button type="cancel" onClick="<%= viewURL.toString() %>"></aui:button>

    </aui:button-row>
</aui:form>
\end{verbatim}

  This is much the same form, though there are more fields now. Using
  some AlloyUI tags, the form is linked to your \texttt{Entry} entity.
  The two hidden fields contain the new \texttt{entryId} and the
  \texttt{guestbookId} for the guestbook the new entry belongs to. The
  submit button is an \texttt{ActionURL} that executes the
  \texttt{addEntry} method in the controller (your portlet class).
\end{enumerate}

Congratulations! You've now successfully replaced your prototype
back-end with a real, database-driven back-end. Next, you'll do a quick
review and deploy your application.

\section{Fitting it All Together}\label{fitting-it-all-together}

\begin{verbatim}
<p id="stepTitle">Refactoring the Prototype</p><p>Step 6 of 6</p>
\end{verbatim}

You've created a complete data-driven application from the back-end to
the display. It's a great time to review how everything connects
together.

\subsection{The Entry}\label{the-entry}

First, you defined your model in Service Builder's configuration file,
\texttt{service.xml}. The main part of this is your \texttt{Entry}
object:

\begin{verbatim}
<entity local-service="true" name="Entry" uuid="true">

    <!-- PK fields -->

    <column name="entryId" primary="true" type="long" />

    <!-- Group instance -->

    <column name="groupId" type="long" />

    <!-- Audit fields -->

    <column name="companyId" type="long" />
    <column name="userId" type="long" />
    <column name="userName" type="String" />
    <column name="createDate" type="Date" />
    <column name="modifiedDate" type="Date" />
    <column name="name" type="String" />
    <column name="email" type="String" />
    <column name="message" type="String" />
    <column name="guestbookId" type="long" />

    <finder name="G_G" return-type="Collection">
        <finder-column name="groupId" />
        <finder-column name="guestbookId" />
    </finder>
</entity>
\end{verbatim}

Next, you created a service implementation in
\texttt{EntryLocalServiceImpl} that defined how to get and store the
entry. Every field you defined was accounted for in the
\texttt{addEntry} method.

\begin{verbatim}
public Entry addEntry(long userId, long guestbookId, String name, String email,
        String message, ServiceContext serviceContext)
        throws PortalException {

        long groupId = serviceContext.getScopeGroupId();

        User user = userLocalService.getUserById(userId);

        Date now = new Date();

        validate(name, email, message);

        long entryId = counterLocalService.increment();

        Entry entry = entryPersistence.create(entryId);

        entry.setUuid(serviceContext.getUuid());
        entry.setUserId(userId);
        entry.setGroupId(groupId);
        entry.setCompanyId(user.getCompanyId());
        entry.setUserName(user.getFullName());
        entry.setCreateDate(serviceContext.getCreateDate(now));
        entry.setModifiedDate(serviceContext.getModifiedDate(now));
        entry.setExpandoBridgeAttributes(serviceContext);
        entry.setGuestbookId(guestbookId);
        entry.setName(name);
        entry.setEmail(email);
        entry.setMessage(message);
    
        entryPersistence.update(entry);

        return entry;
}
\end{verbatim}

Notice that all the fields you described in Service Builder (including
things like the \texttt{uuid}) are present here.

You also added ways to get entries:

\begin{verbatim}
    public List<Entry> getEntries(long groupId, long guestbookId) {
        return entryPersistence.findByG_G(groupId, guestbookId);
    }

    public List<Entry> getEntries(
        long groupId, long guestbookId, int start, int end, OrderByComparator<Entry> obc) {

        return entryPersistence.findByG_G(groupId, guestbookId, start, end, obc);
    }

    public List<Entry> getEntries(long groupId, long guestbookId, int start, int end)
        throws SystemException {

        return entryPersistence.findByG_G(groupId, guestbookId, start, end);
    }
\end{verbatim}

In \texttt{service.xml} you defined \texttt{groupId} and
\texttt{guestbookId} as the two finder fields, and in these methods you
called methods generated to the persistence layer.

After you implemented all that, Service Builder propagated your
implementation to the interfaces, so they could be called. Then, in the
portlet class, you created references to the service classes that
Service Builder generated, and used those references to access the
service to add an entry:

\begin{verbatim}
_entryLocalService.addEntry( serviceContext.getUserId(), guestbookId, 
    userName, email,message, serviceContext);
\end{verbatim}

Finally, you wrapped all this up in a user interface that lets users
enter the information they want, and displays the data they've entered.

Now that you've built the application, and you can see a clear picture
of how it all works, it's time to test it.

\subsection{Deploying and Testing the
Application}\label{deploying-and-testing-the-application}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Drag and drop the \texttt{guestbook-api} module onto the server.
\item
  Drag and drop the \texttt{guestbook-service} module onto the server.
\item
  Look for the STARTED messages from the console.
\item
  Go to your Liferay DXP instance at \texttt{localhost:8080} in your
  browser to test your updated application.
\item
  Click \emph{Add Entry}.
\item
  Enter a \emph{Name}, \emph{Message}, and \emph{Email Address}.
\item
  Click \emph{Submit}.
\item
  Verify that your entry appears.
\end{enumerate}

\begin{figure}
\centering
\includegraphics{./images/guestbook-entry-test.png}
\caption{Your first guestbook and entry appears. Nice job!}
\end{figure}

\subsection{What's Next?}\label{whats-next}

You've created a working web application and deployed it on Liferay DXP.
If you've created web applications before, though, you know that it's
missing some important features: security, front-end validation, and an
interface for administrators to create multiple guestbooks per portlet.
In the next section, you'll begin adding these features.

\chapter{Writing an Administrative
Portlet}\label{writing-an-administrative-portlet}

Like the prototype, the real application lets users add and view
guestbook entries. The application's back-end, however, is much more
powerful. It can support many guestbooks and their associated entries.
Despite this, there's no UI to support these added features. When you
create this UI, you must also make sure that only administrators can add
guestbooks.

To accomplish this, you must create a Guestbook Admin portlet and place
it in Liferay DXP's administrative interface---specifically, within the
Content menu. This way, the Guestbook Admin portlet is accessible only
to Site Administrators, and users can use the Guestbook portlet to
create entries.

In short, this is a simple application with a simple interface:

\begin{figure}
\centering
\includegraphics{./images/admin-app-start.png}
\caption{The Guestbook Admin portlet lets administrators manage
Guestbooks.}
\end{figure}

Are you ready to begin?

Let's Go!{}

\section{Creating the Classes}\label{creating-the-classes}

\begin{verbatim}
<p id="stepTitle">Writing the Guestbook Admin App</p><p>Step 1 of 5</p>
\end{verbatim}

Because the Guestbook and Guestbook Admin applications should be bundled
together, you'll create the new application manually inside the
\texttt{guestbook-web} project, rather than by using a wizard. If you
disagree with this design decision, you can create a separate project
for Guestbook Admin; the project template you'd use is \emph{panel-app}.
For now, however, it's better to go through the process manually to
learn how it all works:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Right-click the \texttt{com.liferay.docs.guestbook.portlet} package in
  the \texttt{guestbook-web} project and select \emph{New} →
  \emph{Class}.
\item
  Name the class \texttt{GuestbookAdminPortlet}.
\item
  Click \emph{Browse} next to the Superclass and search for
  \texttt{MVCPortlet}. Click it and select \emph{OK}.
\item
  Click \emph{Finish}.
\end{enumerate}

You now have your Guestbook Admin application's portlet class. For an
administrative application, however, you need at least one more
component.

\subsection{Panels and Categories}\label{panels-and-categories}

As described in the
\href{/docs/7-1/tutorials/-/knowledge_base/t/customizing-the-product-menu}{product
menu tutorial}, there are three sections of the product menu as
illustrated below.

\begin{figure}
\centering
\includegraphics{./images/product-menu-parts.png}
\caption{The product menu is split into three sections: the Control
Panel, the User menu, and the Sites menu.}
\end{figure}

Each section is called a \emph{panel category}. A panel category can
hold various menu items called \emph{panel apps}. In the illustration
above, the Sites menu is open to reveal its panel apps and categories
(yes, you can nest them).

The most natural place for the Guestbook Admin portlet is in the
\emph{Content} panel category with Liferay DXP's other content-based
apps. This integrates it nicely in the spot where Site administrators
expect it to be. This also means you don't have to create a new category
for it: you can just create the panel entry, which is what you'll do
next. If you'd like to learn more about panel categories and apps after
this, see the
\href{/docs/7-1/tutorials/-/knowledge_base/t/customizing-the-product-menu}{product
menu tutorial} and the
\href{/docs/7-1/tutorials/-/knowledge_base/t/customizing-the-control-menu}{control
menu tutorial}.

Follow these steps to create the panel entry for the Guestbook Admin
portlet:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add the dependency you need to extend Liferay DXP's panel categories
  and apps. To do this, open \texttt{guestbook-web}'s
  \texttt{build.gradle} file and add this dependency:

\begin{verbatim}
compileOnly group: "com.liferay", name: "com.liferay.application.list.api", version: "2.0.0"
\end{verbatim}
\item
  Right-click \texttt{guestbook-web} and select \emph{Gradle} →
  \emph{Refresh Gradle Project}.
\item
  Right-click \texttt{src/main/java} in the \texttt{guestbook-web}
  project and select \emph{New} → \emph{Package}. Name the package
  \texttt{com.liferay.docs.guestbook.application.list} and click
  \emph{Finish}.
\item
  Right-click your new package and select \emph{New} → \emph{Class}.
  Name the class \texttt{GuestbookAdminPanelApp}.
\item
  Click \emph{Browse} next to Superclass, search for
  \texttt{BasePanelApp}, select it, and click \emph{OK}. Then click
  \emph{Finish}.
\end{enumerate}

Great! You've created the classes you need, and you're ready to begin
working on them.

\section{Adding Metadata}\label{adding-metadata}

\begin{verbatim}
<p id="stepTitle">Writing the Guestbook Admin App</p><p>Step 2 of 5</p>
\end{verbatim}

Now that you've generated the classes, you must turn them into OSGi
components. Remember that because components are container-managed
objects, you must provide metadata that tells Liferay DXP's OSGi
container how to manage their life cycles.

Follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add the following portlet key to the \texttt{GuestbookPortletKeys}
  class:

\begin{verbatim}
public static final String GUESTBOOK_ADMIN =
  "com_liferay_docs_guestbook_portlet_GuestbookAdminPortlet";
\end{verbatim}
\item
  Open the \texttt{GuestbookAdminPortlet} class and add the
  \texttt{@Component} annotation immediately above the class
  declaration:

\begin{verbatim}
@Component(
    immediate = true,
    property = {
            "com.liferay.portlet.display-category=category.hidden",
            "com.liferay.portlet.scopeable=true",
            "javax.portlet.display-name=Guestbooks",
            "javax.portlet.expiration-cache=0",
            "javax.portlet.init-param.portlet-title-based-navigation=true",
            "javax.portlet.init-param.template-path=/",
            "javax.portlet.init-param.view-template=/guestbookadminportlet/view.jsp",
            "javax.portlet.name=" + GuestbookPortletKeys.GUESTBOOK_ADMIN,
            "javax.portlet.resource-bundle=content.Language",
            "javax.portlet.security-role-ref=administrator",
            "javax.portlet.supports.mime-type=text/html",
            "com.liferay.portlet.add-default-resource=true"
    },
    service = Portlet.class
)
\end{verbatim}
\item
  Hit {[}CTRL{]}+{[}SHIFT{]}+O to add the \texttt{javax.portlet.Portlet}
  and other imports.
\end{enumerate}

There are only a few new things here. Note the value of the
\texttt{javax.portlet.display-name} property: \texttt{Guestbooks}. This
is the name that appears in the Site menu. Also note the value of the
\texttt{javax.portlet.name} property:
\texttt{+\ GuestbookPortletKeys.GUESTBOOK\_ADMIN}. This specifies the
portlet's title via the \texttt{GUESTBOOK\_ADMIN} portlet key that you
just created.

Pay special attention to the following metadata property:

\begin{verbatim}
com.liferay.portlet.display-category=category.hidden
\end{verbatim}

This is the same property you used before with the Guestbook portlet.
You placed that portlet in the Social category. The value
\texttt{category.hidden} specifies a special category that doesn't
appear anywhere. You're putting the Guestbook Admin portlet here because
it'll be part of the Site menu, and you don't want users adding it to a
page. This prevents them from doing that.

Next, you can configure the Panel app class. Follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open the \texttt{GuestbookAdminPanelApp} class and add the
  \texttt{@Component} annotation immediately above the class
  declaration:

\begin{verbatim}
@Component(
    immediate = true,
    property = {
        "panel.app.order:Integer=300",
        "panel.category.key=" + PanelCategoryKeys.SITE_ADMINISTRATION_CONTENT
    },
    service = PanelApp.class
)
\end{verbatim}

  The \texttt{panel.category.key} metadata property determines where to
  place the Guestbook Admin portlet in the Product Menu. Remember that
  the Product Menu is divided into three main sections: the Control
  Panel, the User Menu, and the Site Administration area. The value of
  the \texttt{panel.category.key} property is
  \texttt{PanelCategoryKeys.SITE\_ADMINISTRATION\_CONTENT}, which means
  Guestbook Admin is in \emph{Site Administration} → \emph{Content}. The
  key is provided by
  \href{https://github.com/liferay/liferay-portal/blob/7.1.x/modules/apps/application-list/application-list-api/src/main/java/com/liferay/application/list/constants/PanelCategoryKeys.java}{the
  \texttt{PanelCategoryKeys} class}. The \texttt{panel.app.order} value
  determines the rank for the Guestbook Admin portlet in the list.
\item
  Finally, update the class to use the proper name and portlet keys:

\begin{verbatim}
public class GuestbookAdminPanelApp extends BasePanelApp {

    @Override
    public String getPortletId() {
        return GuestbookPortletKeys.GUESTBOOK_ADMIN;
    }

    @Override
    @Reference(
        target = "(javax.portlet.name=" + GuestbookPortletKeys.GUESTBOOK_ADMIN + ")",
        unbind = "-"
    )
    public void setPortlet(Portlet portlet) {
        super.setPortlet(portlet);
    }

}
\end{verbatim}
\item
  Hit {[}CTRL{]}+{[}SHIFT{]}+O to organize imports. This time, import
  \texttt{com.liferay.portal.kernel.model.Portlet} instead of
  \texttt{javax.portlet.Portlet}.
\end{enumerate}

Now that the configuration is out of the way, you're free to implement
the app's functionality: adding, editing, and deleting guestbooks.
That's the next step.

\section{Updating Your Service Layer}\label{updating-your-service-layer}

\begin{verbatim}
<p id="stepTitle">Writing the Guestbook Admin App</p><p>Step 3 of 5</p>
\end{verbatim}

In an earlier section, you wrote an \texttt{addGuestbook} service method
in \texttt{GuestbookLocalServiceImpl}, but you never used it. To have
full functionality over guestbooks, you must also add methods for
updating and deleting guestbooks, as well as for returning the number of
guestbooks in a Site.

\subsection{Adding Guestbook Service
Methods}\label{adding-guestbook-service-methods}

Remember that when working with Service Builder, you define your service
in the \texttt{*Impl} classes. After you add, remove a method, or change
the signature of a method in an \texttt{*Impl} class, you must run
Service Builder. Service Builder updates the affected interfaces and any
other generated code.

Follow these steps to add the required guestbook service methods:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Go to the \texttt{guestbook-service} project and open
  \texttt{GuestbookLocalServiceImpl.java} in the
  \texttt{com.liferay.docs.guestbook.service.impl} package. Add the
  following method for updating a guestbook:

\begin{verbatim}
public Guestbook updateGuestbook(long userId, long guestbookId,
    String name, ServiceContext serviceContext) throws PortalException,
                SystemException {

        Date now = new Date();

        validate(name);

        Guestbook guestbook = getGuestbook(guestbookId);

        User user = userLocalService.getUser(userId);

        guestbook.setUserId(userId);
        guestbook.setUserName(user.getFullName());
        guestbook.setModifiedDate(serviceContext.getModifiedDate(now));
        guestbook.setName(name);
        guestbook.setExpandoBridgeAttributes(serviceContext);

        guestbookPersistence.update(guestbook);

        return guestbook;
}
\end{verbatim}

  The \texttt{updateGuestbook} method retrieves the \texttt{Guestbook}
  by its ID, replaces its data with what the user entered, and then
  calls the persistence layer to save it back to the database.
\item
  Next, add the following method for deleting a guestbook:

\begin{verbatim}
public Guestbook deleteGuestbook(long guestbookId,
                ServiceContext serviceContext) throws PortalException,
                SystemException {

        Guestbook guestbook = getGuestbook(guestbookId);

        List<Entry> entries = entryLocalService.getEntries(
                        serviceContext.getScopeGroupId(), guestbookId);

        for (Entry entry : entries) {
                entryLocalService.deleteEntry(entry.getEntryId());
        }

        guestbook = deleteGuestbook(guestbook);

        return guestbook;
}
\end{verbatim}

  It's important to consider what should happen if you delete a
  guestbook that has existing entries. If you just deleted the
  guestbook, the guestbook's entries would still exist in the database,
  but they'd be orphaned. Your \texttt{deleteGuestbook} service method
  makes a service call to delete a guestbook's entries before deleting
  that guestbook. This way, guestbook entries are never orphaned.
\item
  Use {[}CTRL{]}+{[}SHIFT{]}+O to update your imports, then save
  \texttt{GuestbookLocalServiceImpl.java}.
\item
  In the Gradle Tasks pane on the right side in Liferay Dev Studio DXP,
  run Service Builder by opening the \texttt{guestbook-service} module
  and double-clicking \texttt{buildService}.
\end{enumerate}

Now that you've finished updating the service layer, it's time to work
on the Guestbook Admin portlet itself.

\section{Defining Portlet Actions}\label{defining-portlet-actions}

\begin{verbatim}
<p id="stepTitle">Writing the Guestbook Admin App</p><p>Step 4 of 5</p>
\end{verbatim}

The Guestbook Admin portlet now needs action methods for adding,
updating, and deleting guestbooks. As with the Guestbook portlet, action
methods call the corresponding service methods. Note that since your
services and applications are all running in the same container, any
application can call the Guestbook services. This is an advantage of
Liferay DXP's OSGi-based architecture: different applications or modules
can call services published by other modules. If a service is published,
it can be used via \texttt{@Reference}. You'll take advantage of this
here in the Guestbook Admin portlet to consume one of the same services
consumed by the Guestbook portlet (the \texttt{addGuestbook} service).

\subsection{Adding Three Portlet
Actions}\label{adding-three-portlet-actions}

The Guestbook Admin portlet must let administrators add, update, and
delete \texttt{Guestbook} objects. You'll create portlet actions to meet
these requirements. Open \texttt{GuestbookAdminPortlet.java} and follow
these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add the following action method and instance variables needed for
  adding a new guestbook:

\begin{verbatim}
public void addGuestbook(ActionRequest request, ActionResponse response)
    throws PortalException {

    ServiceContext serviceContext = ServiceContextFactory.getInstance(
        Guestbook.class.getName(), request);

    String name = ParamUtil.getString(request, "name");

    try {
        _guestbookLocalService.addGuestbook(
            serviceContext.getUserId(), name, serviceContext);
    }
    catch (PortalException pe) {

        Logger.getLogger(GuestbookAdminPortlet.class.getName()).log(
            Level.SEVERE, null, pe);

        response.setRenderParameter(
            "mvcPath", "/guestbookadminportlet/edit_guestbook.jsp");
    }
}

private GuestbookLocalService _guestbookLocalService;

@Reference(unbind = "-")
protected void setGuestbookService(GuestbookLocalService guestbookLocalService) {
    _guestbookLocalService = guestbookLocalService;
}
\end{verbatim}

  Since \texttt{addGuestbook} is a portlet action method, it takes
  \texttt{ActionRequest} and \texttt{ActionResponse} parameters. To make
  the service call to add a new guestbook, the guestbook's name must be
  retrieved from the request. The \texttt{serviceContext} must also be
  retrieved from the request and passed as an argument in the service
  call. If an exception is thrown, you should display the Add Guestbook
  form and not the default view. That's why you add this line in the
  \texttt{catch} block:

\begin{verbatim}
response.setRenderParameter("mvcPath",
        "/guestbookadminportlet/edit_guestbook.jsp");
\end{verbatim}

  Later, you'll use this for field validation and to show error messages
  to the user. Note that
  \texttt{/guestbookadminportlet/edit\_guestbook.jsp} doesn't exist yet;
  you'll create it in the next section when you're designing the
  Guestbook Admin portlet's user interface.
\item
  Add the following action method for updating an existing guestbook:

\begin{verbatim}
public void updateGuestbook(ActionRequest request, ActionResponse response)
    throws PortalException {

    ServiceContext serviceContext = ServiceContextFactory.getInstance(
        Guestbook.class.getName(), request);

    String name = ParamUtil.getString(request, "name");
    long guestbookId = ParamUtil.getLong(request, "guestbookId");

    try {
        _guestbookLocalService.updateGuestbook(
            serviceContext.getUserId(), guestbookId, name, serviceContext);

    } catch (PortalException pe) {

        Logger.getLogger(GuestbookAdminPortlet.class.getName()).log(
            Level.SEVERE, null, pe);

        response.setRenderParameter(
            "mvcPath", "/guestbookadminportlet/edit_guestbook.jsp");
    }
}
\end{verbatim}

  This method retrieves the guestbook name, ID, and the
  \texttt{serviceContext} from the request. The \texttt{updateGuestbook}
  service call uses the guestbook's ID to identify the guestbook to
  update. If there's a problem with the service call, the Guestbook
  Admin portlet displays the Edit Guestbook form again so that the user
  can edit the form and resubmit:

\begin{verbatim}
response.setRenderParameter("mvcPath",
        "/guestbookadminportlet/edit_guestbook.jsp");
\end{verbatim}

  Note that the Edit Guestbook form uses the same JSP as the Add
  Guestbook form to avoid duplication of code.
\item
  Add the following action method for deleting a guestbook:

\begin{verbatim}
public void deleteGuestbook(ActionRequest request, ActionResponse response)
    throws PortalException {

    ServiceContext serviceContext = ServiceContextFactory.getInstance(
        Guestbook.class.getName(), request);

    long guestbookId = ParamUtil.getLong(request, "guestbookId");

    try {
        _guestbookLocalService.deleteGuestbook(guestbookId, serviceContext);
    }
    catch (PortalException pe) {

        Logger.getLogger(GuestbookAdminPortlet.class.getName()).log(
            Level.SEVERE, null, pe);
    }
}
\end{verbatim}

  This method uses the service layer to delete the guestbook by its ID.
  Since the \texttt{deleteGuestbook} action is invoked from the
  Guestbook Admin portlet's default view, there's no need to set the
  \texttt{mvcPath} render parameter to point to a particular JSP if
  there was a problem with the \texttt{deleteGuestbook} service call.
\item
  Hit {[}CTRL{]}+{[}SHIFT{]}+O to organize imports. Save the file.
\end{enumerate}

You now have your service methods and portlet action methods in place.
Your last task is to implement the Guestbook Admin portlet's user
interface.

\section{Creating a User Interface}\label{creating-a-user-interface}

\begin{verbatim}
<p id="stepTitle">Writing the Guestbook Admin App</p><p>Step 5 of 5</p>
\end{verbatim}

It's time to create the Guestbook Admin portlet's user interface. The
portlet's default view has a button for adding new guestbooks. It must
also display the guestbooks that already exist.

Each guestbook's name is displayed along with an Actions button. The
Actions button reveals options for editing the guestbook, configuring
its permissions, or deleting it.

\subsection{Creating JSPs for the Guestbook Admin Portlet's User
Interface}\label{creating-jsps-for-the-guestbook-admin-portlets-user-interface}

The Guestbook Admin portlet's user interface is made up of three JSPs:
the default view, the Actions button, and the form for adding or editing
a guestbook.

Create the default view first:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a folder for the Guestbook Admin portlet's JSPs. In
  \texttt{src/main/resources/META-INF/resources}, create a folder called
  \texttt{guestbookadminportlet}.
\item
  Create a file in this folder called \texttt{view.jsp} and fill it with
  this code:

\begin{verbatim}
<%@include file="../init.jsp"%>

<liferay-ui:search-container
    total="<%= GuestbookLocalServiceUtil.getGuestbooksCount(scopeGroupId) %>">
    <liferay-ui:search-container-results
        results="<%= GuestbookLocalServiceUtil.getGuestbooks(scopeGroupId, 
            searchContainer.getStart(), searchContainer.getEnd()) %>" />

    <liferay-ui:search-container-row
        className="com.liferay.docs.guestbook.model.Guestbook" modelVar="guestbook">

        <liferay-ui:search-container-column-text property="name" />

        <liferay-ui:search-container-column-jsp
            align="right" 
            path="/guestbookadminportlet/guestbook_actions.jsp" />

    </liferay-ui:search-container-row>

    <liferay-ui:search-iterator />
</liferay-ui:search-container>

<aui:button-row cssClass="guestbook-admin-buttons">
    <portlet:renderURL var="addGuestbookURL">
        <portlet:param name="mvcPath"
            value="/guestbookadminportlet/edit_guestbook.jsp" />
        <portlet:param name="redirect" value="<%= "currentURL" %>" />
    </portlet:renderURL>

    <aui:button onClick="<%= addGuestbookURL.toString() %>"
        value="Add Guestbook" />
</aui:button-row>
\end{verbatim}

  First is the standard \texttt{init.jsp} include to gain access to the
  imports.

  Next is a button row with a single button for adding new guestbooks:
  \texttt{\textless{}aui:button-row\ cssClass="guestbook-admin-buttons"\textgreater{}}.
  The \texttt{cssClass} attribute lets you specify a custom CSS class
  for additional styling. The
  \texttt{\textless{}portlet:renderURL\textgreater{}} tag constructs a
  URL that points to the \texttt{edit\_guestbook.jsp}. You haven't
  created this JSP yet, but you'll use it for adding a new guestbook and
  editing an existing one.

  Finally, a Liferay search container is used to display the list of
  guestbooks. Three sub-tags define the search container:

  \begin{itemize}
  \tightlist
  \item
    \texttt{\textless{}liferay-ui:search-container-results\textgreater{}}
  \item
    \texttt{\textless{}liferay-ui:search-container-row\textgreater{}}
  \item
    \texttt{\textless{}liferay-ui:search-iterator\textgreater{}}
  \end{itemize}

  The
  \texttt{\textless{}liferay-ui:search-container-results\textgreater{}}
  tag's \texttt{results} attribute uses a service call to retrieve the
  guestbooks in the scope. The \texttt{total} attribute uses another
  service call to get a count of guestbooks.

  The \texttt{\textless{}liferay-ui:search-container-row\textgreater{}}
  tag defines what rows contain. In this case, the \texttt{className}
  attribute defines \texttt{com.liferay.docs.guestbook.model.Guestbook}.
  The \texttt{modelVar} attribute defines \texttt{guestbook} as the
  variable for the currently iterated guestbook. In the search container
  row, two columns are defined. The
  \texttt{\textless{}liferay-ui:search-container-column-text\ property="name"\ /\textgreater{}}
  tag specifies the first column. This tag displays text. Its
  \texttt{property="name"} attribute specifies that the text to be
  displayed is the current guestbook object's \texttt{name} attribute.
  The tag \texttt{\textless{}liferay-ui:search-container-column-jsp}
  \texttt{path="/guestbookadminportlet/guestbook\_actions.jsp"\ align="right"\ /\textgreater{}}
  specifies the second (and last) column. This tag includes another JSP
  file within a search container column. Its \texttt{path} attribute
  specifies the path to the JSP file that should be displayed:
  \texttt{guestbook\_actions.jsp}.

  Finally, the
  \texttt{\textless{}liferay-ui:search-iterator\ /\textgreater{}} tag
  iterates through and displays the list of guestbooks. Using Liferay's
  search container makes the Guestbook Admin portlet look like a native
  Liferay DXP portlet. It also provides built-in pagination so that your
  portlet can automatically display large numbers of guestbooks on one
  Site.

  Your next step is to add the \texttt{guestbook\_actions.jsp} file that
  displays the list of possible actions for each guestbook.
\item
  Create a new file called \texttt{guestbook\_actions.jsp} in your
  project's \texttt{/guestbookadminportlet} folder. Paste in this code:

\begin{verbatim}
<%@include file="../init.jsp"%>

<%
    String mvcPath = ParamUtil.getString(request, "mvcPath");

    ResultRow row = (ResultRow) request
                    .getAttribute("SEARCH_CONTAINER_RESULT_ROW");

    Guestbook guestbook = (Guestbook) row.getObject();
%>

<liferay-ui:icon-menu>

    <portlet:renderURL var="editURL">
        <portlet:param name="guestbookId"
            value="<%=String.valueOf(guestbook.getGuestbookId()) %>" />
        <portlet:param name="mvcPath"
            value="/guestbookadminportlet/edit_guestbook.jsp" />
    </portlet:renderURL>

    <liferay-ui:icon image="edit" message="Edit"
            url="<%=editURL.toString() %>" />

    <portlet:actionURL name="deleteGuestbook" var="deleteURL">
            <portlet:param name="guestbookId"
                value="<%= String.valueOf(guestbook.getGuestbookId()) %>" />
    </portlet:actionURL>

    <liferay-ui:icon-delete url="<%=deleteURL.toString() %>" />

</liferay-ui:icon-menu>
\end{verbatim}

  This JSP comprises the pop-up actions menu that shows the possible
  actions users can perform on a guestbook: editing it or deleting it.
  First, \texttt{init.jsp} is included because it contains all the JSP
  imports. Because \texttt{guestbook\_actions.jsp} is included for every
  Search Container row, it retrieves the guestbook in the current
  iteration. The scriptlet grabs that guestbook so its ID can be
  supplied to the menu tags.

  The \texttt{\textless{}liferay-ui:icon-menu\textgreater{}} tag
  dominates \texttt{guestbook\_actions.jsp}. It's a container for menu
  items, of which there are currently only two (you'll add more later).
  The Edit menu item displays the Edit icon and the message \emph{Edit}:

\begin{verbatim}
<liferay-ui:icon image="edit" message="Edit"
        url="<%=editURL.toString() %>" />
\end{verbatim}

  The \texttt{editURL} variable comes from the
  \texttt{\textless{}portlet:renderURL\ var="editURL"\textgreater{}} tag
  with two parameters: \texttt{guestbookId} and \texttt{mvcPath}. The
  \texttt{guestbookId} parameter specifies the guestbook to edit (it's
  the one from the selected search container result row), and the
  \texttt{mvcPath} parameter specifies the Edit Guestbook form's path.

  The Delete menu item displays a delete icon and the default message
  \emph{Delete}:

\begin{verbatim}
<liferay-ui:icon-delete url="<%=deleteURL.toString() %>" />
\end{verbatim}

  Unlike the \texttt{editURL}, which is a render URL that links to the
  \texttt{edit\_guestbook.jsp}, the \texttt{deleteURL} is an action URL
  that invokes the portlet's \texttt{deleteGuestbook} action. The tag
  \texttt{\textless{}portlet:actionURL\ name="deleteGuestbook"\ var="deleteURL"\textgreater{}}
  creates this action URL, which only takes one parameter: the
  \texttt{guestbookId} of the guestbook to be deleted.

  Now there's just one more JSP file left to create: the
  \texttt{edit\_guestbook.jsp} that contains the form for adding a new
  guestbook and editing an existing one.
\item
  Create a new file called \texttt{edit\_guestbook.jsp} in your
  project's \texttt{/guestbookadminportlet} directory. Then add the
  following code to it:

\begin{verbatim}
<%@include file = "../init.jsp" %>

<%
        long guestbookId = ParamUtil.getLong(request, "guestbookId");

        Guestbook guestbook = null;

        if (guestbookId > 0) {
                guestbook = GuestbookLocalServiceUtil.getGuestbook(guestbookId);
        }
%>

<portlet:renderURL var="viewURL">
        <portlet:param name="mvcPath" value="/guestbookadminportlet/view.jsp" />
</portlet:renderURL>

<portlet:actionURL name='<%= guestbook == null ? "addGuestbook" : "updateGuestbook" %>' var="editGuestbookURL" />

<aui:form action="<%= editGuestbookURL %>" name="fm">

        <aui:model-context bean="<%= guestbook %>" model="<%= Guestbook.class %>" />

        <aui:input type="hidden" name="guestbookId"
            value='<%= guestbook == null ? "" : guestbook.getGuestbookId() %>' />

        <aui:fieldset>
             <aui:input name="name" />
        </aui:fieldset>

        <aui:button-row>
             <aui:button type="submit" />
             <aui:button onClick="<%= viewURL %>" type="cancel"  />
        </aui:button-row>
</aui:form>
\end{verbatim}

  After the \texttt{init.jsp} import, you declare a \texttt{null}
  guestbook variable. If there's a \texttt{guestbookId} parameter in the
  request, then you know that you're editing an existing guestbook, and
  you use the \texttt{guestbookId} to retrieve the corresponding
  guestbook via a service call. Otherwise, you know that you're adding a
  new guestbook.

  Next is a view URL that points to the Guestbook Admin portlet's
  default view. This URL is invoked if the user clicks \emph{Cancel} on
  the Add Guestbook or Edit Guestbook form. After that, you create an
  action URL that invokes either the Guestbook Admin portlet's
  \texttt{addGuestbook} method or its \texttt{updateGuestbook} method,
  depending on whether the \texttt{guestbook} variable is null.

  If a guestbook is being edited, the current guestbook's name should
  appear in the form's name field. You use the following tag to define a
  model of the guestbook that can be used in the AlloyUI form:

\begin{verbatim}
<aui:model-context bean="<%= guestbook %>" model="<%= Guestbook.class %>" />
\end{verbatim}

  The form itself is created with the following tag:

\begin{verbatim}
<aui:form action="<%= editGuestbookURL %>" name="<portlet:namespace />fm">
\end{verbatim}

  When the form is submitted, the \texttt{editGuestbookURL} is invoked,
  which calls the Guestbook Admin portlet's \texttt{addGuestbook} or
  \texttt{updateGuestbook} method, as discussed above.

  The \texttt{guestbookId} must appear on the form so that it can be
  submitted. The user, however, doesn't need to see it. Thus, you
  specify \texttt{type="hidden"}:

\begin{verbatim}
<aui:input type="hidden" name="guestbookId"
        value='<%= guestbook == null ? "" : guestbook.getGuestbookId() %>' />
\end{verbatim}

  The name, of course, should be editable by the user so it's not
  hidden.

  The last item on the form is a button row with two buttons. The
  \emph{Submit} button submits the form, invoking the
  \texttt{editGuestbookURL} which, in turn, invokes either the
  \texttt{addGuestbook} or \texttt{updateGuestbook} method. The
  \emph{Cancel} button invokes the \texttt{viewURL} which displays the
  default view.
\end{enumerate}

Excellent! You've now finished creating the UI for the Guestbook Admin
portlet. It should now match the figure below:

\begin{figure}
\centering
\includegraphics{./images/admin-app-start.png}
\caption{The Guestbook Admin portlet lets administrators add or edit
guestbooks, configure their permissions, or delete them.}
\end{figure}

Test out the Guestbook Admin portlet! Try adding, editing, and deleting
guestbooks.

Now all the Guestbook application's primary functions work. There are
still many missing features, however. For example, if there's ever an
error, users never see it: all the code written so far just prints
messages in the logs. Next, you'll learn how to display those errors to
the user.

\chapter{Displaying Messages and
Errors}\label{displaying-messages-and-errors}

When users interact with your application, they perform tasks it
defines, like saving or editing things. The Guestbook application is no
different. Your application should also provide feedback on these
operations so users can know if they worked. Up to now, you've been
placing this information in logs that only administrators can access.
Wouldn't it be better to show users these messages?

\begin{figure}
\centering
\includegraphics{./images/guestbook-status-message.png}
\caption{You can use Liferay's APIs to display helpful messages.}
\end{figure}

That's exactly what you'll do next, in three steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Create language keys for your messages.
\item
  Add the error messages to your action methods.
\item
  Report those error messages in your JSPs.
\end{enumerate}

Ready to get started?

Let's Go!{}

\section{Creating Language Keys}\label{creating-language-keys}

\begin{verbatim}
<p id="stepTitle">Displaying Messages and Errors</p><p>Step 1 of 3</p>
\end{verbatim}

Any modern application should place its messages and form field labels
in a language keys file that can be duplicated and then translated into
multiple languages. Here, you'll learn how to provide a \emph{default}
set of English language keys for your application. For more information
on language keys and providing automatically translated language keys,
\href{/docs/7-1/tutorials/-/knowledge_base/t/automatically-generating-language-files}{see
this tutorial}.

Language keys are stored in the \texttt{Language.properties} file
included in your \texttt{guestbook-web} module.
\texttt{Language.properties} is the default, but you can create a number
of translations by appending the ISO-639 language code to the file name
(e.g., \texttt{Language\_es.properties} for Spanish or
\texttt{Language\_de.properties} for German). For now, stick to the
default language keys.

Follow these steps to create your language keys:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open \texttt{/src/main/resources/content/Language.properties} in your
  \texttt{guestbook-web} module. Remove the default keys in this file.
\item
  Paste in the following keys:

\begin{verbatim}
entry-added=Entry added successfully.
entry-deleted=Entry deleted successfully.
guestbook-added=Guestbook added successfully.
guestbook-updated=Guestbook updated successfully.
guestbook-deleted=Guestbook deleted successfully.
\end{verbatim}
\item
  Save the file.
\end{enumerate}

Your messages are now in place, and your application can use them. Next,
you'll add them to your action methods.

\section{Adding Failure and Success
Messages}\label{adding-failure-and-success-messages}

\begin{verbatim}
<p id="stepTitle">Displaying Messages and Errors</p><p>Step 2 of 3</p>
\end{verbatim}

To display feedback to users properly, you must edit your portlet
classes to use Liferay DXP's \texttt{SessionMessages} and
\texttt{SessionErrors} classes. These classes collect messages that the
view layer shows to the user through a tag.

You'll add these messages to code that runs when the user triggers a
system function that can succeed or fail, such as creating, editing, or
deleting an entry or guestbook. This generally happens in action
methods. You must update these methods to handle failure and success
states in \texttt{GuestbookPortlet.java} and
\texttt{GuestbookAdminPortlet.java}. Start by updating \texttt{addEntry}
and \texttt{deleteEntry} in \texttt{GuestbookPortlet.java}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Find the \texttt{addEntry} method in \texttt{GuestbookPortlet.java}.
  In the first \texttt{try...catch} block's \texttt{try} section, and
  add the success message just before the closing \texttt{\}}:

\begin{verbatim}
SessionMessages.add(request, "entryAdded");
\end{verbatim}

  This uses Liferay's \texttt{SessionMessages} API to add a success
  message whenever a Guestbook is successfully added. It looks up the
  message you placed in the \texttt{Language.properties} file and
  inserts the message for the key \texttt{entry-added} (it automatically
  converts the key from camel case).
\item
  Below that, in the \texttt{catch} block, find the following code:

\begin{verbatim}
System.out.println(e);
\end{verbatim}
\item
  Beneath it, paste this line:

\begin{verbatim}
SessionErrors.add(request, e.getClass().getName());
\end{verbatim}

  Now you not only log the message to the console, you also use the
  \texttt{SessionErrors} object to show the message to the user.
\end{enumerate}

Next, do the same for the \texttt{deleteEntry} method:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  After the logic to delete the entry, add a success message:

\begin{verbatim}
SessionMessages.add(request, "entryDeleted");
\end{verbatim}
\item
  Find the same \texttt{Logger...} block of code in the
  \texttt{deleteEntry} method and after it, paste this line:

\begin{verbatim}
SessionErrors.add(request, e.getClass().getName());
\end{verbatim}
\item
  Hit {[}CTRL{]}+{[}SHIFT{]}+O to import
  \texttt{com.liferay.portal.kernel.servlet.SessionErrors} and
  \texttt{com.liferay.portal.kernel.servlet.SessionMessages}. Save the
  file.
\end{enumerate}

Well done! You've added the messages to \texttt{GuestbookPortlet}. Now
you must update \texttt{GuestbookAdminPortlet.java}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open \texttt{GuestbookAdminPortlet.java} and look for the same cues.
\item
  Add the appropriate success messages to the \texttt{try} section of
  the \texttt{try...catch} in \texttt{addGuestbook},
  \texttt{updateGuestbook}, and \texttt{deleteGuestbook}, respectively:

\begin{verbatim}
 SessionMessages.add(request, "guestbookAdded");

 SessionMessages.add(request, "guestbookUpdated");

 SessionMessages.add(request, "guestbookDeleted");
\end{verbatim}
\item
  In the \texttt{catch} section of those same methods, find
  \texttt{Logger.getlogger...} and paste the \texttt{SessionErrors}
  block beneath it:

\begin{verbatim}
SessionErrors.add(request, pe.getClass().getName());
\end{verbatim}
\item
  Hit {[}CTRL{]}+{[}SHIFT{]}+O to import \texttt{SessionErrors} and
  \texttt{SessionMessages}. Save the file.
\end{enumerate}

Great! The controller now makes relevant and detailed feedback
available. Now all you need to do is publish this feedback in the view
layer.

\section{Adding Messages to JSPs}\label{adding-messages-to-jsps}

\begin{verbatim}
<p id="stepTitle">Displaying Messages and Errors</p><p>Step 3 of 3</p>
\end{verbatim}

Any messages the user should see are now stored in either
\texttt{SessionMessages} or \texttt{SessionErrors}. Next, you'll make
these messages appear in your JSPs.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In the \texttt{guestbook-web} module, open
  \texttt{guestbookwebportlet/view.jsp}. Add the following block of
  success messages to the top of the file, just below the
  \texttt{init.jsp} include statement:

\begin{verbatim}
<liferay-ui:success key="entryAdded" message="entry-added" />
<liferay-ui:success key="entryDeleted" message="entry-deleted" />
\end{verbatim}

  This tag accesses what's stored in \texttt{SessionMessages}. It has
  two attributes. The first is the \texttt{SessionMessages} key that you
  provided in the \texttt{GuestbookPortlet.java} class's add and delete
  methods. The second looks up the specified key in the
  \texttt{Language.properties} file. You could have specified a
  hard-coded message here, but it's far better to provide a localized
  key.
\item
  Now open \texttt{guestbookadminportlet/view.jsp}. Add the following
  block of success messages in the same spot below the include:

\begin{verbatim}
<liferay-ui:success key="guestbookAdded" message="guestbook-added" />
<liferay-ui:success key="guestbookUpdated" message="guestbook-updated" />
<liferay-ui:success key="guestbookDeleted" message="guestbook-deleted" />
\end{verbatim}
\end{enumerate}

\begin{figure}
\centering
\includegraphics{./images/message-complete.png}
\caption{Now the message displays the value you specified in
\texttt{Language.properties}.}
\end{figure}

Congratulations! You've added useful feedback for operations in your
application.

Your application is shaping up, but it is missing another important
feature: permissions. Next, you'll add permission checking for your
guestbooks and entries.

\chapter{Using Resources and
Permissions}\label{using-resources-and-permissions}

You now have an application that uses the database for data storage.
This is a great foundation to build on. What comes next? What if users
want a Guestbook that's limited to certain trusted people? To do that,
you have to implement permissions.

Thankfully, with Liferay DXP you don't have to write an entire
permissions system from scratch: the framework provides a robust and
well-tested permissions system that you can implement quickly. You'll
follow Liferay's well-defined process for implementing permissions,
called \emph{DRAC}:

\begin{itemize}
\tightlist
\item
  \textbf{Define} all resources and permissions
\item
  \textbf{Register} all defined resources in the permissions system
\item
  \textbf{Associate} permissions with resources
\item
  \textbf{Check} for permission before returning resources
\end{itemize}

Ready to start?

Let's Go!{}

\section{Defining Permissions}\label{defining-permissions}

\begin{verbatim}
<p id="stepTitle">Implementing Permissions</p><p>Step 1 of 4</p>
\end{verbatim}

Liferay DXP's permissions framework is configured declaratively, like
Service Builder. You define all your permissions in an XML file that by
convention is called \texttt{default.xml} (but you could really call it
whatever you want). Then you implement permissions checks in the
following places in your code:

\begin{itemize}
\tightlist
\item
  In the view layer, when showing links or buttons to protected
  functionality
\item
  In the actions, before performing a protected action
\item
  Later, in your service, before calling the remote service
\end{itemize}

You should first define the permissions you want. To get started, think
of your application's use cases and how access to that functionality
should be controlled:

\begin{itemize}
\item
  The Add Guestbook button should be available only to administrators.
\item
  The Guestbook tabs should be filtered by permissions so administrators
  can control who can see them.
\item
  To prevent anonymous users from spamming the guestbook, the Add Entry
  button should be available only to Site members.
\item
  Users should be able to set permissions on their own entries.
\end{itemize}

Now you're ready to create the permissions configuration. Objects in
your application (such as \texttt{Guestbook} and \texttt{Entry}) are
defined as \emph{resources}, and \emph{resource actions} manage how
users can interact with those resources. There are therefore two kinds
of permissions: portlet permissions and resource (or model) permissions.
Portlet permissions protect access to global functions, such as
\emph{Add Entry}. If users don't have permission to access that global
function, they're missing a portlet permission. Resource permissions
protect access to objects, such as \texttt{Guestbook} and
\texttt{Entry}. A user may have permission to view one \texttt{Entry},
view and edit another \texttt{Entry}, and may not be able to access
another \texttt{Entry} at all. This is due to a resource permission.

\begin{figure}
\centering
\includegraphics{./images/permission-types.png}
\caption{Portlet permissions and resource permissions cover different
parts of the application.}
\end{figure}

First, create the permissions file in the \texttt{guestbook-service}
project:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In the \texttt{META-INF} folder, create a subfolder called
  \texttt{resource-actions}.
\item
  Create a new file in this folder called \texttt{default.xml}.
\item
  Click the \emph{Source} tab. Add the following \texttt{DOCTYPE}
  declaration to the top of the file:

\begin{verbatim}
<?xml version="1.0"?>
<!DOCTYPE resource-action-mapping PUBLIC "-//Liferay//DTD Resource Action  
Mapping 7.1.0//EN" "http://www.liferay.com/dtd/liferay-resource-action-mapping_7_1_0.dtd">
\end{verbatim}
\item
  Place the following wrapper tags into your \texttt{default.xml} file,
  below the \texttt{DOCTYPE} declaration:

\begin{verbatim}
<resource-action-mapping>

</resource-action-mapping>
\end{verbatim}

  You'll define your resource and model permissions inside these tags.
\item
  Next, place the permissions for your
  \texttt{com.liferay.docs.guestbook} package between the
  \texttt{\textless{}resource-action-mapping\textgreater{}} tags:

\begin{verbatim}
<model-resource>
    <model-name>com.liferay.docs.guestbook</model-name>
    <portlet-ref>
        <portlet-name>com_liferay_docs_guestbook_portlet_GuestbookPortlet</portlet-name>
        <portlet-name>com_liferay_docs_guestbook_portlet_GuestbookAdminPortlet</portlet-name>
    </portlet-ref>
    <root>true</root>
    <permissions>
        <supports>
            <action-key>ADD_GUESTBOOK</action-key>
            <action-key>ADD_ENTRY</action-key>
            <action-key>VIEW</action-key>
        </supports>
        <site-member-defaults>
            <action-key>ADD_ENTRY</action-key>
        </site-member-defaults>
        <guest-defaults>
            <action-key>VIEW</action-key>
        </guest-defaults>
        <guest-unsupported>
            <action-key>ADD_GUESTBOOK</action-key>
            <action-key>ADD_ENTRY</action-key>
        </guest-unsupported>
    </permissions>
</model-resource>
\end{verbatim}

  This defines the baseline configuration for the \texttt{Guestbook} and
  \texttt{Entry} entities. The supported actions are
  \texttt{ADD\_GUESTBOOK} and \texttt{ADD\_ENTRY}. Site members can
  \texttt{ADD\_ENTRY} by default, while guests can't perform either
  action (but they can view).
\item
  Below that, but above the closing
  \texttt{\textless{}/resource-action-mapping\textgreater{}}, place the
  \texttt{Guestbook} model permissions:

\begin{verbatim}
<model-resource>
    <model-name>com.liferay.docs.guestbook.model.Guestbook</model-name>
    <portlet-ref>
        <portlet-name>com_liferay_docs_guestbook_portlet_GuestbookPortlet</portlet-name>
        <portlet-name>com_liferay_docs_guestbook_portlet_GuestbookAdminPortlet</portlet-name>
    </portlet-ref>
    <permissions>
        <supports>
            <action-key>ADD_ENTRY</action-key>
            <action-key>DELETE</action-key>
            <action-key>PERMISSIONS</action-key>
            <action-key>UPDATE</action-key>
            <action-key>VIEW</action-key>
        </supports>
        <site-member-defaults>
            <action-key>ADD_ENTRY</action-key>
            <action-key>VIEW</action-key>
        </site-member-defaults>
        <guest-defaults>
            <action-key>VIEW</action-key>
        </guest-defaults>
        <guest-unsupported>
            <action-key>UPDATE</action-key>
        </guest-unsupported>
    </permissions>
</model-resource>
\end{verbatim}

  This defines the \texttt{Guestbook} specific actions, including
  adding, deleting, updating, and viewing. By default, site members and
  guests can view guestbooks, but guests can't update them.
\item
  Below the \texttt{Guestbook} model permissions, but still above the
  closing \texttt{\textless{}/resource-action-mapping\textgreater{}},
  place the \texttt{Entry} model permissions:

\begin{verbatim}
<model-resource>
    <model-name>com.liferay.docs.guestbook.model.Entry</model-name>
    <portlet-ref>
        <portlet-name>com_liferay_docs_guestbook_portlet_GuestbookPortlet</portlet-name>
    </portlet-ref>
    <permissions>
        <supports>
            <action-key>DELETE</action-key>
            <action-key>PERMISSIONS</action-key>
            <action-key>UPDATE</action-key>
            <action-key>VIEW</action-key>
        </supports>
        <site-member-defaults>
            <action-key>VIEW</action-key>
        </site-member-defaults>
        <guest-defaults>
            <action-key>VIEW</action-key>
        </guest-defaults>
        <guest-unsupported>
            <action-key>UPDATE</action-key>
        </guest-unsupported>
    </permissions>
</model-resource>
\end{verbatim}

  This defines \texttt{Entry} specific actions. By default, a Site
  member can add or view an entry, and a guest can only view an entry.
\item
  Save the file.
\end{enumerate}

Next, you must tell the framework where your permissions are defined.
You'll define resource and model permissions in the module where your
model is defined:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In \texttt{guestbook-service}'s \texttt{src/main/resources} folder,
  create a file called \texttt{portlet.properties}.
\item
  In this file, place the following property:

\begin{verbatim}
resource.actions.configs=META-INF/resource-actions/default.xml
\end{verbatim}
\end{enumerate}

This property defines the name and location of your permissions
definition file.

You now have permissions defined at the model level, but you must also
define portlet permissions. These are managed in the
\texttt{guestbook-web} module, which contains the portlet class. Follow
these steps to add the portlet permissions in the \texttt{guestbook-web}
module:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a subfolder called \texttt{resource-actions} in the
  \texttt{src/main/resources/META-INF} folder.
\item
  Create a new file in this folder called \texttt{default.xml}.
\item
  Add the following \texttt{DOCTYPE} declaration to the top of the file:

\begin{verbatim}
<?xml version="1.0"?>
<!DOCTYPE resource-action-mapping PUBLIC "-//Liferay//DTD Resource Action  
Mapping 7.1.0//EN" "http://www.liferay.com/dtd/liferay-resource-action-mapping_7_1_0.dtd">
\end{verbatim}
\item
  Below the \texttt{DOCTYPE} declaration, add the following
  \texttt{resource-action-mapping} tags:

\begin{verbatim}
<resource-action-mapping>

</resource-action-mapping>
\end{verbatim}

  You'll define your portlet permissions inside these tags.
\item
  Insert this block of code inside the \texttt{resource-action-mapping}
  tags:

\begin{verbatim}
<portlet-resource>
    <portlet-name>com_liferay_docs_guestbook_portlet_GuestbookAdminPortlet</portlet-name>
    <permissions>
        <supports>
            <action-key>ACCESS_IN_CONTROL_PANEL</action-key>
            <action-key>CONFIGURATION</action-key>
            <action-key>VIEW</action-key>
        </supports>
        <site-member-defaults>
            <action-key>VIEW</action-key>
        </site-member-defaults>
        <guest-defaults>
            <action-key>VIEW</action-key>
        </guest-defaults>
        <guest-unsupported>
            <action-key>ACCESS_IN_CONTROL_PANEL</action-key>
            <action-key>CONFIGURATION</action-key>
        </guest-unsupported>
    </permissions>
</portlet-resource>
\end{verbatim}

  This defines the default permissions for the Guestbook Admin portlet.
  It supports the actions \texttt{ACCESS\_IN\_CONTROL\_PANEL},
  \texttt{CONFIGURATION}, and \texttt{VIEW}. While anyone can view the
  app, guests and Site members can't configure it or access it in the
  Control Panel. Since it's a Control Panel portlet, this effectively
  means that only administrators can access it.
\item
  Below the Guestbook Admin permissions, insert this block of code:

\begin{verbatim}
<portlet-resource>
    <portlet-name>com_liferay_docs_guestbook_portlet_GuestbookPortlet</portlet-name>
    <permissions>
        <supports>
            <action-key>ADD_TO_PAGE</action-key>
            <action-key>CONFIGURATION</action-key>
            <action-key>VIEW</action-key>
        </supports>
        <site-member-defaults>
            <action-key>VIEW</action-key>
        </site-member-defaults>
        <guest-defaults>
            <action-key>VIEW</action-key>
        </guest-defaults>
        <guest-unsupported />
    </permissions>
</portlet-resource>
\end{verbatim}

  This defines permissions for the Guestbook portlet. It supports the
  actions \texttt{ADD\_TO\_PAGE}, \texttt{CONFIGURATION}, and
  \texttt{VIEW}. Site members and guests get the \texttt{VIEW}
  permission by default.
\item
  Save the file.
\item
  In \texttt{guestbook-web}'s \texttt{src/main/resources} folder, create
  a file called \texttt{portlet.properties}.
\item
  In this file, place the following property:

\begin{verbatim}
resource.actions.configs=META-INF/resource-actions/default.xml
\end{verbatim}
\item
  Save the file.
\end{enumerate}

Great job! You've now successfully designed and implemented a
permissions scheme for your application. Next, you'll create the Java
code to support permissions in the service layer.

\section{Registering Your Defined
Permissions}\label{registering-your-defined-permissions}

\begin{verbatim}
<p id="stepTitle">Implementing Permissions</p><p>Step 2 of 4</p>
\end{verbatim}

The last step introduced the concept of \emph{resources}. Resources are
data stored with your entities that define how they can be accessed. For
example, when the configuration in your \texttt{default.xml} files is
applied to your application's entities in the database, resources are
created. These resources are then used in conjunction with Liferay DXP's
permissions system to determine who can do what to the entities.

To use these resources, Liferay DXP must know about them. To do that you
\emph{register} the resources with the system, both in the database and
with the running permissions system in the OSGi container.

\subsection{Registering Permissions in the
Database}\label{registering-permissions-in-the-database}

Liferay DXP provides a complete API for managing resources that's
integrated with Service Builder. This API is injected into your
implementation classes automatically. To manage the resources, you need
only call the API in the service's add and delete methods. Follow these
steps to do this in your application:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In your \texttt{guestbook-service} module, open
  \texttt{GuestbookLocalServiceImpl.java} from the
  \texttt{com.liferay.docs.guestbook.service.impl} package.
\item
  Just before the \texttt{addGuestbook} method's \texttt{return}
  statement, add this code:

\begin{verbatim}
resourceLocalService.addResources(user.getCompanyId(), groupId, userId,
    Guestbook.class.getName(), guestbookId, false, true, true);
\end{verbatim}

  Note that the \texttt{resourceLocalService} object is already there,
  ready for you to use. This is one of several utilities that are
  injected automatically by Service Builder. You'll see the rest in the
  future.

  This code adds a resource to Liferay DXP's database to correspond with
  your entity (note that the \texttt{guestbookId} is included in the
  call). The three booleans at the end are settings. The first is
  whether to add portlet action permissions. This should only be
  \texttt{true} if the permission is for a portlet resource. Since this
  permission is for a model resource (an entity), it's \texttt{false}.
  The other two are settings for adding group and guest permissions. If
  you set these to \texttt{true}, you'll add the default permissions you
  defined in the permissions configuration file (\texttt{default.xml})
  in the previous step. Since you definitely want to do this, these
  booleans are set to \texttt{true}.
\item
  Next, go to the \texttt{updateGuestbook} method. Add a similar bit of
  code in between \texttt{guestbookPersistence.update(guestbook);} and
  the \texttt{return} statement:

\begin{verbatim}
resourceLocalService.updateResources(serviceContext.getCompanyId(),
                serviceContext.getScopeGroupId(), 
                Guestbook.class.getName(), guestbookId,
                serviceContext.getGroupPermissions(),
                serviceContext.getGuestPermissions());
\end{verbatim}
\item
  Now you'll do the same for \texttt{deleteGuestbook}. Add this code in
  between \texttt{guestbook\ =\ deleteGuestbook(guestbook);} and the
  \texttt{return} statement:

\begin{verbatim}
resourceLocalService.deleteResource(serviceContext.getCompanyId(),
                Guestbook.class.getName(), ResourceConstants.SCOPE_INDIVIDUAL,
                guestbookId);
\end{verbatim}
\item
  Hit {[}CTRL{]}+{[}SHIFT{]}+O to organize the imports and save the
  file.
\item
  Now you'll add resources for the \texttt{Entry} entity. Open
  \texttt{EntryLocalServiceImpl.java} from the same package. For
  \texttt{addEntry}, add a line of code that adds resources for this
  entity, just before the return statement:

\begin{verbatim}
resourceLocalService.addResources(user.getCompanyId(), groupId, userId,
    Entry.class.getName(), entryId, false, true, true);
\end{verbatim}
\item
  For \texttt{deleteEntry}, add this code just before the
  \texttt{return} statement:

\begin{verbatim}
resourceLocalService.deleteResource(
               serviceContext.getCompanyId(), Entry.class.getName(),
               ResourceConstants.SCOPE_INDIVIDUAL, entryId);
\end{verbatim}
\item
  Finally, find \texttt{updateEntry} and add its resource action, also
  just before the \texttt{return} statement:

\begin{verbatim}
resourceLocalService.updateResources(
      user.getCompanyId(), serviceContext.getScopeGroupId(), 
      Entry.class.getName(), entryId, serviceContext.getGroupPermissions(),
      serviceContext.getGuestPermissions());
\end{verbatim}
\end{enumerate}

That's all it takes to add permissions resources to the database. Future
entities added to the database are fully permissions-enabled. Note,
however, that any entities you've already added to your Guestbook
application in the portal don't have resources and thus can't be
protected by permissions. You'll fix this at the end of this section.
Now you must register permissions with the permissions system, so it
knows how to check for them.

\subsection{Registering Your Entities with the Permissions
Service}\label{registering-your-entities-with-the-permissions-service}

A running service checks permissions, but since the Guestbook portlet,
Guestbooks, and Guestbook Entries are new to the system, it must be
taught about them. You do this by creating permissions registrar
classes. These follow what you did in \texttt{default.xml}: you need one
for your portlet permissions and one for each of your entities. First,
you must do a little reorganization.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In your API module, create a \texttt{GuestbookConstants} class in a
  new package called \texttt{com.liferay.docs.guestbook.constants}:

\begin{verbatim}
package com.liferay.docs.guestbook.constants;

public class GuestbookConstants {

    public static final String RESOURCE_NAME = "com.liferay.docs.guestbook";

}
\end{verbatim}

  The \texttt{RESOURCE\_NAME} string must match exactly your resource
  name from \texttt{default.xml}. You'll see why in a moment.
\item
  You have a \texttt{GuestbookPortletKeys} class in your web module.
  These keys must now be accessible to all modules, so drag this class
  from the web module and drop it into the new
  \texttt{com.liferay.docs.guestbook.constants} package in your API
  module.
\end{enumerate}

Now you're ready to create your permissions registrar classes.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\item
  In your service bundle, create a package that by convention ends in
  \texttt{internal.security.permission.resource}.
\item
  Create a class in this package called
  \texttt{GuestbookModelResourcePermissionRegistrar} with the contents
  below.

\begin{verbatim}
package com.liferay.docs.guestbook.internal.security.permission.resource;

import java.util.Dictionary;

import org.osgi.framework.BundleContext;
import org.osgi.framework.ServiceRegistration;
import org.osgi.service.component.annotations.Activate;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Deactivate;
import org.osgi.service.component.annotations.Reference;

import com.liferay.docs.guestbook.constants.GuestbookConstants;
import com.liferay.docs.guestbook.constants.GuestbookPortletKeys;
import com.liferay.docs.guestbook.model.Guestbook;
import com.liferay.docs.guestbook.service.GuestbookLocalService;
import com.liferay.exportimport.kernel.staging.permission.StagingPermission;
import com.liferay.portal.kernel.security.permission.resource.ModelResourcePermission;
import com.liferay.portal.kernel.security.permission.resource.ModelResourcePermissionFactory;
import com.liferay.portal.kernel.security.permission.resource.PortletResourcePermission;
import com.liferay.portal.kernel.security.permission.resource.StagedModelPermissionLogic;
import com.liferay.portal.kernel.security.permission.resource.WorkflowedModelPermissionLogic;
import com.liferay.portal.kernel.service.GroupLocalService;
import com.liferay.portal.kernel.util.HashMapDictionary;
import com.liferay.portal.kernel.workflow.permission.WorkflowPermission;

@Component (immediate=true)
public class GuestbookModelResourcePermissionRegistrar {

 @Activate
    public void activate(BundleContext bundleContext) {
        Dictionary<String, Object> properties = new HashMapDictionary<>();

        properties.put("model.class.name", Guestbook.class.getName());

        _serviceRegistration = bundleContext.registerService(
            ModelResourcePermission.class,
            ModelResourcePermissionFactory.create(
                Guestbook.class, Guestbook::getGuestbookId,
                _guestbookLocalService::getGuestbook, _portletResourcePermission,
                (modelResourcePermission, consumer) -> {
                    consumer.accept(
                        new StagedModelPermissionLogic<>(
                            _stagingPermission, GuestbookPortletKeys.GUESTBOOK,
                            Guestbook::getGuestbookId));
                    consumer.accept(
                        new WorkflowedModelPermissionLogic<>(
                                _workflowPermission, modelResourcePermission,
                                _groupLocalService, Guestbook::getGuestbookId));
                }),
            properties);
    }

    @Deactivate
    public void deactivate() {
        _serviceRegistration.unregister();
    }

    @Reference
    private GuestbookLocalService _guestbookLocalService;

    @Reference(target = "(resource.name=" + GuestbookConstants.RESOURCE_NAME + ")")
    private PortletResourcePermission _portletResourcePermission;

    private ServiceRegistration<ModelResourcePermission> _serviceRegistration;

    @Reference
    private StagingPermission _stagingPermission;

    @Reference
    private WorkflowPermission _workflowPermission;

    @Reference
    private GroupLocalService _groupLocalService;
}
\end{verbatim}
\end{enumerate}

This class registers a chain of permission logic classes for checking
permissions for Guestbook entities. Since this functionality is the same
for all entities, all that's necessary is to specify yours in addition
to the standard Liferay ones for staging and workflow. Introspection is
done on your entity by the factory to create the necessary permissions
service. You implemented the constants class so you can specify the
resource model name you defined in \texttt{default.xml}. The
\texttt{model.class.name} is set so that any module needing this service
can find this model resource permission by its type.

Now create the registrar for the \texttt{Entry} entity:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a class in the same package called
  \texttt{GuestbookEntryModelResourcePermissionRegistrar}.
\item
  The only difference between this class and the one above is that it
  operates on \texttt{Entry} entities instead of \texttt{Guestbook}
  entities (the imports have been left off in the snippet below):

\begin{verbatim}
@Component(immediate = true)
public class GuestbookEntryModelResourcePermissionRegistrar {

 @Activate
    public void activate(BundleContext bundleContext) {
        Dictionary<String, Object> properties = new HashMapDictionary<>();

        properties.put("model.class.name", Entry.class.getName());

        _serviceRegistration = bundleContext.registerService(
            ModelResourcePermission.class,
            ModelResourcePermissionFactory.create(
                Entry.class, Entry::getEntryId,
                _entryLocalService::getEntry, _portletResourcePermission,
                (modelResourcePermission, consumer) -> {
                    consumer.accept(
                        new StagedModelPermissionLogic<>(
                            _stagingPermission, GuestbookPortletKeys.GUESTBOOK,
                            Entry::getEntryId));
                    consumer.accept(
                        new WorkflowedModelPermissionLogic<>(
                                _workflowPermission, modelResourcePermission,
                                _groupLocalService, Entry::getEntryId));
                }),
            properties);
    }

    @Deactivate
    public void deactivate() {
        _serviceRegistration.unregister();
    }

    @Reference
    private EntryLocalService _entryLocalService;

    @Reference(target = "(resource.name=" + GuestbookConstants.RESOURCE_NAME + ")")
    private PortletResourcePermission _portletResourcePermission;

    private ServiceRegistration<ModelResourcePermission> _serviceRegistration;

    @Reference
    private StagingPermission _stagingPermission;

    @Reference
    private WorkflowPermission _workflowPermission;

    @Reference
    private GroupLocalService _groupLocalService;
}
\end{verbatim}
\end{enumerate}

Finally, create the registrar for the portlet permissions:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a class in the same package called
  \texttt{GuestbookPortletResourcePermissionRegistrar}.
\item
  This class is simpler because you don't have to tell it how to
  retrieve primary keys from any entity:

\begin{verbatim}
@Component (immediate = true)
public class GuestbookPortletResourcePermissionRegistrar {

        @Activate
    public void activate(BundleContext bundleContext) {
        Dictionary<String, Object> properties = new HashMapDictionary<>();

        properties.put("resource.name", GuestbookConstants.RESOURCE_NAME);

        _serviceRegistration = bundleContext.registerService(
            PortletResourcePermission.class,
            PortletResourcePermissionFactory.create(
                GuestbookConstants.RESOURCE_NAME,
                new StagedPortletPermissionLogic(
                    _stagingPermission, GuestbookPortletKeys.Guestbook)),
            properties);
    }

    @Deactivate
    public void deactivate() {
        _serviceRegistration.unregister();
    }

    private ServiceRegistration<PortletResourcePermission> _serviceRegistration;

    @Reference
    private StagingPermission _stagingPermission;

}
\end{verbatim}
\end{enumerate}

You've now completed step two: the R in DRAC: registering permissions.
Next, you'll enable users to associate permissions with resources.

\section{Assigning Permissions to
Resources}\label{assigning-permissions-to-resources}

\begin{verbatim}
<p id="stepTitle">Implementing Permissions</p><p>Step 3 of 4</p>
\end{verbatim}

You've now defined your permissions and registered them in the container
and in the database so permissions can be checked. Now you'll create a
UI for users to assign permissions along with helper classes to make it
easy to check permissions in the next step.

Here's how it works. You have a permission, such as \texttt{ADD\_ENTRY},
and a resource, such as a \texttt{Guestbook}. For a user to add an entry
to a guestbook, you must check if that user has the \texttt{ADD\_ENTRY}
permission for that guestbook. Helper classes make it easier to check
permissions:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Right-click the \texttt{guestbook-web} module and select \emph{New} →
  \emph{Package}. To follow Liferay's practice, name the package
  \texttt{com.liferay.docs.guestbook.web.security.permission.resource}.
  This is where you'll place your helper classes.
\item
  Right-click the new package and select \emph{New} → \emph{Class}. Name
  the class \texttt{GuestbookPermission}.
\item
  Replace this class's contents with the following code:

\begin{verbatim}
package com.liferay.docs.guestbook.web.security.permission.resource;

import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Reference;

import com.liferay.docs.guestbook.constants.GuestbookConstants;
import com.liferay.portal.kernel.security.permission.PermissionChecker;
import com.liferay.portal.kernel.security.permission.resource.PortletResourcePermission;

@Component(immediate=true)
public class GuestbookPermission {

    public static boolean contains(PermissionChecker permissionChecker, long groupId, String actionId) {

        return _portletResourcePermission.contains(permissionChecker, groupId, actionId);

    }

    @Reference(
            target="(resource.name=" + GuestbookConstants.RESOURCE_NAME + ")",
            unbind="-"
            )
    protected void setPortletResourcePermission(PortletResourcePermission portletResourcePermission) {

        _portletResourcePermission = portletResourcePermission;
    }

    private static PortletResourcePermission _portletResourcePermission;

}
\end{verbatim}
\end{enumerate}

This class is a component defining one static method (so you don't have
to instantiate the class) that encapsulates the model you're checking
permissions for. Liferay's \texttt{PermissionChecker} class does most of
the work: give it the proper resource and action, such as
\texttt{ADD\_ENTRY}, and it returns whether the permission exists or
not.

There's only one method: a \texttt{check} method that throws an
exception if the user doesn't have permission.

Next, you'll create helpers for your two entities:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a class in the same package called
  \texttt{GuestbookModelPermission.java}.
\item
  Replace this class's contents with the following code:

\begin{verbatim}
    package com.liferay.docs.guestbook.web.security.permission.resource;

    import org.osgi.service.component.annotations.Component;
    import org.osgi.service.component.annotations.Reference;

    import com.liferay.docs.guestbook.model.Guestbook;
    import com.liferay.portal.kernel.exception.PortalException;
    import com.liferay.portal.kernel.security.permission.PermissionChecker;
    import com.liferay.portal.kernel.security.permission.resource.ModelResourcePermission;

    @Component(immediate = true)
    public class GuestbookModelPermission {

        public static boolean contains(
                PermissionChecker permissionChecker, Guestbook guestbook, String actionId) throws PortalException {

            return _guestbookModelResourcePermission.contains(permissionChecker, guestbook, actionId);
        }

        public static boolean contains(
                PermissionChecker permissionChecker, long guestbookId, String actionId) throws PortalException {

            return _guestbookModelResourcePermission.contains(permissionChecker, guestbookId, actionId);
        }

        @Reference(
                target = "(model.class.name=com.liferay.docs.guestbook.model.Guestbook)",
                unbind = "-")
        protected void setEntryModelPermission(ModelResourcePermission<Guestbook> modelResourcePermission) {

            _guestbookModelResourcePermission = modelResourcePermission;
        }

        private static ModelResourcePermission<Guestbook>_guestbookModelResourcePermission;

    }
\end{verbatim}
\end{enumerate}

As you can see, this class is similar to \texttt{GuestbookPermission}.
The difference is that \texttt{GuestbookModelPermission} is for the
model/resource permission, so you supply the entity or its primary key
(\texttt{guestbookId}).

Your final class is almost identical to
\texttt{GuestbookModelPermission}, but it's for the \texttt{Entry}
entity. Follow these steps to create it:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a class in the same package called
  \texttt{GuestbookEntryPermission.java}.
\item
  Replace this class's contents with the following code:

\begin{verbatim}
package com.liferay.docs.guestbook.web.security.permission.resource;

import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Reference;

import com.liferay.docs.guestbook.model.Entry;
import com.liferay.portal.kernel.exception.PortalException;
import com.liferay.portal.kernel.security.permission.PermissionChecker;
import com.liferay.portal.kernel.security.permission.resource.ModelResourcePermission;

@Component(immediate = true)
public class GuestbookEntryPermission {

    public static boolean contains(
            PermissionChecker permissionChecker, Entry entry, String actionId) throws PortalException {

        return _guestbookEntryModelResourcePermission.contains(permissionChecker, entry, actionId);
    }

    public static boolean contains(
            PermissionChecker permissionChecker, long entryId, String actionId) throws PortalException {

        return _guestbookEntryModelResourcePermission.contains(permissionChecker, entryId, actionId);
    }

    @Reference(
            target = "(model.class.name=com.liferay.docs.guestbook.model.Entry)",
            unbind = "-")
    protected void setEntryModelPermission(ModelResourcePermission<Entry> modelResourcePermission) {

        _guestbookEntryModelResourcePermission = modelResourcePermission;
    }

    private static ModelResourcePermission<Entry>_guestbookEntryModelResourcePermission;

}
\end{verbatim}
\end{enumerate}

This class is almost identical to \texttt{GuestbookModelPermission}. The
only difference is that \texttt{GuestbookEntryPermission} is for the
\texttt{Entry} entity.

Now you can expose the permissions UI to your users so they can assign
permissions:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Go to the \texttt{init.jsp} in your \texttt{guestbook-web} project.
  Add the following imports to the file:

\begin{verbatim}
<%@ page import="com.liferay.docs.guestbook.web.security.permission.resource.GuestbookModelPermission" %>
<%@ page import="com.liferay.docs.guestbook.web.security.permission.resource.GuestbookPermission" %>
<%@ page import="com.liferay.docs.guestbook.web.security.permission.resource.GuestbookEntryPermission" %>
<%@ page import="com.liferay.portal.kernel.util.WebKeys" %>
<%@ page import="com.liferay.portal.kernel.security.permission.ActionKeys" %>
\end{verbatim}

  The first three are the permissions helper classes you just created.
\item
  Open \texttt{guestbook\_actions.jsp}. Add this code just after the
  \texttt{\textless{}liferay-ui:icon-delete\textgreater{}} tag:

\begin{verbatim}
    <c:if
    test="<%=GuestbookModelPermission.contains(permissionChecker, guestbook.getGuestbookId(), ActionKeys.PERMISSIONS) %>">

        <liferay-security:permissionsURL
            modelResource="<%= Guestbook.class.getName() %>"
            modelResourceDescription="<%= guestbook.getName() %>"
            resourcePrimKey="<%= String.valueOf(guestbook.getGuestbookId()) %>"
            var="permissionsURL" />

        <liferay-ui:icon image="permissions" url="<%= permissionsURL %>" />

    </c:if>
\end{verbatim}
\item
  Save the file.
\end{enumerate}

You just added an action button that displays Liferay's permissions UI
for Guestbooks. On top of that, you used the permissions helper you just
created to test whether users can even see the action button. It only
appears if users have the \emph{permissions} permission.

You'll implement this for Guestbook entries in the next step.

Congratulations! You've now created helper classes for your permissions,
and you've enabled users to associate permissions with their resources.
The only thing left is to implement permission checks in the
application's view layer. You'll do this next.

\section{Checking for Permission in
JSPs}\label{checking-for-permission-in-jsps}

\begin{verbatim}
<p id="stepTitle">Implementing Permissions</p><p>Step 4 of 4</p>
\end{verbatim}

You've already seen how user interface components can be wrapped in
permission checks pretty easily. In this step, you'll implement the
rest.

\subsection{Checking Permissions in the
UI}\label{checking-permissions-in-the-ui}

Recall that you want to restrict access to three areas in your
application:

\begin{itemize}
\tightlist
\item
  The guestbook tabs across the top of your application
\item
  The Add Guestbook button
\item
  The Add Entry button
\end{itemize}

First, you'll create the guestbook tabs and check permissions for them:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open \texttt{/guestbookwebportlet/view.jsp} and find the scriptlet
  that gets the \texttt{guestbookId} from the request. Just below this,
  add the following code:

\begin{verbatim}
<aui:nav cssClass="nav-tabs">

    <%
        List<Guestbook> guestbooks = GuestbookLocalServiceUtil.getGuestbooks(scopeGroupId);

            for (int i = 0; i < guestbooks.size(); i++) {

                Guestbook curGuestbook = guestbooks.get(i);
                String cssClass = StringPool.BLANK;

                if (curGuestbook.getGuestbookId() == guestbookId) {
                    cssClass = "active";
                }

                if (GuestbookModelPermission.contains(
                    permissionChecker, curGuestbook.getGuestbookId(), "VIEW")) {

    %>

    <portlet:renderURL var="viewPageURL">
        <portlet:param name="mvcPath" value="/guestbookwebportlet/view.jsp" />
        <portlet:param name="guestbookId"
            value="<%=String.valueOf(curGuestbook.getGuestbookId())%>" />
    </portlet:renderURL>


    <aui:nav-item cssClass="<%=cssClass%>" href="<%=viewPageURL%>"
        label="<%=HtmlUtil.escape(curGuestbook.getName())%>" />

    <%  
                }

            }
    %>

</aui:nav>
\end{verbatim}

  This code gets a list of guestbooks from the database, iterates
  through them, checks the permission for each against the current
  user's Roles, and adds the guestbooks the user can access to a list of
  tabs.

  You've now implemented your first permission check. As you can see,
  it's relatively straightforward thanks to the static methods in your
  helper classes. The code above shows the tab only if the current user
  has the \texttt{VIEW} permission for the guestbook.

  Next, you'll add permission checks to the Add Entry button.
\item
  Scroll down to the line that reads
  \texttt{\textless{}aui:button-row\ cssClass="guestbook-buttons"\textgreater{}}.
  Just below this line, add the following line of code to check for the
  \texttt{ADD\_ENTRY} permission:

\begin{verbatim}
<c:if test='<%= GuestbookPermission.contains(permissionChecker, scopeGroupId, "ADD_ENTRY") %>'>
\end{verbatim}
\item
  After this is the code that creates the \texttt{addEntryURL} and the
  Add Entry button. After the \texttt{aui:button} tag and above the
  \texttt{\textless{}/aui:button-row\textgreater{}} tag, add the closing
  tag for the \texttt{\textless{}c:if\textgreater{}} statement:

\begin{verbatim}
</c:if>
\end{verbatim}

  You've now implemented your permission check for the Add Entry button
  by using JSTL tags.
\end{enumerate}

Next, you'll implement an \texttt{entry\_actions.jsp} that's much like
the one in the Guestbook Admin portlet. This determines what options
appear for logged in users who can see the actions menu in the portlet.
Just like before, you'll wrap each \texttt{renderURL} in a \texttt{if}
statement that checks the permissions against available actions. To do
this, follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In \texttt{src/main/resources/META-INF/resources/guestbookwebportlet},
  create a file called \texttt{entry\_actions.jsp}.
\item
  In this file, add the following code:

\begin{verbatim}
<%@include file="../init.jsp"%>

    <%
    String mvcPath = ParamUtil.getString(request, "mvcPath");

    ResultRow row = (ResultRow)request.getAttribute(WebKeys.SEARCH_CONTAINER_RESULT_ROW);

    Entry entry = (Entry)row.getObject(); 
    %>

    <liferay-ui:icon-menu>

        <c:if
            test="<%= GuestbookEntryPermission.contains(permissionChecker, entry.getEntryId(), ActionKeys.UPDATE) %>">
            <portlet:renderURL var="editURL">
                <portlet:param name="entryId"
                    value="<%= String.valueOf(entry.getEntryId()) %>" />
                <portlet:param name="mvcPath" value="/guestbookwebportlet/edit_entry.jsp" />
            </portlet:renderURL>

            <liferay-ui:icon image="edit" message="Edit"
                url="<%=editURL.toString() %>" />
        </c:if>

        <c:if
        test="<%=GuestbookEntryPermission.contains(permissionChecker, entry.getEntryId(), ActionKeys.PERMISSIONS) %>">

            <liferay-security:permissionsURL
                modelResource="<%= Entry.class.getName() %>"
                modelResourceDescription="<%= entry.getMessage() %>"
                resourcePrimKey="<%= String.valueOf(entry.getEntryId()) %>"
                var="permissionsURL" />

            <liferay-ui:icon image="permissions" url="<%= permissionsURL %>" />

        </c:if>

        <c:if
            test="<%=GuestbookEntryPermission.contains(permissionChecker, entry.getEntryId(), ActionKeys.DELETE) %>">

            <portlet:actionURL name="deleteEntry" var="deleteURL">
                <portlet:param name="entryId"
                    value="<%= String.valueOf(entry.getEntryId()) %>" />
                <portlet:param name="guestbookId"
                    value="<%= String.valueOf(entry.getGuestbookId()) %>" />
            </portlet:actionURL>

            <liferay-ui:icon-delete url="<%=deleteURL.toString() %>" />
        </c:if>

    </liferay-ui:icon-menu>
\end{verbatim}

  This code defines action buttons updating, setting permissions on, and
  deleting entities. Each button is protected by a permissions check. If
  the current user can't perform the given action, the action doesn't
  appear.
\item
  Finally, in \texttt{view.jsp}, you must add the
  \texttt{entry\_actions.jsp} as the last column in the Search
  Container. Find the line defining the Search Container row. It looks
  like this:

\begin{verbatim}
<liferay-ui:search-container-row
    className="com.liferay.docs.guestbook.model.Entry" modelVar="entry">
\end{verbatim}

  Below that line are two columns. After the second column, add a third:

\begin{verbatim}
<liferay-ui:search-container-column-jsp path="/guestbookwebportlet/entry_actions.jsp" align="right" />
\end{verbatim}
\item
  Save all JSP files.
\end{enumerate}

Excellent! You've now implemented all the permissions checks for the
Guestbook portlet.

When testing the application, remember that any guestbook entries you
created without resources won't work with permissions. Add new
guestbooks and entries to test your application with different users.
Administrative users see all the buttons, regular users see the Add
Entry button, and guests see no buttons at all (but can navigate).

\noindent\hrulefill

\textbf{Note:} You may see an error where the Guestbook portlet doesn't
appear at all, and you see this error in the log:

\begin{verbatim}
 Someone may be trying to circumvent the permission checker.
\end{verbatim}

This is because any data you currently have in the Guestbook application
doesn't have resources. In this case, you must drop and re-create your
database. To do this, find your Liferay Workspace on your file system
(it should be inside your Eclipse workspace). Inside the
\texttt{bundles/data} folder is a \texttt{hypersonic} folder. Shut down
Liferay DXP, remove everything from this folder, and then restart. After
adding guestbook to a page, the portlet will work normally.

\noindent\hrulefill

Now see if you can do the same for the Guestbook Admin portlet. Don't
worry if you can't: at the end of this Learning Path is a link to the
completed project for you to examine.

Great! The next step is to integrate search and indexing into your
application. This is a prerequisite for the much more powerful stuff to
come.

\chapter{Search and Indexing}\label{search-and-indexing}

The Guestbook and Guestbook Admin portlets are up and running. The
Guestbook portlet lets users add, edit, delete, and configure
permissions for Guestbook Entries. The Guestbook Admin portlet lets Site
administrators create, edit, delete, and configure permissions for
Guestbooks. In the case of a very popular event (maybe a \emph{Lunar
Luau} dinner at the Lunar Resort), there could be many Guestbook Entries
in the portlet, and users might want to search for Entries that
mentioned the delicious low-gravity ham that was served (melts in your
mouth). Searching for the word \emph{ham} should display these Entries.
In short, Guestbook Entries must be searchable via a search bar in the
Guestbook portlet.

\noindent\hrulefill

\textbf{Note:} In previous versions of Liferay DXP, search was only
\emph{permissions aware} (indexed with the entity's permissions and
searched with those permissions intact) if the application developer
specified this line in the \texttt{Indexer} class's constructor:

\begin{verbatim}
 setPermissionAware(true);
\end{verbatim}

Now, search is permissions aware by default \emph{if the new permissions
approach}, as described in the previous step of this Learning Path and
in
\href{/docs/7-1/tutorials/-/knowledge_base/t/defining-application-permissions}{these
tutorials}, is implemented for an application.

\noindent\hrulefill

To enable search, you must index Guestbooks and their Entries. Although
you probably won't have enough Guestbooks in a Site to warrant searching
the Guestbook Admin portlet, indexing Guestbooks has other benefits. In
a later section, you'll asset-enable Guestbooks and Guestbook Entries so
the Asset Publisher can display them. Enabling search is a prerequisite
for this---you must index any entity that you want to make an asset.

But assets are for later. Right now it's time to index those Guestbooks.
Ready?

\begin{figure}
\centering
\includegraphics{./images/guestbook-portlet-search.png}
\caption{Add a search bar so users can search for Guestbook Entries. If
a message or name matches the search query, the Entry is displayed in
the search results.}
\end{figure}

Let's Go!{}

\chapter{Enabling Search and Indexing for
Guestbooks}\label{enabling-search-and-indexing-for-guestbooks}

In this section, you'll create the classes that control these aspects of
the search functionality:

\begin{itemize}
\item
  Registration:

  \begin{itemize}
  \tightlist
  \item
    \texttt{GuestbookSearchRegistrar} registers the search services to
    the search framework for the Guestbook entity.
  \end{itemize}
\item
  Indexing:

  \begin{itemize}
  \item
    \texttt{GuestbookModelDocumentContributor} controls which Guestbook
    fields are indexed in the search engine.
  \item
    \texttt{GuestbookModelIndexerWriterContributor} configures the
    re-indexing and batch re-indexing behavior for Guestbooks.
  \end{itemize}
\item
  Querying:

  \begin{itemize}
  \item
    \texttt{GuestbookKeywordQueryContributor} contributes clauses to the
    ongoing search query.
  \item
    \texttt{GuestbookModelPreFilterContributor} controls how search
    results are filtered before they're returned from the search engine.
  \end{itemize}
\item
  Generating Result Summaries:

  \begin{itemize}
  \tightlist
  \item
    \texttt{GuestbookModelSummaryContributor} constructs the result
    summary for Guestbooks, including specifying which fields to use.
  \end{itemize}
\end{itemize}

After creating the search classes, you'll modify the service layer to
update the search index when a guestbook is persisted. Specifically,
\texttt{GuestbookLocalServiceImpl}'s \texttt{addGuestbook},
\texttt{updateGuestbook}, and \texttt{deleteGuestbook} methods are
updated to invoke the guestbook indexer.

In prior versions of Liferay DXP, search and indexing was accomplished
with one \texttt{*Indexer} class that extended \texttt{BaseIndexer}. In
7.0 is a new pattern that relies on
\href{https://stackoverflow.com/questions/2399544/difference-between-inheritance-and-composition}{composition
instead of inheritance}. If you want to use the old approach, feel free
to extend \texttt{BaseIndexer}. It's still supported.

Since there's no reason to search for guestbooks in the UI, only
back-end work is necessary.

Let's Go!{}

\section{Understanding Search and
Indexing}\label{understanding-search-and-indexing}

\begin{verbatim}
<p id="stepTitle">Enabling Search and Indexing for Guestbooks</p><p>Step 1 of 6</p>
\end{verbatim}

By default, Liferay DXP uses Elasticsearch, a search engine backed by
the popular Lucene search library, to implement its search and indexing
functionality. You could search the database, but that requires
resource-hogging table merges. Instead, a search engine like
Elasticsearch converts searchable entities into \emph{documents}. In
Elasticsearch, documents are searchable database entities converted into
JSON objects. After you implement indexing for guestbook entries,
Liferay DXP creates a document for each entry. The indexing code
specifies which guestbook entry fields to add to each guestbook entry
document, and it adds all the guestbook entry documents to an index. A
search returns a \emph{hits} object containing pointers to documents
matching the search query. Searching for entities with a search engine
via an index is faster than searching for entities in the database.
Elasticsearch provides some additional features like relevancy scoring
and fuzzy search queries.

Along with the search engine, Liferay DXP has its own search
infrastructure. Liferay DXP adds the following features to the existing
Elasticsearch API:

\begin{itemize}
\tightlist
\item
  Indexed documents include the fields needed by Liferay DXP (e.g.,
  \texttt{entryClassName}, \texttt{entryClassPK},
  \texttt{assetTagNames}, \texttt{assetCategories}, \texttt{companyId},
  \texttt{groupId}, staging status).
\item
  It ensures the scope of returned search results is appropriate by
  applying the right filters to search requests.
\item
  It provides permission checking and hit summaries to display in the
  search portlet.
\end{itemize}

To understand how the search and indexing code presented here makes your
custom models seamlessly searchable, you must know how to influence each
portion of the search and indexing cycle:

\textbf{Indexing}: Model entities store data fields in the database. For
example, Guestbooks store the \emph{name} field. During the cycle's
Indexing step, you prepare the model entity to be searchable by defining
the model's fields that are sent to the search engine, later used during
a search.

\textbf{To influence the way model entity fields are indexed in search
engine documents,}

\texttt{ModelDocumentContributor} classes specify which database fields
are indexed in the model entity's search engine documents. This class's
\texttt{contribute} method is called each time the \texttt{add} and
\texttt{update} methods in the entity's service layer are called.

\texttt{ModelIndexerWriterContributor} classes configure the re-indexing
and batch re-indexing behavior for the model entity. This class's method
is called when a re-index is triggered from the Search administrative
application found in Control Panel → Configuration → Search.

\textbf{Searching:} Most searches start with a user entering keywords
into a search bar. The entered keywords are processed by the back-end
search infrastructure, transformed into a \emph{query} the search engine
can understand, and used to match against each search document's fields.

\textbf{To exert control over the way your model entity documents are
searched,}

\texttt{KeywordQueryContributor} classes contribute clauses to the
ongoing search query. This is called at search time, and ensures that
all the fields you indexed are also the ones searched. For example, if
you index fields with the Site locale appended to them
(\texttt{title\_en\_us}, for example), you want the search query to
include the same locale when the document is searched. If the search
query contain another locale (like \texttt{title\_es\_ES}) or searches
the plain field (\texttt{title}), inaccurate results are returned.

\texttt{ModelPreFilterContributor}s control how search results are
filtered before they're returned from the search engine. For example,
adding the workflow status to the query ensures that an entity in the
trash isn't returned in the search results. For the Guestbook
application, a \texttt{ModelPrefilterContributor} isn't necessary until
you get to the section on workflow-enabling Guestbooks.

\textbf{Returning Results:} When a model entity's indexed search
document is obtained during a search request, it's converted into a
summary of the model entity.

\textbf{To influence the result summaries for your model entity
documents,}

\texttt{ModelSummaryContributor} classes get the \texttt{Summary} object
created for each search document, so you can manipulate it by adding
specific fields or setting the length of the displayed content.

\texttt{ModelVisibilityContributor} classes control the visibility of
model entities that can be attached to other asset types (for example,
File Entries can be attached to Wiki Pages), in the search context.
Since Guestbooks and Guestbook entries won't be attached to other
assets, a model visibility contributor isn't necessary.

One important step must occur to make sure the above classes are
discovered by the search framework.

\textbf{Registration}

To register the model entity with Liferay's search framework,

\texttt{SearchRegistrar}s use the search framework's registry to define
certain things about your model entity's \texttt{ModelSearchDefinition}:
which fields are used by default to retrieve documents from the search
engine, and which optional search services are registered for your
entity. Registration occurs as soon as the Component is activated
(during portal startup).

Let's index some Guestbooks, shall we?

\section{Registering Guestbooks with the Search
Framework}\label{registering-guestbooks-with-the-search-framework}

\begin{verbatim}
<p id="stepTitle">Enabling Search and Indexing for Guestbooks</p><p>Step 2 of 6</p>
\end{verbatim}

First, update your \texttt{build.gradle} to have all of the necessary
imports.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open the \texttt{build.gradle} file in your \texttt{guestbook-service}
  project.
\item
  Add the Search Service Provider Interface and API dependencies to the
  \texttt{build.gradle} file:

\begin{verbatim}
compileOnly group: "com.liferay", name: "com.liferay.portal.search.spi", version: "2.0.0"
compileOnly group: "com.liferay", name: "com.liferay.portal.search.api", version: "2.0.0"
\end{verbatim}
\item
  Save the file and run \texttt{Refresh\ Gradle\ Project}.
\end{enumerate}

Once the dependency is configured, register the Search services that
build the entity's \texttt{ModelSearchDefinition}.

A \texttt{*SearchRegistrar} specifies the classes that the entity uses
to contribute to building a \texttt{ModelSearchDefinition}. Activation
of the \texttt{SearchRegistrar} component results in a cascade of
activity in the search framework, culminating with the building of a
\texttt{DefaultIndexer}. The \texttt{DefaultIndexer} is registered under
the class name defined in the registrar, and then used for
indexing/searching objects of that class.

Create the \texttt{GuestbookSearchRegistrar}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a new package in the \texttt{guestbook-service} module
  project's \texttt{src/main/java} folder called
  \texttt{com.liferay.docs.guestbook.search}. In this package, create a
  new class called \texttt{GuestbookSearchRegistrar} and populate it
  with two methods, \texttt{activate} and \texttt{deactivate}.

\begin{verbatim}
@Component(immediate = true)
public class GuestbookSearchRegistrar {

    @Activate
    protected void activate(BundleContext bundleContext) {

        _serviceRegistration = modelSearchRegistrarHelper.register(
            Guestbook.class, bundleContext, modelSearchDefinition -> {
                modelSearchDefinition.setDefaultSelectedFieldNames(
                    Field.ASSET_TAG_NAMES, Field.COMPANY_ID, Field.CONTENT,
                    Field.ENTRY_CLASS_NAME, Field.ENTRY_CLASS_PK,
                    Field.GROUP_ID, Field.MODIFIED_DATE, Field.SCOPE_GROUP_ID,
                    Field.TITLE, Field.UID);

                modelSearchDefinition.setModelIndexWriteContributor(
                    modelIndexWriterContributor);
                modelSearchDefinition.setModelSummaryContributor(
                    modelSummaryContributor);
            });
    }

    @Deactivate
    protected void deactivate() {

        _serviceRegistration.unregister();
    }
\end{verbatim}

  The annotations \texttt{@Activate} and \texttt{Deactivate} ensure each
  method is invoked as soon as the Component is started (activated) or
  when it's about to be stopped (deactivated). On activation of the
  Component, a chain of search and indexing classes is registered for
  the Guestbook entity. Set the default selected field names used to
  retrieve results documents from the search engine. Then set the
  contributors used to build a model search definition.
\item
  Specify the service references for the class:

\begin{verbatim}
    @Reference(target = "(indexer.class.name=com.liferay.docs.guestbook.model.Guestbook)")
    protected ModelIndexerWriterContributor<Guestbook> modelIndexWriterContributor;

    @Reference
    protected ModelSearchRegistrarHelper modelSearchRegistrarHelper;

    @Reference(target = "(indexer.class.name=com.liferay.docs.guestbook.model.Guestbook)")
    protected ModelSummaryContributor modelSummaryContributor;

    private ServiceRegistration<?> _serviceRegistration;

}
\end{verbatim}

  Target the \texttt{Guestbook} model while looking up a reference to
  the contributor classes. Later, when you create these contributor
  classes, you'll specify the model name again to complete the circle.
\item
  Add the imports by Organizing Imports (Ctrl-Shift-O).
\item
  Export the \texttt{com.liferay.docs.guestbook.search} package in the
  \texttt{guestbook-service} module's \texttt{bnd.bnd} file. The export
  section should look like this:

\begin{verbatim}
 Export-Package: com.liferay.docs.guestbook.search
\end{verbatim}
\end{enumerate}

The Guestbook search and indexing class registration is completed. Next
write the search and indexing logic.

\section{Indexing Guestbooks}\label{indexing-guestbooks}

\begin{verbatim}
<p id="stepTitle">Enabling Search and Indexing for Guestbooks</p><p>Step 3 of 6</p>
\end{verbatim}

To control how Guestbook objects are translated into search engine
documents, create two classes in the new search package:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Implement a \texttt{ModelDocumentContributor} that ``contributes''
  fields to a search document indexed by the search engine. The main
  searchable field for guestbooks is the guestbook name.
\item
  \texttt{ModelIndexerWriterContributor} configures the batch indexing
  behavior for Guestbooks. This code is executed when Guestbooks are
  re-indexed from the Search administration section of the Control
  Panel.
\end{enumerate}

\subsection{\texorpdfstring{Implementing
\texttt{ModelDocumentContributor}}{Implementing ModelDocumentContributor}}\label{implementing-modeldocumentcontributor}

Create \texttt{GuestbookModelDocumentContributor} and populate it with
this:

\begin{verbatim}
@Component(
        immediate = true,
        property = "indexer.class.name=com.liferay.docs.guestbook.model.Guestbook",
        service = ModelDocumentContributor.class
)
public class GuestbookModelDocumentContributor
    implements ModelDocumentContributor<Guestbook> {

    @Override
    public void contribute(Document document, Guestbook guestbook) {
        try {
            document.addDate(Field.MODIFIED_DATE, guestbook.getModifiedDate());

            Locale defaultLocale = PortalUtil.getSiteDefaultLocale(
    guestbook.getGroupId());

            String localizedTitle = LocalizationUtil.getLocalizedName(
    Field.TITLE, defaultLocale.toString());

            document.addText(localizedTitle, guestbook.getName());
        } catch (PortalException pe) {
            if (_log.isWarnEnabled()) {
                _log.warn(
    "Unable to index guestbook " + guestbook.getGuestbookId(), pe);
            }
        }
    }

    private static final Log _log = LogFactoryUtil.getLog(
    GuestbookModelDocumentContributor.class);

}
\end{verbatim}

Because Liferay DXP supports localization, you should too. The above
code gets the default locale from the Site by passing the
\texttt{Guestbook}'s group ID to the \texttt{getSiteDefaultLocale}
method, then using it to get the localized name of the Guestbook's title
field. The retrieved Site locale is appended to the field (e.g.,
\texttt{title\_en\_US}), so the field gets passed to the search engine
and goes through the right analysis and
\href{https://www.elastic.co/guide/en/elasticsearch/reference/2.4/analysis-tokenizers.html}{tokenization}.

\subsection{\texorpdfstring{Implementing
\texttt{ModelIndexerWriterContributor}}{Implementing ModelIndexerWriterContributor}}\label{implementing-modelindexerwritercontributor}

Create \texttt{GuestbookModelIndexerWriterContributor} and populate it
with this:

\begin{verbatim}
@Component(
        immediate = true,
        property = "indexer.class.name=com.liferay.docs.guestbook.model.Guestbook",
        service = ModelIndexerWriterContributor.class
)
public class GuestbookModelIndexerWriterContributor
    implements ModelIndexerWriterContributor<Guestbook> {

    @Override
    public void customize(
        BatchIndexingActionable batchIndexingActionable,
        ModelIndexerWriterDocumentHelper modelIndexerWriterDocumentHelper) {

        batchIndexingActionable.setPerformActionMethod((Guestbook guestbook) -> {
            Document document = modelIndexerWriterDocumentHelper.getDocument(
    guestbook);

            batchIndexingActionable.addDocuments(document);
        });
    }

    @Override
    public BatchIndexingActionable getBatchIndexingActionable() {
        return dynamicQueryBatchIndexingActionableFactory.getBatchIndexingActionable(
    guestbookLocalService.getIndexableActionableDynamicQuery());
    }

    @Override
    public long getCompanyId(Guestbook guestbook) {
        return guestbook.getCompanyId();
    }

    @Override
    public void modelIndexed(Guestbook guestbook) {
        entryBatchReindexer.reindex(
    guestbook.getGuestbookId(), guestbook.getCompanyId());
    }

    @Reference
    protected DynamicQueryBatchIndexingActionableFactory
    dynamicQueryBatchIndexingActionableFactory;

    @Reference
    protected EntryBatchReindexer entryBatchReindexer;

    @Reference
    protected GuestbookLocalService guestbookLocalService;

}
\end{verbatim}

First look at the \texttt{customize} method. Configure the batch
indexing behavior for the entity's documents by calling
\texttt{BatchIndexingActionable} methods. This code uses the Guestbook's
actionable dynamic query helper method to retrieve all Guestbooks in the
virtual instance (identified by the Company ID). Service Builder
generated this query method for you when you built the services. Each
Guestbook's document is then retrieved and added to a collection.

When you write the indexing classes for Entries, you'll add the
Guestbook title to the Entry document. Thus, you must provide a way to
update the indexed Entry documents if a Guestbook title is changed. The
\texttt{modelIndexed} method calls a \texttt{reindex} method from an
interface that will be created later for Entries.

Once the re-indexing behavior is in place, you can move on to
controlling how Guestbook documents are queried from the search engine.

\section{Querying for Guestbook
Documents}\label{querying-for-guestbook-documents}

\begin{verbatim}
<p id="stepTitle">Enabling Search and Indexing for Guestbooks</p><p>Step 4 of 6</p>
\end{verbatim}

The code is in place for for indexing Guestbooks to the search engine.
Next, you'll code the behavior necessary for querying the indexed
documents.

Implement two interfaces:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \texttt{KeywordQueryContributor} contributes clauses to the ongoing
  search query.
\item
  \texttt{ModelPreFilterContributor} controls how search results are
  filtered before they're returned from the search engine.
\end{enumerate}

\subsection{\texorpdfstring{Implementing
\texttt{KeywordQueryContributor}}{Implementing KeywordQueryContributor}}\label{implementing-keywordquerycontributor}

Create \texttt{GuestbookKeywordQueryContributor}:

\begin{verbatim}
@Component(
        immediate = true,
        property = "indexer.class.name=com.liferay.docs.guestbook.model.Guestbook",
        service = KeywordQueryContributor.class
)
public class GuestbookKeywordQueryContributor
    implements KeywordQueryContributor {

    @Override
    public void contribute(
        String keywords, BooleanQuery booleanQuery,
        KeywordQueryContributorHelper keywordQueryContributorHelper) {

        SearchContext searchContext =
    keywordQueryContributorHelper.getSearchContext();

        queryHelper.addSearchLocalizedTerm(
    booleanQuery, searchContext, Field.TITLE, false);
    }

    @Reference
    protected QueryHelper queryHelper;

}
\end{verbatim}

This class adds Guestbook fields to the search query constructed by the
Search application in Liferay DXP. Later, when you asset enable
Guestbooks, this code will allow indexed Guestbooks to be searched from
the Search application when a keyword is entered into the search bar.
Use the query helper to add search terms to the query that allow
Guestbooks to be found. Here it's important to note that adding the
localized search term is important. Since the localized Guestbook title
was indexed, you must retrieve the localized value from the search
engine.

Once the query code is in place, define how returned Guestbook documents
are summarized.

\section{Generating Results
Summaries}\label{generating-results-summaries}

\begin{verbatim}
<p id="stepTitle">Enabling Search and Indexing for Guestbooks</p><p>Step 5 of 6</p>
\end{verbatim}

The Search application and the Asset Publisher application must display
results retrieved from the search engine. Control the summarized content
by implementing a \texttt{ModelSummaryContributor}.

A summary is a condensed, text-based version of the entity's document
that can be displayed generically. You create it by combining key parts
of the entity's data so users can browse through search resmlts to find
the entity they want.

Create a \texttt{GuestbookModelSummaryContributor}:

\begin{verbatim}
@Component(
        immediate = true,
        property = "indexer.class.name=com.liferay.docs.guestbook.model.Guestbook",
        service = ModelSummaryContributor.class
)
public class GuestbookModelSummaryContributor
    implements ModelSummaryContributor {

    @Override
    public Summary getSummary(
        Document document, Locale locale, String snippet) {

        Summary summary = createSummary(document);

        summary.setMaxContentLength(200);

        return summary;
    }

    private Summary createSummary(Document document) {
        String prefix = Field.SNIPPET + StringPool.UNDERLINE;

        String title = document.get(prefix + Field.TITLE, Field.TITLE);

        return new Summary(title, StringPool.BLANK);
    }

}
\end{verbatim}

First override \texttt{getSummary} and set the maximum summary length on
the summary returned. The value \texttt{200} is a Liferay standard.
Control the summary creation in a utility method called
\texttt{createSummary}. Create a \texttt{prefix} variable using two
constants, \texttt{Field.SNIPPET} and \texttt{Stringpool.UNDERLINE}. The
\texttt{snippet\_title} field is returned from the \texttt{document.get}
call, and added to the summary. Using the snippet field provides two
benefits:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Snippet text can be highlighted so matching keywords are emphasized.
\item
  Snippet text can be shortened automatically by the Search application
  so a sensible portion of the field's text is displayed in the search
  results.
\end{enumerate}

Guestbook titles are likely short, so only the highlighting behavior is
useful for the title field of Guestbooks. For longer fields (like some
\texttt{content} fields), the clipping behavior is more useful.
Additional highlighting behavior can be configured via the
\texttt{index.search.highlight.*} properties in
\href{https://docs.liferay.com/portal/7.1-latest/propertiesdoc/portal.properties.html\#Lucene\%20Search}{portal.properties}.

Create summaries by combining key parts of the entity's data so users
can browse through search results to find the entity they want.

Once all the search and indexing logic is in place, update the service
layer so \texttt{add}, \texttt{update}, and \texttt{delete} service
calls trigger the new logic.

\section{Handling Indexing in the Guestbook Service
Layer}\label{handling-indexing-in-the-guestbook-service-layer}

\begin{verbatim}
<p id="stepTitle">Enabling Search and Indexing for Guestbooks</p><p>Step 6 of 6</p>
\end{verbatim}

Whenever a Guestbook database entity is added, updated, or deleted, the
search index must be updated accordingly. The Liferay DXP annotation
\texttt{@Indexable} combines with the \texttt{IndexableType} to mark
your service methods so documents can be updated or deleted. Annotate
\texttt{addGuestbook}, \texttt{updateGuestbook}, and
\texttt{deleteGuestbook} service methods.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open \texttt{GuestbookLocalServiceImpl} in the
  \texttt{guestbook-service} module's
  \texttt{com.liferay.docs.guestbook.service.impl} package, and add the
  following annotation above the method signature for the
  \texttt{addGuestbook} and \texttt{updateGuestbook} methods:

\begin{verbatim}
@Indexable(type = IndexableType.REINDEX)
public Guestbook addGuestbook(...)

@Indexable(type = IndexableType.REINDEX)
public Guestbook updateGuestbook(...)
\end{verbatim}

  The \texttt{@Indexable} annotation indicates that an index update is
  required following the method execution. The indexing classes control
  the type of index: setting the \texttt{@Indexable} annotation type to
  \texttt{IndexableType.REINDEX} updates the document in the index that
  corresponds to the updated Guestbook.
\item
  Add the following annotation above the method signature for the
  \texttt{deleteGuestbook} method:

\begin{verbatim}
@Indexable(type = IndexableType.DELETE)
public Guestbook deleteGuestbook(...)
\end{verbatim}

  When a Guestbook is deleted from the database, its document shouldn't
  remain in the search index. This ensures that it is deleted.
\item
  Add the necessary imports:

\begin{verbatim}
import com.liferay.portal.kernel.search.Indexable;
import com.liferay.portal.kernel.search.IndexableType;
\end{verbatim}

  Save the file.
\item
  In the Gradle Tasks pane on the right-hand side of Liferay Dev Studio
  DXP, double-click \texttt{buildService} in \texttt{guestbook-service}
  → \texttt{build}. This re-runs Service Builder to incorporate your
  changes to \texttt{GuestbookLocalServiceImpl}.
\end{enumerate}

Next, you'll enable search and indexing for Guestbook Entries.

\chapter{Enabling Search and Indexing for
Entries}\label{enabling-search-and-indexing-for-entries}

In this section, you'll create the classes that control these aspects of
the search functionality:

\begin{itemize}
\item
  Registration:

  \begin{itemize}
  \tightlist
  \item
    \texttt{EntrySearchRegistrar} registers the search service for the
    Entry entity.
  \end{itemize}
\item
  Indexing:

  \begin{itemize}
  \item
    \texttt{EntryModelDocumentContributor} controls which Entry fields
    are indexed in the search engine.
  \item
    \texttt{EntryModelIndexerWriterContributor} configures the
    re-indexing and batch re-indexing behavior for Entries.
  \item
    \texttt{EntryBatchReindexer}, an interface, and its
    \texttt{EntryBatchReindexerImpl}, for re-indexing Entries when their
    Guestbook is updated.
  \end{itemize}
\item
  Querying:

  \begin{itemize}
  \item
    \texttt{EntryKeywordQueryContributor} contributes clauses to the
    ongoing search query.
  \item
    \texttt{EntryModelPreFilterContributor} controls how search results
    are filtered before they're returned from the search engine.
  \end{itemize}
\item
  Generating Result Summaries:

  \begin{itemize}
  \tightlist
  \item
    \texttt{EntryModelSummaryContributor} constructs the result summary
    for Entries, including specifying which fields to use.
  \end{itemize}
\end{itemize}

After creating the search classes, modify the service layer to update
the search index when an Entry is persisted:

\begin{itemize}
\tightlist
\item
  Update \texttt{EntryLocalServiceImpl}'s \texttt{addEntry},
  \texttt{updateEntry}, and \texttt{deleteEntry} methods to update the
  index so it matches the databse.
\end{itemize}

\noindent\hrulefill

\textbf{Note:} In prior versions of Liferay DXP, search and indexing was
accomplished with one \texttt{*Indexer} class that extended
\texttt{BaseIndexer}. This Learning Path demonstrates a new pattern that
relies on
\href{https://stackoverflow.com/questions/2399544/difference-between-inheritance-and-composition}{composition
instead of inheritance}. If you desire to use the old approach, feel
free to extend \texttt{BaseIndexer}. It's still supported.

\noindent\hrulefill

Let's Go!{}

\section{Registering Entries with the Search
Framework}\label{registering-entries-with-the-search-framework}

\begin{verbatim}
<p id="stepTitle">Enabling Search and Indexing for Entries</p><p>Step 1 of 5</p>
\end{verbatim}

The search registrar for Entries is very similar to the one created for
Guestbooks. You'll even put it in the same package
(\texttt{com.liferay.docs.guestbook.search}).

Create the \texttt{EntrySearchRegistrar}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In \texttt{com.liferay.docs.guestbook.search}, create a new class
  called \texttt{EntrySearchRegistrar} and populate it with two methods,
  \texttt{activate} and \texttt{deactivate}.

\begin{verbatim}
@Component(immediate = true)
public class EntrySearchRegistrar {

    @Activate
    protected void activate(BundleContext bundleContext) {

        _serviceRegistration = modelSearchRegistrarHelper.register(
            Entry.class, bundleContext, modelSearchDefinition -> {
                modelSearchDefinition.setDefaultSelectedFieldNames(
                    Field.COMPANY_ID, Field.ENTRY_CLASS_NAME,
                    Field.ENTRY_CLASS_PK, Field.UID, 
                    Field.SCOPE_GROUP_ID, Field.GROUP_ID);

                modelSearchDefinition.setDefaultSelectedLocalizedFieldNames(
                    Field.TITLE, Field.CONTENT);

                modelSearchDefinition.setModelIndexWriteContributor(
                    modelIndexWriterContributor);
                modelSearchDefinition.setModelSummaryContributor(
                    modelSummaryContributor);
                modelSearchDefinition.setSelectAllLocales(true);

            });
    }

    @Deactivate
    protected void deactivate() {
        _serviceRegistration.unregister();
    }
\end{verbatim}
\end{enumerate}

As you did with Guestbooks, set the default selected field names used to
retrieve results documents from the search engine. For Entries, call
\texttt{setDefaultSelectedLocalizedFieldNames} for the title and content
fields. This ensures that the localized version of the field is searched
and returned. The only other difference with Entries is the call to
\texttt{setSelectAllLocales(true)}. It takes the fields set in
\texttt{setDefaultSelectedLocalizedFieldNames} and sets those fields for
each available locale in the \texttt{stored\_fields} parameter of the
search request. If not set to \texttt{true}, only a single locale is
searched.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\item
  Specify the service references for the class:

\begin{verbatim}
    @Reference(target = "(indexer.class.name=com.liferay.docs.guestbook.model.Entry)")
    protected ModelIndexerWriterContributor<Entry> modelIndexWriterContributor;

    @Reference
    protected ModelSearchRegistrarHelper modelSearchRegistrarHelper;

    @Reference(target = "(indexer.class.name=com.liferay.docs.guestbook.model.Entry)")
    protected ModelSummaryContributor modelSummaryContributor;

    private ServiceRegistration<?> _serviceRegistration;

}
\end{verbatim}

  Target the \texttt{Entry} model while looking up a reference to the
  contributor classes. Later, when you create these contributor classes,
  you'll specify the model name again to complete the circle.
\end{enumerate}

The Entry search and indexing class registration is completed. Next
write the search and indexing logic.

\section{Indexing Entries}\label{indexing-entries}

\begin{verbatim}
<p id="stepTitle">Enabling Search and Indexing for Entries</p><p>Step 2 of 5</p>
\end{verbatim}

To control how Entry objects are translated into search engine
documents, create these classes in the search package:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \texttt{ModelDocumentContributor}: The main searchable fields for
  Entries are \emph{Name} and \emph{Message}. The Guestbook name
  associated with the entry is indexed, too.
\item
  \texttt{ModelIndexerWriterContributor} configures the batch indexing
  behavior for Entries. This code is executed when Entries are
  re-indexed from the Search administration section of the Control
  Panel.
\item
  A new interface, \texttt{EntryBatchReindexer}, with its
  implementation, \texttt{EntryBatchReindexerImpl}. These classes
  contain code to ensure that Entries are re-indexed when their
  Guestbook is updated.
\end{enumerate}

\subsection{\texorpdfstring{Implementing
\texttt{ModelDocumentContributor}}{Implementing ModelDocumentContributor}}\label{implementing-modeldocumentcontributor-1}

Create \texttt{EntryModelDocumentContributor} and populate it with this:

\begin{verbatim}
@Component(
        immediate = true,
        property = "indexer.class.name=com.liferay.docs.guestbook.model.Entry",
        service = ModelDocumentContributor.class
)
public class EntryModelDocumentContributor
    implements ModelDocumentContributor<Entry> {

    @Override
    public void contribute(Document document, Entry entry) {
        try {
            Locale defaultLocale = PortalUtil.getSiteDefaultLocale(
    entry.getGroupId());

            document.addDate(Field.MODIFIED_DATE, entry.getModifiedDate());
            document.addText("entryEmail", entry.getEmail());

            String localizedTitle = LocalizationUtil.getLocalizedName(
    Field.TITLE, defaultLocale.toString());
            String localizedContent = LocalizationUtil.getLocalizedName(
    Field.CONTENT, defaultLocale.toString());

            document.addText(localizedTitle, entry.getName());
            document.addText(localizedContent, entry.getMessage());

            long guestbookId = entry.getGuestbookId();

            Guestbook guestbook = _guestbookLocalService.getGuestbook(
    guestbookId);

            String guestbookName = guestbook.getName();

            String localizedGbName = LocalizationUtil.getLocalizedName(
    Field.NAME, defaultLocale.toString());

            document.addText(localizedGbName, guestbookName);
        } catch (PortalException pe) {
            if (_log.isWarnEnabled()) {
                _log.warn("Unable to index entry " + entry.getEntryId(), pe);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private static final Log _log = LogFactoryUtil.getLog(
    EntryModelDocumentContributor.class);

    @Reference
    private GuestbookLocalService _guestbookLocalService;

}
\end{verbatim}

As with Guestbooks, add the localized values for fields that might be
translated. The Site locale is appended to the field (e.g.,
\texttt{title\_en\_US}), so the field gets passed to the search engine
and goes through the right analysis and
\href{https://www.elastic.co/guide/en/elasticsearch/reference/2.4/analysis-tokenizers.html}{tokenization}.

\subsection{\texorpdfstring{Implementing
\texttt{ModelIndexerWriterContributor}}{Implementing ModelIndexerWriterContributor}}\label{implementing-modelindexerwritercontributor-1}

Create \texttt{EntryModelIndexerWriterContributor} and populate it with
this:

\begin{verbatim}
@Component(
        immediate = true,
        property = "indexer.class.name=com.liferay.docs.guestbook.model.Entry",
        service = ModelIndexerWriterContributor.class
)
public class EntryModelIndexerWriterContributor
    implements ModelIndexerWriterContributor<Entry> {

    @Override
    public void customize(
        BatchIndexingActionable batchIndexingActionable,
        ModelIndexerWriterDocumentHelper modelIndexerWriterDocumentHelper) {

        batchIndexingActionable.setPerformActionMethod((Entry entry) -> {
            Document document = modelIndexerWriterDocumentHelper.getDocument(
    entry);

            batchIndexingActionable.addDocuments(document);
            
        });
    }

    @Override
    public BatchIndexingActionable getBatchIndexingActionable() {
        return dynamicQueryBatchIndexingActionableFactory.getBatchIndexingActionable(
    entryLocalService.getIndexableActionableDynamicQuery());
    }

    @Override
    public long getCompanyId(Entry entry) {
        return entry.getCompanyId();
    }

    @Reference
    protected DynamicQueryBatchIndexingActionableFactory
    dynamicQueryBatchIndexingActionableFactory;

    @Reference
    protected EntryLocalService entryLocalService;

}
\end{verbatim}

The interesting work is done in the \texttt{customize} method, where all
Entries are retrieved and added to a collection.

\subsection{\texorpdfstring{Implementing
\texttt{EntryBatchReindexer}}{Implementing EntryBatchReindexer}}\label{implementing-entrybatchreindexer}

Create a new interface class, \texttt{EntryBatchReindexer}, with one
method called \texttt{reindex}:

\begin{verbatim}
package com.liferay.docs.guestbook.search;

public interface EntryBatchReindexer {

    public void reindex(long guestbookId, long companyId);

}
\end{verbatim}

Then create the implementation class, \texttt{EntryBatchReindexerImpl}:

\begin{verbatim}
@Component(immediate = true, service = EntryBatchReindexer.class)
public class EntryBatchReindexerImpl implements EntryBatchReindexer {

    @Override
    public void reindex(long guestbookId, long companyId) {
        BatchIndexingActionable batchIndexingActionable =
    indexerWriter.getBatchIndexingActionable();

        batchIndexingActionable.setAddCriteriaMethod(dynamicQuery -> {
            Property guestbookIdPropery = PropertyFactoryUtil.forName(
    "guestbookId");

            dynamicQuery.add(guestbookIdPropery.eq(guestbookId));
        });

        batchIndexingActionable.setCompanyId(companyId);

        batchIndexingActionable.setPerformActionMethod((Entry entry) -> {
            Document document = indexerDocumentBuilder.getDocument(entry);

            batchIndexingActionable.addDocuments(document);
        });

        batchIndexingActionable.performActions();
        
    }

    @Reference(target = "(indexer.class.name=com.liferay.docs.guestbook.model.Entry)")
    protected IndexerDocumentBuilder indexerDocumentBuilder;

    @Reference(target = "(indexer.class.name=com.liferay.docs.guestbook.model.Entry)")
    protected IndexerWriter<Entry> indexerWriter;

}

The `reindex` method of the interface is called when a Guestbook is updated.
The entry documents are re-indexed to include the update Guestbook title.
\end{verbatim}

Once the re-indexing behavior is in place, move on to the code for
controlling how Entry documents are queried from the search engine.

\section{Querying for Entry
Documents}\label{querying-for-entry-documents}

\begin{verbatim}
<p id="stepTitle">Enabling Search and Indexing for Entries</p><p>Step 3 of 5</p>
\end{verbatim}

The code is in place for indexing Entries to the search engine. Next
code the behavior necessary for querying the indexed documents.

Implement two classes:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \texttt{EntryKeywordQueryContributor} contributes clauses to the
  ongoing search query.
\item
  \texttt{EntryModelPreFilterContributor} controls how search results
  are filtered before they're returned from the search engine.
\end{enumerate}

\subsection{\texorpdfstring{Implementing
\texttt{KeywordQueryContributor}}{Implementing KeywordQueryContributor}}\label{implementing-keywordquerycontributor-1}

Create \texttt{EntryKeywordQueryContributor} and populate it with this:

\begin{verbatim}
@Component(
        immediate = true,
        property = "indexer.class.name=com.liferay.docs.guestbook.model.Entry",
        service = KeywordQueryContributor.class
)
public class EntryKeywordQueryContributor implements KeywordQueryContributor {

    @Override
    public void contribute(
        String keywords, BooleanQuery booleanQuery,
        KeywordQueryContributorHelper keywordQueryContributorHelper) {

        SearchContext searchContext =
    keywordQueryContributorHelper.getSearchContext();

        queryHelper.addSearchLocalizedTerm(
    booleanQuery, searchContext, Field.TITLE, false);
        queryHelper.addSearchLocalizedTerm(
    booleanQuery, searchContext, Field.CONTENT, false);
        queryHelper.addSearchLocalizedTerm(
    booleanQuery, searchContext, "entryEmail", false);
    }

    @Reference
    protected QueryHelper queryHelper;

}
\end{verbatim}

Adding the localized search terms is important. For all localized Entry
fields in the index, retrieve the localized value from the search
engine.

Now that the query code is in place, you can define how returned Entry
documents are summarized.

\section{Generating Results
Summaries}\label{generating-results-summaries-1}

\begin{verbatim}
<p id="stepTitle">Enabling Search and Indexing for Entries</p><p>Step 3 of 5</p>
\end{verbatim}

The Search application and the Asset Publisher application display
results retrieved from the search engine. You can control the display by
implementing a \texttt{ModelSummaryContributor}.

Create a \texttt{EntryModelSummaryContributor}:

\begin{verbatim}
@Component(
        immediate = true,
        property = "indexer.class.name=com.liferay.docs.guestbook.model.Entry",
        service = ModelSummaryContributor.class
)
public class EntryModelSummaryContributor implements ModelSummaryContributor {

    @Override
    public Summary getSummary(
        Document document, Locale locale, String snippet) {

        Summary summary = createSummary(document);

        summary.setMaxContentLength(128);

        return summary;
    }

    private Summary createSummary(Document document) {
        String prefix = Field.SNIPPET + StringPool.UNDERLINE;

        String title = document.get(prefix + Field.TITLE, Field.CONTENT);
        String content = document.get(prefix + Field.CONTENT, Field.CONTENT);

        return new Summary(title, content);
    }

}
\end{verbatim}

First override \texttt{getSummary}, and set the maximum summary length
on the summary returned. The value \texttt{200} is a Liferay standard.
Control the summary creation in a utility method called
\texttt{createSummary}. Guestbooks only included the title in the
summary, but Entries use the title and the content (the Entry message
field) to populate the summary.

Create summaries by combining key parts of the entity's data.

Now that the search and indexing logic is in place, you can update the
service layer so \texttt{add}, \texttt{update}, and \texttt{delete}
service calls trigger the new logic.

\section{Handling Indexing in the Entry Service
Layer}\label{handling-indexing-in-the-entry-service-layer}

\begin{verbatim}
<p id="stepTitle">Enabling Search and Indexing for Entries</p><p>Step 5 of 5</p>
\end{verbatim}

Whenever an Entry is added, updated, or deleted, the corresponding
document should also be updated or deleted. A minor update to each of
the \texttt{addEntry}, \texttt{updateEntry}, and \texttt{deleteEntry}
service methods for Entries is all it takes.

Follow these steps to update the methods:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open \texttt{EntryLocalServiceImpl} in the \texttt{guestbook-service}
  module's \texttt{com.liferay.docs.guestbook.service.impl} package, and
  add the annotation \texttt{@Indexable(type\ =\ IndexableType.REINDEX)}
  above the signature for the \texttt{addEntry} and \texttt{updateEntry}
  methods:

\begin{verbatim}
@Indexable(type = IndexableType.REINDEX)
public Entry addEntry(...)

@Indexable(type = IndexableType.REINDEX)
public Entry updateEntry(...)
\end{verbatim}

  The \texttt{@Indexable} annotation indicates that an index update is
  required following method execution. The indexing classes control
  exactly how the indexing happens. Setting the \texttt{@Indexable}
  annotation's type to \texttt{IndexableType.REINDEX} updates the
  indexed document that corresponds to the updated Entry.
\item
  Add the \texttt{@Indexable(type\ =\ IndexableType.DELETE)} annotation
  above the signature for the \texttt{deleteEntry} method. The indexable
  type \texttt{IndexableType.DELETE} ensures that the Entry is deleted
  from the index:

\begin{verbatim}
@Indexable(type = IndexableType.DELETE)
public Entry deleteEntry(...)
\end{verbatim}
\item
  Add the required imports:

\begin{verbatim}
import com.liferay.portal.kernel.search.Indexable;
import com.liferay.portal.kernel.search.IndexableType;
\end{verbatim}

  Save the file.
\item
  In the Gradle Tasks pane on the right-hand side of Liferay Dev Studio
  DXP, double-click \texttt{buildService} in \texttt{guestbook-service}
  → \texttt{build}. This re-runs Service Builder to incorporate your
  changes to \texttt{EntryLocalServiceImpl}.
\end{enumerate}

Guestbooks and their Entries now have search and indexing support in the
back-end. Next, you'll enable search in the Guestbook portlet's
front-end.

\chapter{Updating Your User Interface For
Search}\label{updating-your-user-interface-for-search}

Updating the Guestbook portlet's user interface for search takes two
steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Update the Guestbook portlet's default view JSP to display a search
  bar for submitting queries.
\item
  Create a new JSP for the Guestbook portlet to display search results.
\end{enumerate}

You'll start by updating the Guestbook portlet's view JSP.

Let's Go!{}

\section{Adding a Search Bar to the Guestbook
Portlet}\label{adding-a-search-bar-to-the-guestbook-portlet}

\begin{verbatim}
<p id="stepTitle">Updating Your UI for Search</p><p>Step 1 of 2</p>
\end{verbatim}

Create the search bar UI for the Guestbook portlet:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In \texttt{guestbook-web}, open the file
  \texttt{src/main/resources/META-INF/resources/guestbookwebportlet/view.jsp}.
  Add a render URL near the top of the file, just after the scriptlet
  that gets the \texttt{guestbookId} from the request:

\begin{verbatim}
<portlet:renderURL var="searchURL">
    <portlet:param name="mvcPath" 
    value="/guestbookwebportlet/view_search.jsp" />
</portlet:renderURL>
\end{verbatim}

  The render URL points to
  \texttt{/guestbookwebportlet/view\_search.jsp} (created in the next
  step). You construct the URL first to specify what happens when the
  user submits a search query.
\item
  Right after the render URL, create an AUI form that adds an input
  field for search keywords and a \emph{Submit} button that executes the
  form action, which is mapped to the \texttt{searchURL}.

\begin{verbatim}
<aui:form action="${searchURL}" name="fm">

    <div class="row">
        <div class="col-md-8">
            <aui:input inlineLabel="left" label="" name="keywords" placeholder="search-entries" size="256" />
        </div>

        <div class="col-md-4">
            <aui:button type="submit" value="search" />
        </div>
    </div>
</aui:form>
\end{verbatim}

  The body of the search form consists of a
  \texttt{\textless{}div\textgreater{}} with one row containing two
  fields: an input field, named \texttt{keywords} and a \emph{Submit}
  button. Its \texttt{name="keywords"} attribute specifies the name of
  the URL parameter that contains the search query. The
  \texttt{\textless{}aui:button\textgreater{}} tag defines the search
  button. The \texttt{type="submit"} attribute specifies that when the
  button is clicked (or the \emph{Enter} key is pressed), the AUI form
  is submitted. The \texttt{value="search"} attribute specifies the name
  that appears on the button.
\end{enumerate}

That's all there is to the search form! When the form is submitted, the
\texttt{mvcPath} parameter pointing to the \texttt{view\_search.jsp} is
included in the URL along with the \texttt{keywords} parameter
containing the search query. Next create the \texttt{view\_search.jsp}
file to display the search results.

\section{Creating a Search Results JSP for the Guestbook
Portlet}\label{creating-a-search-results-jsp-for-the-guestbook-portlet}

\begin{verbatim}
<p id="stepTitle">Updating Your UI for Search</p><p>Step 2 of 2</p>
\end{verbatim}

There are several design goals to implement in the search results JSP:

\begin{itemize}
\tightlist
\item
  Use a search container to display guestbook entries matching a search
  query.
\item
  Make the Actions button available for each guestbook entry in the
  results, like it is in the main view's search container.
\item
  Include the search bar so that users can edit and resubmit their
  queries without having to click the back link to go to the portlet's
  default view.
\end{itemize}

\begin{figure}
\centering
\includegraphics{./images/guestbook-portlet-search-results.png}
\caption{The search results should appear in a search container, and the
Actions button should appear for each entry. The search bar should also
be displayed.}
\end{figure}

Follow these steps to create the search results JSP:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a new file called \texttt{view\_search.jsp} in your
  \texttt{guestbook-web} module's \texttt{/guestbookwebportlet} folder.
  In this file, include the \texttt{init.jsp}:

\begin{verbatim}
<%@include file="../init.jsp"%>
\end{verbatim}
\item
  Extract the \texttt{keywords} and \texttt{guestbookId} parameters from
  the request. The \texttt{keywords} parameter contains the search
  query, and the \texttt{guestbookId} parameter contains the ID of the
  guestbook being searched:

\begin{verbatim}
<%
  String keywords = ParamUtil.getString(request, "keywords");
  long guestbookId = ParamUtil.getLong(renderRequest, "guestbookId");
%>
\end{verbatim}
\item
  Define the \texttt{searchURL} and \texttt{viewURL} as
  \texttt{renderURL}s. Both use the \texttt{mvcPath} parameter that's
  available to Liferay MVC Portlets:

\begin{verbatim}
<portlet:renderURL var="searchURL">
        <portlet:param name="mvcPath" 
        value="/guestbookwebportlet/view_search.jsp" />
</portlet:renderURL>

<portlet:renderURL var="viewURL">
    <portlet:param 
        name="mvcPath" 
        value="/guestbookwebportlet/view.jsp" 
    />
</portlet:renderURL>
\end{verbatim}

  The \texttt{searchURL} points to the current JSP:
  \texttt{view\_search.jsp}. The \texttt{viewURL} points back to the
  Guestbook portlet's main view. These URLs are used in the AUI form
  that you'll create next.
\item
  Add this AUI form:

\begin{verbatim}
<aui:form action="${searchURL}" name="fm">

    <liferay-ui:header backURL="${viewURL}" title="back" />

    <div class="row">
        <div class="col-md-8">
            <aui:input inlineLabel="left" label="" name="keywords" placeholder="search-entries" size="256" />
        </div>

        <div class="col-md-4">
            <aui:button type="submit" value="search" />
        </div>
    </div>
</aui:form>
\end{verbatim}

  This form is identical to the one that you added to the Guestbook
  portlet's \texttt{view.jsp}, except that this one contains a
  \texttt{\textless{}liferay-ui:header\textgreater{}} tag that displays
  the Back icon next to the word \emph{Back}. The \texttt{backURL}
  attribute in the header uses the \texttt{viewURL} defined above.
  Submitting the form invokes the \texttt{searchURL} with the user's
  search query added to the URL in the \texttt{keywords} parameter.
\item
  Start a scriptlet to get a search context and set some attributes in
  it:

\begin{verbatim}
<%
    SearchContext searchContext = SearchContextFactory.getInstance(request);

    searchContext.setKeywords(keywords);
    searchContext.setAttribute("paginationType", "more");
    searchContext.setStart(0);
    searchContext.setEnd(10);
\end{verbatim}

  To execute a search, you need a \texttt{SearchContext} object.
  \texttt{SearchContextFactory} creates a \texttt{SearchContext} from
  the request object. Add the user's search query to the
  \texttt{SearchContext} by passing the \texttt{keywords} URL parameter
  to the \texttt{setKeywords} method. Then specify details about
  pagination and how the search results should be displayed.
\item
  Still in the scriptlet, obtain an \texttt{Indexer} to run a search.
  Retrieve the entry indexer from the map in Liferay DXP's indexer
  registry by passing in the indexer's class or class name:

\begin{verbatim}
Indexer indexer = IndexerRegistryUtil.getIndexer(Entry.class);
\end{verbatim}
\item
  In the same scriptlet, use the indexer and the search context to run a
  search:

\begin{verbatim}
Hits hits = indexer.search(searchContext);

List<Entry> entries = new ArrayList<Entry>();

    for (int i = 0; i < hits.getDocs().length; i++) {
            Document doc = hits.doc(i);

            long entryId = GetterUtil
            .getLong(doc.get(Field.ENTRY_CLASS_PK));

            Entry entry = null;

            try {
                    entry = EntryLocalServiceUtil.getEntry(entryId);
            } catch (PortalException pe) {
                    _log.error(pe.getLocalizedMessage());
            } catch (SystemException se) {
                    _log.error(se.getLocalizedMessage());
            }

            entries.add(entry);
    }
\end{verbatim}

  The search results return as \texttt{Hits} objects containing pointers
  to documents that correspond to guestbook entries. You then loop
  through the hit documents, retrieving the corresponding guestbook
  entries and adding them to a list.
\item
  Finish the scriptlet by retrieving a list of all the guestbooks that
  exist in the current site. Create a map between the guestbook IDs and
  the guestbook names.

\begin{verbatim}
        List<Guestbook> guestbooks = GuestbookLocalServiceUtil.getGuestbooks(scopeGroupId);

        Map<String, String> guestbookMap = new HashMap<String, String>();

        for (Guestbook guestbook : guestbooks) {
                guestbookMap.put(Long.toString(guestbook.getGuestbookId()), guestbook.getName());
        }
%>
\end{verbatim}

  Making this single service call and creating a map is more efficient
  than making separate service calls for each guestbook.
\item
  Display the search results in a search container:

\begin{verbatim}
<liferay-ui:search-container delta="10" 
    emptyResultsMessage="no-entries-were-found" 
    total="<%= entries.size() %>">
        <liferay-ui:search-container-results
                results="<%= entries %>"
/>
\end{verbatim}

  This specifies three attributes for the
  \texttt{\textless{}liferay-ui:search-container\textgreater{}} tag:

  \begin{itemize}
  \tightlist
  \item
    \texttt{delta="10"}: specifies that at most, 10 entries can appear
    per page.
  \item
    \texttt{emptyResultsMessage}: specifies the message indicating there
    are no results.
  \item
    \texttt{total}: specifies the number of search results.
  \end{itemize}

  The \texttt{results} attribute of the tag
  \texttt{\textless{}liferay-ui:search-container-results\textgreater{}}
  specifies the search results. This is easy since you stored the
  entries resulting from the search in the \texttt{entries} list.
\item
  Use the
  \texttt{\textless{}liferay-ui:search-container-row\textgreater{}} tag
  to set the name of the class whose properties are displayed in each
  row:

\begin{verbatim}
<liferay-ui:search-container-row
        className="com.liferay.docs.guestbook.model.Entry"
        keyProperty="entryId" modelVar="entry" escapedModel="<%=true%>">
\end{verbatim}

  This uses the \texttt{className} attribute for the class name and
  specifies the entity's primary key attribute in the
  \texttt{keyProperty} attribute. The \texttt{modelVar} property
  specifies the name of the \texttt{Entry} variable that's available to
  each search container row. To ensure that each field of the
  \texttt{Entry} variable is escaped (sanitized), the
  \texttt{escapedModel} is \texttt{true}. This prevents potential hacks
  that could occur if users submitted malicious code into the Add
  Guestbook form, for example.
\item
  Inside the
  \texttt{\textless{}liferay-ui:search-container-row\textgreater{}} tag,
  specify the four columns to display: the guestbook entry's guestbook
  name, message, entry name, and the actions JSP. The guestbook name is
  retrieved from the map created in the scriptlet:

\begin{verbatim}
    <liferay-ui:search-container-column-text name="guestbook"
        value="<%=guestbookMap.get(Long.toString(entry.getGuestbookId()))%>" />

    <liferay-ui:search-container-column-text property="message" />

    <liferay-ui:search-container-column-text property="name" />

    <liferay-ui:search-container-column-jsp
        path="/guestbookwebportlet/entry_actions.jsp"
        align="right" />
</liferay-ui:search-container-row>
\end{verbatim}
\item
  Use the \texttt{\textless{}liferay-ui:search-iterator\textgreater{}}
  tag to iterate through the search results and handle pagination. Close
  the search container tag:

\begin{verbatim}
        <liferay-ui:search-iterator />
</liferay-ui:search-container>
\end{verbatim}
\item
  At the bottom of \texttt{view\_search.jsp}, declare a \texttt{Log}
  object. You used this log in the \texttt{catch} clauses of the
  \texttt{try} clause that calls the
  \texttt{EntryLocalServiceUtil.getEntry} method to retrieve the
  guestbook entries. If this service call throws an exception, it's best
  to log the error so a server administrator can determine what went
  wrong. Liferay DXP's convention is to declare custom logs for
  individual classes or JSPs at the bottom of the file:

\begin{verbatim}
<%!
        private static Log _log = LogFactoryUtil.getLog("html.guestbookwebportlet.view_search_jsp");
%>
\end{verbatim}
\item
  Finally, your \texttt{view\_search.jsp} requires some extra imports.
  Add the following imports to \texttt{init.jsp}:

\begin{verbatim}
<%@ page import="com.liferay.portal.kernel.dao.search.SearchContainer" %>
<%@ page import="com.liferay.portal.kernel.exception.PortalException" %>
<%@ page import="com.liferay.portal.kernel.exception.SystemException" %>
<%@ page import="com.liferay.portal.kernel.language.LanguageUtil" %>
<%@ page import="com.liferay.portal.kernel.log.Log" %>
<%@ page import="com.liferay.portal.kernel.log.LogFactoryUtil" %>
<%@ page import="com.liferay.portal.kernel.search.Indexer" %>
<%@ page import="com.liferay.portal.kernel.search.IndexerRegistryUtil" %>
<%@ page import="com.liferay.portal.kernel.search.SearchContext" %>
<%@ page import="com.liferay.portal.kernel.search.SearchContextFactory" %>
<%@ page import="com.liferay.portal.kernel.search.Hits" %>
<%@ page import="com.liferay.portal.kernel.search.Document" %>
<%@ page import="com.liferay.portal.kernel.search.Field" %>
<%@ page import="com.liferay.portal.kernel.util.StringPool" %>
<%@ page import="com.liferay.portal.kernel.util.GetterUtil" %>
<%@ page import="com.liferay.portal.kernel.util.Validator" %>
<%@ page import="com.liferay.portal.kernel.util.PortalUtil" %>

<%@ page import="java.util.ArrayList" %>
<%@ page import="java.util.Map" %>
<%@ page import="java.util.HashMap" %>

<%@ page import="javax.portlet.PortletURL" %>
\end{verbatim}
\end{enumerate}

Good work! The Guestbook portlet now supports search! Now your users can
find those Guestbook Entries they were looking for.

\begin{figure}
\centering
\includegraphics{./images/guestbook-portlet-search-conclusion.png}
\caption{The Guestbook Application now supports searching for indexed
Guestbook Entries.}
\end{figure}

Once indexing is in place, the asset framework can be added to the
Guestbook application. It provides functionality that's shared across
different types of content like blog posts, message board posts, wiki
articles, and more. This is the heart of integration with Liferay DXP's
development platform.

\chapter{Assets: Integrating with Liferay's
Framework}\label{assets-integrating-with-liferays-framework}

The asset framework transforms entities into a common format that can be
published anywhere in your Site. Web content articles, blog posts, wiki
articles, and documents are some asset-enabled entities that come
out-of-the-box. By asset-enabling your own applications, you can take
advantage of Liferay DXP's functionality for publishing your
application's data across your Site in the form of asset publisher
entries, notifications, social activities, and more.

The asset framework includes the following features:

\begin{itemize}
\tightlist
\item
  Tags and categories
\item
  Comments and ratings
\item
  Related assets (a.k.a. Asset links)
\item
  Faceted search
\item
  Integration with the Asset Publisher portlet
\item
  Integration with the Search portlet
\item
  Integration with the Tags Navigation, Tag Cloud, and Categories
  Navigation portlets
\end{itemize}

Now you'll asset-enable the guestbook and guestbook entry entities.
You'll implement tags, categories, and related assets for guestbooks and
guestbook entries. You'll implement comments and ratings in guestbook
entries. You'll also learn how asset-enabled guestbooks and guestbook
entries integrate with core portlets like the Asset Publisher, Tags
Navigation, Tag Cloud, and Categories Navigation portlets. Ready to
start?

Let's Go!{}

\section{Enabling Assets at the Service
Layer}\label{enabling-assets-at-the-service-layer}

\begin{verbatim}
<p>Enabling Assets at the Service Layer</p><p>Step 1 of 3</p>
\end{verbatim}

Each row in the \texttt{AssetEntry} table represents an asset. It has an
\texttt{entryId} primary key along with \texttt{classNameId} and
\texttt{classPK} foreign keys. The \texttt{classNameId} specifies the
asset's type. For example, an asset with a \texttt{classNameId} of
\texttt{JournalArticle} means that the asset represents a web content
article (\texttt{JournalArticle} is the back-end name for a web content
article). An asset's \texttt{classPK} is the primary key of the entity
represented by the asset.

Follow these steps to make asset services available to your entities'
service layers:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In the \texttt{guestbook-service} module's \texttt{service.xml} file,
  add the following references directly above the closing
  \texttt{\textless{}/entity\textgreater{}} tags for \texttt{Guestbook}
  and \texttt{Entry}:

\begin{verbatim}
<reference package-path="com.liferay.portlet.asset" entity="AssetEntry" />
<reference package-path="com.liferay.portlet.asset" entity="AssetLink" />
\end{verbatim}

  As mentioned above, you must use the \texttt{AssetEntry} service so
  your application can add asset entries corresponding to guestbooks and
  guestbook entries. You also use the \texttt{AssetLink} service to
  support related assets. \emph{Asset links} are Liferay DXP's back-end
  term for related assets.
\item
  You must add finders---two for \texttt{Guestbook}s and two for
  \texttt{Entity}s---so your assets show in Asset Publisher, because it
  searches for entities by \texttt{status} (i.e., is it
  Workflow-approved?) and by \texttt{groupId} (i.e., is it in this
  Site?). Add these below the existing finders for the
  \texttt{Guestbook} and \texttt{Entry} entities:

\begin{verbatim}
<finder name="Status" return-type="Collection">
    <finder-column name="status" />
</finder>

<finder name="G_S" return-type="Collection">
    <finder-column name="groupId" />
    <finder-column name="status" />
</finder>
\end{verbatim}
\item
  Run the \texttt{buildService} Gradle task. This task injects the
  objects referenced above into your services for use.
\item
  Right-click \texttt{build.gradle} and select \emph{Gradle} →
  \emph{Refresh Gradle Project}.
\end{enumerate}

Great! Next, you'll handle assets in your service layer.

\section{Handling Assets at the Guestbook Service
Layer}\label{handling-assets-at-the-guestbook-service-layer}

\begin{verbatim}
<p id="stepTitle">Enabling Assets at the Service Layer</p><p>Step 2 of 3</p>
\end{verbatim}

Before you can update the Service Layer to add the Asset Renderers, you
must update your \texttt{build.gradle} to provide the
\texttt{portlet-api} and \texttt{javax.servlet-api} libraries that the
asset link service needs to function.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open the \texttt{build.gradle} file in your \texttt{guestbook-service}
  module.
\item
  Add the following two lines in the \texttt{dependencies} section:

\begin{verbatim}
compileOnly group: "javax.portlet", name: "portlet-api", version: "3.0.0"
compileOnly group: "javax.servlet", name: "javax.servlet-api", version: "3.0.1"
\end{verbatim}
\end{enumerate}

Now you'll update the guestbook service layer to use assets. You must
update the \texttt{add}, \texttt{update}, and \texttt{delete} methods of
your project's \texttt{GuestbookLocalServiceImpl}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open your project's \texttt{GuestbookLocalServiceImpl} class and find
  the \texttt{addGuestbook} method. Add the call to add the asset
  entries below the call that adds resources:

\begin{verbatim}
  AssetEntry assetEntry = assetEntryLocalService.updateEntry(userId,
                      groupId, guestbook.getCreateDate(),
                      guestbook.getModifiedDate(), Guestbook.class.getName(),
                      guestbookId, guestbook.getUuid(), 0,
                      serviceContext.getAssetCategoryIds(),
                      serviceContext.getAssetTagNames(), true, true, null, null, null, null,
                      ContentTypes.TEXT_HTML, guestbook.getName(), null, null, null,
                      null, 0, 0, null);

  assetLinkLocalService.updateLinks(userId, assetEntry.getEntryId(),
                      serviceContext.getAssetLinkEntryIds(),
                      AssetLinkConstants.TYPE_RELATED);
\end{verbatim}

  Calling \texttt{assetEntryLocalService.updateEntry} adds a new row
  (corresponding to the guestbook that's being added) to the
  \texttt{AssetEntry} table in Liferay DXP's database.
  \texttt{AssetEntryLocalServiceImpl}'s \texttt{updateEntry} method both
  adds and updates asset entries because it checks to see whether the
  asset entry already exists in the database and then takes the
  appropriate action. If you check the
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-impl/com/liferay/portlet/asset/service/impl/AssetEntryLocalServiceImpl.html}{Javadoc}
  for \texttt{AssetEntryLocalServiceUtil.updateEntry}, you'll see that
  this method is overloaded. Now, why did you use a version of this
  method with such a long method signature? Because there's only one
  version of \texttt{updateEntry} that takes a \texttt{title} parameter
  (to set the asset entry's title). Since you want to set the asset
  title to \texttt{guestbook.getName()}, that's the version you use.

  Later, you'll update the Guestbook Admin portlet's form for adding
  guestbooks to allow the selection of related assets, which are stored
  in the database's \texttt{AssetLink} table. The
  \texttt{assetLinkLocalService.updateLinks} call adds the appropriate
  entries to the table so related assets work for your guestbook
  entities. The \texttt{updateEntry} method adds and updates asset
  entries the same way \texttt{updateLink} adds and updates asset links.
\item
  Next, add the asset calls to \texttt{GuestbookLocalServiceImpl}'s
  \texttt{updateGuestbook} method, directly after the resource call:

\begin{verbatim}
  AssetEntry assetEntry = assetEntryLocalService.updateEntry(guestbook.getUserId(),
                      guestbook.getGroupId(), guestbook.getCreateDate(),
                      guestbook.getModifiedDate(), Guestbook.class.getName(),
                      guestbookId, guestbook.getUuid(), 0,
                      serviceContext.getAssetCategoryIds(),
                      serviceContext.getAssetTagNames(), true, true, guestbook.getCreateDate(), 
                      null, null, null, ContentTypes.TEXT_HTML, guestbook.getName(), null, null, 
                      null, null, 0, 0, serviceContext.getAssetPriority());

  assetLinkLocalService.updateLinks(serviceContext.getUserId(),
                      assetEntry.getEntryId(), serviceContext.getAssetLinkEntryIds(),
                      AssetLinkConstants.TYPE_RELATED);
\end{verbatim}

  Here, \texttt{assetEntryLocalService.updateEntry} updates an existing
  asset entry and \texttt{assetLinkLocalService.updateLinks} adds or
  updates that entry's asset links (related assets).
\item
  Next, add the asset calls to the \texttt{deleteGuestbook} method,
  directly after the resource calls:

\begin{verbatim}
  AssetEntry assetEntry = assetEntryLocalService.fetchEntry(
                      Guestbook.class.getName(), guestbookId);

  assetLinkLocalService.deleteLinks(assetEntry.getEntryId());

  assetEntryLocalService.deleteEntry(assetEntry);
\end{verbatim}

  Here, you use the guestbook's class name and ID to retrieve the
  corresponding asset entry. Then you delete that asset entry's asset
  links and the asset entry itself.
\item
  Finally, organize your imports, save the file, and run Service Builder
  to apply the changes.
\end{enumerate}

Next, you'll do the same thing for guestbook entries.

\section{Handling Assets for Entry Service
Layer}\label{handling-assets-for-entry-service-layer}

\begin{verbatim}
<p id="stepTitle">Enabling Assets at the Service Layer</p><p>Step 3 of 3</p>
\end{verbatim}

Now you must update the guestbook entry entity's service methods. In
these methods, the calls you'll make to \texttt{assetEntryLocalService}
and \texttt{assetLinkLocalService} are identical to the ones you made in
the guestbook entity's service methods, except you're specifying assets
for \texttt{Entry} entities.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open \texttt{EntryLocalServiceImpl} and add the asset calls to the
  \texttt{addEntry} method after the resource calls:

\begin{verbatim}
  AssetEntry assetEntry = assetEntryLocalService.updateEntry(userId,
                      groupId, entry.getCreateDate(), entry.getModifiedDate(),
                      Entry.class.getName(), entryId, entry.getUuid(), 0,
                      serviceContext.getAssetCategoryIds(),
                      serviceContext.getAssetTagNames(), true, true, null, null, null, null,
                      ContentTypes.TEXT_HTML, entry.getMessage(), null, null, null,
                      null, 0, 0, null);

  assetLinkLocalService.updateLinks(userId, assetEntry.getEntryId(),
                      serviceContext.getAssetLinkEntryIds(),
                      AssetLinkConstants.TYPE_RELATED);
\end{verbatim}
\item
  Next, add the asset calls to the \texttt{updateEntry} method after the
  resource calls:

\begin{verbatim}
      AssetEntry assetEntry = assetEntryLocalService.updateEntry(userId,
                      serviceContext.getScopeGroupId(),
                      entry.getCreateDate(), entry.getModifiedDate(),
                      Entry.class.getName(), entryId, entry.getUuid(),
                      0, serviceContext.getAssetCategoryIds(),
                      serviceContext.getAssetTagNames(), true, true,
                      entry.getCreateDate(), null, null, null,
                      ContentTypes.TEXT_HTML, entry.getMessage(), null,
                      null, null, null, 0, 0,
                      serviceContext.getAssetPriority());

      assetLinkLocalService.updateLinks(userId, assetEntry.getEntryId(),
                      serviceContext.getAssetLinkEntryIds(),
                      AssetLinkConstants.TYPE_RELATED);
\end{verbatim}
\item
  Add the asset calls to the \texttt{deleteEntry} method after the
  resource calls:

\begin{verbatim}
AssetEntry assetEntry = assetEntryLocalService.fetchEntry(
                      Entry.class.getName(), entryId);

assetLinkLocalService.deleteLinks(assetEntry.getEntryId());

assetEntryLocalService.deleteEntry(assetEntry);
\end{verbatim}
\item
  Organize your imports, save the file, and run Service Builder.
\item
  Finally, add these language keys to the
  \texttt{guestbook-web/src/main/resources/content/Language.properties}
  file:

\begin{verbatim}
model.resource.com.liferay.docs.guestbook.model.Guestbook=Guestbook
model.resource.com.liferay.docs.guestbook.model.Entry=Guestbook Entry
\end{verbatim}
\end{enumerate}

Excellent! You've asset-enabled your guestbook and guestbook entry
entities at the service layer. Your next step is to implement asset
renderers for these entities so they can be fully integrated into the
asset framework. Every asset needs an asset renderer class so the Asset
Publisher portlet can display it.

\chapter{Implementing Asset
Renderers}\label{implementing-asset-renderers}

Assets are display versions of entities, so they contain fields like
\texttt{title}, \texttt{description}, and \texttt{summary}. Liferay DXP
uses these fields to display assets. Asset Renderers translate an entity
into an asset via these fields. You must therefore create and register
Asset Renderer classes for your guestbook and guestbook entry entities.
Without these classes, Liferay DXP can't display your entities in Asset
Publisher, Notifications, Activities, or anywhere else that displays
assets.

Your next task is to create these Asset Renderers. Ready to begin?

Let's Go!{}

\section{Implementing a Guestbook Asset
Renderer}\label{implementing-a-guestbook-asset-renderer}

\begin{verbatim}
<p id="stepTitle">Implementing Asset Renderers</p><p>Step 1 of 2</p>
\end{verbatim}

Liferay DXP's asset renderers follow the factory pattern, so you must
create a \texttt{GuestbookAssetRendererFactory} that instantiates the
\texttt{GuestbookAssetRenderer}'s private guestbook object. Here, you'll
create both classes.

You'll create the Asset Renderer class first.

\subsection{Creating the AssetRenderer
Class}\label{creating-the-assetrenderer-class}

Follow these steps to create the \texttt{GuestbookAssetRenderer} class:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a new package called
  \texttt{com.liferay.docs.guestbook.web.internal.asset} in the
  \texttt{guestbook-web} module's \texttt{src/main/java} folder. In this
  package, create a \texttt{GuestbookAssetRenderer} class that extends
  Liferay DXP's \texttt{BaseJSPAssetRenderer} class. Extending this
  class gives you a head-start on implementing the
  \texttt{AssetRenderer} interface:

\begin{verbatim}
public class GuestbookAssetRenderer extends BaseJSPAssetRenderer<Guestbook> {

}
\end{verbatim}
\item
  Add the constructor, the guestbook class variable, and the permissions
  model resource. Most of the methods in this class are getters that
  return fields from the private \texttt{\_guestbook} object. Methods
  requiring a permission check use
  \texttt{\_guestbookModelResourcePermission}:

\begin{verbatim}
public GuestbookAssetRenderer(Guestbook guestbook, ModelResourcePermission<Guestbook> modelResourcePermission) {

            _guestbook = guestbook;
            _guestbookModelResourcePermission = modelResourcePermission;
}

private Guestbook _guestbook;
private final ModelResourcePermission<Guestbook> _guestbookModelResourcePermission;   
private Logger logger = Logger.getLogger(this.getClass().getName());
\end{verbatim}
\item
  The \texttt{BaseJSPAssetRenderer} abstract class that you're extending
  contains dummy implementations of the \texttt{hasEditPermission} and
  \texttt{hasViewPermission} methods that you must override with actual
  permission checks using the permissions resources that you created
  earlier:

\begin{verbatim}
@Override
public boolean hasEditPermission(PermissionChecker permissionChecker) 
{
    try {
        return _guestbookModelResourcePermission.contains(
            permissionChecker, _guestbook, ActionKeys.UPDATE);
    }
    catch (Exception e) {
    }

    return false;
}

@Override
public boolean hasViewPermission(PermissionChecker permissionChecker) 
{
    try {
        return _guestbookModelResourcePermission.contains(
            permissionChecker, _guestbook, ActionKeys.VIEW);
    }
    catch (Exception e) {
    }

    return true;
}
\end{verbatim}
\item
  Add the following getter methods to retrieve information about the
  guestbook asset:

\begin{verbatim}
@Override
public Guestbook getAssetObject() {
  return _guestbook;
}

@Override
public long getGroupId() {
  return _guestbook.getGroupId();
}

@Override
public long getUserId() {

  return _guestbook.getUserId();
}

@Override
public String getUserName() {
  return _guestbook.getUserName();
}

@Override
public String getUuid() {
  return _guestbook.getUuid();
}

@Override
public String getClassName() {
  return Guestbook.class.getName();
}

@Override
public long getClassPK() {
  return _guestbook.getGuestbookId();
}

@Override
public String getSummary(PortletRequest portletRequest, PortletResponse 
  portletResponse) {
    return "Name: " + _guestbook.getName();
}

@Override
public String getTitle(Locale locale) {
  return _guestbook.getName();
}

@Override
public boolean include(HttpServletRequest request, HttpServletResponse 
  response, String template) throws Exception {
    request.setAttribute("GUESTBOOK", _guestbook);
    request.setAttribute("HtmlUtil", HtmlUtil.getHtml());
    request.setAttribute("StringUtil", new StringUtil());
    return super.include(request, response, template);
}
\end{verbatim}

  The final method makes several utilities and the \texttt{Guestbook}
  entity available in the \texttt{HttpServletRequest} object.
\item
  Override the \texttt{getJspPath} method. It returns a string
  representing the path to the JSP that renders the guestbook asset.
  When the Asset Publisher displays an asset's full content, it invokes
  the asset renderer class's \texttt{getJspPath} method and passes a
  \texttt{template} string parameter that equals
  \texttt{"full\_content"}. This returns
  \texttt{/asset/guestbook/full\_content.jsp} when the
  \texttt{full\_content} template string is passed as a parameter.
  You'll create this JSP later when updating your application's user
  interface:

\begin{verbatim}
  @Override
  public String getJspPath(HttpServletRequest request, String template) {

    if (template.equals(TEMPLATE_FULL_CONTENT)) {
      request.setAttribute("gb_guestbook", _guestbook);

      return "/asset/guestbook/" + template + ".jsp";
    } else {
      return null;
    }
  }
\end{verbatim}
\item
  Override the \texttt{getURLEdit} method. This method returns a URL for
  editing the asset:

\begin{verbatim}
  @Override
  public PortletURL getURLEdit(LiferayPortletRequest liferayPortletRequest,
      LiferayPortletResponse liferayPortletResponse) throws Exception {
    PortletURL portletURL = liferayPortletResponse.createLiferayPortletURL(
        getControlPanelPlid(liferayPortletRequest), GuestbookPortletKeys.GUESTBOOK,
        PortletRequest.RENDER_PHASE);
    portletURL.setParameter("mvcRenderCommandName", "/guestbookwebportlet/edit_guestbook");
    portletURL.setParameter("guestbookId", String.valueOf(_guestbook.getGuestbookId()));
    portletURL.setParameter("showback", Boolean.FALSE.toString());

    return portletURL;
  }
\end{verbatim}
\item
  Override the \texttt{getURLViewInContext} method. This method returns
  a URL to view the asset in its native application:

\begin{verbatim}
  @Override
  public String getURLViewInContext(LiferayPortletRequest liferayPortletRequest,
      LiferayPortletResponse liferayPortletResponse, String noSuchEntryRedirect) throws Exception {
    try {
      long plid = PortalUtil.getPlidFromPortletId(_guestbook.getGroupId(),
          GuestbookPortletKeys.GUESTBOOK);

      PortletURL portletURL;
      if (plid == LayoutConstants.DEFAULT_PLID) {
        portletURL = liferayPortletResponse.createLiferayPortletURL(getControlPanelPlid(liferayPortletRequest),
            GuestbookPortletKeys.GUESTBOOK, PortletRequest.RENDER_PHASE);
      } else {
        portletURL = PortletURLFactoryUtil.create(liferayPortletRequest,
            GuestbookPortletKeys.GUESTBOOK, plid, PortletRequest.RENDER_PHASE);
      }

      portletURL.setParameter("mvcRenderCommandName", "/guestbookwebportlet/view");
      portletURL.setParameter("guestbookId", String.valueOf(_guestbook.getGuestbookId()));

      String currentUrl = PortalUtil.getCurrentURL(liferayPortletRequest);

      portletURL.setParameter("redirect", currentUrl);

      return portletURL.toString();

    } catch (PortalException e) {

        logger.log(Level.SEVERE, e.getMessage());

    } catch (SystemException e) {

        logger.log(Level.SEVERE, e.getMessage());

    }

    return noSuchEntryRedirect;
  }
\end{verbatim}
\item
  Override the \texttt{getURLView} method. This method returns a URL to
  view the asset from within the Asset Publisher:

\begin{verbatim}
  @Override
  public String getURLView(LiferayPortletResponse liferayPortletResponse, 
  WindowState windowState) throws Exception {

    return super.getURLView(liferayPortletResponse, windowState);
  }
\end{verbatim}
\item
  Organize imports (Ctrl-Shift-O) and save the file. Choose
  \texttt{com.liferay.petra.*} libraries when prompted, to avoid the
  deprecated ones in Liferay's kernel. For logging, choose
  \texttt{java.util.logging.Logger} and
  \texttt{java.util.logging.Level}.
\end{enumerate}

Next you can create the \texttt{AssetRendererFactory} class.

\subsection{Creating the GuestbookAssetRendererFactory
Class}\label{creating-the-guestbookassetrendererfactory-class}

Follow these steps to create the \texttt{GuestbookAssetRendererFactory}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In the \texttt{com.liferay.docs.guestbook.web.internal.asset} package,
  create a class called \texttt{GuestbookAssetRendererFactory} that
  extends Liferay DXP's \texttt{BaseAssetRendererFactory} class, and
  overwrite the generated constructor and class variables with this:

\begin{verbatim}
@Component(immediate = true, 
  property = {"javax.portlet.name=" + GuestbookPortletKeys.GUESTBOOK}, 
  service = AssetRendererFactory.class
  )
public class GuestbookAssetRendererFactory extends 
  BaseAssetRendererFactory<Guestbook> {

  public GuestbookAssetRendererFactory() {
    setClassName(CLASS_NAME);
    setLinkable(_LINKABLE);
    setPortletId(GuestbookPortletKeys.GUESTBOOK); setSearchable(true);
    setSelectable(true); 
  }         

  private ServletContext _servletContext;
  private GuestbookLocalService _guestbookLocalService;
  private static final boolean _LINKABLE = true;
  public static final String CLASS_NAME = Guestbook.class.getName();
  public static final String TYPE = "guestbook";
  private Logger logger = Logger.getLogger(this.getClass().getName());
  private ModelResourcePermission<Guestbook>
  _guestbookModelResourcePermission;
\end{verbatim}

  This code contains the class declaration, the constructor, and the
  class variables. It sets the class name it creates an
  \texttt{AssetRenderer} for, a portlet ID, and a \texttt{true} boolean
  (\texttt{\_LINKABLE}). The boolean denotes implemented methods that
  provide URLs in the generated \texttt{AssetRenderer}.
\item
  Implement the \texttt{getAssetRenderer} method, which constructs new
  \texttt{GuestbookAssetRenderer} instances for particular guestbooks.
  It uses the \texttt{classPK} (primary key) parameter to retrieve the
  guestbook from the database. It then calls the
  \texttt{GuestbookAssetRenderer}'s constructor, passing the retrieved
  guestbook and permissions resource model as arguments:

\begin{verbatim}
@Override
public AssetRenderer<Guestbook> getAssetRenderer(long classPK, int type) 
throws PortalException {

  Guestbook guestbook = _guestbookLocalService.getGuestbook(classPK);

  GuestbookAssetRenderer guestbookAssetRenderer = 
  new GuestbookAssetRenderer(guestbook, _guestbookModelResourcePermission);

  guestbookAssetRenderer.setAssetRendererType(type);
  guestbookAssetRenderer.setServletContext(_servletContext);

  return guestbookAssetRenderer;
}
\end{verbatim}
\item
  You're extending \texttt{BaseAssetRendererFactory}, an abstract class
  that implements the \texttt{AssetRendererFactory} interface. To ensure
  that your custom asset is associated with the correct entity, each
  asset renderer factory must implement the \texttt{getClassName} and
  \texttt{getType} methods (among others):

\begin{verbatim}
  @Override
  public String getClassName() {
    return CLASS_NAME;
  }

  @Override
  public String getType() {
    return TYPE;
  }
\end{verbatim}
\item
  Implement the \texttt{hasPermission} method via the
  \texttt{GuestbookPermission} class:

\begin{verbatim}
@Override
public boolean hasPermission(PermissionChecker permissionChecker, 
long classPK, String actionId) throws Exception {

  Guestbook guestbook = _guestbookLocalService.getGuestbook(classPK);
  long groupId = guestbook.getGroupId();
  return GuestbookPermission.contains(permissionChecker, groupId, 
  actionId);
}
\end{verbatim}
\item
  Add the remaining code to create the portlet URL for the asset and
  specify whether it's linkable:

\begin{verbatim}
      @Override
      public PortletURL getURLAdd(LiferayPortletRequest liferayPortletRequest,
          LiferayPortletResponse liferayPortletResponse, long classTypeId) {
        PortletURL portletURL = null;

        try {
          ThemeDisplay themeDisplay = (ThemeDisplay) 
          liferayPortletRequest.getAttribute(WebKeys.THEME_DISPLAY);

          portletURL = liferayPortletResponse.createLiferayPortletURL(getControlPanelPlid(themeDisplay),
              GuestbookPortletKeys.GUESTBOOK, PortletRequest.RENDER_PHASE);
          portletURL.setParameter("mvcRenderCommandName", "/guestbookwebportlet/edit_guestbook");
          portletURL.setParameter("showback", Boolean.FALSE.toString());

          } catch (PortalException e) {

                logger.log(Level.SEVERE, e.getMessage()); 

          }

        return portletURL;
      }

      @Override
      public boolean isLinkable() {
        return _LINKABLE;
      }

      @Override
      public String getIconCssClass() {
          return "bookmarks";
      }

    @Reference(target = "(osgi.web.symbolicname=com.liferay.docs.guestbook.portlet)",
            unbind = "-")
    public void setServletContext(ServletContext servletContext) {
            _servletContext = servletContext;
        }

    @Reference(unbind = "-")
        protected void setGuestbookLocalService(GuestbookLocalService guestbookLocalService) {
            _guestbookLocalService = guestbookLocalService; 
    }
}
\end{verbatim}
\item
  Organize imports (Ctrl-Shift-O). Select the \texttt{org.osgi} packages
  (not \texttt{a.Qute}) when prompted and save the file.
\end{enumerate}

Great! The guestbook asset renderer is complete. Next, you'll create the
entry asset renderer.

\section{Implementing an Entry Asset
Renderer}\label{implementing-an-entry-asset-renderer}

\begin{verbatim}
<p id="stepTitle">Implementing Asset Renderers</p><p>Step 2 of 2</p>
\end{verbatim}

The classes you'll create here are nearly identical to the
\texttt{GuestbookAssetRenderer} and
\texttt{GuestbookAssetRendererFactory} classes you created for
guestbooks in the previous step. This step provides the code needed for
guestbook entries. Please review the previous sections to learn how this
code works.

\subsection{Creating the EntryAssetRenderer
Class}\label{creating-the-entryassetrenderer-class}

In the \texttt{com.liferay.docs.guestbook.web.internal.asset} package,
create an \texttt{EntryAssetRenderer} class that extends Liferay DXP's
\texttt{BaseJSPAssetRenderer} class. Replace the contents of your
\texttt{EntryAssetRenderer} class with the following code:

\begin{verbatim}
package com.liferay.docs.guestbook.web.internal.asset;

import com.liferay.asset.kernel.model.BaseJSPAssetRenderer;
import com.liferay.portal.kernel.exception.PortalException;
import com.liferay.portal.kernel.exception.SystemException;
import com.liferay.portal.kernel.model.LayoutConstants;
import com.liferay.portal.kernel.portlet.LiferayPortletRequest;
import com.liferay.portal.kernel.portlet.LiferayPortletResponse;
import com.liferay.portal.kernel.portlet.PortletURLFactoryUtil;
import com.liferay.portal.kernel.security.permission.ActionKeys;
import com.liferay.portal.kernel.security.permission.PermissionChecker;
import com.liferay.portal.kernel.security.permission.resource.ModelResourcePermission;
import com.liferay.portal.kernel.util.HtmlUtil;
import com.liferay.portal.kernel.util.PortalUtil;
import com.liferay.petra.string.StringUtil;
import com.liferay.docs.guestbook.constants.GuestbookPortletKeys;
import com.liferay.docs.guestbook.model.Entry;
import java.util.Locale;
import javax.portlet.PortletRequest;
import javax.portlet.PortletResponse;
import javax.portlet.PortletURL;
import javax.portlet.WindowState;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class EntryAssetRenderer extends BaseJSPAssetRenderer<Entry> {

    public EntryAssetRenderer(Entry entry, ModelResourcePermission<Entry> modelResourcePermission) {

        _entry = entry;
        _entryModelResourcePermission = modelResourcePermission;
    }

    @Override
    public boolean hasViewPermission(PermissionChecker permissionChecker) 
    {
        try {
            return _entryModelResourcePermission.contains(
                    permissionChecker, _entry, ActionKeys.VIEW);
        }
        catch (Exception e) {
        }

        return true;
    }

    @Override
    public Entry getAssetObject() {
        return _entry;
    }

    @Override
    public long getGroupId() {
        return _entry.getGroupId();
    }

    @Override
    public long getUserId() {

        return _entry.getUserId();
    }

    @Override
    public String getUserName() {
        return _entry.getUserName();
    }

    @Override
    public String getUuid() {
        return _entry.getUuid();
    }

    @Override
    public String getClassName() {
        return Entry.class.getName();
    }

    @Override
    public long getClassPK() {
        return _entry.getEntryId();
    }

    @Override
    public String getSummary(PortletRequest portletRequest, 
            PortletResponse portletResponse) {
        return "Name: " + _entry.getName() + ". Message: " + _entry.getMessage();
    }

    @Override
    public String getTitle(Locale locale) {
        return _entry.getMessage();
    }

    @Override
    public boolean include(HttpServletRequest request, 
            HttpServletResponse response, String template) throws Exception {
        request.setAttribute("ENTRY", _entry);
        request.setAttribute("HtmlUtil", HtmlUtil.getHtml());
        request.setAttribute("StringUtil", new StringUtil());
        return super.include(request, response, template);
    }

    @Override
    public String getJspPath(HttpServletRequest request, String template) {

        if (template.equals(TEMPLATE_FULL_CONTENT)) {
            request.setAttribute("gb_entry", _entry);

            return "/asset/entry/" + template + ".jsp";
        } else {
            return null;
        }
    }

    @Override
    public PortletURL getURLEdit(LiferayPortletRequest liferayPortletRequest,
            LiferayPortletResponse liferayPortletResponse) throws Exception {
        PortletURL portletURL = liferayPortletResponse.createLiferayPortletURL(
                getControlPanelPlid(liferayPortletRequest), GuestbookPortletKeys.GUESTBOOK,
                PortletRequest.RENDER_PHASE);
        portletURL.setParameter("mvcRenderCommandName", "/guestbookwebportlet/edit_entry");
        portletURL.setParameter("entryId", String.valueOf(_entry.getEntryId()));
        portletURL.setParameter("showback", Boolean.FALSE.toString());

        return portletURL;
    }

    @Override
    public String getURLViewInContext(LiferayPortletRequest liferayPortletRequest,
            LiferayPortletResponse liferayPortletResponse, String noSuchEntryRedirect) 
                    throws Exception {
        try {
            long plid = PortalUtil.getPlidFromPortletId(_entry.getGroupId(),
                    GuestbookPortletKeys.GUESTBOOK);

            PortletURL portletURL;
            if (plid == LayoutConstants.DEFAULT_PLID) {
                portletURL = liferayPortletResponse.createLiferayPortletURL(getControlPanelPlid(liferayPortletRequest),
                        GuestbookPortletKeys.GUESTBOOK, PortletRequest.RENDER_PHASE);
            } else {
                portletURL = PortletURLFactoryUtil.create(liferayPortletRequest,
                        GuestbookPortletKeys.GUESTBOOK, plid, PortletRequest.RENDER_PHASE);
            }

            portletURL.setParameter("mvcRenderCommandName", "/guestbookwebportlet/view");
            portletURL.setParameter("entryId", String.valueOf(_entry.getEntryId()));

            String currentUrl = PortalUtil.getCurrentURL(liferayPortletRequest);

            portletURL.setParameter("redirect", currentUrl);

            return portletURL.toString();

        } catch (PortalException e) {

        } catch (SystemException e) {
        }

        return noSuchEntryRedirect;
    }

    @Override
    public String getURLView(LiferayPortletResponse liferayPortletResponse, 
            WindowState windowState) throws Exception {

        return super.getURLView(liferayPortletResponse, windowState);
    }

    @Override
    public boolean isPrintable() {
        return true;
    }
    private final ModelResourcePermission<Entry> _entryModelResourcePermission;
    private Entry _entry;
}
\end{verbatim}

This class is similar to the \texttt{GuestbookAssetRenderer} class. For
the \texttt{EntryAssetRenderer.getSummary} method, you return a summary
that displays the entry name (the name of the user who created the
entry) and the entry message.

\texttt{GuestbookAssetRenderer.getSummary} returns a summary that
displays the guestbook name. \texttt{EntryAssetRenderer.getTitle}
returns the entry message. \texttt{GuestbookAssetRenderer.getTitle}
returns the guestbook name. The other methods of
\texttt{EntryAssetRenderer} are nearly identical to those of
\texttt{GuestbookAssetRenderer}.

\subsection{Creating the EntryAssetRendererFactory
Class}\label{creating-the-entryassetrendererfactory-class}

Next, you must create the guestbook entry asset renderer's factory
class. In the \texttt{com.liferay.docs.guestbook.web.internal.asset}
package, create a class called \texttt{EntryAssetRendererFactory} that
extends Liferay DXP's \texttt{BaseAssetRendererFactory} class. Replace
its content with the following code:

\begin{verbatim}
package com.liferay.docs.guestbook.web.internal.asset;

import com.liferay.asset.kernel.model.AssetRenderer;
import com.liferay.asset.kernel.model.AssetRendererFactory;
import com.liferay.asset.kernel.model.BaseAssetRendererFactory;
import com.liferay.docs.guestbook.constants.GuestbookPortletKeys;
import com.liferay.docs.guestbook.model.Entry;
import com.liferay.docs.guestbook.service.EntryLocalService;
import com.liferay.docs.guestbook.web.internal.security.permission.resource.GuestbookEntryPermission;
import com.liferay.portal.kernel.exception.PortalException;
import com.liferay.portal.kernel.portlet.LiferayPortletRequest;
import com.liferay.portal.kernel.portlet.LiferayPortletResponse;
import com.liferay.portal.kernel.portlet.LiferayPortletURL;
import com.liferay.portal.kernel.security.permission.PermissionChecker;
import com.liferay.portal.kernel.security.permission.resource.ModelResourcePermission;
import com.liferay.portal.kernel.theme.ThemeDisplay;
import com.liferay.portal.kernel.util.WebKeys;

import javax.portlet.PortletRequest;
import javax.portlet.PortletURL;
import javax.portlet.WindowState;
import javax.portlet.WindowStateException;
import javax.servlet.ServletContext;

import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Reference;

@Component(
        immediate = true,
        property = {"javax.portlet.name=" + GuestbookPortletKeys.GUESTBOOK},
        service = AssetRendererFactory.class
        )
public class EntryAssetRendererFactory extends BaseAssetRendererFactory<Entry> {

    public EntryAssetRendererFactory() {
        setClassName(CLASS_NAME);
        setLinkable(_LINKABLE);
        setPortletId(GuestbookPortletKeys.GUESTBOOK);
        setSearchable(true);
        setSelectable(true);

    }

    @Override
    public AssetRenderer<Entry> getAssetRenderer(long classPK, int type)
            throws PortalException {

        Entry entry = _entryLocalService.getEntry(classPK);

        EntryAssetRenderer entryAssetRenderer = new EntryAssetRenderer(entry, _entryModelResourcePermission);

        entryAssetRenderer.setAssetRendererType(type);
        entryAssetRenderer.setServletContext(_servletContext);

        return entryAssetRenderer;
    }

    @Override
    public String getClassName() {
        return CLASS_NAME;
    }

    @Override
    public String getType() {
        return TYPE;
    }

    @Override
    public boolean hasPermission(PermissionChecker permissionChecker,
            long classPK, String actionId) throws Exception {

        Entry entry = _entryLocalService.getEntry(classPK);
        return GuestbookEntryPermission.contains(permissionChecker, entry, actionId);
    }

    @Override
    public PortletURL getURLAdd(LiferayPortletRequest liferayPortletRequest,
            LiferayPortletResponse liferayPortletResponse, long classTypeId) {

        PortletURL portletURL = null;

        try {
            ThemeDisplay themeDisplay = (ThemeDisplay) liferayPortletRequest.getAttribute(WebKeys.THEME_DISPLAY);

            portletURL = liferayPortletResponse.createLiferayPortletURL(getControlPanelPlid(themeDisplay),
                    GuestbookPortletKeys.GUESTBOOK, PortletRequest.RENDER_PHASE);
            portletURL.setParameter("mvcRenderCommandName", "/guestbookwebportlet/edit_entry");
            portletURL.setParameter("showback", Boolean.FALSE.toString());
        } catch (PortalException e) {
        }

        return portletURL;
    }

    @Override
    public PortletURL getURLView(LiferayPortletResponse liferayPortletResponse, WindowState windowState) {

        LiferayPortletURL liferayPortletURL
        = liferayPortletResponse.createLiferayPortletURL(
                GuestbookPortletKeys.GUESTBOOK, PortletRequest.RENDER_PHASE);

        try {
            liferayPortletURL.setWindowState(windowState);
        } catch (WindowStateException wse) {

        }
        return liferayPortletURL;
    }

    @Override
    public boolean isLinkable() {
        return _LINKABLE;
    }

    @Override
    public String getIconCssClass() {
        return "pencil";
    }

    @Reference(target = "(osgi.web.symbolicname=com.liferay.docs.guestbook.portlet)",
            unbind = "-")
    public void setServletContext (ServletContext servletContext) {
        _servletContext = servletContext;
    }

    @Reference(unbind = "-")
    protected void setEntryLocalService(EntryLocalService entryLocalService) {
        _entryLocalService = entryLocalService;
    }


    private EntryLocalService _entryLocalService;
    private ServletContext _servletContext;
    private static final boolean _LINKABLE = true;
    public static final String CLASS_NAME = Entry.class.getName();
    public static final String TYPE = "entry";

    private ModelResourcePermission<Entry>
    _entryModelResourcePermission;


}
\end{verbatim}

\subsection{Exporting the Asset
Package}\label{exporting-the-asset-package}

The container makes the asset renderers and their factories available to
Liferay DXP when it needs them. You must export the package to the
container.

Open the \texttt{guestbook-service} module's \texttt{bnd.bnd} file and
add the asset package to the \texttt{Export-Package} declaration. When
you're finished, it should look like this:

\begin{verbatim}
Export-Package: com.liferay.docs.guestbook.asset,\
                com.liferay.docs.guestbook.service.permission,\
                com.liferay.docs.guestbook.web.internal.security.permission.resource,\
                com.liferay.docs.guestbook.search
\end{verbatim}

Now your guestbook project's entities are fully asset-enabled. To test
the functionality, add the Asset Publisher portlet to a page. Then add
and edit guestbooks and guestbook entries. Then check the Asset
Publisher portlet. The Asset Publisher dynamically displays assets of
any kind from the current Site.

\begin{figure}
\centering
\includegraphics{./images/custom-entities-asset-publisher.png}
\caption{After you've implemented and registered your asset renderers
for your custom entities, the Asset Publisher can display your
entities.}
\end{figure}

Confirm that the Asset Publisher displays the guestbooks and guestbook
entries that you added.

Great! Next, you'll update your portlets' user interfaces to use several
asset framework features: comments, ratings, tags, categories, and
related assets.

\chapter{Adding Asset Features to Your User
Interface}\label{adding-asset-features-to-your-user-interface}

\begin{verbatim}
<p id="stepTitle">Adding Asset Features to Your UI</p><p>Step 1 of 5</p>
\end{verbatim}

Now that your guestbook and guestbook entry entities are asset-enabled,
you can add asset functionality to your application. You'll start by
implementing comments, ratings, tags, categories, and related assets for
guestbooks. Then you'll do the same for guestbook entries. All the
back-end support for these features is already implemented. Your only
task is to update your applications' user interfaces to use these
features.

Now you'll create several new JSPs that need new imports. Add the
following imports to the \texttt{guestbook-web} module project's
\texttt{init.jsp} file:

\begin{verbatim}
<%@ taglib uri="http://liferay.com/tld/asset" prefix="liferay-asset" %>
<%@ taglib uri="http://liferay.com/tld/comment" prefix="liferay-comment" %>

<%@ page import="java.util.Map" %> 
<%@ page import="java.util.HashMap" %>
<%@ page import="com.liferay.asset.kernel.service.AssetEntryLocalServiceUtil" %>
<%@ page import="com.liferay.asset.kernel.service.AssetTagLocalServiceUtil" %>
<%@ page import="com.liferay.asset.kernel.model.AssetEntry" %>
<%@ page import="com.liferay.asset.kernel.model.AssetTag" %>
<%@ page import="com.liferay.portal.kernel.util.ListUtil" %>
<%@ page import="com.liferay.portal.kernel.comment.Discussion" %>
<%@ page import="com.liferay.portal.kernel.comment.CommentManagerUtil" %>
<%@ page import="com.liferay.portal.kernel.service.ServiceContextFunction" %>
\end{verbatim}

Add these imports now so you don't run into errors as you work through
this section.

\section{Creating JSPs for Displaying Custom Assets in the Asset
Publisher}\label{creating-jsps-for-displaying-custom-assets-in-the-asset-publisher}

\begin{verbatim}
<p id="stepTitle">Adding Asset Features to Your UI</p><p>Step 2 of 5</p>
\end{verbatim}

Before proceeding, you must tie up a loose end from the previous step.
Remember that you implemented \texttt{getJspPath} methods in your
\texttt{GuestbookAssetRenderer} and \texttt{EntryAssetRenderer} classes
to JSPs that don't exist yet. These methods return paths to JSPs the
Asset Publisher uses to display the assets' full content. The
\texttt{getJspPath} method of \texttt{GuestbookAssetRenderer} returns
\texttt{"/asset/guestbook/full\_content.jsp"}, and the
\texttt{getJspPath} method of \texttt{EntryAssetRenderer} returns
\texttt{"/asset/entry/full\_content.jsp"}. It's time to create these
JSPs.

Follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In the \texttt{guestbook-web} module project, create a new folder
  called \texttt{asset} under the \texttt{resources/META-INF/resources}
  folder. Add two folders to this new folder: \texttt{entry} and
  \texttt{guestbook}.
\item
  Create a new file called \texttt{full\_content.jsp} in the
  \texttt{/asset/guestbook} folder. This JSP displays a guestbook
  asset's full content. Add the following code to this file:

\begin{verbatim}
<%@include file="../../init.jsp"%>

<%
Guestbook guestbook = (Guestbook)request.getAttribute("gb_guestbook");

guestbook = guestbook.toEscapedModel();
%>

<dl>
        <dt>Name</dt>
        <dd><%= guestbook.getName() %></dd>
</dl>
\end{verbatim}

  This JSP grabs the guestbook object from the request and displays the
  guestbook's name. In \texttt{GuestbookAssetRenderer}, the
  \texttt{getJspPath} method added the \texttt{gb\_guestbook} request
  attribute:

\begin{verbatim}
request.setAttribute("gb_guestbook", _guestbook);
\end{verbatim}

  The guestbook's \texttt{toEscapedModel} method belongs to the
  \texttt{GuestbookModelImpl} class, which was generated by Service
  Builder. This method returns a \emph{safe} guestbook object (a
  guestbook in which each field is HTML-escaped). Calling
  \texttt{guestbook\ =\ guestbook.toEscapedModel()} before displaying
  the guestbook name ensures that your JSP won't display malicious code
  that's masquerading as a guestbook name.
\item
  Next, in the \texttt{/asset/entry} folder, create a
  \texttt{full\_content.jsp} for displaying a guestbook entry asset's
  full content. Add the following code to this file:

\begin{verbatim}
<%@include file="../../init.jsp"%>

<%
Entry entry = (Entry)request.getAttribute("gb_entry");

entry = entry.toEscapedModel();
%>

<dl>
        <dt>Guestbook</dt>
        <dd><%= GuestbookLocalServiceUtil.getGuestbook(entry.getGuestbookId()).getName() %></dd>
        <dt>Name</dt>
        <dd><%= entry.getName() %></dd>
        <dt>Message</dt>
        <dd><%= entry.getMessage() %></dd>
</dl>
\end{verbatim}
\end{enumerate}

This JSP shows a combination of fields from the Guestbook and the
selected Entry.

After deploying your changes, test your new JSPs by clicking a
guestbook's or guestbook entry's title in the Asset Publisher. The Asset
Publisher renders \texttt{full\_content.jsp}:

\begin{figure}
\centering
\includegraphics{./images/asset-publisher-full-content.png}
\caption{When you click the title for a guestbook or guestbook entry in
the Asset Publisher, your \texttt{full\_content.jsp} should be
displayed.}
\end{figure}

By default, when displaying an asset's full view, the Asset Publisher
displays additional links for social media so you can publicize your
asset. The \emph{Back} icon and the \emph{View in Context} link return
you to the Asset Publisher's default view.

\section{Enabling Tags, Categories, and Related Assets for
Guestbooks}\label{enabling-tags-categories-and-related-assets-for-guestbooks}

\begin{verbatim}
<p id="stepTitle">Adding Asset Features to Your UI</p><p>Step 3 of 5</p>
\end{verbatim}

Since you already asset-enabled guestbooks at the service layer,
guestbook entities can now support tags and categories. All that's left
is to enable them in the UI. In this step, you'll update the Guestbook
Admin portlet's \texttt{edit\_guestbook.jsp} so administrators can add,
edit, or remove tags and categories when adding or updating a guestbook.

\subsection{Enabling Asset Features}\label{enabling-asset-features}

Follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In the \texttt{guestbook-web} module's
  \texttt{/guestbookadminportlet/edit\_guestbook.jsp}, add the tags
  \texttt{\textless{}liferay-ui:asset-categories-error\ /\textgreater{}}
  and \texttt{\textless{}liferay-ui:asset-tags-error/\textgreater{}} to
  the \texttt{aui:form} below the closing
  \texttt{\textless{}/aui:button-row\textgreater{}} tag:

\begin{verbatim}
<liferay-ui:asset-categories-error />
<liferay-ui:asset-tags-error />
\end{verbatim}

  These tags display error messages if an error occurs with the tags or
  categories submitted in the form.
\item
  Below the error tags, add a
  \texttt{\textless{}liferay-ui:panel\textgreater{}} tag with the
  following attributes:

\begin{verbatim}
<liferay-ui:panel defaultState="closed" extended="<%= false %>"
  id="guestbookCategorizationPanel" persistState="<%= true %>"
  title="categorization">

</liferay-ui:panel>
\end{verbatim}

  The \texttt{\textless{}liferay-ui:panel\textgreater{}} tag generates a
  collapsible section.
\item
  Add input fields for tags and categories inside the panel section you
  just created. Specify the \texttt{assetCategories} and
  \texttt{assetTags} types for the
  \texttt{\textless{}aui:input\ /\textgreater{}} tags. These input tags
  represent asset categories and asset tags. You can group related input
  fields together with an \texttt{\textless{}aui:fieldset\textgreater{}}
  tag. The tags generate the appropriate selectors for tags and
  categories and displays those that have already been added to the
  guestbook:

\begin{verbatim}
<aui:fieldset>
    <liferay-asset:asset-categories-selector className="<%= Guestbook.class.getName() %>" classPK="<%= guestbook %>" />
    <liferay-asset:asset-tags-selector className="<%= Guestbook.class.getName() %>" classPK="<%= guestbook %>" />
</aui:fieldset>
\end{verbatim}
\item
  Add a second \texttt{\textless{}liferay-ui:panel\textgreater{}} tag
  under the existing one. In this new tag, add an
  \texttt{\textless{}aui:fieldset\textgreater{}} tag containing a
  \texttt{\textless{}liferay-ui:asset-links\textgreater{}} tag. To
  display the correct asset links (the selected guestbook's related
  assets), set the \texttt{className} and \texttt{classPK} attributes:

\begin{verbatim}
<liferay-ui:panel defaultState="closed" extended="<%= false %>"
  id="guestbookAssetLinksPanel" persistState="<%= true %>"
  title="related-assets">
  <aui:fieldset>
    <liferay-ui:input-asset-links
      className="<%= Guestbook.class.getName() %>"
      classPK="<%= guestbookId %>" />
  </aui:fieldset>
</liferay-ui:panel>
\end{verbatim}
\end{enumerate}

Test the updated \texttt{edit\_guestbook.jsp} page by navigating to the
Guestbook Admin portlet in the Control Panel and clicking \emph{Add
Guestbook}. You'll see a field for adding tags and a selector for
selecting related assets.

\begin{figure}
\centering
\includegraphics{./images/guestbook-tags-related-assets.png}
\caption{Once you've updated your Guestbook Admin portlet's
\texttt{edit\_guestbook.jsp} page, you'll see forms for adding tags and
selecting related assets.}
\end{figure}

Don't do anything with these fields yet, because you're not done
implementing assets. Next, you'll enable tags and categories for
guestbook entries.

\section{Enabling Tags, Categories, and Related Assets for Guestbook
Entries}\label{enabling-tags-categories-and-related-assets-for-guestbook-entries}

\begin{verbatim}
<p id="stepTitle">Adding Asset Features to Your UI</p><p>Step 4 of 5</p>
\end{verbatim}

Enabling tags, categories, and related assets for guestbook entries is
similar to enabling them for guestbooks. Please refer back to the
previous step for a detailed explanation.

Open your \texttt{guestbook-web} module's
\texttt{guestbookwebportlet/edit\_entry.jsp} file. Replace its content
with the following code:

\begin{verbatim}
<%@ include file="../init.jsp" %>

    <%
    long entryId = ParamUtil.getLong(renderRequest, "entryId");

    Entry entry = null;

    if (entryId > 0) {
        entry = EntryLocalServiceUtil.getEntry(entryId);
    }

    long guestbookId = ParamUtil.getLong(renderRequest, "guestbookId");
    %>

    <portlet:renderURL var="viewURL">
        <portlet:param 
            name="mvcPath" 
            value="/guestbookwebportlet/view.jsp" 
        />
    </portlet:renderURL>

    <liferay-ui:header
        backURL="<%= viewURL.toString() %>"
        title="<%= entry == null ? "Add Entry" : entry.getName() %>"
    />

    <portlet:actionURL name="addEntry" var="addEntryURL" />

    <aui:form action="<%= addEntryURL %>" name="fm">
        <aui:model-context bean="<%= entry %>" model="<%= Entry.class %>" />

            <aui:fieldset>
                <aui:input name="name" />

                <aui:input name="email" />

                <aui:input name="message" />

                <aui:input name="entryId" type="hidden" />

                <aui:input name="guestbookId" type="hidden" 
                value=
                "<%= entry == null ? guestbookId : entry.getGuestbookId() %>" />
            </aui:fieldset>

    <liferay-ui:asset-categories-error />
                        <liferay-ui:asset-tags-error />
                        <liferay-ui:panel defaultState="closed" 
                        extended="<%= false %>" id="entryCategorizationPanel" 
                        persistState="<%= true %>" title="categorization">
                                <aui:fieldset>
                                   <liferay-asset:asset-categories-selector className="<%= Entry.class.getName() %>" classPK="<%= entryId %>" />
                                   <liferay-asset:asset-tags-selector className="<%= Entry.class.getName() %>" classPK="<%= entryId %>" />
                                </aui:fieldset>
                        </liferay-ui:panel>

                        <liferay-ui:panel defaultState="closed" 
                        extended="<%= false %>" id="entryAssetLinksPanel" 
                        persistState="<%= true %>" title="related-assets">
                                <aui:fieldset collapsed="<%= true %>" collapsible="<%= true %>" label="related-assets">
                
                    <liferay-asset:input-asset-links
                        className="<%= Entry.class.getName() %>"
                        classPK="<%= entryId %>"
                    />
                
                </aui:fieldset>
                        </liferay-ui:panel>

        <aui:button-row>
            <aui:button type="submit" />

            <aui:button onClick="<%= viewURL.toString() %>" type="cancel" />
        </aui:button-row>
    </aui:form>
\end{verbatim}

Test your JSP by using the Guestbook portlet to add and update Guestbook
entries. Add and remove tags, categories, and related assets.

\noindent\hrulefill

\textbf{Note:} Setting your custom asset as the \emph{Main Asset} of a
page is required to display related assets in the Related Assets
portlet. This is done when creating
\href{/docs/7-1/tutorials/-/knowledge_base/t/making-urls-friendlier}{Friendly
URLs} in a later step.

\noindent\hrulefill

Well done! Next, you'll enable comments and ratings for guestbook
entries.

\section{Enabling Comments and Ratings for Guestbook
Entries}\label{enabling-comments-and-ratings-for-guestbook-entries}

\begin{verbatim}
<p id="stepTitle">Adding Asset Features to Your UI</p><p>Step 5 of 5</p>
\end{verbatim}

The asset framework lets users comment on and rate assets. As with tags,
categories, and related assets, you must update the user interface to
expose these features. Good application design requires that you have a
View page where users can rate and comment on assets. Follow these steps
to enable comments and ratings on guestbook entries:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a new file called \texttt{view\_entry.jsp} in your
  \texttt{guestbook-web} module project's \texttt{/guestbookwebportlet}
  folder.
\item
  Add a Java scriptlet to the file you just created. In this scriptlet,
  use an \texttt{entryId} request attribute to get an entry object. For
  security reasons, convert this object to an escaped model as discussed
  in the earlier step
  \href{/docs/7.1/tutorials/-/knowledge_base/t/creating-jsps-for-displaying-custom-assets-in-the-asset-publisher}{Creating
  JSPs for Displaying Custom Assets in the Asset Publisher}:

\begin{verbatim}
<%@ include file="../init.jsp"%>

<%
  long entryId = ParamUtil.getLong(renderRequest, "entryId");

  long guestbookId = ParamUtil.getLong(renderRequest, "guestbookId");

  Entry entry = null;

  if (entryId > 0) {
    entry = EntryLocalServiceUtil.getEntry(entryId);

    entryId = entry.getEntryId();
  }

  entry = EntryLocalServiceUtil.getEntry(entryId);
  entry = entry.toEscapedModel();

  AssetEntry assetEntry = 
  AssetEntryLocalServiceUtil.getEntry(Entry.class.getName(), 
  entry.getEntryId());
\end{verbatim}
\item
  Next, update the breadcrumb entry with the current entry's name:

\begin{verbatim}
String currentURL = PortalUtil.getCurrentURL(request);
PortalUtil.addPortletBreadcrumbEntry(request, entry.getMessage(),
currentURL);
\end{verbatim}
\item
  At the end of the scriptlet, add the names of the current entry's
  existing asset tags as keywords to the portal page. These tag names
  appear in a
  \texttt{\textless{}meta\ content="{[}tag\ names\ here{]}"\ lang="en-US"\ name="keywords"\ /\textgreater{}}
  element in your portal page's \texttt{\textless{}head\textgreater{}}
  section. These keywords can help search engines find and index your
  page:

\begin{verbatim}
  PortalUtil.setPageSubtitle(entry.getMessage(), request);
  PortalUtil.setPageDescription(entry.getMessage(), request);

  List<AssetTag> assetTags = 
  AssetTagLocalServiceUtil.getTags(Entry.class.getName(), 
  entry.getEntryId());
  PortalUtil.setPageKeywords(ListUtil.toString(assetTags, "name"), 
  request);
%>
\end{verbatim}
\item
  After the scriptlet, specify the URLs for the page and back link:

\begin{verbatim}
<liferay-portlet:renderURL varImpl="viewEntryURL">
  <portlet:param name="mvcPath"
    value="/guestbookwebportlet/view_entry.jsp" />
  <portlet:param name="entryId" value="<%=String.valueOf(entryId)%>" />
</liferay-portlet:renderURL>

<liferay-portlet:renderURL varImpl="viewURL">
  <portlet:param name="mvcPath"
    value="/guestbookwebportlet/view.jsp" />
</liferay-portlet:renderURL>

<liferay-ui:header backURL="<%=viewURL.toString()%>"
  title="<%=entry.getName()%>" 
/>
\end{verbatim}
\item
  Next, define the page's main content. Display the guestbook's name,
  and the entry's name and message with the
  \texttt{\textless{}dl\textgreater{}},
  \texttt{\textless{}dt\textgreater{}}, and
  \texttt{\textless{}dd\textgreater{}} tags:

\begin{verbatim}
<dl>
  <dt>Guestbook</dt>
  <dd><%=GuestbookLocalServiceUtil.getGuestbook(entry.getGuestbookId()).getName()%></dd>
  <dt>Name</dt>
  <dd><%=entry.getName()%></dd>
  <dt>Message</dt>
  <dd><%=entry.getMessage()%></dd>
</dl>
\end{verbatim}

  This is the same way you defined the page's main content in
  \texttt{/guestbookwebportlet/full\_content.jsp}.
\item
  Next, use a
  \texttt{\textless{}liferay-ui:panel-container\textgreater{}} tag to
  create a panel container. Inside this tag, use a
  \texttt{\textless{}liferay-ui:panel\textgreater{}} tag to create a
  panel to display the comments and ratings components:

\begin{verbatim}
<liferay-ui:panel-container extended="<%=false%>"
  id="guestbookCollaborationPanelContainer" persistState="<%=true%>">
  <liferay-ui:panel collapsible="<%=true%>" extended="<%=true%>"
    id="guestbookCollaborationPanel" persistState="<%=true%>"
    title="Collaboration">
\end{verbatim}
\item
  Add the ratings component with the
  \texttt{\textless{}liferay-ui:ratings\textgreater{}} tag:

\begin{verbatim}
<liferay-ui:ratings className="<%=Entry.class.getName()%>"
  classPK="<%=entry.getEntryId()%>" type="stars" />

<br />
\end{verbatim}
\item
  Next you need to add a scriptlet to retrieve the comments discussion
  object:

\begin{verbatim}
<% Discussion discussion = 
CommentManagerUtil.getDiscussion(user.getUserId(), 
scopeGroupId, Entry.class.getName(), 
entry.getEntryId(), new ServiceContextFunction(request));
%>
\end{verbatim}
\item
  Below that add the tag for tracking the number of comments:

  '' key=`\textless\%= (discussion.getDiscussionCommentsCount() == 1) ?
  ``x-comment'' : ``x-comments'' \%\textgreater{}' /\textgreater{}
\item
  Create the \texttt{liferay-comment:discussion} tag, which creates the
  comments form, \emph{Reply} button, and retrieves the discussion
  content. It also handles the form action of posting the comment
  without requiring you to create a portlet action URL.

\begin{verbatim}
  <liferay-comment:discussion
    className="<%= Entry.class.getName() %>"
    classPK="<%= entry.getEntryId() %>"
    discussion="<%= discussion %>"
    formName="fm2"
    ratingsEnabled="true"
    redirect="<%= currentURL %>"
    userId="<%= entry.getUserId() %>"
    />

  </liferay-ui:panel>
</liferay-ui:panel-container>
\end{verbatim}
\item
  To restrict comments and ratings access to logged-in users, wrap the
  whole panel container in a \texttt{\textless{}c:if\textgreater{}} tag
  that tests the expression \texttt{themeDisplay.isSignedIn()}:

\begin{verbatim}
<c:if test="<%= themeDisplay.isSignedIn() %>">
    ... your panel container ...
</c:if>
\end{verbatim}

  Make sure you add the closing \texttt{\textless{}/c:if\textgreater{}}
  tag after the closing
  \texttt{\textless{}/liferay-ui:panel-container\textgreater{}} tag.
\end{enumerate}

\noindent\hrulefill

\textbf{Note:} Discussions (comments) are implemented as message board
messages. In the \texttt{MBMessage} table, there's a \texttt{classPK}
column. This \texttt{classPK} represents the guestbook entry's
\texttt{entryId}, linking the comment to the guestbook. Ratings are
stored in the \texttt{RatingsEntry} table. Similarly, the
\texttt{RatingsEntry} table contains a \texttt{classPK} column that
links the guestbook entry to the rating. Using a \texttt{classPK}
foreign key in one table to represent the primary key of another table
is a common pattern throughout Liferay DXP.

\noindent\hrulefill

Next, you'll update the guestbook actions to use the new view.

\subsection{Updating the Entry Actions
JSP}\label{updating-the-entry-actions-jsp}

Your \texttt{view\_entry.jsp} page is currently orphaned. Fix this by
adding the \emph{View} option to the Actions Menu. Open the
\texttt{/guestbookwebportlet/entry\_actions.jsp} and find the following
line:

\begin{verbatim}
<liferay-ui:icon-menu>
\end{verbatim}

Add the following lines below it:

\begin{verbatim}
<portlet:renderURL var="viewEntryURL">
  <portlet:param name="entryId"
    value="<%= String.valueOf(entry.getEntryId()) %>" />
  <portlet:param name="mvcPath"
    value="/guestbookwebportlet/view_entry.jsp" />
</portlet:renderURL>

<liferay-ui:icon message="View" url="<%= viewEntryURL.toString() %>" />
\end{verbatim}

Here, you create a URL that points to \texttt{view\_entry.jsp}. Test
this link by selecting the \emph{View} option in a guestbook entry's
Actions Menu. Then test your comments and ratings.

Excellent! You've asset-enabled the guestbook and guestbook entry
entities and enabled tags, categories, and related assets for both
entities. You've also enabled comments and ratings for guestbook entry
entities! Great job!

\begin{figure}
\centering
\includegraphics{./images/asset-publisher-full-content-finished.png}
\caption{Now you can see comments, rating, and the full range of asset
features.}
\end{figure}

Your next task is to generate web services. This makes it possible to
write other clients (such as mobile applications) for the Guestbook
application.

\chapter{Tooling}\label{tooling}

You can write code for Liferay using any standard toolset. Liferay is
tool-agnostic, rather than pigeonholing you into something specific.
This frees you to work with whatever you're already productive using.

Liferay has also created its own tools that streamline Liferay DXP
development. These tools integrate with popular build environments
(e.g., Gradle and Maven). They include

\begin{itemize}
\tightlist
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-ide}{Liferay Dev
  Studio DXP}: an Eclipse-based IDE supporting development for Liferay
  DXP.
\item
  \href{/docs/7-0/tutorials/-/knowledge_base/t/blade-cli}{Blade CLI}: a
  command line interface bootstrapped on to a Gradle based environment
  that is used to build and manage Liferay Workspaces and Liferay DXP
  projects.
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-workspace}{Liferay
  Workspace}: a generated environment built to hold and manage Liferay
  DXP projects.
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/intellij-idea}{Liferay
  IntelliJ plugin}: a plugin providing support for Liferay DXP
  development with IntelliJ IDEA.
\end{itemize}

Liferay also provides a plethora of
\href{/docs/7-1/reference/-/knowledge_base/r/gradle}{Gradle} and
\href{/docs/7-1/reference/-/knowledge_base/r/maven}{Maven plugins} you
can apply to your projects. Many of these are already built into tools
such as Liferay Workspace.

Want samples or predefined project templates? Liferay has you covered
with 30+
\href{/docs/7-1/reference/-/knowledge_base/r/project-templates}{project
templates} and many more
\href{/docs/7-1/reference/-/knowledge_base/r/sample-projects}{project
samples}.

If you're a newbie looking for the best development tool for Liferay
DXP, or even a seasoned veteran looking for a tool you may like more
than your current setup, this section will answer your tooling
questions.

\chapter{Liferay Dev Studio DXP}\label{liferay-dev-studio-dxp}

Liferay Dev Studio DXP provides an all-in-one, integrated development
environment based on Eclipse for Liferay DXP. Dev Studio includes
Liferay IDE plugins paired with a pre-installed Liferay Digital
Enterprise server.

@ide@ works with build tools such as Gradle and Maven and configuration
tools like BndTools.

Dev Studio makes Liferay development easier. There are editors for
Service Builder files, workflow definitions, POM files, and more. You'll
find wizards for creating every kind of Liferay project there is,
snippets for tag libraries, and auto-deploy of changes to plugins.

In this section of tutorials, you'll learn how to install Liferay Dev
Studio DXP and develop/manage modules using Liferay Workspace and other
technologies.

\section{Installing Liferay Dev Studio
DXP}\label{installing-liferay-dev-studio-dxp}

Liferay Dev Studio DXP is a plugin for Eclipse that provides many
Liferay-specific features and additional enterprise only features. You
can install it into your existing Eclipse environment, or Liferay
provides a bundled version. Before beginning the installation process,
view Dev Studio's
\href{https://web.liferay.com/group/customer/dxp/support/compatibility-matrix/developer-tools}{Compatibility
Matrix} to get acquainted with its supported Liferay versions and
application servers.

In this tutorial, you'll learn the different methods available for
installing Liferay Dev Studio:

\begin{itemize}
\tightlist
\item
  \hyperref[install-the-liferay-dev-studio-bundle]{install the Dev
  Studio bundle from scratch}
\item
  \hyperref[install-liferay-dev-studio-into-eclipse-environment]{install
  Dev Studio into an existing Eclipse instance using an update URL}
\item
  \hyperref[install-liferay-dev-studio-into-eclipse-from-a-zip-file]{install
  Dev Studio into an existing Eclipse instance using a ZIP file}
\end{itemize}

\textbf{Important:} If you're installing Dev Studio into an existing
Eclipse environment, you must be on Eclipse Oxygen or newer. For
instructions on upgrading to Oxygen, see Eclipse's
\href{https://wiki.eclipse.org/FAQ_How_do_I_upgrade_Eclipse_IDE\%3F\#Upgrading_existing_Eclipse_IDE_and_Installed_Features_to_newer_release}{upgrade
documentation}. With this particular upgrade, you should also deactivate
the current available update sites in the \emph{Window} →
\emph{Preferences} → \emph{Install/Update} → \emph{Available Software
Sites} menu to ensure a successful upgrade (e.g., Neon).

\subsection{Install the Liferay Dev Studio
Bundle}\label{install-the-liferay-dev-studio-bundle}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Download and install \href{http://java.oracle.com}{Java}. Liferay DXP
  runs on Java, so you'll need it to run everything else. Because you'll
  be developing apps for Liferay DXP in Liferay Dev Studio, the Java
  Development Kit (JDK) is required. It is an enhanced version of the
  Java Environment used for developing new Java technology. You can
  download the Java SE JDK from the Java
  \href{http://www.oracle.com/technetwork/java/javase/downloads/index.html}{Downloads}
  page.
\item
  Download Liferay's latest 3.2.x
  \href{https://sourceforge.net/projects/lportal/files/Liferay\%20IDE/}{Project
  SDK with Dev Studio DXP} executable that correlates to your operating
  system. The Project SDK includes Dev Studio DXP,
  \href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-workspace}{Liferay
  Workspace}, and
  \href{/docs/7-1/tutorials/-/knowledge_base/t/blade-cli}{Blade CLI}.

  You may be prompted for your liferay.com username and password before
  downloading the Liferay DXP installer. Since Dev Studio DXP includes
  access to Liferay DXP, you must verify that you have rights to use it.

  Your credentials are not saved locally; they're saved as a token in
  the \texttt{\textasciitilde{}/.liferay} folder. The token is used by
  your Dev Studio's
  \href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-workspace}{Liferay
  Workspace} if you ever decide to redownload a Liferay DXP bundle.
  Furthermore, the Liferay DXP bundle that was downloaded in your
  workspace is also copied to your
  \texttt{\textasciitilde{}/.liferay/bundles} folder, so if you decide
  to initialize another Liferay DXP instance of the same version, the
  bundle is not re-downloaded. See the
  \href{/docs/7-1/tutorials/-/knowledge_base/t/configuring-a-liferay-workspace\#adding-a-liferay-bundle-to-a-workspace}{Adding
  a Liferay Bundle to a Workspace} for more information on this topic.

  \textbf{Important:} The token generator sometimes has issues
  generating a token for workspaces built behind a proxy. If you're
  unable to automatically generate a workspace token, you can
  \hyperref[generating-a-workspace-token-manually]{generate one
  manually}.
\item
  Run the installer. You may need to allow permission for the installer
  to run, depending on your operating system and where you want to
  install it.
\item
  Select the Java Runtime to use for the installation process. Then
  click \emph{Next}.
\item
  Click \emph{Next} to begin the installation process. Select the
  installation folder for your Liferay Dev Studio instance. Then click
  \emph{Next}.

  \begin{figure}
  \centering
  \includegraphics{./images/dev-studio-install.png}
  \caption{Choose the folder your Dev Studio instance should reside.}
  \end{figure}
\item
  Input the Liferay DXP activation key to set up the Liferay DXP bundle
  packaged with Dev Studio DXP. Then click \emph{Next}.

  Dev Studio installs
  \href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-workspace}{Liferay
  Workspace} by default, which is a developer environment used to build
  and manage Liferay DXP projects. The installer automatically installs
  Liferay Workspace and its dedicated command line tool
  (\href{/docs/7-1/tutorials/-/knowledge_base/t/blade-cli}{Blade CLI}).
\item
  Configure proxy settings for your Project SDK. If you must use Dev
  Studio behind a firewall, you may want to configure the proxy
  settings. See the
  \href{/docs/7-1/tutorials/-/knowledge_base/t/setting-proxy-requirements-for-liferay-ide}{Liferay
  IDE Proxy Settings} and
  \href{/docs/7-1/tutorials/-/knowledge_base/t/setting-proxy-requirements-for-liferay-workspace}{Liferay
  Workspace Proxy Settings} tutorials for more information. Skip this
  step if you don't need this.

  \begin{figure}
  \centering
  \includegraphics{./images/dev-studio-proxy-settings.png}
  \caption{Configure your Project SDK's proxy settings, if necessary.}
  \end{figure}
\item
  Click \emph{Next} to finish the installation process for your Dev
  Studio instance.
\end{enumerate}

Congratulations! You've installed Liferay Dev Studio DXP! It's now
available in the folder you specified. To run Dev Studio, execute the
\texttt{DeveloperStudio} executable. A Liferay Workspace has also been
initialized in that same folder.

\subsection{Install Liferay Dev Studio into Eclipse
Environment}\label{install-liferay-dev-studio-into-eclipse-environment}

To install Dev Studio using an update URL, follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In Eclipse, go to \emph{Help} → \emph{Install New Software\ldots{}}.
\item
  In the \emph{Work with} field, copy in the URL
  http://releases.liferay.com/tools/ide/latest/milestone/.
\item
  You'll see the Dev Studio components in the list below. Check them off
  and click \emph{Next}.
\item
  Accept the terms of the agreements. Click \emph{Next}, and Dev Studio
  is installed. Like other Eclipse plugins, you must restart Eclipse to
  use them.
\end{enumerate}

Liferay Dev Studio is now installed in your existing Eclipse
environment.

\subsection{Install Liferay Dev Studio into Eclipse from a ZIP
File}\label{install-liferay-dev-studio-into-eclipse-from-a-zip-file}

To install Dev Studio using a Zip file, follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Go to the
  \href{https://web.liferay.com/group/customer/dxp/downloads/developer-tools}{Liferay
  Dev Studio DXP} downloads page. From the drop-down menu, select
  \emph{Developer Studio Updatesite Zip} and click \emph{Download}.
\item
  In Eclipse, go to \emph{Help} → \emph{Install New Software\ldots{}}.
\item
  In the \emph{Add} dialog, click the \emph{Archive} button and browse
  to the location of the downloaded Liferay Dev Studio Update Site
  \texttt{.zip} file. Then press \emph{OK}.
\item
  You'll see the Dev Studio components in the list below. Check them off
  and click \emph{Next}.

  \begin{figure}
  \centering
  \includegraphics{./images/dev-studio-zip-install.png}
  \caption{Make sure to check all the Dev Studio components you wish to
  install.}
  \end{figure}
\item
  Accept the terms of the agreements and click \emph{Next}, and
  Developer Studio is installed. Like other Eclipse plugins, you must
  restart Eclipse to use them.
\end{enumerate}

Awesome! You've installed Liferay Dev Studio in your existing Eclipse
environment.

\subsection{Generating a Workspace Token
Manually}\label{generating-a-workspace-token-manually}

If you run into any issues with generating your token automatically, you
can follow the steps below to manually create one.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Navigate to \href{https://www.liferay.com/}{www.liferay.com} and log
  in to your account.
\item
  Hover over your profile picture in the top-right corner and select
  \emph{Account Home}.
\item
  Select \emph{Account Settings} from the left menu.
\item
  Click \emph{Authorization Tokens} from the right menu under the
  Miscellaneous heading.

  \begin{figure}
  \centering
  \includegraphics{./images/authorization-tokens-option.png}
  \caption{You can manually create your workspace token in the
  Authorization Tokens menu.}
  \end{figure}
\item
  Select \emph{Add Token}, give it a device name, and click
  \emph{Generate}. The device name can be set to any string; it's for
  bookkeeping purposes only.
\item
  Create a file named \texttt{\textasciitilde{}/.liferay/token} and copy
  the generated token into that file.

  \begin{figure}
  \centering
  \includegraphics{./images/generated-token.png}
  \caption{The generated token is available to copy.}
  \end{figure}

  Make sure there are no new lines or white space in the file. It should
  only be one line.
\end{enumerate}

You've successfully generated your token manually and it's now available
for your installer to access. If you haven't run the installer, you can
do so now. If you've already run the installer, you can set the DXP
bundle to download in the \texttt{gradle.properties} file of your
workspace. See the
\href{/docs/7-1/tutorials/-/knowledge_base/t/configuring-a-liferay-workspace\#adding-a-liferay-bundle-to-a-workspace}{Adding
a Liferay Bundle to a Workspace} tutorial for details.

\section{Creating a Liferay Workspace with Dev
Studio}\label{creating-a-liferay-workspace-with-dev-studio}

In this tutorial, you'll learn how to generate a Liferay Workspace using
Liferay Dev Studio, which runs on the
\href{/docs/7-1/tutorials/-/knowledge_base/t/blade-cli}{Blade CLI}
behind the scenes. Dev Studio gives you a graphical interface instead of
the command prompt, which can streamline your workflow. To learn more
about Liferay Workspaces, visit its dedicated
\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-workspace}{tutorial
section}.

!P\href{https://portal.liferay.dev/documents/113763090/113919826/vid-ide-thumbnail.png}{Video
Thumbnail}

Before creating your Liferay Workspace, you should understand the new
perspectives designed for Liferay DXP development: the \emph{Liferay
Workspace} and \emph{Liferay Plugins} perspectives. If you plan on using
a Liferay Workspace for your Liferay DXP development, you should select
the \emph{Liferay Workspace} perspective (default). This offers
development tools that are helpful when using a Liferay Workspace. The
\emph{Liferay Plugins} perspective is for developers using Ant-based
development tools such as the Plugins SDK. Since the Plugins SDK is only
provided for Liferay Portal/DXP 7.0 and older development, this should
not be used for 7.0 development.

To create a Liferay Workspace in Dev Studio, select \emph{File} →
\emph{New} → \emph{Liferay Workspace Project}.

\begin{figure}
\centering
\includegraphics{./images/selecting-liferay-workspace.png}
\caption{By selecting \emph{Liferay Workspace}, you begin the process of
creating a new workspace for your Liferay projects.}
\end{figure}

A New Liferay Workspace dialog appears, presenting several configuration
options. Follow the instructions below to create your workspace.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Give your workspace project a name.
\item
  Choose the location where you'd like your workspace to reside.
  Checking the \emph{Use default location} checkbox places your Liferay
  Workspace in the Eclipse workspace you're working in.
\item
  Select the build tool you want your workspace to be build with (i.e.,
  Gradle or Maven).
\item
  Choose the Liferay DXP version you plan to develop for (i.e., 7.1 or
  7.0).
\item
  Select the specific target platform version corresponding to the GA
  release you're developing for (e.g., 7.1.0 → 7.1 GA1). For more
  information on target platform benefits, see the
  \href{/docs/7-1/tutorials/-/knowledge_base/t/managing-the-target-platform-for-liferay-workspace}{Managing
  the Target Platform for Liferay Workspace} articles.
\item
  Check the \emph{Download Liferay bundle} checkbox if you'd like to
  auto-generate a Liferay instance in your workspace. You'll be prompted
  to name the server and provide the server's download URL, if selected.
  This Liferay bundle is generated the same way as described in the
  previous section.
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** If you'd like to configure a pre-existing Liferay bundle to your
 workspace, you can create a directory for the bundle in your workspace and
 configure it in the workspace's `gradle.properties` file by setting the
 `liferay.workspace.home.dir` property.
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{6}
\item
  Check the \emph{Add project to working set} checkbox if you want the
  workspace to be a part of a larger working set you've already created
  in Dev Studio. For more information on working sets, visit
  \href{http://help.eclipse.org/mars/index.jsp?topic=\%2Forg.eclipse.platform.doc.user\%2Fconcepts\%2Fcworkset.htm}{Eclipse
  Help}.
\item
  Click \emph{Finish} to create your Liferay Workspace.
\end{enumerate}

\begin{figure}
\centering
\includegraphics{./images/new-workspace-menu.png}
\caption{Liferay Dev Studio provides an easy-to-follow menu to create
your Liferay Workspace.}
\end{figure}

A dialog appears prompting you to open the Liferay Workspace
perspective. Click \emph{Yes}, and your perspective will switch to
Liferay Workspace.

\noindent\hrulefill

\textbf{Note:} You can also create a Liferay Workspace during the
initial start-up of a Liferay Developer Studio instance.

\noindent\hrulefill

Awesome! You've successfully created a Liferay Workspace in Dev Studio!

\subsection{Liferay Workspace Settings in Dev
Studio}\label{liferay-workspace-settings-in-dev-studio}

The Liferay Workspace perspective is intended for Gradle or Maven
projects for Liferay DXP. Since Liferay Workspaces are used for
Gradle/Maven based development and the Liferay Plugins perspective is
intended for the Plugins SDK and Ant based development, the two
perspectives are independent of each other.

\begin{figure}
\centering
\includegraphics{./images/liferay-workspace-perspective.png}
\caption{The Liferay Workspace perspective is preferred for 7.0 and OSGi
module development.}
\end{figure}

You'll find your new workspace in the Project Explorer and your Liferay
server (if you created it) in the Servers menu. It's important to note
that an Eclipse workspace can only have one Liferay Workspace project.

\begin{figure}
\centering
\includegraphics{./images/liferay-workspace-duplicate.png}
\caption{A Dev Studio workspace only supports one Liferay Workspace
project. If you create another, you'll be given an error message.}
\end{figure}

You can configure your workspace's module presentation by switching
between the default \emph{Hierarchical} or \emph{Flat} views. To do
this, navigate to the Project Explorer's \emph{View Menu}
(\includegraphics{./images/icon-ide-view-menu.png}), select
\emph{Projects Presentation} and then select the presentation mode you'd
like to display. The Hierarchical view displays subfolders and
subprojects under the workspace project, whereas the Flat view displays
the workspace's modules separately from the workspace.

\begin{figure}
\centering
\includegraphics{./images/workspace-presentation.png}
\caption{The Hierarchical project presentation mode is set, by default.}
\end{figure}

If you've already created a Liferay Workspace and you'd like to import
it into your existing Dev Studio, you can do so by navigating to
\emph{File} → \emph{Import} → \emph{Liferay} → \emph{Liferay Workspace
Project}. Then click \emph{Next} and browse for your workspace project.
Once you've selected you workspace, click \emph{Finish}.

\begin{figure}
\centering
\includegraphics{./images/liferay-workspace-import.png}
\caption{You can import an existing Liferay Workspace into your current
Dev Studio session.}
\end{figure}

Congratulations! You've learned how to create and configure a Liferay
Workspace using Liferay Dev Studio. Now that your workspace is created,
you can begin creating Liferay projects.

!V\href{https://portal.liferay.dev/documents/113763090/113919826/getting-started-with-liferay-ide.mp4\%7Chttps://portal.liferay.dev/documents/113763090/113919826/getting-started-with-liferay-ide.webm}{Video
Tutorial}

\section{Setting Proxy Requirements for Liferay Dev
Studio}\label{setting-proxy-requirements-for-liferay-dev-studio}

If you have proxy server requirements and want to configure your http(s)
proxy\\
to work with Liferay Dev Studio, follow the instructions below.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Navigate to Eclipse's \emph{Window} → \emph{Preferences} →
  \emph{General} → \emph{Network Connections} menu.
\item
  Set the \emph{Active Provider} drop-down selector to \emph{Manual}.
\item
  Under \emph{Proxy entries}, configure both proxy HTTP and HTTPS by
  clicking the field and selecting the \emph{Edit} button.

  \begin{figure}
  \centering
  \includegraphics{./images/ide-network-connections.png}
  \caption{You can configure your proxy settings in Dev Studio's Network
  Connections menu.}
  \end{figure}
\item
  For each schema (HTTP and HTTPS), enter your proxy server's host,
  port, and authentication settings (if necessary).

  \textbf{Note:} Do not leave whitespace at the end of your proxy host
  or port settings.
\item
  Once you've configured your proxy entry, click \emph{OK} → \emph{OK}.
\end{enumerate}

If you're working with a Liferay Workspace in Dev Studio, you'll need to
configure your proxy settings for that environment too. See the
\href{/docs/7-1/tutorials/-/knowledge_base/t/setting-proxy-requirements-for-liferay-workspace}{Setting
Proxy Requirements for Liferay Workspace} for more details.

Awesome! You've successfully configured Dev Studio's proxy settings!

\subsection{Additional Proxy Settings}\label{additional-proxy-settings}

Some Eclipse plugins do not properly check the \texttt{core.net} proxy
infrastructure when setting proxy settings via \emph{Window} →
\emph{Preferences} → \emph{General} → \emph{Network Connections}.
Therefore, you may need to configure additional proxy settings.

To do so, open the \texttt{eclipse.ini} file associated with your
Eclipse installation and add the following entries:

\begin{verbatim}
    -vmargs
    -Dhttp.proxyHost=www.somehost.com
    -Dhttp.proxyPort=1080
    -Dhttp.proxyUser=userId
    -Dhttp.proxyPassword=somePassword
    -Dhttps.proxyHost=www.somehost.com
    -Dhttps.proxyPort=1080
    -Dhttps.proxyUser=userId
    -Dhttps.proxyPassword=somePassword
\end{verbatim}

After saving the file, restart Eclipse. Now your additional proxy
settings are applied!

\section{Updating Liferay Dev Studio}\label{updating-liferay-dev-studio}

If you're already using Liferay Dev Studio but need to update your
environment, follow the steps below:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In Dev Studio, go to \emph{Help} → \emph{Install New
  Software\ldots{}}.
\item
  In the \emph{Work with} field, copy in the URL
  http://releases.liferay.com/tools/ide/latest/stable/.
\item
  You'll see the Dev Studio components in the list below. Check them off
  and click \emph{Next}.

  \begin{figure}
  \centering
  \includegraphics{./images/ide-updatesite-install.png}
  \caption{Make sure to check all the Dev Studio components you wish to
  install.}
  \end{figure}
\item
  Accept the terms of the agreements. Click \emph{Next}, and Dev Studio
  is updated. You must restart Dev Studio for the updates to take
  effect.
\end{enumerate}

You're now on the latest version of Liferay Dev Studio!

\section{Creating Modules with Liferay Dev
Studio}\label{creating-modules-with-liferay-dev-studio}

Dev Studio provides a Module Project Wizard for users to create a
variety of different module projects. You can create a new Liferay
module project by navigating to \emph{File} → \emph{New} → \emph{Liferay
Module Project}.

\begin{figure}
\centering
\includegraphics{./images/new-module-project.png}
\caption{When selecting \emph{New} → \emph{Liferay Module Project}, a
Module Project Wizard appears.}
\end{figure}

You're given options for project name, location, build type, and
template type. You can build your project using Gradle or Maven. If
you're unsure for which template type to choose, see the
\href{/docs/7-1/reference/-/knowledge_base/r/project-templates}{Project
Templates} reference section. Click \emph{Next} and you're given
additional configuration options based on the project template you
selected. For example, if you selected a template that requires a
component class, you must configure it in the wizard.

\begin{figure}
\centering
\includegraphics{./images/component-class-wizard.png}
\caption{Specify your component class's details in the Portlet Component
Class Wizard.}
\end{figure}

You can specify your component class's name, package name, and its
properties. The properties you assign are the ones found in the
\texttt{@Component} annotation's \texttt{property\ =\ \{...\}}
assignment. See more about creating a component class in Liferay Dev
Studio in the \hyperref[creating-component-classes]{Creating Component
Classes} section.

Once you've configured your module, click \emph{Finish} to create your
project.

Now that you've created your module project, you can configure your
project's presentation in the Dev Studio's Project Explorer. To change
the project's presentation, select the default \emph{Hierarchical} or
\emph{Flat} views. To do this, navigate to the Project Explorer's
\emph{View Menu} (\includegraphics{./images/icon-ide-view-menu.png}),
select \emph{Projects Presentation} and then select the presentation
mode you'd like to display. The Hierarchical view displays subfolders
and subprojects under the project, whereas the Flat view displays the
modules separately from their project.

\begin{figure}
\centering
\includegraphics{./images/workspace-presentation.png}
\caption{The Hierarchical project presentation mode is set, by default.}
\end{figure}

You now have the knowledge to create a Liferay module project from
Liferay Dev Studio.

\subsection{Creating Component
Classes}\label{creating-component-classes}

You can also create a new component class for a pre-existing module
project. Navigate to \emph{File} → \emph{New} → \emph{Liferay Component
Class}. This is a similar wizard to the previous component class wizard,
except you can select a component class template. There are many
templates in the \texttt{Component\ Class\ Template} list:

\begin{itemize}
\tightlist
\item
  \emph{Auth Failures}: processes a verify login failure
\item
  \emph{Auth Max Failure}: processes maximum number of login failures
\item
  \emph{Authenticator}: authenticates processing
\item
  \emph{Friendly URL Mapper}: processes Friendly URLs
\item
  \emph{GOGO Command}: creates a custom Gogo command
\item
  \emph{Indexer Post Processor}: creates a new Indexer Post Processor
\item
  \emph{Login Pre Action}: creates a login pre action
\item
  \emph{MVC Portlet}: creates a new MVC portlet
\item
  \emph{Model Listener}: sets a model listener
\item
  \emph{Poller Processor}: creates a new poller processor
\item
  \emph{Portlet}: creates a new portlet class file
\item
  \emph{Portlet Action Command}: creates a new portlet action command
\item
  \emph{Portlet Filter}: creates a new portlet filter
\item
  \emph{Rest}: calls and wraps inner service in the way of Rest
\item
  \emph{Service Wrapper}: creates a new service wrapper
\item
  \emph{Struts in Action}: creates a new struts action
\item
  \emph{Struts Portlet Action}: creates a new struts portlet action
\end{itemize}

Next you'll learn how to import existing projects into Dev Studio.

\subsection{Importing Existing Module
Projects}\label{importing-existing-module-projects}

Dev Studio also provides a method to import existing module projects.
You can import a module project by navigating to \emph{File} →
\emph{Import} → \emph{Liferay} → \emph{Liferay Module Project(s)}. Then
point to the project location and click \emph{Finish}.

\begin{figure}
\centering
\includegraphics{./images/import-wizard.png}
\caption{Select the \emph{Liferay Module Project(s)} to import a module
project.}
\end{figure}

You're now equipped to import module projects into Liferay Dev Studio.
Now go out there and get stuff done!

\section{Creating Themes with Liferay Dev
Studio}\label{creating-themes-with-liferay-dev-studio}

Liferay Dev Studio lets you create and configure Liferay theme projects.
You can create a theme standalone or in a
\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-workspace}{Liferay
Workspace}. You can even create a Gradle or Maven based theme! Read on
to learn more about creating themes in Dev Studio.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In Dev Studio, navigate to \emph{File} → \emph{New} → \emph{Liferay
  Module Project}.
\item
  In the New Liferay Module Project wizard, give your project a name and
  select the \emph{theme} project template. Also choose your theme's
  build type by selecting either \emph{Gradle} or \emph{Maven}.

  \begin{figure}
  \centering
  \includegraphics{./images/theme-in-ide.png}
  \caption{Use the theme project template to create a Liferay theme in
  Dev Studio.}
  \end{figure}
\item
  Select \emph{Finish}.
\end{enumerate}

That's it! You've created a theme project in Dev Studio! Learn how to
deploy it in
\href{/docs/7-1/tutorials/-/knowledge_base/t/deploying-projects-with-liferay-ide}{this
tutorial}.

If you've
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-a-liferay-workspace-with-liferay-ide}{configured
a Liferay Workspace in your Dev Studio instance}, your theme is
available in the workspace's \texttt{wars} folder by default. If you
don't have a workspace configured in Dev Studio, it's available in the
root of Dev Studio's Project Explorer.

Note that themes created in Dev Studio follow a WAR-style layout.
Although the wizard can be misleading by calling the theme a new module
project, it is a WAR.

To modify a theme created in Dev Studio, mirror the folder structure of
the files you wish to change and copy them into your theme's
\texttt{webapp} folder.

\textbf{Important:} Under the hood, Dev Studio is using the
\href{/docs/7-1/reference/-/knowledge_base/r/theme-template}{theme
project template}. The WAR-style theme created by Dev Studio is
Gradle/Maven based; this differs from themes created with the
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-themes}{Liferay
Theme Generator} that use the
\href{https://github.com/liferay/liferay-themes-sdk/tree/master/packages}{Liferay
JS Theme Toolkit}. Do not mix these two development strategies. See the
\href{/docs/7-1/tutorials/-/knowledge_base/t/managing-themes-in-liferay-workspace}{Managing
Themes in Liferay Workspace} tutorial for more information on how these
two strategies are used in Workspace and Dev Studio.

If you're interested in creating Liferay themes using the Liferay Theme
Generator, see its dedicated
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-themes}{tutorial}.
For more general information on Liferay themes, visit their dedicated
tutorial section
\href{/docs/7-1/tutorials/-/knowledge_base/t/themes-and-layout-templates}{Themes
and Layout Templates}.

\section{Deploying Projects with Liferay Dev
Studio}\label{deploying-projects-with-liferay-dev-studio}

Deploying projects in Liferay Dev Studio is a cinch. Before deploying
your project, make sure you have a Liferay server configured in Dev
Studio. To see how to do this, see the
\href{/docs/7-1/tutorials/-/knowledge_base/t/installing-a-server-in-liferay-ide}{Installing
a Server in Liferay Dev Studio}

There are two ways to deploy a project to your Liferay server. You
should start your Liferay server before attempting to deploy to it.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Select the project from the Package Explorer window and drag it to
  your Liferay server in the Servers window.

  \begin{figure}
  \centering
  \includegraphics{./images/starting-module-dev-drag-module.png}
  \caption{You can use the drag-and-drop method to deploy your project
  to Liferay DXP.}
  \end{figure}
\item
  Right-click the server from the Servers window and select \emph{Add
  and Remove\ldots{}}. Add the project(s) you'd like to deploy from the
  Available window to the Configured window. Then click \emph{Finish}.

  \begin{figure}
  \centering
  \includegraphics{./images/add-and-remove-ide.png}
  \caption{Using the this deployment method is convenient when deploying
  multiple projects.}
  \end{figure}
\end{enumerate}

\noindent\hrulefill

\textbf{Note:} For a legacy Maven application, you were able to deploy
it by right-clicking it in the Package Explorer and selecting
\emph{Liferay} → \emph{Maven} → \emph{liferay:deploy}. This is no longer
possible because Liferay's Maven archetypes no longer rely on the legacy
\texttt{liferay-maven-plugin}. To deploy Maven projects in Dev Studio,
make sure to follow the methods described above.

\noindent\hrulefill

If you're deploying a project using
\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-workspace}{Liferay
Workspace}, the \texttt{watch} Blade CLI task is used to deploy your
project. This watches your local project and quickly propagates any
saved changes to the deployed project. With this, project updates are
viewable almost instantaneously from your Liferay server. For more info
on the \texttt{watch} task, see the
\href{/docs/7-1/tutorials/-/knowledge_base/t/deploying-projects-with-blade-cli}{Deploying
Projects with Blade CLI} article.

\noindent\hrulefill

\textbf{Note:} You can deploy standalone projects not residing in a
Liferay Workspace with the \texttt{watch} task by right-clicking the
project and selecting \emph{Liferay} → \emph{watch}.

\noindent\hrulefill

That's it! Once your project is deployed to the Liferay server, you can
verify its installation in Dev Studio's Console window.

\section{Managing Projects with Liferay Dev
Studio}\label{managing-projects-with-liferay-dev-studio}

Liferay Dev Studio provides the ability to manage Liferay projects from
a GUI. Before you begin learning about managing your projects from
Liferay Dev Studio, you should make sure a Liferay server is configured
in your Eclipse workspace so you can deploy and run your projects. You
can learn how to create a Liferay bundle and link it to your Liferay
workspace in the
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-a-liferay-workspace-with-liferay-ide}{Creating
a Liferay Workspace with Liferay Dev Studio} tutorial.

Once you've created projects, you can deploy them using Dev Studio.
First, make sure your Liferay server is started by clicking the
\emph{Start Server} button
(\includegraphics{./images/icon-start-server.png}). Then navigate to
your project from the Project Explorer and drag-and-drop it onto the
configured Liferay bundle in the \emph{Servers} menu. If at any time
you'd like to stop your Liferay server, click the \emph{Stop Server}
button (\includegraphics{./images/icon-stop-server.png}). Awesome!
You've deployed a project to your running Liferay instance!

For the deployed project, you can check if it has been deployed
successfully by using the
\href{/docs/7-1/reference/-/knowledge_base/r/using-the-felix-gogo-shell}{Gogo
Shell}. Right-click the started portal in your Server view and select
\emph{Open Gogo Shell}.

\begin{figure}
\centering
\includegraphics{./images/open-gogo-shell.png}
\caption{Select \emph{Open Gogo Shell} to open a terminal window in Dev
Studio using Gogo shell.}
\end{figure}

A Gogo shell terminal appears, allowing you to enter Gogo commands to
inspect your Liferay instance and the projects deployed to it. Enter the
\texttt{lb} command to view a list of deployed bundles. If the project
status is active, then it deployed successfully.

\begin{figure}
\centering
\includegraphics{./images/gogo-deploy-successful.png}
\caption{You can check to see if your project deployed successfully to
Liferay using the Gogo shell.}
\end{figure}

Dev Studio's Gogo shell usage requires
\href{/docs/7-1/tutorials/-/knowledge_base/t/using-developer-mode-with-themes\#setting-developer-mode-for-your-server-in-dev-studio}{Developer
Mode} to be enabled. Developer Mode is enabled in
\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-workspace}{Liferay
Workspace} by default.

Since the Liferay Workspace perspective in Dev Studio is Gradle-based,
you have some additional Gradle features you can take advantage of. The
Gradle Tasks toolbar presents Gradle commands for your workspace that
you can execute with a click of the mouse.

\begin{figure}
\centering
\includegraphics{./images/gradle-task-toolbar.png}
\caption{The Gradle Task toolbar offers Gradle tasks and their
descriptions, which can be executed by double-clicking them.}
\end{figure}

You can also access various Gradle build operations intended for Liferay
module projects. Right-click your module project and select
\emph{Liferay} and then the build command you want to execute.

\begin{figure}
\centering
\includegraphics{./images/gradle-build-operations.png}
\caption{You can execute build operations by right-clicking the Gradle
project in the Project Explorer.}
\end{figure}

To learn more about Gradle development in Liferay Dev Studio, see the
\href{/docs/7-1/tutorials/-/knowledge_base/t/using-gradle-in-liferay-ide}{Using
Gradle in Liferay Dev Studio} tutorial.

Excellent! You've learned how to manage your Gradle-based Liferay
Workspace using Dev Studio.

\section{Installing a Server in Liferay Dev
Studio}\label{installing-a-server-in-liferay-dev-studio}

Installing a server in Liferay Dev Studio is easy. In just a few steps
you'll have your server up and running. Follow these steps to install
your server:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In the Servers view, click the \emph{No Servers are available} link.
  If you already have a server installed, you can install a new server
  by right-clicking in the Servers view and selecting \emph{New} →
  \emph{Server}. This brings up a wizard that walks you through the
  process of defining a new server.
\item
  Select the type of server you would like to create from the list of
  available options. For a standard server, open the \emph{Liferay,
  Inc.} folder and select the \emph{Liferay 7.x} option. You can change
  the server name to something more unique too; this is the name
  displayed in the Servers view. Then click \emph{Next}. If you're
  creating a server for the first time, continue to the next step.

  \begin{figure}
  \centering
  \includegraphics{./images/define-new-server.png}
  \caption{Choose the type of server you want to create.}
  \end{figure}

  \textbf{Note:} If you've already configured previous Liferay servers,
  you'll be provided the \emph{Server runtime environment} field, which
  lets you choose previously configured runtime environments. If you
  want to re-add an existing server, select one from the dropdown menu.
  You can also add a new server by selecting \emph{Add}, or you can edit
  existing servers by selecting \emph{Configure runtime environments}.
  Once you've configured the server runtime environment, select
  \emph{Finish}. If you selected an existing server, your server
  installation is finished; you can skip steps 3-5.
\item
  Enter a name for your server. This is the name for the Liferay DXP
  runtime configuration used by Dev Studio. This is not the display name
  used in the Servers tab.
\item
  Browse to the installation folder of the Liferay DXP bundle. For
  example,
  \texttt{C:\textbackslash{}liferay-ce-portal-7.1-m1\textbackslash{}tomcat-8.0.32}.

  \begin{figure}
  \centering
  \includegraphics{./images/specify-directory.png}
  \caption{Specify the installation folder of the bundle.}
  \end{figure}
\item
  Select a runtime JRE and click \emph{Finish}. Your new server appears
  under the Servers view.

  \begin{figure}
  \centering
  \includegraphics{./images/new-server-added.png}
  \caption{Your new server appears under the \emph{Servers} view.}
  \end{figure}
\end{enumerate}

Your server is now available in Liferay Dev Studio!

For reference, here's how the Dev Studio server buttons work with your
Liferay DXP instance:

\begin{itemize}
\tightlist
\item
  \emph{Start} (\includegraphics{./images/icon-start-server.png}):
  Starts the server.
\item
  \emph{Stop} (\includegraphics{./images/icon-stop-server.png}): Stops
  the server.
\item
  \emph{Debug} (\includegraphics{./images/icon-debug-server.png}):
  Starts the server in debug mode. For more information on debugging in
  Dev Studio, see the
  \href{/docs/7-1/tutorials/-/knowledge_base/t/debugging-product-source-in-liferay-ide}{Debugging
  Liferay DXP source in Liferay Dev Studio} article.
\end{itemize}

Now you're ready to use your server in Liferay Dev Studio!

\section{Searching Liferay DXP Source in Liferay Dev
Studio}\label{searching-liferay-dxp-source-in-liferay-dev-studio}

In Liferay Dev Studio, you can search through Liferay DXP's source code
to aid in the development of your project. Liferay provides great
resources to help with development (e.g., official documentation,
\href{https://docs.liferay.com/}{docs.liferay.com},
\href{/docs/7-1/reference/-/knowledge_base/r/sample-projects}{sample
projects}, etc.), but sometimes, searching through Liferay's codebase
(i.e., platform and official apps) for patterns is just as useful. For
example, if you're creating a custom app that extends a class provided
in Liferay's \texttt{portal-kernel} JAR, you can inspect that class and
research how it's used in other areas of Liferay DXP's codebase.

To do this, you must be developing in a
\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-workspace}{Liferay
Workspace}. Liferay Workspace is able to provide this functionality by
targeting a specific Liferay DXP version, which indexes the configured
Liferay DXP source code to provide advanced search. See the
\href{/docs/7-1/tutorials/-/knowledge_base/t/managing-the-target-platform-for-liferay-workspace}{Managing
the Target Platform in Liferay Workspace} tutorial for more information
on how this works.

Workspace does not perform portal source indexing by default. You must
enable this functionality by adding the following property to your
workspace's \texttt{gradle.properties} file:

\begin{verbatim}
target.platform.index.sources=true
\end{verbatim}

\noindent\hrulefill

\textbf{Note:} Portal source indexing is disabled in Gradle workspace
version 2.0.3+ (Target Platform plugin version 2.0.0+).

\noindent\hrulefill

In this tutorial, you'll explore three use cases where advanced search
would be useful.

\begin{itemize}
\tightlist
\item
  \hyperref[search-class-hierarchy]{Search class hierarchy}
\item
  \hyperref[search-method-declarations]{Search declarations}
\item
  \hyperref[search-annotation-references]{Search references}
\end{itemize}

These examples are just a small subset of what you can search in Liferay
Dev Studio. See Eclipse's documentation on
\href{http://help.eclipse.org/oxygen/index.jsp?topic=\%2Forg.eclipse.jdt.doc.user\%2Fconcepts\%2Fconcept-java-search.htm&resultof=\%22\%6a\%61\%76\%61\%22\%20}{Java
Search} for a comprehensive guide.

\subsection{Search Class Hierarchy}\label{search-class-hierarchy}

Inspecting classes that extend a similar superclass can help you find
useful patterns and examples for how you can develop your own app. For
example, suppose your app extends the
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/bridges/mvc/MVCPortlet.html}{MVCPortlet}
class. You an search classes that extend that same class in Dev Studio
by right-clicking the \texttt{MVCPortlet} declaration and selecting
\emph{Open Type Hierarchy}. This opens a window that lets you inspect
all classes residing in the target platform that extend
\texttt{MVCPortlet}.

\begin{figure}
\centering
\includegraphics{./images/open-type-hierarchy.png}
\caption{Browse the Type Hierarchy window and open the provided classes
for examples on how to extend a class.}
\end{figure}

Great! Now you can search for all extensions and implementations of a
class/interface to aid in your quest for developing the perfect app.

\subsection{Search Method
Declarations}\label{search-method-declarations}

Sometimes you want a search to be more granular, exploring the
declarations of a specific method provided by a class/interface. Liferay
Dev Studio's advanced search has no limits; Liferay Workspace's target
platform indexing provides method exploration too!

Suppose in the
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/bridges/mvc/MVCPortlet.html}{MVCPortlet}
class you're extending, you'd like to search for declarations of its
\texttt{doView} method you're overriding. You can do this by
right-clicking the \texttt{doView} method declaration in your custom
app's class and selecting \emph{Declarations} → \emph{Workspace}.

\begin{figure}
\centering
\includegraphics{./images/inspect-declared-method.png}
\caption{All declarations of the method are returned in the Search
window.}
\end{figure}

The rendered Search window displays the other occurrences in the target
platform where that method was overridden.

\subsection{Search Annotation
References}\label{search-annotation-references}

Annotations used in Liferay DXP's source code can sometimes be cryptic.
With the ability to search where these types of annotations reside in
Liferay's target platform, you can find how they could be used in your
own app.

For example, you may find some official documentation on using the
\texttt{@Reference} annotation in an OSGi module and implement it in
your custom app. It could be useful to reference real world examples in
Liferay DXP's apps to check how it was used elsewhere. You could search
for this by right-clicking the annotation in a class and selecting
\emph{References} → \emph{Workspace}.

\begin{figure}
\centering
\includegraphics{./images/inspect-references-ide.png}
\caption{All matching annotations are displayed in the Search window.}
\end{figure}

The rendered Search window displays the other occurrences in the target
platform where that annotation was used.

Excellent! You now have the tools to search the configured target
platform specified in your Liferay Workspace!

\section{Debugging Liferay DXP Source in Liferay Dev
Studio}\label{debugging-liferay-dxp-source-in-liferay-dev-studio}

You can use Liferay Dev Studio to debug Liferay DXP source code to help
resolve errors. Debugging Liferay DXP code follows most of the same
techniques associated with debugging in Eclipse. If you need some help
with general debugging, you can visit Eclipse's documentation. Here's
some helpful Eclipse links to visit:

\begin{itemize}
\tightlist
\item
  \href{http://help.eclipse.org/oxygen/index.jsp?topic=\%2Forg.eclipse.jdt.doc.user\%2Fconcepts\%2Fcdebugger.htm&cp=1_2_9}{Debugger}
\item
  \href{http://help.eclipse.org/oxygen/index.jsp?topic=\%2Forg.eclipse.jdt.doc.user\%2Fconcepts\%2Fclocdbug.htm&cp=1_2_11}{Local
  Debugging}
\item
  \href{http://help.eclipse.org/oxygen/index.jsp?topic=\%2Forg.eclipse.jdt.doc.user\%2Fconcepts\%2Fcremdbug.htm&cp=1_2_12}{Remote
  Debugging}
\end{itemize}

There are a couple Liferay-specific configurations to know before
debugging Liferay DXP code:

\begin{itemize}
\tightlist
\item
  \hyperref[configure-your-target-platform]{Configure your target
  platform.}
\item
  \hyperref[configure-a-liferay-server-and-start-it-in-debug-mode]{Configure
  a Liferay server and start it in debug mode.}
\end{itemize}

Let's explore these Liferay-specific debugging configurations.

\subsection{Configure Your Target
Platform}\label{configure-your-target-platform}

To configure your target platform, you must be developing in a
\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-workspace}{Liferay
Workspace}. Liferay Workspace is able to provide debugging capabilities
by targeting a specific Liferay DXP version, which indexes the
configured Liferay DXP source code. You must enable this functionality
by adding the following property to your workspace's
\texttt{gradle.properties} file:

\begin{verbatim}
target.platform.index.sources=true
\end{verbatim}

\noindent\hrulefill

\textbf{Note:} Portal source indexing is disabled in Gradle workspace
version 2.0.3+ (Target Platform plugin version 2.0.0+).

\noindent\hrulefill

Without specifying a target platform, Liferay DXP's source code cannot
be accessed by Dev Studio. See the
\href{/docs/7-1/tutorials/-/knowledge_base/t/managing-the-target-platform-for-liferay-workspace}{Managing
the Target Platform in Liferay Workspace} tutorial for more information
on how this works.

\textbf{Important:} The target platform should match the Liferay server
version you configure in the next section.

Once the target platform is configured in your workspace, Eclipse has
access to all of Liferay DXP's source code. Next, you'll configure a
Liferay server and learn how to start it in Debug mode.

\subsection{Configure a Liferay Server and Start It in Debug
Mode}\label{configure-a-liferay-server-and-start-it-in-debug-mode}

Configuring your target platform gives Eclipse Liferay DXP's source code
to reference. Now you must configure a Liferay server matching the
target platform version so you can deploy the custom code you wish to
debug.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Set up your Liferay DXP server to run in Dev Studio. See the
  \href{/docs/7-1/tutorials/-/knowledge_base/t/installing-a-server-in-liferay-ide}{Installing
  a Server in Liferay Dev Studio} for more details.
\item
  Start the server in debug mode. To do this, click the debug button in
  the Servers pane of Liferay Dev Studio.

  \begin{figure}
  \centering
  \includegraphics{./images/ide-debug.png}
  \caption{The red box in this screenshot highlights the debug button.
  Click this button to start the server in debug mode.}
  \end{figure}
\end{enumerate}

Awesome! You're now equipped to begin debugging in Liferay Dev Studio!

\section{Using Gradle in Liferay Dev
Studio}\label{using-gradle-in-liferay-dev-studio}

\href{http://gradle.org/}{Gradle} is a popular open source build
automation system. You can take full advantage of Gradle in Liferay Dev
Studio by utilizing
\href{https://projects.eclipse.org/releases/photon}{Buildship}, which is
a collection of Eclipse plugin-ins that provide support for building
software using Gradle with Liferay Dev Studio. Buildship is bundled with
Liferay Dev Studio versions 3.0 and higher.

\begin{figure}
\centering
\includegraphics{./images/buildship-in-liferayide.png}
\caption{Navigate to \emph{Help} → \emph{Installation Details} to view
plugins included in Dev Studio.}
\end{figure}

The first thing you'll learn about in this tutorial is creating Gradle
projects in Dev Studio.

\subsection{Creating and Importing Gradle
Projects}\label{creating-and-importing-gradle-projects}

You can create a Gradle project by using the Gradle Project wizard.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Navigate to \emph{File} → \emph{New} → \emph{Project\ldots{}} and
  select \emph{Gradle} → \emph{Gradle Project}. Finally, click
  \emph{Next} → \emph{Next}.
\item
  Enter a valid project name. You can also specify your project location
  and working sets.
\item
  Optionally, you can navigate to the next page and specify your Gradle
  distribution and other advanced options. Once you're finished, select
  \emph{Finish}.
\end{enumerate}

\begin{figure}
\centering
\includegraphics{./images/new-gradle-project.png}
\caption{You can specify your Gradle distribution and advanced options
such as home directories, JVM options, and program arguments.}
\end{figure}

You can also import existing Gradle projects in Liferay Dev Studio.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Go to \emph{File} → \emph{Import\ldots{}} → \emph{Gradle} →
  \emph{Existing Gradle Project} → \emph{Next} → \emph{Next}.

  \begin{figure}
  \centering
  \includegraphics{./images/import-gradle-project.png}
  \caption{You can specify what Gradle project to import from the
  \emph{Import Gradle Project} wizard.}
  \end{figure}
\item
  Click the \emph{Browse\ldots{}} button to choose a Gradle project.
\item
  Optionally, you can navigate to the next page and specify your Gradle
  distribution and other advanced options. Once you're finished, click
  \emph{Next} again to review the import configuration. Select
  \emph{Finish} once you've confirmed your Gradle project import.

  \begin{figure}
  \centering
  \includegraphics{./images/import-configuration-overview.png}
  \caption{You can preview your Gradle project's import information.}
  \end{figure}
\end{enumerate}

Next you'll learn about Gradle tasks and executions, and learn how to
run and display them in Liferay Dev Studio.

\subsection{Gradle Tasks and
Executions}\label{gradle-tasks-and-executions}

Dev Studio provides two views to enhance your developing experience
using Gradle: Gradle Tasks and Gradle Executions. You can open these
views by following the instructions below.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Go to \emph{Window} → \emph{Show View} → \emph{Other\ldots{}}.
\item
  Navigate to the \emph{Gradle} folder and open \emph{Gradle Tasks} and
  \emph{Gradle Executions}.
\end{enumerate}

Gradle tasks and executions views open automatically once you create or
import a Gradle project.

The Gradle Tasks view lets you display the Gradle tasks available for
you to use in your Gradle project. Users can execute a task listed under
the Gradle project by double-clicking it.

\begin{figure}
\centering
\includegraphics{./images/gradle-tasks.png}
\caption{Navigate into your preferred Gradle project to view its
available Gradle tasks.}
\end{figure}

Once you've executed a Gradle task, you can open the Gradle Executions
view to inspect its output.

\begin{figure}
\centering
\includegraphics{./images/gradle-executions.png}
\caption{The Gradle Executions view helps you visualize the Gradle build
process.}
\end{figure}

Keep in mind that if you change the Gradle build scripts inside your
Gradle projects (e.g., \texttt{build.gradle} or
\texttt{settings.gradle}), you must refresh the project so Dev Studio
can account for the change and display it properly in your views. To
refresh a Gradle project, right-click on the project and select
\emph{Gradle} → \emph{Refresh Gradle Project}.

\begin{figure}
\centering
\includegraphics{./images/refresh-gradle-project.png}
\caption{Make sure to always refresh your Gradle project in Liferay Dev
Studio after build script edits.}
\end{figure}

If you prefer Eclipse refresh your Gradle projects automatically,
navigate to \emph{Window} → \emph{Preferences} → \emph{Gradle} and
enable the \emph{Automatic Project Synchronization} checkbox. If you'd
like to enable Gradle's automatic synchronization for just one Gradle
project, you can right-click a Gradle project and select
\emph{Properties} → \emph{Gradle} and enable auto sync that way.

Excellent! You're now equipped with the knowledge to add, import, and
build your Gradle projects in Liferay Dev Studio!

\section{Using Maven in Liferay Dev
Studio}\label{using-maven-in-liferay-dev-studio}

You can take full advantage of Maven in Liferay Dev Studio with its
built-in Maven support. In this tutorial, you'll learn about the
following topics:

\begin{itemize}
\tightlist
\item
  \hyperref[installing-maven-plugins-for-liferay-dev-studio]{Installing
  Maven Plugins for Liferay Dev Studio}
\item
  \hyperref[creating-maven-projects]{Creating Maven Projects}
\item
  \hyperref[importing-maven-projects]{Importing Maven Projects}
\item
  \hyperref[using-the-pom-graphic-editor]{Using the POM Graphic Editor}
\end{itemize}

First you'll install the necessary Maven plugins for Dev Studio.

\subsection{Installing Maven Plugins for Liferay Dev
Studio}\label{installing-maven-plugins-for-liferay-dev-studio}

In order to support Maven projects in Dev Studio properly, you first
need a mechanism to recognize Maven projects as Dev Studio projects. Dev
Studio projects are recognized in Eclipse as faceted web projects that
include the appropriate Liferay plugin facet. Therefore, all Dev Studio
projects are also Eclipse web projects (faceted projects with the web
facet installed). For Dev Studio to recognize the Maven project and for
it to be able to leverage Java EE tooling features (e.g., the Servers
view) with the project, the project must be a flexible web project. Dev
Studio relies on the following Eclipse plugins to provide this
capability:

\begin{itemize}
\tightlist
\item
  \texttt{m2e} (Maven integration for Eclipse)
\item
  \texttt{m2e-wtp} (Maven integration for WTP)
\end{itemize}

All you have to do is install them so you can begin developing Maven
projects for Liferay DXP.

When first installing Liferay Dev Studio, the installation startup
screen lets you select whether you'd like to install the Maven plugins
automatically. Don't worry if you missed this during setup. You'll learn
how to install the required Maven plugins for Dev Studio manually below.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Navigate to \emph{Help} → \emph{Install New Software}. In the
  \emph{Work with} field, insert the following value:

\begin{verbatim}
Liferay IDE repository - http://releases.liferay.com/tools/ide/latest/stable/
\end{verbatim}
\item
  Check the \emph{Liferay IDE Maven Support} option. This bundles all
  the required Maven plugins you need to begin developing Maven projects
  for Liferay DXP.

  \begin{figure}
  \centering
  \includegraphics{./images/maven-install-ide-plugins.png}
  \caption{You can install all the necessary Maven plugins for Dev
  Studio by installing the \emph{Liferay IDE Maven Support} option.}
  \end{figure}

  If the \emph{Liferay IDE Maven Support} option does not appear, then
  it's already installed. To verify that it's installed, uncheck the
  \emph{Hide items that are already installed} checkbox and look for
  \emph{Liferay IDE Maven Support} in the list of installed plugins.
  Also, if you'd like to view everything that is bundled with the
  \emph{Liferay IDE Maven Support} option, uncheck the \emph{Group items
  by category} checkbox.
\item
  Click \emph{Next}, review the install details, accept the term and
  license agreements, and select \emph{Finish}.
\end{enumerate}

Awesome! Your Dev Studio is ready to develop Maven projects for Liferay
DXP!

You'll learn about creating Maven projects in Dev Studio next.

\subsection{Creating Maven Projects}\label{creating-maven-projects}

You can create a Maven project based on Liferay's provided Maven
archetypes.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Navigate to \emph{File} → \emph{New} → \emph{Liferay Module Project}.
\item
  Give your project a name, select the \texttt{Maven} build type, and
  choose the project template (archetype) to use.

  \begin{figure}
  \centering
  \includegraphics{./images/create-maven-ide-project.png}
  \caption{The New Liferay Module Project wizard lets you generate a
  Maven project.}
  \end{figure}
\item
  (Optional) Click \emph{Next} and name your component class name and
  package. You can also specify your component class's properties in the
  Properties menu.
\item
  Click \emph{Finish}.
\end{enumerate}

That's it! You've created a Liferay module project using Maven!

If you created your Maven project outside of Dev Studio with another
tool, you can still manage that project in Dev Studio, but you must
first import it. You'll learn how to do this next.

\subsection{Importing Maven Projects}\label{importing-maven-projects}

To import a pre-existing Maven project into Dev Studio, follow the steps
outlined below:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Navigate to \emph{File} → \emph{Import} → \emph{Maven} →
  \emph{Existing Maven Projects} and click \emph{Next}.

  \begin{figure}
  \centering
  \includegraphics{./images/import-maven-project.png}
  \caption{Dev Studio offers the Maven folder in the Import wizard.}
  \end{figure}
\item
  Click \emph{Browse\ldots{}} and select the root folder for your Maven
  project. Once you've selected it, the \texttt{pom.xml} for that
  project should be visible in the Projects menu.

  \begin{figure}
  \centering
  \includegraphics{./images/select-maven-import.png}
  \caption{Use the Import Maven Projects wizard to import your
  pre-existing project.}
  \end{figure}
\item
  Click \emph{Finish}.
\end{enumerate}

Now your Maven project is available from the Package Explorer. Next
you'll learn about Dev Studio's POM graphical editor.

\subsubsection{Using the POM Graphic
Editor}\label{using-the-pom-graphic-editor}

You're provided a nifty POM graphic editor when opening your Maven
project's \texttt{pom.xml} in Dev Studio. This gives you several
different ways to leverage the power of Maven in your project:

\begin{itemize}
\item
  \textbf{Overview:} provides a graphical interface where you can add to
  and edit the \texttt{pom.xml} file.
\item
  \textbf{Dependencies:} provides a graphical interface for adding and
  editing dependencies in your project, as well as modifying the
  \texttt{dependencyManagement} section of the \texttt{pom.xml} file.
\item
  \textbf{Effective POM:} provides a read-only version of your project
  POM merged with its parent POM(s), \texttt{settings.xml}, and the
  settings in Eclipse for Maven.
\item
  \textbf{Dependency Hierarchy:} provides a hierarchical view of project
  dependencies and an interactive listing of resolved dependencies.
\item
  \textbf{pom.xml:} provides an editor for your POM's source XML.
\end{itemize}

The figure below shows the \texttt{pom.xml} file editor and its modes.

\begin{figure}
\centering
\includegraphics{./images/pom-editor-features.png}
\caption{Liferay Dev Studio provides five interactive modes to help you
edit and organize your POM..}
\end{figure}

By taking advantage of these interactive modes, Dev Studio makes
modifying and organizing your POM and its dependencies a snap!

\section{Enabling Code Assist Features in Your
Project}\label{enabling-code-assist-features-in-your-project}

Liferay Dev Studio's integration of \href{http://ternjs.net/}{Tern}
provides many valuable front-end and back-end development tools for code
inference and completion. This tutorial covers how to enable Tern
features for your projects.

Before beginning this tutorial, make sure your Dev Studio instance has
the necessary development tooling and Tern integration installed. To do
this, go to \emph{Help} → \emph{About Eclipse} → \emph{Installation
Details} and search for \emph{Liferay IDE AlloyUI} under \emph{Installed
Software}. If you have it installed, you can continue to the
\emph{Setting Up Tern Features} section; if you do not, you'll need to
install it by following the instructions below.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Navigate to \emph{Help} → \emph{Install New Software\ldots{}}.
\item
  Paste the following link into the \emph{Work with} field:

\begin{verbatim}
http://releases.liferay.com/tools/ide/latest/stable/
\end{verbatim}
\item
  Make sure the \emph{Liferay IDE AlloyUI} option is checked and finish
  the installation process.

  \begin{figure}
  \centering
  \includegraphics{./images/alloyui-ide-feature.png}
  \caption{The \emph{Liferay IDE AlloyUI} option is actually a
  sub-option listed within the \emph{Liferay IDE} option.}
  \end{figure}
\end{enumerate}

Now that the necessary features are installed, follow the steps below to
learn how to enable Tern's code assist features in your project.

\subsection{Setting Up Tern Features}\label{setting-up-tern-features}

Tern features are enabled on a project-by-project basis. By default,
Tern is already enabled for Liferay WAR-style portlets generated using
the Plugins SDK. For all other project types, (e.g., Liferay module
projects), you'll need to follow the steps below:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Right-click on your project and select \emph{Configure} →
  \emph{Convert to Tern Project}.

  Your project is now configured to use Tern. Now that you have your
  project configured, you need to enable the modules you want to use for
  your project.
\item
  You're presented a menu listing Tern plugins that are installed. For
  example, to use AlloyUI features, you'll need the \emph{AlloyUI},
  \emph{Browser}, \emph{JSCS}, \emph{Liferay}, and \emph{YUI Library}
  modules enabled. The figure below shows the Tern Modules menu.

  \begin{figure}
  \centering
  \includegraphics{./images/tern-modules.png}
  \caption{By selecting these Tern modules, you can use AlloyUI code
  assist features in your project.}
  \end{figure}

  If you need to refer back to this list of installed Tern plugins,
  right-click your project and select \emph{Properties}. Then select
  \emph{Tern} → \emph{Modules}.
\item
  Check any additional modules you wish to use in your project and click
  \emph{OK}.
\end{enumerate}

Your project is now set up to use Dev Studio's Tern features.

\subsection{Related Topics}\label{related-topics-14}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-front-end-code-assist-features-in-ide}{Using
Front-End Code Assist Features in Dev Studio}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-modules-with-liferay-ide}{Creating
Modules with Liferay Dev Studio}

\href{/docs/7-1/tutorials/-/knowledge_base/t/blade-cli}{Blade CLI}

\section{Using Front-End Code Assist Features in Dev
Studio}\label{using-front-end-code-assist-features-in-dev-studio}

Liferay Dev Studio provides extended front-end development tools to
assist in Liferay development. You now have access to code inferencing
and code completion features for AlloyUI, JavaScript, CSS, and jQuery.

This tutorial covers how to use the code assist features in Dev Studio
for

\begin{itemize}
\tightlist
\item
  \hyperref[alloyui-code-assist-features]{AlloyUI}
\item
  \hyperref[javascript-code-assist-features]{JavaScript}
\item
  \hyperref[css-code-assist-features]{CSS}
\item
  \hyperref[jquery-code-assist-features]{jQuery}
\end{itemize}

Each language is covered in its own section, so you can navigate to the
language you're most interested in. There are many languages, including
the four listed above, that Dev Studio provides code assist for. This is
provided by Dev Studio's integration of \href{http://ternjs.net/}{Tern}.
To access these features, you must be working in a file those languages
are expected for (e.g., JavaScript, JSP, HTML, CSS, etc.).

You must have Tern features enabled in your project in order to use
them. You should also have the appropriate Tern modules enabled based on
the language you're writing in. For example, if you're writing in a
jQuery file, you must apply the Tern \emph{jQuery} module to use code
assist for that language. See the
\href{/docs/7-1/tutorials/-/knowledge_base/t/enabling-code-assist-features-in-your-project}{Enabling
Code Assist Features in your Project} tutorial to learn how to enable
Tern features for your projects.

You'll begin testing the AlloyUI code assist features first.

\subsection{AlloyUI Code Assist
Features}\label{alloyui-code-assist-features}

There are several helpful code assist features that can improve your
productivity when writing code for AlloyUI. Before beginning, enable the
Tern modules required to use AlloyUI features: \emph{AlloyUI},
\emph{Browser}, \emph{JSCS}, \emph{Liferay}, and \emph{YUI Library}. The
example below shows how to access the AlloyUI code assist features in
the \texttt{main.js} of your project:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open your project's \texttt{main.js} file and type the following code:

\begin{verbatim}
 AUI().
\end{verbatim}
\item
  Press \emph{Ctrl+Space} with your cursor to the right of
  \texttt{AUI().}. This brings up the code inference for the
  \texttt{AUI()} global object. Notice the AlloyUI framework's own API
  documentation is also displayed. Press \emph{Enter} to use code
  completion.
\end{enumerate}

\begin{figure}
\centering
\includegraphics{./images/code-inference.png}
\caption{This figure demonstrates code inference in a JS file.}
\end{figure}

\noindent\hrulefill

\textbf{Note:} Code assist not only works for methods of an object, but
also works for AUI-specific Tern completions for objects. For instance,
you could type \texttt{AU} and press \emph{Ctrl+Space} to see a list of
objects to choose from.

\noindent\hrulefill

By default, code inference is triggered by a keystroke combination;
however, you can enable auto activation in Dev Studio's Preferences
menu. Follow the steps below to enable auto activation:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Navigate to \emph{Window} → \emph{Preferences} → \emph{JavaScript} →
  \emph{Editor} → \emph{Content Assist}.
\item
  Check the \emph{Enable auto activation} box and click \emph{Apply and
  Close}.

  The figure below shows how to enable auto activation:

  \begin{figure}
  \centering
  \includegraphics{./images/enable-auto-activation.png}
  \caption{The \emph{Enable auto activation} checkbox is listed below
  the \emph{Auto-Activation} heading.}
  \end{figure}
\end{enumerate}

Now, if you follow the previous example, code inference activates as
soon as you press the trigger key, which in this case is the \emph{.}
(period) key.

In addition to general code inference for AlloyUI, you have access to
code templates. AUI JavaScript templates are available in Eclipse's
JavaScript editor as well as in the HTML/JSP editor when working with
\texttt{\textless{}script\textgreater{}} and
\texttt{\textless{}aui-script\textgreater{}} tags. Follow the steps
below to use AUI code templates:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Type the following code in your \texttt{main.js}:

\begin{verbatim}
AUI
\end{verbatim}
\item
  Press \emph{Ctrl+Space} to bring up the code inference for
  \texttt{AUI}, and you'll see a list of all the available AlloyUI code
  templates, along with documentation.

  \begin{figure}
  \centering
  \includegraphics{./images/code-template.png}
  \caption{Dev Studio gives you access to AUI code templates in the JS
  and JSP editors.}
  \end{figure}
\item
  Select your template and hit \emph{Enter} to paste its contents into
  your \texttt{main.js}.
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** You can view all the AlloyUI code templates you have
 installed by going to Dev Studio's Preferences menu and selecting *JavaScript*
 &rarr; *Editor* &rarr; *Templates*.
\end{verbatim}

\noindent\hrulefill

In addition to code inference in your JS files, you can also use code
inference in your JSP/HTML files using
\texttt{\textless{}aui:script\textgreater{}} tags.

Open one of your project's JSPs and add the AUI taglib directive if it's
not already in your JSP:

\begin{verbatim}
<%@ taglib uri="http://liferay.com/tld/aui" prefix="aui" %>
\end{verbatim}

You can also add the import from the Snippets menu (\emph{Window} →
\emph{Show View} → \emph{Snippets}) under \emph{Taglib imports} →
\emph{Liferay AUI Taglib Import v6.0}.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add an \texttt{\textless{}aui:script\textgreater{}} tag inside your
  JSP and configure it to look like the following code:

\begin{verbatim}
 <aui:script>
     aui
 </aui:script>
\end{verbatim}
\item
  Press \emph{Ctrl+Space} with your cursor placed to the right of
  \texttt{aui} to bring up code inference.
\end{enumerate}

There you go! Whether in a JavaScript file or inside a JSP, you now have
access to code assist features that improve your workflow.

Next, you'll examine the JavaScript code assist features for Dev Studio.

\subsection{JavaScript Code Assist
Features}\label{javascript-code-assist-features}

In addition to AlloyUI code assist features, you also have access to
code inference and completion using raw JavaScript. This code assist
feature is available in your project because the Tern module
\texttt{Liferay} is enabled. This plugin provides code completions for
the static JavaScript object APIs available to portlets when running in
Liferay Portal. To learn more about enabling Tern modules in Eclipse,
refer to the
\href{/docs/7-1/tutorials/-/knowledge_base/t/enabling-code-assist-features-in-your-project}{Enabling
Code Assist Features in Your Project} tutorial.

The example below shows how you can use code assist features to easily
access functions in your portlet project.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open the \texttt{main.js} of your portlet and add the following
  function:

\begin{verbatim}
function say(text){
    alert(text);
}
\end{verbatim}
\item
  Add the following button to the \texttt{view.jsp} of your portlet:

\begin{verbatim}
<aui:button onClick=""/>
\end{verbatim}
\item
  Place your cursor within the quotation marks of the \texttt{onClick}
  attribute and press \emph{Ctrl+Space}. The code inference dialog pops
  up with a list of possible JavaScript functions available for you to
  use.
\item
  Type \emph{say} and you'll notice the list is narrowed down to your
  new \texttt{say(text)} function.

  \begin{figure}
  \centering
  \includegraphics{./images/js-code-inference.png}
  \caption{JavaScript code assist features give easy access to your
  functions.}
  \end{figure}
\item
  Select the \texttt{say(text)} function, and you'll notice that it's
  accompanied by documentation that provides the parameter for the
  function, as well as the file path where the function is located.
\item
  Press \emph{Enter} to use code completion and add the function to your
  button.
\end{enumerate}

As you can see, JavaScript development is a breeze using Dev Studio's
code assist features. Now that you know how to use the AlloyUI and
JavaScript code assist features, you can learn how to use the CSS code
assist features next.

\subsection{CSS Code Assist Features}\label{css-code-assist-features}

Dev Studio offers code inference and completion tools for CSS. In order
to use these tools, you'll need to install an additional plugin.

\noindent\hrulefill

\textbf{Note:} The plugin described below is planned to be bundled with
Liferay Dev Studio in the near future. Initial tests of the plugin
revealed performance issues in some cases, which is why it is not yet a
part of Liferay Dev Studio. Problems were not consistent, so you may
have no issues installing the plugin, but we wanted to give full
disclosure about it.

\noindent\hrulefill

Follow the steps below to install the plugin in Dev Studio:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Go to \emph{Help} → \emph{Install New Software\ldots{}}.
\item
  Paste the following link into the \texttt{Work\ with:} input field:

\begin{verbatim}
 http://oss.opensagres.fr/eclipse-wtp-webresources/1.1.0/
\end{verbatim}
\item
  Click \emph{Add\ldots{}} and check the box next to \emph{WTP HTML -
  Web Resources}.
\item
  Click \emph{Next} and follow the installation instructions.
\end{enumerate}

Now that your plugin is installed, you'll need to enable the CSS
features in your project. Right-click your project and go to
\emph{Properties} → \emph{Web Resources} → \emph{CSS}. Check both boxes
to enable CSS features in your project.

You have successfully installed and enabled the new CSS features in your
project!

Now that you have the CSS features enabled, you'll find out how to use
them next. Follow the steps below to use the CSS code assist features to
locate a CSS class. Note that the process below can also be used to
locate an ID.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open your \texttt{main.css} file and add the following class to it:

\begin{verbatim}
.sample-class {
    background-color:green;
}
\end{verbatim}
\item
  Inside your \texttt{view.jsp} add an
  \texttt{\textless{}aui:button/\textgreater{}} tag and configure it to
  match the following code:

\begin{verbatim}
<aui:button name="test" value="test" cssClass=""/>
\end{verbatim}
\item
  Within the quotations of the \texttt{cssClass} attribute, press
  \emph{Ctrl+Space} to bring up the code inference for CSS. Begin typing
  \emph{sample-class} to narrow down the classes to the one you're
  looking for.

  \begin{figure}
  \centering
  \includegraphics{./images/css-code-inference.png}
  \caption{CSS code inference improves your workflow when developing in
  CSS.}
  \end{figure}

  Notice, along with code inference, you can also view the styling you
  have for the class, as well as the file in which it is located.
\item
  Press \emph{Enter} to use code completion and add the CSS class to the
  JSP.
\end{enumerate}

If you look at the code inference dialog for CSS classes, you'll also
notice that in addition to your own CSS classes, you also have access to
Bootstrap CSS classes found in Liferay Portal.

\noindent\hrulefill

\textbf{Note:} You can go to the file that the class, ID, or function is
located in by hovering over top of it in your JSP and holding down the
\texttt{Ctrl} (Windows) or \texttt{command} (Mac) key, and clicking the
hyperlink that appears.

\noindent\hrulefill

Lastly, you'll learn about the code assist features for jQuery.

\subsection{jQuery Code Assist
Features}\label{jquery-code-assist-features}

You can also use code assist with jQuery. To do this, you must enable
the \texttt{jQuery} Tern module. Follow the instructions in the
\href{/docs/7-1/tutorials/-/knowledge_base/t/enabling-code-assist-features-in-your-project}{Enabling
Code Assist Features in Your Project} tutorial to learn how to enable
Tern modules in your project.

The jQuery Tern plugin gives type information for the jQuery framework.
In the example below, you'll test the jQuery code assist feature.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open your project's \texttt{jquery.js} file.
\item
  In the file, type the following sample variable:

\begin{verbatim}
var form = 
\end{verbatim}
\item
  Press \emph{Ctrl+Space} to bring up the code inference for the
  variable you're declaring, and you'll see a list of everything that is
  available. Also notice jQuery documentation is available for each
  method. Take a look at the figure below for an example of using code
  assit in jQuery.

  \begin{figure}
  \centering
  \includegraphics{./images/jquery-js-1.png}
  \caption{Using the jQuery code assist features gives you the
  convenience of showing you what's available, and the documentation
  behind each option.}
  \end{figure}

  Furthermore, for jQuery callback handlers, the type information for
  parameters is also made available.

  \begin{figure}
  \centering
  \includegraphics{./images/jquery-js-2.png}
  \caption{jQuery code assist also displays type information for
  parameters.}
  \end{figure}
\end{enumerate}

Excellent! You now know how to use Dev Studio's front-end development
code assist features to improve your workflow.

\subsection{Related Topics}\label{related-topics-15}

\href{/docs/7-1/tutorials/-/knowledge_base/t/enabling-code-assist-features-in-your-project}{Enabling
Code Assist Features in your Project}

\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-workspace}{Liferay
Workspace}

\href{/docs/7-1/tutorials/-/knowledge_base/t/from-liferay-6-to-liferay-7}{From
Liferay 6 to 7.0}

\chapter{Blade CLI}\label{blade-cli}

The \href{https://github.com/liferay/liferay-blade-cli/}{Blade CLI} tool
is the easiest way for Liferay developers to create new Liferay modules.
Blade CLI lets you

\begin{itemize}
\tightlist
\item
  create projects (Gradle or Maven) that can be used with any IDE or
  development environment
\item
  create/manage Liferay DXP instances
\item
  deploy modules (Gradle or Maven)
\end{itemize}

The following sub-commands are callable in the Blade CLI environment:

\begin{itemize}
\tightlist
\item
  \emph{convert}: Converts a Plugins SDK plugin project to a Gradle
  Workspace project.
\item
  \emph{create}: Creates a new Liferay module project from available
  templates.
\item
  \emph{deploy}: Builds and deploys bundles to the Liferay module
  framework.
\item
  \emph{gw}: Executes Gradle command using the Gradle Wrapper, if
  detected.
\item
  \emph{help}: Gives help on a specific command.
\item
  \emph{init}: Initializes a new Liferay Workspace.
\item
  \emph{install}: Installs a bundle into Liferay's module framework.
\item
  \emph{open}: Opens or imports a file or project in Liferay Dev Studio
  DXP.
\item
  \emph{samples}: Generates a sample project.
\item
  \emph{server}: Starts or stops server defined by your Liferay project.
\item
  \emph{sh}: Connects to Liferay DXP, executes succeeding Gogo command,
  and returns output.
\item
  \emph{update}: Updates Blade CLI to latest version.
\item
  \emph{upgradeProps:} Analyzes your old \texttt{portal-ext.properties}
  and your newly installed 7.x server to show you properties moved to
  OSGi configuration files or removed from the product.
\item
  \emph{version}: Displays version information about Blade CLI.
\end{itemize}

For additional information on these sub-commands, run the sub-command
with the \texttt{-\/-help} flag (e.g.,
\texttt{blade\ samples\ -\/-help}).

In this set of tutorials, you'll learn how to use these commands to
create and test Liferay DXP instances and modules.

\section{Installing Blade CLI}\label{installing-blade-cli}

You can install Blade CLI using the Liferay Project SDK installer. This
installs JPM and Blade CLI into your user home folder and optionally
initializes a
\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-workspace}{Liferay
Workspace} folder.

\noindent\hrulefill

\textbf{Note:} In the past, if you've installed Blade CLI globally
(e.g., using \texttt{sudo}), you should not run the installer to
\emph{update} your Blade CLI version. Since the installer only installs
Blade CLI to your user home folder, your previous global installation
would always override the installer's installation. Therefore, always
follow the
\href{/docs/7-1/tutorials/-/knowledge_base/t/updating-blade-cli}{Updating
Blade CLI} tutorial to update your Blade CLI instance.

\noindent\hrulefill

If you need to configure proxy settings for Blade CLI, follow the
\href{/docs/7-1/tutorials/-/knowledge_base/t/setting-blade-cli-proxy-requirments}{Installing
Blade CLI with Proxy Requirements}

Follow the steps below to download and install Blade CLI:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Download the latest
  \href{https://sourceforge.net/projects/lportal/files/Liferay\%20IDE/}{Liferay
  Project SDK installer} that corresponds with your operating system
  (e.g., Windows, MacOS, or Linux). The Project SDK installer is listed
  under \emph{Liferay IDE}, so the folder versions are based on IDE
  releases. You can select an installer that does not include Dev Studio
  DXP, if you don't intend to use it. The Project SDK installer is
  available for versions 3.2.0+. Do \textbf{not} select the large green
  download button; this downloads Liferay Portal instead.
\item
  Run the installer. Click \emph{Next} to step through the installer's
  introduction.
\item
  If you'd like to initialize a Liferay Workspace, you can set the
  directory where it should go.

  \begin{figure}
  \centering
  \includegraphics{./images/blade-installer-workspace-init.png}
  \caption{Determine where your Liferay Workspace should reside, if you
  want one.}
  \end{figure}

  Select the \emph{Don't initialize Liferay Workspace directory} option
  if you only want to install Blade CLI. Then click \emph{Next}.
\item
  If you decided to initialize a Liferay Workspace folder in the
  previous step, you'll have an additional option to select the Liferay
  product type you'll use with your workspace. Choose the product type
  and click \emph{Next}.

  \begin{figure}
  \centering
  \includegraphics{./images/installer-workspace-type.png}
  \caption{Select the product version you'll use with your Liferay
  Workspace.}
  \end{figure}
\item
  Click \emph{Next} to begin installing Blade CLI/Liferay Workspace on
  your computer.
\end{enumerate}

That's it! Blade CLI is installed on your machine! If you specified a
location to initialize a Liferay Workspace folder, that is also
available.

\noindent\hrulefill

\textbf{Note:} The Liferay Project SDK installer attempts to add JPM to
your path. For Windows, it uses the Windows registry. For Mac/Linux, it
updates \texttt{.bashrc} or \texttt{.zshrc}.

At a minimum, Mac/Linux users must open a new shell after the installer
finishes for the new features to be available. If, however, you're using
a different shell (i.e., Korn, csh, etc.) or you've customized your CLI
via \texttt{.profile} or some other configuration file, you must add JPM
to your path manually.

\noindent\hrulefill

Blade CLI offers many
\href{/docs/7-1/reference/-/knowledge_base/r/project-templates}{templates}
to help build 7.0 applications. It also offers various ways to deploy
those apps and interact with your Liferay server. Be sure to explore
more Blade CLI tutorials to learn how.

\subsection{Installer Issues on
macOS/Linux}\label{installer-issues-on-macoslinux}

If you're using macOS or Linux, you could experience an issue where the
\texttt{blade} command is not available via command line. This is caused
by the installer being unable to add JPM's \texttt{bin} folder to your
user path. JPM is a Java package manager used in Blade CLI.

To add the required \texttt{bin} folder, execute the appropriate command
based on your operating system.

macOS:

\begin{verbatim}
echo 'export PATH="$PATH:$HOME/Library/PackageManager/bin"' >> ~/.bash_profile
\end{verbatim}

Linux:

\begin{verbatim}
echo 'export PATH="$PATH:$HOME/jpm/bin"' >> ~/.bash_profile
\end{verbatim}

Once you restart the command line, the \texttt{blade} command should be
available.

\section{Installing Blade CLI with Proxy
Requirements}\label{installing-blade-cli-with-proxy-requirements}

If you have proxy server requirements and want to use Blade CLI, you
must configure your http(s) proxy for it using JPM. Before beginning,
make sure you've installed JPM and Blade CLI using the Liferay Project
SDK installer. Read the
\href{/docs/7-1/tutorials/-/knowledge_base/t/installing-blade-cli}{Installing
Blade CLI} tutorial for more details.

Once Blade CLI and JPM are installed, execute the following command to
configure your proxy requirements for Blade CLI:

\begin{verbatim}
jpm command --jvmargs "-Dhttp(s).proxyHost=[your proxy host] -Dhttp(s).proxyPort=[your proxy port]" jpm
\end{verbatim}

Excellent! You've configured Blade CLI with your proxy settings using
JPM.

\section{Creating a Liferay Workspace with Blade
CLI}\label{creating-a-liferay-workspace-with-blade-cli}

In this tutorial, you'll learn how to generate a Liferay Workspace using
Blade CLI. The Blade CLI tool you installed in the
\href{/docs/7-1/tutorials/-/knowledge_base/t/installing-blade-cli}{Installing
Blade CLI} section provides many different commands to help build and
customize Liferay projects. The first thing you should do before
building and customizing projects is create a Liferay Workspace. You can
use Blade CLI to generate a Gradle or Maven based workspace. For more
information on managing a Liferay Workspace built with Maven, see the
\href{/docs/7-1/tutorials/-/knowledge_base/t/maven-workspace}{Maven
Workspace} tutorial.

Your workspace is the home for all your custom Liferay projects.
Navigate to the folder where you want your workspace and run the
following command to build a Gradle based workspace:

\begin{verbatim}
blade init -v 7.1 [WORKSPACE_NAME]
\end{verbatim}

To create a Maven based workspace, run this instead:

\begin{verbatim}
blade init -v 7.1 -b maven [WORKSPACE_NAME]
\end{verbatim}

\noindent\hrulefill

\textbf{Note:} The version you set when first initializing your
workspace is stored in the workspace's \texttt{.blade.properties} file
with the \texttt{liferay.version.default} property. This version is
applied when creating projects based on the corresponding project
template versions.

If you wish to develop projects for a different Liferay DXP version, you
can pass a different version in the Blade init command. For example,

\begin{verbatim}
blade init -v 7.0 [WORKSPACE_NAME]
\end{verbatim}

\noindent\hrulefill

Initializing a workspace requires no downloading or access to the
internet.

If you have a Plugins SDK and are looking to migrate to Liferay
Workspace using Blade CLI, navigate to your Plugins SDK root folder and
run the following command:

\begin{verbatim}
blade init -u
\end{verbatim}

This command builds a workspace and automatically adds and configures
your current Plugins SDK environment for use inside the workspace. See
the
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-a-liferay-workspace-with-blade-cli\#configuring-a-plugins-sdk-in-your-workspace}{Configuring
a Plugins SDK in Your Workspace} section for more details on the
\texttt{init\ -u} command. See the
\href{/docs/7-0/tutorials/-/knowledge_base/t/configuring-a-liferay-workspace\#using-a-plugins-sdk-from-your-workspace}{Using
a Plugins SDK From Your Workspace} section for more information on how
to use a Plugins SDK from within a workspace.

Once your workspace is generated, look at its folder structure. Several
folders and build/properties files were autogenerated:

\begin{itemize}
\tightlist
\item
  \texttt{configs}
\item
  \texttt{gradle}
\item
  \texttt{modules}
\item
  \texttt{themes}
\item
  \texttt{.blade.properties}
\item
  \texttt{build.gradle}
\item
  \texttt{gradle-local.properties}
\item
  \texttt{gradle.properties}
\item
  \texttt{gradlew}
\item
  \texttt{gradlew.bat}
\item
  \texttt{platform.bndrun}
\item
  \texttt{settings.gradle}
\end{itemize}

The build/properties files included in your workspace's root directory
sets your workspace's Gradle properties and facilitates the build
processes of your modules. You can learn more about these generated
files/folders in the
\href{/docs/7-1/tutorials/-/knowledge_base/t/configuring-a-liferay-workspace}{Configuring
a Liferay Workspace} tutorial. You'll learn about how to use these
folders and properties files throughout the next few tutorials.

Next you'll learn about generating and using a Liferay DXP instance from
within your workspace.

\subsection{Running a Liferay Instance from Your
Workspace}\label{running-a-liferay-instance-from-your-workspace}

As discussed in the
\href{/docs/7-1/tutorials/-/knowledge_base/t/configuring-a-liferay-workspace\#adding-a-liferay-bundle-to-a-workspace}{Configuring
a Liferay Workspace} tutorial, Liferay Workspaces can generate and hold
a Liferay Server. This lets you build/test your plugins against a
running Liferay instance. Once you've properly generated and installed a
Liferay server in your workspace, you can begin using it with Blade CLI.
To start your Liferay instance, run

\begin{verbatim}
blade server start
\end{verbatim}

This command starts your Liferay server in a separate window. You also
have the option to run your server in debug mode (\texttt{-d}).

Awesome! You have a built-in Liferay server in your workspace and can
start the server using Blade CLI.

\section{Creating Projects with Blade
CLI}\label{creating-projects-with-blade-cli}

When you use Blade CLI to create a project, your project's folder
structure, build script (e.g., \texttt{build.gradle}), Java classes, and
other resources (such as JSPs) are created based on the chosen template.
In this tutorial, you'll learn how to use Blade CLI to create modules
based on pre-existing templates and samples.

Using Blade CLI gives you the flexibility to choose how you want to
create your application. You can do so in your own standalone
environment, or within a
\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-workspace}{Liferay
Workspace}. You can also create a project using either the Gradle or
Maven build tool. Creating Liferay modules in a workspace using Blade
CLI is very similar to creating them in a standalone environment.

When creating projects in a workspace, you should navigate to the
appropriate folder corresponding to that type of project (e.g., the
\texttt{/modules} folder for a module project). You can also provide
further directory nesting into that folder, if preferred. For example,
the Gradle workspace, by default, sets the directory where your modules
should be stored by setting the following property in the workspace's
\texttt{gradle.properties} file:

\begin{verbatim}
liferay.workspace.modules.dir=modules
\end{verbatim}

Change this property if you'd like to store your modules in a different
directory.

\noindent\hrulefill

\textbf{Note:} Your projects should define a repository where external
dependencies can be downloaded. Unlike Maven, Gradle does not define any
repositories by default. For convenience, Gradle projects created with
Blade CLI define Liferay's public Nexus repository as its default
repository. This is defined, however, in different files depending on
where the project was created.

If you used Blade CLI to create a Gradle project outside of a workspace,
your repository is defined in the module's \texttt{build.gradle} file.
Likewise, if you created your module inside a workspace, your repository
is defined in the \texttt{settings.gradle} file located in the
workspace's ROOT folder. This ensures that all modules residing in the
workspace share the same repository URL.

\noindent\hrulefill

First, you'll learn how to create a module using a template.

\subsection{Project Templates}\label{project-templates}

To create a new Liferay project, you can run the Blade \texttt{create}
command, which offers many available templates. There are, however, many
other options you can specify to help mold your project just the way you
want it. To learn how to use the Blade \texttt{create} command and the
many options it provides, enter \texttt{blade\ help\ create} into a
terminal. A list of the \texttt{create} options are listed below:

\texttt{-\/-base}: The base directory. The default base directory is the
current directory.

\texttt{-b,\ -\/-build\ \textless{}String\textgreater{}}: The build type
of the project. Available options are \texttt{gradle} (default) and
\texttt{maven}.

\texttt{-c,\ -\/-classname\ \textless{}String\textgreater{}}: If a class
is generated in the project, provide the name of the class to be
generated. If not provided, the class name defaults to the project name.

\texttt{-C,\ -\/-contributor-type\ \textless{}String\textgreater{}}:
Identifies your module as a theme contributor. This is also used to add
the \texttt{Liferay-Theme-Contributor-Type} and \texttt{Web-ContextPath}
bundle headers to the BND file.

\texttt{-d,\ -\/-dir\ \textless{}File\textgreater{}}: The directory to
create the new project.
\texttt{-h,\ -\/-host-bundle-bsn\ \textless{}String\textgreater{}}: If
creating a new JSP hook fragment, provide the name of the host bundle
symbolic name. This is required when using the \texttt{fragment} project
template.

\texttt{-H,\ -\/-host-bundle-version\ \textless{}String\textgreater{}}:
If a new JSP hook fragment needs to be created, provide the name of the
host bundle version. This is required when using the \texttt{fragment}
project template.

\texttt{-v,\ -\/-liferay-version}: The version to target when creating a
project. The default is \texttt{7.2}.

\texttt{-l,\ -\/-list-templates}: Prints a list of available project
templates.

\texttt{-p,\ -\/-package-name\ \textless{}String\textgreater{}}: The
package name to use when creating the project.

\texttt{-s,\ -\/-service\ \textless{}String\textgreater{}}: If a new
Declarative Services (DS) component needs to be created, provide the
name of the service to be implemented. Note that in this context, the
term \emph{service} refers to an OSGi service, not to a Liferay API.

\texttt{-t,\ -\/-template\ \textless{}String\textgreater{}}: The project
template to use when creating the project. Run
\texttt{blade\ create\ -l} for a listing of available Blade CLI
templates. \texttt{-\/-trace}: Prints exception stack traces when they
occur. This is \texttt{false} by default.

To create a module project, use the following syntax:

\begin{verbatim}
blade create [OPTIONS] <NAME>
\end{verbatim}

For example, if you wanted to create an MVC portlet project with Gradle,
you could execute the following:

\begin{verbatim}
blade create -t mvc-portlet -p com.liferay.docs.guestbook -c GuestbookPortlet my-guestbook-project
\end{verbatim}

This command creates an MVC portlet project based on the template
\texttt{mvc-portlet}. It uses the package name
\texttt{com.liferay.docs.guestbook} and creates the portlet class
\texttt{GuestbookPortlet}. The project name is
\texttt{my-guestbook-project}. Since the directory was not specified, it
is created in the folder you executed the command. When generating a
project using Blade CLI, there is no downloading, which means internet
access is not required.

If you want to generate a project for a previous version (e.g., Liferay
Portal 7.0), you can specify this using the \texttt{-v} flag. For
example, to create a project for Liferay Portal 7.0, you would include
\texttt{-v\ 7.0} in your \texttt{create} command sequence.

Blade CLI can also create the same project with Maven by specifying the
\texttt{-b\ maven} parameter. Using Blade CLI's Maven option isn't the
only way to leverage Liferay's Maven project templates; you can also
generate them using Maven archetypes. See Liferay's
\href{/docs/7-1/reference/-/knowledge_base/r/project-templates}{Project
Templates} articles to see how.

When using Blade CLI, you must manually edit your project's component
class. Blade CLI gives you the ability to specify the class's name, but
all other contents of the class can only be edited after the class is
created. See the
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-modules-with-liferay-ide}{Creating
Modules with Liferay @ide@} tutorial for further details and important
dependency information on component classes.

Now that you know the basics on creating Liferay projects using
\texttt{blade\ create}, you can visit the
\href{/docs/7-1/reference/-/knowledge_base/r/project-templates}{Project
Templates} reference section to view specific \texttt{create} templates
and how they work.

Next, you'll explore Liferay's provided project samples and how to
generate them using Blade CLI.

\subsection{Project Samples}\label{project-samples}

Liferay provides many sample projects that are useful for those
interested in learning best practices on structuring their projects to
accomplish specific tasks. These samples can be found in the
\href{https://github.com/liferay/liferay-blade-samples}{liferay-blade-samples}
Github repository. You can also learn more about these samples by
visiting the
\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-sample-projects}{Liferay
Sample Projects} article.

You can generate these samples using Blade CLI for convenience, instead
of cloning the repository and manually copy/pasting them to your
environment. To do this, use the following syntax:

\begin{verbatim}
blade samples <NAME>
\end{verbatim}

For example, if you wanted to generate the
\href{https://github.com/liferay/liferay-blade-samples/tree/7.1/gradle/apps/ds-portlet}{portlet-ds}
sample, you could execute

\begin{verbatim}
blade samples ds-portlet
\end{verbatim}

\noindent\hrulefill

\textbf{Note:} Interested in generating legacy versions of Blade
samples? Pass in the \texttt{-v} param followed by the Liferay DXP
version to target. For example,

\begin{verbatim}
 blade samples -v 7.0 ds-portlet
\end{verbatim}

\noindent\hrulefill

For a full listing of all the available Blade samples, run

\begin{verbatim}
blade samples
\end{verbatim}

Awesome! Now you know the basics on creating Liferay projects with Blade
CLI.

\section{Deploying Projects with Blade
CLI}\label{deploying-projects-with-blade-cli}

Deploying projects to a Liferay server using Blade CLI is easy. To use
the Blade \texttt{deploy} command, you must first have built a project
to deploy. See the
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-projects-with-blade-cli}{Creating
Projects with Blade CLI} tutorials for more information about creating
Liferay projects. Once you've built a project, navigate to it with your
CLI and execute the following command to deploy it:

\begin{verbatim}
blade deploy
\end{verbatim}

This can be used for WAR-style projects and modules (JARs). You can also
deploy all projects in a folder by running the \texttt{deploy} command
from the parent folder (e.g., \texttt{{[}WORKSPACE\_ROOT{]}/modules}).

If you're using Liferay Workspace, the \texttt{deploy} command deploys
your project based on the build tool's deployment configuration. For
example, leveraging Blade CLI in a default Gradle Liferay Workspace uses
the underlying Gradle deployment configuration. The build tool's
deployment configuration is found by reading the Liferay Home folder set
in your workspace's \texttt{gradle.properties} or \texttt{pom.xml} file.
The \texttt{deploy} command works similarly if you're working outside of
workspace; the Liferay Home folder, in contrast, is set by loading the
Liferay extension object (Gradle) or the effective POM (Maven) and
searching for the Liferay Home property stored there. If it's not
stored, Blade prompts you to set it so it's available.

\noindent\hrulefill

\textbf{Note:} If you prefer using pure Gradle or Maven to deploy your
project, you can do this by applying the appropriate plugin and
configuring your Liferay Home property. Here's how you can do this for
Gradle and Maven:

\textbf{Gradle:}

First ensure the Liferay Gradle plugin is applied in your
\texttt{build.gradle} file:

\begin{verbatim}
 apply plugin: "com.liferay.plugin"
\end{verbatim}

Then extend the Liferay extension object to set your Liferay Home and
\texttt{deploy} folder:

\begin{verbatim}
 liferay {
     liferayHome = "../../../../liferay-ce-portal-7.1.1-ga2"
     deployDir = file("${liferayHome}/deploy")
 }
\end{verbatim}

\textbf{Maven:}

Ensure the Bundle Support plugin is applied and configure Liferay Home
in your \texttt{pom.xml}. See the
\href{/docs/7-1/tutorials/-/knowledge_base/t/deploying-a-project-built-with-maven-to-product}{Deploying
a Project Built with Maven to Liferay Portal} for details.

\noindent\hrulefill

If you prefer not to use your underlying build tool's (Gradle or Maven)
module deployment configuration, and instead, you want to deploy
straight to Liferay DXP's OSGi container, run this command instead:

\begin{verbatim}
blade deploy -l
\end{verbatim}

Blade CLI also offers a way to \emph{watch} a deployed project, which
compiles and redeploys a project when changes are detected. There are
two ways to do this:

\begin{itemize}
\tightlist
\item
  \texttt{blade\ watch}
\item
  \texttt{blade\ deploy\ -w}
\end{itemize}

The \texttt{blade\ watch} command is the fastest way to develop and test
module changes, because the \texttt{watch} command does not rebuild your
project every time a change is detected. When running
\texttt{blade\ watch}, your project is not copied to Portal, but rather,
is installed into the runtime as a reference. This means that the Portal
does not make a cached copy of the project. This allows the Portal to
see changes that are made to your project's files immediately. When you
cancel the \texttt{watch} task, your module is uninstalled
automatically.

The \texttt{watch} task does not work with JSF portlets or fragment
projects.

\noindent\hrulefill

\textbf{Note:} The \texttt{blade\ watch} command is available for
Liferay Workspace versions 1.10.9+ (i.e., the
\texttt{com.liferay.gradle.plugins.workspace} dependency). Maven
projects cannot leverage the \texttt{watch} feature at this time.

\noindent\hrulefill

The \texttt{blade\ deploy\ -w} command works similarly to
\texttt{blade\ watch}, except it manually recompiles and deploys your
project every time a change is detected. This causes slower update
times, but does preserve your deployed project in Portal when it's shut
down.

Cool! You've successfully deployed your module project using Blade CLI.

\section{Managing Your Liferay Server with Blade
CLI}\label{managing-your-liferay-server-with-blade-cli}

In this tutorial, you'll learn how to manage a Liferay server using
Blade CLI. For example, Blade CLI lets you install, start, stop,
inspect, and modify a Liferay server.

Make sure you're in a Liferay Workspace and have a bundle installed and
configured in the workspace before testing the Blade CLI commands on
your own. To learn more about installing a Liferay server in a Liferay
Workspace, see the
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-a-liferay-workspace-with-liferay-ide}{Creating
a Liferay Workspace with Liferay Dev Studio DXP} section. The following
Blade CLI commands are covered in this sub-section:

\begin{itemize}
\tightlist
\item
  \texttt{server}
\item
  \texttt{sh}
\end{itemize}

The first thing that comes to mind when interacting with a server is
simply turning it on/off. You can use the \texttt{server} sub-command to
accomplish this. To turn on a Liferay server (Tomcat or Wildfly/JBoss),
you can run

\begin{verbatim}
blade server start
\end{verbatim}

This starts the server in the background. You can tail the logs by
adding the \texttt{-t} flag. If you prefer starting the server in the
foreground, run \texttt{blade\ server\ run}. Additionally, if you prefer
starting the server in debug mode, add the \texttt{-d} flag.

Debug mode can be customized by adding the \texttt{-p} tag to set the
custom remote debugging port (defaults are \texttt{8000} for Tomcat and
\texttt{8787} for Wildfly) and/or the boolean \texttt{-s} tag to set
whether you want to suspend the started server until the debugger is
connected.

Once you've started your server, you can examine its OSGi container by
using the \texttt{sh} command, which provides access to your server
using the Felix Gogo shell. For example, to check if you successfully
deployed your application from the previous section, you could run:

\begin{verbatim}
blade sh lb
\end{verbatim}

Your output lists a long list of modules that are active/installed in
your server's OSGi container.

\begin{figure}
\centering
\includegraphics{./images/blade-sh.png}
\caption{Blade CLI accesses the Gogo shell script to run the \texttt{lb}
command.}
\end{figure}

You can run any Gogo command using \texttt{blade\ sh}. This command
requires
\href{/docs/7-1/tutorials/-/knowledge_base/t/using-developer-mode-with-themes\#setting-developer-mode-for-your-server-using-portal-developerproperties}{Developer
Mode} to be enabled. Developer Mode is enabled in
\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-workspace}{Liferay
Workspace} by default. See the
\href{/docs/7-1/reference/-/knowledge_base/r/using-the-felix-gogo-shell}{Using
the Felix Gogo Shell} section for more information on this tool.

To turn off your server, run

\begin{verbatim}
blade server stop
\end{verbatim}

Awesome! You learned how to conveniently interact with Liferay DXP using
Blade CLI.

\section{Updating Blade CLI}\label{updating-blade-cli}

If your Blade CLI version is outdated, you can run the following command
to automatically download and install the latest version of Blade CLI:

\begin{verbatim}
blade update
\end{verbatim}

\noindent\hrulefill

\textbf{Note:} For Windows users on Blade CLI 3.3.0 and older, the
\texttt{blade\ update} command does not work because Windows cannot
update a file that is currently in use. To bypass this issue, use JPM to
update your version of Blade CLI:

\begin{verbatim}
 jpm install -f https://releases.liferay.com/tools/blade-cli/latest/blade.jar
\end{verbatim}

The \texttt{blade\ update} command for Windows users on Blade CLI 3.4.1+
works as expected.

\noindent\hrulefill

Blade CLI is updated frequently, so it's recommended to update your
Blade CLI environment for new features. You can check the released
versions of Blade CLI on Nexus by inspecting the
\href{https://repository-cdn.liferay.com/nexus/content/repositories/liferay-public-releases/com/liferay/blade/com.liferay.blade.cli/}{com.liferay.blade.cli}.
artifact. You can check your current installed version by running
\texttt{blade\ version}. When running \texttt{blade\ version}, you are
notified if there's a newer Blade CLI version available.

\noindent\hrulefill

\textbf{Note:} If you run \texttt{blade\ version} after updating, but
don't see the expected version installed, you may have two separate
Blade CLI installations on your machine. This is typically caused if you
installed an earlier version of Blade CLI, and then used the
\href{/docs/7-1/tutorials/-/knowledge_base/t/installing-blade-cli}{Liferay
Project SDK installer} (at any time prior) to update the older Blade CLI
instance. This is not recommended. Doing this installs Blade CLI in the
global and user home folder of your machine. The latest Blade CLI update
process installs to your user home folder, so you must delete the legacy
Blade files in your global folder, if present. To do this, navigate to
your \texttt{GLOBAL\_FOLDER/JPM4J} folder and delete

\begin{itemize}
\tightlist
\item
  \texttt{/bin/blade}
\item
  \texttt{/commands/blade}
\end{itemize}

The newest Blade CLI installation in your user home folder is now
recognized and available.

\noindent\hrulefill

Although Blade CLI is frequently released, if you want bleeding edge
features not yet available, you can install the latest snapshot version:

\begin{verbatim}
blade update -s
\end{verbatim}

This pulls the latest snapshot version of Blade CLI and installs it to
your local machine. Running \texttt{blade\ version} after installing a
snapshot displays output similar to this:

\begin{verbatim}
blade version 3.3.1.SNAPSHOT201811301746
\end{verbatim}

Be careful; snapshot versions are unstable and should only be used for
experimental purposes.

Awesome! You've successfully learned how to update Blade CLI.

\section{Converting Plugins SDK Projects with Blade
CLI}\label{converting-plugins-sdk-projects-with-blade-cli}

Blade CLI can automatically migrate a Plugins SDK project to a Liferay
Workspace. During the process, the Ant-based Plugins SDK project is
copied to the applicable workspace folder based on its project type
(e.g., \texttt{wars}) and is converted to a Gradle-based Liferay
Workspace project. This drastically speeds up the migration process when
upgrading to a Liferay Workspace from a legacy Plugins SDK.

\noindent\hrulefill

\textbf{Note:} There is no Maven command for the migration process yet,
so you must complete it manually for Maven-based workspaces.

\noindent\hrulefill

To copy your Plugins SDK project and convert it to Gradle, use the Blade
\texttt{convert} command:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Navigate to the root folder of your workspace in a command line tool.
\item
  Execute the following command:

\begin{verbatim}
blade convert -s [PLUGINS_SDK_PATH] [PLUGINS_SDK_PROJECT_NAME]
\end{verbatim}

  You must provide the path of the Plugins SDK your project resides in
  and the project name you want to convert. If you prefer converting all
  the Plugins SDK projects at once, replace the project name variable
  with \texttt{-a} (i.e., specifying all plugins).
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** If the `convert` task doesn't work as described above, you may
 need to update your Blade CLI version. See the
 [Updating Blade CLI](/docs/7-1/tutorials/-/knowledge_base/t/updating-blade-cli)
 article for more information.
\end{verbatim}

\noindent\hrulefill

\begin{verbatim}
This Gradle conversion process also works for themes; they're converted to
automatically leverage NodeJS. If you're converting a Java-based theme, add
the `-t` option to your command too. This will incorporate the
[Theme Builder](/docs/reference/7-1/-/knowledge_base/r/theme-builder-gradle-plugin)
Gradle plugin for the theme instead. For more information on upgrading
6.2 themes, see the
[Upgrade a 6.2 Theme to 7.1](/docs/7-1/tutorials/-/knowledge_base/t/upgrading-6-2-themes-to-7-1)
article.
\end{verbatim}

\noindent\hrulefill

\textbf{Note:} When converting a Service Builder project, the
\texttt{convert} task automatically extracts the project's service
interfaces and implementations into OSGi modules (i.e., \emph{-impl and
}-api) and places them in the workspace's \texttt{modules} folder. Your
portlet and controller logic remain a WAR and reside in the
\texttt{wars} folder.

\noindent\hrulefill

Your project is successfully converted to a Gradle-based workspace
project! Great job!

\chapter{Liferay Workspace}\label{liferay-workspace}

A \emph{Liferay Workspace} is a generated environment that is built to
hold and manage your Liferay projects. This workspace is intended to aid
in the management of Liferay projects by providing various Gradle build
scripts and configured properties. This is the official way to create
7.0 modules using Gradle. Do you prefer Maven over Gradle? See the
\href{/docs/7-1/tutorials/-/knowledge_base/t/maven-workspace}{Maven
Workspace} tutorial to learn about using Liferay Workspace with Maven.

Liferay Workspaces can be used in many different development
environments, which makes it flexible and applicable to many different
developers. You can download the
\href{https://sourceforge.net/projects/lportal/files/Liferay\%20Workspace}{Liferay
Project SDK installer} and run it to install
\href{/docs/7-1/tutorials/-/knowledge_base/t/blade-cli}{Blade CLI}
(default CLI for workspace), initialize a new Liferay Workspace, and
download Dev Studio DXP.

You can also use it with other developer IDEs. For example, a Liferay
Workspace easily integrates with Liferay Dev Studio DXP, providing a
seamless development experience. To learn more about Liferay Dev Studio
DXP and using workspace with it, see the
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-a-liferay-workspace-with-liferay-ide}{Creating
a Liferay Workspace with Liferay Dev Studio DXP} tutorial.

Your workspace also offers Gradle properties that you can modify to help
manage the generated folders. There are also some folders that aren't
generated by default, but can be manually created and set. This provides
you the power to customize your workspace's folder structure any way
you'd like. To learn more info on a workspace's folder structure and how
you can configure a workspace, see the
\href{/docs/7-1/tutorials/-/knowledge_base/t/configuring-a-liferay-workspace}{Configuring
a Liferay Workspace} tutorial.

Liferay Workspaces offer a full development lifecycle for your modules
to make your Liferay development easier than ever. The development
lifecycle includes creating, building, deploying, testing, and releasing
modules. To learn more about the development lifecycle of a Liferay
Workspace, see the
\href{/docs/7-1/tutorials/-/knowledge_base/t/development-lifecycle-for-a-liferay-workspace}{Development
Lifecycle for a Liferay Workspace} tutorial.

\section{Installing Liferay
Workspace}\label{installing-liferay-workspace}

You can install Liferay Workspace using the Liferay Project SDK
installer. This installs JPM and
\href{/docs/7-1/tutorials/-/knowledge_base/t/blade-cli}{Blade CLI} into
your user home folder and optionally initializes a Liferay Workspace
folder. This is the same installer used to install Blade CLI, which is
covered in the
\href{/docs/7-1/tutorials/-/knowledge_base/t/installing-blade-cli}{Installing
Blade CLI} tutorial.

Follow the steps below to download and install Liferay Workspace:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Download the latest
  \href{https://sourceforge.net/projects/lportal/files/Liferay\%20IDE/}{Liferay
  Project SDK installer} that corresponds with your operating system
  (e.g., Windows, MacOS, or Linux). The Project SDK installer is listed
  under \emph{Liferay IDE}, so the folder versions are based on IDE
  releases. You can select an installer that does not include Dev Studio
  DXP, if you don't intend to use it. The Project SDK installer is
  available for versions 3.2.0+. Do \textbf{not} select the large green
  download button; this downloads Liferay Portal instead.
\item
  Run the installer. Click \emph{Next} to step through the installer's
  introduction.
\item
  Set the directory where your Liferay Workspace should be initialized.

  \begin{figure}
  \centering
  \includegraphics{./images/blade-installer-workspace-init.png}
  \caption{Determine where your Liferay Workspace should reside.}
  \end{figure}

  Then click \emph{Next}.
\item
  Choose the Liferay product type you intend to use with the workspace.
  Then click \emph{Next}.

  \begin{figure}
  \centering
  \includegraphics{./images/installer-workspace-type.png}
  \caption{Select the product version you'll use with your Liferay
  Workspace.}
  \end{figure}
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** You'll be prompted for your liferay.com username and password
 before downloading the Liferay DXP bundle. Your credentials are not saved
 locally; they're saved as a token in the `~/.liferay` folder. The token is
 used by your workspace if you ever decide to redownload a DXP bundle.
 Furthermore, the bundle that is downloaded in your workspace is also copied
 to your `~/.liferay/bundles` folder, so if you decide to initialize another
 Liferay DXP instance of the same version, the bundle is not re-downloaded. See
 the
 [Adding a Liferay Bundle to a Workspace](/docs/7-1/tutorials/-/knowledge_base/t/configuring-a-liferay-workspace#adding-a-liferay-bundle-to-a-workspace)
 for more information on this topic.
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{4}
\tightlist
\item
  Click \emph{Next} to begin installing Liferay Workspace on your
  machine.
\end{enumerate}

That's it! Liferay Workspace is now installed on your machine!

\section{Configuring a Liferay
Workspace}\label{configuring-a-liferay-workspace}

A Liferay Workspace offers a development environment that can be
configured to fit your development needs. You'll learn about the
files/folders a workspace provides by default, and then you'll dive into
configuring your workspace.

The top-level files/folder of a Liferay (Gradle) Workspace are outlined
below:

\begin{itemize}
\tightlist
\item
  \texttt{bundles} (generated): the default folder for Liferay DXP
  bundles.
\item
  \texttt{configs}: holds the configuration files for different
  environments. These files serve as your global configuration files for
  all Liferay DXP servers and projects residing in your workspace. To
  learn more about using the \texttt{configs} folder, see the
  \href{/docs/7-1/tutorials/-/knowledge_base/t/development-lifecycle-for-a-liferay-workspace\#testing-projects}{Testing
  Modules} section.
\item
  \texttt{ext} (generated): holds the Ext OSGi modules and Ext plugins.
\item
  \texttt{gradle}: holds the Gradle Wrapper used by your workspace.
\item
  \texttt{modules}: holds your custom modules. This can also hold
  frontend portlets created with the
  \href{/docs/7-1/reference/-/knowledge_base/r/js-generator}{Liferay JS
  Toolkit}
\item
  \texttt{plugins-sdk} (generated): holds plugins to migrate from
  previous releases. These project types should eventually be migrated
  to the \texttt{wars} folder, if possible. This is targeted for Liferay
  DXP 7.0 to provide a way to migrate from the Plugins SDK to Liferay
  Workspace. See the
  \href{/docs/7-0/tutorials/-/knowledge_base/t/configuring-a-liferay-workspace\#using-a-plugins-sdk-from-your-workspace}{Using
  a Plugins SDK from Your Workspace} section for more information. The
  Plugins SDK is no longer available for 7.0.
\item
  \texttt{themes}: holds Node.js-style themes that use the Liferay JS
  Theme Toolkit, which are built using the Liferay Theme Generator.
\item
  \texttt{wars}: holds traditional WAR-style web application projects
  and theme projects (i.e., generated by the
  \href{/docs/7-1/reference/-/knowledge_base/r/theme-template}{\texttt{theme}}
  project template).
\item
  \texttt{build.gradle}: the common Gradle build file.
\item
  \texttt{gradle.properties}: specifies the workspace's project
  locations and Liferay DXP server configuration globally.
\item
  \texttt{gradle-local.properties}: sets user-specific properties for
  your workspace. This lets multiple users use a single workspace,
  letting them configure specific properties for the workspace on their
  own machine.
\item
  \texttt{gradlew}: executes the Gradle command wrapper.
\item
  \texttt{settings.gradle}: applies plugins to the workspace and
  configures its dependencies.
\end{itemize}

If you're using a Liferay
\href{/docs/7-1/tutorials/-/knowledge_base/t/maven-workspace}{Maven
Workspace} instead, your folder hierarchy is the same, except the Gradle
build files are swapped out for a \texttt{pom.xml} file. See the Maven
Workspace tutorial for more info on configuring that kind of workspace
project.

The build/properties files included in your workspace's root folder sets
your workspace's Gradle properties and facilitates the build processes
of your modules.

Before you begin using your workspace, you should set your workspace
Gradle properties in the \texttt{gradle.properties} file. There are many
commented out properties in this file. These are the default properties
set in your workspace. If you'd like to change a variable, uncomment the
variable and set it to a custom value. For instance, if you want to
store your modules in a folder other than \texttt{{[}ROOT{]}/modules},
uncomment the \texttt{liferay.workspace.modules.dir} variable and set it
to a different value.

If you'd like to keep the global Gradle properties the same, but want to
change them for yourself only (perhaps for local testing), you can
override the \texttt{gradle.properties} file with your own
\texttt{gradle-local.properties} file.

All properties in the \texttt{gradle.properties} file are documented
within the file. To learn more about how each property works and what's
available, visit your workspace's generated \texttt{gradle.properties}
file. You can also visit the
\hyperref[gradle-workspace-properties]{Gradle Workspace Properties}
section for a list of these properties.

\noindent\hrulefill

\textbf{Note:} Liferay Workspace provides many subprojects for you
behind the scenes, which hides some complexities of Gradle. You can
learn more about this in the
\href{/docs/7-1/tutorials/-/knowledge_base/t/development-lifecycle-for-a-liferay-workspace\#building-projects}{Building
Modules} section.

\noindent\hrulefill

Now that you know about a workspace's default folder structure and how
to modify its Gradle properties, you'll learn how to add a Liferay
bundle to your workspace.

\subsection{Adding a Liferay Bundle to a
Workspace}\label{adding-a-liferay-bundle-to-a-workspace}

Liferay Workspaces can generate and hold a Liferay Server. This lets you
build/test your plugins against a running Liferay instance. Before
generating a Liferay instance, open the \texttt{gradle.properties} file
located in your workspace's root folder. There are several configurable
properties for your workspace's Liferay instance. You can set the
version of the Liferay bundle you'd like to generate and install by
setting the download URL for the \texttt{liferay.workspace.bundle.url}
property (e.g.,
\texttt{https://releases-cdn.liferay.com/portal/7.1.0-ga1/liferay-ce-portal-tomcat-7.1.0-ga1-20180703012531655.zip}).
You can also set the folder where your Liferay bundle is generated with
the \texttt{liferay.workspace.home.dir} property. It's set to
\texttt{bundles} by default.

You can download a Liferay DXP bundle for your workspace if you're a DXP
subscriber. Do this by setting the \texttt{liferay.workspace.bundle.url}
property to a ZIP hosted on \emph{api.liferay.com}. For example,

\texttt{liferay.workspace.bundle.url=https://api.liferay.com/downloads/portal/7.1.10/liferay-dxp-tomcat-7.1.10-ga1-20180703090613030.zip}

It can be tricky to find the fully qualified ZIP name/number for the DXP
bundle you want. You cannot access Liferay's API site directly to find
it, so you must start to download DXP manually, take note of the file
name, and append it to
\texttt{https://api.liferay.com/downloads/portal/}.

You must also set the \texttt{liferay.workspace.bundle.token.download}
property to \texttt{true} to allow your workspace to access Liferay's
API site.

Once you've finalized your Gradle properties, navigate to your
workspace's root folder and run

\begin{verbatim}
blade server init
\end{verbatim}

This uses workspace's pre-bundled
\href{/docs/7-1/tutorials/-/knowledge_base/t/blade-cli}{Blade CLI} tool
to download the version of Liferay DXP you specified in your Gradle
properties and installs your Liferay instance in the \texttt{bundles}
folder.

If you want to skip the downloading process, you can create the
\texttt{bundles} folder manually in your workspace's ROOT folder and
unzip your Liferay DXP bundle to that folder.

You can also produce a distributable Liferay bundle (Zip or Tar) from
within a workspace. To do this, navigate to your workspace's root folder
and run the following command:

\begin{verbatim}
./gradlew distBundle[Zip|Tar]
\end{verbatim}

Your distribution file is available from the workspace's \texttt{/build}
folder.

\noindent\hrulefill

\textbf{Note:} You can define different environments for your Liferay
bundle for easy testing. You can learn more about this in the
\href{/docs/7-1/tutorials/-/knowledge_base/t/development-lifecycle-for-a-liferay-workspace\#testing-projects}{Testing
Modules} section.

\noindent\hrulefill

The Liferay Workspace is a great development environment for Liferay
module development; however, what if you'd like to also stick with
developing WAR-style applications? Liferay Workspace can handle that
request too!

\subsection{Gradle Workspace
Properties}\label{gradle-workspace-properties}

The following configurable properties are available in your workspace's
\texttt{gradle.properties} file:

\begin{itemize}
\tightlist
\item
  \texttt{liferay.workspace.bundle.cache.dir}: Set the directory where
  the downloaded bundle Zip files are stored. The default value is the
  \texttt{.liferay/bundles} folder inside the user home directory.
\item
  \texttt{liferay.workspace.bundle.token.download}: Set this to
  \texttt{true} if the \texttt{liferay.workspace.bundle.url} property is
  set to a DXP bundle Zip. This property allows the token residing in
  the \texttt{\textasciitilde{}/.liferay} folder to be used to validate
  your user credentials when downloading the bundle. The default value
  is \texttt{false}.
\item
  \texttt{liferay.workspace.bundle.token.email.address}: Set the email
  address to use when downloading a DXP bundle. This is used to create
  the authentication token. The email address must match the one
  registered for your DXP subscription. If you wish to create a new
  token without providing your email address and password in this file,
  you can create a token manually by navigating to your Liferay
  profile's Account Setting page and generating a token in the
  Authentication Tokens menu. Your token must reside in the
  \texttt{\textasciitilde{}/.liferay} folder.
\item
  \texttt{liferay.workspace.bundle.token.force}: Set this to
  \texttt{true} to override the existing token with a newly generated
  token created by the \texttt{createToken} task. The default value is
  \texttt{false}.
\item
  \texttt{liferay.workspace.bundle.token.password}: Set the password to
  use when downloading a DXP bundle. This is used to create the
  authentication token. The password must match the one registered for
  your DXP subscription. See the
  \texttt{liferay.workspace.bundle.token.email.address} property for
  more details.
\item
  \texttt{liferay.workspace.bundle.token.password.file}: Set the file to
  hold the Liferay bundle authentication token password. The default
  file value is \texttt{\textasciitilde{}/.liferay/token}.
\item
  \texttt{liferay.workspace.bundle.url}: Set the URL pointing to the
  bundle Zip to download. If the URL points to a DXP bundle (e.g.,
  https://api.liferay.com/\ldots), set the
  \texttt{liferay.workspace.bundle.token.download} property to
  \texttt{true}. The default value is the URL for the latest version of
  Liferay Portal CE.
\item
  \texttt{liferay.workspace.default.repository.enabled}: Set this to
  \texttt{true} to configure Liferay CDN as the default repository in
  the root project. The default value is \texttt{true}.
\item
  \texttt{liferay.workspace.environment}: Set the environment with the
  settings appropriate for current development. The \texttt{configs}
  folder is used to hold different environments in the same workspace.
  You can organize environment settings and generate an environment
  installation with those settings. There are five environments:
  \texttt{common}, \texttt{dev}, \texttt{local}, \texttt{prod}, and
  \texttt{uat}. The default value is \texttt{local}.
\item
  \texttt{liferay.workspace.home.dir}: Set the folder that contains the
  Liferay bundle downloaded from the
  \texttt{liferay.workspace.bundle.url} property. The default value is
  \texttt{bundles}.
\item
  \texttt{liferay.workspace.modules.default.repository.enabled}: Set
  this to \texttt{true} to configure Liferay CDN as the default
  repository for module/OSGi projects. The default value is
  \texttt{true}.
\item
  \texttt{liferay.workspace.ext.dir}: Set the folder that contains all
  Ext OSGi modules and Ext plugins. The default value is \texttt{ext}.
\item
  \texttt{liferay.workspace.modules.dir}: Set the folder that contains
  all module/OSGi projects. The default value is \texttt{modules}.
\item
  \texttt{liferay.workspace.modules.jsp.precompile.enabled}: Set this to
  \texttt{true} to compile the JSP files in OSGi modules and have them
  added to the distributable Zip/Tar. The default value is
  \texttt{false}.
\item
  \texttt{liferay.workspace.plugins.sdk.dir}: Set the folder that
  contains the Plugins SDK environment. The default value is
  \texttt{plugins-sdk}.
\item
  \texttt{liferay.workspace.target.platform.version}: Set the Liferay
  Portal or DXP bundle version to develop against. This property enables
  target platform features such as the OSGi \texttt{resolve} task and
  specialized dependency management. Use \texttt{7.1.1} for the latest
  Liferay CE release and \texttt{7.1.10} for the latest DXP release.
\item
  \texttt{liferay.workspace.themes.dir}: Set the folder that contains
  Node.js-style theme projects, which use the Liferay JS Theme Toolkit.
  The default value is \texttt{themes}.
\item
  \texttt{liferay.workspace.themes.java.build}: Set this to
  \texttt{true} to build the theme projects using the Liferay Portal
  Tools Theme Builder. The default value is \texttt{false}.
\item
  \texttt{liferay.workspace.wars.dir}: Set the folder that contains
  classic WAR-style projects. The default value is \texttt{wars}.
\end{itemize}

That's it! You now have the knowledge to fully leverage the power of
Liferay Workspace!

\section{Setting Proxy Requirements for Liferay
Workspace}\label{setting-proxy-requirements-for-liferay-workspace}

If you're working behind a corporate firewall that requires using a
proxy server to access external repositories, you need to add some extra
configuration to make Liferay Workspace work within your environment.
You'll learn how to set proxy requirements for both Gradle and Maven
environments.

\subsection{Using Gradle}\label{using-gradle}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open your \texttt{\textasciitilde{}/.gradle/gradle.properties} file.
  Create this file if it does not exist.
\item
  Add the following properties to the file:

\begin{verbatim}
systemProp.http.proxyHost=www.somehost.com
systemProp.http.proxyPort=1080
systemProp.https.proxyHost=www.somehost.com
systemProp.https.proxyPort=1080
\end{verbatim}

  Make sure to replace the proxy host and port values with your own.
\item
  If the proxy server requires authentication, also add the following
  properties:

\begin{verbatim}
systemProp.http.proxyUser=userId
systemProp.http.proxyPassword=yourPassword
systemProp.https.proxyUser=userId
systemProp.https.proxyPassword=yourPassword
\end{verbatim}
\end{enumerate}

Excellent! Your proxy settings are set in your Liferay Workspace's
Gradle environment.

\subsection{Using Maven}\label{using-maven}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open your \texttt{\textasciitilde{}/.m2/settings.xml} file. Create
  this file if it does not exist.
\item
  Add the following XML snippet to the file:

\begin{verbatim}
<?xml version="1.0" encoding="UTF-8"?>
    <settings xmlns="http://maven.apache.org/SETTINGS/1.0.0"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd">
        <proxies>
            <proxy>
                <id>httpProxy</id>
                <active>true</active>
                <protocol>http</protocol>
                <host>www.somehost.com</host>
                <port>1080</port>
            </proxy>
            <proxy>
                <id>httpsProxy</id>
                <active>true</active>
                <protocol>https</protocol>
                <host>www.somehost.com</host>
                <port>1080</port>
            </proxy>
        </proxies>
    </settings>
\end{verbatim}

  Make sure to replace the proxy host and port values with your own.
\item
  If the proxy server requires authentication, also add the
  \texttt{username} and \texttt{password} proxy properties. For example,
  the HTTP proxy authentication configuration would look like this:

\begin{verbatim}
<proxy>
  <id>httpProxy</id>
  <active>true</active>
  <protocol>http</protocol>
  <host>www.somehost.com</host>
  <port>1080</port>
  <username>userID</username>
  <password>somePassword</password>
</proxy>
\end{verbatim}
\end{enumerate}

Excellent! Your Maven proxy settings are now set.

\section{Development Lifecycle for a Liferay
Workspace}\label{development-lifecycle-for-a-liferay-workspace}

Liferay Workspaces provide an environment that supports all phases of a
Liferay module's development lifecycle:

\begin{itemize}
\tightlist
\item
  \hyperref[creating-projects]{Creating projects}
\item
  \hyperref[building-projects]{Building projects}
\item
  \hyperref[deploying-projects]{Deploying projects}
\item
  \hyperref[testing-projects]{Testing projects}
\item
  \hyperref[releasing-projects]{Releasing projects}
\end{itemize}

In this tutorial, you'll explore the development lifecycle phases
Liferay Workspace provides for you. Then you'll be directed to other
tutorials that go into further detail for leveraging the workspace's
particular lifecycle phase for a specific tool (e.g., Blade CLI or
Liferay Dev Studio DXP). Let's get started!

\subsection{Creating Projects}\label{creating-projects}

The first step of Liferay Workspace's development phase is the project
creation process. Workspace provides a slew of templates that you can
use to create many different types of Liferay projects. Workspace also
provides development support for frontend portlets generated with the
\href{/docs/7-1/reference/-/knowledge_base/r/js-generator}{Liferay JS
Toolkit}. They're stored in the \texttt{modules} folder by default.

You can configure where your workspace creates modules by editing the
\texttt{liferay.workspace.modules.dir} property in the workspace's
\texttt{gradle.properties} file. By default, modules are created in the
\texttt{{[}ROOT{]}/modules} folder.

You can also control where themes are generated by specifying the
\texttt{liferay.workspace.themes.dir} property in the
\texttt{gradle.properties} file. Themes are typically migrated to the
\texttt{themes} folder after being created using the
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-themes}{Liferay
Theme Generator}.

Workspace also provides a way to create WAR projects, which are
generated in the folder set by the \texttt{liferay.workspace.wars.dir}
property in the \texttt{gradle.properties} file. There are several
\href{/docs/7-1/reference/-/knowledge_base/r/project-templates}{project
templates} that create WAR-style projects, which should be stored in the
\texttt{wars} folder.

To learn more about creating projects in a workspace using Blade CLI or
Liferay Dev Studio, visit the
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-projects-with-blade-cli}{Creating
Projects with Blade CLI} and
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-modules-with-liferay-ide}{Creating
Modules with Liferay Dev Studio} tutorials, respectively.

\subsection{Building Projects}\label{building-projects}

Liferay Workspace abstracts many build requirements away so you can
focus on developing projects instead of worrying about how to build
them. Liferay Workspace is built using Gradle, so your projects leverage
the Gradle build lifecycle.

Workspace includes a Gradle wrapper in its ROOT folder (e.g.,
\texttt{gradlew}), which you can leverage to execute Gradle commands.
This means that you can run familiar Gradle build commands (e.g.,
\texttt{build}, \texttt{clean}, \texttt{compile}, etc.) from a Liferay
Workspace without having Gradle installed on your machine.

\noindent\hrulefill

\textbf{Note:} You can also use the workspace's Gradle wrapper by
executing \texttt{blade\ \ gw} followed by the Gradle command. This is
an easier way to run the workspace's Gradle wrapper without specifying
its path. Since the workspace's Gradle wrapper resides in its root
folder, it can sometimes be a hassle running it for a deeply nested
module (e.g., \texttt{../../../../gradlew\ compileJava}). Running the
Gradle wrapper from Blade CLI automatically detects the Gradle wrapper
and can run it anywhere.

\noindent\hrulefill

When using Liferay Workspace, the workspace plugin is automatically
applied which adds a multitude of subprojects for you, hiding some
complexities of Gradle. For example, a typical project's
\texttt{settings.gradle} file could contain many included subprojects
like this:

\begin{verbatim}
...
include images:base:oracle-jdk:oracle-jdk-6
include images:base:oracle-jdk:oracle-jdk-7
include images:base:oracle-jdk:oracle-jdk-8
include images:base:liferay-portal:liferay-portal-ce-tomcat-7.1-ga1
include images:source-bundles:glassfish
include images:source-bundles:jboss-eap
include images:source-bundles:tomcat
include images:source-bundles:websphere
include images:source-bundles:wildfly
include compose:jboss-eap-mysql
include compose:tomcat-mariadb
include compose:tomcat-mysql
include compose:tomcat-mysql-elastic
include compose:tomcat-postgres
include file-server
...
\end{verbatim}

You don't have to worry about applying these subprojects because the
workspace plugin does it for you. Likewise, if a folder in the
\texttt{/themes} folder includes a \texttt{liferay-theme.json} file, the
\texttt{gulp} plugin is applied to it; if a folder in the
\texttt{/modules} folder includes a \texttt{bnd.bnd} file, the
\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-sample-projects}{liferay-gradle}
plugin is applied to it. See the
\href{/docs/7-1/reference/-/knowledge_base/r/gradle}{Gradle} reference
article for a list of Liferay Gradle plugins automatically provided for
all Workspace apps. As you can see, Liferay Workspace provides many
plugins and build configurations behind the scenes to make your
development process convenient.

A good example of the Gradle build lifecycle abstraction is the project
deployment process in a workspace. You can build/deploy your modules
from workspace without ever running a Gradle command. You'll learn how
to do this next.

\subsection{Deploying Projects}\label{deploying-projects}

Liferay Workspace provides easy-to-use deployment mechanisms that let
you deploy your project to a Liferay server without any custom
configuration. To learn more about deploying projects from a workspace
using Blade CLI or Liferay Dev Studio DXP, visit the
\href{/docs/7-1/tutorials/-/knowledge_base/t/deploying-projects-with-blade-cli}{Deploying
Projects with Blade CLI} and
\href{/docs/7-1/tutorials/-/knowledge_base/t/deploying-projects-with-liferay-ide}{Deploying
Modules with Liferay Dev Studio DXP} tutorials, respectively.

\subsection{Testing Projects}\label{testing-projects}

Liferay provides many configuration settings for 7.0. Configuring
several different Liferay DXP installations to simulate/test certain
behaviors can become cumbersome and time consuming. With Liferay
Workspace, you can easily organize environment settings and generate an
environment installation with those settings.

Liferay Workspace provides the \texttt{configs} folder, which lets you
configure different environments in the same workspace. For example, you
could configure separate Liferay DXP environment settings for
development, testing, and production in a single Liferay Workspace. So
how does it work?

The \texttt{configs} folder offers five subfolders:

\begin{itemize}
\tightlist
\item
  \texttt{common}: holds a common configuration that you want applied to
  all environments.
\item
  \texttt{dev}: holds the development configuration.
\item
  \texttt{local}: holds the configuration intended for testing locally.
\item
  \texttt{prod}: holds the configuration for a production site.
\item
  \texttt{uat}: holds the configuration for a UAT site.
\end{itemize}

You're not limited to just these environments. You can create any
subfolder in the \texttt{configs} folder (e.g., \texttt{aws},
\texttt{docker}, etc.) to simulate any environment. Each environment
folder can supply its own database, \texttt{portal-ext.properties},
Elasticsearch, etc. The files in each folder overlay your Liferay DXP
installation, which you generate from within workspace.

\begin{figure}
\centering
\includegraphics{./images/workspace-configs.png}
\caption{The \texttt{configs/common} and
\texttt{configs/{[}environment{]}} overlay you Liferay DXP bundle when
it's generated.}
\end{figure}

When workspace generates a Liferay DXP bundle, these things happen:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Configuration files found in the \texttt{configs/common} folder are
  applied to the Liferay DXP bundle.
\item
  The configured workspace environment (\texttt{dev}, \texttt{local},
  \texttt{prod}, \texttt{uat}, etc.) is applied on top of any existing
  configurations from the \texttt{common} folder.
\end{enumerate}

To generate a Liferay DXP bundle with a specific environment
configuration to the workspace's \texttt{/bundles} folder, run

\begin{verbatim}
./gradlew initBundle -Pliferay.workspace.environment=[ENVIRONMENT]
\end{verbatim}

To generate a distributable Liferay DXP installation to the workspace's
\texttt{/build} folder, run

\begin{verbatim}
./gradlew distBundle[Zip|Tar] -Pliferay.workspace.environment=[ENVIRONMENT]
\end{verbatim}

The \texttt{ENVIRONMENT} variable should match the configuration folder
(\texttt{dev}, \texttt{local}, \texttt{prod}, \texttt{uat}, etc.) you
intend to apply.

\noindent\hrulefill

\textbf{Note:} You may prefer to set your workspace environment in the
\texttt{gradle.properties} file instead of passing it via Gradle
command. If so, it's recommended to set the workspace envrionment
variable inside the \texttt{{[}USER\_HOME{]}/.gradle/gradle.properties}
file.

\begin{verbatim}
 liferay.workspace.environment=local
\end{verbatim}

The variable is set to \texttt{local} by default.

\noindent\hrulefill

To simulate using the \texttt{configs} folder, let's explore a typical
scenario. Suppose you want a local Liferay DXP installation for testing
and a UAT installation for simulating a production site. Assume you want
the following configuration for the two environments:

\textbf{Local Environment}

\begin{itemize}
\tightlist
\item
  Use MySQL database pointing to localhost
\item
  Skip setup wizard
\end{itemize}

\textbf{UAT Environment}

\begin{itemize}
\tightlist
\item
  Use MySQL database pointing to a live server
\item
  Skip setup wizard
\end{itemize}

To configure these two environments in your workspace, follow the steps
below:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open the \texttt{configs/common} folder and add the
  \texttt{portal-setup-wizard.properties} file with the
  \texttt{setup.wizard.enabled=false} property.
\item
  Open the \texttt{configs/local} folder and configure the MySQL
  database settings for localhost in a \texttt{portal-ext.properties}
  file.
\item
  Open the \texttt{configs/uat} folder and configure the MySQL database
  settings for the live server in a \texttt{portal-ext.properties} file.
\item
  Now that your two environments are configured, generate one of them:

\begin{verbatim}
./gradlew distBundle[Zip|Tar] -Pliferay.workspace.environment=uat
\end{verbatim}

  You've successfully configured two environments and generated one of
  them.
\end{enumerate}

Awesome! You can now test various Liferay DXP bundle environments using
Liferay Workspace.

\subsection{Releasing Projects}\label{releasing-projects}

Liferay Workspace does not provide a built-in release mechanism, but
there are easy ways to use external release tools with workspace. The
most popular choice is uploading your projects to a Maven Nexus
repository. You could also use other release tools like
\href{https://www.jfrog.com/artifactory/}{Artifactory}.

Uploading projects to a remote repository is useful if you need to share
them with other non-workspace projects. Also, if you're ready for your
projects to be in the spotlight, uploading them to a public remote
repository gives other developers the chance to use them.

For more instructions on how to set up a Maven Nexus repository for your
workspace's projects, see the
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-a-maven-repository}{Creating
a Maven Repository} and
\href{/docs/7-1/tutorials/-/knowledge_base/t/deploying-liferay-maven-artifacts-to-a-repository}{Deploying
Liferay Maven Artifacts to a Repository} tutorials.

\section{Managing the Target Platform for Liferay
Workspace}\label{managing-the-target-platform-for-liferay-workspace}

Liferay Workspace helps you target a specific release of Liferay DXP, so
dependencies get resolved properly. This makes upgrades easy: specify
your target platform, and Workspace points to the new version. All your
dependencies are updated to the latest ones provided in the targeted
release.

\noindent\hrulefill

\textbf{Note:} There are times when configuring dependencies based on a
version range is better than tracking exact versions. See the
\href{/docs/7-1/tutorials/-/knowledge_base/t/semantic-versioning}{Semantic
Versioning} tutorial for more details.

\noindent\hrulefill

\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-ide}{Liferay Dev
Studio DXP 3.2+} helps you streamline targeting a specific version even
more. Dev Studio DXP can index the configured Liferay DXP source code to

\begin{itemize}
\tightlist
\item
  provide advanced Java search (Open Type and Reference Searching)
  (\href{/docs/7-1/tutorials/-/knowledge_base/t/searching-product-source-in-liferay-ide}{tutorial})
\item
  debug Liferay DXP sources
  (\href{/docs/7-1/tutorials/-/knowledge_base/t/debugging-product-source-in-liferay-ide}{tutorial})
\end{itemize}

To enable this functionality, set the following property in your
workspace's \texttt{gradle.properties} file:

\begin{verbatim}
target.platform.index.sources=true
\end{verbatim}

\noindent\hrulefill

\textbf{Note:} Portal source indexing is disabled in Gradle workspace
version 2.0.3+ (Target Platform plugin version 2.0.0+).

\noindent\hrulefill

These options in Dev Studio DXP are only available when developing in a
Liferay Workspace, or if you have the
\href{/docs/7-1/reference/-/knowledge_base/r/target-platform-gradle-plugin}{Target
Platform} Gradle plugin applied to your multi-module Gradle project with
specific configurations. See the
\hyperref[targeting-a-platform-outside-of-workspace]{Targeting a
Platform Outside of Workspace} section for more info on applying the
Target Platform Gradle plugin.

Next, you'll discover how all of this is possible.

\subsection{Dependency Management with
BOMs}\label{dependency-management-with-boms}

You can target a version by importing a predefined bill of materials
(BOM). This only requires that you specify a property in your
workspace's \texttt{gradle.properties} file. You'll see how to do this
later.

Each Liferay DXP version has a predefined BOM that you can specify for
your workspace to reference. Each BOM defines the artifacts and their
versions used in the specific release. BOMs list all dependencies in a
management fashion, so it doesn't \textbf{add} dependencies to your
project; it only \textbf{provides} your build tool (e.g., Gradle or
Maven) the versions needed for the project's defined artifacts. This
means you don't need to specify your dependency versions; the BOM
automatically defines the appropriate artifact versions based on the
BOM.

You can override a BOM's defined artifact version by specifying a
different version in your project's \texttt{build.gradle}. Artifact
versions defined in your project's build files override those specified
in the predefined BOM. Note that overriding the BOM can be dangerous;
make sure the new version is compatible in the targeted platform.

For more information on BOMs, see the
\href{https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism\#Importing_Dependencies}{Importing
Dependencies} section in Maven's official documentation.

Pretty cool, right? Next, you'll step through an example configuration.

\subsection{Setting the Target
Platform}\label{setting-the-target-platform}

Setting the version to develop for takes two steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open the workspace's \texttt{gradle.properties} file and set the
  \texttt{liferay.workspace.target.platform.version} property to the
  version you want to target. For example,

\begin{verbatim}
liferay.workspace.target.platform.version=7.1.1
\end{verbatim}

  If you're using Liferay DXP, you can set the property like this:

\begin{verbatim}
liferay.workspace.target.platform.version=7.1.10
\end{verbatim}

  The versions following a GA1 release of DXP follow fix pack versions
  (e.g., \texttt{7.1.10.fp1}, \texttt{7.1.10.fp2}, etc.).
\item
  Once the target platform is configured, check to make sure no
  dependencies in your Gradle build files specify a version. The
  versions are now imported from the configured target platform's BOM.
  For example, a simple MVC portlet's \texttt{build.gradle} may look
  something like this:

\begin{verbatim}
dependencies {
    compileOnly group: "com.liferay.portal", name: "com.liferay.portal.kernel"
    compileOnly group: "com.liferay.portal", name: "com.liferay.util.taglib"
    compileOnly group: "javax.portlet", name: "portlet-api"
    compileOnly group: "javax.servlet", name: "javax.servlet-api"
    compileOnly group: "jstl", name: "jstl"
    compileOnly group: "org.osgi", name: "osgi.cmpn"
}
\end{verbatim}
\end{enumerate}

\noindent\hrulefill

\textbf{Note}: The \texttt{liferay.workspace.target.platform.version}
property also sets the distro JAR, which can be used to validate your
projects during the build process. See the
\href{/docs/7-1/tutorials/-/knowledge_base/t/validating-modules-against-the-target-platform}{Validating
Modules Against the Target Platform} tutorials for more info.

\noindent\hrulefill

The target platform functionality is available in Liferay Workspace
version 1.9.0+. If you have an older version, you must update it to
leverage platform targeting. See the
\href{/docs/7-1/tutorials/-/knowledge_base/t/updating-liferay-workspace}{Updating
Liferay Workspace} tutorial to do this.

You now know how to configure a target platform in workspace and how
dependencies without versions appear in your Gradle build files. You're
all set!

\subsection{Targeting a Platform Outside of
Workspace}\label{targeting-a-platform-outside-of-workspace}

If you prefer to not use Liferay Workspace, but still want to target a
platform, you must apply the
\href{/docs/7-1/reference/-/knowledge_base/r/target-platform-gradle-plugin}{Target
Platform} Gradle plugin to the root \texttt{build.gradle} file of your
custom multi-module Gradle build.

To do this, your \texttt{build.gradle} file should look similar to this:

\begin{verbatim}
buildscript {
    dependencies {
        classpath group: "com.liferay", name: "com.liferay.gradle.plugins.target.platform", version: "1.1.6"
    }
    repositories {
        maven {
            url "https://repository-cdn.liferay.com/nexus/content/groups/public"
        }
    }
}

apply plugin: "com.liferay.target.platform"

dependencies {
    targetPlatformBoms group: "com.liferay.portal", name: "release.portal.bom", version: "7.1.0"
    targetPlatformBoms group: "com.liferay.portal", name: "release.portal.bom.compile.only", version: "7.1.0"
}
\end{verbatim}

Liferay DXP users must replace the artifact names and versions:

\begin{itemize}
\tightlist
\item
  \texttt{release.portal.bom} → \texttt{release.dxp.bom}
\item
  \texttt{release.portal.bom.compile.only} →
  \texttt{release.dxp.bom.compile.only}
\item
  \texttt{7.1.0} → \texttt{7.1.10}
\end{itemize}

This Gradle code

\begin{itemize}
\tightlist
\item
  applies Liferay's Target Platform Gradle plugin
\item
  configures the repository that provides the necessary artifacts for
  your project build
\item
  sets the Target Platform plugin's dependencies:

  \begin{itemize}
  \tightlist
  \item
    \texttt{com.liferay.ce.portal.bom}: provides all the artifacts
    included in Liferay DXP.
  \item
    \texttt{com.liferay.ce.portal.compile.only}: provides artifacts that
    are not included in Liferay DXP, but are necessary to reference
    during the build (e.g., \texttt{org.osgi.core}).
  \end{itemize}
\end{itemize}

If you're interested in
\href{/docs/7-1/tutorials/-/knowledge_base/t/searching-product-source-in-liferay-ide}{advanced
search} and/or
\href{/docs/7-1/tutorials/-/knowledge_base/t/debugging-product-source-in-liferay-ide}{debugging}
Liferay DXP's source using
\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-ide}{Liferay Dev
Studio DXP}, you must also apply the following configuration:

\begin{verbatim}
targetPlatformIDE {
    includeGroups "com.liferay", "com.liferay.portal"
}
\end{verbatim}

This indexes the target platform's source code and makes it available to
Dev Studio DXP.

Now you can define your target platform!

\section{Managing Themes in Liferay
Workspace}\label{managing-themes-in-liferay-workspace}

Creating a Liferay DXP theme can be accomplished using two different
tools:

\begin{itemize}
\tightlist
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/creating-themes}{Liferay
  Theme Generator} (Node.js-based themes that use the Liferay JS Theme
  Toolkit)
\item
  \href{/docs/7-1/reference/-/knowledge_base/r/theme-template}{Project
  template/archetype} (Gradle/Maven-based)
\end{itemize}

Liferay Workspace offers an environment where developers can use the
Liferay Theme Generator to create themes and their work can be
seamlessly integrated into their overall DevOps strategy. You can
leverage the Liferay Theme Generator to create Node.js-based themes
inside workspace or you can leverage it externally and copy themes into
Workspace.

Workspace also offers a traditional Java-based theme approach
(leveraging Gradle/Maven) for those that can't use the Liferay JS Theme
Toolkit's tools in their CI environment.

Below you'll learn how to manage both Node.js-based themes and
Gradle/Maven-based themes in Workspace.

\subsection{Node.js Themes in
Workspace}\label{node.js-themes-in-workspace}

Liferay Workspace reserves the \texttt{themes} folder only for themes
that are created with the Themes Generator. There are no Blade
CLI-provided commands or Maven archetypes to generate a theme. You must
leverage the
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-themes}{Liferay
Theme Generator} from within the \texttt{themes} folder to create them;
you can also copy a generated theme into the folder.

You'll demo this theme management capability next. Be sure the Liferay
Theme Generator's required tooling is installed.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Navigate to your workspace's \texttt{themes} folder and run the
  following command:

\begin{verbatim}
yo liferay-theme
\end{verbatim}

  Follow the prompts to create your theme.
\item
  Navigate into your new theme and run \texttt{../gradlew\ build}.
  Liferay Workspace builds the front-end theme using Gradle. Under the
  hood, Liferay's
  \href{/docs/7-1/reference/-/knowledge_base/r/node-gradle-plugin}{Node
  Gradle Plugin} is applied and used to build your theme.
\item
  Workspace is smart enough to differentiate between theme types. For
  instance, you can't copy a theme built with the Theme Generator into
  the \texttt{wars} folder and expect it to build. You can test if your
  project is recognized by Workspace by running this command from
  Workspace's root folder:

\begin{verbatim}
../gradlew projects
\end{verbatim}

  Your CLI should display your new theme under the \texttt{themes}
  project.

\begin{verbatim}
Root project 'liferay-workspace'
+--- Project ':themes'
\end{verbatim}
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
        \--- Project ':themes:my-generated-theme'
\end{verbatim}

\noindent\hrulefill

\begin{verbatim}
If you moved a WAR-style theme (Gradle/Maven-based) into the `themes`
folder, it is not recognized by the Gradle `projects` command.

**Note:** Workspace identifies whether a theme was generated by the Theme
Generator by checking whether it has a `package.json` file. Any theme
without this file is not compatible in the `themes` folder.
\end{verbatim}

Excellent! You learned how generated themes are recognized in workspace
and where they should reside. Next you'll learn how workspace manages
WAR-style themes.

\subsection{Gradle/Maven Themes in
Workspace}\label{gradlemaven-themes-in-workspace}

Liferay Workspace provides the \texttt{wars} folder for any WAR-style
project. Themes created with
\href{/docs/7-1/tutorials/-/knowledge_base/t/blade-cli}{Blade CLI} or
Maven using the
\href{/docs/7-1/reference/-/knowledge_base/r/theme-template}{\texttt{theme}}
project template or archetype are automatically generated here when
creating the project within Workspace.

Themes built using Liferay's \texttt{theme} project template are always
WARs and should always reside in Workspace's \texttt{wars} folder. They
should never be moved to the \texttt{themes} folder; that folder is
reserved for themes generated by the Theme Generator only.

To build an existing WAR-style theme in Workspace, run the
\texttt{../gradlew\ build} command. Liferay Workspace builds the theme
using Gradle. Under the hood, Liferay's
\href{/docs/7-1/reference/-/knowledge_base/r/theme-builder-gradle-plugin}{Theme
Builder Gradle Plugin} is applied and used to build your theme. It works
similarly in a Maven workspace. See the
\href{/docs/7-1/tutorials/-/knowledge_base/t/building-themes-in-a-maven-project}{Building
Themes in a Maven Project} tutorial for more information.

Awesome! You know how WAR-style themes are built in workspace and where
they should reside.

\chapter{Validating Modules Against the Target
Platform}\label{validating-modules-against-the-target-platform}

\noindent\hrulefill

\textbf{Important:} Validating modules with the \texttt{resolve} task is
deprecated. It only functions as it's documented here in versions prior
to Liferay Workspace (Gradle only) version 2.0.3. It is being redesigned
for workspace versions 2.0.3+ and is still in development at this time.

\noindent\hrulefill

After you write a module in Liferay Workspace, you can validate it
before deployment to make sure of several things:

\begin{itemize}
\tightlist
\item
  Will my app deploy successfully?
\item
  Will there be some sort of missing requirement?
\item
  If there's an issue, how do I diagnose it?
\end{itemize}

These are all common worries that can be frustrating.

Instead of deploying your app and checking for errors in the log, you
can validate your app before deployment. This is done by calling Liferay
Workspace's \texttt{resolve} task, which validates your modules against
a targeted platform. Continue on to learn how this works.

\section{Resolving Your Modules}\label{resolving-your-modules}

Deploying your modules only to be met with console errors or mysterious
problems can be frustrating. You can avoid this painful process by
resolving your modules before deployment. This can be done by calling
the \texttt{resolve} Gradle task provided by Liferay Workspace.

\begin{verbatim}
../gradlew resolve
\end{verbatim}

This task gathers all the capabilities provided by

\begin{itemize}
\tightlist
\item
  the specified version of Liferay DXP (i.e.,
  \href{/docs/7-1/tutorials/-/knowledge_base/t/managing-the-target-platform-for-liferay-workspace}{targeted
  platform})
\item
  the current workspace's modules
\end{itemize}

Some capabilities/information gathered by the \texttt{resolve} task that
are validated include

\begin{itemize}
\tightlist
\item
  declared required capabilities
\item
  module versions
\item
  package imports/use constraints
\item
  service references
\end{itemize}

It also computes a list of run requirements for your project. Then it
compares the current project's requirements against the gathered
capabilities. If your project requires something not available in the
gathered list of capabilities, the task fails.

The task can only validate OSGi modules. It does not work with WAR-style
projects, themes, or npm portlets.

\noindent\hrulefill

\textbf{Note:} The \texttt{resolve} task can be executed from a specific
project folder or from the workspace's root folder. Running the task
from the root folder validates all the modules in your workspace.

\noindent\hrulefill

The \texttt{resolve} task can automatically gather the available
capabilities from your workspace, but you must specify this for your
targeted Liferay DXP version. To do this, open your workspace's
\texttt{gradle.properties} file and set the
\texttt{liferay.workspace.target.platform.version} property to the
version you want to target. For example,

\begin{verbatim}
liferay.workspace.target.platform.version=7.1.0
\end{verbatim}

If you're using Liferay DXP, you can set the property like this:

\begin{verbatim}
liferay.workspace.target.platform.version=7.1.10
\end{verbatim}

The versions following a GA1 release of DXP follow fix pack versions
(e.g., \texttt{7.1.10.fp1}, \texttt{7.1.10.fp2}, etc.).

Setting the target platform property provides a static \emph{distro} JAR
for the specified version of Liferay DXP, which contains all the
metadata (i.e., capabilities, packages, versions, etc.) running in that
version. The distro JAR is a complete snapshot of everything provided in
the OSGi runtime; this serves as the target platform's list of
capabilities that your modules are validated against.

You can now validate your module projects before deploying them!
Sometimes, you must modify the \texttt{resolve} task's default behavior
to successfully validate your app. See the
\href{/docs/7-1/tutorials/-/knowledge_base/t/modifying-the-target-platforms-capabilities}{Modifying
the Target Platform's Capabilities} tutorial for more information. For
help resolving common output errors printed by the \texttt{resolve}
task, see the
\href{/docs/7-1/reference/-/knowledge_base/r/resolving-common-output-errors-reported-by-the-resolve-task}{Resolving
Common Output Errors Reported by the resolve Task} article.

\section{Modifying the Target Platform's
Capabilities}\label{modifying-the-target-platforms-capabilities}

In a perfect world, everything the \texttt{resolve} task gathers and
checks against would work during your development process.
Unfortunately, there are exceptions that may force you to modify the
default functionality of the \texttt{resolve} task. If you're unfamiliar
with workspace's \texttt{resolve} task, see the
\href{/docs/7-1/tutorials/-/knowledge_base/t/resolving-your-modules}{Resolving
Your Modules} tutorial for more information.

There are two scenarios you may run into during development that require
a modification for your project to pass the resolver check.

\begin{itemize}
\tightlist
\item
  You're depending on a third party library that is not available in the
  targeted Liferay DXP instance or the current workspace.
\item
  You're depending on a customized distribution of Liferay DXP.
\end{itemize}

You'll explore these use cases next.

\subsection{Depending on Third Party Libraries Not Included in Liferay
DXP}\label{depending-on-third-party-libraries-not-included-in-liferay-dxp}

The \texttt{resolve} task, by default, gathers all of Liferay DXP's
capabilities and the capabilities of your workspace's modules. What if,
however, your module depends on a third party project that is not
included in either space (e.g.,
\href{https://opensource.google.com/projects/guava}{Google Guava})?. The
\texttt{resolve} task fails by default if your project depends on this
project type. You probably plan to have this project deployed and
available at runtime, so it's not a concern, but the resolver doesn't
know that; you must customize the resolver to bypass this.

There are three ways you can do this:

\begin{itemize}
\tightlist
\item
  \hyperref[embed-the-third-party-library-in-your-module]{Embed the
  third party library in your module}
\item
  \hyperref[add-the-third-party-librarys-capabilities-to-the-current-static-set-of-resolver-capabilities]{Add
  the third party library's capabilities to the current static set of
  resolver capabilities}
\item
  \hyperref[skip-the-resolving-process-for-your-module]{Skip the
  resolving process for your module}
\end{itemize}

For help resolving third party dependency errors, see the
\href{/docs/7-1/tutorials/-/knowledge_base/t/adding-third-party-libraries-to-a-module}{Resolving
Third Party Library Package Dependencies} tutorial.

\subsubsection{Embed the Third Party Library in Your
Module}\label{embed-the-third-party-library-in-your-module}

If you only have one module that depends on the third party project, you
can bypass the resolver failure by embedding the JAR in your module.
This is not a best practice if more than one project in the OSGi
container depends on that module. See the
\href{/docs/7-1/tutorials/-/knowledge_base/t/adding-third-party-libraries-to-a-module\#embedding-libraries-in-a-module}{Embedding
Libraries in a Module} section for more details.

\subsubsection{Add the Third Party Library's Capabilities to the Current
Static Set of Resolver
Capabilities}\label{add-the-third-party-librarys-capabilities-to-the-current-static-set-of-resolver-capabilities}

You can add your third party dependencies to the target platform's
default list of capabilities by listing them as provided modules. Do
this by adding the following Gradle code into your workspace's root
\texttt{build.gradle} file:

\begin{verbatim}
dependencies {
    providedModules group: "GROUP_ID", name: "NAME", version: "VERSION"
}
\end{verbatim}

For example, if you wanted to add
\href{https://opensource.google.com/projects/guava}{Google Guava} as a
provided module, it would look like this:

\begin{verbatim}
dependencies {
    providedModules group: "com.google.guava", name: "guava", version: "23.0"
}
\end{verbatim}

This both provides the third party dependency to the resolver, and it
downloads and includes it in your Liferay DXP bundle's
\texttt{osgi/modules} folder when you initialize it (e.g.,
\texttt{blade\ server\ init}).

\subsubsection{Skip the Resolving Process for Your
Module}\label{skip-the-resolving-process-for-your-module}

It may be easiest to skip validating a particular module during the
resolve process. To do this, open your workspace's root
\texttt{build.gradle} file and insert the following Gradle code at the
bottom of the file:

\begin{verbatim}
targetPlatform {
    resolveOnlyIf { project ->
        project.name != 'PROJECT_NAME'
    }
}
\end{verbatim}

Be sure to replace the \texttt{PROJECT\_NAME} filler with your module's
name (e.g., \texttt{test-api}).

If you prefer to disable the Target Platform plugin altogether, you can
add a slightly different directive to your \texttt{build.gradle} file:

\begin{verbatim}
targetPlatform {
    onlyIf { project ->
        project.name != 'PROJECT_NAME'
    }
}
\end{verbatim}

This both skips the \texttt{resolve} task execution and disables BOM
dependency management.

Now the \texttt{resolve} task skips your module project.

\subsection{Depending on a Customized Distribution of Liferay
DXP}\label{depending-on-a-customized-distribution-of-liferay-dxp}

There are times when manually specifying your project's list of
dependent JARs does not suffice. If your app requires a customized
Liferay DXP instance to run, you must regenerate the target platform's
default list of capabilities with an updated list. Two examples of a
customized Liferay DXP instance are described below:

\textbf{Example 1: Leveraging an External Feature}

There are many external features/frameworks available that are not
included in the downloadable bundle by default. After deploying a
feature/framework, it's available for your module projects to leverage.
When validating your app, however, the \texttt{resolve} task does not
have access to external capabilities not included by default. For
example, Audience Targeting is an example of this type of external
framework. If you're creating a Liferay Audience Targeting rule that
depends on the Audience Targeting framework, you can't easily provide a
slew of JARs for your module. In this case, you should install the
platform your code depends on and regenerate an updated list of
capabilities that your Liferay DXP instance provides.

\textbf{Example 2: Leveraging a Customized Core Feature}

You can extend Liferay DXP's core features to provide a customized
experience for your intended audience. Once deployed, you can assume
these customizations are present and build other things on top of them.
The new capabilities resulting from your customizations are not
available, however, in the target platform's default list of
capabilities. Therefore, when your application relies on non-default
capabilities, it fails during the \texttt{resolve} task. To get around
this, you must regenerate a new list of capabilities that your
customized Liferay DXP instance provides.

To regenerate the target platform's capabilities (distro JAR) based on
the current workspace's Liferay DXP instance, follow the steps below:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Start the Liferay DXP instance stored in your workspace. Make sure the
  platform you want to depend on is installed.
\item
  Download the
  \href{https://search.maven.org/\#search\%7Cga\%7C1\%7Cbiz.aqute.remote.agent}{BND
  Remote Agent JAR file} and copy it into the \texttt{osgi/modules}
  folder.
\item
  From the root folder of your workspace, run the following command:

\begin{verbatim}
bnd remote distro -o custom_distro.jar release.portal.distro 7.1.0
\end{verbatim}

  Liferay DXP users must replace the \texttt{release.portal.distro}
  artifact name with \texttt{release.dxp.distro} and use the
  \texttt{7.1.10} version syntax.

  This connects to the newly deployed BND agent running in Liferay DXP
  and generates a new distro JAR named \texttt{custom\_distro.jar}. All
  other capabilities inherit their functionality based on your Liferay
  DXP instance, so verify the workspace bundle is the version you plan
  to release in production.
\item
  Navigate to your workspace's root \texttt{build.gradle} file and add
  the following dependency:

\begin{verbatim}
dependencies {
    targetPlatformDistro files('custom_distro.jar')
}
\end{verbatim}
\end{enumerate}

Now your workspace is pointing to a custom distro JAR file instead of
the default one provided. Run the \texttt{resolve} task to validate your
modules against the new set of capabilities.

\section{Including the Resolver in Your Gradle
Build}\label{including-the-resolver-in-your-gradle-build}

By default, Liferay Workspace provides the \texttt{resolve} task as an
independent executable. It's provided by the
\href{/docs/7-1/reference/-/knowledge_base/r/target-platform-gradle-plugin}{Target
Platform} Gradle plugin and is not integrated in any other Gradle
processes. This gives you control over your Gradle build without
imposing strategies you may not want included in your default build
process.

With that said, the \texttt{resolve} task can be useful to include in
your build process if you want to check for errors in your module
projects before deployment. Instead of resolving your projects
separately from your standard build, you can build and resolve them all
in one shot.

In Liferay Workspace, the recommended path for doing this is adding it
to the default \texttt{check} Gradle task. The \texttt{check} task is
provided by default in a workspace by the
\href{https://docs.gradle.org/current/userguide/java_plugin.html\#_lifecycle_tasks}{Java}
plugin. Adding the \texttt{resolve} task to the \texttt{check} lifecycle
task also promotes the \texttt{resolve} task to run for CI and other
test tools that typically run the \texttt{check} task for verification.
Of course, Gradle's \texttt{build} task also depends on the
\texttt{check} task, so you can run \texttt{gradlew\ build} and run the
resolver too.

To call the \texttt{resolve} task during the \texttt{check} task
automatically, open your workspace's root \texttt{build.gradle} file and
add the following directive:

\begin{verbatim}
check.dependsOn resolve
\end{verbatim}

You can also configure this for specific projects in a workspace if you
don't want all modules to be included in the global \texttt{check}.

If the \texttt{resolve} task runs during every Gradle build, you may
want to prevent the build from failing if there are errors reported by
the resolver. To do this, open your workspace's root
\texttt{build.gradle} file and add the following code:

\begin{verbatim}
targetPlatform {
    ignoreResolveFailures = true
}
\end{verbatim}

This reports the failures without failing the build. Note, this can only
be configured in the workspace's root \texttt{build.gradle} file.

Awesome! You can now run the \texttt{resolve} task in your current
Gradle lifecycle.

\section{Validating Modules Outside of
Workspace}\label{validating-modules-outside-of-workspace}

If you prefer to not use Liferay Workspace, but still want to validate
modules against a target platform, you must apply the
\href{/docs/7-1/reference/-/knowledge_base/r/target-platform-gradle-plugin}{Target
Platform} Gradle plugin to the root \texttt{build.gradle} file of your
multi-module Gradle build. Follow the
\href{/docs/7-1/tutorials/-/knowledge_base/t/managing-the-target-platform-for-liferay-workspace\#targeting-a-platform-outside-of-workspace}{Targeting
a Platform Outside of Workspace} section to do this.

Once you have the Target Platform plugin and its BOM dependencies
configured, you must configure the \texttt{targetPlatformDistro}
dependency. Open your project's root \texttt{build.gradle} file and add
it to the list of dependencies. It should look like this:

\begin{verbatim}
dependencies {
    targetPlatformBoms group: "com.liferay.portal", name: "release.portal.bom", version: "7.1.0"
    targetPlatformBoms group: "com.liferay.portal", name: "release.portal.bom.compile.only", version: "7.1.0"
    targetPlatformDistro group: "com.liferay.portal", name "release.portal.distro", version: "7.1.0"
}
\end{verbatim}

Liferay DXP users must replace the artifact names and versions:

\begin{itemize}
\tightlist
\item
  \texttt{release.portal.bom} → \texttt{release.dxp.bom}
\item
  \texttt{release.portal.bom.compile.only} →
  \texttt{release.dxp.bom.compile.only}
\item
  \texttt{release.portal.distro} → \texttt{release.dxp.distro}
\item
  \texttt{7.1.0} → \texttt{7.1.10}
\end{itemize}

Now you can validate your modules against a target platform!

\section{Leveraging Docker}\label{leveraging-docker}

Docker has become increasingly popular in today's development lifecycle,
by providing an automated way to package software and its dependencies
into a standardized unit that can be shared cross-platform. Read
Docker's extensive \href{https://docs.docker.com/}{documentation} to
learn more.

Liferay provides Docker images for

\begin{itemize}
\tightlist
\item
  \href{https://hub.docker.com/r/liferay/portal}{Liferay Portal}
\item
  \href{https://hub.docker.com/r/liferay/dxp}{Liferay DXP}
\item
  \href{https://hub.docker.com/r/liferay/commerce}{Liferay Commerce}
\item
  \href{https://hub.docker.com/r/liferay/portal-snapshot}{Liferay Portal
  Snapshots}
\end{itemize}

You can pull Liferay's Docker images from those resources and manage
them yourself. Liferay Workspace, however, provides an easy way to
integrate Docker development into your existing development workflow
with preconfigured Gradle tasks.

\noindent\hrulefill

\textbf{Note:} Leveraging Docker in Liferay Workspace is only available
for Gradle projects at this time.

\noindent\hrulefill

In this tutorial, you'll learn how to do the following tasks within a
workspace:

\begin{itemize}
\tightlist
\item
  \hyperref[creating-a-product-docker-container]{Creating a Docker
  container based on a provided Liferay DXP image}
\item
  \hyperref[configuring-the-container]{Configuring the container}
\item
  \hyperref[interacting-with-the-container]{Interacting with the
  container}
\item
  \hyperref[building-a-custom-product-image]{Building a custom Liferay
  DXP image}
\end{itemize}

\subsection{Creating a Liferay DXP Docker
Container}\label{creating-a-liferay-dxp-docker-container}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Choose the Docker image you need. This is configured in your
  workspace's \texttt{gradle.properties} file by customizing this
  property:

\begin{verbatim}
liferay.workspace.docker.image.liferay
\end{verbatim}

  To find the possible property values you can set, see the official
  Liferay DXP Docker Hub's Tags section (e.g.,
  \href{https://hub.docker.com/r/liferay/portal/tags}{Liferay Portal
  Docker Tags}. For example, if you want to base your container on the
  Liferay Portal 7.1 GA2 image, you would set this property:

\begin{verbatim}
liferay.workspace.docker.image.liferay=liferay/portal:7.1.1-ga2
\end{verbatim}
\item
  Run the following command from your workspace's root folder:

\begin{verbatim}
./gradlew createDockerContainer
\end{verbatim}
\end{enumerate}

This command creates a new container named
\texttt{{[}projectName{]}-liferayapp}. A new \texttt{build/docker}
folder is generated in your workspace. This folder is mounted into the
container's file system. This means files in workspace's
\texttt{build/docker} folder are also available in the container's
\texttt{/etc/liferay} folder.

Any projects in your workspace are automatically compiled and copied to
the \texttt{build/docker/deploy} folder when the container is created;
this means that when the container is started, all your projects are
deployed to the container. All configurations are also applied to the
container. You'll learn more about configuring your container next.

\subsection{Configuring the Container}\label{configuring-the-container}

Before starting your container, you may want to add additional portal
configurations. This could include things like

\begin{itemize}
\tightlist
\item
  Property overrides (e.g., \texttt{portal-ext.properties})
\item
  Marketplace app overrides
\item
  App server configurations
\item
  License files
\end{itemize}

You can do this by applying files (and their accompanying folder
structures, if necessary) to your workspace's \texttt{configs/docker}
folder. This folder is treated as your Liferay Home for Docker
development; you add additional files that overlay your workspace's
\texttt{configs/common} folder and your Liferay DXP container's default
configuration.

For example, to enable the Gogo shell for your container, add a
\texttt{configs/docker/portal-ext.properties} file to your workspace
with the following configuration:

\begin{verbatim}
module.framework.properties.osgi.console=0.0.0.0:11311
\end{verbatim}

This lets you access your container using
\href{/docs/7-1/reference/-/knowledge_base/r/using-the-felix-gogo-shell}{Gogo
shell} via telnet session.

Once the container is started, the configurations stored in
\texttt{configs/commmon} and \texttt{configs/docker} are transferred to
the \texttt{build/docker/files} folder, which applies all configurations
to the container's file system. For more information on workspace's
\texttt{configs} folder, see
\href{/docs/7-1/tutorials/-/knowledge_base/t/development-lifecycle-for-a-liferay-workspace\#testing-projects}{this
section}.

\noindent\hrulefill

\textbf{Note:} You can call the \texttt{deployDocker} Gradle task from
your workspace's root folder to initiate the Docker configuration
transfer to the \texttt{build/docker/files} folder manually. It's
executed automatically when creating or starting the container.

\noindent\hrulefill

Next, you'll explore the commands for interacting with the container.

\subsection{Interacting with the
Container}\label{interacting-with-the-container}

\texttt{startDockerContainer}: starts the container.

\texttt{logsDockerContainer}: prints the portal runtime's logs. You can
exit log tracking mode while maintaining a running container (e.g.,
{[}Ctrl\textbar Command{]} + C).

\texttt{dockerDeploy}: deploys the project to the container's
\texttt{deploy} folder by copying the project archive file to
workspace's \texttt{build/docker/deploy} folder. This command can also
be executed from workspace's root folder to deploy all projects and copy
all Docker configurations (i.e., from the \texttt{configs/common} and
\texttt{configs/docker} folders) to the container.

\texttt{stopDockerContainer}: stops the container.

\texttt{removeDockerContainer}: removes the container from Docker's
system.

\noindent\hrulefill

\textbf{Note:} During your container's startup, you may run into the
following error:

\begin{verbatim}
 /etc/liferay/entrypoint.sh: line 3:    11 Killed
 ${LIFERAY_HOME}/tomcat/bin/catalina.sh run
\end{verbatim}

This usually means you have not allocated enough memory to your Docker
engine to successfully run your container. See Docker's
\href{https://docs.docker.com}{documentation} to learn how to increase
resources available to Docker.

\noindent\hrulefill

Next, you'll learn how to build a custom image.

\subsection{Building a Custom Liferay DXP
Image}\label{building-a-custom-liferay-dxp-image}

You can preserve your container's configuration by building it as an
image. To build your custom Liferay DXP image, run

\begin{verbatim}
./gradlew buildDockerImage
\end{verbatim}

A \texttt{Dockerfile} is generated for your container when building your
image. To do this manually, run

\begin{verbatim}
./gradlew createDockerfile
\end{verbatim}

The \texttt{Dockerfile} is generated in your workspace's
\texttt{build/docker} folder. For more information on how to configure
the \texttt{Dockerfile}, see Docker's
\href{https://docs.docker.com/engine/reference/builder/}{Dockerfile
reference documentation}.

Your custom image is now available! Run \texttt{docker\ image\ ls} to
verify its availability.

You can now manage Liferay's Docker images in Liferay Workspace!

\section{Updating Liferay Workspace}\label{updating-liferay-workspace}

Liferay Workspace is continuously being updated with new features. If
you created your workspace a while ago, you may be missing out on some
of the latest features that could improve your Liferay development
experience. Updating your Liferay Workspace is easy; you'll learn how to
do it next.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Find the latest Liferay Workspace version. To do this, open the
  \href{https://github.com/liferay/liferay-portal/blob/master/modules/sdk/gradle-plugins-workspace/CHANGELOG.markdown}{Liferay
  Gradle Plugins Workspace Change Log} and copy the version to which you
  want to upgrade. You can find the updates and new features associated
  with each version by browsing the change log too.
\item
  Open your Liferay Workspace's \texttt{settings.gradle} file. This file
  resides in your Workspace's root folder.
\item
  In the \texttt{dependencies} block, you'll find code similar to below:

\begin{verbatim}
dependencies {
    classpath group: "com.liferay", name: "com.liferay.gradle.plugins.workspace", version: "[WORKSPACE_VERSION]"
}
\end{verbatim}

  Update the \texttt{com.liferay.gradle.plugins.workspace} dependency's
  \texttt{version} to the version number you copied from the change log
  in step 1.
\item
  Execute any Gradle command to initiate the update process for your
  Workspace (e.g., \texttt{blade\ gw\ tasks}).
\end{enumerate}

\noindent\hrulefill

\textbf{Note:} The Gradle wrapper provided in a Gradle-based Liferay
Workspace must be updated if you're migrating from a workspace before
version \texttt{1.10.14} to the latest available version. To update your
Gradle wrapper, run

\begin{verbatim}
 ./gradlew wrapper --gradle-version=4.10.2
\end{verbatim}

\noindent\hrulefill

Awesome! You learned where to check for Liferay Workspace's latest
version, how to update your Workspace to that version, and how to
initiate the update process.

\section{Updating Default Plugins Provided by Liferay
Workspace}\label{updating-default-plugins-provided-by-liferay-workspace}

Liferay Workspace comes with a slew of plugins like these:

\begin{itemize}
\tightlist
\item
  \href{https://github.com/liferay/liferay-portal/tree/master/modules/util/css-builder}{CSS
  Builder}
\item
  \href{https://github.com/liferay/liferay-portal/tree/master/modules/util/javadoc-formatter}{Javadoc
  Formatter}
\item
  \href{https://github.com/liferay/liferay-portal/tree/master/modules/util/lang-builder}{Lang
  Builder}
\item
  \href{https://github.com/liferay/liferay-portal/tree/master/modules/util/portal-tools-service-builder}{Service
  Builder}
\item
  \href{https://github.com/liferay/liferay-portal/tree/master/modules/util/source-formatter}{Source
  Formatter}
\item
  \href{https://github.com/liferay/liferay-portal/tree/master/modules/util/portal-tools-theme-builder}{Theme
  Builder}
\item
  etc.
\end{itemize}

Bundled plugins are updated with each release of workspace. Suppose you
need a new feature in the
\href{https://github.com/liferay/liferay-portal/tree/master/modules/util/source-formatter}{Source
Formatter plugin}, but the latest workspace version has not yet been
updated to include it. You can upgrade it yourself!

To upgrade one of workspace's bundled plugins, follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Find the bundle symbolic name (BSN) for the plugin you want to update.
  You can find this value in the
  \href{https://github.com/liferay/liferay-portal/blob/master/modules/sdk/gradle-plugins/src/main/resources/com/liferay/gradle/plugins/dependencies/portal-tools.properties}{\texttt{portal-tools.properties}}
  file. For example, the Source Formatter's BSN is
  \texttt{com.liferay.source.formatter}.
\item
  Open your workspace's \texttt{gradle.properties} file and copy the
  plugin's BSN followed by \texttt{.version} and set the desired plugin
  version you want to use. For example,

\begin{verbatim}
com.liferay.source.formatter.version=1.0.654
\end{verbatim}

  If you're most interested in the latest and greatest plugins, you can
  set the above property to \texttt{latest.release} to always use the
  latest available version. This could, however, cause your workspace to
  become unstable.
\end{enumerate}

That's it! You're no longer tied to particular plugin versions provided
by your workspace.

\chapter{Maven}\label{maven-1}

\href{https://maven.apache.org/}{Maven} is a viable option for managing
Liferay projects if you don't want to use Liferay's default Gradle
management system. Liferay provides several
\href{/docs/7-1/reference/-/knowledge_base/r/maven}{Maven plugins} to
let you generate and manage your project. Liferay also provides Maven
artifacts that are easy to obtain and are required for Liferay Maven
module development. In the Maven tutorials, you'll learn how to

\begin{itemize}
\tightlist
\item
  Install Liferay Maven artifacts.
\item
  Generate Liferay projects using Maven archetypes.
\item
  Create a Module JAR using Maven.
\item
  Deploy a project built with Maven to Liferay DXP.
\item
  Create a remote repository for Maven projects.
\item
  Deploy a Maven project to a remote repository.
\item
  Use Service Builder in a Maven project.
\item
  Compile Sass files in a Maven project.
\item
  Build a Liferay theme in a Maven project.
\item
  Leverage the Maven Workspace.
\end{itemize}

Because Liferay DXP is tool agnostic, Maven is fully supported for
Liferay DXP development. Read on to learn more!

\section{Installing Liferay Maven
Artifacts}\label{installing-liferay-maven-artifacts}

To create Liferay modules using Maven, you'll need the archives required
by Liferay (e.g., JAR and WAR files). This isn't a problem--Liferay
provides them as Maven artifacts. You can retrieve them from a remote
repository.

There are two repositories that contain Liferay artifacts: Central
Repository and Liferay Repository. The Central Repository is the default
repository used to download artifacts if you don't have a remote
repository configured. The Central Repository \emph{usually} offers the
latest Liferay Maven artifacts, but using the the Liferay Repository
\emph{guarantees} the latest artifacts released by Liferay. Other than a
slight delay between artifact releases between the two repositories,
they're identical. You'll learn how to reference both of them next.

Using the Central Repository to install Liferay Maven artifacts only
requires that you specify your module's dependencies in its
\texttt{pom.xml} file. For example, the snippet below sets a dependency
on Liferay's \texttt{com.liferay.portal.kernel} artifact:

\begin{verbatim}
<dependencies>
    <dependency>
        <groupId>com.liferay.portal</groupId>
        <artifactId>com.liferay.portal.kernel</artifactId>
        <version>2.61.2</version>
        <scope>provided</scope>
    </dependency>
    ...
</dependencies>
\end{verbatim}

When packaging your module, the automatic Maven artifact installation
process only downloads the artifacts necessary for that module from the
Central Repository.

You can view the published Liferay Maven artifacts on the Central
Repository by searching for \emph{liferay maven} in the repo's Search
bar. For convenience, you can reference the available artifacts at
\href{http://search.maven.org/\#search\%7Cga\%7C1\%7Cliferay\%20maven}{http://search.maven.org/\#search\textbar ga\textbar1\textbar liferay
maven}. Use the Latest Version column as a guide to see what's available
for the intended version of Liferay DXP for which you're developing.

If you'd like to access Liferay's latest Maven artifacts, you can
configure Maven to use \href{https://repository.liferay.com}{Liferay's
Nexus repository} instead by inserting the following snippet in your
project's parent \texttt{pom.xml}:

\begin{verbatim}
<repositories>
    <repository>
        <id>liferay-public-releases</id>
        <name>Liferay Public Releases</name>
        <url>https://repository.liferay.com/nexus/content/repositories/liferay-public-releases</url>
    </repository>
</repositories>
  
<pluginRepositories>
    <pluginRepository>
        <id>liferay-public-releases</id>
        <url>https://repository.liferay.com/nexus/content/repositories/liferay-public-releases/</url>
    </pluginRepository>
</pluginRepositories>
\end{verbatim}

The above configuration retrieves artifacts from Liferay's release
repository.

\noindent\hrulefill

\textbf{Note:} Liferay also provides a
\href{https://repository.liferay.com/nexus/content/repositories/liferay-public-snapshots/}{snapshot
repository} that you can access by modifying the
\texttt{\textless{}id\textgreater{}},
\texttt{\textless{}name\textgreater{}}, and
\texttt{\textless{}url\textgreater{}} tags to point to that repo. This
repository should only be used in special cases. You'll also need to
enable accessing the snapshot artifacts:

\begin{verbatim}
 <snapshots>
     <enabled>true</enabled>
 </snapshots>
\end{verbatim}

\noindent\hrulefill

When the Liferay repository is configured in your \texttt{settings.xml}
file, archetypes are generated based on that repository's contents. See
the
\href{/docs/7-1/tutorials/-/knowledge_base/t/generating-new-projects-using-archetypes}{Generating
New Projects Using Archetypes} tutorial for details on using Maven
archetypes for Liferay development.

If you've configured the Liferay Nexus repository to access Liferay
Maven artifacts and you've already been syncing from the Central
Repository, you may need to clear out parts of your local repository to
force Maven to re-download the newer artifacts. Also, do not leave the
Liferay repository configured when publishing artifacts to Maven
Central. You must comment out the Liferay Repository credentials when
publishing your artifacts.

The Liferay Maven repository offers a good alternative for those who
want the most up-to-date Maven artifacts produced by Liferay.

Congratulations! You've downloaded the Liferay artifacts and installed
them to your chosen repository.

\section{Generating New Projects Using
Archetypes}\label{generating-new-projects-using-archetypes}

Creating Maven projects from scratch can be a lot of work. What
dependencies does my Liferay portlet project need? What does a Liferay
Maven Service Builder project look like? How do I create a Liferay
Maven-based context contributor? These questions can be answered with
three words: Liferay Maven Archetypes.

Liferay provides a slew of Maven archetypes to easily create Liferay
projects. In this tutorial, you'll learn how to use Liferay's Maven
archetypes to generate a project.

At the time of this writing, Liferay provides approximately 60 Maven
archetypes for you to use; expect this number to continue growing! These
archetypes are generated from the Central Repository, unless you've
configured for them to be generated from another remote repository
(e.g., \href{https://repository.liferay.com}{Liferay Repository}. You
can view the Liferay-provided Maven archetypes by running the following
command:

\begin{verbatim}
mvn archetype:generate -Dfilter=liferay
\end{verbatim}

The generated archetypes are not all intended for the latest Liferay DXP
release. Some are intended for earlier versions of Liferay Portal (e.g.,
7.0, 6.2). For example, archetypes with the
\texttt{com.liferay.maven.archetypes} prefix are legacy archetypes
targeted for Liferay Portal 6.2. Those prefixed with
\texttt{com.liferay.project.templates.{[}TYPE{]}} or
\texttt{com.liferay.faces.archetype:{[}TYPE{]}} are compatible with 7.0.

Here's a brief list of some popular Maven archetypes provided by
Liferay:

\begin{itemize}
\tightlist
\item
  \href{/docs/7-1/reference/-/knowledge_base/r/activator-template}{Activator}
\item
  \href{/docs/7-1/reference/-/knowledge_base/r/using-the-fragment-template}{Fragment}
\item
  \href{/docs/7-1/reference/-/knowledge_base/r/using-the-mvc-portlet-template}{MVC
  Portlet}
\item
  \href{/docs/7-1/reference/-/knowledge_base/r/npm-angular-portlet-template}{npm
  Angular Portlet}
\item
  \href{/docs/7-1/reference/-/knowledge_base/r/npm-react-portlet-template}{npm
  React Portlet}
\item
  \href{/docs/7-1/reference/-/knowledge_base/r/panel-app-template}{Panel
  App}
\item
  \href{/docs/7-1/reference/-/knowledge_base/r/portlet-provider-template}{Portlet
  Provider}
\item
  \href{/docs/7-1/reference/-/knowledge_base/r/using-the-service-builder-template}{Service
  Builder}
\item
  \href{/docs/7-1/reference/-/knowledge_base/r/soy-portlet-template}{Soy
  Portlet}
\item
  \href{/docs/7-1/reference/-/knowledge_base/r/theme-template}{Theme}
\item
  and many more\ldots{}
\end{itemize}

For documentation on the archetypes (project templates) compatible with
7.0, see the
\href{/docs/7-1/reference/-/knowledge_base/r/project-templates}{Project
Templates} reference section. Visit Maven's
\href{http://maven.apache.org/archetype/maven-archetype-plugin/generate-mojo.html}{Archetype
Generation} documentation for further details on how to modify the Maven
archetype generation process.

\noindent\hrulefill

\textbf{Note:} If you're creating a JSF portlet using Liferay Faces, you
can find example archetype declarations for JSF component suites at
\href{http://www.liferayfaces.org/}{http://www.liferayfaces.org}.

\noindent\hrulefill

Here's an example that creates a Liferay MVC portlet using its Liferay
Maven archetype.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  On the command line, navigate to where you want your Maven project.
  Run the Maven archetype generation command filtered for Liferay
  archetypes only:

\begin{verbatim}
mvn archetype:generate -Dfilter=liferay
\end{verbatim}
\item
  Select the \texttt{com.liferay.project.templates.mvc.portlet}
  archetype by choosing its corresponding number (e.g., \texttt{11}).

  In most cases, you should choose the latest archetype version. The
  archetype versions provided are compatible with all 7.x versions of
  Liferay DXP.
\item
  Depending on the Maven archetype you selected, you're given a set of
  archetype options to fill out for your Maven project. For the MVC
  portlet archetype, you could use these properties:

  \begin{itemize}
  \tightlist
  \item
    \texttt{groupId}: \texttt{com.liferay}
  \item
    \texttt{artifactId}:
    \texttt{com.liferay.project.templates.mvc.portlet}
  \item
    \texttt{version}: \texttt{1.0.6}
  \item
    \texttt{package}: \texttt{com.liferay.docs}
  \item
    \texttt{className}: \texttt{SampleMVC}
  \end{itemize}

  Once you've filled out the required property values, you're given a
  summary of the properties configuration you defined. Enter \texttt{Y}
  to confirm your project's configuration.
\end{enumerate}

Your Maven project is generated and available from the folder you ran
the archetype generation command from. If you have an existing parent
\texttt{pom.xml} file in that folder, your module project is
automatically accounted for there:

\begin{verbatim}
<modules>
    ...
    <module>com.liferay.project.templates.mvc.portlet</module>
</modules>
\end{verbatim}

The Liferay Maven archetypes generate deployable Liferay projects, but
they're bare bones and likely require further customizations.

If you want to generate a quick foundation for a Liferay project built
with Maven, using Liferay Maven archetypes is your best option.

\section{Creating a Module JAR Using
Maven}\label{creating-a-module-jar-using-maven}

If you have an existing Liferay module built with Maven that you created
from scratch, or you're upgrading your Maven project from a previous
version of Liferay DXP, your project probably can't generate an
executable OSGi JAR. Don't fret! You can do this by making a few minor
configurations in your module's POMs.

\noindent\hrulefill

\textbf{Note:} If you used Liferay's Maven archetypes to generate your
module project, the project already has the Maven plugins required to
generate an OSGi JAR.

\noindent\hrulefill

Continue on to see how this is done.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In your project's \texttt{pom.xml} file, add the
  \href{http://njbartlett.name/2015/03/27/announcing-bnd-maven-plugin.html}{BND
  Maven Plugin} declaration:

\begin{verbatim}
<plugin>
    <groupId>biz.aQute.bnd</groupId>
    <artifactId>bnd-maven-plugin</artifactId>
    <version>3.3.0</version>
    <executions>
        <execution>
            <goals>
                <goal>bnd-process</goal>
            </goals>
        </execution>
    </executions>
    <dependencies>
        <dependency>
            <groupId>biz.aQute.bnd</groupId>
            <artifactId>biz.aQute.bndlib</artifactId>
            <version>3.2.0</version>
        </dependency>
        <dependency>
            <groupId>com.liferay</groupId>
            <artifactId>com.liferay.ant.bnd</artifactId>
            <version>2.0.41</version>
        </dependency>
    </dependencies>
</plugin>
\end{verbatim}

  The BND Maven plugin prepares all your Maven module's resources (e.g.,
  \texttt{MANIFEST.MF}) and inserts them into the generated
  \texttt{{[}Maven\ Project{]}/target/classes} folder. This plugin
  prepares your module to be packaged as an OSGi JAR deployable to
  Liferay DXP.
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** Although WABs can be generated using the `bnd-maven-plugin`, this
 is not supported by Liferay. WABs should be created as a standard WAR
 project and deployed to the
 [Liferay WAB Generator](/docs/7-1/tutorials/-/knowledge_base/t/using-the-wab-generator),
 which generates a WAB for you.
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\item
  In your project's \texttt{pom.xml} file, add the
  \href{http://maven.apache.org/plugins/maven-jar-plugin/}{Maven JAR
  Plugin} declaration:

\begin{verbatim}
<build>
    <plugins>
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-jar-plugin</artifactId>
            <version>2.6</version>
            <configuration>
                <archive>
                    <manifestFile>${project.build.outputDirectory}/META-INF/MANIFEST.MF</manifestFile>
                </archive>
            </configuration>
        </plugin>
    </plugins>
</build>
\end{verbatim}

  The Maven JAR plugin builds your Maven project as a JAR file,
  including the resources generated by the BND Maven plugin. The above
  configuration also sets the default project \texttt{MANIFEST.MF} file
  path for your project, which is essential when packaging your module
  using the BND Maven plugin. By default, the Maven JAR Plugin ignores
  the \texttt{target/classes/META-INF/MANIFEST.MF} generated by the BND
  Maven plugin, so you must explicitly set it as the manifest file so
  it's included properly in the generated JAR file.
\item
  Make sure you've added a \href{http://bnd.bndtools.org/}{bnd.bnd file}
  to your Liferay Maven project, residing in the same folder as your
  project's \texttt{pom.xml} file.
\item
  Build your Maven OSGi JAR by running

\begin{verbatim}
mvn package
\end{verbatim}

  Your Maven JAR is generated in your project's \texttt{/target} folder.
  You can deploy it manually into Liferay DXP's \texttt{/deploy} folder,
  or you can configure your project to deploy automatically to Liferay
  DXP by following the
  \href{/docs/7-1/tutorials/-/knowledge_base/t/deploying-a-project-built-with-maven-to-product}{Deploying
  a Project Built with Maven to Liferay DXP} tutorial.
\end{enumerate}

Fantastic! You've configured your Liferay Maven project to package
itself into a deployable OSGi module.

\section{Deploying a Project Built with Maven to Liferay
DXP}\label{deploying-a-project-built-with-maven-to-liferay-dxp}

There are two ways to deploy a Maven-built Liferay project:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Copy your generated Maven JAR/WAR to your Liferay DXP instance's
  \texttt{/deploy} folder.
\item
  Configure your Maven project to deploy to the Liferay DXP instance
  automatically by running a Maven command via the command line.
\end{enumerate}

Although manually copying your JAR/WAR for deployment is a viable
option, this is an inefficient way to deploy your projects. With a small
configuration in your Maven POMs, you can deploy a project to Liferay
DXP with one command execution.

\noindent\hrulefill

\textbf{Note:} In previous versions of Liferay Portal, you were able to
execute the \texttt{liferay:deploy} command to deploy your configured
Maven project to a Liferay server. This is no longer possible since the
\texttt{liferay-maven-plugin} is not applied to Maven projects built
from Liferay archetypes.

\noindent\hrulefill

If you're deploying a module JAR, a prerequisite for this tutorial is to
have your project configured to generate an OSGi module JAR; if you
haven't done this, visit the
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-a-module-jar-using-maven}{Creating
a Module JAR Using Maven} tutorial for more information.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add the following plugin configuration to your Liferay Maven project's
  parent \texttt{pom.xml} file.

\begin{verbatim}
<build>
    <plugins>
        <plugin>
            <groupId>com.liferay</groupId>
            <artifactId>com.liferay.portal.tools.bundle.support</artifactId>
            <version>3.2.1</version>
            <executions>
                <execution>
                    <id>deploy</id>
                    <goals>
                        <goal>deploy</goal>
                    </goals>
                    <phase>pre-integration-test</phase>
                </execution>
            </executions>
        </plugin>
    </plugins>
</build>
\end{verbatim}

  This POM configuration applies Liferay's
  \href{/docs/7-1/reference/-/knowledge_base/r/bundle-support-plugin}{Bundle
  Support plugin} by defining its \texttt{groupId}, \texttt{artifactId},
  and \texttt{version}. You can learn more about this plugin in the
  \href{/docs/7-1/tutorials/-/knowledge_base/t/maven-workspace}{Maven
  Workspace} tutorial. The logic also defines the
  \href{https://maven.apache.org/guides/mini/guide-configuring-plugins.html\#Using_the_executions_Tag}{executions}
  tag, which configures the Bundle Support plugin to run during the
  \texttt{pre-integration-test} phase of your Maven project's build
  lifecycle. The \texttt{deploy}
  \href{http://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html\#A_Build_Phase_is_Made_Up_of_Plugin_Goals}{goal}
  is defined for that lifecycle phase.
\item
  By default, the Bundle Support plugin deploys to the Liferay
  installation in the \texttt{bundles} folder, located in your plugin's
  parent folder. If you do not have your project set up this way, you
  must define your Liferay home folder in your POM. You can do this by
  adding the following logic within the \texttt{plugin} tags, but
  outside of the \texttt{execution} tags:

\begin{verbatim}
<configuration>
    <liferayHome>LIFERAY_HOME_PATH</liferayHome>
</configuration>
\end{verbatim}

  An example configuration would look like this:

\begin{verbatim}
<configuration>
    <liferayHome>C:/liferay/liferay-ce-portal-7.1-ga1</liferayHome>
</configuration>
\end{verbatim}
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** Maven applications built for previous Liferay Portal versions
 required the `<liferay.maven.plugin.version>` tag to do various tasks (e.g.,
 deploying to a Liferay server). This tag is not needed since the old
 `liferay-maven-plugin` is no longer used.
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\item
  Run this command to deploy your project:

\begin{verbatim}
mvn verify
\end{verbatim}
\end{enumerate}

That's it! Your Liferay Maven project is built and deployed
automatically to your Liferay DXP instance.

\section{Creating a Maven Repository}\label{creating-a-maven-repository}

You'll frequently want to share Liferay artifacts and modules with
teammates or manage your repositories using a GUI. You can do this using
\href{http://www.sonatype.org/nexus/}{Sonatype Nexus}. It's a Maven
repository management server that facilitates creating and managing
release servers, snapshot servers, and proxy servers. There are several
other Maven repository management servers you can use (for example,
\href{https://www.jfrog.com/artifactory/}{Artifactory}), but this
tutorial focuses on Nexus.

To create a Maven repository using Nexus, download
\href{https://help.sonatype.com/display/NXRM2/Download}{Nexus} and
follow the instructions on Nexus'
\href{https://help.sonatype.com/display/NXRM2/Installing+and+Running}{Installation
page} to install and start it.

To create your own repository using Nexus, follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open your web browser; navigate to your Nexus repository server (e.g.,
  \url{http://localhost:8081/nexus}) and log in. The default user name
  is \texttt{admin} with password \texttt{admin123}.
\item
  Click on \emph{Repositories} and navigate to \emph{Add\ldots{}} →
  \emph{Hosted Repository}.

  \begin{figure}
  \centering
  \includegraphics{./images/maven-nexus-create-repo.png}
  \caption{Adding a repository to hold your Liferay artifacts is easy
  with Nexus.}
  \end{figure}

  To learn more about each type of Nexus repository, read Sonatype's
  \href{http://books.sonatype.com/nexus-book/reference/confignx-sect-manage-repo.html}{Managing
  Repositories} guide.
\item
  Enter repository properties appropriate for the type of artifacts it
  will hold. If you're installing release version artifacts into the
  repository, specify \emph{Release} as the repository policy. Below are
  example repository property values:

  \begin{itemize}
  \tightlist
  \item
    \textbf{Repository ID:} \emph{liferay-releases}
  \item
    \textbf{Repository Name:} \emph{Liferay Release Repository}
  \item
    \textbf{Provider:} \emph{Maven2}
  \item
    \textbf{Repository Policy:} \emph{Release}
  \end{itemize}
\item
  Click \emph{Save}.
\end{enumerate}

You just created a Liferay Maven repository accessible from your Nexus
repository server! Congratulations!

It's also useful to create a Maven repository to hold snapshots of each
Liferay project you create. Creating a snapshot repository is almost
identical to creating a release repository. The only difference is that
you specify \emph{Snapshot} as its repository policy. For example,
examine an example snapshot repository's property values:

\begin{itemize}
\tightlist
\item
  \textbf{Repository ID:} \emph{liferay-snapshots}
\item
  \textbf{Repository Name:} \emph{Liferay Snapshot Repository}
\item
  \textbf{Provider:} \emph{Maven2}
\item
  \textbf{Repository Policy:} \emph{Snapshot}
\end{itemize}

Voila! You've created a repository for your Liferay releases (i.e.,
\texttt{liferay-releases}) and Liferay snapshots (i.e.,
\texttt{liferay-snapshots}). To learn how to deploy your Liferay Maven
artifacts to a Nexus repository, see the
\href{/docs/7-1/tutorials/-/knowledge_base/t/deploying-liferay-maven-artifacts-to-a-repository}{Deploying
Liferay Maven Artifacts to a Repository} tutorial.

Next, you'll configure your new repository servers in your Maven
settings to install artifacts to them.

\subsection{Configuring Local Maven
Settings}\label{configuring-local-maven-settings}

Before using your repository servers, you must specify them in your
Maven environment settings. Your repository settings let Maven find the
repository and retrieve and install artifacts. You can configure your
local Maven settings in the \texttt{{[}USER\_HOME{]}/.m2/settings.xml}
file.

You only need to configure a repository server if you're sharing
artifacts (e.g., Liferay artifacts and/or your modules) with others. If
you're automatically installing Liferay artifacts from the
Central/Liferay Repository and aren't interested in sharing artifacts,
you don't need a repository server specified in your Maven settings. You
can find out more about installing artifacts from the Central Repository
or Liferay's own Nexus repository in the
\href{/docs/7-1/tutorials/-/knowledge_base/t/installing-liferay-maven-artifacts}{Installing
Liferay Maven Artifacts} tutorial.

To configure your Maven environment to access your
\texttt{liferay-releases} and \texttt{liferay-snapshots} repository
servers, do the following:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Navigate to your \texttt{{[}USER\_HOME{]}/.m2/settings.xml} file.
  Create it if it doesn't yet exist.
\item
  Provide settings for your repository servers. Here are contents from a
  \texttt{settings.xml} file that has \texttt{liferay-releases} and
  \texttt{liferay-snapshots} repository servers configured:

\begin{verbatim}
<?xml version="1.0"?>
<settings>
    <servers>
        <server>
            <id>liferay-releases</id>
            <username>admin</username>
            <password>admin123</password>
        </server>
        <server>
            <id>liferay-snapshots</id>
            <username>admin</username>
            <password>admin123</password>
        </server>
    </servers>
</settings>
\end{verbatim}
\end{enumerate}

The user name \texttt{admin} and password \texttt{admin123} are the
credentials of the default Nexus administrator account. If you changed
these credentials for your Nexus server, make sure to update
\texttt{settings.xml} with these changes.

Now that your repositories are configured, they're ready to receive all
the Liferay Maven artifacts you'll download and the Liferay module
artifacts you'll create!

\section{Deploying Liferay Maven Artifacts to a
Repository}\label{deploying-liferay-maven-artifacts-to-a-repository}

Deploying artifacts to a remote repository is important if you intend to
share your Maven projects with others. First, you must have a remote
repository that can hold deployed Maven artifacts. If you do not
currently have a remote repository, see the
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-a-maven-repository}{Creating
a Maven Repository} tutorial to learn how you can set up a Nexus
repository. Also make sure your
\texttt{{[}USER\_HOME{]}/.m2/settings.xml} file specifies your remote
repository's ID, user name, and password.

To deploy to a remote repository, your Liferay project should be
packaged using Maven. Maven provides a packaging command that creates an
artifact (JAR) that can be easily deployed to your remote repository.
You'll learn how to do this with a Liferay portlet module.

Once you've created a deployable artifact, you'll configure your module
project to communicate with your remote repository and use Maven's
\texttt{deploy} command to send it on its way. Once your module project
resides on the remote repository, other developers can configure your
remote repository in their projects and set dependencies in their
project POMs to reference it.

To follow this tutorial, you'll need a Liferay module built with Maven.
For demonstration purposes, this tutorial uses the \texttt{portlet.ds}
sample module project. To follow along with this module, download the
\href{https://portal.liferay.dev/documents/113763090/114000186/portlet.ds.zip}{portlet.ds}
Zip.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a folder anywhere on your machine to serve as the parent folder
  for your Liferay modules. Unzip the \texttt{portlet.ds} module project
  into that folder.
\item
  Create a \texttt{pom.xml} file inside this folder. Copy the following
  logic into the parent POM:

\begin{verbatim}
<?xml version="1.0" encoding="UTF-8"?>
<project
    xmlns="http://maven.apache.org/POM/4.0.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"
>

    <modelVersion>4.0.0</modelVersion>
    <groupId>liferay.sample</groupId>
    <artifactId>liferay.sample.maven</artifactId>
    <version>1.0.0</version>
    <name>Liferay Maven Module Projects</name>
    <packaging>pom</packaging>

    <distributionManagement>
        <repository>
            <id>liferay-releases</id>
            <url>http://localhost:8081/nexus/content/repositories/liferay-releases</url>
        </repository>
    </distributionManagement>

    <modules>
        <module>portlet.ds</module>
    </modules>
</project>
\end{verbatim}

  The tags \texttt{\textless{}modelVersion\textgreater{}} through
  \texttt{\textless{}packaging\textgreater{}} are POM tags that are used
  frequently in parent POMs. Visit Maven's
  \href{https://maven.apache.org/pom.html}{POM Reference} documentation
  for more information.

  The \texttt{\textless{}distributionManagement\textgreater{}} tag
  specifies the deployment repository for all module projects residing
  in the parent folder. You should include the repository's ID and URL.
  The above \texttt{distributionManagement} declaration is configured
  for the Liferay Nexus repository created in the
  \href{/docs/7-1/tutorials/-/knowledge_base/t/creating-a-maven-repository}{Creating
  a Maven Repository} tutorial. That tutorial also created the
  \texttt{{[}USER\_HOME{]}/.m2/settings.xml}, which specified the remote
  repository's ID, user name, and password. Both the parent POM and
  \texttt{settings.xml} file's repository declarations are required to
  deploy your modules to that remote repository.

  Finally, you must list the modules residing in the parent folder that
  you want deployed using the \texttt{\textless{}modules\textgreater{}}
  tag. The \texttt{portlet.ds} module is specified within that tag.
\item
  Open the \texttt{portlet.ds} module's \texttt{pom.xml} file. If you
  did not download the \texttt{portlet.ds} module project Zip, you can
  reference its POM below.

\begin{verbatim}
<project
    xmlns="http://maven.apache.org/POM/4.0.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"
>

    <modelVersion>4.0.0</modelVersion>
    <artifactId>portlet.ds</artifactId>
    <version>1.0.0</version>
    <packaging>jar</packaging>

    <parent>
        <groupId>liferay.sample</groupId>
        <artifactId>liferay.sample.maven</artifactId>
        <version>1.0.0</version>
        <relativePath>../pom.xml</relativePath>
    </parent>

    <dependencies>
        <dependency>
            <groupId>javax.portlet</groupId>
            <artifactId>portlet-api</artifactId>
            <version>2.0</version>
            <scope>provided</scope>
        </dependency>
        <dependency>
            <groupId>org.osgi</groupId>
            <artifactId>org.osgi.service.component.annotations</artifactId>
            <version>1.3.0</version>
            <scope>provided</scope>
        </dependency>
    </dependencies>
</project>
\end{verbatim}

  The \texttt{portlet.ds} module's POM specifies its own attributes
  first, followed by the parent POM's attributes. Declaring the
  \texttt{\textless{}parent\textgreater{}} tag like above links the
  \texttt{portlet.ds} module to its parent POM, which is necessary to
  deploy to the remote repository. Then the module's dependencies are
  listed. These dependencies are downloaded from the Central Repository
  and installed to your local \texttt{.m2} repository when you package
  the \texttt{portlet.ds} module.
\item
  Now that you've configured your parent POM and module POM, package
  your Maven project. Navigate to your module project (e.g.,
  \texttt{project.ds}) using the command line and run the Maven package
  command:

\begin{verbatim}
mvn package
\end{verbatim}

  This downloads and installs all your module's dependencies and
  packages the project into a JAR file. Navigate to your module
  project's generated build folder (e.g., \texttt{/target}). You'll
  notice there is a newly generated JAR file. This is the artifact
  you'll deploy to your Nexus repository.
\item
  Run Maven's deploy command to deploy your module project's artifact to
  your configured remote repository.

\begin{verbatim}
mvn deploy
\end{verbatim}

  Your console shows output from the artifact being deployed into your
  repository server.
\end{enumerate}

To verify that your artifact is deployed, navigate to the
\emph{Repositories} page of your Nexus server and select your
repository. A window appears below showing the Liferay artifact now
deployed to your repository.

\begin{figure}
\centering
\includegraphics{./images/maven-verify-deployment.png}
\caption{Your repository server now provides access to your Liferay
Maven artifacts.}
\end{figure}

Awesome! You can now share your Liferay module projects with anyone by
deploying them as artifacts to your remote repository!

\section{Using Service Builder in a Maven
Project}\label{using-service-builder-in-a-maven-project}

Liferay's
\href{/docs/7-1/tutorials/-/knowledge_base/t/what-is-service-builder}{Service
Builder} is a model-driven service generation tool that is frequently
used by many Liferay module projects. If you have a Liferay Maven
project, you may be wondering if Service Builder works with your Maven
projects; the answer is a resounding yes!

The easiest way to add Service Builder to your Maven project is to
create a new Maven project using Liferay's provided Service Builder
archetype. You can learn how to generate a Service Builder Maven project
by visiting the
\href{/docs/7-1/reference/-/knowledge_base/r/using-the-service-builder-template}{Service
Builder Template} article. In some cases, you should not use this
template due to a number of reasons:

\begin{itemize}
\tightlist
\item
  You're updating a legacy Maven project to follow OSGi modular
  architecture.
\item
  You have a pre-existing modular Maven project and don't want to start
  over.
\end{itemize}

If you have questions about upgrading your legacy Service Builder
project, see the
\href{/docs/7-1/tutorials/-/knowledge_base/t/from-liferay-6-to-liferay-7}{From
Liferay 6 to 7} tutorial section.

Time to get started!

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Apply the Service Builder plugin in your Maven project's
  \texttt{pom.xml} file:

\begin{verbatim}
<build>
    <plugins>
        <plugin>
            <groupId>com.liferay</groupId>
            <artifactId>com.liferay.portal.tools.service.builder</artifactId>
            <version>1.0.182</version>
            <configuration>
                <apiDirName>../basic-api/src/main/java</apiDirName>
                <autoImportDefaultReferences>true</autoImportDefaultReferences>
                <autoNamespaceTables>true</autoNamespaceTables>
                <buildNumberIncrement>true</buildNumberIncrement>
                <hbmFileName>src/main/resources/META-INF/module-hbm.xml</hbmFileName>
                <implDirName>src/main/java</implDirName>
                <inputFileName>service.xml</inputFileName>
                <modelHintsFileName>src/main/resources/META-INF/portlet-model-hints.xml</modelHintsFileName>
                <mergeModelHintsConfigs>src/main/resources/META-INF/portlet-model-hints.xml</mergeModelHintsConfigs>
                <osgiModule>true</osgiModule>
                <propsUtil>com.liferay.blade.samples.servicebuilder.service.util.PropsUtil</propsUtil>
                <resourcesDirName>src/main/resources</resourcesDirName>
                <springFileName>src/main/resources/META-INF/spring/module-spring.xml</springFileName>
                <springNamespaces>beans,osgi</springNamespaces>
                <sqlDirName>src/main/resources/META-INF/sql</sqlDirName>
                <sqlFileName>tables.sql</sqlFileName>
                <testDirName>src/main/test</testDirName>
            </configuration>
        </plugin>
    </plugins>
</build>
\end{verbatim}

  Service Builder is applied by specifying its \texttt{groupId},
  \texttt{artifactId}, and \texttt{version}. The \texttt{configuration}
  tag used above is an example of what a Service Builder project's
  configuration could look like. All the configuration attributes above
  should be modified to fit your project.

  The above code configures Service Builder for a sample
  \texttt{basic-service} module. When running Service Builder with this
  configuration, the project's API classes are generated in the
  \texttt{basic-api} module's \texttt{src/main/java} folder. You can
  also specify your hibernate module mappings, implementation directory
  name, model hints file, Spring configurations, SQL configurations,
  etc. You can reference all the configurable Service Builder properties
  in the
  \href{/docs/7-1/reference/-/knowledge_base/r/service-builder-with-maven}{Service
  Builder Plugin} reference article. Also, visit the
  \href{/docs/7-1/tutorials/-/knowledge_base/t/defining-an-object-relational-map-with-service-builder}{Defining
  an Object-Relational Map with Service Builder} tutorial for more
  information on defining a \texttt{service.xml} file to configure
  Service Builder.
\item
  Apply the WSDD Builder plugin declaration directly after the Service
  Builder plugin declaration:

\begin{verbatim}
<plugin>
    <groupId>com.liferay</groupId>
    <artifactId>com.liferay.portal.tools.wsdd.builder</artifactId>
    <version>1.0.3</version>
    <configuration>
        <inputFileName>service.xml</inputFileName>
        <outputDirName>src/main/java</outputDirName>
        <serverConfigFileName>src/main/resources/server-config.wsdd</serverConfigFileName>
    </configuration>
</plugin>
\end{verbatim}

  The WSDD Builder is necessary to generate your project's remote
  services. Visit the
  \href{/docs/7-1/tutorials/-/knowledge_base/t/creating-remote-services}{Creating
  Remote Services} tutorial for more information on WSDD (Web Service
  Deployment Descriptor). Similar to the Service Builder configuration,
  the \texttt{service.xml} file is set to define your project's remote
  services. Also, the \texttt{outputDirName} defines where the
  \texttt{*\_deploy.wsdd} and \texttt{*\_undeploy.wsdd} files are
  generated. Make sure to define your
  \href{http://axis.apache.org/axis/java/reference.html\#Global_Axis_Configuration}{\texttt{server-config.wsdd}
  file}, as well.
\end{enumerate}

Terrific! You've successfully configured your Maven project to use
Service Builder by applying the
\texttt{com.liferay.portal.tools.service.builder} and
\texttt{com.liferay.portal.tools.wsdd.builder} plugins in your project's
POM. To run Service Builder, see the
\href{/docs/7-1/tutorials/-/knowledge_base/t/running-service-builder}{Running
Service Builder and Understanding the Generated Code} tutorial for
instructions.

\section{Compiling Sass Files in a Maven
Project}\label{compiling-sass-files-in-a-maven-project}

If your Liferay Maven project uses Sass files to style its UI, you must
configure the project to convert its Sass files into CSS files so they
are recognizable for Maven's build lifecycle. It would be a real pain to
convert your Sass files into CSS files manually before building your
Maven project!

Liferay provides the \texttt{com.liferay.css.builder} plugin. The
\href{/docs/7-1/reference/-/knowledge_base/r/css-builder-plugin}{CSS
Builder} converts Sass files into CSS files so the Maven build can parse
your style sheets.

Here's how to apply Liferay's CSS builder to your Maven project.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open your project's \texttt{pom.xml} file and apply Liferay's CSS
  Builder:

\begin{verbatim}
<plugin>
    <groupId>com.liferay</groupId>
    <artifactId>com.liferay.css.builder</artifactId>
    <version>2.1.0</version>
    <executions>
        <execution>
            <id>default-build</id>
            <phase>compile</phase>
            <goals>
                <goal>build</goal>
            </goals>
        </execution>
    </executions>
    <configuration>
        <docrootDirName>${com.liferay.portal.tools.theme.builder.outputDir}</docrootDirName>
        <outputDirName>/</outputDirName>
        <portalCommonPath>target/deps/com.liferay.frontend.css.common.jar</portalCommonPath>
    </configuration>
</plugin>
\end{verbatim}

  The above configuration applies the CSS Builder by specifying its
  \texttt{groupId}, \texttt{artifactId}, and \texttt{version}. It then
  defines the CSS Builder's execution and configuration.

  \begin{itemize}
  \tightlist
  \item
    The
    \href{https://maven.apache.org/guides/mini/guide-configuring-plugins.html\#Using_the_executions_Tag}{executions}
    tag configures the CSS Builder to run during the \texttt{compile}
    phase of your Maven project's build lifecycle. The \texttt{build}
    \href{http://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html\#A_Build_Phase_is_Made_Up_of_Plugin_Goals}{goal}
    is defined for that lifecycle phase.
  \item
    The \href{https://maven.apache.org/pom.html\#Plugins}{configuration}
    tag defines two important properties:

    \begin{itemize}
    \tightlist
    \item
      \texttt{docrootDirName}: The base \texttt{resources} folder
      containing the Sass files to compile.
    \item
      \texttt{outputDirName}: The name of the sub-directories where the
      SCSS files are compiled to.
    \item
      \texttt{portalCommonPath}: The file path for the
      \href{https://mvnrepository.com/artifact/com.liferay/com.liferay.frontend.css.common}{Liferay
      Frontend Common CSS JAR} file.
    \end{itemize}
  \end{itemize}
\item
  If you're using \href{http://bourbon.io/}{Bourbon} in your Sass files,
  you'll need to
  \href{/docs/7-1/tutorials/-/knowledge_base/t/configuring-dependencies}{add
  an additional plugin dependency} to your project's POM. If you're not
  using Bourbon, skip this step. Add the following plugin dependency:

\begin{verbatim}
<plugin>
    <artifactId>maven-dependency-plugin</artifactId>
    <executions>
        <execution>
            <phase>generate-sources</phase>
            <goals>
                <goal>copy</goal>
            </goals>
            <configuration>
                <artifactItems>
                    <artifactItem>
                        <groupId>com.liferay</groupId>
                        <artifactId>com.liferay.frontend.css.common</artifactId>
                        <version>2.0.4</version>
                    </artifactItem>
                </artifactItems>
                <outputDirectory>${project.build.directory}/deps</outputDirectory>
                <stripVersion>true</stripVersion>
            </configuration>
        </execution>
    </executions>
</plugin>
\end{verbatim}

  The
  \href{http://maven.apache.org/plugins/maven-dependency-plugin/}{maven-dependency-plugin}
  copies the \texttt{com.liferay.frontend.css.common} dependency from
  Maven Central to your project's build folder so the CSS Builder can
  leverage it.
\item
  Use this command to compile your Maven project's Sass files:

\begin{verbatim}
mvn compile
\end{verbatim}
\end{enumerate}

\noindent\hrulefill

\textbf{Note:} Liferay's CSS Builder is supported for Oracle's JDK and
uses a native compiler for increased speed. If you're using an IBM JDK,
you may experience issues when building your Sass files (e.g., when
building a theme). It's recommended to switch to using the Oracle JDK,
but if you prefer using the IBM JDK, you must use the fallback Ruby
compiler. To do this, add the following tag to your CSS Builder
configuration in your POM:

\begin{verbatim}
 <sassCompilerClassName>ruby</sasscompilerClassName>
\end{verbatim}

Be aware that the Ruby-based compiler doesn't perform as well as the
native compiler, so expect longer compile times.

\noindent\hrulefill

Awesome! You can now compile Sass files in your Liferay Maven project.

\section{Building Themes in a Maven
Project}\label{building-themes-in-a-maven-project}

Liferay's Theme Builder is a tool used to build Liferay DXP theme files
in your project. You can incorporate the Theme Builder into your Maven
project to generate WAR-style themes deployable to Liferay DXP. To learn
more about theming in Liferay DXP, see the
\href{/docs/7-1/tutorials/-/knowledge_base/t/themes-and-layout-templates}{Themes
and Layout Templates} tutorial section.

The easiest way to create a Liferay theme with Maven is to create a new
Maven project using Liferay's provided
\href{/docs/7-1/reference/-/knowledge_base/r/theme-template}{Theme
archetype}. You can learn how to generate a Maven Theme project by
visiting the
\href{/docs/7-1/tutorials/-/knowledge_base/t/generating-new-projects-using-archetypes}{Generating
New Projects Using Archetypes} tutorial. In some cases, however, this
may not be convenient. For instance, if you have a legacy theme project
and don't want to start over, generating a new project is not ideal.

For cases like this, you should manually configure your Maven project to
build a theme. You'll learn how to do this next.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Configure Liferay's
  \href{/docs/7-1/reference/-/knowledge_base/r/theme-builder-plugin}{Theme
  Builder} plugin in your project's \texttt{pom.xml} file:

\begin{verbatim}
<build>
    <plugins>
        <plugin>
            <groupId>com.liferay</groupId>
            <artifactId>com.liferay.portal.tools.theme.builder</artifactId>
            <version>1.1.4</version>
            <executions>
                <execution>
                    <phase>generate-resources</phase>
                    <goals>
                        <goal>build</goal>
                    </goals>
                    <configuration>
                        <diffsDir>${maven.war.src}</diffsDir>
                        <name>${project.artifactId}</name>
                        <outputDir>${project.build.directory}/${project.build.finalName}</outputDir>
                        <parentDir>${project.build.directory}/deps/com.liferay.frontend.theme.styled.jar</parentDir>
                        <parentName>_styled</parentName>
                        <templateExtension>ftl</templateExtension>
                        <unstyledDir>${project.build.directory}/deps/com.liferay.frontend.theme.unstyled.jar</unstyledDir>
                    </configuration>
                </execution>
            </executions>
        </plugin>
    </plugins>
</build>
\end{verbatim}

  The above configuration applies the Theme Builder by specifying its
  \texttt{groupId}, \texttt{artifactId}, and \texttt{version}. It then
  defines the Theme Builder's execution and configuration.

  \begin{itemize}
  \tightlist
  \item
    The
    \href{https://maven.apache.org/guides/mini/guide-configuring-plugins.html\#Using_the_executions_Tag}{executions}
    tag configures the Theme Builder to run during the
    \texttt{generate-resources} phase of your Maven project's build
    lifecycle. The \texttt{build}
    \href{http://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html\#A_Build_Phase_is_Made_Up_of_Plugin_Goals}{goal}
    is defined for that lifecycle phase.
  \item
    The \href{https://maven.apache.org/pom.html\#Plugins}{configuration}
    defines tag several important properties:

    \begin{itemize}
    \tightlist
    \item
      \texttt{diffsDir}: The folder holding the files to copy over the
      parent theme.
    \item
      \texttt{name}: The new theme's name.
    \item
      \texttt{outputDir}: The folder to build the theme.
    \item
      \texttt{parentDir}: The parent theme's folder.
    \item
      \texttt{parentName}: The parent theme's name.
    \item
      \texttt{templateExtension}: The extension of the template files
      (e.g., \texttt{ftl} or \texttt{vm}).
    \item
      \texttt{unstyledDir}: The unstyled theme's folder.
    \end{itemize}
  \end{itemize}
\item
  Apply the CSS Builder plugin, which is required to use the Theme
  Builder:

\begin{verbatim}
<plugin>
    <groupId>com.liferay</groupId>
    <artifactId>com.liferay.css.builder</artifactId>
    <version>2.1.0</version>
    <executions>
        <execution>
            <id>default-build</id>
            <phase>compile</phase>
            <goals>
                <goal>build</goal>
            </goals>
        </execution>
    </executions>
    <configuration>
        <docrootDirName>target/${project.build.finalName}</docrootDirName>
        <outputDirName>/</outputDirName>
        <portalCommonPath>target/deps/com.liferay.frontend.css.common.jar</portalCommonPath>
    </configuration>
</plugin>
\end{verbatim}

  You can learn more about the CSS Builder's Maven configuration by
  visiting the
  \href{/docs/7-1/tutorials/-/knowledge_base/t/compiling-sass-files-in-a-maven-project}{Compiling
  Sass Files in a Maven Project} tutorial.
\item
  You can configure your project to exclude Sass files from being
  packaged in your theme. This is optional, but is a nice convenience to
  keep any unnecessary source code out of your WAR. Since the Theme
  Builder creates a WAR-style theme, you should apply the
  \href{https://maven.apache.org/plugins/maven-war-plugin/}{maven-war-plugin}
  so it instructs the WAR file packaging process to exclude Sass files:

\begin{verbatim}
<plugin>
    <artifactId>maven-war-plugin</artifactId>
    <version>3.0.0</version>
    <configuration>
        <packagingExcludes>**/*.scss</packagingExcludes>
    </configuration>
</plugin>
\end{verbatim}
\item
  Insert the \texttt{\textless{}packaging\textgreater{}} tag in your
  project's POM so your project is correctly packaged as a WAR file.
  This tag can be placed with your project's \texttt{groupId},
  \texttt{artifactId}, and \texttt{version} specifications like this:

\begin{verbatim}
<groupId>com.liferay</groupId>
<artifactId>com.liferay.project.templates.theme</artifactId>
<version>1.0.0</version>
<packaging>war</packaging>
\end{verbatim}
\item
  Building themes requires certain dependencies. You can
  \href{/docs/7-1/tutorials/-/knowledge_base/t/configuring-dependencies}{configure
  these dependenices} in your project's \texttt{pom.xml} as directories
  or JAR files. If you choose to use JARs, you must apply the
  \href{http://maven.apache.org/plugins/maven-dependency-plugin/}{maven-dependency-plugin}
  and have it copy JAR dependencies into your project from Maven
  Central:

\begin{verbatim}
<plugin>
    <artifactId>maven-dependency-plugin</artifactId>
    <executions>
        <execution>
            <phase>generate-sources</phase>
            <goals>
                <goal>copy</goal>
            </goals>
            <configuration>
                <artifactItems>
                    <artifactItem>
                        <groupId>com.liferay</groupId>
                        <artifactId>com.liferay.frontend.css.common</artifactId>
                        <version>${com.liferay.frontend.css.common.version}</version>
                    </artifactItem>
                    <artifactItem>
                        <groupId>com.liferay</groupId>
                        <artifactId>com.liferay.frontend.theme.styled</artifactId>
                        <version>${com.liferay.frontend.theme.styled.version}</version>
                    </artifactItem>
                    <artifactItem>
                        <groupId>com.liferay</groupId>
                        <artifactId>com.liferay.frontend.theme.unstyled</artifactId>
                        <version>${com.liferay.frontend.theme.unstyled.version}</version>
                    </artifactItem>
                </artifactItems>
                <outputDirectory>${project.build.directory}/deps</outputDirectory>
                <stripVersion>true</stripVersion>
            </configuration>
        </execution>
    </executions>
</plugin>
\end{verbatim}

  This configuration copies the
  \texttt{com.liferay.frontend.css.common},
  \texttt{com.liferay.frontend.theme.styled}, and
  \texttt{com.liferay.frontend.theme.unstyled} dependencies into your
  Maven project. Notice that you've set the \texttt{stripVersion} tag to
  \texttt{true} and you're setting the artifact versions within each
  \texttt{artifactItem} tag. You'll set these versions and a few other
  properties for your Maven project next.
\item
  Configure the properties for your project in its \texttt{pom.xml}
  file:

\begin{verbatim}
<properties>
    <com.liferay.css.builder.version>2.0.1</com.liferay.css.builder.version>
    <com.liferay.frontend.css.common.version>2.0.4</com.liferay.frontend.css.common.version>
    <com.liferay.frontend.theme.styled.version>2.0.28</com.liferay.frontend.theme.styled.version>
    <com.liferay.frontend.theme.unstyled.version>2.2.5</com.liferay.frontend.theme.unstyled.version>
    <com.liferay.portal.tools.theme.builder.version>1.1.4</com.liferay.portal.tools.theme.builder.version>
</properties>
\end{verbatim}

  The properties above set the versions for the CSS and Theme Builder
  plugins and their dependencies.
\end{enumerate}

You've successfully configured your Maven project to build a Liferay
theme! For info on running the Theme Builder in your Maven project, see
the
\href{/docs/7-1/tutorials/-/knowledge_base/t/compiling-and-building-themes-with-ant-gradle-and-maven}{Theme
Builder} tutorial.

\section{Maven Workspace}\label{maven-workspace}

A Liferay Maven Workspace is a generated environment that is built to
hold and manage Liferay projects built with Maven. This workspace aids
in Liferay project management by applying various Maven plugins and
configured properties. The Liferay Maven Workspace offers a full
development lifecycle for your Maven projects to make developing them
for Liferay DXP easier than ever. In this tutorial, you'll learn how to
leverage the development lifecycle of a Liferay Maven Workspace.

First, you'll learn how to install a Maven Workspace.

\subsection{Installation}\label{installation}

The Maven Workspace is installed by generating the workspace project
from either an archetype or via
\href{/docs/7-1/tutorials/-/knowledge_base/t/blade-cli}{Blade CLI}. You
can generate a workspace via archetype by executing the following
command:

\begin{verbatim}
mvn archetype:generate \
    -DarchetypeGroupId=com.liferay \
    -DarchetypeArtifactId=com.liferay.project.templates.workspace \
    -DgroupId=[GROUP_ID] \
    -DartifactId=[WORKSPACE_NAME] \
    -Dversion=[VERSION]
\end{verbatim}

If you have Blade CLI installed, and want to use that instead of
generating an archetype, you can run the following command:

\begin{verbatim}
blade init -b maven [WORKSPACE_NAME]
\end{verbatim}

A Maven Workspace is generated in the current folder. No other tools or
CLIs are required for Maven Workspace.

\subsection{Anatomy}\label{anatomy}

The default Maven Workspace contains the following folders/files:

\begin{itemize}
\tightlist
\item
  \texttt{{[}MAVEN\_WORKSPACE{]}}

  \begin{itemize}
  \tightlist
  \item
    \texttt{configs}

    \begin{itemize}
    \tightlist
    \item
      \texttt{common}
    \item
      \texttt{dev}
    \item
      \texttt{local}
    \item
      \texttt{prod}
    \item
      \texttt{uat}
    \end{itemize}
  \item
    \texttt{modules}

    \begin{itemize}
    \tightlist
    \item
      \texttt{pom.xml}
    \end{itemize}
  \item
    \texttt{themes}

    \begin{itemize}
    \tightlist
    \item
      \texttt{pom.xml}
    \end{itemize}
  \item
    \texttt{wars}

    \begin{itemize}
    \tightlist
    \item
      \texttt{pom.xml}
    \end{itemize}
  \item
    \texttt{pom.xml}
  \end{itemize}
\end{itemize}

For more information on the \texttt{configs} folder, see the
\href{/docs/7-1/tutorials/-/knowledge_base/t/development-lifecycle-for-a-liferay-workspace\#testing-projects}{Testing
Modules} section. The \texttt{modules}, \texttt{themes}, and
\texttt{wars} folders hold projects of that type. The parent
\texttt{pom.xml} configures your workspace as a Maven project and
applies the
\href{/docs/7-1/reference/-/knowledge_base/r/bundle-support-plugin}{Bundle
Support plugin}, which is required for your Maven Workspace to handle
7.0 projects. You can also
\hyperref[configuring-maven-workspace-properties]{configure workspace
properties} in your POM, which you'll learn about later.

Next, you'll learn how to initialize and package Liferay DXP bundles
using workspace.

\subsection{Adding a Liferay Bundle to a Maven
Workspace}\label{adding-a-liferay-bundle-to-a-maven-workspace}

Liferay Maven Workspaces can generate and hold a Liferay Server. This
lets you build/test your plugins against a running Liferay instance.
Before generating a Liferay instance, open the \texttt{pom.xml} file
located in your workspace's root folder and set the version of the
Liferay bundle to generate and install by setting the download URL for
the \texttt{liferay.workspace.bundle.url} property. For example,

\begin{verbatim}
<properties>
    <liferay.workspace.bundle.url>
        https://releases-cdn.liferay.com/portal/7.1.0-ga1/liferay-ce-portal-tomcat-7.1.0-ga1-20180703012531655.zip
    </liferay.workspace.bundle.url>
    ...
</properties>
\end{verbatim}

You can also set location of your Liferay bundle with the
\texttt{liferay.workspace.home.dir} property. It's set to
\texttt{bundles} by default.

\textbf{Important:} Make sure the
\texttt{com.liferay.portal.tools.bundle.support} plugin in your POM is
configured to use version \texttt{3.2.0+}. The
\texttt{liferay.workspace.bundle.url} property does not work for
workspaces using an older version of the Bundle Support plugin. See the
\hyperref[updating-a-maven-workspace]{Updating a Maven Workspace}
section for instructions on how to update the plugin.

Once you've finalized your workspace properties, navigate to your
workspace's root folder and run

\begin{verbatim}
blade server init
\end{verbatim}

This uses workspace's pre-bundled
\href{/docs/7-1/tutorials/-/knowledge_base/t/blade-cli}{Blade CLI} tool
to download the version of Liferay DXP you specified in your POM file
and installs your Liferay DXP instance in the \texttt{bundles} folder.
If you prefer to not use Blade CLI or do not have it installed, the pure
Maven equivalent for this command is \texttt{mvn\ bundle-support:init}.

If you want to skip the downloading process, you can create the
\texttt{bundles} folder manually in your workspace's ROOT folder and
extract your Liferay Portal bundle to that folder.

You can also produce a distributable Liferay DXP bundle (Zip) from
within a workspace. To do this, navigate to your workspace's root folder
and run the following command:

\begin{verbatim}
mvn bundle-support:dist
\end{verbatim}

Your distribution file is available from the workspace's
\texttt{/target} folder.

\subsection{Configuring Maven Workspace
Properties}\label{configuring-maven-workspace-properties}

There are some configurable workspace properties you can set in the root
\texttt{pom.xml} file:

\begin{itemize}
\tightlist
\item
  \texttt{liferay.workspace.bundle.url}: the URL used to download the
  Liferay DXP bundle. For more information, see
  \hyperref[adding-a-liferay-bundle-to-a-maven-workspace]{Adding a
  Liferay Bundle to a Maven Workspace}.
\item
  \texttt{liferay.workspace.environment}: the name of a \texttt{configs}
  subfolder holding the Liferay DXP server configuration to use. See
  \href{/docs/7-1/tutorials/-/knowledge_base/t/development-lifecycle-for-a-liferay-workspace\#testing-projects}{Testing
  Modules} for more information.
\end{itemize}

Properties can be set by adding tags with the property name. See the
property configurations below for an example on how these can be set in
your POM:

\begin{verbatim}
<properties>
    <liferay.workspace.bundle.url>https://releases-cdn.liferay.com/portal/7.1.0-ga1/liferay-ce-portal-tomcat-7.1.0-ga1-20180703012531655.zip</liferay.workspace.bundle.url>
    <liferay.workspace.environment>local</liferay.workspace.environment>
</properties>
\end{verbatim}

Next, you'll learn how to add and deploy modules/projects in your Maven
Workspace.

\subsection{Module Management}\label{module-management}

Maven Workspace makes managing your Maven project easier than ever. To
create a project, navigate to the appropriate workspace folder for that
type of project (e.g., \texttt{modules}, \texttt{wars}, etc.). Then
generate the project archetype. You can view a full listing of the
available archetypes in the
\href{/docs/7-1/reference/-/knowledge_base/r/project-templates}{Project
Templates} reference section. Once the project is generated, it can
leverage all of Maven Workspace's functionality.

Maven Workspace also lets you deploy your projects to Liferay DXP using
Maven. See the
\href{/docs/7-1/tutorials/-/knowledge_base/t/deploying-a-project-built-with-maven-to-product}{Deploying
a Project Built with Maven to Liferay DXP} tutorial for more
information.

Want to leverage Maven Workspace's testing infrastructure so you can
simulate your Maven projects in a specific environment? See the
\href{/docs/7-1/tutorials/-/knowledge_base/t/development-lifecycle-for-a-liferay-workspace\#testing-projects}{Testing
Modules} section for more information.

Once you have your Maven projects solidified and ready for the
limelight, it'd be great to release your projects to the public. Maven
Workspace doesn't provide this functionality, but there are easy ways to
use external release tools with workspace. See the
\href{/docs/7-1/tutorials/-/knowledge_base/t/development-lifecycle-for-a-liferay-workspace\#releasing-projects}{Releasing
Modules} section for more information.

Next, you'll learn how to update a Maven Workspace.

\subsection{Updating a Maven
Workspace}\label{updating-a-maven-workspace}

Liferay Workspace is updated periodically with new features, so you'll
want to update your workspace instance accordingly. To update your Maven
Workspace, you must update the Bundle Support plugin configured in your
workspace's root \texttt{pom.xml} file:

\begin{verbatim}
<plugin>
    <groupId>com.liferay</groupId>
    <artifactId>com.liferay.portal.tools.bundle.support</artifactId>
    <version>3.2.5</version>
    ...
</plugin>
\end{verbatim}

Update the version to the latest available release. You can reference
the available releases for the Bundle Support plugin
\href{https://repository.liferay.com/nexus/content/repositories/liferay-public-releases/com/liferay/com.liferay.portal.tools.bundle.support/}{here}.

\chapter{IntelliJ IDEA}\label{intellij-idea}

The
\href{https://plugins.jetbrains.com/plugin/10739-liferay-intellij-plugin}{Liferay
IntelliJ plugin} provides support for Liferay DXP development in
\href{https://www.jetbrains.com/idea/}{IntelliJ IDEA}. Liferay's
IntelliJ plugin provides the following built-in features:

\begin{itemize}
\tightlist
\item
  Creating a Liferay Workspace (Gradle and Maven based)
\item
  Creating Liferay projects (Gradle and Maven based)
\item
  Liferay DXP Tomcat server support for project deployment and debugging
\item
  Support for adding line markers for each entity in the service editor
\item
  Syntax checking, highlighting, and code completion (e.g., Bnd and XML
  files)
\end{itemize}

In these tutorials, you'll learn how to install the Liferay IntelliJ
plugin and leverage its features to improve Liferay development with
IntelliJ IDEA.

\section{Installing the Liferay IntelliJ
Plugin}\label{installing-the-liferay-intellij-plugin}

There are two ways to install the IntelliJ plugin for IDEA:

\begin{itemize}
\tightlist
\item
  \hyperref[installing-via-intellij-marketplace]{via IntelliJ
  Marketplace}
\item
  \hyperref[installing-via-zip-file]{via Zip file}
\end{itemize}

Follow the steps pertaining to your preferred installation process.

\subsection{Installing Via IntelliJ
Marketplace}\label{installing-via-intellij-marketplace}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In IntelliJ, navigate to \emph{File} → \emph{Settings} →
  \emph{Plugins}.
\item
  In the Marketplace tab, search for \emph{Liferay} in the provided
  search bar.
\item
  Click \emph{Install} next to the Liferay IntelliJ Plugin.

  \begin{figure}
  \centering
  \includegraphics{./images/intellij-marketplace-installation.png}
  \caption{IntelliJ Marketplace offers a streamlined way to install
  plugins.}
  \end{figure}
\item
  After the plugin has downloaded, select \emph{Restart IDE}.
\end{enumerate}

Once IntelliJ restarts, the Liferay IntelliJ plugin is installed and
ready for use.

\subsection{Installing Via Zip File}\label{installing-via-zip-file}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Navigate to the
  \href{https://plugins.jetbrains.com/plugin/10739-liferay-intellij-plugin}{JetBrains'
  Liferay IntelliJ plugin} page and download it to your local machine.
\item
  In IntelliJ, navigate to \emph{File} → \emph{Settings} →
  \emph{Plugins}.
\item
  Click the gear icon from the top menu and select \emph{Install Plugin
  from Disk\ldots{}}.
\item
  Navigate to the Installed tab in the top menu and select \emph{Restart
  IDE}.
\end{enumerate}

Once IntelliJ restarts, the Liferay IntelliJ plugin is installed and
ready for use.

Great job! You're now ready to develop for Liferay DXP in IntelliJ!

\section{Creating a Liferay Workspace with IntelliJ
IDEA}\label{creating-a-liferay-workspace-with-intellij-idea}

In this tutorial, you'll learn how to generate a Liferay Workspace using
IntelliJ IDEA, which runs on
\href{/docs/7-1/tutorials/-/knowledge_base/t/blade-cli}{Blade CLI}
behind the scenes. IntelliJ gives you a graphical interface instead of
the command prompt, which can streamline your workflow. You'll also
learn how to import an existing Liferay Workspace into IntelliJ. To
learn more about Liferay Workspaces, visit its dedicated
\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-workspace}{tutorial
section}.

\subsection{Creating a Liferay
Workspace}\label{creating-a-liferay-workspace-1}

Follow the steps below to create a Liferay Workspace:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open the New Project wizard by selecting \emph{File} → \emph{New} →
  \emph{Project}. If you're starting IntelliJ for the first time, you
  can do this by selecting \emph{Create New Project} in the opening
  window.
\item
  Select \emph{Liferay} from the left menu.
\item
  Choose the build type for your workspace (i.e., Gradle or Maven). Then
  click \emph{Next}.

  \begin{figure}
  \centering
  \includegraphics{./images/intellij-workspace-build.png}
  \caption{Choose \emph{Liferay Gradle Workspace} or \emph{Liferay Maven
  Workspace}, depending on the build you prefer.}
  \end{figure}
\item
  Specify your workspace's name, location, intended Liferay DXP version,
  \href{/docs/7-1/tutorials/-/knowledge_base/t/managing-the-target-platform-for-liferay-workspace}{target
  platform}, and SDK (i.e., Java JDK). Then click \emph{Finish}.

  \begin{figure}
  \centering
  \includegraphics{./images/intellij-workspace-project.png}
  \caption{Specify your workspace's configurations.}
  \end{figure}
\item
  A window opens for additional build configurations for the build type
  you selected (i.e., Gradle or Maven). Verify the settings and click
  \emph{OK}.
\end{enumerate}

Awesome! You've successfully created a Liferay Workspace in IntelliJ
IDEA!

\subsection{Importing a Liferay
Workspace}\label{importing-a-liferay-workspace}

To import an existing workspace into IntelliJ, follow the steps below:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Select \emph{File} → \emph{New} → \emph{Project from Existing
  Sources\ldots{}}.
\item
  Select the workspace you want to import. Then click \emph{OK}.

  \begin{figure}
  \centering
  \includegraphics{./images/intellij-import-workspace.png}
  \caption{Specify your workspace's configurations.}
  \end{figure}
\item
  Click the \emph{Import project from external model} radio button and
  select the build tool your workspace uses (e.g., Gradle or Maven).
\item
  Configure the project import (if necessary) and then click
  \emph{Finish}. See the
  \href{https://www.jetbrains.com/help/idea/creating-and-managing-projects.html\#importing-project}{Import
  a Project} section of IntelliJ's official documentation for more
  information.
\item
  Step through the remaining import prompts and then open your imported
  workspace as you desire (i.e., in the current window or a new window).
\end{enumerate}

Excellent! Your existing Liferay Workspace is now imported in IntelliJ
IDEA!

\section{Creating Projects with IntelliJ
IDEA}\label{creating-projects-with-intellij-idea}

IntelliJ IDEA provides a New Liferay Modules wizard to create a variety
of different module projects. You can also use the same wizard to create
theme projects, WAR-style projects, and more. Before beginning, ensure
you've
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-a-liferay-workspace-with-intellij-idea}{created/imported
a Liferay Workspace} in your IntelliJ environment. Follow the steps
below to create a Liferay DXP module:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Navigate to \emph{File} → \emph{New} → \emph{Liferay Module}.

  \begin{figure}
  \centering
  \includegraphics{./images/intellij-new-liferay-module.png}
  \caption{Selecting \emph{Liferay Module} opens the New Liferay Modules
  wizard.}
  \end{figure}
\item
  Select the project you want to create. Although the wizard
  characterizes itself for \emph{modules}, there are many available
  projects that are not OSGi-based modules (e.g., \texttt{theme},
  \texttt{war-mvc-portlet}, etc.). See the
  \href{/docs/7-1/reference/-/knowledge_base/r/project-templates}{Project
  Templates} reference section for more information on the available
  templates.

  \begin{figure}
  \centering
  \includegraphics{./images/intellij-modules.png}
  \caption{Choose the project template to create your module.}
  \end{figure}
\item
  Configure your project's SDK (i.e., JDK), package name, class name,
  and service name, if necessary. Then click \emph{Next}.
\item
  Give your project a name. Then click \emph{Finish}.
\end{enumerate}

Awesome! Your project is available under its project type folder in your
workspace.

\section{Installing a Server in IntelliJ
IDEA}\label{installing-a-server-in-intellij-idea}

Installing a Liferay server in IntelliJ is easy. In just a few steps,
you'll have your server up and running.

\noindent\hrulefill

\textbf{Note:} Tomcat and Wildfly are the only supported Liferay app
server bundles available to install in IntelliJ.

\noindent\hrulefill

Follow these steps to install your server:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Right-click your Liferay workspace and select \emph{Liferay} →
  \emph{InitBundle}.

  This downloads the Liferay DXP bundle specified in your workspace's
  \texttt{gradle.properties} file. You can change the default bundle by
  updating the \texttt{liferay.workspace.bundle.url} property. For
  example, this is required to update the default bundle version and/or
  type (e.g., Wildfly). The downloaded bundle is stored in the
  workspace's \texttt{bundles} folder.
\item
  Navigate to the top right Configurations dropdown menu and select
  \emph{Edit Configurations}. From here, you can configure your server's
  run and debug configurations.

  \begin{figure}
  \centering
  \includegraphics{./images/intellij-server-dropdown.png}
  \caption{You have several options to choose from the server dropdown
  menu.}
  \end{figure}
\item
  Click the \emph{Add New Configuration} button
  (\includegraphics{./images/icon-intellij-add-config.png}) and select
  \emph{Liferay Server}.
\item
  Give your server a better name and modify any other configurations, if
  necessary. Then select \emph{OK} .

  \begin{figure}
  \centering
  \includegraphics{./images/intellij-run-debug-wizard.png}
  \caption{Set your Liferay server's configurations in the Run/Debug
  Configurations menu.}
  \end{figure}
\end{enumerate}

Your server is now available in IntelliJ! Make sure to select it in the
Configurations dropdown before executing the configuration buttons
(below).

For reference, here's how the IntelliJ configuration buttons work with
your Liferay DXP instance:

\begin{itemize}
\tightlist
\item
  \emph{Start}
  (\includegraphics{./images/icon-intellij-start-server.png}): Starts
  the server.
\item
  \emph{Stop}
  (\includegraphics{./images/icon-intellij-stop-server.png}): Stops the
  server.
\item
  \emph{Debug}
  (\includegraphics{./images/icon-intellij-debug-server.png}): Starts
  the server in debug mode. For more information on debugging in
  IntelliJ, see the
  \href{https://www.jetbrains.com/help/idea/debugging-code.html}{IntelliJ
  Debugging} article.
\end{itemize}

Now you're ready to use your server in IntelliJ!

\section{Deploying Projects with IntelliJ
IDEA}\label{deploying-projects-with-intellij-idea}

Once you've
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-projects-with-intellij-idea}{created
a project} and
\href{/docs/7-1/tutorials/-/knowledge_base/t/installing-a-server-in-intellij-idea}{installed
your Liferay server} in IntelliJ, you'll want to deploy your project.
Follow the steps below to do this:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Right-click your project from within the Liferay Workspace folder
  structure and select \emph{Liferay} → \emph{Deploy}.

  This automatically loads a build progress window viewable at the
  bottom of your IntelliJ instance.

  \begin{figure}
  \centering
  \includegraphics{./images/intellij-project-build.png}
  \caption{Verify that your project build successfully.}
  \end{figure}
\item
  Verify that your project builds successfully from the build progress
  window. Then navigate back to your server's window and confirm it
  starts in your configured Liferay DXP instance. You should receive a
  message like this:

\begin{verbatim}
INFO  [fileinstall-C:/liferay-workspace/bundles/osgi/modules][BundleStartStopLogger:35] STARTED com.liferay.docs_1.0.0 [652]
\end{verbatim}
\end{enumerate}

The \texttt{watch} Blade CLI task deploys your project. This watches
your local project and propagates saved changes to the deployed project.
With this, project updates are viewable almost instantaneously from your
Liferay server. For more info on the \texttt{watch} task, see the
\href{/docs/7-1/tutorials/-/knowledge_base/t/deploying-projects-with-blade-cli}{Deploying
Projects with Blade CLI} article.

That's it! You've successfully deployed your project to Liferay DXP!

\chapter{Liferay Sample Projects}\label{liferay-sample-projects}

Liferay provides working examples of sample projects that target
different integration points in Liferay DXP. These working examples can
be copy/pasted into your own independent project so you can take
advantage of various Liferay extension points. Each sample is a
standalone project and includes its own build files. Liferay's sample
projects can be found in the
\href{https://github.com/liferay/liferay-blade-samples}{liferay-blade-samples}
repository on GitHub. You can find documentation for Liferay's sample
projects in the
\href{/docs/7-1/reference/-/knowledge_base/r/sample-projects}{Sample
Projects} reference section.

If you'd like to browse the repository locally or copy sample projects
into your own project,
\href{https://help.github.com/articles/fork-a-repo/}{fork} and
\href{https://help.github.com/articles/cloning-a-repository/}{clone} the
\texttt{liferay-blade-samples} repository.

You can also use
\href{/docs/7-1/tutorials/-/knowledge_base/t/blade-cli}{Blade CLI} to
create samples by running this command:

\begin{verbatim}
blade samples [SAMPLE_NAME]
\end{verbatim}

For example, the following command generates the
\href{https://github.com/liferay/liferay-blade-samples/tree/7.1/gradle/apps/ds-portlet}{ds-portlet}
sample:

\begin{verbatim}
blade samples ds-portlet
\end{verbatim}

At first glance, you'll notice that the repository is broken up into
three primary folders:

\begin{itemize}
\tightlist
\item
  \texttt{gradle}
\item
  \texttt{liferay-workspace}
\item
  \texttt{maven}
\end{itemize}

The provided sample projects are organized by their development
toolchains to cater to a variety of developers. Each folder offers the
same set of sample Liferay projects. Their only difference is that the
build files are specific to their toolchain. For example, the
\texttt{gradle} folder contains projects using standard OSS Gradle
plugins that can be added to any Gradle composite build. The same
concept also applies to the \texttt{liferay-workspace} and
\texttt{maven} projects.

The \texttt{gradle} folder also uses the Liferay Gradle plugin (e.g.,
\texttt{com.liferay.plugin}) which encompasses additional functionality
for various types of Liferay projects. The Liferay Gradle plugin is
recommended for Gradle users developing for Liferay DXP.

Some samples also come configured with logging to help you fully
understand what the sample is accomplishing behind the scenes. For
example, OSGi module logging is implemented for several samples (e.g.,
\href{https://github.com/liferay/liferay-blade-samples/tree/7.1/gradle/apps/action-command-portlet}{action-command-portlet},
\href{/docs/7-1/reference/-/knowledge_base/r/document-action}{document-action},
\href{/docs/7-1/reference/-/knowledge_base/r/service-builder-application-using-external-database-via-jdbc}{service-builder/jdbc},
etc.), which lets OSGi modules supply their own logging configuration
defaults without external configuration. See the
\href{/docs/7-1/tutorials/-/knowledge_base/t/adjusting-module-logging}{Adjusting
Module Logging} tutorial for more information.

For a list of sample template projects available, visit the
\href{https://github.com/liferay/liferay-blade-samples\#liferay-extension-points-and-template-projects}{Liferay
extension points} sub-section in the Liferay Blade Samples repository.
This list is not comprehensive. A subset of missing extension point
samples can be found in the
\href{https://github.com/liferay/liferay-blade-samples\#liferay-extension-points-without-template-projects}{Liferay
extension points without template projects} sub-section. Visit the
repo's
\href{https://github.com/liferay/liferay-blade-samples\#contribution-guidelines}{Contribution
Guidelines} section for details on contributing to this repository.

\section{Liferay Upgrade Planner}\label{liferay-upgrade-planner}

The Liferay Upgrade Planner provides an automated way to adapt your
installation's data and legacy plugins to your desired Liferay DXP
upgrade version. We recommend leveraging this tool for any of the
following upgrades:

\begin{itemize}
\tightlist
\item
  Liferay Portal 6.2 → Liferay DXP 7.0, 7.1, or 7.2
\item
  Liferay DXP 7.0 → Liferay DXP 7.1 or 7.2
\item
  Liferay DXP 7.1 → Liferay DXP 7.2
\end{itemize}

The Upgrade Planner is provided in
\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-ide}{Liferay Dev
Studio} (versions 3.6+). Here's what the Upgrade Planner does:

\begin{itemize}
\tightlist
\item
  Updates your development environment.
\item
  Identifies code affected by the API changes.
\item
  Describes each API change related to the code.
\item
  Suggests how to adapt the code.
\item
  Provides options, in some cases, to adapt code automatically.
\item
  Transfers database and server data to your new environment.
\end{itemize}

Even if you prefer tools other than Dev Studio (which is based on
Eclipse), you should upgrade your data and legacy plugins using the
Upgrade Planner first--you can use your favorite tools afterward.

To start the Upgrade Planner in Dev Studio, do this:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Navigate to \emph{Project} → \emph{New Liferay Upgrade Plan\ldots{}}.
\item
  In the New Liferay Upgrade Plan wizard, assign your plan a name and
  choose an upgrade plan outline. The data and code upgrade processes
  are separate, so you must step through each process independently.
\item
  Choose your current Liferay version and the new version you're
  upgrading to.
\item
  If you chose to complete a code upgrade, you must also select the
  folder where your legacy plugins reside (e.g., Plugins SDK for Liferay
  6.2 projects).
\item
  Click \emph{Finish}.
\end{enumerate}

\begin{figure}
\centering
\includegraphics{./images/upgrade-plan-wizard.png}
\caption{Configure your upgrade plan before beginning the upgrade
process.}
\end{figure}

Switch to the new Liferay Upgrade Planner perspective (prompted
automatically). You're now offered several windows in the UI:

\begin{itemize}
\tightlist
\item
  \emph{Project Explorer:} displays your legacy plugin environment and
  new development environment. It also displays your
  \href{/docs/7-1/tutorials/-/knowledge_base/t/fixing-upgrade-problems}{upgrade
  problems} that are detected during the \emph{Fix Upgrade Problems}
  step.
\item
  \emph{Liferay Upgrade Plan:} outlines the upgrade plan's steps and
  step summaries.
\item
  \emph{Liferay Upgrade Plan Info:} shows official documentation that
  describes the upgrade step.
\end{itemize}

To progress through your upgrade plan, click the steps outlined in the
Liferay Upgrade Plan window. Each step can have several options:

\begin{itemize}
\tightlist
\item
  \emph{Click to preview:} previews what an automated step will perform.
\item
  \emph{Click to perform:} executes an automated process provided with
  the step. This is only offered for steps where the Upgrade Planner can
  assist.
\item
  \emph{Click when complete:} marks the step as complete. This is only
  offered when the Upgrade Planner cannot provide automated assistance
  and, instead, only offers documentation to assist in completing the
  step manually.
\item
  \emph{Restart:} marks a completed step as unfinished. The step is
  performed again if automation is involved.
\item
  \emph{Skip:} skips the step and jumps to the next step in the outline.
\end{itemize}

\begin{figure}
\centering
\includegraphics{./images/preview-upgrade-planner-changes.png}
\caption{You can preview the Upgrade Planner's automated updates before
you perform them.}
\end{figure}

Great! You now have a good understanding of the Liferay Upgrade
Planner's UI and how to get started.

\noindent\hrulefill

\textbf{Note:} The Upgrade Planner upgrades data and code to Liferay DXP
versions that include 7.0 and the latest DXP version. It links to the
latest Liferay DXP upgrade documentation. 7.0 upgrade documentation is
available here:

\begin{itemize}
\tightlist
\item
  \href{/docs/7-1/deploy/-/knowledge_base/d/upgrading-to-liferay-71}{Data
  Upgrade}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-plugins-to-liferay-7}{Code
  Upgrade}
\end{itemize}

\section{Using the Upgrade Planner with Proxy
Requirements}\label{using-the-upgrade-planner-with-proxy-requirements}

If you have proxy server requirements and want to configure your http(s)
proxy\\
to work with the Liferay Upgrade Planner, follow the instructions below.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In Dev Studio's \texttt{DeveloperStudio.ini}/\texttt{eclipse.ini}
  file, add the following parameters:

\begin{verbatim}
-Djdk.http.auth.proxying.disabledSchemes=
-Djdk.http.auth.tunneling.disabledSchemes=
\end{verbatim}
\item
  Launch Dev Studio.
\item
  Go to \emph{Window} → \emph{Preferences} → \emph{General} →
  \emph{Network Connections}.
\item
  Set the \emph{Active Provider} drop-down selector to \emph{Manual}.
\item
  Under \emph{Proxy entries}, configure both proxy HTTP and HTTPS by
  clicking the field and selecting the \emph{Edit} button.

  \begin{figure}
  \centering
  \includegraphics{./images/upgrade-planner-proxy.png}
  \caption{You can configure your proxy settings in Dev Studio's Network
  Connections menu.}
  \end{figure}
\item
  For each schema (HTTP and HTTPS), enter your proxy server's host,
  port, and authentication settings (if necessary). Do not leave
  whitespace at the end of your proxy host or port settings.
\item
  Once you've configured your proxy entry, click \emph{Apply and Close}.
\end{enumerate}

Awesome! You've successfully configured the Upgrade Planner's proxy
settings!

\chapter{Portlets}\label{portlets}

Web apps in Liferay DXP are called \emph{portlets}. Like many web apps,
portlets process requests and generate responses. In the response, the
portlet returns content (e.g., HTML, XHTML) for display in browsers. One
key difference between portlets and other web apps is that portlets run
in a portion of the web page. When you're writing a portlet application,
you only need to worry about that application: the rest of the page--the
navigation, the top banner, and any other global components of the
interface--is handled by other components. Another difference is that
portlets run only in a portal server. Portlets can therefore use the
portal's existing support for user management, authentication,
permissions, page management, and more. This frees you to focus on
developing the portlet's core functionality. In many ways, writing your
application as a portlet is easier than writing a standalone
application.

Portlets can be placed on pages by users (if they have permission) or
portal administrators, who can place several different portlets on a
single page. For example, a page in a community site could have a
calendar portlet for community events, an announcements portlet for
important announcements, and a bookmarks portlet for links of interest
to the community. And because the portal controls page layout, you can
reposition and resize one or more portlets on a page without altering
any portlet code. Doing all this in other types of web apps would
require manual re-coding. Alternatively, a single portlet can take up an
entire page if it's the only app you need on that page. For example, a
message boards or wiki portlet is best suited on its own page. In short,
portlets alleviate many of the traditional pain points associated with
developing web apps.

\begin{figure}
\centering
\includegraphics{./images/portlet-applications.png}
\caption{You can place multiple portlets on a single page.}
\end{figure}

What's more, portals and portlets are standards-based. In 2003, Java
Portlet Specification 1.0
(\href{https://jcp.org/en/jsr/detail?id=168}{JSR-168}) first defined
portal and portlet behavior. In 2008, Java Portlet Specification 2.0
(\href{https://jcp.org/en/jsr/detail?id=286}{JSR-286}) refined and built
on JSR-168, while maintaining backwards compatibility, to define
features like inter-portlet communication (IPC) and more. The recently
released Java Portlet Specification 3.0
(\href{https://jcp.org/en/jsr/detail?id=362}{JSR-362}) continues portal
and portlet evolution. Liferay leads in this space by having a member in
the Expert Group.

So what do these specifications define? The links above show the
complete definition; here we'll briefly summarize how portlets differ
from other types of servlet-based web apps.

Portlets handle requests in multiple phases. This makes portlets much
more flexible than servlets. Each portlet phase executes different
operations:

\begin{itemize}
\tightlist
\item
  \textbf{Render:} Generates the portlet's contents based on the
  portlet's current state. When this phase runs on one portlet, it also
  runs on all other portlets on the page. The Render phase runs when any
  portlets on the page complete the Action or Event phases.
\item
  \textbf{Action:} In response to a user action, the Action phase
  performs some operations that change the portlet's state. The Action
  phase can also trigger events that are processed by the Event phase.
  Following the Action phase and optional Event phase, the Render phase
  then regenerates the portlet's contents.
\item
  \textbf{Event:} Processes events triggered in the Action phase. Events
  are used for inter-process communication (IPC). Once the portlet
  processes all events, the portal calls the Render phase on all
  portlets on the page.
\item
  \textbf{Resource-serving:} Serves a resource independent from the rest
  of the lifecycle. This lets a portlet serve dynamic content without
  running the Render phase on all portlets on a page. The
  Resource-serving phase handles AJAX requests.
\end{itemize}

Compared to servlets, portlets also have some other key differences.
Since portlets only render a portion of a page, tags like
\texttt{\textless{}html\textgreater{}},
\texttt{\textless{}head\textgreater{}}, and
\texttt{\textless{}body\textgreater{}} aren't allowed. And because you
don't know the portlet's page ahead of time, you can't create portlet
URLs directly. Instead, the portlet API gives you methods to create
portlet URLs programmatically. Also, because portlets don't have direct
access to the \texttt{javax.servlet.ServletRequest}, they can't read
query parameters directly from a URL. Portlets instead access a
\texttt{javax.portlet.PortletRequest} object. The portlet specification
only provides a mechanism for a portlet to read its own URL parameters
or those declared as public render parameters. Liferay DXP does,
however, provide utility methods that can access the
\texttt{ServletRequest} and query parameters. Portlets also have a
\emph{portlet filter} available for each phase in the portlet lifecycle.
Portlet filters are similar to servlet filters in that they allow
request and response modification on the fly.

Portlets also differ from servlets by having distinct modes and window
states. Modes distinguish the portlet's current function:

\begin{itemize}
\tightlist
\item
  \textbf{View mode:} The portlet's standard mode. Use this mode to
  access the portlet's main functionality.
\item
  \textbf{Edit mode:} The portlet's configuration mode. Use this mode to
  configure a custom view or behavior. For example, the Edit mode of a
  weather portlet could let you choose a location to retrieve weather
  data from.
\item
  \textbf{Help mode:} A mode that displays the portlet's help
  information.
\end{itemize}

Most modern applications use View Mode only.

Portlet window states control the amount of space a portlet takes up on
a page. Window states mimic window behavior in a traditional desktop
environment:

\begin{itemize}
\tightlist
\item
  \textbf{Normal:} The portlet can be on a page that contains other
  portlets. This is the default window state.
\item
  \textbf{Maximized:} The portlet takes up an entire page.
\item
  \textbf{Minimized:} Only the portlet's title bar shows.
\end{itemize}

When you develop portlets, you can leverage all the features defined by
the portlet specification. Depending on how you develop and package your
portlet, however, it may not be able to run on other portal containers.
You may now be saying, ``Hold on a minute! I thought Liferay DXP was
standards-compliant? What gives?'' Liferay DXP is standards-compliant,
but it contains some sweeteners in the form of APIs designed to make
developers' lives easier. For example, Liferay DXP contains an
\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-mvc-portlet}{MVC
framework} that makes it simpler to implement MVC in your portlet. This
framework, however, is only available in Liferay DXP. Without
modification, a portlet that uses this framework won't run if deployed
to a non-Liferay portal container. Note, though, that we don't force you
to use our MVC framework or any of its other unique APIs. For example,
you can develop your portlet with strictly standards-compliant
frameworks and APIs, package it in a WAR file, and then deploy it on any
standards-compliant portal container.

Liferay DXP also contains an OSGi runtime. This means that you don't
have to develop and deploy your portlet as a traditional WAR file; you
can do so as OSGi modules instead. We recommend the latter, so you can
take advantage of the modularity features inherent in OSGi. For a
detailed description of these features, see the tutorial
\href{/docs/7-1/tutorials/-/knowledge_base/t/osgi-and-modularity-for-liferay-6-developers}{OSGi
and Modularity}. Note, however, that portlets you develop as OSGi
modules won't run on other portlet containers that lack an OSGi runtime.
Even so, the
\href{/docs/7-1/tutorials/-/knowledge_base/t/the-benefits-of-modularity}{advantages
of modularity} are so great that we still recommend you develop your
portlets as OSGi modules.

So what's the benefit to adopting Liferay's frameworks and APIs? There
are several:

\begin{itemize}
\tightlist
\item
  They follow Liferay's design patterns. The better you understand them,
  the better you understand Liferay DXP.
\item
  They are the result of nearly 15 years of portlet development.
\item
  They provide many conveniences that make development easier and
  faster.
\item
  They make your applications fit more naturally with the rest of the
  system.
\item
  If necessary, they're easy to migrate from, because they're built on
  top of the standards.
\end{itemize}

With that said, you can use a variety of technologies to develop
portlets. This section shows you how to develop portlets using the
following frameworks and techniques:

\begin{itemize}
\tightlist
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-mvc-portlet}{Liferay's
  MVCPortlet}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-soy-portlet}{Liferay
  Soy Portlet}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/spring-mvc}{Spring MVC}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/making-urls-friendlier}{Making
  URLs Friendlier}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/automatic-single-page-applications}{Automatic
  Single Page Applications}
\item
  Applying Clay Styles to Your App
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/creating-layouts-inside-custom-portlets}{Creating
  Layouts Inside Portlets}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/using-javascript-in-your-portlets}{Using
  JavaScript Inside Portlets}
\end{itemize}

\section{Related Topics}\label{related-topics-16}

\href{/docs/7-1/tutorials/-/knowledge_base/t/configuring-dependencies}{Configuring
Dependencies}

\href{/docs/7-1/tutorials/-/knowledge_base/t/importing-packages}{Importing
Packages}

\href{/docs/7-1/tutorials/-/knowledge_base/t/exporting-packages}{Exporting
Packages}

\chapter{Liferay MVC Portlet}\label{liferay-mvc-portlet}

Web applications often follow the Model View Controller (MVC) pattern.
But Liferay has developed a groundbreaking new pattern called the
\emph{Modal Veal Contractor} (MVC) pattern. Okay, that's not true: the
framework is actually another implementation of Model View Controller.
If you're an experienced developer, this is not the first time you've
heard about Model View Controller. In this article you must stay
focused, because there are several attempts to show you why Liferay's
implementation of Model View Controller is different, when instead
you're hearing about another MVC framework. With that in mind, let's get
back to the \emph{Medial Vein Constriction} pattern we were discussing.

If there are so many implementations of MVC frameworks in Java, why did
Liferay create yet another one? Stay with us and you'll see that Liferay
MVC provides these benefits:

\begin{itemize}
\tightlist
\item
  It's lightweight, as opposed to many other Java MVC frameworks.
\item
  There are no special configuration files that need to be kept in sync
  with your code.
\item
  It's a simple extension of \texttt{GenericPortlet}.
\item
  You avoid writing a bunch of boilerplate code, since Liferay's MVC
  framework simply looks for some pre-defined parameters when the
  \texttt{init()} method is called.
\item
  The controller can be broken down into MVC command classes, each of
  which handles the controller code for a particular portlet phase
  (render, action, and resource serving phases).
\item
  Liferay's portlets use it. That means there are plenty of robust
  implementations to reference when you need to design or troubleshoot
  your Liferay applications.
\end{itemize}

The Liferay MVC portlet framework is light, it hides part of the
complexity of portlets, and it makes the most common operations easier.
The default \texttt{MVCPortlet} project uses separate JSPs for each
portlet mode: For example, \texttt{edit.jsp} is for \emph{edit} mode and
\texttt{help.jsp} is for \emph{help} mode.

Before diving in to the Liferay MVC swimming pool with all the other
cool kids (applications), here's an overview of the Liferay MVC Portlet:

\begin{itemize}
\tightlist
\item
  \hyperref[mvc-layers-and-modularity]{MVC layers and modularity}
\item
  \hyperref[liferay-mvc-command-classes]{Liferay MVC command classes}
\item
  \hyperref[liferay-mvc-portlet-component]{Liferay MVC portlet
  component}
\item
  \hyperref[a-simpler-mvc-portlet]{Simple MVC portlets}
\end{itemize}

Review how each layer of the \emph{Moody Vase Conscription} pattern
helps you separate the concerns of your application.

\section{MVC Layers and Modularity}\label{mvc-layers-and-modularity}

In MVC, there are three layers, and you can probably guess what they
are.

\textbf{Model:} The model layer holds the application data and logic for
manipulating it.

\textbf{View:} The view layer contains logic for displaying data.

\textbf{Controller:} The middle man in the MVC pattern, the Controller
contains logic for passing the data back and forth between the view and
the model layers.

The \emph{Middle Verse Completer} pattern fits well with
\href{/docs/7-1/tutorials/-/knowledge_base/t/fundamentals\#modules}{Liferay's
application modularity effort}.

Liferay's applications are divided into multiple discrete modules. With
\href{/docs/7-1/tutorials/-/knowledge_base/t/service-builder}{Service
Builder}, the model layer is generated into a \texttt{service} and an
\texttt{api} module. That accounts for the model in the MVC pattern. For
the web, the view and the controller share a module, the \texttt{web}
module.

Generating the skeleton for a multi-module Service Builder-driven MVC
application using
\href{/docs/7-1/tutorials/-/knowledge_base/t/blade-cli}{Liferay Blade
CLI} saves you lots of time and gets you started on the more important
(and interesting, if we're being honest) development work.

\section{Liferay MVC Command Classes}\label{liferay-mvc-command-classes}

In a larger application, your \texttt{-Portlet} class can become
monstrous and unwieldy if it holds all of the controller logic. Liferay
provides MVC command classes to break up your controller functionality.

\begin{itemize}
\tightlist
\item
  \textbf{\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/bridges/mvc/MVCActionCommand.html}{\texttt{MVCActionCommand}}:}
  Use \texttt{-ActionCommand} classes to hold each of your portlet
  actions, which are invoked by action URLs.
\item
  \textbf{\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/bridges/mvc/MVCRenderCommand.html}{\texttt{MVCRenderCommand}}:}
  Use \texttt{-RenderCommand} classes to hold a \texttt{render} method
  that dispatches to the appropriate JSP, by responding to render URLs.
\item
  \textbf{\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/bridges/mvc/MVCResourceCommand.html}{\texttt{MVCResourceCommand}}:}
  Use \texttt{-ResourceCommand} classes to serve resources based on
  resource URLs.
\end{itemize}

There must be some confusing configuration files to keep everything
wired together and working properly, right? Wrong: it's all easily
managed in the OSGi component in the \texttt{-Portlet} class.

\section{Liferay MVC Portlet
Component}\label{liferay-mvc-portlet-component}

Whether or not you plan to split up the controller into MVC command
classes, you use a portlet component class with a certain set of
properties. Here's a simple portlet component as an example:

\begin{verbatim}
@Component(
    immediate = true,
    property = {
        "com.liferay.portlet.css-class-wrapper=portlet-hello-world",
        "com.liferay.portlet.display-category=category.sample",
        "com.liferay.portlet.icon=/icons/hello_world.png",
        "com.liferay.portlet.preferences-owned-by-group=true",
        "com.liferay.portlet.private-request-attributes=false",
        "com.liferay.portlet.private-session-attributes=false",
        "com.liferay.portlet.remoteable=true",
        "com.liferay.portlet.render-weight=50",
        "com.liferay.portlet.use-default-template=true",
        "javax.portlet.display-name=Hello World",
        "javax.portlet.expiration-cache=0",
        "javax.portlet.init-param.always-display-default-configuration-icons=true",
        "javax.portlet.name=" + HelloWorldPortletKeys.HELLO_WORLD,
        "javax.portlet.resource-bundle=content.Language",
        "javax.portlet.security-role-ref=guest,power-user,user",
        "javax.portlet.supports.mime-type=text/html"
    },
    service = Portlet.class
)
public class HelloWorldPortlet extends MVCPortlet {
}
\end{verbatim}

When using MVC commands, the \texttt{javax.portlet.name} property is
important. This property is one of two that must be included in each MVC
command component; it links a particular portlet URL/command combination
to the correct portlet.

\noindent\hrulefill

\textbf{Important:} Make your portlet name unique, considering how
\href{/docs/7-1/reference/-/knowledge_base/r/portlet-descriptor-to-osgi-service-property-map\#ten}{Liferay
DXP uses the name to create the portlet's ID}.

\noindent\hrulefill

There can be some confusion over exactly what kind of
\texttt{Portlet.class} implementation you're publishing with this
component. Liferay's service registry expects this to be the
\texttt{javax.portlet.Portlet} interface. Import that, and not, for
example, \texttt{com.liferay.portal.kernel.model.Portlet}.

\noindent\hrulefill

\textbf{Note:} The DTD
\href{https://docs.liferay.com/dxp/portal/7.1-latest/definitions/liferay-portlet-app_7_1_0.dtd.html}{liferay-portlet-app\_7\_1\_0.dtd}
defines all the Liferay-specific attributes you can specify as
properties in your portlet components.

Consider the \texttt{\textless{}css-class-wrapper\textgreater{}} element
from the above link as an example. To specify that property in your
component, use this syntax in your property list:

\begin{verbatim}
 "com.liferay.portlet.css-class-wrapper=portlet-hello-world",
\end{verbatim}

The properties namespaced with \texttt{javax.portlet....} are elements
of the
\href{http://java.sun.com/xml/ns/portlet/portlet-app_2_0.xsd}{portlet.xml
descriptor}.

\noindent\hrulefill

\section{A Simpler MVC Portlet}\label{a-simpler-mvc-portlet}

With all this focus on MVC commands, don't be concerned that you'll be
forced into a more complex pattern than you need, especially if you're
developing only a small MVC application. Not so; just put all your logic
into the \texttt{-Portlet} class if you don't want to split up your MVC
commands.

In simpler applications, if you don't have an MVC command to rely on,
your portlet render URLs specify JSP paths in \texttt{mvcPath}
parameters.

\begin{verbatim}
    <portlet:renderURL var="addEntryURL">
        <portlet:param name="mvcPath" value="/entry/edit_entry.jsp" />
        <portlet:param name="redirect" value="<%= redirect %>" />
    </portlet:renderURL>
\end{verbatim}

As you've seen, Liferay's \emph{Medical Vortex Concentrator} (MVC)
portlet framework gives you a well-structured controller layer that
takes very little time to implement. With all your free time, you could

\begin{itemize}
\tightlist
\item
  Learn a new language
\item
  Take pottery classes
\item
  Lift weights
\item
  Work on your application's business logic
\end{itemize}

It's entirely up to you. To get into the details of creating an MVC
Portlet application, follow the
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-an-mvc-portlet}{Creating
an MVC Portlet} tutorial.

\chapter{Creating an MVC Portlet}\label{creating-an-mvc-portlet}

MVC Portlet applications are web modules containing at least one portlet
class that's registered in Liferay's runtime environment as a component.
Web modules describe themselves using standard OSGi metadata and can use
any build environment.

Here are the general steps for implementing a Liferay MVC Portlet
component module:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Configuring a Web module
\item
  Specifying OSGi metadata
\item
  Creating a portlet Component
\end{enumerate}

Start by creating a web module for your portlet.

\section{Step 1: Configuring a Web
Module}\label{step-1-configuring-a-web-module}

The folder structure for a web module generally follows this pattern:

\begin{itemize}
\tightlist
\item
  docs.liferaymvc.web/

  \begin{itemize}
  \tightlist
  \item
    src/main/java/

    \begin{itemize}
    \tightlist
    \item
      com/liferay/docs/liferaymvc/web/portlet/LiferayMVCPortlet.java
    \end{itemize}
  \item
    src/main/resources/

    \begin{itemize}
    \tightlist
    \item
      content/

      \begin{itemize}
      \tightlist
      \item
        Language.properties
      \end{itemize}
    \item
      META/-INF/resources/

      \begin{itemize}
      \tightlist
      \item
        init.jsp
      \item
        view.jsp
      \end{itemize}
    \end{itemize}
  \item
    build.gradle
  \item
    bnd.bnd
  \end{itemize}
\end{itemize}

The
\href{/docs/7-1/reference/-/knowledge_base/r/using-the-mvc-portlet-template}{MVC
portlet template}, available for both Maven and Gradle in
\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-ide}{Liferay Dev
Studio DXP} and
\href{/docs/7-1/tutorials/-/knowledge_base/t/blade-cli}{Blade CLI},
makes creating such Web modules a snap. Of course you're not tied to
using Gradle or bnd to build your project. However, you must build your
module as a JAR and define your module with proper OSGi headers.

\section{Step 2: Specifying OSGi
Metadata}\label{step-2-specifying-osgi-metadata}

OSGi metadata describes your module to the OSGi runtime environment. At
a minimum, you should specify the bundle symbolic name and the bundle
version. We recommend a human-readable bundle name.

\begin{verbatim}
Bundle-Name: Example Liferay MVC Web
Bundle-SymbolicName: com.liferay.docs.liferaymvc.web
Bundle-Version: 1.0.0
\end{verbatim}

If you don't specify a \texttt{Bundle-SymbolicName}, one is generated
from the project's folder path, which is suitable for many cases.
Liferay's convention is to specify the root package name as your bundle
symbolic name.

\section{Step 3: Creating a Portlet
Component}\label{step-3-creating-a-portlet-component}

The OSGi Declarative Services component model makes it easy to publish
service implementations to the OSGi runtime. For example, publishing
your portlet class as a \texttt{javax.portlet.Portlet} requires an
\texttt{@Component} annotation like this one:

\begin{verbatim}
@Component(
    immediate = true,
    service = Portlet.class
)
public class LiferayMVCPortlet extends MVCPortlet {
}
\end{verbatim}

The \texttt{immediate\ =\ true} attribute tells the runtime to publish
the portlet as soon as its dependencies resolve. The attribute
\texttt{service\ =\ Portlet.class} specifies that the portlet provides
the \texttt{javax.portlet.Portlet} service.

Since Liferay's
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/bridges/mvc/MVCPortlet.html}{\texttt{MVCPortlet}
class} is itself an extension of \texttt{javax.portlet.Portlet}, you've
provided the right implementation. That's good in itself, but the
Component must be configured:

\begin{verbatim}
@Component(
    immediate = true,
    property = {
        "com.liferay.portlet.display-category=category.sample",
        "com.liferay.portlet.instanceable=true",
        "javax.portlet.display-name=Liferay MVC Portlet",
        "javax.portlet.init-param.template-path=/",
        "javax.portlet.init-param.view-template=/view.jsp",
        "javax.portlet.name=MyMVCPortlet",
        "javax.portlet.resource-bundle=content.Language",
        "javax.portlet.security-role-ref=power-user,user"
    },
    service = Portlet.class
)
public class LiferayMVCPortlet extends MVCPortlet {
}
\end{verbatim}

Liferay's
\href{/docs/7-1/reference/-/knowledge_base/r/using-the-mvc-portlet-template}{MVC
portlet template} includes these component properties in the portlet
class it generates.

Some of the properties might look familiar to you if you've developed
Liferay MVC portlets for Liferay Portal 6.2. That's because they're the
same as the XML attributes you used to specify in
\texttt{liferay-portlet.xml}, \texttt{liferay-display.xml}, and
\texttt{portlet.xml}. The
\href{/docs/7-1/reference/-/knowledge_base/r/portlet-descriptor-to-osgi-service-property-map}{mapping
of portlet descriptors to OSGi properties} can you help find OSGi
properties for descriptors you already know.

To keep compatibility with the JSR-168 and JSR-286 portlet specs, these
DTDs define the Liferay-specific portlet attributes:

\begin{itemize}
\tightlist
\item
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/definitions/liferay-portlet-app_7_1_0.dtd.html}{liferay-portlet-app\_7\_1\_0.dtd}.
\item
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/definitions/liferay-display_7_1_0.dtd.html}{liferay-display\_7\_1\_0.dtd}
\end{itemize}

For example, consider the \texttt{\textless{}instanceable\textgreater{}}
element from \texttt{liferay-portlet-app\_7\_1\_0.dtd}. To specify that
property in your Component, use this syntax in your \texttt{@Component}
property list:

\begin{verbatim}
"com.liferay.portlet.instanceable=true",
\end{verbatim}

The properties namespaced with \texttt{javax.portlet....} are elements
of the
\href{http://java.sun.com/xml/ns/portlet/portlet-app_2_0.xsd}{portlet.xml
descriptor}.

Also note that you can use the
\texttt{com.liferay.portlet.display-category} property to create nested
categories. Use \texttt{//} to separate the category root and all
categories and sub-categories that comprise your portlet's category
path. Here's an example:

\begin{verbatim}
com.liferay.portlet.display-category=root//category.category1//category.category2
\end{verbatim}

You now know how to extend Liferay's \texttt{MVCPortlet} and register it
as a Component in the OSGi runtime. It's time to write your controller
code.

\section{Writing Controller Code}\label{writing-controller-code}

In MVC, your controller receives requests from the front-end, and it
pulls data from the back-end. It's a traffic director: it provides data
to the right front-end view for display to the user, and it takes data
the user entered in the front-end and passes it to the right back-end
service. For this reason, the controller must process requests from the
front-end, and it must determine the right front-end view to pass data
back to the user.

If you have a small application that's not heavy on controller logic
(maybe just a couple of action methods), you can put all your controller
code in the \texttt{-Portlet} class. If you have more complex needs
(lots of actions, complex render logic to implement, or maybe even some
resource serving code), consider breaking the controller into
\href{/docs/7-1/tutorials/-/knowledge_base/t/mvc-render-command}{MVC
Render Command classes},
\href{/docs/7-1/tutorials/-/knowledge_base/t/mvc-action-command}{MVC
Action Command classes}, and
\href{/docs/7-1/tutorials/-/knowledge_base/t/mvc-resource-command}{MVC
Resource Command classes}. This tutorial demonstrates implementing
controller logic for small applications.

In this tutorial you'll learn to implement a Liferay MVC portlet with
all the controller code in the \texttt{-Portlet} class. It involves
these things:

\begin{itemize}
\tightlist
\item
  Action methods
\item
  Render logic
\item
  Setting and retrieving request parameters and attributes
\end{itemize}

Start with creating action methods.

\subsection{Action Methods}\label{action-methods}

If you have a small application, you can implement all your controller
logic in the portlet class you created in the last step. It can act as
your controller by itself. Use action methods to process requests.
Here's a sample action method:

\begin{verbatim}
public void addGuestbook(ActionRequest request, ActionResponse response)
        throws PortalException, SystemException {

    ServiceContext serviceContext = ServiceContextFactory.getInstance(
        Guestbook.class.getName(), request);

    String name = ParamUtil.getString(request, "name");

    try {
        _guestbookService.addGuestbook(serviceContext.getUserId(),
                name, serviceContext);

        SessionMessages.add(request, "guestbookAdded");

    } catch (Exception e) {
        SessionErrors.add(request, e.getClass().getName());

        response.setRenderParameter("mvcPath",
            "/html/guestbook/edit_guestbook.jsp");
    }

}
\end{verbatim}

This action has one job: call a service to add a Guestbook. If this call
succeeds, the message \texttt{"guestbookAdded"} is associated with the
request and added to the
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/servlet/SessionMessages.html}{\texttt{SessionMessages}
object}. If an exception is thrown, it's caught, and the class name is
associated with the request and added to the
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/servlet/SessionErrors.html}{\texttt{SessionErrors}
object} and the response is set to render \texttt{edit\_guestbook.jsp}.
Setting the \texttt{mvcPath} render parameter is a Liferay
\texttt{MVCPortlet} framework convention that denotes the next view to
render to the user.

While action methods respond to user actions, render logic determines
the view to display to the user. Render logic is next.

\subsection{Render Logic}\label{render-logic}

Here's how MVC Portlet determines which view to render. Note the
\texttt{init-param} properties you set in your component:

\begin{verbatim}
"javax.portlet.init-param.template-path=/",
"javax.portlet.init-param.view-template=/view.jsp",
\end{verbatim}

The \texttt{template-path} property tells the MVC framework where your
JSP files live. In the above example, \texttt{/} means that the JSP
files are in your project's root \texttt{resources} folder. That's why
it's important to follow Liferay's standard folder structure. The
\texttt{view-template} property directs the default rendering to
\texttt{view.jsp}.

Here's the path of a hypothetical Web module's resource folder:

\begin{verbatim}
docs.liferaymvc.web/src/main/resources/META-INF/resources
\end{verbatim}

Based on that resource folder, the \texttt{view.jsp} file is found at

\begin{verbatim}
docs.liferaymvc.web/src/main/resources/META-INF/resources/view.jsp
\end{verbatim}

and that's the default view of the application. When the portlet's
\texttt{init} method (e.g., your portlet's override of
\texttt{MVCPortlet.init()}) is called, the initialization parameters you
specify are read and used to direct rendering to the default JSP.
Throughout the controller, you can render different views (JSP files) by
setting the render parameter \texttt{mvcPath} like this:

\begin{verbatim}
actionResponse.setRenderParameter("mvcPath", "/error.jsp");
\end{verbatim}

It's possible to avoid render logic by using initialization parameters
and render parameters, but most of the time you'll override the
portlet's \texttt{render} method. Here's an example:

\begin{verbatim}
@Override
public void render(RenderRequest renderRequest,
        RenderResponse renderResponse) throws PortletException, IOException {

    try {
        ServiceContext serviceContext = ServiceContextFactory.getInstance(
                Guestbook.class.getName(), renderRequest);

        long groupId = serviceContext.getScopeGroupId();

        long guestbookId = ParamUtil.getLong(renderRequest, "guestbookId");

        List<Guestbook> guestbooks = _guestbookService
                .getGuestbooks(groupId);

        if (guestbooks.size() == 0) {
            Guestbook guestbook = _guestbookService.addGuestbook(
                    serviceContext.getUserId(), "Main", serviceContext);

            guestbookId = guestbook.getGuestbookId();

        }

        if (!(guestbookId > 0)) {
            guestbookId = guestbooks.get(0).getGuestbookId();
        }

        renderRequest.setAttribute("guestbookId", guestbookId);

    } catch (Exception e) {

        throw new PortletException(e);
    }

    super.render(renderRequest, renderResponse);

}
\end{verbatim}

This render logic provides the view layer with data to display to the
user. The \texttt{render} method above sets the render request attribute
\texttt{guestbookId} with the ID of a guestbook to display. If
guestbooks exist, it chooses the first. Otherwise, it creates a
guestbook and sets it to display. Lastly the method passes the render
request and render response objects to the base class via its
\texttt{render} method.

\noindent\hrulefill

\textbf{Note:} Are you wondering how to call Service Builder services in
7.0?
\href{/docs/7-1/tutorials/-/knowledge_base/t/invoking-services-from-service-builder-code}{Invoking
Services from Service Builder Code} can help. In short, obtain a
reference to the service by annotating one of your fields of that
service type with the \texttt{@Reference} Declarative Services
annotation.

\begin{verbatim}
 @Reference
 private GuestbookService _guestbookService;
\end{verbatim}

Once done, you can call the service's methods.

\begin{verbatim}
 _guestbookService.addGuestbook(serviceContext.getUserId(), "Main",
         serviceContext);
\end{verbatim}

\noindent\hrulefill

Before venturing into the view layer, the next section demonstrates ways
to pass information between the controller and view layers.

\subsection{Setting and Retrieving Request and Response Parameters and
Attributes}\label{setting-and-retrieving-request-and-response-parameters-and-attributes}

You can use a handy utility class called
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/util/ParamUtil.html}{\texttt{ParamUtil}}
to retrieve parameters from an \texttt{ActionRequest} or a
\texttt{RenderRequest}.

For example, a JSP could pass a parameter named \texttt{guestbookId} in
an action URL.

\begin{verbatim}
<portlet:actionURL name="doSomething" var="doSomethingURL">
    <portlet:param name="guestbookId" 
            value="<%= String.valueOf(entry.getGuestbookId()) %>" />
</portlet:actionURL>
\end{verbatim}

The \texttt{\textless{}portlet:actionURL\textgreater{}} tag's
\texttt{name} attribute maps the action URL to a controller action
method named \texttt{doSomething}. Triggering an action URL invokes the
corresponding method in the controller.

The controller's \texttt{doSomething} method referenced in this example
can then get the \texttt{guestbookId} parameter value from the
\texttt{ActionRequest}.

\begin{verbatim}
long guestbookId = ParamUtil.getLong(actionRequest, "guestbookId");
\end{verbatim}

To pass information back to the view layer, the controller code can set
render parameters on response objects.

\begin{verbatim}
actionResponse.setRenderParameter("mvcPath", "/error.jsp");
\end{verbatim}

The code above sets a parameter called \texttt{mvcPath} to JSP path
\texttt{/error.jsp}. This causes the controller's render method to
redirect the user to the JSP \texttt{/error.jsp}.

Your controller class can also set attributes into response objects
using the \texttt{setAttribute} method.

\begin{verbatim}
renderRequest.setAttribute("guestbookId", guestbookId);
\end{verbatim}

JSPs can use Java code in scriptlets to interact with the request
object.

\begin{verbatim}
<%
    long guestbookId = Long.valueOf((Long) renderRequest
            .getAttribute("guestbookId"));
%>
\end{verbatim}

Passing information back and forth from your view and controller is
important, but there's more to the view layer than that. The view layer
is up next.

\section{Configuring the View Layer}\label{configuring-the-view-layer}

This section briefly covers how to get your view layer working, from
organizing your imports in one JSP file, to creating URLs that direct
processing to methods in your portlet class.

\noindent\hrulefill

Note: As you create JSPs, you can
\href{/docs/7-1/tutorials/-/knowledge_base/t/applying-clay-styles-to-your-app}{apply
Clay styles to your app to match Liferay's apps}.

\noindent\hrulefill

Liferay's best practice puts all Java imports, tag library declarations,
and variable initializations into a JSP called \texttt{init.jsp}. If you
use \href{/docs/7-1/tutorials/-/knowledge_base/t/blade-cli}{Blade CLI}
or \href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-ide}{Liferay Dev
Studio DXP} to create a module based on the \texttt{mvc-portlet} project
template, these taglib declarations and initializations are added
automatically to your \texttt{init.jsp}:

\begin{verbatim}
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %>

<%@ taglib uri="http://java.sun.com/portlet_2_0" prefix="portlet" %>

<%@ taglib uri="http://liferay.com/tld/aui" prefix="aui" %>
<%@ taglib uri="http://liferay.com/tld/portlet" prefix="liferay-portlet" %>
<%@ taglib uri="http://liferay.com/tld/theme" prefix="liferay-theme" %>
<%@ taglib uri="http://liferay.com/tld/ui" prefix="liferay-ui" %>

<liferay-theme:defineObjects />

<portlet:defineObjects />
\end{verbatim}

Make sure to include the \texttt{init.jsp} in your other JSPs:

\begin{verbatim}
<%@include file="/html/init.jsp"%>
\end{verbatim}

JSPs can use action URLs to invoke controller methods. To create a link
to another page, use a render URL with the \texttt{mvcPath} parameter.
The
\href{https://docs.liferay.com/dxp/portal/7.1-latest/taglibs/util-taglib/portlet/renderURL.html}{\texttt{\textless{}portlet:renderURL\textgreater{}}
tag} constructs the URL and assigns it to a variable.

\begin{verbatim}
<portlet:renderURL var="searchURL">
        <portlet:param name="mvcPath" value="/admin/view.jsp" />
</portlet:renderURL>
\end{verbatim}

The render URL is assigned to the \texttt{searchURL} variable specified
by the \texttt{var} attribute. The
\href{https://docs.liferay.com/dxp/portal/7.1-latest/taglibs/util-taglib/portlet/param.html}{\texttt{\textless{}portlet:param\textgreater{}}
tag} above assigns JSP path \texttt{/admin/view.jsp} to the render
parameter \texttt{mvcPath}. The controller's \texttt{render} method gets
the JSP path from the \texttt{mvcPath} parameter to render the following
JSP:

\begin{verbatim}
docs.liferaymvc.web/src/main/resources/META-INF/resources/admin/view.jsp
\end{verbatim}

To invoke the render URL, assign its variable (the one set to the
\texttt{var} attribute of the
\texttt{\textless{}portlet:renderURL\textgreater{}}) to an action for a
UI component, such as a button or navigation bar item.

Action methods are different because they invoke an action (i.e., code),
rather than just linking to another page. In your JSP, use a
\href{https://docs.liferay.com/dxp/portal/7.1-latest/taglibs/util-taglib/portlet/actionURL.html}{\texttt{\textless{}portlet:actionURL\textgreater{}}
tag} to create an action URL and then assign that URL as an action for a
UI component. Here's an action URL that calls a controller method named
\texttt{doSomething}.

\begin{verbatim}
<portlet:actionURL name="doSomething" var="doSomethingURL">
    <portlet:param name="redirect" value="<%= redirect %>" />
</portlet:actionURL>
\end{verbatim}

The portlet parameter named \texttt{redirect} is assigned to a JSP path
for the portlet to redirect to after invoking the portlet action. This
action URL is assigned to a variable named \texttt{doSomethingURL}. As
with a render URL, you can assign an action URL to a UI component action
by the action URL's variable (the one set to \texttt{var}).

These simple examples demonstrate how the Liferay MVC framework
facilitates communication between a smaller application's view layer and
controller.

\section{Beyond the Basics for
Portlets}\label{beyond-the-basics-for-portlets}

The tutorial you've just completed should get you up and running with a
Liferay MVC Web module, but there's more to know about creating an app
in Liferay. To support more actions, complex render logic, and or
serving resources, continue reading the MVC command tutorials that
follow.

Regardless of your application's size or complexity, there are more
conveniences and features to leverage in your portlets. Here are a few
useful jumping off points:

\begin{itemize}
\tightlist
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/making-urls-friendlier}{Making
  URLs Friendlier}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/applying-clay-styles-to-your-app}{Applying
  Clay Styles to your App}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/localizing-your-application}{Localizing
  your Application}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/liferays-workflow-framework}{Liferay's
  Workflow Framework}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/model-listeners}{Model
  Listeners}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/application-security}{Application
  Security}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/asset-framework}{Asset
  Framework}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/service-builder}{Service
  Builder}
\end{itemize}

Enjoy creating your own portlets!

\section{MVC Action Command}\label{mvc-action-command}

Liferay's MVC framework lets you split your portlet's
\href{/docs/7-1/tutorials/-/knowledge_base/t/writing-controller-code\#action-methods}{action
methods} into separate classes. This can be very helpful in portlets
that have many actions. Each action URL in your portlet's JSPs then
calls the appropriate action class when necessary.

First,
\href{configuring-the-view-layer\#configuring-the-view-layer}{configure
your view layer} and use the
\href{https://docs.liferay.com/dxp/portal/7.1-latest/taglibs/util-taglib/portlet/actionURL.html}{\texttt{\textless{}portlet:actionURL\textgreater{}}
tag} to create the action URL in your JSP. For example, the Blogs app's
\href{https://github.com/liferay/liferay-portal/blob/master/modules/apps/blogs/blogs-web/src/main/resources/META-INF/resources/blogs/edit_entry.jsp}{\texttt{edit\_entry.jsp}
file} defines the following action URL for editing blog entries:

\begin{verbatim}
<portlet:actionURL name="/blogs/edit_entry" var="editEntryURL" />
\end{verbatim}

The \texttt{name} attribute declares a variable to hold the portlet
action URL object. Assign that variable to a UI component, such as a
button or icon. When the user triggers the UI component, the
\texttt{*MVCActionCommand} class that matches the action URL processes
the action request and response. Create an action class by implementing
the
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/bridges/mvc/MVCActionCommand.html}{\texttt{MVCActionCommand}
interface}, or extending the
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/bridges/mvc/BaseMVCActionCommand.html}{\texttt{BaseMVCActionCommand}
class}. The latter may save you time, since it already implements
\texttt{MVCActionCommand}.

Naming your \texttt{*MVCActionCommand} class after the action it
performs is a good convention. For example, if your action class edits
some kind of entry, you could name its class
\texttt{EditEntryMVCActionCommand}. If your application has several MVC
command classes, naming them this way helps differentiate them.

Your \texttt{*MVCActionCommand} class must also have an
\texttt{@Component} annotation like the following example. Set the
property \texttt{javax.portlet.name} to your portlet's internal ID. Set
the property \texttt{mvc.command.name} to the value of the \texttt{name}
property in your JSP's matching \texttt{actionURL}. To register the
component in the OSGi container as an \texttt{MVCActionCommand} service,
set the \texttt{service} property to \texttt{MVCActionCommand.class}:

\begin{verbatim}
@Component(
    immediate = true,
    property = {
        "javax.portlet.name=your_portlet_name_YourPortlet",
        "mvc.command.name=/your/jsp/action/url"
    },
    service = MVCActionCommand.class
)

public class YourMVCActionCommand extends BaseMVCActionCommand {
    // implement your action
}
\end{verbatim}

The Blogs app's \texttt{EditEntryMVCActionCommand} class is a real world
example of a \texttt{*MVCActionCommand} class:

\begin{verbatim}
@Component(
    immediate = true,
    property = {
        "javax.portlet.name=" + BlogsPortletKeys.BLOGS,
        "javax.portlet.name=" + BlogsPortletKeys.BLOGS_ADMIN,
        "javax.portlet.name=" + BlogsPortletKeys.BLOGS_AGGREGATOR,
        "mvc.command.name=/blogs/edit_entry"
    },
    service = MVCActionCommand.class
)
public class EditEntryMVCActionCommand extends BaseMVCActionCommand {

        @Override
        protected void doProcessAction(
                ActionRequest actionRequest, ActionResponse actionResponse)
            throws Exception {

            String cmd = ParamUtil.getString(actionRequest, Constants.CMD);

            try {
                BlogsEntry entry = null;

                UploadException uploadException =
                    (UploadException)actionRequest.getAttribute(
                        WebKeys.UPLOAD_EXCEPTION);

                if (uploadException != null) {
                    Throwable cause = uploadException.getCause();

                    if (uploadException.isExceededFileSizeLimit()) {
                        throw new FileSizeException(cause);
                    }

                    if (uploadException.isExceededLiferayFileItemSizeLimit()) {
                        throw new LiferayFileItemException(cause);
                    }

                    if (uploadException.isExceededUploadRequestSizeLimit()) {
                        throw new UploadRequestSizeException(cause);
                    }

                    throw new PortalException(cause);
                }
                else if (cmd.equals(Constants.ADD) ||
                         cmd.equals(Constants.UPDATE)) {

                    Callable<BlogsEntry> updateEntryCallable =
                        new UpdateEntryCallable(actionRequest);

                    entry = TransactionInvokerUtil.invoke(
                        _transactionConfig, updateEntryCallable);
                }
                else if (cmd.equals(Constants.DELETE)) {
                    deleteEntries(actionRequest, false);
                }
                else if (cmd.equals(Constants.MOVE_TO_TRASH)) {
                    deleteEntries(actionRequest, true);
                }
                else if (cmd.equals(Constants.RESTORE)) {
                    restoreTrashEntries(actionRequest);
                }
                else if (cmd.equals(Constants.SUBSCRIBE)) {
                    subscribe(actionRequest);
                }
                else if (cmd.equals(Constants.UNSUBSCRIBE)) {
                    unsubscribe(actionRequest);
                }

                ... do more action processing
            }

            ... handle exceptions
    }
}
\end{verbatim}

The \texttt{@Component}'s multiple \texttt{javax.portlet.name} property
values make this \texttt{*MVCActionCommand} class available to those
portlets as a Service Component. The \texttt{mvc.command.name} property
setting \texttt{/blogs/edit\_entry} matches the \texttt{actionURL}'s
\texttt{name} attribute shown earlier, and the \texttt{service} property
set to \texttt{MVCActionCommand.class} makes the class an
\texttt{MVCActionCommand} Service Component.

The \texttt{EditEntryMVCActionCommand} class extends
\texttt{BaseMVCActionCommand} and overrides the \texttt{doProcessAction}
method. Similarly, \texttt{*MVCActionCommand} classes that implement
\texttt{MVCActionCommand} directly must implement the
\texttt{processAction} method. Both methods process resource requests
and responses via their \texttt{javax.portlet.ActionRequest} and
\texttt{javax.portlet.ActionResponse} parameters, respectively.

\texttt{EditEntryMVCActionCommand}'s \texttt{doProcessAction} method
gets the value of a command parameter named by
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/util/Constants.html}{constant
\texttt{Constants.CMD}} from the \texttt{ActionRequest}.

\begin{verbatim}
String cmd = ParamUtil.getString(actionRequest, Constants.CMD);
\end{verbatim}

Then the \texttt{doProcessAction} method checks whether an entry-related
upload occurred or handles any exceptions the upload throws. Based on
the command (stored in \texttt{cmd}) accessed from the action request,
one of the following actions is performed:

\begin{itemize}
\tightlist
\item
  add or update an entry
\item
  delete an entry
\item
  move an entry to the Recycle Bin
\item
  restore an entry from the Recycle Bin
\item
  subscribe a user to a blog
\item
  unsubscribe a user from a blog
\end{itemize}

\texttt{EditEntryMVCActionCommand}'s \texttt{doProcessAction} method
continues with some more processing and prepares to redirect the portlet
to an appropriate view. This shows you can do as much as you need for
processing your portlet's actions.

\noindent\hrulefill

\textbf{Note}:
\href{https://github.com/liferay/liferay-blade-samples/tree/7.1/gradle/apps/action-command-portlet}{Liferay
Blade Sample \texttt{action-command-portlet}} demonstrates implementing
\texttt{MVCActionCommand} directly.

\noindent\hrulefill

Now you can create your own action URLs and \texttt{*MVCActionCommand}
classes in your applications that use Liferay's MVC framework. Your
\texttt{*MVCActionCommand}s can do whatever you need them to do.

\subsection{Related Topics}\label{related-topics-17}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-an-mvc-portlet}{Creating
an MVC Portlet}

\href{/docs/7-1/tutorials/-/knowledge_base/t/mvc-render-command}{MVC
Render Command}

\href{/docs/7-1/tutorials/-/knowledge_base/t/mvc-resource-command}{MVC
Resource Command}

\href{/docs/7-1/tutorials/-/knowledge_base/t/overriding-mvc-commands}{MVC
Command Overrides}

\section{MVC Render Command}\label{mvc-render-command}

If you're here, that means you know that \texttt{MVCRenderCommand}s are
used to
\href{/docs/7-1/tutorials/-/knowledge_base/t/writing-controller-code\#render-logic}{respond
to portlet render URLs}, and you want to know how to create and use MVC
render commands. If you just want to learn about Liferay's MVC Portlet
framework in general, that information is in a
\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-mvc-portlet}{separate
article}.

First,
\href{configuring-the-view-layer\#configuring-the-view-layer}{configure
your view layer} and use the
\href{https://docs.liferay.com/dxp/portal/7.1-latest/taglibs/util-taglib/portlet/renderURL.html}{\texttt{\textless{}portlet:renderURL\textgreater{}}}
to create the render URL in your JSP. For example, the following render
URL invokes an MVC render command named \texttt{/hello/edit\_entry}.
This might direct the user to a page with a form for editing.

\begin{verbatim}
<portlet:renderURL var="editEntryURL">
    <portlet:param name="mvcRenderCommandName" value="/hello/edit_entry" />
    <portlet:param name="entryId" value="<%= String.valueOf(entry.getEntryId()) %>" />
</portlet:renderURL>
\end{verbatim}

The \texttt{\textless{}portlet:param\textgreater{}} named
\texttt{mvcRenderCommandName} declares the render URL. The
\texttt{\textless{}portlet:param\textgreater{}} named \texttt{entryId}
declares a variable to hold the portlet render URL object. Assign that
variable to a UI component such, as a button or menu item. When the user
triggers the UI component, the \texttt{*MVCRenderCommand} class that
matches the render URL processes the render request and response.

What is it you want to do when a particular portlet render URL is
invoked? By implementing the
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/bridges/mvc/MVCRenderCommand.html}{\texttt{MVCRenderCommand}
interface} and overriding its \texttt{render} method, you can perform
your own logic to render JSPs. Some \texttt{*MVCRenderCommand}s, such as
the one below, always render the same JSP.

\begin{verbatim}
public class BlogsViewMVCRenderCommand implements MVCRenderCommand {

    @Override
    public String render(
        RenderRequest renderRequest, RenderResponse renderResponse) {

        return "/blogs/view.jsp";
    }

}
\end{verbatim}

Other \texttt{*MVCRenderCommand}s render JSPs based on conditions:

\begin{verbatim}
@Override
public String render(
    RenderRequest renderRequest, RenderResponse renderResponse)
    throws PortletException {

    try {
        ActionUtil.getEntry(renderRequest);
    }
    catch (Exception e) {
        if (e instanceof NoSuchEntryException ||
            e instanceof PrincipalException) {

            SessionErrors.add(renderRequest, e.getClass());

            return "/hello/error.jsp";
        }
        else {
            throw new PortletException(e);
        }
    }

    return "/hello/edit_entry.jsp";
}
\end{verbatim}

In the method above, if no exceptions are thrown on invoking
\texttt{ActionUtil.getEntry}, the method renders
\texttt{/hello/edit\_entry.jsp}. If a \texttt{NoSuchEntryException} is
thrown, it renders \texttt{/hello/error.jsp}. If any other exception is
thrown, the method re-throws it as a \texttt{PortletException}.

To respond to a particular render URL, your \texttt{MVCRenderCommand}
must be an OSGi Declarative Services Component (e.g., annotated with
@Component) that specifies these properties:

\begin{itemize}
\tightlist
\item
  \texttt{javax.portlet.name}
\item
  \texttt{mvc.command.name}
\end{itemize}

Here's an example of these two properties:

\begin{verbatim}
 "javax.portlet.name=" + HelloWorldPortletKeys.HELLO_WORLD,
 "mvc.command.name=/hello/edit_entry"
\end{verbatim}

The portlet name, in this case, is defined by the constant
\texttt{HelloWorldPortletKeys.HELLO\_WORLD}. The
\texttt{mvc.command.name} is set to \texttt{/hello/edit\_entry}, which
seems to indicate the MVC render command is related to editing
entries--just a hunch.

The Component must also publish to the OSGi runtime as a
\texttt{MVCRenderCommand.class} service. Here's a basic Component that
specifies the example properties and publishes itself as an
\texttt{MVCRenderCommand.class} service:

\begin{verbatim}
@Component(
    immediate = true,
    property = {
       "javax.portlet.name=" + HelloWorldPortletKeys.HELLO_WORLD,
       "mvc.command.name=/hello/edit_entry"
    },
    service = MVCRenderCommand.class
)
public class EditEntryMVCRenderCommand implements MVCRenderCommand {
    ...
}
\end{verbatim}

The \texttt{mvc.command.name} value \texttt{/hello/edit\_entry} matches
the value of \texttt{portlet:renderURL}'s \texttt{mvcRenderCommand}
parameter shown earlier. That render URL invokes this
\texttt{*MVCRenderCommand} class. In fact, any render URL of JSPs in
this portlet (\texttt{HelloWorldPortletKeys.HELLO\_WORLD}) whose
\texttt{mvcRenderCommand} is \texttt{/hello/edit\_entry} invokes this
\texttt{*MVCRenderCommand}.

To make an \texttt{MVCRenderCommand} respond to multiple portlets, add
them to your \texttt{@Component} as \texttt{javax.portlet.name}
properties assigned to the portlet names. Likewise, to make it respond
to multiple render URLs, add them as \texttt{mvc.command.name}
properties. If you're really feeling wild, you can specify multiple
portlets and multiple command URLs in the same command component, like
this:

\begin{verbatim}
@Component(
    immediate = true,
    property = {
       "javax.portlet.name=" + HelloWorldPortletKeys.HELLO_MY_WORLD,
       "javax.portlet.name=" + HelloWorldPortletKeys.HELLO_WORLD,
       "mvc.command.name=/hello/edit_super_entry",
       "mvc.command.name=/hello/edit_entry"
    },
    service = MVCRenderCommand.class
)
\end{verbatim}

As you can see, MVC render commands are easy to implement and can
respond to multiple command names for multiple portlets.

\subsection{Related Topics}\label{related-topics-18}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-an-mvc-portlet}{Creating
an MVC Portlet}

\href{/docs/7-1/tutorials/-/knowledge_base/t/mvc-resource-command}{MVC
Resource Command}

\href{/docs/7-1/tutorials/-/knowledge_base/t/mvc-action-command}{MVC
Action Command}

\href{/docs/7-1/tutorials/-/knowledge_base/t/overriding-mvc-commands}{MVC
Command Overrides}

\section{MVC Resource Command}\label{mvc-resource-command}

When using Liferay's MVC framework, you can create resource URLs in your
JSPs to retrieve images, XML, or any other kind of resource from a
Liferay instance. The resource URL then invokes the corresponding MVC
resource command class (\texttt{*MVCResourceCommand}) that processes the
resource request and response.

First,
\href{configuring-the-view-layer\#configuring-the-view-layer}{configure
your view layer} and use the
\href{https://docs.liferay.com/dxp/portal/7.1-latest/taglibs/util-taglib/portlet/resourceURL.html}{\texttt{\textless{}portlet:resourceURL\textgreater{}}
tag} to create the resource URL in a JSP. For example, the Login
Portlet's
\texttt{/login-web/src/main/resources/META-INF/resources/navigation/create\_account.jsp}
file defines the following resource URL for retrieving a CAPTCHA image
during account creation:

\begin{verbatim}
<portlet:resourceURL id="/login/captcha" var="captchaURL" />
\end{verbatim}

The \texttt{id} attribute declares the resource URL. The \texttt{var}
attribute declares a variable to hold the portlet resource URL object.
Assign that variable to a UI component, such as a button or icon. When
the user triggers the UI component, the \texttt{*MVCResourceCommand}
class that matches the resource URL processes the resource request and
response. You can create this class by implementing the
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/bridges/mvc/MVCResourceCommand.html}{\texttt{MVCResourceCommand}
interface} or extending the
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/bridges/mvc/BaseMVCResourceCommand.html}{\texttt{BaseMVCResourceCommand}
class}. The latter may save you time, since it already implements
\texttt{MVCResourceCommand}.

Also, it's a good idea to name your \texttt{*MVCResourceCommand} class
after the resource it handles and suffix it with
\texttt{MVCResourceCommand}. For example, the resource command class
matching the preceding CAPTCHA resource URL in the Login Portlet is
\href{https://github.com/liferay/liferay-portal/blob/master/modules/apps/login/login-web/src/main/java/com/liferay/login/web/internal/portlet/action/CaptchaMVCResourceCommand.java}{\texttt{CaptchaMVCResourceCommand}}.
In an application with several MVC command classes, this helps
differentiate them.

Your \texttt{*MVCResourceCommand} class must also have an
\texttt{@Component} annotation like the following example. Set the
property \texttt{javax.portlet.name} to your portlet's internal ID, and
the property \texttt{mvc.command.name} to the value of the \texttt{id}
property in your JSP's matching \texttt{resourceURL}. To register the
component in the OSGi container as using the \texttt{MVCResourceCommand}
class, you must set the \texttt{service} property to
\texttt{MVCResourceCommand.class}:

\begin{verbatim}
@Component(
    immediate = true,
    property = {
        "javax.portlet.name=your_portlet_name_YourPortlet",
        "mvc.command.name=/your/jsp/resource/url"
    },
    service = MVCResourceCommand.class
)
public class YourMVCResourceCommand implements MVCResourceCommand {
    // your resource handling code
}
\end{verbatim}

As a real-world example, consider the Login Portlet's
\texttt{CaptchaMVCResourceCommand} class (find this class in the Liferay
source code at
\texttt{modules/apps/login/login-web/src/main/java/com/liferay/login/web/internal/portlet/action/CaptchaMVCResourceCommand.java}):

\begin{verbatim}
@Component(
    property = {
        "javax.portlet.name=" + LoginPortletKeys.FAST_LOGIN,
        "javax.portlet.name=" + LoginPortletKeys.LOGIN,
        "mvc.command.name=/login/captcha"
    },
    service = MVCResourceCommand.class
)
public class CaptchaMVCResourceCommand implements MVCResourceCommand {

    @Override
    public boolean serveResource(
        ResourceRequest resourceRequest, ResourceResponse resourceResponse) {
        
        try {
            CaptchaUtil.serveImage(resourceRequest, resourceResponse);

            return false;
        }
        catch (Exception e) {
            _log.error(e, e);
            
            return true;
        }
    }

    private static final Log _log = LogFactoryUtil.getLog(
        CaptchaMVCResourceCommand.class);
}
\end{verbatim}

In the \texttt{@Component} annotation, note that
\texttt{javax.portlet.name} has two different settings. This lets
multiple portlets use the same component. In this example, the portlet
IDs are defined as constants in the
\href{https://docs.liferay.com/dxp/apps/foundation/7.0.8/javadocs/com/liferay/login/web/constants/LoginPortletKeys.html}{\texttt{LoginPortletKeys}
class}. Also note that the \texttt{mvc.command.name} property setting
\texttt{/login/captcha} matches the \texttt{resourceURL}'s \texttt{id}
setting shown earlier in this tutorial, and that the \texttt{service}
property is set to \texttt{MVCResourceCommand.class}.

The \texttt{CaptchaMVCResourceCommand} class implements the
\texttt{MVCResourceCommand} interface with only a single method:
\texttt{serveResource}. This method processes the resource request and
response via the \texttt{javax.portlet.ResourceRequest} and
\texttt{javax.portlet.ResourceResponse} parameters, respectively. Note
that the \texttt{try} block uses the helper class
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/captcha/CaptchaUtil.html}{\texttt{CaptchaUtil}}
to serve the CAPTCHA image. Though you don't have to create such a
helper class, doing so often simplifies your code.

Great! Now you know how to use \texttt{MVCResourceCommand} to process
resources in your Liferay MVC portlets.

\subsection{Related Topics}\label{related-topics-19}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-an-mvc-portlet}{Creating
an MVC Portlet}

\href{/docs/7-1/tutorials/-/knowledge_base/t/mvc-render-command}{MVC
Render Command}

\href{/docs/7-1/tutorials/-/knowledge_base/t/mvc-action-command}{MVC
Action Command}

\href{/docs/7-1/tutorials/-/knowledge_base/t/overriding-mvc-commands}{MVC
Command Overrides}

\href{/docs/7-1/tutorials/-/knowledge_base/t/osgi-basics-for-liferay-development}{OSGi
Basics for Liferay Development}

\chapter{Liferay Soy Portlet}\label{liferay-soy-portlet}

A Soy portlet is an extension of Liferay's MVC portlet framework. This
gives you access to all the MVC Portlet functionality you are familiar
with, plus the added bonus of using Soy templates for writing your
front-end. Soy templates use an easy templating language that also lets
you use MetalJS components. With all these benefits and more, Soy
portlets can be a good front-end tool to have in your utility belt.

You can learn about Liferay MVC portlets in the
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-an-mvc-portlet}{Creating
an MVC Portlet} tutorial.

This section covers how to implement a Soy portlet.

\section{Creating a Soy Portlet}\label{creating-a-soy-portlet}

To create a Soy portlet, you'll need these key components:

\begin{itemize}
\tightlist
\item
  A module that publishes a portlet component with the necessary
  properties
\item
  Controller code to handle the request and response
\item
  Soy templates to implement your view layer
\end{itemize}

\subsection{Configuring the Web
Module}\label{configuring-the-web-module}

First, familiarize yourself with a Soy portlet's anatomy. You may
recognize it, since a Soy portlet extends an MVC portlet:

\begin{itemize}
\tightlist
\item
  \texttt{my-soy-portlet}

  \begin{itemize}
  \tightlist
  \item
    \texttt{bnd.bnd}
  \item
    \texttt{build.gradle}
  \item
    \texttt{package.json}
  \item
    \texttt{src/main/}

    \begin{itemize}
    \tightlist
    \item
      \texttt{java/path/to/portlet/}

      \begin{itemize}
      \tightlist
      \item
        \texttt{MySoyPortletRegister.java}
      \item
        \texttt{action/}

        \begin{itemize}
        \tightlist
        \item
          \texttt{*MVCRenderCommand.java}
        \end{itemize}
      \end{itemize}
    \item
      \texttt{resources/META-INF/resources/}

      \begin{itemize}
      \tightlist
      \item
        \texttt{content/}

        \begin{itemize}
        \tightlist
        \item
          \texttt{Language.properties}
        \end{itemize}
      \item
        \texttt{View.es.js} (MetalJS component)
      \item
        \texttt{View.soy} (Soy template)
      \end{itemize}
    \end{itemize}
  \end{itemize}
\end{itemize}

Now that you know the basic structure of a Soy portlet module, you can
configure it. You can use the
\href{/docs/7-1/reference/-/knowledge_base/r/soy-portlet-template}{soy
portlet Blade template} to build your initial project if you wish.
Otherwise, you can follow the instructions in this section to manually
configure the module.

\subsubsection{Specifying OSGi Metadata}\label{specifying-osgi-metadata}

Add the OSGi metadata to your module's \texttt{bnd.bnd} file. A sample
BND configuration is shown below:

Bundle-Name: Liferay Hello Soy Web Bundle-SymbolicName:
com.liferay.hello.soy.web Bundle-Version: 2.0.7 Provide-Capability:\\
soy;\\
type=``hello-soy'';\\
version:Version=``1.0.10'' Require-Capability:\\
soy;\\
filter:=``(type=metal)'' Web-ContextPath: /hello-soy-web

The \texttt{Provide-Capability} header specifies that this bundle
provides the soy capability, so the template engine can track the
bundle. The \texttt{Require-Capability} header specifies that the bundle
requires modules that provide the capability \texttt{soy} with a
\texttt{type} of \texttt{metal} to work. The \texttt{Web-ContextPath}
header specifies the relative path of the application so you can
reference resources.

\subsubsection{Specifying JavaScript
Dependencies}\label{specifying-javascript-dependencies}

Specify the JavaScript module dependencies in your
\texttt{package.json}. At a minimum, you should have the following
dependencies and configuration parameters. Always use the latest
component versions (the versions shown below may not be the latest).

\begin{verbatim}
{
    "dependencies": {
        "metal-component": "^2.16.8",
        "metal-soy": "^2.16.8"
    },
    "scripts": {
        "build": "liferay-npm-scripts build",
        "checkFormat": "liferay-npm-scripts check",
    "format": "liferay-npm-scripts fix"
    },
    "name": "my-portlet-name",
    "version": "1.0.0"
}
\end{verbatim}

This provides everything you need to create a Metal component based on
Soy. Note that the \texttt{version} in your \texttt{package.json} should
match the \texttt{Bundle-Version} in your \texttt{bnd.bnd} file.

Next you can specify your module's build dependencies.

\subsubsection{Specifying Build
Dependencies}\label{specifying-build-dependencies}

Add the dependencies shown below to your \texttt{build.gradle} file:

\begin{verbatim}
dependencies {
    compileOnly group: "com.liferay", name: "com.liferay.portal.portlet.bridge.soy.api", version: "1.0.0"
    compileOnly group: "com.liferay.portal", name: "com.liferay.portal.kernel", version: "2.0.0"
    compileOnly group: "com.liferay.portal", name: "com.liferay.util.java", version: "3.0.0"
    compileOnly group: "javax.portlet", name: "portlet-api", version: "3.0.0"
    compileOnly group: "javax.servlet", name: "javax.servlet-api", version: "3.0.1"
    compileOnly group: "org.osgi", name: "org.osgi.service.component.annotations", version: "1.3.0"
}
\end{verbatim}

\noindent\hrulefill

\textbf{Note:} These are current at the time of this writing, but may
change. Please check the \href{https://repository.liferay.com}{Nexus
Repository} for the proper versions for your Liferay DXP instance.

\noindent\hrulefill

Now that your module build is configured, you can learn how to create
the Soy portlet component.

\subsection{Creating a Soy Portlet Register
Component}\label{creating-a-soy-portlet-register-component}

Create a Soy Portlet component that extends the
\texttt{SoyPortletRegister} class. This\\
requires an implementation of the \texttt{javax.portlet.Portlet} service
to run. Declare this using an \texttt{@Component} annotation in the
portlet class:

\begin{verbatim}
@Component(
    immediate = true,
    service = SoyPortletRegister.class
)
public class MySoyPortletRegister extends SoyPortletRegister {
  
}
\end{verbatim}

Liferay DXP's
\href{https://github.com/liferay/liferay-portal/blob/7.1.x/modules/apps/portal-portlet-bridge/portal-portlet-bridge-soy-api/src/main/java/com/liferay/portal/portlet/bridge/soy/SoyPortletRegister.java}{\texttt{SoyPortletRegister}
class} is imported in the
\href{https://github.com/liferay/com-liferay-portal-portlet-bridge/blob/7.1.x/portal-portlet-bridge-soy/src/main/java/com/liferay/portal/portlet/bridge/soy/SoyPortlet.java}{\texttt{SoyPortlet}
class} which extends
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/bridges/mvc/MVCPortlet.html}{\texttt{MVCPortlet}
class}, which is an extension itself of \texttt{javax.portlet.Portlet},
so you've provided the right implementation.

The component requires some properties as well. A sample configuration
is shown below:

\begin{verbatim}
@Component(
        immediate = true,
        property = {
          "com.liferay.portlet.add-default-resource=true",
            "com.liferay.portlet.application-type=full-page-application",
            "com.liferay.portlet.application-type=widget",
            "com.liferay.portlet.display-category=category.sample",
            "com.liferay.portlet.layout-cacheable=true",
            "com.liferay.portlet.preferences-owned-by-group=true",
            "com.liferay.portlet.private-request-attributes=false",
            "com.liferay.portlet.private-session-attributes=false",
            "com.liferay.portlet.render-weight=50",
            "com.liferay.portlet.scopeable=true",
            "com.liferay.portlet.single-page-application=false",
            "com.liferay.portlet.use-default-template=true",
            "javax.portlet.display-name=Hello Soy Portlet",
            "javax.portlet.expiration-cache=0",
            "javax.portlet.init-param.copy-request-parameters=true",
            "javax.portlet.init-param.template-path=/META-INF/resources/",
            "javax.portlet.init-param.view-template=View",
            "javax.portlet.name=hello_soy_portlet",
            "javax.portlet.resource-bundle=content.Language",
            "javax.portlet.security-role-ref=guest,power-user,user",
            "javax.portlet.supports.mime-type=text/html"
        },
        service = SoyPortletRegister.class
)
\end{verbatim}

Some of these properties may seem familiar to you, as they are the same
ones used to develop an MVC portlet. You can find a full list of the
available Liferay-specific portlet component properties in the
\href{https://docs.liferay.com/dxp/portal/7.1-latest/definitions/liferay-portlet-app_7_1_0.dtd.html}{\texttt{liferay-portlet-app\_7\_1\_0.dtd}}.

The \texttt{javax.portlet...} properties are elements of the
\href{http://java.sun.com/xml/ns/portlet/portlet-app_2_0.xsd}{portlet.xml
descriptor}

Liferay's DTD files can be found
\href{https://docs.liferay.com/dxp/portal/7.1-latest/definitions/}{here}

Now that you've set your Soy portlet component's foundation, you can
write the controller code.

\subsection{Writing Controller Code}\label{writing-controller-code-1}

Soy portlets extend MVC portlets, so they use the same
Model-View-Controller framework to operate. Your controller receives
requests from the front-end and data from the back-end. It's responsible
for sending that data to the right front-end view so it can be displayed
to the user, and it's responsible for taking data the user entered in
the front-end and passing it to the right back-end service. For this
reason, it needs a way to process requests from the front-end and
respond to them appropriately, and it needs a way to determine the
appropriate front-end view to pass data back to the user.

\subsubsection{Render Logic}\label{render-logic-1}

The render logic is where all the magic happens. After all, what's the
use of a portlet if you can't see it? Note the \texttt{init-param}
properties you set in your Component class:

\begin{verbatim}
"javax.portlet.init-param.template-path=/",
"javax.portlet.init-param.view-template=View",
\end{verbatim}

This directs the default rendering to View (\texttt{View.soy}). The
\texttt{template-path} property specifies the location of your Soy
templates. The \texttt{/} above means that the Soy files are located in
the project's root \texttt{resources} folder. That's why it's important
to follow the standard folder structure, outlined above. Here's the path
of a hypothetical web module's resource folder:

\begin{verbatim}
docs.liferaysoy.web/src/main/resources/META-INF/resources
\end{verbatim}

In this case, the \texttt{View.soy} file is found at:

\begin{verbatim}
docs.liferaysoy.web/src/main/resources/META-INF/resources/View.soy
\end{verbatim}

That's the default view of the application. When the \texttt{init}
method is called, the initialization parameters you specify are read and
used to direct rendering to the default template. Throughout this
framework, you can render a different view (Soy template) by setting the
\texttt{mvcRenderCommandName} parameter of the
\texttt{javax.portlet.PortletURL} to the Soy template that you want to
render. The example below uses a portlet URL called
\texttt{navigationURL} to render the view \texttt{View}:

\begin{verbatim}
navigationURL.setParameter("mvcRenderCommandName", "View");
\end{verbatim}

Each view, excluding the default template view, \textbf{must have} an
implementation of the
\href{/docs/7-1/tutorials/-/knowledge_base/t/mvc-render-command}{\texttt{MVCRenderCommand}
class}. The \texttt{*MVCRenderCommand} implementation must declare
itself as a component with the \texttt{MVCRenderCommand} service, and it
must specify the portlet's name and MVC command name using the
\texttt{javax.portlet.name} and \texttt{mvc.command.name} properties
respectively. Below is an example \texttt{MVCRenderCommand}
implementation for a \texttt{Navigation} Soy template:

\begin{verbatim}
@Component(
        immediate = true,
        property = {
                "javax.portlet.name=hello_soy_portlet",
                "mvc.command.name=Navigation"
        },
        service = MVCRenderCommand.class
)
public class HelloSoyNavigationExampleMVCRenderCommand
        implements MVCRenderCommand {

        @Override
        public String render(
                RenderRequest renderRequest, RenderResponse renderResponse) {

                Template template = (Template)renderRequest.getAttribute(
                        WebKeys.TEMPLATE);

                PortletURL navigationURL = renderResponse.createRenderURL();

                navigationURL.setParameter("mvcRenderCommandName", "View");

                template.put("navigationURL", navigationURL.toString());

                return "Navigation";
        }

}
\end{verbatim}

The render logic provides the view layer with information to display the
data properly to the user. Below is an explanation of the example above:

\begin{itemize}
\tightlist
\item
  The MVC command name is \texttt{Navigation} (the Soy template with
  namespace \texttt{Navigation}). This means that this logic is for the
  \texttt{Navigation} view.
\item
  A \texttt{PortletURL} (\texttt{navigationURL}) is defined and its
  \texttt{mvcRenderCommandName} is set to \texttt{View}(the Soy template
  with namespace \texttt{View}).
\item
  The \texttt{navigationURL} is converted to a \texttt{String} and
  passed as the variable \texttt{navigationURL} to the
  \texttt{Navigation} Soy template with the \texttt{template.put()}
  method.
\end{itemize}

Note that Soy portlet parameters are scoped to the portlet class they're
written in. For instance, you can have a \texttt{navigationURL}
parameter in two different classes, each with a different value. Below
is an example \texttt{HelloSoyViewMVCRenderCommand} class that also
defines a \texttt{navigationURL} parameter:

\begin{verbatim}
public class HelloSoyViewMVCRenderCommand implements MVCRenderCommand {

@Override
public String render(
        RenderRequest renderRequest, RenderResponse renderResponse) {

        Template template = (Template)renderRequest.getAttribute(
            WebKeys.TEMPLATE);

        ThemeDisplay themeDisplay = (ThemeDisplay)renderRequest.getAttribute(
            WebKeys.THEME_DISPLAY);

        template.put("layouts", themeDisplay.getLayouts());

        PortletURL navigationURL = renderResponse.createRenderURL();

        navigationURL.setParameter("mvcRenderCommandName", "Navigation");

        template.put("navigationURL", navigationURL.toString());

        template.put("releaseInfo", ReleaseInfo.getReleaseInfo());

        return "View";
    }

}
\end{verbatim}

Below is an explanation of the example above:

\begin{itemize}
\tightlist
\item
  The \texttt{navigationURL} points to the \texttt{Navigation} Soy
  template this time.
\item
  The \texttt{navigationURL} and \texttt{releaseInfo} parameters are
  passed to the \texttt{View} Soy template.
\item
  Since this logic should be executed before the default \texttt{render}
  method, the method concludes by calling \texttt{super.render}.
\end{itemize}

Now that you understand the render logic, you can learn how the view
layer works.

\subsection{Configuring the View
Layer}\label{configuring-the-view-layer-1}

Your portlet also requires a view layer, and for that you'll use Soy
templates, which is the whole point of developing a Soy portlet, isn't
it? This section briefly covers how to get your view layer working, from
including other Soy templates, to creating a MetalJS component for
rendering your views.

Soy templates are defined in a file with the extension \texttt{.soy}.
The filename is arbitrary. The Soy template's name is specified at the
top of the template using the \texttt{namespace} declaration. For
example, the declaration below is for a \texttt{View} template:

\begin{verbatim}
{namespace View}
\end{verbatim}

It can be accessed in another Soy template by calling the
\texttt{render} method on the namespace as shown below. The
\texttt{data=\textquotesingle{}all\textquotesingle{}} attribute
specifies that the template should include all its parameters as well:

\begin{verbatim}
{call View.render data="all"}{/call}
\end{verbatim}

\noindent\hrulefill

\textbf{Note:} Template namespaces must be unique.

\noindent\hrulefill

Below is an example \texttt{View} Soy template that includes
\texttt{Header} and \texttt{Footer} Soy templates:

\begin{verbatim}
{namespace View}

/**
 * Prints the portlet main view.
 */
{template .render}
  <div id="{$id}">
    {call Header.render data="all"}{/call}

    <p>{msg desc=""}here-is-a-message{/msg}</p>

    {call Footer.render data="all"}{/call}
  </div>
{/template}
\end{verbatim}

Each view has a corresponding \texttt{*es.js} file (usually with the
same name) that imports the Soy templates the view requires and
registers the view as a MetalJS component. This file is also used for
any additional JavaScript logic your view may have. For example, here is
a \texttt{View.es.js} component for a \texttt{View.soy} template:

\begin{verbatim}
import Component from 'metal-component/src/Component';
import Footer from './Footer.es';
import Header from './Header.es';
import Soy from 'metal-soy/src/Soy';
import templates from './View.soy';

/**
 * View Component
 */
class View extends Component {}

// Register component
Soy.register(View, templates);

export default View;
\end{verbatim}

Now that you understand how to configure a Soy template view, you can
learn how to use portlet parameters in your Soy templates next.

\subsubsection{Using Portlet Template Parameters in the Soy
Template}\label{using-portlet-template-parameters-in-the-soy-template}

As mentioned above, the \texttt{template.put()} method exposes portlet
parameters to the Soy templates. Once a parameter is exposed, you can
access it in the Soy template by defining it at the top with the
\texttt{@param\ name} declaration. For instance, the
\texttt{hello-soy-web} portlet's \texttt{View} Soy template defines the
\texttt{navigationURL} parameter with the code below:

\begin{verbatim}
@param navigationURL
\end{verbatim}

It is then used to navigate between portlet views:

\begin{verbatim}
<a href="{$navigationURL}">{msg desc=""}
    click-here-to-navigate-to-another-view
{/msg}</a>
\end{verbatim}

Some Java theme object variables are available as well. For example, to
access the
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/theme/ThemeDisplay.html}{\texttt{ThemeDisplay}
object} in a Soy template, use the following syntax:

\begin{verbatim}
{$themeDisplay}
\end{verbatim}

You can also access the \texttt{Locale} object by using
\texttt{\{\$locale\}}. Here is the full \texttt{View.soy} template for
the \texttt{com.liferay.hello.soy.web} portlet, which demonstrates the
features covered in this section:

\begin{verbatim}
{namespace View}

/**
 * Prints the Hello Soy portlet main view.
 *
 * @param id
 * @param layouts
 * @param navigationURL
 */
{template .render}
    <div id="{$id}">
        {call Header.render data="all"}{/call}

        <p>
      {msg desc=""}here-you-will-find-how-easy-it-is-to-do-things-like{/msg}
    </p>

        <h3>{msg desc=""}listing-pages{/msg}</h3>

        <div class="list-group">
            <div class="list-group-heading">{msg desc=""}navigate-to{/msg}</div>

            {foreach $layout in $layouts}
                <a class="list-group-item" href="{$layout.friendlyURL}">
          {$layout.nameCurrentValue}
        </a>
            {/foreach}
        </div>

        <h3>{msg desc=""}navigating-between-views{/msg}</h3>

        <a href="{$navigationURL}">
      {msg desc=""}click-here-to-navigate-to-another-view{/msg}
    </a>

        {call Footer.render data="all"}{/call}
    </div>
{/template}
\end{verbatim}

Now you know how to create a Soy Portlet!

\subsection{Related Topics}\label{related-topics-20}

\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-mvc-portlet}{Liferay
MVC Portlet}

\chapter{The State Object}\label{the-state-object}

MetalJS's \texttt{component} class, which your
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-a-soy-portlet\#configuring-the-view-layer}{view
component} extends, extends MetalJS's \texttt{state} class. The
\texttt{state} class provides a \texttt{STATE} object that contains
state properties and watches these properties for changes. Any
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-a-soy-portlet\#using-portlet-template-parameters-in-the-soy-template}{template
parameters} defined in your portlet classes are added automatically as
properties to the portlet's \texttt{STATE} object. The
\texttt{component} class provides additional rendering logic, such as
automatically re-rendering the component when the \texttt{state} class
detects a change in a state property. This means that you can
\href{/docs/7-1/tutorials/-/knowledge_base/t/configuring-soy-portlet-template-parameters-on-the-client-side}{change
a state property on the client side} and automatically see that change
reflected in the component's UI!

This section of tutorials covers how to configure and use your Soy
portlet's \texttt{STATE} object.

\section{Understanding The State Object's
Architecture}\label{understanding-the-state-objects-architecture}

An example \texttt{STATE} object configuration appears below:

\begin{verbatim}
View.STATE {
  myStateProperty: {
    setter: 'setterFunction',
    validator: val => val === expected value,
    value: default value,
    valueFn: val => default value,
    writeOnce: true
  }
}
\end{verbatim}

State properties have these configuration options:

\textbf{setter:} Normalizes the state key's value. The setter function
receives the new value that was set and returns the value that should be
stored.

\textbf{validator:} Validates the state key's value. When it returns
\texttt{false}, the new value is ignored.

\textbf{value:} The state key's default value. Alternatively, you can
set the default value with the \texttt{valueFn} property. Setting this
to an object causes all class instances to use the same reference to the
object. To have each instance use a different reference for objects, use
the \texttt{valueFn} option instead. Note that the portlet template
parameter's value (if applicable) has priority over this value.

\textbf{valueFn:} A function that returns the state key's default value.
Alternatively, you can set the default value with the \texttt{value}
property. Note that the portlet template parameter's value (if
applicable) has priority over this value.

\textbf{writeOnce:} Whether the state key is read-only, meaning the
initial value is the final value.

Now you know the \texttt{STATE} object's architecture and how to
configure it!

\subsection{Related Topics}\label{related-topics-21}

\href{/docs/7-1/tutorials/-/knowledge_base/t/configuring-portlet-template-parameter-state-properties}{Configuring
Portlet Template Parameter State Properties}

\href{/docs/7-1/tutorials/-/knowledge_base/t/configuring-soy-portlet-template-parameters-on-the-client-side}{Configuring
Soy Portlet Template Parameters on the Client Side}

\section{Configuring Portlet Template Parameter State
Properties}\label{configuring-portlet-template-parameter-state-properties}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-a-soy-portlet\#using-portlet-template-parameters-in-the-soy-template}{Portlet
template parameters} are added automatically as state properties to the
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-a-soy-portlet\#configuring-the-view-layer}{view
component}'s
\href{/docs/7-1/tutorials/-/knowledge_base/t/understanding-the-state-object-architecture}{\texttt{STATE}
object}. Therefore, you can provide additional configuration options for
them in the \texttt{STATE} object. The example below sets the default
value for the portlet template parameter \texttt{color} in its
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-a-soy-portlet\#render-logic}{\texttt{*MVCRenderCommand}
class}:

\begin{verbatim}
Template template = (Template)renderRequest.getAttribute(
            WebKeys.TEMPLATE);
      
String color = "red";

template.put("color", color);
\end{verbatim}

The configuration above has the implicit state property configuration
shown below in the view's component file (\texttt{View.es.js} for
example):

\begin{verbatim}
   View.STATE {
     color: {
       value: 'red'
     }
   }
\end{verbatim}

You can provide additional settings by
\href{/docs/7-1/tutorials/-/knowledge_base/t/understanding-the-state-object-architecture}{configuring
the state Property} in the \texttt{View} component. The example below
defines a \texttt{setter} function that transforms the color's string to
upper case before adding it to the \texttt{STATE} object:

\begin{verbatim}
function setColor(color) {
  return color.toUpperCase();
}

View.STATE = {
  color: {
    setter: 'setColor'      
  }
}
\end{verbatim}

Now you know how to configure portlet template parameter state
properties!

\subsection{Related Topics}\label{related-topics-22}

\href{/docs/7-1/tutorials/-/knowledge_base/t/understanding-the-state-object-architecture}{Understanding
the State Object's Architecture}

\href{/docs/7-1/tutorials/-/knowledge_base/t/configuring-soy-portlet-template-parameters-on-the-client-side}{Configuring
Soy Portlet Template Parameters on the Client Side}

\section{Configuring Soy Portlet Template Parameters on the Client
Side}\label{configuring-soy-portlet-template-parameters-on-the-client-side}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-a-soy-portlet\#using-portlet-template-parameters-in-the-soy-template}{Portlet
template parameters} are set in the Soy Portlet's server-side code.
MetalJS's \texttt{state} class provides a
\href{/docs/7-1/tutorials/-/knowledge_base/t/understanding-the-state-object-architecture}{\texttt{STATE}
object} that exposes these parameters as properties so you can access
them on the client side. This tutorial covers how to configure your view
component's \texttt{STATE} object and its properties on the client side
so you can update the UI.

This tutorial references the example below.

\subsection{An Example Header State
Portlet}\label{an-example-header-state-portlet}

This tutorial references the example portlet covered in this section. It
includes one view with a header that reads \emph{Hello Soy} by default.

\begin{figure}
\centering
\includegraphics{./images/soy-example-portlet-start.png}
\caption{The example Soy portlet has a configurable header.}
\end{figure}

The text in the header following \emph{Hello} is provided by the
\texttt{header} state property defined in its \texttt{*mvcRenderCommand}
class:

\texttt{*MVCRenderCommand} class:

\begin{verbatim}
@Component(
    immediate = true,
    property = {
        "javax.portlet.name=MyStateSoyPortlet", "mvc.command.name=View",
        "mvc.command.name=/"
    },
    service = MVCRenderCommand.class
)
public class MyStateSoyPortletViewMVCRenderCommand
    implements MVCRenderCommand {

    @Override
    public String render(
        RenderRequest renderRequest, RenderResponse renderResponse) {

        Template template = (Template)renderRequest.getAttribute(
            WebKeys.TEMPLATE);

        String header = "Soy";

        template.put("header", header);

        return "View";
    }

}
\end{verbatim}

\texttt{View.soy}:

\begin{verbatim}
{namespace View}

/**
 * Prints the portlet main view.
 *
 * @param id: string
 * @param header: string
 */
{template .render}

    <div id="{$id}">

        <h1>Hello {$header}</h1>

        <p>You can update the header with the portlet's header State properties.</p>
    </div>
{/template}
\end{verbatim}

\subsection{Configuring the State
properties}\label{configuring-the-state-properties}

Soy Portlets are registered automatically using the
\texttt{Liferay.component} API, so you can use this API to retrieve your
portlet and update its state properties. You can test this in your
browser's developer console.

Follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open the console in your web browser.
\item
  Retrieve your portlet's component by passing the Soy portlet's ID in
  the method \texttt{Liferay.component()}. Here's an example
  configuration:

\begin{verbatim}
Liferay.component('_MyStateSoyPortlet_');
\end{verbatim}

  This returns the Soy portlet's component Object containing the state
  properties along with properties inherited from the prototype.
  Alternatively, you can access the \texttt{STATE} object directly by
  calling the \texttt{getState()} method:

\begin{verbatim}
Liferay.component("_MyStateSoyPortlet_").getState();
\end{verbatim}
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** The `Liferay.component()` method only returns the `STATE` object
 information for components currently on the page. These are the state
 properties defined for the current view.
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\item
  Now that you retrieved your Soy portlet's component, you can access
  its state properties the same way you would access any object's
  properties: the dot notation or the bracket notation. The code below
  retrieves the example portlet's \texttt{header} state property:

\begin{verbatim}
Liferay.component("_MyStateSoyPortlet_").header;
\end{verbatim}

  or

\begin{verbatim}
Liferay.component("_MyStateSoyPortlet_")["header"]
\end{verbatim}
\item
  Update the state property's value:

\begin{verbatim}
Liferay.component("portletID").stateProperty = "new value";
\end{verbatim}

  or

\begin{verbatim}
Liferay.component("portletID")["stateProperty"] = "new value";
\end{verbatim}

  or you can pass a configuration object with the \texttt{setState()}
  method:

\begin{verbatim}
Liferay.component("portletID").setState({stateProperty: new value});
\end{verbatim}

  For example, you can change the example portlet's header to read
  \emph{Hello Hamburger} instead, if you don't like soy:

\begin{verbatim}
Liferay.component('_MyStateSoyPortlet_').setState({header: 'Hamburger'});
\end{verbatim}
\end{enumerate}

\begin{figure}
\centering
\includegraphics{./images/soy-example-portlet-fin.png}
\caption{You can change the example portlet's header state property on
the client side.}
\end{figure}

Now you know how to configure Soy portlet state properties on the client
side!

\subsection{Related Topics}\label{related-topics-23}

\href{/docs/7-1/tutorials/-/knowledge_base/t/understanding-the-state-object-architecture}{Understanding
the State Object's Architecture}

\href{/docs/7-1/tutorials/-/knowledge_base/t/configuring-portlet-template-parameter-state-properties}{Configuring
Portlet Template Parameter State Properties}

\chapter{Spring MVC}\label{spring-mvc}

Liferay is an open platform in an ecosystem of open platforms. Just
because Liferay has its own
\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-mvc-portlet}{MVC
framework} doesn't mean you have to use it. It is perfectly valid to
bring the tools and experience you have from other development projects
over to Liferay. In fact, we expect you to. Liferay's development
platform is standards-based, making it an ideal choice for applications
of almost any type.

If you're already a wizard with Spring MVC, you can use it instead of
Liferay's
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/bridges/mvc/MVCPortlet.html}{\texttt{MVCPortlet}
class} with no limitations whatsoever. Since Spring MVC replaces only
your application's web application layer, you can still use
\href{/docs/7-1/tutorials/-/knowledge_base/t/what-is-service-builder}{Service
Builder} for your service layer.

So what does it take to implement a Spring MVC application in Liferay?

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Develop as you normally do using Spring MVC.
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/configuring-a-spring-mvc-portlet}{Configure
  your application for Liferay.}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/deploying-a-spring-mvc-portlet}{Deploy
  it to Liferay.}
\end{enumerate}

Since you already have your app, you'll start with configuration.

\section{Configuring a Spring MVC
Portlet}\label{configuring-a-spring-mvc-portlet}

This isn't a comprehensive guide to configuring a Spring MVC portlet. It
covers the high points, assuming you already have familiarity with
Spring MVC. If you don't, you should consider using
\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-mvc-portlet}{Liferay's
MVC framework}.

What does a Liferay Spring MVC portlet look like? Almost identical to
any other Spring MVC portlet.

\subsection{Portlet Configuration}\label{portlet-configuration}

In the \texttt{portlet.xml} file's \texttt{portlet-class} element you
must declare Spring's \texttt{DispatcherPortlet}:

\begin{verbatim}
<portlet-class>org.springframework.web.portlet.DispatcherPortlet</portlet-class>
\end{verbatim}

The Spring front controller needs to know where the application context
file is, so specify it as an initialization parameter in the
\texttt{portlet.xml} (update the path as needed):

\begin{verbatim}
<init-param>
    <name>contextConfigLocation</name>
    <value>/WEB-INF/spring/portlet-context.xml</value>
</init-param>
\end{verbatim}

Provide an application context file (\texttt{portlet-context.xml} in the
example above), specified as you normally would for your Spring MVC
portlet. Next configure your web application.

\subsection{Web Application
Configuration}\label{web-application-configuration}

If you're
\href{/docs/7-1/tutorials/-/knowledge_base/t/using-the-wab-generator}{letting
Liferay generate the WAB for you} (this is the recommended approach),
the elements are added automatically during auto-deployment.

If you're configuring an
\href{/docs/7-1/tutorials/-/knowledge_base/t/using-the-wab-generator}{OSGi
Web Application Bundle (WAB)} yourself, the \texttt{web.xml} file in
your Spring MVC project must be fully ready for deployment. In addition
to your Spring MVC configuration, your \texttt{web.xml} must include
these elements:

\begin{itemize}
\item
  \texttt{listener} for
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/servlet/PluginContextListener.html}{\texttt{PluginContextListener}}
\item
  \texttt{servlet} and \texttt{servlet-mapping} for
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/servlet/PortletServlet.html}{\texttt{PortletServlet}}
\end{itemize}

The elements look like this:

\begin{verbatim}
<listener>
    <listener-class>com.liferay.portal.kernel.servlet.PluginContextListener</listener-class>
</listener>
<servlet>
    <servlet-name>Portlet Servlet</servlet-name>
    <servlet-class>com.liferay.portal.kernel.servlet.PortletServlet</servlet-class>
    <load-on-startup>1</load-on-startup>
</servlet>
<servlet-mapping>
    <servlet-name>Portlet Servlet</servlet-name>
    <url-pattern>/portlet-servlet/*</url-pattern>
</servlet-mapping>
\end{verbatim}

Your application must be able to convert
\texttt{javax.portlet.PortletRequest}s to
\texttt{javax.servlet.ServletRequest}s and back again. Add this to the
\texttt{web.xml}:

\begin{verbatim}
<servlet>
    <servlet-name>ViewRendererServlet</servlet-name>
    <servlet-class>org.springframework.web.servlet.ViewRendererServlet</servlet-class>
    <load-on-startup>1</load-on-startup>
</servlet>
<servlet-mapping>
    <servlet-name>ViewRendererServlet</servlet-name>
    <url-pattern>/WEB-INF/servlet/view</url-pattern>
</servlet-mapping>
\end{verbatim}

That's all the configuration that's necessary for \texttt{web.xml}. Now
you're ready to configure the views.

\subsection{Views}\label{views}

To configure the Spring view resolver, add a bean to your application
context file (\texttt{portlet-context.xml} in the previous example):

\begin{verbatim}
<bean id="viewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver">
    <property name="prefix" value="/WEB-INF/views/" />
    <property name="suffix" value=".jsp" />
</bean>
\end{verbatim}

Now the front controller,
\texttt{org.springframework.web.portlet.DispatcherPortlet}, can get a
request from the view layer, so now it's time to configure controller
classes to handle the requests.

\subsection{Controllers}\label{controllers}

With Spring MVC, your controller is conveniently separated into classes
that handle the portlet modes (View, Edit, Help).

You'll use Spring's annotations to configure the controller and tell
\texttt{DispatcherPortlet} which mode the controller supports.

\subsubsection{View Mode Controller}\label{view-mode-controller}

A simple controller class supporting View mode might look like this:

\begin{verbatim}
@Controller("myAppController")
@RequestMapping("VIEW")
public class MyAppController {

    @RenderMapping
    public String processRenderRequest(RenderRequest request,
            RenderResponse response) {

        return "defaultView";
    }
}
\end{verbatim}

The \texttt{return\ defaultView} statement should be understood in terms
of the view resolver bean in the application context file, which gives
the String \texttt{defaultView} a prefix of \texttt{WEB-INF/views/}, and
a suffix of \texttt{.jsp}. That maps to the path
\texttt{WEB-INF/views/defaultView.jsp}, where you would place your
default view for the application.

With Spring MVC, you can only support one portlet phase in each
controller.

\subsubsection{Edit Mode Controller}\label{edit-mode-controller}

An edit mode controller might contain render methods and action methods.

\begin{verbatim}
@Controller("myAppEditController")
@RequestMapping("EDIT")
public class MyAppEditController {

    @RenderMapping
    public String processRenderRequest(RenderRequest request,
            RenderResponse response) {

        return "thisView";
    }

    @ActionMapping(params="action=doSomething")
    public void doSomething(Actionrequest request, ActionResponse response){
    
        // Do something here

    }
}
\end{verbatim}

Make sure to define any controller classes in your application context
file by adding a \texttt{bean} element for each one:

\begin{verbatim}
<bean class="com.liferay.docs.springmvc.portlet.MyAppController" />
<bean class="com.liferay.docs.springmvc.portlet.MyAppEditController" />
\end{verbatim}

Develop your controllers and your views as you normally would in a
Spring MVC portlet. You must also provide some necessary descriptors for
Liferay.

\subsection{Liferay Descriptors}\label{liferay-descriptors}

Liferay portlet plugins that are packaged as WAR files should include
some Liferay specific descriptors.

The descriptor \texttt{liferay-display.xml} controls the category in
which your portlet appears in Liferay DXP's \emph{Add} menu. Find the
complete DTD
\href{https://docs.liferay.com/dxp/portal/7.1-latest/definitions/liferay-display_7_1_0.dtd.html}{here}.

Here's a simple example that specifies a new category for the
application in Liferay's menu for adding applications:

\begin{verbatim}
<display>
    <category name="New Category">
        <portlet id="example-portlet" />
    </category>
</display>
\end{verbatim}

The descriptor \texttt{liferay-portlet.xml} specifies additional
information about the portlet (like the location of CSS and JavaScript
files or the portlet's icon. A complete list of the attributes you can
set can be found
\href{https://docs.liferay.com/dxp/portal/7.1-latest/definitions/liferay-portlet-app_7_1_0.dtd.html}{here}

\begin{verbatim}
<liferay-portlet-app>
    <portlet>
        <portlet-name>example-portlet</portlet-name>
        <instanceable>true</instanceable>
        <render-weight>0</render-weight>
        <ajaxable>true</ajaxable>
        <header-portlet-css>/css/main.css</header-portlet-css>
        <footer-portlet-javascript>/js/main.js</footer-portlet-javascript>
        <footer-portlet-javascript>/js/jquery.foundation.orbit.js</footer-portlet-javascript>
    </portlet>
    <role-mapper>
        <role-name>administrator</role-name>
        <role-link>Administrator</role-link>
    </role-mapper>
    <role-mapper>
        <role-name>guest</role-name>
        <role-link>Guest</role-link>
    </role-mapper>
    <role-mapper>
        <role-name>power-user</role-name>
        <role-link>Power User</role-link>
    </role-mapper>
    <role-mapper>
        <role-name>user</role-name>
        <role-link>User</role-link>
    </role-mapper>
</liferay-portlet-app>
\end{verbatim}

\noindent\hrulefill

\textbf{Important:} Make your portlet name unique, considering how
\href{/docs/7-1/reference/-/knowledge_base/r/portlet-descriptor-to-osgi-service-property-map\#ten}{Liferay
DXP uses the name to create the portlet's ID}.

\noindent\hrulefill

You'll also notice the \texttt{role-mapper} elements included above.
They define the Liferay roles used in the portlet.

The \texttt{liferay-plugin-package.properties} file describes the
Liferay plugin, declares its resources, and specifies its security
related parameters. The DTD is
\href{https://docs.liferay.com/dxp/portal/7.1-latest/definitions/liferay-plugin-package_7_1_0.dtd.html}{here}.

\begin{verbatim}
name=example-portlet
module-group-id=liferay
module-incremental-version=1
tags=
short-description=
change-log=
page-url=http://www.liferay.com
author=Liferay, Inc.
licenses=LGPL
version=1
\end{verbatim}

In the \texttt{liferay-plugin-package.properties} file, you can also add
OSGi metadata which the
\href{/docs/7-1/tutorials/-/knowledge_base/t/using-the-wab-generator}{Liferay
WAB Generator} adds to the \texttt{MANIFEST.MF} file when you deploy
your WAR file.

All of Liferay's DTDs are
\href{https://docs.liferay.com/dxp/portal/7.1-latest/definitions/}{here}.

\subsection{Calling Services from Spring
MVC}\label{calling-services-from-spring-mvc}

To call OSGi-based Service Builder services from your Spring MVC
portlet, you need a mechanism that gives you access to the OSGi service
registry.

Since you're in the context of a Spring MVC portlet, you can't look up a
reference to the services (including Service Builder services) published
to the OSGi runtime using Declarative Services. You have to use
\href{/docs/7-1/tutorials/-/knowledge_base/t/service-trackers}{Service
Trackers}. There's some boilerplate code involved, but the ability to
look up services in the OSGi runtime is worth it.

Next consider how to package and deploy your Spring MVC portlet.

\section{Deploying a Spring MVC
Portlet}\label{deploying-a-spring-mvc-portlet}

Developers creating portlets for Liferay DXP can usually deploy their
portlet as Java EE-style Web Application ARchive (WAR) artifacts or as
Java ARchive (JAR) OSGi bundle artifacts. Spring MVC portlet developers
don't have that flexibility. Spring MVC portlets must be packaged as WAR
artifacts because the Spring MVC framework is designed for Java EE.
Therefore, it expects a WAR layout and requires Java EE resources such
as the \texttt{WEB-INF/web.xml} descriptor.

Because Liferay supports the OSGi WAB (Web Application Bundler) standard
for deployment, you can deploy your WAR and it runs as expected in the
OSGi runtime. Here are the high points on why that works in Liferay:

\begin{itemize}
\item
  The Liferay auto-deploy process runs, adding the
  \texttt{PortletServlet} and \texttt{PlugincontextListener}
  configurations to the \texttt{WEB-INF/web.xml} file.
\item
  The
  \href{/docs/7-1/tutorials/-/knowledge_base/t/using-the-wab-generator}{Liferay
  WAB Generator} automatically creates an OSGi-ready
  \texttt{META-INF/MANIFEST.MF} file. If you want to affect the content
  of the manifest file, you can place bnd directives and OSGi headers
  directly into a \texttt{WEB-INF/liferay-plugin-package.properties}
  file for the WAB.
\end{itemize}

\href{/docs/7-1/tutorials/-/knowledge_base/t/importing-packages}{Import
class packages} your portlet's descriptor files reference by adding the
packages to an \texttt{Import-Package} header in your
\texttt{liferay-plugin-package.properties} file.

Here's an example \texttt{Import-Package} header:

\begin{verbatim}
Import-Package:\
    org.springframework.beans.factory.xml,\
    org.springframework.context.config,\
    org.springframework.security.config,\
    org.springframework.web.servlet.config
\end{verbatim}

The auto-deploy process and Liferay's WAB generator convert your project
to a Liferay-ready WAB. The WAB generator detects your class's
\texttt{import} statements and adds all external packages to the WAB's
\texttt{Import-Package} header. The generator merges packages from your
plugin's \texttt{liferay-plugin-package.properties} into the header
also.

If you depend on a package from Java's \texttt{rt.jar} other than a
\texttt{java.*} package, override
\href{https://docs.liferay.com/dxp/portal/7.1-latest/propertiesdoc/portal.properties.html\#Module\%20Framework}{portal
property \texttt{org.osgi.framework.bootdelegation}} and add it to the
property's list. Go
\href{/docs/7-1/tutorials/-/knowledge_base/t/resolving-classnotfoundexception-and-noclassdeffounderror-in-osgi-bundles\#case-4-the-missing-class-belongs-to-a-java-runtime-package}{here}
for details.

\noindent\hrulefill

\textbf{Note}: Spring MVC portlets whose embedded JARs contain
properties files (e.g., \texttt{spring.handlers},
\texttt{spring.schemas}, \texttt{spring.tooling}) might be affected by
issue \href{https://issues.liferay.com/browse/LPS-75212}{LPS-75212}. The
last JAR that has properties files is the only JAR whose properties are
added to the resulting WAB's classpath. Properties in other JARs aren't
added.

For example, suppose that a portlet has several JARs containing these
properties files:

\begin{itemize}
\tightlist
\item
  \texttt{WEB-INF/src/META-INF/spring.handlers}
\item
  \texttt{WEB-INF/src/META-INF/spring.schemas}
\item
  \texttt{WEB-INF/src/META-INF/spring.tooling}
\end{itemize}

The properties from the last JAR processed are the only ones added to
the classpath. The properties files must be on the classpath in order
for the module to use them.

To add all the properties files to the classpath, you can combine them
into one of each type (e.g., one \texttt{spring.handlers}, one
\texttt{spring.schemas}, and one \texttt{spring.tooling}) and add them
to \texttt{WEB-INF/src}.

Here's a shell script that combines these files:

\begin{verbatim}
 cat /dev/null > docroot/WEB-INF/src/META-INF/spring.handlers
 cat /dev/null > docroot/WEB-INF/src/META-INF/spring.schemas
 cat /dev/null > docroot/WEB-INF/src/META-INF/spring.tooling
 for jar in $(find docroot/WEB-INF/lib/ -name '*.jar'); do
 for file in $(unzip -l $jar | grep -F META-INF/spring. | awk '
 { print $4 }
 '); do
 if [ "META-INF/spring.tld" != "$file" ]; then
 unzip -p $jar $file >> docroot/WEB-INF/src/$file
 echo >> docroot/WEB-INF/src/$file
 fi
 done
 done
\end{verbatim}

You can modify and use the shell script to add your JAR's properties
files to the classpath.

\noindent\hrulefill

\noindent\hrulefill

\textbf{Note}: If you want to use a Spring Framework version different
from the version Liferay provides, you must name your Spring Framework
JARs differently from the ones
\href{https://docs.liferay.com/ce/portal/7.1-latest/propertiesdoc/portal.properties.html\#Module\%20Framework}{portal
property \texttt{module.framework.web.generator.excluded.paths}}
excludes. If you don't rename your Spring Framework JARs, the WAB
generator assumes you're using Liferay's Spring Framework JARs and
excludes yours from the generated WAB.
\href{/docs/7-1/tutorials/-/knowledge_base/t/resolving-a-plugins-dependencies\#understanding-excluded-jars}{Understanding
Excluded JARs} explains how to detect Liferay DXP's Spring Framework
version.

\noindent\hrulefill

Once you've packaged your Spring MVC portlet as a WAR, you can deploy it
by copying it to \texttt{{[}LIFERAY\_HOME{]}/deploy}.

Congratulations on deploying your Spring MVC portlet!

\chapter{JSF Portlets with Liferay
Faces}\label{jsf-portlets-with-liferay-faces}

\includegraphics{./images/liferay-faces-logo.png}

Do you want to develop MVC-based portlets using the Java EE standard? Do
you want to use a portlet development framework with a UI component
model that makes it easy to develop sophisticated, rich UIs? Or have you
been writing web apps using JSF that you'd like to use in Liferay DXP?
If you answered \emph{yes} to any of these questions, you're in luck!
Liferay Faces provides all these capabilities and more.

Liferay Faces is an umbrella project that provides support for the
JavaServer™ Faces (JSF) standard in Liferay DXP. It encompasses the
following projects:

\begin{itemize}
\tightlist
\item
  \href{/docs/7-1/reference/-/knowledge_base/r/understanding-liferay-faces-bridge}{Liferay
  Faces Bridge} lets you deploy JSF web apps as portlets without writing
  portlet-specific Java code. It also contains innovative features that
  make it possible to leverage the power of JSF 2.x inside a portlet
  application. Liferay Faces Bridge implements the JSR 329/378 Portlet
  Bridge Standard.
\item
  \href{/docs/7-1/reference/-/knowledge_base/r/understanding-liferay-faces-alloy}{Liferay
  Faces Alloy} lets you use AlloyUI components in a way that is
  consistent with JSF development.
\item
  \href{/docs/7-1/reference/-/knowledge_base/r/understanding-liferay-faces-portal}{Liferay
  Faces Portal} lets you leverage Liferay-specific utilities and UI
  components in JSF portlets.
\end{itemize}

For a comprehensive demo for the JSF component suite, visit the
\href{http://www.liferayfaces.org}{Liferay Faces Showcase}.

If you're new to JSF, you may want to know its strengths, its
weaknesses, and how it stacks up to developing portlets with
CSS/JavaScript.

Here are some good reasons to use JSF and Liferay Faces:

\begin{itemize}
\tightlist
\item
  JSF is the Java EE standard for developing web applications that use
  the Model/View/Controller (MVC) design pattern. As a standard, the
  specification is actively maintained by the Java Community Process
  (JCP), and the Oracle reference implementation (Mojarra) has frequent
  releases. Software Architects often choose standards like JSF because
  they are supported by Java EE application server vendors and have a
  guaranteed service life according to Service Level Agreements (SLAs).
\item
  JSF was first introduced in 2003 and is a mature technology for
  developing web applications that are (arguably) easy to maintain.
\item
  JSF Portlet Bridges (like Liferay Faces Bridge) are also standardized
  by the JCP and make it possible to deploy JSF web applications as
  portlets without writing portlet-specific Java code.
\item
  Support for JSF (via Liferay Faces) is included with Liferay DXP
  support.
\item
  JSF is a unique framework in that it provides a UI component model
  that makes it easy to develop sophisticated, rich user interfaces.
\item
  JSF has built-in Ajax functionality that provides automatic updates to
  the browser by replacing elements in the DOM.
\item
  JSF is designed with many extension points that make a variety of
  integrations possible.
\item
  There are several JSF component suites available including Liferay
  Faces Alloy, Primefaces, ICEfaces, and RichFaces. Each of these
  component suites fortify JSF with a variety of UI components and
  complimentary technologies such as Ajax Push.
\item
  JSF is a good choice for server-side developers that need to build web
  user interfaces. This enables server-side developers to focus on their
  core competencies rather than being experts in HTML/CSS/JavaScript.
\item
  JSF provides the Facelets templating engine which makes it possible to
  create reusable UI components that are encapsulated as markup.
\item
  JSF provides good integration with HTML5 markup
\item
  JSF provides the Faces Flows feature which makes it easy for
  developers to create wizard-like applications that flow from
  view-to-view.
\item
  JSF has good integration with dependency injection frameworks such as
  CDI and Spring that make it easy for developers to create beans that
  are placed within a scope managed by a container:
  \texttt{@RequestScoped}, \texttt{@ViewScoped},
  \texttt{@SessionScoped}, \texttt{@FlowScoped}
\item
  Since JSF is a stateful technology, the framework encapsulates the
  complexities of managing application state so the developer doesn't
  have to write state management code. It is also possible to use JSF in
  a stateless manner, but some of the features of application state
  management become effectively disabled.
\end{itemize}

There are some reasons not to use JSF. For example, if you are a
front-end developer who makes heavy use of HTML/CSS/JavaScript, you
might find that JSF UI components render HTML in a manner that gives you
less control over the overall HTML document. Sticking with JavaScript
and leveraging AlloyUI or some other JavaScript framework may be better
for you. Or, perhaps standards aren't a major consideration for you or
you may simply prefer developing portlets using your current framework.

Whether you develop your next portlet application with JSF and Liferay
Faces or with HTML/CSS/JavaScript is entirely up to you. But you
probably want to learn more about Liferay Faces and try it out for
yourself.

\section{Generating a JSF Project from the Command
Line}\label{generating-a-jsf-project-from-the-command-line}

You can generate a Liferay Faces application without having to create
your own folder structure, descriptor files, and such manually. If you
really want to do that manually, you can examine the structure of a JSF
application and create one from scratch in the
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-a-jsf-project-manually}{Creating
a JSF Project Manually} tutorial.

!P\href{https://portal.liferay.dev/documents/113763090/113919826/jsf-vid-thumbnail.png}{Video
Thumbnail}

Before generating your JSF application, you should first visit
\href{http://liferayfaces.org/}{liferayfaces.org}, a great reference
spot for JSF application development targeted for Liferay DXP. This site
lets you choose the options for your JSF application and generates a
Maven archetype command you can execute to generate an application with
your chosen options. You can select the following archetype options:

\begin{itemize}
\tightlist
\item
  Liferay Portal Version
\item
  JSF Version
\item
  Component Suite
\end{itemize}

You can also choose a build framework (Gradle or Maven) and have a list
of dependencies generated for you and displayed on the page. The
dependencies are provided to you on the site page in a \texttt{pom.xml}
or \texttt{build.gradle} file, depending on the build type you selected.
This is useful because it gives you an idea of what dependencies are
required in your JSF application before generating it.

\textbf{Note:} Gradle developers can also use the
\texttt{archetype:generate} command because it generates both a
\texttt{build.gradle} and a \texttt{pom.xml} file for you to use.

\begin{figure}
\centering
\includegraphics{./images/jsf-app-generation.png}
\caption{You can select the Liferay Portal version, JSF version, and
component suite for your archetype generation command.}
\end{figure}

Next you'll generate an example JSF application (e.g., Liferay Portal 7
+ JSF 2.2 + JSF Standard) via command line using
\href{http://liferayfaces.org/}{liferayfaces.org}.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Navigate to \href{http://liferayfaces.org/}{liferayfaces.org} and
  select the following options:

  \begin{itemize}
  \tightlist
  \item
    \textbf{Liferay Portal:} 7
  \item
    \textbf{JSF:} 2.2
  \item
    \textbf{Component Suite:} JSF Standard
  \end{itemize}
\item
  Copy the archetype generation command and execute it. Make sure you've
  navigated to the folder where you want to generate your project.
\end{enumerate}

That's it! Your JSF application is generated in the current folder!

You can also generate a Liferay JSF application using Maven's
interactive archetype UI. To do this, execute
\texttt{mvn\ archetype:generate\ -Dfilter=liferay} and select the JSF
archetype you want to use. Then you'll step through each option and
select the version, group ID, artifact ID, etc. To learn more about
this, see the
\href{/docs/7-1/tutorials/-/knowledge_base/t/generating-new-projects-using-archetypes}{Generating
New Projects Using Archetypes} tutorial.

Once you have your JSF application generated, you can
\href{/docs/7-1/tutorials/-/knowledge_base/t/using-maven-in-liferay-ide\#importing-maven-projects}{import
it into Liferay Dev Studio DXP} and develop it further. To
\href{/docs/7-1/tutorials/-/knowledge_base/t/deploying-projects-with-liferay-ide}{deploy
it to your Liferay DXP instance}, drag and drop it onto the Liferay DXP
server.

You can build the project and deploy it to Liferay DXP from the command
line too! If you're using Gradle, run the following command to build
your JSF application:

\begin{verbatim}
../gradlew build
\end{verbatim}

For Maven, execute the following command:

\begin{verbatim}
mvn package
\end{verbatim}

Then copy the generated WAR to Liferay DXP's \texttt{deploy} folder:

\begin{verbatim}
[cp|copy] ./com.mycompany.my.jsf.portlet.war LIFERAY_HOME/deploy
\end{verbatim}

Awesome! You've generated your JSF application and deployed it using the
command line.

!V\href{https://portal.liferay.dev/documents/113763090/113919826/developing-a-new-jsf-portlet.mp4\%7Chttps://portal.liferay.dev/documents/113763090/113919826/developing-a-new-jsf-portlet.mkv}{Video
Tutorial}

\section{Generating a JSF Project Using Dev
Studio}\label{generating-a-jsf-project-using-dev-studio}

You can generate a Liferay Faces application without having to create
your own folder structure and descriptor files manually using Liferay
Dev Studio. If you're interested in creating the structure of a JSF
application manually or if you want to examine a basic JSF application
structure, visit the
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-a-jsf-project-manually}{Creating
a JSF Project Manually} tutorial.

In this tutorial, you'll generate an example JSF project using Liferay
Dev Studio. Open your Dev Studio instance to get started.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Navigate to \emph{File} → \emph{New} → \emph{Project\ldots{}}. This
  opens a new project wizard.
\item
  Select the \emph{Liferay} project and choose \emph{Liferay JSF
  Project} from the listed subprojects. Then click \emph{Next}.

  \begin{figure}
  \centering
  \includegraphics{./images/jsf-project-ide.png}
  \caption{Choose the \emph{Liferay JSF Project} option to begin
  creating a JSF project in Dev Studio.}
  \end{figure}
\item
  Assign your JSF project a name, build framework (Gradle or Maven), and
  Component Suite. You have five component suites to choose from:

  \begin{itemize}
  \tightlist
  \item
    ICEFaces
  \item
    JSF Standard
  \item
    Liferay Faces Alloy
  \item
    PrimeFaces
  \item
    RichFaces
  \end{itemize}

  \begin{figure}
  \centering
  \includegraphics{./images/new-jsf-project-ide.png}
  \caption{Choose your preferred options for your JSF project.}
  \end{figure}
\item
  Click \emph{Finish} to generate your Liferay JSF project.
\end{enumerate}

You've generated a Liferay JSF project using Dev Studio! The project you
generated contains a simple portlet that you can customize.

\begin{figure}
\centering
\includegraphics{./images/jsf-ide-generated-project.png}
\caption{The generated JSF portlet project displays basic build
information.}
\end{figure}

\noindent\hrulefill

\textbf{Note:} There is another option in Dev Studio's \emph{File} →
\emph{New} menu named \emph{Liferay JSF Portlet}. This is intended to
add portlets to existing JSF projects. Currently, this is only
configured to create Liferay Portal 6.2 JSF portlets. Do not use this
option if you're developing for 7.0.

\noindent\hrulefill

To
\href{/docs/7-1/tutorials/-/knowledge_base/t/deploying-projects-with-liferay-ide}{deploy
the new JSF project to your Liferay DXP instance}, drag and drop it onto
the Liferay server.

Fantastic! You're now able to quickly generate your Liferay JSF project
using Liferay Dev Studio!

\chapter{Creating a JSF Project
Manually}\label{creating-a-jsf-project-manually}

Liferay DXP's modular architecture lends itself well to modular
applications created using a multitude of different technologies. JSF
applications are no different and can be developed to integrate
seamlessly into the Liferay platform.

In this section of tutorials, you'll step through packaging and creating
a JSF application that is deployable as an OSGi module at runtime.

The steps you'll take are outlined below:

\begin{itemize}
\tightlist
\item
  Construct the WAR-style folder structure.
\item
  Specify the necessary dependencies in a build file of your choice.
\item
  Create JSF portlet descriptors and Liferay descriptors.
\item
  Add resource files in the two designated \texttt{resources} folders.
\item
  Define the portlet's behavior using a Java class.
\item
  Design a view XHTML form to let the user interact with the portlet.
\end{itemize}

You can examine the example JSF application solution any time during
this section by downloading its
\href{https://portal.liferay.dev/documents/113763090/114000653/hello-user-jsf-portlet.zip}{ZIP
file}.

Let's get started!

\section{Packaging a JSF Application}\label{packaging-a-jsf-application}

Developers creating portlets for 7.0 can package their portlets as Java
EE style Web Application ARchive (WAR) artifacts or as Java ARchive
(JAR) OSGi bundle artifacts. JSF portlet developers, however, must
package their portlets as WAR artifacts because the JSF framework
expects a WAR layout and often requires the
\texttt{WEB-INF/faces-config.xml} descriptor and other Java EE resources
such as the \texttt{WEB-INF/web.xml} descriptor.

Liferay provides a way for these WAR-styled portlets to be deployed and
treated like OSGi modules by Liferay's OSGi runtime. The WAB Generator
does this automatically by converting your WAR artifact to a WAB at
deployment time. You can learn more about WABs and the WAB Generator in
the
\href{/docs/7-1/tutorials/-/knowledge_base/t/using-the-wab-generator}{Using
the WAB Generator} tutorial.

This is how a JSF WAR artifact is structured:

\begin{itemize}
\tightlist
\item
  \texttt{jsf-portlet}

  \begin{itemize}
  \tightlist
  \item
    \texttt{src}

    \begin{itemize}
    \tightlist
    \item
      \texttt{main}

      \begin{itemize}
      \tightlist
      \item
        \texttt{java}

        \begin{itemize}
        \tightlist
        \item
          Java Classes
        \end{itemize}
      \item
        \texttt{resources}

        \begin{itemize}
        \tightlist
        \item
          Properties files
        \end{itemize}
      \item
        \texttt{webapp}

        \begin{itemize}
        \tightlist
        \item
          \texttt{WEB-INF/}

          \begin{itemize}
          \tightlist
          \item
            \texttt{classes/}

            \begin{itemize}
            \tightlist
            \item
              Class files and related properties
            \end{itemize}
          \item
            \texttt{lib/}

            \begin{itemize}
            \tightlist
            \item
              JAR dependencies
            \end{itemize}
          \item
            \texttt{resources/}

            \begin{itemize}
            \tightlist
            \item
              CSS, XHTML, PNG or other frontend files
            \end{itemize}
          \item
            \texttt{views/}

            \begin{itemize}
            \tightlist
            \item
              XHTML views
            \end{itemize}
          \item
            \texttt{faces-config.xml}
          \item
            \texttt{liferay-display.xml}
          \item
            \texttt{liferay-plugin-package.properties}
          \item
            \texttt{liferay-portlet.xml}
          \item
            \texttt{portlet.xml}
          \item
            \texttt{web.xml}
          \end{itemize}
        \end{itemize}
      \end{itemize}
    \end{itemize}
  \end{itemize}
\end{itemize}

Next, you'll begin creating a simple JSF application that is deployable
to Liferay DXP.

\section{Defining a JSF Application's Structure and
Dependencies}\label{defining-a-jsf-applications-structure-and-dependencies}

JSF portlets are supported on Liferay Portal by using
\href{/docs/7-1/reference/-/knowledge_base/r/understanding-liferay-faces-bridge}{Liferay
Faces Bridge}. Liferay Faces Bridge makes developing JSF portlets as
similar as possible to JSF web app development.

You'll create a simple \emph{Hello User} application that asks for the
user's name and then greets him or her with the name. You'll begin by
creating the WAR-style folder structure, and then you'll configure
dependencies like Liferay Faces Bridge.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a WAR-style folder structure for your module.
  \href{https://web.liferay.com/web/neil.griffin/blog/-/blogs/new-maven-archetypes-for-jsf-portlets}{Maven
  archetypes} are available to help you get started quickly. They set
  the default configuration for you and contain boilerplate code so you
  can skip the file creation steps and get started right away. For your
  JSF application, you'll set up the folder structure manually. Follow
  the folder structure outline below:

\begin{verbatim}
- hello-user-jsf-portlet
    - src
        - main
            - java
            - resources
            - webapp
                - WEB-INF
                    - resources
                    - views
\end{verbatim}
\item
  Make sure your module specifies the dependencies necessary for a
  Liferay JSF application. For instance, you must always specify the
  Faces API, Faces Reference Implementation (Mojarra), and Liferay Faces
  Bridge as dependencies in a Liferay-compatible JSF application. Also,
  an important, but not required, dependency is the Log4j logging
  utility. This is highly recommended for development purposes because
  it logs DEBUG messages in the console. You'll configure the logging
  utility later.

  For an example build file, the \texttt{pom.xml} file used for the
  Maven based Hello User JSF application is below. All the dependencies
  described above are configured in the Hello User JSF application's
  \texttt{pom.xml} file.

\begin{verbatim}
<?xml version="1.0"?>

<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <groupId>com.liferay</groupId>
    <artifactId>com.liferay.hello.user.jsf.portlet</artifactId>
    <packaging>war</packaging>
    <name>hello-user-jsf-portlet</name>
    <version>1.0-SNAPSHOT</version>
    <properties>
        <faces.api.version>2.2</faces.api.version>
        <liferay.faces.bridge.ext.version>5.0.3</liferay.faces.bridge.ext.version>
        <liferay.faces.bridge.version>4.1.2</liferay.faces.bridge.version>
        <mojarra.version>2.2.18</mojarra.version>
    </properties>
    <build>
        <plugins>
            <plugin>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.3</version>
                <configuration>
                    <encoding>UTF-8</encoding>
                    <source>1.8</source>
                    <target>1.8</target>
                </configuration>
            </plugin>
            <plugin>
                <artifactId>maven-war-plugin</artifactId>
                <version>2.3</version>
                <configuration>
                    <filteringDeploymentDescriptors>true</filteringDeploymentDescriptors>
                </configuration>
            </plugin>
        </plugins>
    </build>
    <dependencies>
        <dependency>
            <groupId>javax.faces</groupId>
            <artifactId>javax.faces-api</artifactId>
            <version>${faces.api.version}</version>
            <scope>provided</scope>
        </dependency>
        <dependency>
            <groupId>org.glassfish</groupId>
            <artifactId>javax.faces</artifactId>
            <version>${mojarra.version}</version>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>com.liferay.faces</groupId>
            <artifactId>com.liferay.faces.bridge.ext</artifactId>
            <version>${liferay.faces.bridge.ext.version}</version>
        </dependency>
        <dependency>
            <groupId>com.liferay.faces</groupId>
            <artifactId>com.liferay.faces.bridge.impl</artifactId>
            <version>${liferay.faces.bridge.version}</version>
        </dependency>
        <dependency>
            <groupId>log4j</groupId>
            <artifactId>log4j</artifactId>
            <version>1.2.14</version>
        </dependency>
    </dependencies>
</project>
\end{verbatim}

  There are also two plugins the Hello User JSF application defined in
  its \texttt{pom.xml}:
  \href{https://maven.apache.org/plugins/maven-compiler-plugin/}{maven-compiler-plugin}
  and
  \href{https://maven.apache.org/plugins/maven-war-plugin/}{maven-war-plugin}.
  These two plugins are responsible for building and compiling the JSF
  application using Maven.

  There are several UI component suites that a JSF application can use,
  which include
  \href{/docs/7-1/reference/-/knowledge_base/r/understanding-liferay-faces-alloy}{\emph{Liferay
  Faces Alloy}}, \href{http://primefaces.org/}{\emph{PrimeFaces}},
  \href{http://www.icesoft.org/java/projects/ICEfaces/overview.jsf}{\emph{ICEfaces}},
  and \href{http://richfaces.jboss.org/}{\emph{RichFaces}}. Furthermore,
  you can take advantage of
  \href{/docs/7-1/reference/-/knowledge_base/r/understanding-liferay-faces-portal}{\emph{Liferay
  Faces Portal}} in order to use Liferay-specific utilities and UI
  components. These components can be used by specifying them as
  dependencies in your build file, as well.
\end{enumerate}

Now that your build file is configured, you must define the JSF-specific
configurations for your application. These fall into two convenient
categories: general descriptors and Liferay descriptors. You'll start
with creating the necessary general descriptors next.

\section{Defining JSF Portlet
Descriptors}\label{defining-jsf-portlet-descriptors}

Since JSF portlets must follow a WAR-style folder structure, they must
also have WAR-style portlet descriptors.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a \texttt{portlet.xml} file in the \texttt{webapp/WEB-INF}
  folder. All portlet WARs require this file. In this file, make sure to
  declare the following portlet class:

\begin{verbatim}
<portlet>
    ...
    <portlet-class>javax.portlet.faces.GenericFacesPortlet</portlet-class>
    ...
</portlet>
\end{verbatim}

  The \texttt{javax.portlet.faces.GenericFacesPortlet} class handles
  invocations to your JSF portlet and makes your portlet, since it
  relies on Liferay Faces Bridge, easy to develop by acting as a turnkey
  implementation.
\item
  Define a default view file as an \texttt{init-param} in the
  \texttt{portlet.xml}. This ensures your portlet is visible when
  deployed to Liferay DXP.

\begin{verbatim}
<init-param>
    <name>javax.portlet.faces.defaultViewId.view</name>
    <value>/WEB-INF/views/view.xhtml</value>
</init-param>
\end{verbatim}

  You'll create this view later.

  The \texttt{portlet.xml} file holds other important details too, like
  portlet info and security settings. Look at the \texttt{portlet.xml}
  file for the example Hello User JSF application.

\begin{verbatim}
<?xml version="1.0"?>

<portlet-app xmlns="http://java.sun.com/xml/ns/portlet/portlet-app_2_0.xsd" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/portlet/portlet-app_2_0.xsd http://java.sun.com/xml/ns/portlet/portlet-app_2_0.xsd" version="2.0">
    <portlet>
        <portlet-name>hello-user-jsf-portlet</portlet-name>
        <display-name>Hello User JSF Portlet</display-name>
        <portlet-class>javax.portlet.faces.GenericFacesPortlet</portlet-class>
        <init-param>
            <name>javax.portlet.faces.defaultViewId.view</name>
            <value>/WEB-INF/views/view.xhtml</value>
        </init-param>
        <expiration-cache>0</expiration-cache>
        <supports>
            <mime-type>text/html</mime-type>
        </supports>
        <portlet-info>
            <title>Hello User JSF Portlet</title>
            <short-title>Hello User</short-title>
            <keywords>com.liferay.hello.user.jsf.portlet</keywords>
        </portlet-info>
        <security-role-ref>
            <role-name>administrator</role-name>
        </security-role-ref>
        <security-role-ref>
            <role-name>guest</role-name>
        </security-role-ref>
        <security-role-ref>
            <role-name>power-user</role-name>
        </security-role-ref>
        <security-role-ref>
            <role-name>user</role-name>
        </security-role-ref>
    </portlet>
</portlet-app>
\end{verbatim}

  The above configuration sets your portlet's various names, MIME type,
  expiration cache, and security roles.
\item
  Create a \texttt{web.xml} file in your JSF application's
  \texttt{webapp/WEB-INF} folder. The \texttt{web.xml} file serves as a
  deployment descriptor that provides necessary configurations for your
  JSF portlet to deploy and function in Liferay DXP. Copy the XML code
  below into your Hello User JSF application.

\begin{verbatim}
<?xml version="1.0" encoding="UTF-8"?>

<web-app xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd" version="3.0">

    <context-param>
        <param-name>javax.faces.PROJECT_STAGE</param-name>
        <param-value>${project.stage}</param-value>
    </context-param>
    <context-param>
        <param-name>javax.faces.WEBAPP_RESOURCES_DIRECTORY</param-name>
        <param-value>/WEB-INF/resources</param-value>
    </context-param>
    <servlet>
        <servlet-name>Faces Servlet</servlet-name>
        <servlet-class>javax.faces.webapp.FacesServlet</servlet-class>
        <load-on-startup>1</load-on-startup>
    </servlet>
    <security-constraint>
        <display-name>Prevent direct access to Facelet XHTML</display-name>
        <web-resource-collection>
            <web-resource-name>Facelet XHTML</web-resource-name>
            <url-pattern>*.xhtml</url-pattern>
        </web-resource-collection>
        <auth-constraint/>
    </security-constraint>
</web-app>
\end{verbatim}

  First, you set the \texttt{javax.faces.PROJECT\_STAGE} parameter to
  the \texttt{\$\{project.stage\}} variable, which is defined in your
  build file (e.g., \texttt{pom.xml}) as \texttt{Development}. When set
  to \texttt{Development}, the JSF implementation will perform the
  following steps at runtime:

  \begin{enumerate}
  \def\labelenumii{\arabic{enumii}.}
  \tightlist
  \item
    Log more verbose messages.
  \item
    Render tips and/or warnings in the view markup.
  \item
    Cause the default \texttt{ExceptionHandler} to display a
    developer-friendly error page.
  \end{enumerate}

  The \texttt{javax.faces.WEBAPP\_RESOURCES\_DIRECTORY} parameter sets
  the resources folder inside the \texttt{WEB-INF} folder. This setting
  makes the resources in that folder (e.g., CSS, JavaScript, XHTML)
  secure from non-JSF calls. You'll
  \href{/docs/7-1/tutorials/-/knowledge_base/t/defining-resources-for-a-jsf-application}{create
  resources} for your app later.

  The Faces Servlet configuration is required to initialize JSF and
  should be defined in all JSF portlets deployed to Liferay DXP.

  Finally, a security restraint is set on Facelet XHTML, which prevents
  direct access to XHTML files in your JSF application.
\item
  Create a \texttt{faces-config.xml} file in your JSF application's
  \texttt{webapp/WEB-INF} folder. The \texttt{faces-config.xml}
  descriptor is a JSF portlet's application configuration file, which is
  used to register and configure objects and navigation rules. The Hello
  User portlet's \texttt{faces-config.xml} file has the following
  contents:

\begin{verbatim}
<?xml version="1.0"?>

<faces-config version="2.2"
    xmlns="http://xmlns.jcp.org/xml/ns/javaee"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-facesconfig_2_2.xsd"
>
    <lifecycle>
        <phase-listener>com.liferay.faces.util.lifecycle.DebugPhaseListener</phase-listener>
    </lifecycle>
</faces-config>
\end{verbatim}

  Many auto-generated \texttt{faces-config.xml} files have the following
  configuration:

\begin{verbatim}
<lifecycle>
    <phase-listener>com.liferay.faces.util.lifecycle.DebugPhaseListener</phase-listener>
</lifecycle>
\end{verbatim}

  This configures your JSF portlet to log the before/after phases of the
  JSF lifecycle to your console in debug mode. Remove this declaration
  before deploying to production.
\end{enumerate}

Great! You now have a good idea of how to specify and define general
descriptor files for your JSF portlet. JSF portlets also use Liferay
descriptors, which you can learn more about in the
\href{/docs/7-1/tutorials/-/knowledge_base/t/configuring-a-spring-mvc-portlet\#liferay-descriptors}{Liferay
Descriptors} sub-section.

Now that your portlet descriptors are defined, you'll begin working on
your JSF application's resources next.

\section{Defining Resources for a JSF
Application}\label{defining-resources-for-a-jsf-application}

If you look back at the Hello User portlet's structure, you'll notice
two \texttt{resources} folders defined. Why are there two of these
folders for one portlet? These two folders have distinct differences in
how they're used and what should be placed in them.

The \texttt{resources} folder in the application's \texttt{src/main}
folder is intended for resources that need to be on the classpath. Files
in this folder are usually properties files. For this portlet, you'll
create two properties files to reside in this folder.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create the \texttt{i18n.properties} file in the
  \texttt{src/main/resources} folder. Add the following property to this
  file:

\begin{verbatim}
enter-your-name=Enter your name:
\end{verbatim}

  This is a language key your JSF portlet displays in its view XHTML.
  The messages in the \texttt{i18n.properties} file can be accessed via
  the
  \href{http://docs.oracle.com/javaee/6/tutorial/doc/bnahq.html}{Expression
  Language} using the implicit \texttt{i18n} object provided by the
  Liferay Faces Util class. The \texttt{i18n} object can access messages
  both from a resource bundle defined in the portlet's
  \texttt{portlet.xml} file, and from Liferay DXP's
  \texttt{Language.properties} file.
\item
  Create the \texttt{log4j.properties} file in the
  \texttt{src/main/resources} folder. This file sets properties for the
  Log4j logging utility defined in your JSF application (i.e.,
  \texttt{faces-config.xml}). Insert the properties below into your JSF
  application's \texttt{log4j.properties} file.

\begin{verbatim}
log4j.rootLogger=INFO, CONSOLE

log4j.appender.CONSOLE=org.apache.log4j.ConsoleAppender
log4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayout
log4j.appender.CONSOLE.layout.ConversionPattern=%d{ABSOLUTE} %-5p [%c{1}:%L] %m%n

log4j.logger.com.liferay.faces.util.lifecycle.DebugPhaseListener=DEBUG
\end{verbatim}
\end{enumerate}

The second \texttt{resources} folder in your JSF application is located
in the \texttt{src/main/webapp/WEB-INF} folder. This folder holds
CSS/JS/XHTML resources that shouldn't be accessed directly by the
browser. For the Hello User JSF application, create a \texttt{css}
folder with a \texttt{main.css} file inside. In the \texttt{main.css}
file, add the following style:

\begin{verbatim}
.com.liferay.hello.user.jsf.portlet {
    font-weight: bold;
}
\end{verbatim}

This file gives your JSF portlet a bold font.

Now that your resources are defined, you'll begin developing the Hello
User application's behavior and UI next.

\section{Developing a JSF Application's Behavior and
UI}\label{developing-a-jsf-applications-behavior-and-ui}

Your current JSF application satisfies the requirements for portlet
descriptors and WAR-style structure, but it doesn't do anything yet.
You'll learn how to develop a JSF application's back-end and give it a
simple UI next.

The first thing to do is create a Java class for your module. Your JSF
portlet's behavior is defined here. In the case of the Hello User
portlet, you should provide Java methods that can get/set a name and
facilitate the submission process.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a unique package name in the module's \texttt{src/main/java}
  folder and create a new public Java class named
  \texttt{ExampleBacking.java} in that package. For example, the class's
  folder structure could be
  \texttt{src/main/java/com/liferay/example/ExampleBacking.java}. Make
  sure the class is annotated with
  \href{http://docs.oracle.com/javaee/7/api/javax/faces/bean/RequestScoped.html}{@RequestScoped}
  and
  \href{http://docs.oracle.com/javaee/7/api/javax/faces/bean/ManagedBean.html}{@ManagedBean}:

\begin{verbatim}
@RequestScoped
@ManagedBean
public class ExampleBacking {
\end{verbatim}

  Managed beans are Java beans that are managed by the JSF framework.
  Managed beans annotated with \texttt{@RequestScoped} are usually
  responsible for handling actions and listeners. JSF \emph{manages}
  these beans by creating and removing the bean object from the server.
  Visit the linked annotations above for more details.
\item
  Add the following methods and field to your
  \texttt{ExampleBacking.java} class:

\begin{verbatim}
public String getName() {
    return name;
}

public void setName(String name) {
    this.name = name;
}

public void submit(ActionEvent actionEvent) {
    FacesContextHelperUtil.addGlobalSuccessInfoMessage();
}

private String name;
\end{verbatim}

  You've provided a getter and setter method for the private
  \texttt{name} field. You've also provided a \texttt{submit(...)}
  method, which is called when the \emph{Submit} button is selected. A
  success info message is displayed once the method is invoked.

  You've defined your Hello User portlet's Java behavior; now create its
  UI!
\item
  Create a \texttt{view.xhtml} file in the \texttt{webapp/WEB-INF/views}
  folder. Add the following logic to that file:

\begin{verbatim}
<?xml version="1.0"?>

<f:view
    xmlns="http://www.w3.org/1999/xhtml"
    xmlns:f="http://java.sun.com/jsf/core"
    xmlns:h="http://java.sun.com/jsf/html"
>
    <h:head>
        <h:outputStylesheet library="css" name="main.css" />
    </h:head>
    <h:form>
        <h:messages globalOnly="true" />
        <h:outputLabel value="#{i18n['enter-your-name']}" />
        <h:inputText value="#{exampleBacking.name}" />
        <h:commandButton actionListener="#{exampleBacking.submit}" value="#{i18n['submit']}">
            <f:ajax execute="@form" render="@form" />
        </h:commandButton>
        <br />
        <h:outputText value="Hello #{exampleBacking.name}" />
    </h:form>
</f:view>
\end{verbatim}

  The first thing to notice is the \texttt{main.css} file you created is
  specified here, which makes your portlet's heading typeface bold.
  Next, your form is defined within the
  \texttt{\textless{}h:form\textgreater{}} tags. The form asks the user
  to enter his or her name, and then sets that value to the
  \texttt{name} field in your Java class. The form uses the
  \texttt{\textless{}h:commandButton\textgreater{}} tag to execute the
  Submit button and render the form after submission.

  Notice the \texttt{i18n} object call for the \texttt{enter-your-name}
  and \texttt{submit} properties. The \texttt{enter-your-name} property
  was set in the \texttt{i18n.properties} file you specified, but what
  about the \texttt{submit} property? This was not defined in your
  portlet's \texttt{i18n.properties} file, so how does your portlet know
  to use the string \emph{Submit} for your button? If you recall, the
  \texttt{i18n} object can also access messages in Liferay DXP's
  \texttt{Language.properties} file. This is where the \texttt{submit}
  language key comes from.

  Finally, the \texttt{\textless{}h:outputText\textgreater{}} tag prints
  the submitted name on the page, prefixed with \emph{Hello}.
\end{enumerate}

Awesome! Your Hello User JSF application is complete! Deploy your WAR to
Liferay DXP. Remember, when your WAR-style portlet is deployed, it's
converted to a WAB via the WAB Generator. Visit the
\href{/docs/7-1/tutorials/-/knowledge_base/t/using-the-wab-generator}{Using
the WAB Generator} tutorial for more information on this process and
your portlet's resulting folder structure.

\begin{figure}
\centering
\includegraphics{./images/hello-user-jsf-portlet.png}
\caption{After submitting the user's name, it's displayed with a
greeting.}
\end{figure}

You can view the finished version of the Hello User JSF application by
downloading its
\href{https://portal.liferay.dev/documents/113763090/114000653/hello-user-jsf-portlet.zip}{ZIP
file}.

\section{Services in JSF}\label{services-in-jsf}

Creating services works the same in a JSF portlet as it would in any
other standard WAR-style MVC portlet; generate custom services as
separate API and Impl JARs and deploy them as individual modules to
Liferay DXP. You can generate custom services for your JSF portlet using
Service Builder. To learn more about how Service Builder works in
Liferay DXP, visit the
\href{/docs/7-1/tutorials/-/knowledge_base/t/service-builder}{Service
Builder} tutorials.

The JSF WAR can then rely on the API module as a \emph{provided}
dependency. The main benefit for packaging your services this way is to
allow multiple WARs to utilize the same custom service API without
packaging it inside every WAR's \texttt{WEB-INF/lib} folder. This
practice also enforces a separation of concerns, or \emph{modularity},
between the UI layer and service layer of a system.

To call OSGi-based Service Builder services from your JSF portlet, you
need a mechanism that gives you access to the OSGi service registry,
because you can't look up services published to the OSGi runtime using
Declarative Services. Instead, you should open a
\href{https://osgi.org/javadoc/r6/core/org/osgi/util/tracker/ServiceTracker.html}{ServiceTracker}
when you want to call a service that's in the OSGi service registry.

To implement a service tracker in your JSF portlet, you can add a
type-safe wrapper class that extends
\texttt{org.osgi.util.tracker.ServiceTracker}. For example, this is done
in a demo JSF portlet as follows

\begin{verbatim}
public class UserLocalServiceTracker extends ServiceTracker<UserLocalService, UserLocalService> {

    public UserLocalServiceTracker(BundleContext bundleContext) {
        super(bundleContext, UserLocalService.class, null);
    }
}
\end{verbatim}

After extending the \texttt{ServiceTracker}, just call the constructor
and the service tracker is ready to use in your managed bean.

In a managed bean, whenever you need to call a service, open the service
tracker. For example, this is done in the same demo JSF portlet to open
the service tracker, using the
\href{http://docs.oracle.com/javaee/7/api/javax/annotation/PostConstruct.html}{\texttt{@PostContruct}}
annotation:

\begin{verbatim}
@PostConstruct
public void postConstruct() {
    Bundle bundle = FrameworkUtil.getBundle(this.getClass());
    BundleContext bundleContext = bundle.getBundleContext();
    userLocalServiceTracker = new UserLocalServiceTracker(bundleContext);
    userLocalServiceTracker.open();
}
\end{verbatim}

Then the service can be called:

\begin{verbatim}
UserLocalService userLocalService = userLocalServiceTracker.getService();
...

userLocalService.updateUser(user);
\end{verbatim}

When it's time for the managed bean to go out of scope, you must close
the service tracker using the
\href{http://docs.oracle.com/javaee/7/api/javax/annotation/PreDestroy.html}{\texttt{@PreDestroy}}
annotation:

\begin{verbatim}
@PreDestroy
public void preDestroy() {
    userLocalServiceTracker.close();
}
\end{verbatim}

For more information on service trackers and how to use them in
WAR-style portlets, see the
\href{/docs/7-1/tutorials/-/knowledge_base/t/service-trackers}{Service
Trackers} tutorial.

\subsection{Related Topics}\label{related-topics-24}

\href{/docs/7-1/tutorials/-/knowledge_base/t/fundamentals}{Fundamentals}

\href{/docs/7-1/tutorials/-/knowledge_base/t/internationalization}{Internationalization}

\href{/docs/7-1/tutorials/-/knowledge_base/t/configurable-applications}{Configurable
Applications}

\section{Making URLs Friendlier}\label{making-urls-friendlier}

This is a story of two URLs who couldn't be more different. One was full
of himself and always wanted to show everyone (users and SEO services
alike) just how smart he was by openly displaying all the parameters he
carried. He was happiest when he could tell people he met were
intimidated and confused by him.

\begin{verbatim}
http://localhost:8080/group/guest/~/control_panel/manage?p_p_id=com_liferay_blogs_web_portlet_BlogsAdminPortlet&p_p_lifecycle=0&p_p_state=maximized&p_p_mode=view&_com_liferay_blogs_web_portlet_BlogsAdminPortlet_mvcRenderCommandName=%2Fblogs%2Fedit_entry&_com_liferay_blogs_web_portlet_BlogsAdminPortlet_redirect=http%3A%2F%2Flocalhost%3A8080%2Fgroup%2Fguest%2F~%2Fcontrol_panel%2Fmanage%3Fp_p_id%3Dcom_liferay_blogs_web_portlet_BlogsAdminPortlet%26p_p_lifecycle%3D0%26p_p_state%3Dmaximized%26p_p_mode%3Dview%26_com_liferay_blogs_web_portlet_BlogsAdminPortlet_mvcRenderCommandName%3D%252Fblogs%252Fview%26_com_liferay_blogs_web_portlet_BlogsAdminPortlet_orderBycol%3Dtitle%26_com_liferay_blogs_web_portlet_BlogsAdminPortlet_orderByType%3Dasc%26_com_liferay_blogs_web_portlet_BlogsAdminPortlet_entriesNavigation%3D%26_com_liferay_blogs_web_portlet_BlogsAdminPortlet_cur%3D1%26_com_liferay_blogs_web_portlet_BlogsAdminPortlet_delta%3D20&_com_liferay_blogs_web_portlet_BlogsAdminPortlet_entryId=30836
\end{verbatim}

The other was just, well, friendly. She was less concerned about looking
smart and more concerned about those she interacted with, so she shared
only the important things about her. She didn't need to look fancy and
complicated. She aspired to be simple and kind to all the users and SEO
services she encountered.

\begin{verbatim}
http://localhost:8080/web/guest/home/-/blogs/lunar-scavenger-hunt
\end{verbatim}

If you want your application to be friendly to your users and to SEO
services, make your URLs friendlier. It only takes a couple steps, after
all.

\subsection{Creating Friendly URL
Routes}\label{creating-friendly-url-routes}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  First create a \texttt{routes.xml} file in your application's web
  module. Liferay's pattern puts it in a
  \texttt{src/main/resources/META-INF/friendly-url-routes/} folder.
\item
  Add friendly URL routes, using as many
  \texttt{\textless{}route\textgreater{}} tags as you need friendly
  URLs, like this:

\begin{verbatim}
<?xml version="1.0"?>
<!DOCTYPE routes PUBLIC "-//Liferay//DTD Friendly URL Routes 7.1.0//EN" "http://www.liferay.com/dtd/liferay-friendly-url-routes_7_1_0.dtd">

<routes>
    <route>
        <pattern></pattern>
        <implicit-parameter name="mvcRenderCommandName">/blogs/view</implicit-parameter>
        <implicit-parameter name="p_p_lifecycle">0</implicit-parameter>
        <implicit-parameter name="p_p_state">normal</implicit-parameter>
    </route>
    <route>
        <pattern>/maximized</pattern>
        <implicit-parameter name="mvcRenderCommandName">/blogs/view</implicit-parameter>
        <implicit-parameter name="p_p_lifecycle">0</implicit-parameter>
        <implicit-parameter name="p_p_state">maximized</implicit-parameter>
    </route>
    <route>
        <pattern>/{entryId:\d+}</pattern>
        <implicit-parameter name="categoryId"></implicit-parameter>
        <implicit-parameter name="mvcRenderCommandName">/blogs/view_entry</implicit-parameter>
        <implicit-parameter name="p_p_lifecycle">0</implicit-parameter>
        <implicit-parameter name="p_p_state">normal</implicit-parameter>
        <implicit-parameter name="tag"></implicit-parameter>
    </route>
    ...
</routes>
\end{verbatim}
\end{enumerate}

Use \texttt{\textless{}pattern\textgreater{}} tags to define placeholder
values for the parameters that normally appear in the generated URL.
This is just a mask. The beastly URL still lurks beneath it.

The \texttt{pattern} value \texttt{/\{entryId:\textbackslash{}d+\}}
matches a \texttt{/} followed by an \texttt{entryId} variable that
matches the
\href{https://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html}{Java
regular expression} \texttt{\textbackslash{}d+}---one or more numeric
digits. For example, a URL \texttt{/entryId}, where the \texttt{entryId}
value is \texttt{123} results in a URL value \texttt{/123}, which
matches the pattern.

\noindent\hrulefill

\textbf{Warning:} Make sure your \texttt{pattern} values don't end in a
slash \texttt{/}. A trailing slash character prevents the request from
identifying the correct route.

\noindent\hrulefill

\textbf{Important:} If your portlet is instanceable, you must use a
variant of the \texttt{instanceId} in the \texttt{pattern} value. If the
starting value is \texttt{render-it}, for example, use one of these
patterns:

\begin{verbatim}
<pattern>/{userIdAndInstanceId}/render-it</pattern>
\end{verbatim}

or

\begin{verbatim}
<pattern>/{instanceId}/render-it</pattern>
\end{verbatim}

or

\begin{verbatim}
<pattern>/{p_p_id}/render-it</pattern>
\end{verbatim}

Use \texttt{\textless{}implicit-parameter\textgreater{}} tags to define
parameters that are always the same for the URL. For example, for a
render URL, you can be certain that the \texttt{p\_p\_lifecycle}
parameter is always \texttt{0}. You don't have to define these types of
implicit parameters, but it's a best practice because if you don't, they
still appear in your URL.

The implicit parameters with the name \texttt{mvcRenderCommandName} are
very important. If you're
\href{/docs/7-1/tutorials/-/knowledge_base/t/mvc-render-command}{using
an \texttt{MVCPortlet} with \texttt{MVCRenderCommand} classes}, that
parameter comes from the \texttt{mvc.command.name} property in the
\texttt{@Component} of your \texttt{MVCRenderCommand} implementation.
This determines the page that's rendered (for example,
\texttt{view.jsp}).

\begin{verbatim}
@Component(
    immediate = true,
    property = {
        "javax.portlet.name=" + BlogsPortletKeys.BLOGS, "mvc.command.name=/",
        "mvc.command.name=/blogs/view"
    },
    service = MVCRenderCommand.class
)
\end{verbatim}

The
\href{https://docs.liferay.com/dxp/portal/7.1-latest/definitions/liferay-friendly-url-routes_7_1_0.dtd.html}{DTD
file} completely defines the \texttt{routes.xml} file.

\subsection{Implementing a Friendly URL
Mapper}\label{implementing-a-friendly-url-mapper}

Once you have your URLs mapped in a \texttt{routes.xml} file, you must
provide an implementation of the
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/FriendlyURLMapper.html}{\texttt{FriendlyURLMapper}
service}. Create a component that specifies a \texttt{FriendlyURLMapper}
service, with two properties:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  A \texttt{com.liferay.portlet.friendly-url-routes} property sets the
  path to your \texttt{routes.xml} file.
\item
  A \texttt{javax.portlet.name} property, which you probably have
  already, specifies your portlet's name.

\begin{verbatim}
@Component(
    property = {
        "com.liferay.portlet.friendly-url-routes=META-INF/friendly-url-routes/routes.xml",
        "javax.portlet.name=" + BlogsPortletKeys.BLOGS
    },
    service = FriendlyURLMapper.class
)
\end{verbatim}
\end{enumerate}

After that, implement the \texttt{FriendlyURLMapper} service. For your
convenience, the
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/DefaultFriendlyURLMapper.html}{\texttt{DefaultFriendlyURLMapper}
class} provides a default implementation. If you extend
\texttt{DefaultFriendlyURLMapper} you must only override one method,
\texttt{getMapping()}. Return a String that defines the first part of
your Friendly URLs. It's smart to name it after your application. Here's
what it looks like for Liferay's Blogs application:

\begin{verbatim}
public class BlogsFriendlyURLMapper extends DefaultFriendlyURLMapper {

    @Override
    public String getMapping() {
        return _MAPPING;
    }

    private static final String _MAPPING = "blogs";

}
\end{verbatim}

All friendly URLs in Blogs begin with the String set here
(\texttt{blogs}).

\subsection{Friendly URLs in Action}\label{friendly-urls-in-action}

Let's look at one of these Friendly URLs in action. Add a blog entry and
then click on the entry's title. Look at the URL:

\begin{verbatim}
http://localhost:8080/web/guest/home/-/blogs/lunar-scavenger-hunt
\end{verbatim}

As specified in the friendly URL mapper class, \texttt{blogs} is the
first part of the friendly URL that comes after the Liferay part of the
URL. The next part is determined by a specific URL route in
\texttt{routes.xml}:

\begin{verbatim}
<route>
    <pattern>/{urlTitle}</pattern>
    <implicit-parameter name="categoryId"></implicit-parameter>
    <implicit-parameter name="mvcRenderCommandName">/blogs/view_entry</implicit-parameter>
    <implicit-parameter name="p_p_lifecycle">0</implicit-parameter>
    <implicit-parameter name="p_p_state">normal</implicit-parameter>
    <implicit-parameter name="tag"></implicit-parameter>
</route>
\end{verbatim}

The \texttt{urlTitle} is generated from the blog post's title. Since
it's already a parameter in the URL (see below), it's available for use
in the friendly URL.

\begin{verbatim}
<portlet:renderURL var="viewEntryURL">
    <portlet:param name="mvcRenderCommandName" value="/blogs/view_entry" />
    <portlet:param name="urlTitle" value="<%= entry.getUrlTitle() %>" />
</portlet:renderURL>
\end{verbatim}

When the render URL is invoked, the String defined in the friendly URL
mapper teams up with the \texttt{pattern} tag in your friendly URL
routes file, and you get a very friendly URL indeed, instead of some
nasty, conceited, unfriendly URL that's despised by users and SEO
services alike.

\chapter{Using JavaScript in Your
Portlets}\label{using-javascript-in-your-portlets}

Would you like to use the latest ECMAScript features in your JavaScript
files and portlets? Do you wish you could use npm and npm packages in
your portlets?

In this section of tutorials you'll learn how to prepare your JavaScript
files to leverage these features in your portlets.

\section{Preparing Your JavaScript Files for
ES2015+}\label{preparing-your-javascript-files-for-es2015}

To use the ES2015+ syntax in a JavaScript file, add the extension
\texttt{.es} to its name. For example, you rename file
\texttt{filename.js} to \texttt{filename.es.js}. The extension indicates
it uses ES2015+ syntax and must therefore be transpiled by
\href{https://babeljs.io/}{Babel} before deployment.

ES2015+ advanced features, such as
\href{https://babeljs.io/docs/learn-es2015/\#generators}{generators},
are available to you if you import the \texttt{polyfillBabel} class from
the \texttt{polyfill-babel} module:

\begin{verbatim}
import polyfillBabel from 'polyfill-babel'
\end{verbatim}

The \href{http://babeljs.io/docs/usage/polyfill/}{Babel Polyfill}
emulates a complete ES6 environment. Use it at your own discretion, as
it loads a large amount of code. You can inspect
\url{https://github.com/zloirock/core-js\#core-js} to see what's
polyfilled.

Once you've completed writing your module, you can expose it by creating
a \texttt{package.json} file that specifies your bundle's name and
version. Make sure to create this in your module's root folder. Below is
an example \texttt{package.json} file for a \texttt{js-logger} module:

\begin{verbatim}
{
    "name": "js-logger",
    "version": "1.0.0"
}
\end{verbatim}

The Module Config Generator creates the module based on this
information. There you have it! In just a few steps you can prepare your
module to leverage the latest JavaScript standard features and publish
it.

\subsection{Related Topics}\label{related-topics-25}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-esplus-modules-in-your-portlet}{Using
ES2015+ Modules in Your Portlet}

\section{Using ES2015 Modules in your
Portlet}\label{using-es2015-modules-in-your-portlet}

Once you've
\href{/docs/7-1/tutorials/-/knowledge_base/t/preparing-your-javascript-files-for-esplus}{exposed
your modules} via your \texttt{package.json} file, you can use them in
your portlets. The \texttt{aui:script} tag's \texttt{require} attribute
makes it easy.

This tutorial covers how to access your exposed modules in your
portlets. Follow the steps below to use your exposed modules in your
portlets.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Declare the \texttt{aui} taglib in your view JSP:

\begin{verbatim}
<%@ taglib uri="http://liferay.com/tld/aui" prefix="aui" %>
\end{verbatim}

  \textbf{Note:} if you created the portlet using Blade, the
  \texttt{aui} taglib is already provided for you in the
  \texttt{init.jsp}.
\item
  Add an \texttt{aui:script} tag to the JSP and set the \texttt{require}
  attribute to the relative path for your module.

  The \texttt{require} attribute lets you include your exposed modules
  in your JSP. The AMD Loader fetches the specified module and its
  dependencies. An example faux Console Logger Portlet's
  \texttt{view.jsp} shown below includes the module \texttt{logger.es}:

\begin{verbatim}
<aui:script require="js-logger/logger.es">
    var Logger = jsLoggerLoggerEs.default;

    var loggerOne = new Logger('*** -> ');
    loggerOne.log('Hello');

    var loggerDefault = new Logger();
    loggerDefault.log('World');
</aui:script>
\end{verbatim}

  References to the module within the script tag are named after the
  \texttt{require} value, in camel-case and with all invalid characters
  removed. The \texttt{logger.es} module's reference
  \texttt{jsLoggerLoggerEs} is derived from the module's relative path
  value \texttt{js-logger/logger.es}. The value is stripped of its dash
  and slash characters and converted to camel case.
\end{enumerate}

Thanks to the \texttt{aui:script} tag and its \texttt{require}
attribute, using your modules in your portlet is a piece of cake!

\subsection{Related Topics}\label{related-topics-26}

\href{/docs/7-1/tutorials/-/knowledge_base/t/customizing-jsps}{Customizing
JSPs}

\href{/docs/7-1/tutorials/-/knowledge_base/t/web-services}{Web Services}

\chapter{Using npm in Your Portlets}\label{using-npm-in-your-portlets}

npm is a powerful tool, and almost a necessity for Front-End
development. You can use npm as your JavaScript package manager
tool---including npm and npm packages---while developing portlets in
your normal, everyday workflow.

Deployed portlets leverage
\href{/docs/7-1/tutorials/-/knowledge_base/t/loading-amd-modules-in-liferay}{Liferay
AMD Loader} to share JavaScript modules and take advantage of semantic
versioning when resolving modules among portlets on the same page. The
liferay-npm-bundler helps prepare your npm modules for the Liferay AMD
Loader.

This section of tutorials covers how to set up npm-based portlet
projects.

\section{Formatting Your npm Modules for
AMD}\label{formatting-your-npm-modules-for-amd}

For Liferay DXP to recognize your npm modules, they must be formatted
for the Liferay AMD Loader. Luckily, the liferay-npm-bundler handles
this for you, you just have to provide the proper configuration and add
it to your build script. This tutorial shows how to use the
liferay-npm-bundler to set up npm-based portlet projects.

\noindent\hrulefill

\textbf{Note:} the example and steps covered in this tutorial use the
old mode of the liferay-npm-bundler that includes additional build steps
in the \texttt{build} script before the bundler runs. The new mode of
the bundler, like webpack, uses loaders and a set of rules. See
\href{/docs/7-1/tutorials/-/knowledge_base/t/migrating-your-project-to-use-the-new-mode}{Migrating
Your Project to Use the New Mode} to learn how to migrate your project
to use the new mode.

\noindent\hrulefill

The example structure below is referenced throughout this tutorial. You
can download it
\href{https://github.com/izaera/liferay-npm-bundler-2-example}{here} if
you want to follow along:

\begin{itemize}
\tightlist
\item
  \texttt{npm-angular5-portlet-say-hello/}

  \begin{itemize}
  \tightlist
  \item
    \texttt{META-INF/}

    \begin{itemize}
    \tightlist
    \item
      \texttt{resources/}

      \begin{itemize}
      \tightlist
      \item
        \texttt{package.json}

        \begin{itemize}
        \tightlist
        \item
          name: npm-angular5-portlet-say-hello
        \item
          version: 1.0.0
        \item
          main: js/angular.pre.loader.js
        \item
          scripts:

          \begin{itemize}
          \tightlist
          \item
            build: tsc \&\& liferay-npm-bundler
          \end{itemize}
        \end{itemize}
      \item
        \texttt{tsconfig.json}

        \begin{itemize}
        \tightlist
        \item
          target: es5
        \item
          moduleResolution: node
        \end{itemize}
      \item
        \texttt{.npmbundlerrc}

        \begin{itemize}
        \tightlist
        \item
          exclude:

          \begin{itemize}
          \tightlist
          \item
            *: true
          \end{itemize}
        \item
          config:

          \begin{itemize}
          \tightlist
          \item
            imports:

            \begin{itemize}
            \tightlist
            \item
              npm-angular5-provider:

              \begin{itemize}
              \tightlist
              \item
                @angular/animations: \^{}5.0.0
              \item
                @angular/cdk: \^{}5.0.0
              \item
                @angular/common: \^{}5.0.0
              \item
                @angular/compiler: \^{}5.0.0
              \end{itemize}
            \item
              ``\,'' :

              \begin{itemize}
              \tightlist
              \item
                npm-angular5-provider: \^{}1.0.0
              \end{itemize}
            \end{itemize}
          \end{itemize}
        \end{itemize}
      \item
        \texttt{js/}

        \begin{itemize}
        \tightlist
        \item
          \texttt{indigo-pink.css}
        \item
          \texttt{angular.pre.loader.ts} // Bootstrap shims and
          providers
        \item
          import npm-angular5-provider;
        \end{itemize}
      \end{itemize}
    \end{itemize}
  \end{itemize}
\item
  \texttt{npm-angular5-provider}

  \begin{itemize}
  \tightlist
  \item
    \texttt{package.json}

    \begin{itemize}
    \tightlist
    \item
      name: npm-angular5-provider
    \item
      version: 1.0.0
    \item
      main: bootstrap.js
    \item
      scripts:

      \begin{itemize}
      \tightlist
      \item
        build: liferay-npm-bundler
      \end{itemize}
    \item
      dependencies:

      \begin{itemize}
      \tightlist
      \item
        @angular/animations: \^{}5.0.0
      \item
        @angular/cdk: \^{}5.0.0
      \item
        @angular/common: \^{}5.0.0
      \item
        @angular/compiler: \^{}5.0.0
      \item
        \ldots{}
      \end{itemize}
    \end{itemize}
  \item
    \texttt{src/main/resources/META-INF/resources/}

    \begin{itemize}
    \tightlist
    \item
      \texttt{bootstrap.js} // This file includes polyfills needed by
      Angular and must be loaded before the app

      \begin{itemize}
      \tightlist
      \item
        require(`core-js/es6/reflect');
      \item
        require(`core-js/es7/reflect');
      \item
        require(`zone-js/dist/zone');
      \end{itemize}
    \end{itemize}
  \end{itemize}
\end{itemize}

Follow these steps to configure your project to use the
liferay-npm-bundler:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Install NodeJS \textgreater=
  \href{http://nodejs.org/dist/v6.11.0/}{v6.11.0} if you don't have it
  installed.
\item
  Navigate to your portlet's project folder and initialize a
  \texttt{package.json} file if it's not present yet.

  If you don't have a portlet already, create an empty MVC portlet
  project. For convenience, you can use
  \href{/docs/7-1/tutorials/-/knowledge_base/t/installing-blade-cli}{Blade
  CLI} to create an empty portlet with the
  \href{/docs/7-1/reference/-/knowledge_base/r/using-the-mvc-portlet-template}{mvc
  portlet blade template}.

  If you don't have a \texttt{package.json} file, you can run
  \texttt{npm\ init\ -y} to create an empty one based on the project
  directory's name.
\item
  Run the following command to install the liferay-npm-bundler:

\begin{verbatim}
npm install --save-dev liferay-npm-bundler
\end{verbatim}
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** Use npm from within your portlet project's root folder (where the
 `package.json` file lives), as you normally do on a typical web project.
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{3}
\item
  Add the \texttt{liferay-npm-bundler} to your \texttt{package.json}'s
  build script to pack the needed npm packages and transform them to
  AMD:

\begin{verbatim}
"scripts": {
      "build": "[... && ] liferay-npm-bundler"
}
\end{verbatim}

  The \texttt{{[}...\&\&{]}} refers to any previous steps you need to
  perform (for example, transpiling your sources with Babel, compiling
  SOY templates, transpiling Typescript, etc.). The example includes the
  Typescript compiler (\texttt{tsc}) in its build script because Angular
  requires it for transpiling code to ES5:

\begin{verbatim}
"build": "tsc && liferay-npm-bundler" 
\end{verbatim}
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** You can use any languages you like as long as they can be
 transpiled to ECMAscript 5 or higher. The only requirements are:
 
 - That Babel can convert them to an AST to be able to process it
 - That your browser can execute it.
 - That modules are loaded using `require()` calls (this requirement can be
   relaxed by using customized plugins, but is mandatory for the default
   out-of-the-box configuration).
 
   When you deploy your portlet using Gradle, the build script is called as
   part of the process.
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{4}
\item
  Configure your project for the bundler, using the
  \texttt{.npmbundlerrc} file (create this file in your project's root
  folder if it doesn't exist). You can specify packages to exclude from
  the output JAR, imports for shared dependencies, and more. See the
  \href{/docs/7-1/reference/-/knowledge_base/r/configuring-liferay-npm-bundler}{Configuring
  liferay-npm-bundler reference} for more information on the available
  options.

  The example excludes every dependency (using the wildcard (\texttt{*})
  symbol) of the \texttt{npm-angular5-portlet-say-hello} widget to
  prevent Angular from appearing in its JAR, making the build process
  faster and optimizing deployment. Note that
  \texttt{npm-angular5-provider} is also imported with no namespace
  (\texttt{""}) because one of its modules is going to be invoked to
  bootstrap Angular shims: see the \texttt{angular.pre.loader.ts} file,
  where \texttt{npm-angular5-provider} is imported. That import, in
  turn, loads \texttt{npm-angular5-provider}'s main file
  (\texttt{bootstrap.js}):

\begin{verbatim}
{
    ...
    "exclude": {
        "*": true
    },
    "config": {
        "imports": {
            "npm-angular5-provider": {
                "@angular/animations": "^5.0.0",
                "@angular/cdk": "^5.0.0",
                "@angular/common": "^5.0.0",
                "@angular/compiler": "^5.0.0",
                ...
            },
            "": {
                "npm-angular5-provider": "^1.0.0"
            }
        }
    }
}
\end{verbatim}
\item
  Run \texttt{npm\ install} to install the required dependencies.
\item
  Run the build script to bundle your dependencies with the
  liferay-npm-bundler:

\begin{verbatim}
npm run-script build
\end{verbatim}
\end{enumerate}

The bundler copies the project and \texttt{node\_modules}' JS files to
the output and wraps them inside a \texttt{Liferay.Loader.define()} call
so that the Liferay AMD Loader knows how to handle them. It also
namespaces the module names in \texttt{require()} calls and inside the
\texttt{Liferay.Loader.define()} call with the project's name prefix
(\texttt{npm-angular5-provider\$} in the example) to achieve
\href{/docs/7-1/reference/-/knowledge_base/r/how-liferay-portal-publishes-npm-packages\#isolated-package-dependencies}{dependency
isolation}. the bundler injects the dependencies in the
\texttt{package.json} pertaining to \texttt{npm-angular5-provider} to
make them available at runtime. The resulting build for the example
widget is shown below:

\begin{itemize}
\tightlist
\item
  \texttt{npm-angular5-portlet-say-hello/}

  \begin{itemize}
  \tightlist
  \item
    \texttt{build/}

    \begin{itemize}
    \tightlist
    \item
      \texttt{resources/main/META-INF/resources}

      \begin{itemize}
      \tightlist
      \item
        \texttt{package.json}

        \begin{itemize}
        \tightlist
        \item
          dependencies:

          \begin{itemize}
          \tightlist
          \item
            @npm-angular5-provider\$angular/animations: \^{}5.0.0
          \item
            @npm-angular5-provider\$angular/cdk: \^{}5.0.0
          \item
            @npm-angular5-provider\$angular/common: \^{}5.0.0
          \item
            @npm-angular5-provider\$angular/compiler: \^{}5.0.0
          \end{itemize}
        \end{itemize}
      \item
        \texttt{js/}

        \begin{itemize}
        \tightlist
        \item
          \texttt{angular.loader.js}

          \begin{itemize}
          \tightlist
          \item
            Liferay.Loader.define(``npm-angular5-portlet-say-hello@1.0.0/js/angular.loader''
          \item
            {[}`module', `exports', `require',
            `@npm-angular5-provider\$angular/platform-browser-dynamic',
            \ldots{]}
          \end{itemize}
        \end{itemize}
      \end{itemize}
    \end{itemize}
  \end{itemize}
\item
  \texttt{npm-angular5-provider}

  \begin{itemize}
  \tightlist
  \item
    \texttt{package.json}

    \begin{itemize}
    \tightlist
    \item
      name: npm-angular5-provider
    \item
      version: 1.0.0
    \item
      main: bootstrap.js
    \item
      dependencies:

      \begin{itemize}
      \tightlist
      \item
        @npm-angular5-provider\$angular/animations: \^{}5.0.0
      \item
        @npm-angular5-provider\$angular/cdk: \^{}5.0.0
      \item
        @npm-angular5-provider\$angular/common: \^{}5.0.0
      \item
        @npm-angular5-provider\$angular/compiler: \^{}5.0.0
      \item
        \ldots{}
      \end{itemize}
    \end{itemize}
  \item
    \texttt{bootstrap.js}

    \begin{itemize}
    \tightlist
    \item
      Liferay.Loader.define(`npm-angular5-provider@1.0.0/bootstrap'
    \item
      {[}`module', `exports', `require',
      `npm-angular5-provider\(core-js/es6/reflect',
        'npm-angular5-provider\)core-js/es7/reflect',
      `npm-angular5-provider\$zone.js/dist/zone'{]}
    \end{itemize}
  \item
    \texttt{src/main/resources/META-INF/resources/}

    \begin{itemize}
    \tightlist
    \item
      \texttt{bootstrap.js} // This file includes polyfills needed by
      Angular and must be loaded before the app

      \begin{itemize}
      \tightlist
      \item
        require(`core-js/es6/reflect');
      \item
        require(`core-js/es7/reflect');
      \item
        require(`zone-js/dist/zone');
      \end{itemize}
    \end{itemize}
  \end{itemize}
\end{itemize}

\noindent\hrulefill

\textbf{Note:} By default, the AMD Loader times out in seven seconds.
Since Liferay DXP Fix Pack 3 and Liferay Portal 7.1 CE GA 2, you can
configure this value through System Settings. Open the Control Panel and
navigate to \emph{Configuration} → \emph{System Settings} →
\emph{PLATFORM} → \emph{Infrastructure}, and select \emph{JavaScript
Loader}. Set the \emph{Module Definition Timeout} configuration to the
time you want and click \emph{Save}.

\noindent\hrulefill

Now you know how to use the liferay-npm-bundler to bundle your npm-based
portlets for the Liferay AMD Loader!

\subsection{Related Topics}\label{related-topics-27}

\href{/docs/7-1/tutorials/-/knowledge_base/t/preparing-your-javascript-files-for-esplus}{Preparing
Your JavaScript Files for ES2015+}

\section{Migrating a liferay-npm-bundler Project from 1.x to
2.x}\label{migrating-a-liferay-npm-bundler-project-from-1.x-to-2.x}

You should use the latest 2.x version of the liferay-npm-bundler. It
\href{/docs/7-1/reference/-/knowledge_base/r/changes-between-liferay-npm-bundler-1x-and-2x}{offers
more stability and includes more features out-of-the-box}. If you
already created a project using the 1.x version, don't worry. Follow
these steps to migrate your project to 2.x:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Update the \texttt{liferay-npm-bundler} dependency in your
  \texttt{package.json} to version 2.x:

\begin{verbatim}
{
  "devDependencies": {
    ...
    "liferay-npm-bundler": "^2.0.0",
    ...
  },
  ...
}
\end{verbatim}
\item
  Remove all \texttt{liferay-npm-bundler-preset-*} dependencies from
  your \texttt{package.json} because liferay-npm-bundler 2.x includes
  these by default.
\item
  Remove any bundler presets you configured in your
  \texttt{.npmbundlerrc} file. liferay-npm-bundler 2.x includes one
  smart preset that handles all frameworks automatically.
\end{enumerate}

These are the standard requirements that all projects have in common.
The remaining steps depend on your project's framework. Follow the
instructions in the corresponding section to finish migrating your
project.

\subsection{Migrating a Plain JavaScript, Billboard JS, JQuery, Metal
JS, React, or Vue JS
Project}\label{migrating-a-plain-javascript-billboard-js-jquery-metal-js-react-or-vue-js-project}

After following the steps covered in the beginning, follow these
remaining steps to migrate the framework projects shown below to 2.x:

\begin{itemize}
\tightlist
\item
  plain JS project
\item
  Billboard.js project
\item
  JQuery project
\item
  Metal.js project
\item
  React project
\item
  Vue.js project
\end{itemize}

While Babel is required to transpile your source files, you must remove
any Babel preset used for transformations from your project that bundler
1.x imposed. liferay-npm-bundler 2.x handles these transformations by
default:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Remove the \emph{liferay-project} preset from your project's
  \texttt{.babelrc} file. All that should remain is the \texttt{es2015}
  preset shown below:

\begin{verbatim}
{
  "presets": ["es2015"]
}
\end{verbatim}

  If your project uses React, make sure the \texttt{react} preset
  remains as well:

\begin{verbatim}
{
  "presets": ["es2015", "react"]
}
\end{verbatim}
\item
  Remove the \texttt{babel-preset-liferay-project} dependency from your
  \texttt{package.json}.
\end{enumerate}

If you're migrating an Angular project, follow the steps in the next
section.

\subsection{Migrating an Angular
Project}\label{migrating-an-angular-project}

After following the steps covered in the beginning, follow these
remaining steps to migrate your Angular project to 2.x. While
liferay-npm-bundler 1.x relied on Babel to perform some transformation
steps, these transformations are now automatically applied in version
2.x. Therefore, you should remove Babel from your project:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open your \texttt{tsconfig.json} file and replace the
  \texttt{"module":\ "amd"} compiler option with the configuration shown
  below to produce CommonJS modules:

\begin{verbatim}
{
  "compilerOptions": {
    ...
    "module": "commonjs",
    ...
  }
}
\end{verbatim}
\item
  Delete the \texttt{.babelrc} file to remove the Babel configuration.
\item
  Remove Babel from your \texttt{package.json} build process so it
  matches the configuration below:

\begin{verbatim}
{
  "scripts": {
    "build": "tsc && liferay-npm-bundler"
  },
  ...
}
\end{verbatim}
\item
  Remove the following Babel dependencies from your
  \texttt{package.json} \emph{devDependencies}:

\begin{verbatim}
"babel-cli": "6.26.0",
"babel-preset-liferay-amd": "1.2.2"
\end{verbatim}
\end{enumerate}

\subsection{Related Topics}\label{related-topics-28}

\href{/docs/7-1/tutorials/-/knowledge_base/t/formatting-your-npm-modules-for-amd}{Formatting
Your npm Modules for AMD}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-the-npmresolver-api-in-your-portlets}{Using
the NPMResolver API in Your Portlets}

\href{/docs/7-1/reference/-/knowledge_base/r/changes-between-liferay-npm-bundler-1x-and-2x}{What
Changed between liferay-npm-bundler 1.x and 2.x}

\section{Migrating Your Project to Use liferay-npm-bundler's New
Mode}\label{migrating-your-project-to-use-liferay-npm-bundlers-new-mode}

In the previous version of the liferay-npm-bundler, before the bundler
ran, the build did some preprocessing, then the bundler modified the
output from the preprocessed files, as shown in the example build script
below:

\begin{verbatim}
{
  "scripts":{
    "build": "babel --source-maps -d build src && liferay-npm-bundler"
  }
}
\end{verbatim}

In the new mode, the liferay-npm-bundler is in charge of the whole
process, like webpack, and configured via a set of rules. The build
script is condensed, as shown below:

\begin{verbatim}
{
  "scripts":{
    "build": "liferay-npm-bundler"
  }
}
\end{verbatim}

Follow these steps to migrate your project to use the new configuration
mode:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open the project's \texttt{package.json} file and update the
  \texttt{build} script to only use the liferay-npm-bundler:

\begin{verbatim}
{
  "scripts":{
    "build": "liferay-npm-bundler"
  }
}
\end{verbatim}
\item
  Define the rules for the bundler to use (e.g.~running babel to
  transpile files) in the project's \texttt{.npmbundlerrc} file. The
  example configuration below defines rules for using the
  \texttt{babel-loader} to transpile JavaScript files. See the
  \href{/docs/7-1/reference/-/knowledge_base/r/default-liferay-npm-bundler-loaders}{Default
  Loaders reference} for the full list of default loaders. Follow the
  steps in
  \href{/docs/7-1/tutorials/-/knowledge_base/t/creating-custom-loaders-for-the-liferay-npm-bundler}{Creating
  Custom Loaders for the Bundler} to create a custom loader. The
  liferay-npm-bundler processes the \texttt{*.js} files in
  \texttt{/src/} with babel and writes the results in the default
  \texttt{/build/} folder:

\begin{verbatim}
{
  "sources": ["src"],
  "rules": [
    {
      "test": "\\.js$",
      "exclude": "node_modules",
      "use": [
        {
          "loader": "babel-loader",
          "options": {
            "presets": ["env"]
          }
        }
      ]
    }
  ]
}
\end{verbatim}
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
**Note:** The new mode of the liferay-npm-bundler acts very much 
 like webpack, but because webpack creates a single JS bundle file and 
 liferay-npm-bundler targets an AMD loader, they are not compatible.
\end{verbatim}

\noindent\hrulefill

\subsection{Related Topics}\label{related-topics-29}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-1/reference/-/knowledge_base/r/default-liferay-npm-bundler-loaders}{Default
  liferay-npm-bundler Loaders}
\item
  \href{/docs/7-1/reference/-/knowledge_base/r/understanding-liferay-npm-bundlers-loaders}{Understanding
  liferay-npm-bundler's Loaders}
\end{itemize}

\section{Creating Custom Loaders for the
liferay-npm-bundler}\label{creating-custom-loaders-for-the-liferay-npm-bundler}

Since webpack creates JS bundles and the liferay-npm-bundler targets AMD
loader, webpack's loaders aren't compatible with the
liferay-npm-bundler. So, if you want to use a loader that isn't
\href{/docs/7-1/reference/-/knowledge_base/r/default-liferay-npm-bundler-loaders}{available
by default}, you must create a custom loader.

A loader, in terms of the liferay-npm-bundler, is defined as an npm
package that has a main module which exports a default function with
this signature:

\begin{verbatim}
function(context, options){
}
\end{verbatim}

The arguments are defined as follows:

\begin{itemize}
\tightlist
\item
  \texttt{context}: an object that contains these fields

  \begin{itemize}
  \tightlist
  \item
    \texttt{content}: A string with the contents of the processed file
    (the main input of the loader)
  \item
    \texttt{filepath}: the project-relative path to the file to process
    with the loader
  \item
    \texttt{extraArtifacts}: an object with project-relative paths as
    keys and strings as values of properties which may be used to output
    extra files along with the one being processed (for example, you can
    use it to generate source maps).
  \item
    \texttt{log}: a logger that writes execution information to the
    bundler's report file (see the
    \href{https://github.com/liferay/liferay-js-toolkit/blob/master/packages/liferay-npm-build-tools-common/src/plugin-logger.js}{PluginLogger
    class} for information on its structure and API).
  \end{itemize}
\item
  \texttt{options}: an object taken from the \texttt{options} field of
  the loader's configuration (See
  \href{/docs/7-1/reference/-/knowledge_base/r/understanding-liferay-npm-bundlers-loaders}{Understanding
  liferay-npm-bundler's loaders and rules} for more information).
\end{itemize}

\noindent\hrulefill

\textbf{Note:} the function may return nothing or modified content. If
something is returned, it is copied on top of the
\texttt{context.content} field ans used to feed the next loader or write
the output file. This is the equivalent to \texttt{context.content} =
`something'. If your loader does not return a file, but instead it only
filters files to prevent them from being generated, you must explicitly
set
\texttt{context.content\ =\ \textquotesingle{}undefined\textquotesingle{}}.

\noindent\hrulefill

Follow these steps to write a new loader. These steps use the babel
loader as an example:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  If your loader requires configuration, like babel, you may define a
  rule configuration like the one shown below so you can specify options
  for the loader:

\begin{verbatim}
{
  "rules": [
    {
      "test": "\\.js$",
      "exclude": "node_modules",
      "use": [
        {
          "loader": "babel-loader",
          "options": {
            "presets": ["env", "react"]
          }
        }
      ]
    }
  ]
}
\end{verbatim}
\item
  Create an \texttt{index.js} file and write a function that takes the
  input content, passes it through the loader, and writes the result and
  the source map file to the output folder. The loader function below
  takes the passed content (JS files), run it through babel, and writes
  the result and source map to the default \texttt{/build/} output
  folder:

\begin{verbatim}
export default function(context, options) {
  // Get input parameters
  const { content, filePath, log, sourceMap } = context;

  // Run babel on content
  const result = babel.transform(content, options);

  // Create an extra .map file with source map next to source .js file
  context.extraArtifacts[`${filePath}.map`] = JSON.stringify(result.map);

  // Tell the user what we have done
  log.info("babel-loader", "Transpiled file");

  // Return the modified content
  return result.code;
}
\end{verbatim}
\item
  Place the \texttt{index.js} file in an npm package and publish it.
\item
  Include the npm package you just created as a devDependency in the
  project's \texttt{package.json}:

\begin{verbatim}
"devDependencies": {
  "liferay-npm-bundler": "2.12.0",
  "liferay-npm-build-support": "2.12.0",
  "liferay-npm-bundler-loader-babel-loader": "2.12.0",
  ...
}
\end{verbatim}
\item
  Configure the loader's name in the \texttt{rules} section of the
  project's \texttt{.npmbundlerrc} file:

\begin{verbatim}
{
  "sources": ["src"],
  ...
  "rules": [
    {
      "test": "\\.js$",
      "exclude": "node_modules",
      "use": [
        {
          "loader": "babel-loader",
          "options": {
            "presets": ["env", "react"]
          }
        }
      ]
    }
  ],
  ...
}
\end{verbatim}
\end{enumerate}

\subsection{Related Topics}\label{related-topics-30}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-1/reference/-/knowledge_base/r/default-liferay-npm-bundler-loaders}{Default
  liferay-npm-bundler Loaders}
\item
  \href{/docs/7-1/reference/-/knowledge_base/r/understanding-liferay-npm-bundlers-loaders}{Understanding
  liferay-npm-bundler's Loaders}
\end{itemize}

\chapter{Using the NPMResolver API in Your
Portlets}\label{using-the-npmresolver-api-in-your-portlets}

If you're developing an npm-based portlet, your OSGi bundle's
\texttt{package.json} is a treasure-trove of information. It contains
everything that's stored in the npm registry about your bundle: default
entry point, dependencies, modules, package names, versions, and more.
The
\href{https://docs.liferay.com/dxp/apps/foundation/latest/javadocs/com/liferay/frontend/js/loader/modules/extender/npm/NPMResolver.html}{\texttt{NPMResolver}
APIs} expose this information so you can access it in your portlet. If
it's defined in the OSGi bundle's \texttt{package.json}, you can
retrieve the information in your portlet with the \texttt{NPMResolver}
API. For instance, you can use this API to
\href{/docs/7-1/tutorials/-/knowledge_base/t/obtaining-dependency-npm-package-descriptors}{reference
an npm package's static resources} (such as CSS files) and even to
\href{/docs/7-1/tutorials/-/knowledge_base/t/referencing-an-npm-modules-package}{make
your code more maintainable}.

To enable the \texttt{NPMResolver} in your portlet, use the
\texttt{@Reference} annotation to inject the \texttt{NPMResolver} OSGi
component into your portlet's Component class, as shown below:

\begin{verbatim}
import com.liferay.frontend.js.loader.modules.extender.npm.NPMResolver;

public class MyPortlet extends MVCPortlet {
  
  @Reference
  private NPMResolver `_npmResolver`;
  
}
\end{verbatim}

\noindent\hrulefill

\textbf{Note:} Because the \texttt{NPMResolver} reference is tied
directly to the OSGi bundle's \texttt{package.json} file, it can only be
used to retrieve npm module and package information from that file. You
can't use the \texttt{NPMResolver} to retrieve npm package information
for other OSGi bundles.

\noindent\hrulefill

Now that the \texttt{NPMResolver} is added to your portlet, the
tutorials in this section describe retrieving your OSGi bundle's npm
package and module information.

\section{Referencing an npm Module's Package to Improve Code
Maintenance}\label{referencing-an-npm-modules-package-to-improve-code-maintenance}

Once you've
\href{/docs/7-1/tutorials/-/knowledge_base/t/preparing-your-javascript-files-for-esplus}{exposed
your modules}, you can use them in your portlet via the
\texttt{aui:script} tag's \texttt{require} attribute. By default,
Liferay DXP automatically composes an npm module's JavaScript variable
based on its name. For example, the module \texttt{my-package@1.0.0}
translates to the variable \texttt{myPackage100} for the
\texttt{\textless{}aui:script\textgreater{}} tag's \texttt{require}
attribute. This means that each time a new version of the OSGi bundle's
npm package is released, you must update your code's variable to reflect
the new version. You can use the
\href{https://docs.liferay.com/dxp/apps/foundation/latest/javadocs/com/liferay/frontend/js/loader/modules/extender/npm/JSPackage.html}{\texttt{JSPackage}
interface} to obtain the module's package name and create an alias to
reference it, so the variable name always reflects the latest version
number!

Follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Retrieve a reference to the OSGi bundle's npm package using the
  \href{https://docs.liferay.com/dxp/apps/foundation/latest/javadocs/com/liferay/frontend/js/loader/modules/extender/npm/NPMResolver.html\#getJSPackage}{\texttt{getJSPackage()}
  method}:

\begin{verbatim}
JSPackage jsPackage = _npmResolver.getJSPackage();
\end{verbatim}
\item
  Grab the npm package's resolved ID (the current package version, in
  the format
  \texttt{\textless{}package\ name\textgreater{}@\textless{}version\textgreater{}},
  defined in the OSGi module's \texttt{package.json}) using the
  \href{https://docs.liferay.com/dxp/apps/foundation/latest/javadocs/com/liferay/frontend/js/loader/modules/extender/npm/JSPackage.html\#getResolvedId}{\texttt{getResolvedId()}
  method} and alias it with the \texttt{as\ myVariableName} pattern. The
  example below retrieves the npm module's resolved ID, sets it to the
  \texttt{bootstrapRequire} variable, and assigns the entire value to
  the attribute \texttt{bootstrapRequire}. This ensures that the package
  version is always up to date:

\begin{verbatim}
renderRequest.setAttribute(
  "bootstrapRequire",
  jsPackage.getResolvedId() + " as bootstrapRequire");
\end{verbatim}
\item
  Include the reference to the
  \href{https://docs.liferay.com/dxp/apps/foundation/latest/javadocs/com/liferay/frontend/js/loader/modules/extender/npm/NPMResolver.html}{\texttt{NPMResolver}}:

\begin{verbatim}
@Reference
private NPMResolver _npmResolver;
\end{verbatim}
\item
  Resolve the \texttt{JSPackage} and \texttt{NPMResolver} imports:

\begin{verbatim}
import com.liferay.frontend.js.loader.modules.extender.npm.JSPackage;
import com.liferay.frontend.js.loader.modules.extender.npm.NPMResolver;
\end{verbatim}
\item
  In the portlet's JSP, retrieve the aliased attribute
  (\texttt{bootstrapRequire} in the example):

\begin{verbatim}
<%
String bootstrapRequire =
    (String)renderRequest.getAttribute("bootstrapRequire");
%>
\end{verbatim}
\item
  Finally, use the attribute as the
  \texttt{\textless{}aui:script\textgreater{}} require attribute's
  value:

\begin{verbatim}
<aui:script require="<%= bootstrapRequire %>">
    bootstrapRequire.default();
</aui:script>
\end{verbatim}
\end{enumerate}

Below is the full example \texttt{*Portlet} class:

\begin{verbatim}
public class MyPortlet extends MVCPortlet {
    
    @Override
    public void doView(
            RenderRequest renderRequest, RenderResponse renderResponse)
        throws IOException, PortletException {

        JSPackage jsPackage = _npmResolver.getJSPackage();

        renderRequest.setAttribute(
            "bootstrapRequire",
            jsPackage.getResolvedId() + " as bootstrapRequire");

        super.doView(renderRequest, renderResponse);
    }
    
    @Reference
    private NPMResolver _npmResolver;
    
}
\end{verbatim}

And here is the corresponding example \texttt{view.jsp}:

\begin{verbatim}
<%
String bootstrapRequire =
  (String)renderRequest.getAttribute("bootstrapRequire");
%>

<aui:script require="<%= bootstrapRequire %>">
  bootstrapRequire.default();
</aui:script>
\end{verbatim}

Now you know how to reference an npm module's package!

\subsection{Related Topics}\label{related-topics-31}

\href{/docs/7-1/tutorials/-/knowledge_base/t/obtaining-dependency-npm-package-descriptors}{Obtaining
an OSGi bundle's Dependency npm Package Descriptors}

\href{/docs/7-1/reference/-/knowledge_base/r/liferay-npm-bundler}{liferay-npm-bundler}

\href{/docs/7-1/reference/-/knowledge_base/r/how-liferay-portal-publishes-npm-packages}{How
Liferay DXP Publishes npm Packages}

\section{Obtaining an OSGi bundle's Dependency npm Package
Descriptors}\label{obtaining-an-osgi-bundles-dependency-npm-package-descriptors}

While writing your npm portlet, you may need to reference a dependency
package or its modules. For instance, you can retrieve an npm dependency
package module's CSS file and use it in your portlet. The
\href{https://docs.liferay.com/dxp/apps/foundation/latest/javadocs/com/liferay/frontend/js/loader/modules/extender/npm/NPMResolver.html}{\texttt{NPMResolver}
OSGi component} provides two methods for retrieving an OSGi bundle's
dependency npm package descriptors:
\href{https://docs.liferay.com/dxp/apps/foundation/latest/javadocs/com/liferay/frontend/js/loader/modules/extender/npm/NPMResolver.html\#getDependencyJSPackage}{\texttt{getDependencyJSPackage()}}
to retrieve dependency npm packages and
\href{https://docs.liferay.com/dxp/apps/foundation/latest/javadocs/com/liferay/frontend/js/loader/modules/extender/npm/NPMResolver.html\#resolveModuleName}{\texttt{resolveModuleName()}}
to retrieve dependency npm modules. This tutorial references the
\texttt{package.json} below to help demonstrate these methods:

\begin{verbatim}
{
    "dependencies": {
        "react": "15.6.2",
        "react-dom": "15.6.2"
    },
    .
    .
    .
}
\end{verbatim}

To obtain an OSGi bundle's npm dependency package, pass the package's
name in as the \texttt{getDependencyJSPackage()} method's argument. The
example below resolves the \texttt{react} dependency package:

\begin{verbatim}
String reactResolvedId = npmResolver.getDependencyJSPackage("react");
\end{verbatim}

\texttt{reactResolvedId}'s resulting value is \texttt{react@15.6.2}.

You can use the \texttt{resolveModuleName()} method To obtain a module
in an npm dependency package. To do this, pass the module's relative
path in as the \texttt{resolveModuleName()} method's argument. The
example below resolves a module named \texttt{react-with-addons} for the
\texttt{react} dependency package:

\begin{verbatim}
String resolvedModule = 
npmResolver.resolveModuleName("react/dist/react-with-addons");
\end{verbatim}

The \texttt{resolvedModule} variable evaluates to
\texttt{react@15.6.2/dist/react-with-addons}. You can also use this to
reference static resources inside npm packages (like CSS or image
files), as shown in the example below:

\begin{verbatim}
String cssPath = npmResolver.resolveModuleName(
      "react/lib/css/main.css"); 
\end{verbatim}

Now you know how to obtain an OSGi bundle's dependency npm packages
descriptors!

\subsection{Related Topics}\label{related-topics-32}

\href{/docs/7-1/tutorials/-/knowledge_base/t/referencing-an-npm-modules-package}{Referencing
an npm Module's Package}

\href{/docs/7-1/reference/-/knowledge_base/r/the-structure-of-osgi-bundles-containing-npm-packages}{The
Structure of OSGi Bundles Containing npm Packages}

\href{/docs/7-1/reference/-/knowledge_base/r/how-liferay-portal-publishes-npm-packages}{How
Liferay DXP Publishes npm Packages}

\chapter{Applying Clay Styles to your
App}\label{applying-clay-styles-to-your-app}

It's important to have a consistent user experience across your apps.
Portal's built-in apps achieve this through Liferay's
\href{https://lexicondesign.io/}{Lexicon Experience Language} and its
web implementation,
\href{https://clayui.com/docs/getting-started/clay.html}{Clay}.

Clay provides a consistent, user-friendly UI and is included in all
themes that are based on the \texttt{\_styled} base theme, making all
the components documented on the
\href{https://clayui.com/docs/components/alerts.html}{Clay site}
accessible.

This means you can use Clay markup and components in your apps. These
tutorials explain how to apply Clay's design patterns to achieve the
same look and feel as Portal's built-in apps.

The tutorials in this section cover the following topics:

\begin{itemize}
\tightlist
\item
  Applying Clay to navigation
\item
  Implementing the Management Toolbar
\end{itemize}

\section{Applying Clay Patterns to
Navigation}\label{applying-clay-patterns-to-navigation}

This tutorial covers how to leverage Clay patterns in your app's
navigation to make it more user-friendly. Updating your app's navigation
bar to use Clay is easy, thanks to the
\texttt{\textless{}clay:navigation-bar\ /\textgreater{}} tag. Follow
these steps to update your app:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add the required imports to your app's \texttt{init.jsp}:

\begin{verbatim}
// Import the clay tld file to be able to use the new tag
<%@ taglib uri="http://liferay.com/tld/clay" prefix="clay" %>

// Import the NavigationItem utility class to create the items model
<%@ page import="com.liferay.frontend.taglib.clay.servlet.taglib.util.JSPNavigationItemList" %>
\end{verbatim}
\item
  Add the \texttt{frontend-taglib-clay} and \texttt{frontend.taglib.soy}
  module dependencies to your app's \texttt{build.gradle} file:

\begin{verbatim}
compileOnly group: "com.liferay", name: "com.liferay.frontend.taglib.soy", 
version: "1.0.10"

compileOnly group: "com.liferay", name: "com.liferay.frontend.taglib.clay", 
version: "1.0.0"
\end{verbatim}
\item
  Inside your JSP view, add a java scriplet to retrieve the navigation
  variable and portlet URL. An example configuration is shown below:

\begin{verbatim}
<%
final String navigation = ParamUtil.getString(request, "navigation", 
"entries");

PortletURL portletURL = renderResponse.createRenderURL();

portletURL.setParameter("mvcRenderCommandName", "/blogs/view");
portletURL.setParameter("navigation", navigation);
%>
\end{verbatim}
\item
  Add the \texttt{\textless{}clay:navigation-bar\ /\textgreater{}} tag
  to your app, and use the \texttt{items} attribute to specify the
  navigation items. The navigation bar should be dark if your app is
  intended for Admin use. To do this, set the \texttt{inverted}
  attribute to \texttt{true}. If your app is intended for an instance on
  a live site, keep the navigation bar light by setting the
  \texttt{inverted} attribute to \texttt{false}. An example
  configuration for an admin app is shown below:

\begin{verbatim}
<clay:navigation-bar
    inverted="<%= true %>"
    navigationItems="<%=
        new JSPNavigationItemList(pageContext) {
            {
                add(
                navigationItem -> {
                    navigationItem.setActive(navigation.equals("entries"));
                    navigationItem.setHref(renderResponse.createRenderURL());
                    navigationItem.setLabel(LanguageUtil.get(request, "entries"));
                });

                add(
                navigationItem -> {
                    navigationItem.setActive(navigation.equals("images"));
                    navigationItem.setHref(renderResponse.createRenderURL(), 
          "navigation", "images");
                    navigationItem.setLabel(LanguageUtil.get(request, "images"));
                });
            }
        }
    %>"
/>
\end{verbatim}
\item
  Add a conditional block to display the proper JSP for the selected
  navigation item. An example configuration for the Blogs Admin portlet
  is shown below:

\begin{verbatim}
<c:choose>
    <c:when test='<%= navigation.equals("entries") %>'>
        <liferay-util:include page="/blogs_admin/view_entries.jsp" 
    servletContext="<%= application %>" />
    </c:when>
    <c:otherwise>
        <liferay-util:include page="/blogs_admin/view_images.jsp" 
    servletContext="<%= application %>" />
    </c:otherwise>
</c:choose>
\end{verbatim}
\end{enumerate}

Live site navigation bar:

\begin{figure}
\centering
\includegraphics{./images/clay-patterns-navbar.png}
\caption{The navigation bar should be light for apps on the live site.}
\end{figure}

Admin app navigation bar:

\begin{figure}
\centering
\includegraphics{./images/clay-patterns-navbar-inverted.png}
\caption{The navigation bar should be dark (inverted) in admin apps.}
\end{figure}

Sweet! Now you know how to style a navigation bar with Clay.

\subsection{Related topics}\label{related-topics-33}

\href{/docs/7-1/tutorials/-/knowledge_base/t/implementing-the-management-toolbar}{Implementing
the Management Toolbar}

\section{Configuring Your Application's Title and Back
Link}\label{configuring-your-applications-title-and-back-link}

For administration applications, the title should be moved to the inner
views of the app and the associated back link should be moved to the
portlet titles. If you open the Blogs Admin application in the Control
Panel and add a new blog entry, you'll see this behavior in action:

\begin{figure}
\centering
\includegraphics{./images/new-blog-entry-title.png}
\caption{Adding a new blog entry displays the portlet title at the top,
along with a back link.}
\end{figure}

The Blogs Admin application is used as an example throughout this
article. Follow these steps to configure your app's title and back URL:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Use \texttt{ParamUtil} to retrieve the redirect for the URL:

\begin{verbatim}
String redirect = ParamUtil.getString(request, "redirect");
\end{verbatim}
\item
  Display the back icon and set the back URL to the \texttt{redirect}:

\begin{verbatim}
portletDisplay.setShowBackIcon(true);
portletDisplay.setURLBack(redirect);
\end{verbatim}
\item
  Finally, set the title using the \texttt{renderResponse.setTitle()}
  method. The example below provides a title for two scenarios:

  \begin{itemize}
  \tightlist
  \item
    If an existing blog entry is being updated, the blog's title is
    displayed.
  \item
    Otherwise it defaults to \emph{New Blog Entry} since a new blog
    entry is being created.
  \end{itemize}

\begin{verbatim}
renderResponse.setTitle((entry != null) ? entry.getTitle() : 
LanguageUtil.get(request, "new-blog-entry"));
%>
\end{verbatim}
\item
  Update any back links in the view to use the \texttt{redirect}. The
  Blog Admin app's \texttt{edit\_entry.jsp} form's cancel button is
  shown below as an example:

\begin{verbatim}
<aui:button cssClass="btn-lg" href="<%= redirect %>" name="cancelButton" 
type="cancel" />
\end{verbatim}
\end{enumerate}

Great! Now you know how to configure your app's title and back URL.

\subsection{Related Topics}\label{related-topics-34}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/applying-clay-patterns-to-navigation}{Applying
  Clay Patterns to Your Navigation Bar}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/setting-empty-results-messages}{Setting
  Empty Results Messages}
\end{itemize}

\section{Setting Empty Results
Messages}\label{setting-empty-results-messages}

If you've toured the UI, you've probably noticed messages or possibly
even animations in the search containers when no results are found.

\begin{figure}
\centering
\includegraphics{./images/no-web-content-found.png}
\caption{This is a still frame from the Web Content portlet's empty
results animation.}
\end{figure}

You can configure your apps to use empty results messages and animations
too, thanks to the \texttt{liferay-frontend:empty-results-message} tag.

Follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add the \texttt{liferay-frontend} taglib declaration into your
  portlet's \texttt{init.jsp}:

\begin{verbatim}
<%@ taglib uri="http://liferay.com/tld/frontend" prefix="liferay-frontend" %>
\end{verbatim}
\item
  Add an
  \href{https://docs.liferay.com/dxp/apps/frontend-taglib/latest/taglibdocs/liferay-frontend/empty-result-message.html}{\texttt{empty-result-message}
  tag} to your portlet's view:

\begin{verbatim}
<liferay-frontend:empty-result-message
/>
\end{verbatim}
\item
  Configure the tag's attributes to define your search container's empty
  results message, with or without an animation or image. The attributes
  are described in the table below:
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 Attribute | Description |
 --- | --- |
 `actionDropdownItems` | Specifies the action or actions to display for the empty results in either a dropdown menu, a link, or a button, depending on the number of available actions. |
 `animationType` | The CSS class for the animation. Four values are available by default with these CSS classes: `EmptyResultMessageKeys.AnimationType.EMPTY` (`taglib-empty-state`), `EmptyResultMessageKeys.AnimationType.SEARCH` (`taglib-search-state`), `EmptyResultMessageKeys.AnimationType.SUCCESS` (`taglib-success-state`), and `EmptyResultMessageKeys.AnimationType.NONE`. You can also specify a custom CSS class if you prefer. |
 `componentId` | Specifies the ID for the `actionDropdownItems` component (dropdown menu, link, or button)|
 `description` | The descriptive text to display beneath the main message. |
 `elementType` | The type of element to replace the `x` parameter in the main message's language key `no-x-yet`. |
\end{verbatim}

\noindent\hrulefill

\begin{verbatim}
An example configuration is shown below:

```html
<liferay-frontend:empty-result-message
  actionDropdownItems="<%= FragmentPermission.contains(permissionChecker, scopeGroupId, 
  FragmentActionKeys.MANAGE_FRAGMENT_ENTRIES) ? fragmentDisplayContext.getActionDropdownItems() : null %>"
  animationType="<%= EmptyResultMessageKeys.AnimationType.NONE %>"
  componentId="actionsComponent"
  description='<%= LanguageUtil.get(request, "collections-are-needed-to-create-fragments") %>'
  elementType='<%= LanguageUtil.get(request, "collections") %>'
/>
```
\end{verbatim}

\noindent\hrulefill

\begin{verbatim}
 **Note:** You can replace the available default animations with your own 
 by overriding the `taglib-empty-state`, `taglib-search-state`, and 
 `taglib-success-state` CSS classes provided by 
 [_empty_result_message.scss](https://github.com/liferay/liferay-portal/blob/7.1.x/modules/apps/frontend-css/frontend-css-web/src/main/resources/META-INF/resources/taglib/_empty_result_message.scss), 
 or by replacing the existing animations in the `@theme_image_path@/states/` 
 folder. Alternatively, you can also provide a new CSS class that defines 
 the animation and use it for the `animationType` attribute's value. 
\end{verbatim}

\noindent\hrulefill

empty\_state.gif:

\begin{figure}
\centering
\includegraphics{./images/empty_state.gif}
\caption{Use the empty state animation to signify there are no entries
to search.}
\end{figure}

search\_state.gif:

\begin{figure}
\centering
\includegraphics{./images/search_state.gif}
\caption{Use the search state animation to signify no search results
were found.}
\end{figure}

success\_state.gif:

\begin{figure}
\centering
\includegraphics{./images/success_state.gif}
\caption{Use the success state animation to signify search results were
found.}
\end{figure}

\noindent\hrulefill

\textbf{Note:} Empty results messages can also contain static images if
you prefer. Just use a valid image type instead. All animations must be
of type \texttt{GIF} though.

\noindent\hrulefill

Great! Now you know how to configure your app to display an empty
results message.

\subsection{Related Topics}\label{related-topics-35}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/using-liferay-frontend-taglibs-in-your-portlet}{Using
  the Liferay Front-End Taglib}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/applying-the-add-button-pattern}{Applying
  the Add Button Pattern}
\end{itemize}

\chapter{Implementing the Management
Toolbar}\label{implementing-the-management-toolbar}

The Management Toolbar is a combination of search, filters, sorting
options, and display options that let you manage data. For admin apps,
we recommend that you add a management toolbar to manage your search
container results. The
\href{/docs/7-1/tutorials/-/knowledge_base/t/clay-management-toolbar}{Clay
Management Toolbar} tutorial covers how to use the Clay taglibs to
create the Management Toolbar. This section of tutorials covers how to
create the features below for the Management Toolbar:

\begin{itemize}
\tightlist
\item
  Implementing View Types
\item
  Sorting and Filtering Items
\end{itemize}

\section{Implementing the View Types}\label{implementing-the-view-types}

The Management Toolbar has three predefined view types for your app's
search container results. Each style offers a slightly different look
and feel. To provide these view types in your app, you must make some
updates to your search result columns. Start by defining the view types
you want to provide.

\subsection{Defining the View Types}\label{defining-the-view-types}

The Management Toolbar has three view types:

\begin{itemize}
\item
  \textbf{Cards:} displays search result columns on a horizontal or
  vertical card
\item
  \textbf{List:} displays a detailed description along with summarized
  details for the search result columns
\item
  \textbf{Table:} the default view, which list the search result columns
  from left to right
\end{itemize}

Follow these steps to define the view types for your management toolbar:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Import the \texttt{ViewTypeItemList} utility class to create the
  action items model:

\begin{verbatim}
<%@ page import="com.liferay.frontend.taglib.clay.servlet.taglib.util.JSPViewTypeItemList" %>
\end{verbatim}
\item
  Add the \texttt{frontend.taglib.clay} and \texttt{frontend.taglib.soy}
  module dependencies to your app's \texttt{build.gradle} file:

\begin{verbatim}
compileOnly group: "com.liferay", name: "com.liferay.frontend.taglib.soy", 
version: "1.0.10"

compileOnly group: "com.liferay", name: "com.liferay.frontend.taglib.clay", 
version: "1.0.0"
\end{verbatim}
\item
  In your app's main view, retrieve the \texttt{displayStyle} for
  reference. Each view type corresponds to a display style. this is used
  to determine the proper content configuration to display for the
  selected view type:

\begin{verbatim}
<%
String displayStyle = ParamUtil.getString(request, "displayStyle");
%>
\end{verbatim}
\item
  Add the management toolbar to your app's main view and configure the
  display buttons as shown below. Note that while this example
  implements all three view types, only one view type is required. The
  default or active view type is set by adding
  \texttt{viewTypeItem.setActive(true)} to the view type:

\begin{verbatim}
<clay:management-toolbar
    disabled=<%= assetTagsDisplayContext.isDisabledTagsManagementBar() %>
    namespace="<%= renderResponse.getNamespace() %>"
    searchContainerId="assetTags"
    selectable="<%= true %>"
    viewTypes="<%=
        new JSPViewTypeItemList(pageContext, baseURL, selectedType) {
            {
                addCardViewTypeItem(
                    viewTypeItem -> {
                        viewTypeItem.setActive(true);
                        viewTypeItem.setLabel("Card");
                    });

                addListViewTypeItem(
                    viewTypeItem -> {
                        viewTypeItem.setLabel("List");
                    });

                addTableViewTypeItem(
                    viewTypeItem -> {
                        viewTypeItem.setLabel("Table");
                    });
            }
        }
    %>"
/>
\end{verbatim}

  \texttt{viewTypes}: The available view types

  \texttt{portletURL}: The current URL, with the view type parameter
  included.
\item
  Create a conditional block to check for the view types. If you only
  have one view type, you can skip this step.

\begin{verbatim}
<c:choose>
    <%-- view type configuration goes here --%>
</c:choose>
\end{verbatim}
\end{enumerate}

Now that the view types are defined, you can configure them.

\subsection{Implementing the Card
View}\label{implementing-the-card-view}

The card view displays the entry's information in a vertical or
horizontal card with an image, user profile, or an icon representing the
content's type, along with details about the content, such as its name,
workflow status, and a condensed description.

See the
\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-frontend-cards}{Liferay
Frontend Cards} tutorial for examples and use cases of each card.

\begin{figure}
\centering
\includegraphics{./images/clay-taglib-management-toolbar-view-type-card.png}
\caption{The Management Toolbar's card view gives a quick summary of the
content's description and status.}
\end{figure}

Follow the steps below to create your card view:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Inside the \texttt{\textless{}c:choose\textgreater{}} conditional
  block, add a condition for the icon display style (Card view type):

\begin{verbatim}
<c:when test='<%= Objects.equals(displayStyle, "icon") %>'>
    <%-- card view type configuration goes here --%>
</c:when>
\end{verbatim}
\item
  Add the proper java scriplet to make the card view responsive to
  different devices:

  Use the pattern below for vertical cards:

\begin{verbatim}
<%
row.setCssClass("col-md-2 col-sm-4 col-xs-6");
%>
\end{verbatim}

  For horizontal cards use the following pattern:

\begin{verbatim}
<%
row.setCssClass("col-md-3 col-sm-4 col-xs-12");
%>
\end{verbatim}
\item
  Add the search container column text containing your card. The card
  should include the actions for the entry(if applicable), as well as an
  image, icon or user profile, and the entry's title. An example
  configuration is shown below:

\begin{verbatim}
<liferay-frontend:icon-vertical-card
  actionJsp='<%= dlPortletInstanceSettingsHelper.isShowActions() ? 
  "/image_gallery_display/image_action.jsp" : StringPool.BLANK %>'
  actionJspServletContext="<%= application %>"
  cssClass="entry-display-style"
  icon="documents-and-media"
  resultRow="<%= row %>"
  title="<%= dlPortletInstanceSettingsHelper.isShowActions() ? 
  fileEntry.getTitle() : StringPool.BLANK %>"
/>
\end{verbatim}
\end{enumerate}

\subsection{Implementing the List
View}\label{implementing-the-list-view}

The list view displays the entry's complete description, along with a
small icon for the content type, and its name.

\begin{figure}
\centering
\includegraphics{./images/clay-taglib-management-toolbar-view-type-list.png}
\caption{The Management Toolbar's list view gives the content's full
description.}
\end{figure}

Inside the \texttt{\textless{}c:choose\textgreater{}} conditional block,
add a condition for the descriptive display style (list view type):

\begin{verbatim}
<c:when test='<%= Objects.equals(displayStyle, "descriptive") %>'>
    <%-- list view type configuration goes here --%>
</c:when>
\end{verbatim}

Your list view should have three columns with the content shown in the
table below:

Column \textbar{} Content Options \textbar{} Example 1 \textbar{} icon
\textbar{}
\textless liferay-ui:search-container-column-icon/\textgreater{} ~
\textbar{} image \textbar{}
\textless liferay-ui:search-container-column-image/\textgreater{} ~
\textbar{} user portrait \textbar{}
\textless liferay-ui:search-container-column-text\textgreater{}~~\textless liferay-ui:user-portrait/\textgreater{}\textless/liferay-ui:search-container-column-text\textgreater{}
2 \textbar{} description \textbar{}
\textless liferay-ui:search-container-column-text
~~colspan=``\textless\%=2\%\textgreater{}''
\textgreater{}~~\textless h5\textgreater\textless\%= userGroup.getName()
\%\textgreater\textless/h5\textgreater{} ~~\textless h6
class=``text-default''\textgreater{}
~~~~\textless span\textgreater\textless\%= userGroup.getDescription()
\%\textgreater\textless/span\textgreater{} ~~\textless/h6\textgreater{}
~~\textless h6 class=``text-default''\textgreater{}
~~~~\textless span\textgreater{} ~~~~~~~~''
key=``x-users''/\textgreater{} ~~~~\textless/span\textgreater{}
~~\textless/h6\textgreater{} 3 \textbar{} actions \textbar{}
\textless liferay-ui:search-container-column-jsp
~~path=``/edit\_team\_assignments\_user\_groups\_action.jsp''/\textgreater{}

\subsection{Implementing the Table
View}\label{implementing-the-table-view}

The table view list the search container columns from left to right.

\begin{figure}
\centering
\includegraphics{./images/clay-taglib-management-toolbar-view-type-table.png}
\caption{The Management Toolbar's table view list the content's
information in individual columns.}
\end{figure}

Inside the \texttt{\textless{}c:choose\textgreater{}} conditional block,
add a condition for the list display style (table view type):

\begin{verbatim}
<c:when test='<%= Objects.equals(displayStyle, "list") %>'>
    <%-- table view type configuration goes here --%>
</c:when>
\end{verbatim}

The columns should at least contain the information shown in the table
below:

Column \textbar{} Content Options \textbar{} Example 1 \textbar{} name
\textbar{} \textless liferay-ui:search-container-column-text
~~cssClass=``content-column name-column title-column'' ~~name=``name''
~~truncate=``\textless\%= true \%\textgreater{}'' ~~value=``\textless\%=
rule.getName(locale) \%\textgreater{}'' /\textgreater{} 2 \textbar{}
description \textbar{} \textless liferay-ui:search-container-column-text
~~cssClass=``content-column description-column'' ~~name=``description''
~~truncate=``\textless\%= true \%\textgreater{}'' ~~value=``\textless\%=
rule.getDescription(locale) \%\textgreater{}'' /\textgreater{} 3
\textbar{} create date \textbar{}
\textless liferay-ui:search-container-column-date
~~cssClass=``create-date-column text-column'' ~~name=``create-date''
~~property=``createDate'' /\textgreater{} 4 \textbar{} actions
\textbar{} \textless liferay-ui:search-container-column-jsp ~~
cssClass=``entry-action-column'' ~~path=``/rule\_actions.jsp''
/\textgreater{}

\subsection{Updating the Search
Iterator}\label{updating-the-search-iterator}

Once the view type's display styles are defined, you must update the
search iterator to show the selected view type. If your management
toolbar only has one view type, you can set the \texttt{displayStyle}
attribute to the style you defined, otherwise follow the pattern below:

\begin{verbatim}
<liferay-ui:search-iterator
    displayStyle="<%= displayStyle %>"
    markupView="lexicon"
    searchContainer="<%= searchContainer %>"
/>
\end{verbatim}

The \texttt{displayStyle}'s value is set to the
\href{/docs/7-1/tutorials/-/knowledge_base/t/implementing-the-view-types\#defining-the-view-types}{current
view type}.

\subsection{Related Topics}\label{related-topics-36}

\href{/docs/7-1/tutorials/-/knowledge_base/t/clay-management-toolbar}{Configuring
the Clay Management Toolbar Taglib}

\href{/docs/7-1/tutorials/-/knowledge_base/t/filtering-and-sorting-items-with-the-management-toolbar}{Filtering
and Sorting Items with the Management Toolbar}

\section{Filtering and Sorting Items with the Management
Toolbar}\label{filtering-and-sorting-items-with-the-management-toolbar}

The Management Toolbar lets you filter and sort your search container
results. While you can configure the toolbar's filters in the JSP, this
can quickly crowd the JSP. We recommend instead that you move this
functionality to a separate java class, which we refer to as a Display
Context throughout this tutorial.

There are two main types of filters: navigation and order. Both of these
are contained within the same dropdown menu. Follow the steps below to
create your filters.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Depending on your needs, there are two classes that you can extend for
  your management toolbar Display Context. These base classes provide
  the required methods to create your navigation and order filters:

  \begin{itemize}
  \tightlist
  \item
    \href{https://github.com/liferay/liferay-portal/blob/7.1.x/modules/apps/frontend-taglib/frontend-taglib-clay/src/main/java/com/liferay/frontend/taglib/clay/servlet/taglib/display/context/BaseManagementToolbarDisplayContext.java}{\texttt{BaseManagementToolbarDisplayContext}}:
    for apps without a search container
  \item
    \href{https://github.com/liferay/liferay-portal/blob/7.1.x/modules/apps/frontend-taglib/frontend-taglib-clay/src/main/java/com/liferay/frontend/taglib/clay/servlet/taglib/display/context/SearchContainerManagementToolbarDisplayContext.java}{\texttt{SearchContainerManagementToolbarDisplayContext}}:
    for apps with a search container (extends
    \texttt{BaseManagementToolbarDisplayContext} and provides additional
    logic for search containers)
  \end{itemize}

  An example configuration for each is shown below:

  \texttt{BaseManagementToolbarDisplayContext} example:

\begin{verbatim}
public class MyManagementToolbarDisplayContext
  extends BaseManagementToolbarDisplayContext {

  public MyManagementToolbarDisplayContext(
    LiferayPortletRequest liferayPortletRequest,
    LiferayPortletResponse liferayPortletResponse,
    HttpServletRequest request) {

    super(liferayPortletRequest, liferayPortletResponse, request);
  }
  ...
}
\end{verbatim}

  \texttt{SearchContainerManagementToolbarDisplayContext} example:

\begin{verbatim}
public class MyManagementToolbarDisplayContext
  extends SearchContainerManagementToolbarDisplayContext {

  public MyManagementToolbarDisplayContext(
    LiferayPortletRequest liferayPortletRequest,
    LiferayPortletResponse liferayPortletResponse,
    HttpServletRequest request, SearchContainer searchContainer) {

    super(
      liferayPortletRequest, liferayPortletResponse, request,
      searchContainer);
  }
}
\end{verbatim}
\item
  Override the \texttt{getNavigationKeys()} method to return the
  navigation filter dropdown item(s). If your app doesn't require any
  navigation filters, you can just provide the \emph{all} filter to
  display everything. An example configuration is shown below:

\begin{verbatim}
@Override
protected String[] getNavigationKeys() {
  return new String[] {"all", "pending", "done"};
}
\end{verbatim}
\item
  override the \texttt{getOrderByKeys()} method to return the columns to
  order. An example configuration is shown below:

\begin{verbatim}
@Override
protected String[] getOrderByKeys() {
  return new String[] {"name", "items", "status"};
}
\end{verbatim}
\item
  Open the JSP view that contains the Clay Management Toolbar and set
  its \texttt{displayContext} attribute to the Display Context you
  created. An example configuration is shown below:

\begin{verbatim}
<clay:management-toolbar
    displayContext="<%= myManagementToolbarDisplayContext %>"
/>
\end{verbatim}
\end{enumerate}

Now you know how to configure the Management Toolbar's filters via a
Display Context.

\subsection{Related Topics}\label{related-topics-37}

\href{/docs/7-1/tutorials/-/knowledge_base/t/clay-management-toolbar\#filtering-and-sorting-search-results}{Configuring
Filtering and Sorting Management Toolbar Attributes}

\href{/docs/7-1/tutorials/-/knowledge_base/t/implementing-the-view-types}{Implementing
the View Types}

\section{Applying the Add Button
Pattern}\label{applying-the-add-button-pattern}

Clay's add button pattern is for actions that add entities (for example
a new blog entry button). It gives you a clean, minimal UI. You can use
it in any of your app's screens. Follow these steps to add a plus button
to your app:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add the \texttt{liferay-frontend} taglib declaration to your portlet's
  \texttt{init.jsp}:

\begin{verbatim}
<%@ taglib uri="http://liferay.com/tld/frontend" prefix="liferay-frontend" %>
\end{verbatim}
\item
  Add an
  \href{https://docs.liferay.com/dxp/apps/frontend-taglib/latest/taglibdocs/liferay-frontend/add-menu.html}{\texttt{add-menu}
  tag} to your portlet's view:

\begin{verbatim}
<liferay-frontend:add-menu>
</liferay-frontend:add-menu>
\end{verbatim}
\item
  Nest a
  \href{https://docs.liferay.com/dxp/apps/frontend-taglib/latest/taglibdocs/liferay-frontend/add-menu-item.html}{\texttt{\textless{}liferay-frontend:add-menu-item\textgreater{}}}
  tag for every menu item you have. Here's an example of the add button
  pattern with a single item:

\begin{verbatim}
<liferay-frontend:add-menu>
    <liferay-frontend:add-menu-item 
      title='<%= LanguageUtil.get(request,"titleName") %>' 
      url="<%= nameURL.toString() %>" 
    />
</liferay-frontend:add-menu>
\end{verbatim}

  If there's only one item, the plus icon acts as a button that triggers
  the item. If there's multiple items, clicking the plus icon displays a
  menu containing them.

  \begin{figure}
  \centering
  \includegraphics{./images/add-button-diagram.png}
  \caption{The add button pattern consists of an \texttt{add-menu} tag
  and at least one \texttt{add-menu-item} tag.}
  \end{figure}
\end{enumerate}

The \texttt{com.liferay.mobile.device.rules.web} module's add menu is
shown below:

\begin{verbatim}
<liferay-frontend:add-menu
  inline="<%= true %>"
>
  <liferay-frontend:add-menu-item
    title='<%= LanguageUtil.get(resourceBundle, "add-device-family") %>'
    url="<%= addRuleGroupURL %>"
  />
</liferay-frontend:add-menu>
\end{verbatim}

There you have it! Now you know how to use the add button pattern.

\subsection{Related Topics}\label{related-topics-38}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/setting-empty-results-messages}{Setting
  Empty Results Messages}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/implementing-the-management-toolbar}{Implementing
  the Management Toolbar}
\end{itemize}

\section{Configuring Your Admin App's Actions
Menu}\label{configuring-your-admin-apps-actions-menu}

Rather then have a series of buttons or menus with actions in the
different views of the app, you can move all of these actions to the
upper right menu of the administrative portlet, leaving the primary
action (often an
\href{/docs/7-1/tutorials/-/knowledge_base/t/applying-the-add-button-pattern}{``Add''
operation}) visible in the add menu. For example, the web content
application has the actions menu shown below:

\begin{figure}
\centering
\includegraphics{./images/actions-menu.png}
\caption{The upper right ellipsis menu contains most of the actions for
the app.}
\end{figure}

Follow these steps to configure the actions menu in your admin app:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a \texttt{*ConfigurationIcon} Component class for the action
  that extends the
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/configuration/icon/BasePortletConfigurationIcon.html}{\texttt{BasePortletConfigurationIcon}
  class} and implements the \texttt{PortletConfigurationIcon} service:

\begin{verbatim}
@Component(
    immediate = true,
    service = PortletConfigurationIcon.class
)
public class MyConfigurationIcon extends BasePortletConfigurationIcon {
  ...
}
\end{verbatim}
\item
  Override the \texttt{getMessage()} method to specify the action's
  label:

\begin{verbatim}
@Override
public String getMessage(PortletRequest portletRequest) {
  ThemeDisplay themeDisplay = (ThemeDisplay)portletRequest.getAttribute(
    WebKeys.THEME_DISPLAY);

  ResourceBundle resourceBundle = ResourceBundleUtil.getBundle(
    themeDisplay.getLocale(), ExportAllConfigurationIcon.class);

  return LanguageUtil.get(resourceBundle, "export-all-settings");
}
\end{verbatim}
\item
  Override the \texttt{get()} method to specify whether the action is
  invoked with the \texttt{GET} or \texttt{POST} method:

\begin{verbatim}
@Override
public String getMethod() {
    return "GET";
}
\end{verbatim}
\item
  Override the \texttt{getURL()} method to specify the URL (or
  \texttt{onClick} JavaScript method) to invoke when the action is
  clicked:

\begin{verbatim}
@Override
public String getURL(
  PortletRequest portletRequest, PortletResponse portletResponse) {

  LiferayPortletURL liferayPortletURL =
    (LiferayPortletURL)_portal.getControlPanelPortletURL(
      portletRequest, ConfigurationAdminPortletKeys.SYSTEM_SETTINGS,
      PortletRequest.RESOURCE_PHASE);

  liferayPortletURL.setResourceID("export");

  return liferayPortletURL.toString();
}
\end{verbatim}
\item
  Override the \texttt{getWeight()} method to specify the order that the
  action should appear in the list:

\begin{verbatim}
@Override
public double getWeight() {
  return 1;
}
\end{verbatim}
\item
  Override the \texttt{isShow()} method to specify the context in which
  the action should be displayed:

\begin{verbatim}
@Override
public boolean isShow(PortletRequest portletRequest) {
    return true;
}
\end{verbatim}
\item
  Define the view where you want to display the configuration options.
  By default, if the portlet uses \texttt{mvcPath}, the global actions
  (such as configuration, export/import, maximized, etc.) are displayed
  for the JSP indicated in the initialization parameter of the portlet
  \texttt{javax.portlet.init-param.view-template=/view.jsp}. The value
  indicates the JSP where the global actions should be displayed.
  However, if the portlet uses MVC Command, the views for the global
  actions must be indicated with the initialization parameter
  \texttt{javax.portlet.init-param.mvc-command-names-default-views=/wiki\_admin/view}
  and the value must contain the \texttt{mvcRenderCommandName} where the
  global actions should be displayed.
\item
  If the portlet can be added to a page and you want to always include
  the configuration options, add this initialization parameter to the
  portlet's properties:

\begin{verbatim}
javax.portlet.init-param.always-display-default-configuration-icons=true
\end{verbatim}

  In this example, the action appears in the System Settings portlet. To
  make it appear in a secondary screen, you can use the \texttt{path}
  property as shown below. The value of the \texttt{path} property
  depends on the MVC framework used to develop the app. For the
  MVCPortlet framework, provide the path (often a JSP) from the
  \texttt{mvcPath} parameter. For MVCPortlet with MVC Commands, the path
  should contain the \texttt{mvcRenderCommandName} where the actions
  should be displayed (such as \texttt{/document\_library/edit\_folder}
  for example):

\begin{verbatim}
@Component(
    immediate = true,
    property = {
        "javax.portlet.name=" + ConfigurationAdminPortletKeys.SYSTEM_SETTINGS,
        "path=/view_factory_instances"
    },
    service = PortletConfigurationIcon.class
)
public class ExportFactoryInstancesIcon extends BasePortletConfigurationIcon {

    @Override
    public String getMessage(PortletRequest portletRequest) {
        ThemeDisplay themeDisplay = (ThemeDisplay)portletRequest.getAttribute(
            WebKeys.THEME_DISPLAY);

        ResourceBundle resourceBundle = ResourceBundleUtil.getBundle(
            themeDisplay.getLocale(), ExportFactoryInstancesIcon.class);

        return LanguageUtil.get(resourceBundle, "export-entries");
    }

    @Override
    public String getMethod() {
        return "GET";
    }

    @Override
    public String getURL(
        PortletRequest portletRequest, PortletResponse portletResponse) {

        LiferayPortletURL liferayPortletURL =
            (LiferayPortletURL)_portal.getControlPanelPortletURL(
                portletRequest, ConfigurationAdminPortletKeys.SYSTEM_SETTINGS,
                PortletRequest.RESOURCE_PHASE);

        ConfigurationModel factoryConfigurationModel =
            (ConfigurationModel)portletRequest.getAttribute(
                ConfigurationAdminWebKeys.FACTORY_CONFIGURATION_MODEL);

        liferayPortletURL.setParameter(
            "factoryPid", factoryConfigurationModel.getFactoryPid());

        liferayPortletURL.setResourceID("export");

        return liferayPortletURL.toString();
    }

    @Override
    public double getWeight() {
        return 1;
    }

    @Override
    public boolean isShow(PortletRequest portletRequest) {
        ConfigurationModelIterator configurationModelIterator =
            (ConfigurationModelIterator)portletRequest.getAttribute(
                ConfigurationAdminWebKeys.CONFIGURATION_MODEL_ITERATOR);

        if (configurationModelIterator.getTotal() > 0) {
            return true;
        }

        return false;
    }

    @Reference
    private Portal _portal;

}
\end{verbatim}
\end{enumerate}

This covers some of the available methods. See the
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/configuration/icon/BasePortletConfigurationIcon.html}{Javadoc}
for a complete list of the available methods.

Great! Now you know how to configure your admin app's actions.

\subsection{Related Topics}\label{related-topics-39}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/applying-clay-patterns-to-navigation}{Applying
  Clay Patterns to Your Navigation Bar}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/configuring-your-applications-title-and-back-link}{Configuring
  Your Application's Title and Back Link}
\end{itemize}

\section{Automatic Single Page
Applications}\label{automatic-single-page-applications}

A good user experience is the measure of a well-designed site. A user's
time is highly valuable. The last thing you want is for someone to grow
frustrated with your site because of constant page reloads. A Single
Page Application (SPA) avoids this issue. Single Page Applications
drastically cut down on load times by loading only a single HTML page
that's dynamically updated as the user interacts and navigates through
the site. This provides a more seamless app experience by eliminating
page reloads. \textbf{SPA is enabled by default in your apps and sites
and requires no changes to your workflow or code!}

This tutorial covers these key topics:

\begin{itemize}
\tightlist
\item
  The benefits of SPAs
\item
  What is SennaJS?
\item
  How to enable SPA in Liferay DXP
\item
  How to configure SPA settings
\item
  How to listen to SPA lifecycle events
\end{itemize}

\subsection{The Benefits of SPAs}\label{the-benefits-of-spas}

Let's say you're surfing the web and you find a really rad site that
happens to be SPA enabled. All right! Page load times are blazin' fast.
You're deep into the site, scrolling along, when you find this great
post that just speaks to you. You copy the URL from the address bar and
email it to all of your friends with the subject: `Your Life Will Change
Forever.' They must experience this awe-inspiring work!

You get a response back almost immediately. ``This is a rad site, but
what post are you talking about?'' it reads.

``What!? Do my eyes deceive me?'' you exclaim. You were in so much of a
hurry to share this life-changing content that you neglected to notice
that the URL never updated when you clicked the post. You click the back
button, hoping to get back to the post, but it takes you to the site you
were on before you ever visited this one. The page history didn't update
as you navigated through the app; Only the main app URL was saved.

What a bummer! ``Why? Why have you failed me, site?'' you cry.

If only there was a way to have a Single Page Application, but also be
able to link to the content you want. Well, don't despair my friend. You
can have your cake and eat it too, thanks to SennaJS.

\subsection{What is SennaJS?}\label{what-is-sennajs}

SennaJS is Liferay DXP's SPA engine. SennaJS handles the client-side
data, and AJAX loads the page's content dynamically. While there are
other JavaScript frameworks out there that may provide some of the same
features, Senna's only focus is SPA, ensuring that your site provides
the best user experience possible.

SennaJS provides the following key enhancements to SPA:

\textbf{SEO \& Bookmarkability}: Sharing or bookmarking a link displays
the same content you are viewing. Search engines are able to index this
content.

\textbf{Hybrid rendering}: Ajax + server-side rendering lets you disable
\texttt{pushState} at any time, allowing progressive enhancement. You
can use your preferred method to render the server side (e.g.~HTML
fragments or template views).

\textbf{State retention}: Scrolling, reloading, or navigating through
the history of the page takes you back to where you were.

\textbf{UI feedback}: The UI indicates to the user when some content is
requested.

\textbf{Pending navigations}: UI rendering is blocked until data is
loaded, and the content is displayed all at once.

\textbf{Timeout detection}: If the request takes too long to load or the
user tries to navigate to a different link while another request is
pending, the request times out.

\textbf{History navigation}: The browser history is manipulated via the
\href{https://developer.mozilla.org/en-US/docs/Web/API/History}{History
API}, so you can use the back and forward history buttons to navigate
through the history of the page.

\textbf{Cacheable screens}: Once a surface is loaded, the content is
cached in memory and is retrieved later without any additional request,
speeding up your application.

\textbf{Page resources management}: Scripts and stylesheets are
evaluated from dynamically loaded resources. Additional content can be
appended to the DOM using \texttt{XMLHttpRequest}. For security reasons,
some browsers won't evaluate \texttt{\textless{}script\textgreater{}}
tags from content fragments. Therefore, SennaJS extracts scripts from
the content and parses them to ensure that they meet the browser loading
requirements.

You can see examples and read more about SennaJS at its
\href{http://sennajs.com/}{website}.

Now that you have a better understanding of how SennaJS benefits SPA,
you can learn how to enable and configure options for SPA within Liferay
DXP next.

\subsection{Enabling SPA}\label{enabling-spa}

Enabling SPA is easy. Since this module is included by default, you
shouldn't have to do anything. If you've removed it, deploy
\texttt{com.liferay.frontend.js.spa.web-{[}version{]}} module and enable
it, and you're all set to use SPA.

\textbf{SPA is enabled by default in your apps and sites, and requires
no changes to your workflow or existing code!}

Next you can learn how to customize SPA settings to meet your own needs.

\subsection{Customizing SPA Settings}\label{customizing-spa-settings}

Depending on what behaviors you need to customize, you can configure SPA
options in one of two places. SPA caching and SPA timeout settings are
configured in System Settings. If you wish to disable SPA for a certain
link, page, or portlet in your site, you can do so within the
corresponding element itself. All SPA configuration options are covered
here.

\subsubsection{Configuring SPA System
Settings}\label{configuring-spa-system-settings}

To configure system settings for SPA, follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In the Control Panel, navigate to \emph{Configuration} → \emph{System
  Settings}.
\item
  Select \emph{Infrastructure} under the \emph{PLATFORM} heading.
\item
  Click \emph{Frontend SPA Infrastructure}.
\end{enumerate}

The following configuration options are available:

\textbf{Cache Expiration Time}: The time, in minutes, in which the SPA
cache is cleared. A negative value means the cache should be disabled.

\textbf{Navigation Exception Selectors}: Defines a CSS selector that SPA
should ignore.

\textbf{Request Timeout Time}: The time, in milliseconds, in which a SPA
request times out. A zero value means the request should never timeout.

\textbf{User Notification Timeout}: The time, in milliseconds, in which
a notification is shown to the user stating that the request is taking
longer than expected. A zero value means no notification should be
shown.

Now that you know how to configure system settings for SPA, you can
learn how to disable SPA for elements in your site next.

\subsubsection{Disabling SPA}\label{disabling-spa}

Certain elements of your page may require a regular navigation to work
properly. For example, you may have downloadable content that you want
to share with the user. In these cases, SPA must be disabled for those
specific elements.

To disable SPA across an entire Liferay DXP instance, you can add the
following line to your \texttt{portal-ext.properties}:

\begin{verbatim}
javascript.single.page.application.enabled = false
\end{verbatim}

If there is a portlet or element that you don't want to be part of the
SPA, you have some options:

\begin{itemize}
\tightlist
\item
  Blacklist the portlet to disable SPA for the entire portlet
\item
  Use the \texttt{data-senna-off} annotation to disable SPA for a
  specific form or link
\end{itemize}

To blacklist a portlet from SPA, follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open your portlet class.
\item
  Set the \texttt{com.liferay.portlet.single-page-application} property
  to false:

\begin{verbatim}
com.liferay.portlet.single-page-application=false
\end{verbatim}

  If you prefer, you can set this property to false in your
  \texttt{portlet.xml} instead by adding the following property to the
  \texttt{\textless{}portlet\textgreater{}} section:

\begin{verbatim}
<single-page-application>false</single-page-application>
\end{verbatim}
\item
  Alternatively, you can override the
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-impl/com/liferay/portal/model/impl/PortletImpl.html\#isSinglePageApplication--}{\texttt{isSinglePageApplication}
  method} of the portlet to return \texttt{false}.
\end{enumerate}

To disable SPA for a form or link follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add the \texttt{data-senna-off} attribute to the element.
\item
  Set the value to \texttt{true}.
\end{enumerate}

For example
\texttt{\textless{}a\ data-senna-off="true"\ href="/pages/page2.html"\textgreater{}Page\ 2\textless{}/a\textgreater{}}

That's all you need to do to disable SPA in your app.

Now that you know how to disable SPA, you can learn how to specify how
resources are loaded during navigation.

\subsubsection{Specifying How Resources Are Loaded During
Navigation}\label{specifying-how-resources-are-loaded-during-navigation}

By default, Liferay DXP unloads CSS resources from the
\texttt{\textless{}head\textgreater{}} element on navigation. JavaScript
resources in the \texttt{\textless{}head\textgreater{}}, however, are
not removed on navigation. This functionality can be customized by
setting the resource's \texttt{data-senna-track} attribute. Follow these
steps to customize your resources:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Select the resource you want to modify the default behavior for.
\item
  Add the \texttt{data-senna-track} attribute to the resource.
\item
  Set the \texttt{data-senna-track} attribute to \texttt{permanent} to
  prevent a resource from unloading on navigation.

  Alternatively, set the \texttt{data-senna-track} attribute to
  \texttt{temporary} to unload the resource on navigation.
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** the `data-senna-track` attribute can be added to resources loaded
 outside of the `<head>` element as well to specify navigation behavior.
\end{verbatim}

\noindent\hrulefill

The example below ensures that the JS resource isn't unloaded during
navigation:

\begin{verbatim}
<script src="myscript.js" data-senna-track="permanent" />
\end{verbatim}

Next you can learn about the available SPA lifecycle events next.

\subsection{Listening to SPA Lifecycle
Events}\label{listening-to-spa-lifecycle-events}

During development, you may need to know when navigation has started or
stopped in your SPA. SennaJS makes this easy by exposing lifecycle
events that represent state changes in the application. The following
events are available:

\textbf{beforeNavigate}: Fires before navigation starts. This event
passes a JSON object with the path to the content you are navigating to
and whether to update the history. Below is an example event payload:

\begin{verbatim}
{ path: '/pages/page1.html', replaceHistory: false }
\end{verbatim}

\textbf{startNavigate}: Fires when navigation begins. Below is an
example event payload:

\begin{verbatim}
{ form: '<form name="form"></form>', path: '/pages/page1.html',
replaceHistory: false }
\end{verbatim}

\textbf{endNavigate}: Fired after the content has been retrieved and
inserted onto the page. This event passes the following JSON object:

\begin{verbatim}
{ form: '<form name="form"></form>', path: '/pages/page1.html' }
\end{verbatim}

These events can be leveraged easily by listening for them on the
Liferay global object. For example, the JavaScript below alerts the user
to ``Get ready to navigate to'' the URL that has been clicked, just
before SPA navigation begins:

\begin{verbatim}
Liferay.on('beforeNavigate', function(event) {
    alert("Get ready to navigate to " + event.path);
});
\end{verbatim}

The alert takes advantage of the payload for the \texttt{beforeNavigate}
event, retrieving the URL from the \texttt{path} attribute of the JSON
payload object.

\begin{figure}
\centering
\includegraphics{./images/private-messaging-before-navigate.png}
\caption{You can leverage SPA lifecycle events in your apps.}
\end{figure}

Due to the nature of SPA navigation, global listeners that you create
can become problematic over time if not handled properly. You'll learn
how to handle these listeners next.

\subsection{Detaching Global
Listeners}\label{detaching-global-listeners}

SPA provides several improvements that highly benefit your site and
users, but there is potentially some additional maintenance as a
consequence. In a traditional navigation scenario, every page refresh
resets everything, so you don't have to worry about what's left behind.
In a SPA scenario, however, global listeners such as
\texttt{Liferay.on}, \texttt{Liferay.after}, or body delegates can
become problematic. Every time you execute these global listeners, you
add yet another listener to the globally persisted \texttt{Liferay}
object. The result is multiple invocations of those listeners. This can
obviously cause problems if not handled.

To prevent this, you need to listen to the navigation event in order to
detach your listeners. For example, you would use the following code to
detach the event listeners of a global \texttt{category} event:

\begin{verbatim}
var onCategory = function(event) {...};

var clearPortletHandlers = function(event) {
    if (event.portletId === '<%= portletDisplay.getRootPortletId() %>') {
        Liferay.detach('onCategoryHandler', onCategory);
        Liferay.detach('destroyPortlet', clearPortletHandlers);
    }
};


Liferay.on('category', onCategory);
Liferay.on('destroyPortlet', clearPortletHandlers);
\end{verbatim}

Now you know how to configure and use SPA in Liferay DXP!

\subsection{Related Topics}\label{related-topics-40}

\href{/docs/7-1/tutorials/-/knowledge_base/t/preparing-your-javascript-files-for-esplus}{Preparing
your JavaScript Files for ES2015+}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-esplus-modules-in-your-portlet}{Using
ES2015+ Modules in Your Portlet}

\section{Creating Layouts inside Custom
Portlets}\label{creating-layouts-inside-custom-portlets}

Layout templates specify how your portlets and content are organized on
your site pages. What if, instead, you want to organize your portlet's
content? \texttt{\textless{}aui\textgreater{}} tags let you create
layouts using Bootstrap within your portlets. This tutorial explains
this process.

Follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open your portlet's JSP and include the AUI taglib declaration if it's
  not already included:

\begin{verbatim}
<%@ taglib uri="http://liferay.com/tld/aui" prefix="aui" %>
\end{verbatim}
\item
  Wrap your portlet's content in
  \hyperref[aui-container]{\texttt{\textless{}aui:container\textgreater{}}
  tags}. If you wish to only have a portion of your portlet's content in
  a layout, wrap that portion with a
  \texttt{\textless{}aui:container\textgreater{}} tags.
\item
  In between the
  \texttt{\textless{}aui:container\textgreater{}...\textless{}/aui:container\textgreater{}}
  tags, add a set of
  \hyperref[aui-row]{\texttt{\textless{}aui:row\textgreater{}} tags} for
  each row that you want in your portlet's layout.
\item
  Add a set of
  \hyperref[aui-col]{\texttt{\textless{}aui:col\textgreater{}} tags} for
  each column that you want in the row. Repeat this step for each row in
  the layout.
\end{enumerate}

A complete example is shown below:

\begin{verbatim}
<aui:container>
  <aui:row>
    <aui:col md="12">
      <h1>My Custom Layout Portlet</h1>
    </aui:col>
  </aui:row>
  <aui:row>
    <aui:col md="4" sm="6">
      <h2>Column One</h2>
      <p>
        Lorem ipsum dolor sit amet, consectetur adipiscing elit. 
        Integer eget pulvinar quam. Vivamus ornare leo libero, sed 
        mollis urna aliquam ac. Duis porta sapien non felis varius, in 
        iaculis orci fermentum. Etiam quis molestie elit, in tempor 
        risus. Morbi varius elementum lectus at feugiat. Quisque 
        dapibus orci ac dui eleifend, ut ullamcorper nulla sagittis. 
        Ut ac scelerisque sem.
      </p>
    </aui:col>
    <aui:col md="8" sm="6">
    <h2>Column Two</h2>
      <p>
        Aliquam hendrerit augue sed nisl ullamcorper pulvinar. Donec 
        tristique congue erat ac condimentum. Suspendisse vehicula 
        nunc vel velit imperdiet dapibus. In hac habitasse platea 
        dictumst. Morbi eleifend arcu sit amet magna faucibus, vitae 
        posuere erat finibus. Sed hendrerit convallis ipsum id luctus. 
        Aliquam aliquam consequat turpis eu vulputate. Nulla vitae 
        libero lorem. Proin nec lacus et nunc laoreet posuere. 
        Vestibulum euismod vestibulum faucibus. Vivamus dolor justo, 
        malesuada ac libero ac, feugiat varius leo. Integer viverra 
        nisi vel fringilla aliquam.
      </p>
      <p>
        Suspendisse potenti. Mauris neque nisl, hendrerit a sem at, 
        rutrum dictum arcu. Ut aliquet tortor vel tortor interdum 
        dictum. Sed non sapien quam. Nunc aliquet in massa elementum 
        aliquam. Cras convallis tristique ante ut ultrices. Aenean 
        quis congue nulla. Integer in lacus lectus. Mauris maximus, 
        nibh sit amet pharetra laoreet, sem dolor eleifend metus, non 
        semper sem justo vel mauris. Praesent tristique quis risus 
        vulputate faucibus. Nullam feugiat diam vel elit pharetra, id 
        porta velit fringilla. Pellentesque metus justo, dictum et 
        dolor venenatis, pretium egestas massa. Donec risus nisi, 
        elementum in lectus id, imperdiet blandit mauris.
      </p>
    </aui:col>
  </aui:row>
</aui:container>
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/portlets-layout.png}
\caption{Custom layouts in your portlets let you organize your portlet's
content with the user in mind.}
\end{figure}

The columns in the second row take advantage of Bootstrap's grid classes
to create responsive layouts. On medium sized view ports,
\texttt{column-1} is 33.33\% width and \texttt{column-2} is 66.66\%
width, but on small sized view ports both \texttt{column-1} and
\texttt{column-2} are 50\% width.

\begin{figure}
\centering
\includegraphics{./images/portlets-layout-responsive.png}
\caption{You can take advantage of Bootstrap's grid classes to create
responsive layouts within your custom portlets.}
\end{figure}

\subsection{AUI Layout Tag Attributes}\label{aui-layout-tag-attributes}

This section contains a list of the available attributes for each tag
along with a brief description of its purpose.

\subsubsection{AUI Container}\label{aui-container}

The \texttt{\textless{}aui:container\textgreater{}} tag creates a
container \texttt{\textless{}div\textgreater{}} tag to wrap
\texttt{\textless{}aui:row\textgreater{}} components and offer
additional styling.

It supports the following attributes:

\noindent\hrulefill

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.3333}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Attribute
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Type
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Description
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
cssClass & String & A CSS class for styling the component \\
dynamicAttributes & Map\textless String, Object\textgreater{} & Map of
\texttt{data-} attributes for your container \\
fluid & boolean & Whether to enable the container to span the entire
width of the viewport. The default value is true \\
id & String & An ID for the component instance \\
\end{longtable}

\noindent\hrulefill

\subsubsection{AUI Row}\label{aui-row}

The \texttt{\textless{}aui:row\textgreater{}} tag creates a row to hold
\texttt{\textless{}aui:col\textgreater{}} components.

It supports the following attributes:

\noindent\hrulefill

\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Attribute & Type & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
cssClass & String & A CSS class for styling the component \\
id & String & An ID for the component instance \\
\end{longtable}

\noindent\hrulefill

\subsubsection{AUI Col}\label{aui-col}

The \texttt{\textless{}aui:col\textgreater{}} tag creates a column to
display content in an \texttt{\textless{}aui:row\textgreater{}}
component.

It supports the following attributes:

\noindent\hrulefill

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.3333}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Attribute
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Type
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Description
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
cssClass & String & A CSS class for styling the component. \\
id & String & An ID for the component instance. \\
lg & String & Comma separated string of numbers 1-12 to be used for
Boostrap grid \texttt{col-lg-} \\
md & String & Comma separated string of numbers 1-12 to be used for
Boostrap grid \texttt{col-md-} \\
sm & String & Comma separated string of numbers 1-12 to be used for
Boostrap grid \texttt{col-sm-} \\
xs & String & Comma separated string of numbers 1-12 to be used for
Boostrap grid \texttt{col-xs-} \\
span & int & The width of the column in the containing row as a fraction
of 12. For example, a span of 4 would result in a column width 4/12 (or
1/3) of the total width of the containing row. \\
width & int & The width of the column in the containing row as a
percentage, overriding the span attribute. The width is then converted
to a span expressed as ((width/100) x 12), rounded to the nearest whole
number. For example, a width of 33 would be converted to 3.96, which
would be rounded up to a span value of 4. \\
\end{longtable}

\noindent\hrulefill

Now you know how to create layouts inside your portlets!

\subsection{Related Topics}\label{related-topics-41}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-layout-templates-with-the-themes-generator}{Layout
Templates with the Liferay Theme Generator}

\chapter{Customizing}\label{customizing}

\href{/docs/7-1/tutorials/-/knowledge_base/t/portlets}{Portlets} are the
main application platform, and
\href{/docs/7-1/tutorials/-/knowledge_base/t/themes-and-layout-templates}{themes}
let you style your sites. You can also modify existing behavior,
globally and in the installed applications, as well as specify your own
look and feel.

The \emph{Customizing} tutorials below show you how to affect your site
in the following ways:

\begin{itemize}
\tightlist
\item
  Add, modify, or remove content
\item
  Modify behavior
\item
  Perform actions that respond to events
\end{itemize}

\chapter{Customizing JSPs}\label{customizing-jsps}

There are several different ways to customize JSPs in portlets and the
core. Liferay DXP's API provides the safest ways to customize them. If
you customize a JSP by other means, new versions of the JSP can render
your customization invalid and leave you with runtime errors. It's
highly recommended to use one of the API-based ways.

\section{Using Liferay's API to Override a
JSP}\label{using-liferays-api-to-override-a-jsp}

Here are API-based approaches to overriding JSPs in Liferay DXP:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.2857}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.3571}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.3571}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
\textbf{Approach}
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\textbf{Description}
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\textbf{Cons/Limitations}
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\href{/docs/7-1/tutorials/-/knowledge_base/t/customizing-jsps-with-dynamic-includes}{Dynamic
includes} & Adds content at dynamic include tags. & Limited to JSPs that
have \texttt{dynamic-include} tags (or tags whose classes inherit from
\texttt{IncludeTag}). Only inserts content in the JSPs at the dynamic
include tags. \\
\href{/docs/7-1/tutorials/-/knowledge_base/t/jsp-overrides-using-portlet-filters}{Portlet
filters} & Modifies portlet requests and/or responses to simulate a JSP
customization. & Although this approach doesn't directly customize a
JSP, it achieves the effect of a JSP customization. \\
\end{longtable}

\section{Overriding a JSP Without Using Liferay's
API}\label{overriding-a-jsp-without-using-liferays-api}

It's strongly recommended to customize JSPs using Liferay DXP's API, as
the previous section describes. Since overriding a JSP using an OSGi
fragment or a Custom JSP Bag is not based on APIs there's no way to
guarantee that they'll fail gracefully. Instead, if your customization
is buggy (because of your code or because of a change in Liferay), you
are most likely to find out at runtime, where functionality breaks and
nasty log errors greet you. These approaches should only be used as a
last resort.

If you're maintaining a JSP customization that uses one of these
approaches, you should know how they work. This section describes them
and links to their tutorials.

Here are ways to customize JSPs without using Liferay DXP's API:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.2857}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.3571}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.3571}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
\textbf{Approach}
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\textbf{Description}
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\textbf{Cons/Limitations}
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\href{/docs/7-1/tutorials/-/knowledge_base/t/jsp-overrides-using-osgi-fragments}{OSGi
fragment} & Completely overrides a module's JSP using an OSGi fragment &
Changes to the original JSP or module can cause runtime errors. \\
\href{/docs/7-1/tutorials/-/knowledge_base/t/jsp-overrides-using-custom-jsp-bag}{Custom
JSP bag} & Completely override a Liferay DXP core JSP or one of its
corresponding \texttt{-ext.jsp} files. & For Liferay DXP core JSPs only.
Changes to the original JSP or module can cause runtime errors. \\
\end{longtable}

All the JSP customization approaches are available to you. It's time to
customize some JSPs!

\section{Customizing JSPs with Dynamic
Includes}\label{customizing-jsps-with-dynamic-includes}

The
\href{https://docs.liferay.com/dxp/portal/7.1-latest/taglibs/util-taglib/liferay-util/dynamic-include.html}{\texttt{liferay-util:dynamic-include}
tag} is placeholder into which you can inject content. Every JSP's
dynamic include tag is an extension point for inserting content (e.g.,
JavaScript code, HTML, and more). To do this, create a module that has
content you want to insert, register that content with the dynamic
include tag, and deploy your module.

\noindent\hrulefill

\textbf{Note}: If the JSP you want to customize has no
\texttt{liferay-util:dynamic-include} tags (or tags whose classes
inherit from \texttt{IncludeTag}), you must use a different
customization approach, such as
\href{/docs/7-1/tutorials/-/knowledge_base/t/jsp-overrides-using-portlet-filters}{portlet
filters}.

\noindent\hrulefill

Blogs entries contain a good example of how dynamic includes work. For
reference, you can download the
\href{https://portal.liferay.dev/documents/113763090/114000186/example-dynamic-include-blogs-master.zip}{example
module}.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Find the \texttt{liferay-util:dynamic-include} tag where you want to
  insert content and note the tag's key.

  The Blogs app's \texttt{view\_entry.jsp} has a dynamic include tag at
  the top and another at the very bottom.

\begin{verbatim}
<%@ include file="/blogs/init.jsp" %>

<liferay-util:dynamic-include key="com.liferay.blogs.web#/blogs/view_entry.jsp#pre" />

    ... JSP content is here

<liferay-util:dynamic-include key="com.liferay.blogs.web#/blogs/view_entry.jsp#post" />
\end{verbatim}

  Here are the Blogs view entry dynamic include keys:

  \begin{itemize}
  \tightlist
  \item
    \texttt{key="com.liferay.blogs.web\#/blogs/view\_entry.jsp\#pre"}
  \item
    \texttt{key="com.liferay.blogs.web\#/blogs/view\_entry.jsp\#post"}
  \end{itemize}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/starting-module-development}{Create
  a module} (e.g., \texttt{blade\ create\ my-dynamic-include}). The
  module will hold your dynamic include implementation.
\item
  Specify compile-only dependencies, like these Gradle dependencies, in
  your module build file:

\begin{verbatim}
dependencies {
    compileOnly group: "javax.portlet", name: "portlet-api", version: "2.0"
    compileOnly group: "javax.servlet", name: "javax.servlet-api", version: "3.0.1"
    compileOnly group: "com.liferay", name: "com.liferay.petra.string", version: "1.0.0"
    compileOnly group: "com.liferay.portal", name: "com.liferay.portal.kernel", version: "2.0.0"
    compileOnly group: "org.osgi", name: "osgi.cmpn", version: "6.0.0"
}
\end{verbatim}
\item
  Create an OSGi component class that implements the
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/servlet/taglib/DynamicInclude.html}{\texttt{DynamicInclude}
  interface}.

  Here's an example dynamic include implementation for Blogs:

\begin{verbatim}
import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.osgi.service.component.annotations.Component;

import com.liferay.portal.kernel.servlet.taglib.DynamicInclude;

@Component(
    immediate = true,
    service = DynamicInclude.class
)
public class BlogsDynamicInclude implements DynamicInclude {

    @Override
    public void include(
            HttpServletRequest request, HttpServletResponse response,
            String key)
        throws IOException {

        PrintWriter printWriter = response.getWriter();

        printWriter.println(
            "<h2>Added by Blogs Dynamic Include!</h2><br />");
    }

    @Override
    public void register(DynamicIncludeRegistry dynamicIncludeRegistry) {
        dynamicIncludeRegistry.register(
            "com.liferay.blogs.web#/blogs/view_entry.jsp#pre");
    }

}
\end{verbatim}

  Giving the class an \texttt{@Component} annotation that has the
  service attribute \texttt{service\ =\ DynamicInclude.class} makes the
  class a \texttt{DynamicInclude} service component.

\begin{verbatim}
@Component(
    immediate = true,
    service = DynamicInclude.class
)
\end{verbatim}

  In the \texttt{include} method, add your content. The example
  \texttt{include} method writes a heading.

\begin{verbatim}
@Override
public void include(
        HttpServletRequest request, HttpServletResponse response,
        String key)
    throws IOException {

    PrintWriter printWriter = response.getWriter();

    printWriter.println(
    "<h2>Added by Blogs Dynamic Include!</h2><br />");
}
\end{verbatim}

  In the \texttt{register} method, specify the dynamic include tag to
  use. The example register method targets the dynamic include at the
  top of the Blogs \texttt{view\_entry.jsp}.

\begin{verbatim}
@Override
public void register(DynamicIncludeRegistry dynamicIncludeRegistry) {
    dynamicIncludeRegistry.register(
        "com.liferay.blogs.web#/blogs/view_entry.jsp#pre");
}
\end{verbatim}
\end{enumerate}

Once you've
\href{/docs/7-1/tutorials/-/knowledge_base/t/starting-module-development\#building-and-deploying-a-module}{deployed
your module}, the JSP dynamically includes your content. Congratulations
on injecting dynamic content into a JSP!

\section{JSP Overrides Using Portlet
Filters}\label{jsp-overrides-using-portlet-filters}

Portlet filters let you intercept portlet requests before they're
processed and portlet responses after they're processed but before
they're sent back to the client. You can operate on the request and / or
response to modify the JSP content. Unlike dynamic includes, portlet
filters give you access to all the content sent back to the client.

This demonstration uses a portlet filter to modify content in Liferay's
Blogs portlet. For reference, you can download the
\href{https://portal.liferay.dev/documents/113763090/114000186/example-portlet-filter-customize-jsp-master.zip}{example
module}.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a new module and make sure it specifies these compile-only
  dependencies, shown here in Gradle format:

\begin{verbatim}
dependencies {
    compileOnly group: "javax.portlet", name: "portlet-api", version: "2.0"
    compileOnly group: "javax.servlet", name: "javax.servlet-api", version: "3.0.1"
    compileOnly group: "com.liferay.portal", name: "com.liferay.portal.kernel", version: "2.0.0"
    compileOnly group: "org.osgi", name: "osgi.cmpn", version: "6.0.0"
}
\end{verbatim}
\item
  Create an OSGi component class that implements the
  \texttt{javax.portlet.filter.RenderFilter} interface.

  Here's an example portlet filter implementation for Blogs:

\begin{verbatim}
import java.io.IOException;

import javax.portlet.PortletException;
import javax.portlet.RenderRequest;
import javax.portlet.RenderResponse;
import javax.portlet.filter.FilterChain;
import javax.portlet.filter.FilterConfig;
import javax.portlet.filter.PortletFilter;
import javax.portlet.filter.RenderFilter;
import javax.portlet.filter.RenderResponseWrapper;

import org.osgi.service.component.annotations.Component;

import com.liferay.portal.kernel.util.PortletKeys;

@Component(
    immediate = true,
    property = {
            "javax.portlet.name=" + PortletKeys.BLOGS
    },
    service = PortletFilter.class
)
public class BlogsRenderFilter implements RenderFilter {

    @Override
    public void init(FilterConfig config) throws PortletException {

    }

    @Override
    public void destroy() {

    }

    @Override
    public void doFilter(RenderRequest request, RenderResponse response, FilterChain chain)
            throws IOException, PortletException {

        RenderResponseWrapper renderResponseWrapper = new BufferedRenderResponseWrapper(response);

        chain.doFilter(request, renderResponseWrapper);

        String text = renderResponseWrapper.toString();

        if (text != null) {
            String interestingText = "<input  class=\"field form-control\"";

            int index = text.lastIndexOf(interestingText);

            if (index >= 0) {
                String newText1 = text.substring(0, index);
                String newText2 = "\n<p>Added by Blogs Render Filter!</p>\n";
                String newText3 = text.substring(index);

                String newText = newText1 + newText2 + newText3;

                response.getWriter().write(newText);
            }
        }
    }

}
\end{verbatim}
\item
  Make your class a \texttt{PortletFilter} service component by giving
  it the \texttt{@Component} annotation that has the service attribute
  \texttt{service\ \ \ \ \ =\ PortletFilter.class}. Target the portlet
  whose content you're overriding by assigning it a javax.portlet.name
  property that's the same as your portlet's key. Here's the example
  \texttt{@Component} annotation:

\begin{verbatim}
@Component(
   immediate = true,
   property = {
           "javax.portlet.name=" + PortletKeys.BLOGS
   },
   service = PortletFilter.class
)
\end{verbatim}
\item
  Override the \texttt{doFilterMethod} to operate on the request or
  response to produce the content you want. The example appends a
  paragraph stating \texttt{Added\ \ \ \ \ by\ Blogs\ Render\ Filter!}
  to the portlet content:

\begin{verbatim}
@Override
public void doFilter(RenderRequest request, RenderResponse response, FilterChain chain)
        throws IOException, PortletException {

    RenderResponseWrapper renderResponseWrapper = new BufferedRenderResponseWrapper(response);

    chain.doFilter(request, renderResponseWrapper);

    String text = renderResponseWrapper.toString();

    if (text != null) {
        String interestingText = "<input  class=\"field form-control\"";

        int index = text.lastIndexOf(interestingText);

        if (index >= 0) {
            String newText1 = text.substring(0, index);
            String newText2 = "\n<p>Added by Blogs Render Filter!</p>\n";
            String newText3 = text.substring(index);

            String newText = newText1 + newText2 + newText3;

            response.getWriter().write(newText);
        }
    }
}
\end{verbatim}

  The example uses a \texttt{RenderResponseWrapper} extension class
  called \texttt{BufferedRenderResponseWrapper}.
  \texttt{BufferedRenderResponseWrapper} is a helper class whose
  \texttt{toString} method returns the current response text and whose
  \texttt{getWriter} method lets you write data to the response before
  it's sent back to the client.

\begin{verbatim}
import java.io.CharArrayWriter;
import java.io.IOException;
import java.io.OutputStream;
import java.io.PrintWriter;

import javax.portlet.RenderResponse;
import javax.portlet.filter.RenderResponseWrapper;

public class BufferedRenderResponseWrapper extends RenderResponseWrapper {

    public BufferedRenderResponseWrapper(RenderResponse response) {
        super(response);

        charWriter = new CharArrayWriter();
    }

    public OutputStream getOutputStream() throws IOException {
        if (getWriterCalled) {
            throw new IllegalStateException("getWriter already called");
        }

        getOutputStreamCalled = true;

        return super.getPortletOutputStream();
    }

    public PrintWriter getWriter() throws IOException {
        if (writer != null) {
            return writer;
        }

        if (getOutputStreamCalled) {
            throw new IllegalStateException("getOutputStream already called");
        }

        getWriterCalled = true;

        writer = new PrintWriter(charWriter);

        return writer;
    }

    public String toString() {
        String s = null;

        if (writer != null) {
            s = charWriter.toString();
        }

        return s;
    }

    protected CharArrayWriter charWriter;
    protected PrintWriter writer;
    protected boolean getOutputStreamCalled;
    protected boolean getWriterCalled;

}
\end{verbatim}
\end{enumerate}

Once you've
\href{/docs/7-1/tutorials/-/knowledge_base/t/starting-module-development\#building-and-deploying-a-module}{deployed
your module}, the portlet's JSP shows your custom content.

Your portlet filter operates directly on portlet response content.
Unlike dynamic includes, portlet filters let you work with all of a
JSP's content.

\section{JSP Overrides Using OSGi
Fragments}\label{jsp-overrides-using-osgi-fragments}

You can completely override JSPs using OSGi fragments. This approach is
powerful but can make things unstable when the host module is upgraded:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  By overriding an entire JSP, you might not account for new content or
  new widgets essential to new host module versions.
\item
  Fragments are tied to a specific host module version. If the host
  module is upgraded, the fragment detaches from it. In this scenario,
  the original JSPs are still available and the module is functional
  (but lacks your JSP enhancements).
\item
  Liferay cannot guarantee that JSPs overridden by fragments can be
  upgraded.
\end{enumerate}

Using OSGi fragments to override JSPs is a bad practice, equivalent to
using Ext plugins to customize Liferay DXP. They should only be used as
a last resort. Liferay's API based approaches to overriding JSPs (i.e.,
\href{/docs/7-1/tutorials/-/knowledge_base/t/customizing-jsps-with-dynamic-includes}{Dynamic
Includes} and
\href{/docs/7-1/tutorials/-/knowledge_base/t/jsp-overrides-using-portlet-filters}{Portlet
Filters}), on the other hand, provide more stability as they customize
specific parts of JSPs that are safe to override. Also, the API based
approaches don't limit your override to a specific host module version.
If you are maintaining existing JSP overrides that use OSGi fragments,
however, this tutorial explains how they work.

An OSGi fragment that overrides a JSP requires these two things:

\begin{itemize}
\item
  The host module's symbolic name and version in the OSGi header
  \texttt{Fragment-Host} declaration.
\item
  The original JSP with any modifications you need to make.
\end{itemize}

For more information about fragment modules, you can refer to section
3.14 of the
\href{https://osgi.org/specification/osgi.core/7.0.0/framework.module.html}{OSGi
Alliance's core specification document}.

\subsection{Declaring a Fragment Host}\label{declaring-a-fragment-host}

There are two players in this game: the fragment and the host. The
fragment is a parasitic module that attaches itself to a host. That
sounds harsh, so let's compare the fragment-host relationship to the
relationship between a pilot fish and a huge, scary shark. It's
symbiotic, really. Your fragment module benefits by not doing much work
(like the pilot fish who benefits from the shark's hunting prowess). In
return, the host module gets whatever benefits you've conjured up in
your fragment's JSPs (for the shark, it gets free dental cleanings!). To
the OSGi runtime, your fragment is part of the host module.

Your fragment must declare two things to the OSGi runtime regarding the
host module:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  The Bundle Symbolic Name of the host module. This is the module
  containing the original JSP.
\item
  The exact version of the host module to which the fragment belongs.
\end{enumerate}

Both are declared using the OSGi manifest header \texttt{Fragment-Host}.

\begin{verbatim}
Fragment-Host: com.liferay.login.web;bundle-version="[1.0.0,1.0.1)"
\end{verbatim}

Supplying a specific host module version is important. If that version
of the module isn't present, your fragment won't attach itself to a
host, and that's a good thing. A new version of the host module might
have changed its JSPs, so if your now-incompatible version of the JSP is
applied to the host module, you'll break the functionality of the host.
It's better to detach your fragment and leave it lonely in the OSGi
runtime than it is to break the functionality of an entire application.

\subsection{Provide the Overridden
JSP}\label{provide-the-overridden-jsp}

There are two possible naming conventions for targeting the host
original JSP: \texttt{portal} or \texttt{original}. For example, if the
original JSP is in the folder \texttt{/META-INF/resources/login.jsp},
then the fragment bundle should contain a JSP with the same path, using
the following pattern:

\begin{verbatim}
<liferay-util:include 
    page="/login.original.jsp" (or login.portal.jsp) 
    servletContext="<%= application %>" 
/>
\end{verbatim}

After that, make your modifications. Just make sure you mimic the host
module's folder structure when overriding its JAR. If you're overriding
Liferay's login application's \texttt{login.jsp} for example, you'd put
your own \texttt{login.jsp} in

\begin{verbatim}
my-jsp-fragment/src/main/resources/META-INF/resources/login.jsp
\end{verbatim}

If you must post-process the output, you can update the pattern to
include Liferay DXP's buffering mechanism. Below is an example that
overrides the original \texttt{create\_account.jsp}:

\begin{verbatim}
<%@ include file="/init.jsp" %>

<liferay-util:buffer var="html">
    <liferay-util:include page="/create_account.portal.jsp" 
    servletContext="<%= application %>"/>
</liferay-util:buffer>

<liferay-util:buffer var="openIdFieldHtml"><aui:input name="openId" 
type="hidden" value="<%= ParamUtil.getString(request, "openId") %>" />
</liferay-util:buffer>

<liferay-util:buffer var="userNameFieldsHtml"><liferay-ui:user-name-fields />
</liferay-util:buffer>

<liferay-util:buffer var="errorMessageHtml">
    <liferay-ui:error 
    exception="<%= com.liferay.portal.kernel.exception.NoSuchOrganizationException.class %>" message="no-such-registration-code" />
</liferay-util:buffer>

<liferay-util:buffer var="registrationCodeFieldHtml">
            <aui:input name="registrationCode" type="text" value="">
                    <aui:validator name="required" />
            </aui:input>
</liferay-util:buffer>

<%
    html = com.liferay.portal.kernel.util.StringUtil.replace(html, 
      openIdFieldHtml, openIdFieldHtml + errorMessageHtml);
    html = com.liferay.portal.kernel.util.StringUtil.replace(html, 
      userNameFieldsHtml, userNameFieldsHtml + registrationCodeFieldHtml);
%>

<%=html %>
\end{verbatim}

\noindent\hrulefill

\textbf{Note:} An OSGi fragment can access all of the fragment host's
packages---it doesn't need to import them from another bundle. bnd adds
external packages the fragment uses (even ones in the fragment host) to
the fragment's \texttt{Import-Package:\ {[}package{]},...} OSGi manifest
header. That's fine for packages exported to the OSGi runtime. The
problem is, however, when bnd tries to import a host's internal package
(a package the host doesn't export). The OSGi runtime can't activate the
fragment because the internal package remains an
\texttt{Unresolved\ \ requirement}---a fragment shouldn't import a
fragment host's packages.

If your fragment uses an internal package from the fragment host,
continue using it but explicitly exclude the package from your bundle's
\texttt{Import-Package} OSGi manifest header. This
\texttt{Import-Package} header, for example, excludes packages that
match \texttt{com.liferay.portal.search.web.internal.*}.

\begin{verbatim}
 Import-Package: !com.liferay.portal.search.web.internal.*,*
\end{verbatim}

\noindent\hrulefill

Now you can easily modify the JSPs of any application in Liferay.

\includegraphics{./images/sharks.jpg}

To see a sample JSP-modifying fragment in action, look at the
\href{/docs/7-1/reference/-/knowledge_base/r/module-jsp-override}{Module
JSP Override sample project}.

\subsection{Related Topics}\label{related-topics-42}

\href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-app-jsp-hook-plugins}{Upgrading
App JSP Hooks}

\section{JSP Overrides Using Custom JSP
Bag}\label{jsp-overrides-using-custom-jsp-bag}

Liferay's API based approaches to overriding JSPs (i.e.,
\href{/docs/7-1/tutorials/-/knowledge_base/t/customizing-jsps-with-dynamic-includes}{Dynamic
Includes} and
\href{/docs/7-1/tutorials/-/knowledge_base/t/jsp-overrides-using-portlet-filters}{Portlet
Filters}) are the best way to override JSPs in apps and in the core. You
can also use Custom JSP Bags to override core JSPs. But the approach is
not as stable as the API based approaches. If your Custom JSP Bag's JSP
is buggy (because of your code or because of a change in Liferay), you
are most likely to find out at runtime, where functionality breaks and
nasty log errors greet you. Using Custom JSP Bags to override JSPs is a
bad practice, equivalent to using Ext plugins to customize Liferay DXP.
If you're maintaining existing Custom JSP Bags, however, this tutorial
explains how they work.

\noindent\hrulefill

\textbf{Important:} Liferay cannot guarantee that JSPs overridden using
Custom JSP Bag can be upgraded.

\noindent\hrulefill

A Custom JSP Bag module must satisfy these criteria:

\begin{itemize}
\item
  Provides and specifies a custom JSP for the JSP you're extending.
\item
  Includes a
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-impl/com/liferay/portal/deploy/hot/CustomJspBag.html}{\texttt{CustomJspBag}}
  implementation for serving the custom JSPs.
\end{itemize}

The module provides transportation for this code into Liferay's OSGi
runtime. After you
\href{/docs/7-1/tutorials/-/knowledge_base/t/starting-module-development\#creating-a-module}{create
your new module}, continue with providing your custom JSP.

\subsection{Providing a Custom JSP}\label{providing-a-custom-jsp}

Create your JSPs to override Liferay DXP core JSPs. If you're using the
Maven
\href{https://maven.apache.org/guides/introduction/introduction-to-the-standard-directory-layout.html}{Standard
Directory Layout}, place your JSPs under
\texttt{src/main/resources/META-INF/jsps}. For example, if you're
overriding

\begin{verbatim}
portal-web/docroot/html/common/themes/bottom-ext.jsp 
\end{verbatim}

place your custom JSP at

\begin{verbatim}
[your module]/src/main/resources/META-INF/jsps/html/common/themes/bottom-ext.jsp
\end{verbatim}

\noindent\hrulefill

\textbf{Note:} If you place custom JSPs somewhere other than
\texttt{src/main/resources/META-INF/jsps} in your module, assign that
location to a \texttt{-includeresource:\ META-INF/jsps=} directive in
your module's \texttt{bnd.bnd} file. For example, if you place custom
JSPs in a folder \texttt{src/META-INF/custom\_jsps} in your module,
specify this in your \texttt{bnd.bnd}:

\begin{verbatim}
 -includeresource: META-INF/jsps=src/META-INF/custom_jsps
\end{verbatim}

\noindent\hrulefill

\subsection{Implement a Custom JSP
Bag}\label{implement-a-custom-jsp-bag}

Liferay DXP (specifically the
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-impl/com/liferay/portal/deploy/hot/CustomJspBagRegistryUtil.html}{\texttt{CustomJspBagRegistryUtil}
class}) loads JSPs from
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-impl/com/liferay/portal/deploy/hot/CustomJspBag.html}{\texttt{CustomJspBag}}
services. The following steps implement a custom JSP bag.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In your module, create a class that implements\\
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-impl/com/liferay/portal/deploy/hot/CustomJspBag.html}{\texttt{CustomJspBag}}.
\item
  Register your class as an OSGi service by adding an
  \texttt{@Component} annotation to it, like this:

\begin{verbatim}
@Component(
    immediate = true,
    property = {
        "context.id=BladeCustomJspBag",
        "context.name=Test Custom JSP Bag",
        "service.ranking:Integer=100"
    }
)
\end{verbatim}

  \begin{itemize}
  \tightlist
  \item
    \textbf{\texttt{immediate\ =\ true}:} Makes the service available on
    module activation.
  \item
    \textbf{\texttt{context.id}:} Your custom JSP bag class name.
    Replace \texttt{BladeCustomJspBag} with your class name.
  \item
    \textbf{\texttt{context.name}:} A more human readable name for your
    service. Replace it with a name of your own.
  \item
    \textbf{\texttt{service.ranking:Integer}:} A priority for your
    implementation. The container chooses the implementation with the
    highest priority.
  \end{itemize}
\item
  Implement the \texttt{getCustomJspDir} method to return the folder
  path in your module's JAR where the JSPs reside (for example,
  \texttt{META-INF/jsps}).

\begin{verbatim}
@Override
public String getCustomJspDir() {
    return "META-INF/jsps/";
}
\end{verbatim}
\item
  Create an \texttt{activate} method and the following fields. The
  method adds the URL paths of all your custom JSPs to a list when the
  module is activated.

\begin{verbatim}
@Activate
protected void activate(BundleContext bundleContext) {
    _bundle = bundleContext.getBundle();

    _customJsps = new ArrayList<>();

    Enumeration<URL> entries = _bundle.findEntries(
        getCustomJspDir(), "*.jsp", true);

    while (entries.hasMoreElements()) {
        URL url = entries.nextElement();

        _customJsps.add(url.getPath());
    }
}

private Bundle _bundle;
private List<String> _customJsps;
\end{verbatim}
\item
  Implement the \texttt{getCustomJsps} method to return the list of this
  module's custom JSP URL paths.

\begin{verbatim}
@Override
public List<String> getCustomJsps() {
    return _customJsps;
}
\end{verbatim}
\item
  Implement the \texttt{getURLContainer} method to return a new
  \texttt{com.liferay.portal.kernel.url.URLContainer}. Instantiate the
  URL container and override its \texttt{getResources} and
  \texttt{getResource} methods. The \texttt{getResources} method looks
  up all the paths to resources in the container by a given path. It
  returns a \texttt{HashSet} of \texttt{Strings} for the matching custom
  JSP paths. The \texttt{getResource} method returns one specific
  resource by its name (the path included).

\begin{verbatim}
@Override
public URLContainer getURLContainer() {
    return _urlContainer;
}

private final URLContainer _urlContainer = new URLContainer() {

    @Override
    public URL getResource(String name) {
        return _bundle.getEntry(name);
    }

    @Override
    public Set<String> getResources(String path) {
        Set<String> paths = new HashSet<>();

        for (String entry : _customJsps) {
            if (entry.startsWith(path)) {
               paths.add(entry);
            }
        }

        return paths;
    }

};
\end{verbatim}
\item
  Implement the \texttt{isCustomJspGlobal} method to return
  \texttt{true}.

\begin{verbatim}
@Override
public boolean isCustomJspGlobal() {
    return true;
}
\end{verbatim}
\end{enumerate}

Now your module provides custom JSPs and a custom JSP bag
implementation. When you deploy it, Liferay DXP uses its custom JSPs in
place of the core JSPs they override.

\subsection{Extend a JSP}\label{extend-a-jsp}

If you want to add something to a core JSP, see if it has an empty
\texttt{-ext.jsp} and override that instead of the whole JSP. It keeps
things simpler and more stable, since the full JSP might change
significantly, breaking your customization in the process. By overriding
the \texttt{-ext.jsp}, you're only relying on the original JSP including
the \texttt{-ext.jsp}. For an example, open
\texttt{portal-web/docroot/html/common/themes/bottom.jsp}, and scroll to
the end. You'll see this:

\begin{verbatim}
<liferay-util:include page="/html/common/themes/bottom-ext.jsp" />
\end{verbatim}

If you must add something to \texttt{bottom.jsp}, override
\texttt{bottom-ext.jsp}.

Since Liferay DXP 7.0, the content from the following JSP files formerly
in \texttt{html/common/themes} are inlined to improve performance.

\begin{itemize}
\tightlist
\item
  \texttt{body\_bottom-ext.jsp}
\item
  \texttt{body\_top-ext.jsp}
\item
  \texttt{bottom-ext.jsp}
\item
  \texttt{bottom-test.jsp}
\end{itemize}

They're no longer explicit files in the code base. But you can still
create them in your module to add functionality and content.

Remember, this type of customization is a last resort. Your override may
break due to the nature of this implementation, and core functionality
in Liferay can go down with it. If the JSP you want to override is in
another module, refer to the section on
\href{/docs/7-1/tutorials/-/knowledge_base/t/customizing-jsps}{Liferay
API based approaches to overriding JSPs}.

\subsection{Site Scoped JSP
Customization}\label{site-scoped-jsp-customization}

In Liferay Portal 6.2, you could use
\href{/docs/6-2/tutorials/-/knowledge_base/t/customizing-sites-and-site-templates-with-application-adapters}{Application
Adapters} to scope your core JSP customizations to a specific Site.
Since the majority of JSPs were moved into modules for Liferay DXP 7.0,
the use case for this has shrunk considerably. If you must scope a core
JSP customization to a Site, prepare an application adapter
\href{/docs/6-2/tutorials/-/knowledge_base/t/customizing-sites-and-site-templates-with-application-adapters}{as
you would have for Liferay Portal 6.2}, and deploy it to 7.0. It will
still work. However, note that this approach is deprecated in 7.0 and
won't be supported at all in Liferay 8.0.

\subsection{Related Topics}\label{related-topics-43}

\href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-core-jsp-hooks}{Upgrading
Core JSP Hooks}

\section{Overriding Inline Content Using
JSPs}\label{overriding-inline-content-using-jsps}

Some Liferay DXP core content, such as tag library tags, can only be
overridden using JSPs ending in \texttt{.readme}. The suffix
\texttt{.readme} facilitates finding them. The code from these JSPs is
now inlined (brought into Liferay DXP Java source files) to improve
performance. Liferay DXP ignores JSP files with the \texttt{.readme}
suffix. If you add code to a JSP \texttt{.readme} file and remove the
\texttt{.readme} suffix, Liferay DXP uses that JSP instead of the core
inline content. This tutorial shows you how to make these
customizations.

\noindent\hrulefill

\textbf{Important:} This type of customization is a last resort. Your
override may break due to the nature of this implementation, and core
functionality can go down with it. Liferay cannot guarantee that content
overridden using JSP \texttt{.readme} files can be upgraded.

\noindent\hrulefill

\noindent\hrulefill

\textbf{Warning:} Modifying a Liferay DXP tag library tag affects all
uses of that tag in your Liferay DXP installation.

\noindent\hrulefill

Here's how to override inline content using JSPs:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Create a
  \href{/docs/7-1/tutorials/-/knowledge_base/t/jsp-overrides-using-custom-jsp-bag}{Custom
  JSP Bag} for deploying your JSP. Note the module folder you're storing
  the JSPs in: the default folder is
  \texttt{{[}your\ \ \ \ \ module{]}/src/main/resources/META-INF/jsps/}
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** you can develop your JSP anywhere, but a Custom JSP Bag module
 provides a straightforward way to build and deploy it.
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\item
  Download the Liferay DXP source code or browse the source code on
  \href{https://github.com/liferay/liferay-portal/tree/7.1.x}{GitHub
  (Liferay Portal CE)}.
\item
  Search the source code for a \texttt{.jsp.readme} file that overrides
  the tag you're customizing.
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** Files ending in `-ext.jsp.readme` let you prepend or
 append new content to existing content. Examples include the
 `bottom-test.jsp.readme`, `bottom-ext.jsp.readme`,
 `body_top-ext.jsp.readme`, and `body_bottom-ext.jsp.readme` files in
 the Liferay DXP application's `portal-web/docroot/html/common/themes` folder.
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{3}
\item
  Copy the \texttt{.jsp.readme} file into your project and drop the
  \texttt{.readme} suffix. Use the same relative file path Liferay DXP
  uses for the \texttt{.jsp.readme} file. For example, if the file in
  Liferay DXP is

\begin{verbatim}
portal-web/docroot/html/taglib/aui/fieldset/start.jsp.readme
\end{verbatim}

  use file path

\begin{verbatim}
[your module]/src/main/resources/META-INF/jsps/html/taglib/aui/fieldset/start.jsp
\end{verbatim}
\item
  Familiarize yourself with the current UI content and logic, so you can
  override it appropriately. Tag library tag content logic, for example,
  is in the respective \texttt{*Tag.java} file under
  \texttt{util-taglib/src/com/liferay/taglib/{[}tag\ library{]}/}.
\item
  Develop your new logic, keeping in mind the current inline logic
  you're replacing.
\item
  Deploy your JSP.
\end{enumerate}

Liferay DXP uses your JSP in place of the current inline logic. If you
want to walk through an example override, continue with this tutorial.
Otherwise, congratulations on a modified \texttt{.jsp.readme} file to
override core inline content!

\subsection{Example: Overriding the fieldset Taglib
Tag}\label{example-overriding-the-fieldset-taglib-tag}

This example demonstrates changing the \texttt{liferay:aui} tag
library's \texttt{fieldset} tag. Browsing the Liferay DXP web
application or the source code at
\texttt{portal-web/docroot/html/taglib/aui/fieldset} reveals these
files:

\begin{itemize}
\tightlist
\item
  \texttt{start.jsp.readme}
\item
  \texttt{end.jsp.readme}
\end{itemize}

They can override the logic that creates the start and end of the
\texttt{fieldset} tag. The \texttt{FieldsetTag.java} class's
\texttt{processStart} and \texttt{processEnd} methods implement the
current inline content. Here's the
\href{https://github.com/liferay/liferay-portal/blob/7.1.0-ga1/util-taglib/src/com/liferay/taglib/aui/FieldsetTag.java\#L86-L141}{\texttt{processStart}}
method:

\begin{verbatim}
@Override
protected int processStartTag() throws Exception {
    JspWriter jspWriter = pageContext.getOut();

    jspWriter.write("<fieldset class=\"fieldset ");
    jspWriter.write(GetterUtil.getString(getCssClass()));
    jspWriter.write("\" ");

    String id = getId();

    if (id != null) {
        jspWriter.write("id=\"");
        jspWriter.write(id);
        jspWriter.write("\" ");
    }

    jspWriter.write(
        InlineUtil.buildDynamicAttributes(getDynamicAttributes()));

    jspWriter.write(StringPool.GREATER_THAN);

    String lable = getLabel();

    if (lable != null) {
        jspWriter.write(
            "<legend class=\"fieldset-legend\"><span class=\"legend\">");

        MessageTag messageTag = new MessageTag();

        messageTag.setKey(lable);
        messageTag.setLocalizeKey(getLocalizeLabel());

        messageTag.doTag(pageContext);

        String helpMessage = getHelpMessage();

        if (helpMessage != null) {
            IconHelpTag iconHelpTag = new IconHelpTag();

            iconHelpTag.setMessage(helpMessage);

            iconHelpTag.doTag(pageContext);
        }

        jspWriter.write("</span></legend>");
    }

    if (getColumn()) {
        jspWriter.write("<div class=\"row\">");
    }
    else {
        jspWriter.write("<div class=\"\">");
    }

    return EVAL_BODY_INCLUDE;
}
\end{verbatim}

The code above does this:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Write
  \texttt{\textless{}fieldset\ class=\textbackslash{}"fieldset}starting
  tag.
\item
  Write the CSS class name attribute.
\item
  If the tag has an ID, add the \texttt{id} as an attribute.
\item
  Write the tag's dynamic attribute (map).
\item
  Close the starting \texttt{fieldset} tag.
\item
  Get the tag's \texttt{label} attribute.
\item
  Write the starting \texttt{legend} element.
\item
  Use \texttt{getLocalizeLabel()} to add the localized label in the
  \texttt{legend}.
\item
  If there's a help message (retrieved from \texttt{getHelpMessage()}),
  write it in an \texttt{icon-help-tag}.
\item
  Write the closing \texttt{legend} tag.
\item
  If there's a column attribute, write
  \texttt{\textless{}div\ class=\textbackslash{}"row\textbackslash{}"\textgreater{}};
  else write
  \texttt{\textless{}div\ class=\textbackslash{}"\textbackslash{}"\textgreater{}}.
\end{enumerate}

Replicating the current logic in your custom JSP helps you set up the
tag properly for customizing. The \texttt{init.jsp} for
\texttt{fieldset} initializes all the variables required to create the
starting tag. You can use the variables in the \texttt{start.jsp}. The
logic from \texttt{FieldsetTag}'s \texttt{processStart} method converted
to JSP code for \texttt{start.jsp} (renamed from
\texttt{start.jsp.readme}) would look like this:

\begin{verbatim}
<%@ include file="/html/taglib/aui/fieldset/init.jsp" %>

<fieldset class="fieldset <%= cssClass %>" <%= Validator.isNotNull(id) ? "id=\"" + id + "\"" : StringPool.BLANK %> <%= InlineUtil.buildDynamicAttributes(dynamicAttributes) %>>
    <c:if test="<%= Validator.isNotNull(label) %>">
        <legend class="fieldset-legend">
            <span class="legend">
                <liferay-ui:message key="<%= label %>" localizeKey="<%= localizeLabel %>" />

                <c:if test="<%= Validator.isNotNull(helpMessage) %>">
                    <liferay-ui:icon-help message="<%= helpMessage %>" />
                </c:if>
            </span>
        </legend>
    </c:if>

    <div class="<%= column ? "row" : StringPool.BLANK %>">
\end{verbatim}

\noindent\hrulefill

\textbf{Tip:} A \texttt{*Tag.java} file's history might reveal original
JSP code that was inlined. For example, the logic from \texttt{fieldset}
tag's
\href{https://github.com/liferay/liferay-portal/blob/df22ba66eff49b76404cfda908d3cd024efbebd9/portal-web/docroot/html/taglib/aui/fieldset/start.jsp}{\texttt{start.jsp}}
was inlined in
\href{https://github.com/liferay/liferay-portal/commit/7fba0775bcc1d1a0bc4d107cabfb41a90f15937c\#diff-2ad802b4c0d8f7a2da45b895e89d6e46}{this
commit}.

\noindent\hrulefill

On deploying the \texttt{start.jsp}, the \texttt{fieldset} tags render
the same as they did before. This is expected because it uses the same
logic as \texttt{FieldsetTag}'s \texttt{processStart} method.

\begin{figure}
\centering
\includegraphics{./images/jsp-readme-inline-fieldset.png}
\caption{Liferay DXP's home page's search and sign in components are in
a \texttt{fieldset}.}
\end{figure}

The \texttt{fieldset} starting logic is ready for customization. To test
that this works, you'll print the word \emph{test} surrounded by
asterisks before the end of the \texttt{fieldset} tag's starting logic.
Insert this line before the \texttt{start.jsp}'s last \texttt{div} tag:

\begin{verbatim}
<c:out value="**********test**********"/>
\end{verbatim}

Redeploy the JSP and refresh the page to see the text printed above the
\texttt{fieldset}'s fields.

\begin{figure}
\centering
\includegraphics{./images/jsp-readme-override-inline-fieldset.png}
\caption{Before the \texttt{fieldset}'s nested fields, it prints
\emph{test} surrounded by asterisks.}
\end{figure}

You know how to override specific Liferay DXP core inline content using
Liferay's \texttt{.jsp.readme} files.

\subsection{Related Topics}\label{related-topics-44}

\href{/docs/7-1/tutorials/-/knowledge_base/t/customizing-jsps-with-dynamic-includes}{Customizing
JSPs with Dynamic Includes}

\href{/docs/7-1/tutorials/-/knowledge_base/t/jsp-overrides-using-portlet-filters}{JSP
Overrides Using Portlet Filters}

\chapter{Overriding Liferay Services (Service
Wrappers)}\label{overriding-liferay-services-service-wrappers}

Why might you need to customize Liferay services? Perhaps you've added a
new field to Liferay's \texttt{User} object and you want its value to be
saved whenever the \texttt{addUser} or \texttt{updateUser} methods of
Liferay's API are called. Or maybe you want to add some additional
logging functionality to some Liferay APIs or other services built using
\href{/docs/7-1/tutorials/-/knowledge_base/t/service-builder}{Service
Builder}. Whatever your case may be, Liferay's service wrappers provide
easy-to-use extension points for customizing Liferay's services.

To create a module that overrides one of Liferay's services, follow the
\href{/docs/7-1/reference/-/knowledge_base/r/using-the-service-wrapper-template}{Service
Wrapper Template} reference article to create a \texttt{servicewrapper}
project type.

As an example, here's the \texttt{UserLocalServiceOverride} class that's
generated in the Service Wrapper Template tutorial:

\begin{verbatim}
package com.liferay.docs.serviceoverride;

import com.liferay.portal.kernel.service.UserLocalServiceWrapper;
import com.liferay.portal.kernel.service.ServiceWrapper;
import org.osgi.service.component.annotations.Component;

@Component(
    immediate = true,
    property = {
    },
    service = ServiceWrapper.class
)
public class UserLocalServiceOverride extends UserLocalServiceWrapper {

    public UserLocalServiceOverride() {
        super(null);
    }

}
\end{verbatim}

Notice that you must specify the fully qualified class name of the
service wrapper class that you want to extend. The \texttt{service}
argument was used in full in this import statement:

\begin{verbatim}
import com.liferay.portal.service.UserLocalServiceWrapper
\end{verbatim}

This import statement, in turn, allowed the short form of the service
wrapper class name to be used in the class declaration of your component
class:

\begin{verbatim}
public class UserLocalServiceOverride extends UserLocalServiceWrapper
\end{verbatim}

The bottom line is that when using \texttt{blade\ create} to create a
service wrapper project, you must specify a fully qualified class name
as the \texttt{service} argument. (This is also true when using
\texttt{blade\ create} to create a service project.) For information
about creating service projects, please see the
\href{/docs/7-1/tutorials/-/knowledge_base/t/service-builder}{Service
Builder} tutorial.

The generated \texttt{UserLocalServiceOverride} class does not actually
customize any Liferay service. Before you can test that your service
wrapper module actually works, you need to override at least one service
method.

Open your \texttt{UserLocalServiceOverride} class and add the following
methods:

\begin{verbatim}
@Override
public int authenticateByEmailAddress(long companyId, String emailAddress,
        String password, Map<String, String[]> headerMap,
        Map<String, String[]> parameterMap, Map<String, Object> resultsMap)
    throws PortalException {

    System.out.println(
        "Authenticating user by email address " + emailAddress);
    return super.authenticateByEmailAddress(companyId, emailAddress, password,
        headerMap, parameterMap, resultsMap);
}

@Override
public User getUser(long userId) throws PortalException {
    System.out.println("Getting user by id " + userId);
    return super.getUser(userId);
}
\end{verbatim}

Each of these methods overrides a Liferay service method. These
implementations merely execute a few print statements that before
executing the original service implementations.

Lastly, you must add the following method to the bottom of your service
wrapper so it can find the appropriate service it's overriding on
deployment.

\begin{verbatim}
@Reference(unbind = "-")
private void serviceSetter(UserLocalService userLocalService) {
    setWrappedService(userLocalService);
}
\end{verbatim}

\href{/docs/7-0/tutorials/-/knowledge_base/t/starting-module-development\#building-and-deploying-a-module}{Build
and deploy your module}. Congratulations! You've created and deployed a
Liferay service wrapper!

\section{Related Topics}\label{related-topics-45}

\href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-service-wrappers}{Upgrading
Service Wrappers}

\href{/docs/7-1/tutorials/-/knowledge_base/t/installing-blade-cli}{Installing
Blade CLI}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-projects-with-blade-cli}{Creating
Projects with Blade CLI}

\chapter{Overriding OSGi Services}\label{overriding-osgi-services}

Components register as services with the OSGi service registry. A
service component's availability, ranking, and attributes determine
whether components referring to the service type bind to that particular
service. Liferay DXP's OSGI container is a dynamic environment in which
services come and go and can be overridden, which means that if there's
a service whose behavior you want to change, you can override it. Here
are the steps for overriding a service:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/examining-an-osgi-service-to-override}{Get
  the service and service reference details}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/creating-a-custom-osgi-service}{Create
  a custom service}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/reconfiguring-components-to-use-your-service}{Configure
  components to use your custom service}
\end{enumerate}

\noindent\hrulefill

\textbf{Note:} The
\href{/docs/7-1/tutorials/-/knowledge_base/t/service-builder}{Service
Builder} services in
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-impl/}{portal-impl}
are Spring beans that Liferay makes available as OSGi services.

\noindent\hrulefill

Start with examining the service you want to override.

\section{Examining an OSGi Service to
Override}\label{examining-an-osgi-service-to-override}

Creating and injecting a custom service in place of an existing service
requires three things:

\begin{itemize}
\tightlist
\item
  Understanding the service interface
\item
  The existing service
\item
  The references to the service
\end{itemize}

Your custom service must implement the service interface, match
references you want, and might need to invoke the existing service.

Getting components to adopt your custom service immediately can require
reconfiguring their references to the service. Here you'll flesh out
service details to make these decisions.

\subsection{Gathering Information on a
Service}\label{gathering-information-on-a-service}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Since component service references are extension points, start with
  following the tutorial
  \href{/docs/7-1/tutorials/-/knowledge_base/t/finding-extension-points}{Finding
  Extension Points} to determine the service you want to override and
  components that use that service.
\item
  Once you know the service and components that use it, use Gogo Shell's
  Service Component Runtime (SCR) to inspect the components and get the
  service and reference details. The
  \href{/docs/7-1/reference/-/knowledge_base/r/using-the-felix-gogo-shell}{Gogo
  Shell} command \texttt{scr:info\ {[}componentName{]}} lists the
  component's attributes and service references.
\end{enumerate}

Here's an example \texttt{scr:info} command and results (abbreviated
with \texttt{...}) that describe component
\texttt{override.my.service.reference.OverrideMyServiceReference} (from
sample module
\href{https://portal.liferay.dev/documents/113763090/114000186/override-my-service-reference.zip}{override-my-service-reference})
and its reference to a service of type
\texttt{override.my.service.reference.service.api.SomeService}:

\begin{verbatim}
> scr:info override.my.service.reference.OverrideMyServiceReference 

...
Component Description:
    Name: override.my.service.reference.portlet.OverrideMyServiceReferencePortlet
...
Reference: _someService
    Interface Name: override.my.service.reference.service.api.SomeService
    Cardinality: 1..1
    Policy: static
    Policy option: reluctant
    Reference Scope: bundle
...
Component Configuration:
ComponentId: 2399
State: active
SatisfiedReference: _someService
  Target: null
  Bound to:        6840
      Properties:
        component.id = 2400
        component.name = override.my.service.reference.service.impl.SomeServiceImpl
        objectClass = [override.my.service.reference.service.api.SomeService]
        service.bundleid = 524
        service.id = 6840
        service.scope = bundle
...
\end{verbatim}

The \texttt{scr:info} results, like the ones above, contain information
relevant to injecting a custom service. Here's what you'll do with the
information:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \hyperref[step-1-copy-the-service-interface-name]{Copy the service
  interface name}
\item
  \hyperref[step-2-copy-the-existing-service-name]{Copy the existing
  service name}
\item
  \hyperref[step-3-gather-reference-configuration-details-if-reconfiguration-is-needed]{Gather
  reference configuration details (if reconfiguration is necessary)}
\end{enumerate}

Start with the service interface.

\subsection{Step 1: Copy the Service Interface
Name}\label{step-1-copy-the-service-interface-name}

The reference's \emph{Interface Name} is the service interface's fully
qualified name.

\begin{verbatim}
...
Reference: _someService
    Interface Name: override.my.service.reference.service.api.SomeService
    ...
\end{verbatim}

\textbf{Copy and save the interface name}, because it's the type your
custom service must implement.

\noindent\hrulefill

Javadocs for Liferay DXP service interfaces are at these locations:

\begin{itemize}
\tightlist
\item
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/}{Liferay
  DXP core Javadocs}
\item
  \href{https://docs.liferay.com/dxp/apps}{Liferay DXP app Javadocs}
\item
  \href{https://mvnrepository.com/}{MVNRepository} and
  \href{https://search.maven.org/}{Maven Central} (for Liferay and
  non-Liferay artifact Javadocs).
\end{itemize}

\noindent\hrulefill

\subsection{Step 2: Copy the Existing Service
Name}\label{step-2-copy-the-existing-service-name}

If you want to invoke the existing service along with your custom
service, get the existing service name.

The \texttt{src:info} result's Component Configuration section lists the
existing service's fully qualified name. For example, the
\texttt{OverrideMyServiceReferencePortlet} component's references
\texttt{\_someService} is bound to a service component whose fully
qualified name is
\texttt{override.my.service.reference.service.impl.SomeServiceImpl}.

\begin{verbatim}
Component Configuration:
...
SatisfiedReference: _someService
  ...
  Bound to:        6840
      Properties:
        ...
        component.name = override.my.service.reference.service.impl.SomeServiceImpl
\end{verbatim}

\textbf{Copy the \texttt{component.name}} so you can reference the
service in your
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-a-custom-osgi-service}{custom
service}.

Here's an example of referencing the service above.

\begin{verbatim}
@Reference  (
    target = "(component.name=override.my.service.reference.service.impl.SomeServiceImpl)"
)
private SomeService _defaultService;
\end{verbatim}

\subsection{Step 3: Gather Reference Configuration Details (if
reconfiguration is
needed)}\label{step-3-gather-reference-configuration-details-if-reconfiguration-is-needed}

The service reference's policy and policy option determine a component's
conditions for adopting a particular service.

\begin{itemize}
\item
  If the reference's policy option is \texttt{greedy}, it binds to the
  matching, highest ranking service right away. The reference need not
  be reconfigured to adopt your service.
\item
  If policy is \texttt{static} and its policy option is
  \texttt{reluctant}, however, the component requires one of the
  following conditions to switch from using the existing service it's
  referencing to using the matching, highest ranking service (i.e.,
  you'll rank your custom service highest):

  \begin{enumerate}
  \def\labelenumi{\arabic{enumi}.}
  \tightlist
  \item
    The component is reactivated
  \item
    The component's existing referenced service is unavailable
  \item
    The component's reference is modified so that it does not match the
    existing service but matches your service
  \end{enumerate}
\end{itemize}

\href{/docs/7-1/tutorials/-/knowledge_base/t/reconfiguring-components-to-use-your-service}{Reconfiguring
the reference} can be the quickest way for the component to adopt a new
service.

\textbf{Gather these details:}

\begin{itemize}
\item
  \emph{Component name:} Find this at \emph{Component Description} →
  \emph{Name}. For example,

\begin{verbatim}
  Component Description:
      Name: override.my.service.reference.portlet.OverrideMyServiceReferencePortlet
      ...
\end{verbatim}
\item
  \emph{Reference name:} The \emph{Reference} value (e.g.,
  \texttt{Reference:\ \_someService}).
\item
  \emph{Cardinality:} Number of service instances the reference can bind
  to.
\end{itemize}

\noindent\hrulefill

\textbf{Note}: Declarative Services makes all components configurable
through OSGi Configuration Admin. Each \texttt{@Reference} annotation in
the source code has a name property, either \emph{explicitly} set in the
annotation or \emph{implicitly} derived from the name of the member on
which the annotation is used.

\begin{itemize}
\tightlist
\item
  If no reference name property is used and the \texttt{@Reference} is
  on a field, then the reference name is the field name. If
  \texttt{@Reference} is on a field called \texttt{\_someService}, for
  example, then the reference name is \texttt{\_someService}.
\item
  If the \texttt{@Reference} is on a method, then heuristics derive the
  reference name. Method name suffix is used and prefixes such as
  \texttt{set}, \texttt{add}, and \texttt{put} are ignored. If
  \texttt{@Reference} is on a method called
  \texttt{setSearchEngine(SearchEngine\ se)}, for example, then the
  reference name is \texttt{SearchEngine}.
\end{itemize}

\noindent\hrulefill

After
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-a-custom-osgi-service}{creating
your custom service} (next), you'll use the details you collected here
to
\href{/docs/7-1/tutorials/-/knowledge_base/t/reconfiguring-components-to-use-your-service}{configure
the component to use your custom service}.

Congratulations on getting the details required for overriding the OSGi
service!

\subsection{Related Topics}\label{related-topics-46}

\href{/docs/7-1/tutorials/-/knowledge_base/t/osgi-services-and-dependency-injection-with-declarative-services}{OSGi
Services and Dependency Injection with Declarative Services}

\href{/docs/7-1/tutorials/-/knowledge_base/t/finding-extension-points}{Finding
Extension Points}

\href{/docs/7-1/reference/-/knowledge_base/r/using-the-felix-gogo-shell}{Gogo
Shell}

\section{Creating a Custom OSGi
Service}\label{creating-a-custom-osgi-service}

It's time to implement your OSGi service. Make sure to
\href{/docs/7-1/tutorials/-/knowledge_base/t/examining-an-osgi-service-to-override}{examine
the service and service reference details}, if you haven't done so
already. Here you'll create a custom service that implements the service
interface, declares it an OSGi service of that type, and makes it the
best match for binding with other components.

The example custom service \texttt{CustomServiceImpl} (from sample
module
\href{https://portal.liferay.dev/documents/113763090/114000186/overriding-service-reference.zip}{\texttt{overriding-service-reference}})
implements service interface \texttt{SomeService}, declares itself an
OSGi service of the \texttt{SomeService} service type, and even
delegates work to the existing service. Examine this example code as you
follow the steps for creating your custom service.

\begin{verbatim}
@Component(
    property = {
        "service.ranking:Integer=100"
    },
    service = SomeService.class
)
public class CustomServiceImpl implements SomeService {

    @Override
    public String doSomething() {

        StringBuilder sb = new StringBuilder();
        sb.append(this.getClass().getName());
        sb.append(", which delegates to ");
        sb.append(_defaultService.doSomething());

        return sb.toString();
    }

    @Reference  (
        target = "(component.name=override.my.service.reference.service.impl.SomeServiceImpl)"
    )
    private SomeService _defaultService;
}
\end{verbatim}

Here are the steps to create a custom OSGi service:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/starting-module-development}{Create
  a module}.
\item
  Create your custom service class so that it \texttt{implements} the
  \href{/docs/7-1/tutorials/-/knowledge_base/t/examining-an-osgi-service-to-override\#step-1-copy-the-service-interface-name}{service
  interface} you want. In the example above,
  \texttt{CustomServiceImpl\ implements\ SomeService}. Step 5 (later)
  demonstrates implementing the interface methods.
\item
  Make your class a Declarative Services component that is the best
  match for references to the service interface:

  \begin{itemize}
  \item
    Use an \texttt{@Component} annotation and \texttt{service} attribute
    to make your classes a Declarative Services (DS) component. This
    declares your class to be an OSGi service that can be made available
    in the OSGi service registry. The example class above is a DS
    service component of service type \texttt{SomeService.class}.
  \item
    Use a \texttt{service.ranking:Integer} component property to rank
    your service higher than existing services. The
    \texttt{"service.ranking:Integer=100"} property above sets the
    example's ranking to \texttt{100}.
  \end{itemize}
\item
  If you want to invoke the existing service implementation, declare a
  field that uses a Declarative Services reference to the existing
  service. Use the
  \href{/docs/7-1/tutorials/-/knowledge_base/t/examining-an-osgi-service-to-override\#step-2-copy-the-existing-service-name}{\texttt{component.name}
  you copied when you examined the service} to target the existing
  service. The example above refers to an existing service like this:

\begin{verbatim}
@Reference  (
    target = "(component.name=override.my.service.reference.service.impl.SomeServiceImpl)"
)
private SomeService _defaultService;
\end{verbatim}

  The field lets you invoke the existing service in your custom service.
\item
  Override the interface's methods. Optionally, delegate work to the
  existing service implementation (see previous step).

  The example custom service's \texttt{doSomething} method delegates
  work to the original service implementation.
\item
  Register your custom service with the OSGi runtime framework by
  \href{/docs/7-1/tutorials/-/knowledge_base/t/starting-module-development\#building-and-deploying-a-module}{deploying
  your module}.
\end{enumerate}

Components that reference the service type you implemented and whose
reference policy option is \texttt{greedy} bind to your custom service
immediately. Components bound to an existing service and whose reference
policy option is \texttt{reluctant} can be dynamically reconfigured to
use your service. That's demonstrated next.

\subsection{Related Topics}\label{related-topics-47}

\href{/docs/7-1/tutorials/-/knowledge_base/t/osgi-services-and-dependency-injection-with-declarative-services}{OSGi
Services and Dependency Injection with Declarative Services}

\section{Reconfiguring Components to Use Your OSGi
Service}\label{reconfiguring-components-to-use-your-osgi-service}

In many cases, assigning your
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-a-custom-osgi-service}{custom
service (service)} a higher ranking convinces components to unbind from
their current service and bind to yours. In other cases, components keep
using their current service. Why is that? And how do you make components
adopt your service? The component's
\href{/docs/7-1/tutorials/-/knowledge_base/t/examining-an-osgi-service-to-override\#step-3-gather-reference-configuration-details-if-reconfiguration-is-needed}{service
reference policy option} is the key to determining the service.

Here are the policy options:

\texttt{greedy}: The component uses the matching, highest ranking
service as soon as it's available.

\texttt{reluctant}: The component uses the matching, highest ranking
service available in the following events:

\begin{itemize}
\tightlist
\item
  the component is (re)activated
\item
  the component's existing referenced service becomes unavailable
\item
  the component's reference is modified so that it no longer matches the
  existing bound service
\end{itemize}

In short, references with greedy policy options adopt your higher
ranking service right away, while ones with reluctant policy options
require particular events. What's great is that Liferay DXP's
Configuration Admin lets you use configuration files (config files) or
the API to swap in service reference changes on the fly. Here you'll use
a config file to reconfigure a service reference to use your custom
service immediately.

This tutorial uses example modules
\texttt{override-my-service-reference} and
\texttt{overriding-service-reference} to demonstrate reconfiguring a
service reference, binding the component to a different service. You can
download the modules and build them using Gradle (bundled with each
module) or you can apply the tutorial steps to configure your own
customization. Executing \texttt{gradlew\ jar} in each example module
root generates the module JAR to the \texttt{build/libs} folder.

\begin{itemize}
\item
  \texttt{override-my-service-reference}
  (\href{https://portal.liferay.dev/documents/113763090/114000186/override-my-service-reference.zip}{download}):
  This module's portlet component
  \texttt{OverrideMyServiceReferencePortlet}'s field
  \texttt{\_someService} references a service of type
  \texttt{SomeService}. The reference's policy is static and reluctant.
  By default, it binds to an implementation called
  \texttt{SomeServiceImpl}.
\item
  \texttt{overriding-service-reference}
  (\href{https://portal.liferay.dev/documents/113763090/114000186/overriding-service-reference.zip}{download}):
  Provides a custom \texttt{SomeService} implementation called
  \texttt{CustomServiceImpl}. The module's configuration file overrides
  \texttt{OverrideMyServiceReferencePortlet}'s \texttt{SomeService}
  reference so that it binds to \texttt{CustomServiceImpl}.
\end{itemize}

You're ready to reconfigure a component's service reference to target
your custom service.

\subsection{Reconfiguring the Service
Reference}\label{reconfiguring-the-service-reference}

Liferay DXP's Configuration Admin lets you use configuration files to
swap in service references on the fly.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \href{/docs/7-1/user/-/knowledge_base/u/understanding-system-configuration-files}{Create
  a system configuration file} named after the referencing component.
  Follow the name convention \texttt{{[}component{]}.config}, replacing
  \texttt{{[}component{]}} with the
  \href{/docs/7-1/tutorials/-/knowledge_base/t/examining-an-osgi-service-to-override\#step-3-gather-reference-configuration-details-if-reconfiguration-is-needed}{component
  name}. The configuration file name for the example component
  \texttt{override.my.service.reference.portlet.OverrideMyServiceReferencePortlet}
  is:

\begin{verbatim}
override.my.service.reference.portlet.OverrideMyServiceReferencePortlet.config
\end{verbatim}
\item
  In the configuration file, add a reference target entry that filters
  on your custom service. Follow this format for the entry:

\begin{verbatim}
[reference].target=[filter]
\end{verbatim}

  Replace \texttt{{[}reference{]}} with the name of the reference you're
  overriding. Replace \texttt{{[}filter{]}} with service properties that
  filter on your custom service.

  This example filters on the \texttt{component.name} service property:

\begin{verbatim}
_someService.target="(component.name\=overriding.service.reference.service.CustomServiceImpl)" 
\end{verbatim}

  This example filters on the \texttt{service.vendor} service property:

\begin{verbatim}
_someService.target="(service.vendor\=Acme, Inc.)"
\end{verbatim}
\item
  Optionally, you can add a \texttt{cardinality.minimum} entry to
  specify the number of services the reference can use. Here's the
  format:

\begin{verbatim}
[reference].cardinality.minimum=[int]
\end{verbatim}

  Here's an example cardinality minimum:

\begin{verbatim}
_someService.cardinality.minimum=1
\end{verbatim}
\item
  Deploy the configuration by copying the configuration file into the
  folder \texttt{{[}Liferay\_Home{]}/osgi/configs}.
\end{enumerate}

Executing \texttt{scr:info} on your component shows that the custom
service is now bound to the reference.

For example, executing
\texttt{scr:info\ override.my.service.reference.portlet.OverrideMyServiceReferencePortlet}
reports the following information:

\begin{verbatim}
...
Component Description:
  Name: override.my.service.reference.portlet.OverrideMyServiceReferencePortlet
  ...
  Reference: _someService
    Interface Name: override.my.service.reference.service.api.SomeService
    Cardinality: 1..1
    Policy: static
    Policy option: reluctant
    Reference Scope: bundle
    ...
  Component Configuration:
    ComponentId: 2399
    State: active
    SatisfiedReference: _someService
      Target: (component.name=overriding.service.reference.CustomServiceImpl)
      Bound to:        6841
          Properties:
            _defaultService.target = (component.name=overriding.service.reference.service.CustomServiceImpl)
            component.id = 2398
            component.name = overriding.service.reference.service.CustomServiceImpl
            objectClass = [override.my.service.reference.service.api.SomeService]
            service.bundleid = 525
            service.id = 6841
            service.scope = bundle
      Component Configuration Properties:
        _someService.target = (component.name=overriding.service.reference.service.CustomServiceImpl)
        ...
\end{verbatim}

The example component's \texttt{\_someService} reference targets the
custom service component
\texttt{overriding.service.reference.service.CustomServiceImpl}.
\texttt{CustomServiceImpl} references default service
\texttt{SomeServiceImpl} to delegate work to it.

\begin{figure}
\centering
\includegraphics{./images/overriding-service-refs-result.png}
\caption{Because the example component's service reference is overridden
by the configuration file deployment, the portlet indicates it's calling
the custom service.}
\end{figure}

Liferay DXP processed the configuration file and injected the service
reference, which in turn bound the custom service to the referencing
component!

\subsection{Related Topics}\label{related-topics-48}

\href{/docs/7-1/tutorials/-/knowledge_base/t/osgi-services-and-dependency-injection-with-declarative-services}{OSGi
Services and Dependency Injection with Declarative Services}

\href{/docs/7-1/tutorials/-/knowledge_base/t/finding-extension-points}{Finding
Extension Points}

\href{/docs/7-1/reference/-/knowledge_base/r/using-the-felix-gogo-shell}{Using
Felix Gogo Shell}

\chapter{Overriding Language Keys}\label{overriding-language-keys}

Core and portlet module \texttt{Language*.properties} files implement
site internationalization. They're fully customizable, too. These
tutorials demonstrate this in the following topics:

\begin{itemize}
\tightlist
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/overriding-language-keys}{Overriding
  Liferay's Language Keys}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/overriding-a-modules-language-keys}{Overriding
  a Module's Language Keys}
\end{itemize}

\section{Overriding Global Language
Keys}\label{overriding-global-language-keys}

Language files contain
\href{/docs/7-1/tutorials/-/knowledge_base/t/localizing-your-application}{translations
of your application's user interface messages}. But you can also
override the default language keys globally and in other applications
(including your own). Here are the steps for overriding language keys:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \hyperref[determine-the-language-keys-to-override]{Determine the
  language keys to override}
\item
  \hyperref[override-the-keys-in-a-new-language-properties-file]{Override
  the keys in a new language properties file}
\item
  \hyperref[create-a-resource-bundle-service-component]{Create a
  Resource Bundle service component}
\end{enumerate}

\noindent\hrulefill

\textbf{Note:} Many applications that were once part of Liferay Portal
6.2 are now modularized. Their language keys might have been moved out
of Liferay's language properties files and into one of the application's
modules. The process for
\href{/docs/7-1/tutorials/-/knowledge_base/t/overriding-a-modules-language-keys}{overriding
a module's language keys} is different from the process for overriding
Liferay's language keys.

\noindent\hrulefill

\subsection{Determine the language keys to
override}\label{determine-the-language-keys-to-override}

So how do you find global language keys? They're in the
\texttt{Language{[}xx\_XX{]}.properties} files in the source code or
your bundle.

\begin{itemize}
\item
  From the source:

  \texttt{/portal-impl/src/content/Language{[}xx\_XX{]}.properties}
\item
  From a bundle:

  \texttt{portal-impl.jar}
\end{itemize}

All language properties files contain properties you can override, like
the language settings properties:

\begin{verbatim}
##
## Language settings
##

...
lang.user.name.field.names=prefix,first-name,middle-name,last-name,suffix
lang.user.name.prefix.values=Dr,Mr,Ms,Mrs
lang.user.name.required.field.names=last-name
lang.user.name.suffix.values=II,III,IV,Jr,Phd,Sr
...
\end{verbatim}

There are also many simple keys you can override to update default
messages and labels.

\begin{verbatim}
##
## Category titles
##

category.admin=Admin
category.alfresco=Alfresco
category.christianity=Christianity
category.cms=Content Management
...
\end{verbatim}

For example, Figure 1 shows a button that uses Liferay's
\texttt{publish} default language key.

\begin{verbatim}
`publish=Publish`
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/standard-publish.png}
\caption{Messages displayed in Liferay's user interface can be
customized.}
\end{figure}

Next, you'll learn how to override this key.

\subsection{Override the keys in a new language properties
file}\label{override-the-keys-in-a-new-language-properties-file}

Once you know the keys to override, create a language properties file
for the locale you want (or the default \texttt{Language.properties}
file) in your module's \texttt{src/main/resources/content} folder. In
your file, define the keys your way. For example, you could override the
\texttt{publish} key.

\begin{verbatim}
publish=Publish Override
\end{verbatim}

To enable your change, you must create a resource bundle service
component to reference your language file.

\subsubsection{Create a Resource Bundle service
component}\label{create-a-resource-bundle-service-component}

In your module, create a class that extends
\texttt{java.util.ResourceBundle} for the locale you're overriding.
Here's an example resource bundle class for the \texttt{en\_US} locale:

\begin{verbatim}
@Component(
    property = { "language.id=en_US" }, 
    service = ResourceBundle.class
)
public class MyEnUsResourceBundle extends ResourceBundle {

    @Override
    protected Object handleGetObject(String key) {
        return _resourceBundle.getObject(key);
    }

    @Override
    public Enumeration<String> getKeys() {
        return _resourceBundle.getKeys();
    }

    private final ResourceBundle _resourceBundle = ResourceBundle.getBundle(
        "content.Language_en_US", UTF8Control.INSTANCE);

}
\end{verbatim}

The class's \texttt{\_resourceBundle} field is assigned a
\texttt{ResourceBundle}. The call to \texttt{ResourceBundle.getBundle}
needs two parameters. The \texttt{content.Language\_en\_US} parameter is
the language file's qualified name with respect to the module's
\texttt{src/main/resources} folder. The second parameter is a
\texttt{control} that sets the language syntax of the resource bundle.
To use language syntax identical to Liferay's syntax, import Liferay's
\texttt{com.liferay.portal.kernel.language.UTF8Control} class and set
the second parameter to \texttt{UTF8Control.INSTANCE}.

The class's \texttt{@Component} annotation declares it an OSGi
\texttt{ResourceBundle} service component. It's \texttt{language.id}
property designates it for the \texttt{en\_US} locale.

\begin{verbatim}
@Component(
    property = { "language.id=en_US" }, 
    service = ResourceBundle.class
)
\end{verbatim}

The class overrides these methods:

\begin{itemize}
\item
  \textbf{\texttt{handleGetObject}:} Looks up the key in the module's
  resource bundle (which is based on the module's language properties
  file) and returns the key's value as an \texttt{Object}.
\item
  \textbf{\texttt{getKeys}:} Returns an \texttt{Enumeration} of the
  resource bundle's keys.
\end{itemize}

Your resource bundle service component redirects the default language
keys to your module's language key overrides.

\noindent\hrulefill

\textbf{Note}: Global language key overrides for multiple locales
require a separate module for each locale. Each module's
\texttt{ResourceBundle} extension class (like the
\texttt{MyEnUsResourceBundle} class above) must specify its locale in
the \texttt{language.id} component property definition and in the
language file qualified name parameter. For example, here is what they
look like for the Spanish locale.

Component definition:

\begin{verbatim}
 @Component(
     property = { "language.id=es_ES" },
     service = ResourceBundle.class
 )
\end{verbatim}

Resource bundle assignment:

\begin{verbatim}
 private final ResourceBundle _resourceBundle = ResourceBundle.getBundle(
     "content.Language_es_ES", UTF8Control.INSTANCE);
\end{verbatim}

\noindent\hrulefill

\textbf{Important}: If your module
\href{/docs/7-1/tutorials/-/knowledge_base/t/localizing-your-application\#using-a-language-module}{uses
language keys from another module} and
\href{/docs/7-1/tutorials/-/knowledge_base/t/localizing-your-application\#using-a-language-module-from-a-module}{overrides
any of that other module's keys}, make sure to use OSGi headers to
specify the capabilities your module requires and provides. This lets
you prioritize resource bundles from the modules.

To see your Liferay language key overrides in action,
\href{/docs/7-1/tutorials/-/knowledge_base/t/starting-module-development\#building-and-deploying-a-module}{deploy
your module} and visit the portlets and pages that use the keys.

\begin{figure}
\centering
\includegraphics{./images/localized-publish.png}
\caption{This button uses the overridden \texttt{publish} key.}
\end{figure}

That's all there is to overriding Liferay's language keys.

\subsection{Related Topics}\label{related-topics-49}

\href{/docs/7-1/reference/-/knowledge_base/r/resource-bundle-override}{Resource
Bundle Override Sample Project}

\href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-core-language-key-hooks}{Upgrading
Core Language Key Hooks}

\href{/docs/7-1/tutorials/-/knowledge_base/t/internationalization}{Internationalization}

\section{Overriding a Module's Language
Keys}\label{overriding-a-modules-language-keys}

What do you do if the language keys you want to modify are in one of
Liferay's applications or another module whose source code you don't
control? Since module language keys are in the respective module, the
process for overriding a module's language keys is different from
\href{/docs/7-1/tutorials/-/knowledge_base/t/overriding-language-keys}{the
process of overriding Liferay's language keys}.

Here is the process:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Find the module and its metadata and language keys
\item
  Write your custom language key values
\item
  Prioritize your module's resource bundle
\end{enumerate}

\subsection{Find the module and its metadata and language
keys}\label{find-the-module-and-its-metadata-and-language-keys}

In
\href{/docs/7-1/reference/-/knowledge_base/r/using-the-felix-gogo-shell}{Gogo
shell}, list the bundles and grep for keyword(s) that match the
portlet's display name. Language keys are in the portlet's web module
(bundle). When you find the bundle, note its ID number.

To find the Blogs portlet, for example, your Gogo commands and output
might look like this:

\begin{verbatim}
g! lb | grep Blogs
  152|Active     |    1|Liferay Blogs Service (1.0.2)
  184|Active     |    1|Liferay Blogs Editor Config (2.0.1)
  202|Active     |    1|Liferay Blogs Layout Prototype (2.0.2)
  288|Active     |    1|Liferay Blogs Recent Bloggers Web (1.0.2)
  297|Active     |    1|Liferay Blogs Item Selector Web (1.0.2)
  374|Active     |    1|Liferay Blogs Item Selector API (2.0.1)
  448|Active     |    1|Liferay Blogs API (3.0.1)
  465|Active     |    1|Liferay Blogs Web (1.0.6)
true
\end{verbatim}

List the bundle's headers by passing its ID to the \texttt{headers}
command.

\begin{verbatim}
g! headers 465

Liferay Blogs Web (465)
-----------------------
Manifest-Version = 1.0
Bnd-LastModified = 1459866186018
Bundle-ManifestVersion = 2
Bundle-Name = Liferay Blogs Web
Bundle-SymbolicName = com.liferay.blogs.web
Bundle-Version: 1.0.6
... 
Web-ContextPath = /blogs-web
g! 
\end{verbatim}

Note the \texttt{Bundle-SymbolicName}, \texttt{Bundle-Version}, and
\texttt{Web-ContextPath}. The \texttt{Web-ContextPath} value, following
the \texttt{/}, is the servlet context name.

\textbf{Important}: Record the servlet context name, bundle symbolic
name and version, as you'll use them to create the resource bundle
loader later in the process.

For example, here are those values for Liferay Blogs Web module:

\begin{itemize}
\tightlist
\item
  Bundle symbolic name: \texttt{com.liferay.blogs.web}
\item
  Bundle version: \texttt{1.0.6}
\item
  Servlet context name: \texttt{blogs-web}
\end{itemize}

Next find the module's JAR file so you can examine its language keys.
Liferay follows this module JAR file naming convention:

\begin{verbatim}
[bundle symbolic name]-[version].jar
\end{verbatim}

For example, the Blogs Web version 1.0.6 module is in
\texttt{com.liferay.blogs.web-1.0.6.jar}.

Here's where to find the module JAR:

\begin{itemize}
\tightlist
\item
  Liferay's
  \href{https://repository.liferay.com/nexus/content/repositories/liferay-public-releases/com/liferay/}{Nexus
  repository}
\item
  \texttt{{[}Liferay\ Home{]}/osgi/modules}
\item
  Embedded in an application's or application suite's LPKG file in
  \texttt{{[}Liferay\ \ \ \ \ Home{]}/osgi/marketplace}.
\end{itemize}

The language property files are in the module's
\texttt{src/main/resources/content} folder. Identify the language keys
you want to override in the \texttt{Language{[}\_xx{]}.properties}
files.

Checkpoint: Make sure you have the required information for overriding
the module's language keys:

\begin{itemize}
\tightlist
\item
  Language keys
\item
  Bundle symbolic name
\item
  Servlet context name
\end{itemize}

Next you'll write new values for the language keys.

\subsection{Write custom language key
values}\label{write-custom-language-key-values}

Create a new module to hold a resource bundle loader and your custom
language keys.

In your module's \texttt{src/main/resources/content} folder, create
\href{/docs/7-1/tutorials/-/knowledge_base/t/localizing-your-application\#what-are-language-keys}{language
properties files} for each locale whose keys you want to override. In
each language properties file, specify your language key overrides.

Next you'll prioritize your module's language keys as a resource bundle
for the target module.

\subsection{Prioritize Your Module's Resource
Bundle}\label{prioritize-your-modules-resource-bundle}

Now that your language keys are in place, use OSGi manifest headers to
specify the language keys are for the target module. To compliment the
target module's resource bundle, you'll aggregate your resource bundle
with the target module's resource bundle. You'll list your module first
to prioritize its resource bundle over the target module resource
bundle. Here's an example of module
\texttt{com.liferay.docs.l10n.myapp.lang} prioritizing its resource
bundle over target module \texttt{com.liferay.blogs.web}'s resource
bundle:

\begin{verbatim}
Provide-Capability:\
liferay.resource.bundle;resource.bundle.base.name="content.Language",\
liferay.resource.bundle;resource.bundle.aggregate:String="(bundle.symbolic.name=com.liferay.docs.l10n.myapp.lang),(bundle.symbolic.name=com.liferay.blogs.web)";bundle.symbolic.name=com.liferay.blogs.web;resource.bundle.base.name="content.Language";service.ranking:Long="2";\
servlet.context.name=blogs-web
\end{verbatim}

The example \texttt{Provide-Capability} header has two parts:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \texttt{liferay.resource.bundle;resource.bundle.base.name="content.Language"}
  declares that the module provides a resource bundle with the base name
  \texttt{content.language}.
\item
  The
  \texttt{liferay.resource.bundle;resource.bundle.aggregate:String=...}
  directive specifies the list of bundles with resource bundles to
  aggregate, the target bundle, the target bundle's resource bundle
  name, and this service's ranking:

  \begin{itemize}
  \tightlist
  \item
    \texttt{"(bundle.symbolic.name=com.liferay.docs.l10n.myapp.lang),(bundle.symbolic.name=com.liferay.blogs.web)"}:
    The service aggregates resource bundles from bundles
    \texttt{com.liferay.docs.l10n.myapp.lang} and
    \texttt{com.liferay.blogs.web}. Aggregate as many bundles as
    desired. Listed bundles are prioritized in descending order.
  \item
    \texttt{bundle.symbolic.name=com.liferay.blogs.web;resource.bundle.base.name="content.Language"}:
    Override the \texttt{com.liferay.blogs.web} bundle's resource bundle
    named \texttt{content.Language}.
  \item
    \texttt{service.ranking:Long="2"}: The resource bundle's service
    ranking is \texttt{2}. The OSGi framework applies this service if it
    outranks all other resource bundle services that target
    \texttt{com.liferay.blogs.web}'s \texttt{content.Language} resource
    bundle.
  \item
    \texttt{servlet.context.name=blogs-web}: The target resource bundle
    is in servlet context \texttt{blogs-web}.
  \end{itemize}
\end{enumerate}

\href{/docs/7-1/tutorials/-/knowledge_base/t/starting-module-development\#building-and-deploying-a-module}{Deploy
your module} to see the language keys you've overridden.

\noindent\hrulefill

\textbf{Tip:} If your override isn't showing, use
\href{/docs/7-1/reference/-/knowledge_base/r/using-the-felix-gogo-shell}{Gogo
Shell} to check for competing resource bundle services. It may be that
another service outranks yours. To check for competing resource bundle
services whose aggregates include \texttt{com.liferay.blogs.web}'s
resource bundle, for example, execute this Gogo Shell command:

\begin{verbatim}
 services "(bundle.symbolic.name=com.liferay.login.web)"
\end{verbatim}

Search the results for resource bundle aggregate services whose ranking
is higher.

\noindent\hrulefill

Now you can modify the language keys of modules in Liferay's OSGi
runtime. Remember, language keys you want to override might actually be
in Liferay's core. You can
\href{/docs/7-1/tutorials/-/knowledge_base/t/overriding-language-keys}{override
Liferay's language keys} too.

\subsection{Related Topics}\label{related-topics-50}

\href{/docs/7-1/reference/-/knowledge_base/r/resource-bundle-override}{Resource
Bundle Override Sample Project}

\href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-core-language-key-hooks}{Upgrading
Core Language Key Hooks}

\href{/docs/7-1/tutorials/-/knowledge_base/t/internationalization}{Internationalization}

\chapter{Overriding MVC Commands}\label{overriding-mvc-commands}

MVC Commands are used to break up the controller layer of
\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-mvc-portlet}{Liferay
MVC applications} into smaller, more digestible code chunks.

Sometimes you'll want to override an MVC command, whether it's in a
Liferay application or another Liferay MVC application whose source code
you don't own. Since MVC commands are components registered in the OSGi
runtime, you can simply publish your own customization of the component,
give it a higher service ranking, and deploy it.

All existing components that reference the original MVC command service
component (using a greedy reference policy) switch to reference your new
one. Any existing
\href{/docs/7-1/tutorials/-/knowledge_base/t/overriding-service-references}{reluctant
references to the original command must be configured to reference the
new one}. Once they're configured with the new service component, their
JSP's command URLs invoke the new custom MVC command.

Here are the customization options available for each Liferay MVC
Command type:

\begin{itemize}
\tightlist
\item
  MVCActionCommand:
  \href{/docs/7-1/tutorials/-/knowledge_base/t/overriding-mvcactioncommand}{Add
  logic}
\item
  MVCRenderCommand:

  \begin{itemize}
  \tightlist
  \item
    \href{/docs/7-1/tutorials/-/knowledge_base/t/overriding-mvcrendercommand\#adding-logic-to-an-existing-mvc-render-command}{Add
    logic}
  \item
    \href{/docs/7-1/tutorials/-/knowledge_base/t/overriding-mvcrendercommand\#redirecting-to-a-new-jsp}{Redirect
    to a different JSP}
  \end{itemize}
\item
  MVCResourceCommand:
  \href{/docs/7-1/tutorials/-/knowledge_base/t/overriding-mvcresourcecommand}{Add
  logic}
\end{itemize}

These tutorials demonstrate each MVC command customization option. Since
the steps for adding logic are generally the same across MVC command
types, start with
\href{/docs/7-1/tutorials/-/knowledge_base/t/adding-logic-to-mvc-commands}{adding
logic}.

\section{Adding Logic to MVC
Commands}\label{adding-logic-to-mvc-commands}

You can completely override MVC commands, or any OSGi service for that
matter, but \emph{adding logic} to the commands is the better option.
Discarding necessary logic is bad. Conversely any logic you copy from
the original might not work in new versions of the portlet. Adding
custom logic while continuing to invoke the original logic decouples the
custom class from the original implementation. Keeping the new logic
separate form the original logic keeps the code clean, maintainable, and
easy to understand.

Here are the steps for adding logic to MVC commands.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Implement the interface
\item
  Publish as a component
\item
  Refer to the original implementation
\item
  Add the logic, and call the original
\end{enumerate}

\subsection{Step 1: Implement the
interface}\label{step-1-implement-the-interface}

Implement the respective MVC Command interface either directly or by
extending an existing base class that implements it. Extending a base
class for the interface relieves you from implementing logic that should
typically be a part of most command implementations. For example, to add
logic to the Blogs portlet's \texttt{EditEntryMVCActionCommand}, you
would extend base class \texttt{BaseMVCActionCommand}.

\begin{verbatim}
public class CustomBlogsMVCActionCommand extends BaseMVCActionCommand
\end{verbatim}

Check the MVC command interfaces for existing base classes:

\begin{itemize}
\tightlist
\item
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/bridges/mvc/MVCActionCommand.html}{\texttt{MVCActionCommand}}
\item
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/bridges/mvc/MVCRenderCommand.html}{\texttt{MVCRenderCommand}}
\item
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/bridges/mvc/MVCResourceCommand.html}{\texttt{MVCResourceCommand}}
\end{itemize}

Next make your class a service component.

\subsection{Step 2: Publish as a
component}\label{step-2-publish-as-a-component}

The Declarative Services \texttt{@Component} annotation facilitates
customizing MVC commands. All the customization options require
publishing your MVC command class as a component. For example, this
\texttt{@Component} annotation declares an \texttt{MVCActionCommand}
service.

\begin{verbatim}
@Component(
    immediate = true,
    property = { 
        "javax.portlet.name=" + BlogsPortletKeys.BLOGS_ADMIN, 
        "mvc.command.name=/blogs/edit_entry",
        "service.ranking:Integer=100" 
    }, 
    service = MVCActionCommand.class
)
public class CustomBlogsMVCActionCommand extends BaseMVCActionCommand {
    ...
} 
\end{verbatim}

It publishes \texttt{CustomBlogsMVCActionCommand} as a service component
for the \texttt{MVCActionCommand} class. Upon resolving, it's activated
immediately because \texttt{immediate\ =\ true}. The component is
invoked in the Blogs Admin portlet by the command URL
\texttt{/blogs/edit\_entry}. Its service ranking of \texttt{100}
prioritizes it ahead of the original service component, whose ranking is
\texttt{0}.

Here's what you need to specify in an \texttt{@Component} annotation for
your custom MVC command:

\begin{itemize}
\item
  \texttt{javax.portlet.name}: for each portlet you want the
  customization to affect. JSPs in these portlets can invoke the MVC
  command via applicable command URL tags. You can specify the same
  portlets as the original MVC command or a subset of those portlets.
\item
  \texttt{mvc.command.name}: this property declares the command URL that
  maps to this custom MVC command component.
\item
  \texttt{service.ranking:Integer}: set this property to a higher
  integer than the original service implementation's ranking. The
  ranking tells the OSGi runtime which service to use, in cases where
  multiple components register the same service, with the same
  properties. The higher the integer you specify here, the more weight
  your component carries. Liferay's service implementations typically
  have a \texttt{0} ranking.
\item
  \texttt{service}: this attribute specifies the service (interface) to
  override .
\item
  \texttt{immediate}: set this attribute to \texttt{true} to activate
  your component immediately upon resolution.
\end{itemize}

You can refer back to this list as you add \texttt{@Component}
annotations to your custom MVC commands.

Next reference the original implementation.

\subsection{Step 3: Refer to the original
implementation}\label{step-3-refer-to-the-original-implementation}

Use a field annotated with \texttt{@Reference} to fetch a reference to
the original MVC command component. If there are no additional
customizations on the original component, this reference will be for the
original MVC command type. For example, this field references the
original MVC command component \texttt{EditEntryMVCActionCommand}.

\begin{verbatim}
@Reference(
    target = "(component.name=com.liferay.blogs.web.internal.portlet.action.EditEntryMVCActionCommand)")
protected MVCActionCommand mvcActionCommand;
\end{verbatim}

Here's how to add the reference:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Declare the field as the MVC command interface type that it is. For
  example, the \texttt{mvcActionCommand} field is type
  \texttt{MVCActionCommand}.
\item
  Add the \texttt{@Reference} annotation.
\item
  In the annotation, define a \texttt{target} attribute that filters on
  a \texttt{component.name} equal to the default service implementation
  class's fully qualified name.
\end{enumerate}

When your custom component resolves, the OSGi runtime assigns the
targeted service to your field. It's time to add your custom logic.

\subsection{Step 4: Add the logic}\label{step-4-add-the-logic}

Adding the logic involves overriding the primary method of the base
class you're extending or the interface you're implementing. In your
method override, add your new logic AND then invoke the original
implementation. For example, the following method overrides
\texttt{BaseMVCActionCommand}'s method \texttt{doProcessAction}.

\begin{verbatim}
@Override
protected void doProcessAction(
    ActionRequest actionRequest, ActionResponse actionResponse)
throws Exception {
    // Add custom logic here 
    ...
    
    // Call the original service implementation 
    mvcActionCommand.processAction(actionRequest, actionResponse);
}
\end{verbatim}

The method above defines custom logic and then invokes the original
service it referenced in the previous step.

If you use this approach, your extension will continue to work with new
versions of the original portlet, because no coupling exists between the
original portlet logic and your customization. The command
implementation class can change. Make sure to keep your reference
updated to the name of the current implementation class.

Congratulations on adding logic to your existing MVC command.

\section{Overriding
MVCRenderCommands}\label{overriding-mvcrendercommands}

You can override
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/bridges/mvc/MVCRenderCommand.html}{\texttt{MVCRenderCommand}}
for any portlet that uses Liferay's MVC framework and publishes an
\texttt{MVCRenderCommand} component.

For example, Liferay's Blogs application has a class called
\texttt{EditEntryMVCRenderCommand}, with this component:

\begin{verbatim}
@Component(
    immediate = true,
    property = {
        "javax.portlet.name=" + BlogsPortletKeys.BLOGS,
        "javax.portlet.name=" + BlogsPortletKeys.BLOGS_ADMIN,
        "javax.portlet.name=" + BlogsPortletKeys.BLOGS_AGGREGATOR,
        "mvc.command.name=/blogs/edit_entry"
    },
    service = MVCRenderCommand.class
)
\end{verbatim}

This MVC render command can be invoked from any of the portlets
specified by the \texttt{javax.portlet.name} parameter, by calling a
render URL that names the MVC command.

\begin{verbatim}
<portlet:renderURL var="addEntryURL">
    <portlet:param name="mvcRenderCommandName" value="/blogs/edit_entry" />
    <portlet:param name="redirect" value="<%= viewEntriesURL %>" />
</portlet:renderURL>
\end{verbatim}

What if you want to override the command, but not for all of the
portlets listed in the original component? In your override component,
just list the \texttt{javax.portlet.name} of the portlets where you want
the override to take effect. For example, if you want to override the
\texttt{/blogs/edit\_entry} MVC render command just for the Blogs Admin
portlet (the Blogs Application accessed in the site administration
section of Liferay), your component could look like this:

\begin{verbatim}
@Component(
  immediate = true,
  property = {
     "javax.portlet.name=" + BlogsPortletKeys.BLOGS_ADMIN,
     "mvc.command.name=/blogs/edit_entry",
     "service.ranking:Integer=100"
  },
  service = MVCRenderCommand.class
)
\end{verbatim}

Note the last property listed, \texttt{service.ranking}. It's used to
tell the OSGi runtime which service to use, in cases where there are
multiple components registering the same service, with the same
properties. The higher the integer you specify here, the more weight
your component carries. In this case, the override component is used
instead of the original one, since the default value for this property
is \texttt{0}.

After that, it's up to you to do whatever you'd like. MVC render
commands can be customized for these purposes:

\begin{itemize}
\tightlist
\item
  \hyperref[adding-logic-to-an-existing-mvc-render-command]{Adding Logic
  to an Existing MVC Render Command}
\item
  \hyperref[redirecting-to-a-new-jsp]{Redirecting to a new JSP}
\end{itemize}

Start by exploring how to add logic to an existing MVC render command.

\subsection{Adding Logic to an Existing MVC Render
Command}\label{adding-logic-to-an-existing-mvc-render-command}

You can add logic to an MVC render command following the
\href{/docs/7-1/tutorials/-/knowledge_base/t/adding-logic-to-mvc-commands}{general
steps for MVC commands}. Specifically for MVC render commands, you must
directly implement the
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/bridges/mvc/MVCRenderCommand.html}{\texttt{MVCRenderCommand}
interface} and override its \texttt{render} method.

For example, this custom MVC render command has a placeholder (i.e., at
comment \texttt{//Do\ something\ here}) for adding logic to the
\texttt{render} method.:

\begin{verbatim}
public CustomEditEntryRenderCommand implements MVCRenderCommand {
    @Override
    public String render(RenderRequest renderRequest, 
                        RenderResponse renderResponse)
           throws PortletException {

        //Do something here

        return mvcRenderCommand.render(renderRequest, renderResponse);
    }

    @Reference(target = 
          "(component.name=com.liferay.blogs.web.internal.portlet.action.EditEntryMVCRenderCommand)")
      protected MVCRenderCommand mvcRenderCommand;
}
\end{verbatim}

The example references an \texttt{EditEntryMVCRenderCommand}
implementation of \texttt{MVCRenderCommand}. In the \texttt{render}
method, you'd replace the placeholder with new logic and then invoke the
original implementation's logic by calling its \texttt{render} method.

Sometimes, you might need to redirect the request to an entirely new
JSP. You can do that from a custom MVC render command module too.

\subsection{Redirecting to a New JSP}\label{redirecting-to-a-new-jsp}

\texttt{MVCRenderCommand}'s \texttt{render} method returns a JSP path as
a String. By default, the JSP must live in the original module, so you
cannot simply specify a path to a custom JSP in your override module. To
redirect it to a JSP in your new module, you must make the method skip
dispatching to the original JSP altogether, by using the constant
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/bridges/mvc/MVCRenderConstants.html}{\texttt{MVCRenderConstants.MVC\_PATH\_VALUE\_SKIP\_DISPATCH}
class}. Then you need to initiate your own dispatching process,
directing the request to your JSP path. Here's how that might look in
practice:

\begin{verbatim}
public class CustomEditEntryMVCRenderCommand implements MVCRenderCommand {

    @Override
    public String render(
        RenderRequest renderRequest, RenderResponse renderResponse) throws
            PortletException {

        System.out.println("Rendering custom_edit_entry.jsp");

        RequestDispatcher requestDispatcher =
            servletContext.getRequestDispatcher("/custom_edit_entry.jsp");

        try {
            HttpServletRequest httpServletRequest = 
                PortalUtil.getHttpServletRequest(renderRequest);
            HttpServletResponse httpServletResponse = 
                PortalUtil.getHttpServletResponse(renderResponse);

            requestDispatcher.include
                (httpServletRequest, httpServletResponse);
        } catch (Exception e) {
            throw new PortletException
                ("Unable to include custom_edit_entry.jsp", e);
        }

        return MVCRenderConstants.MVC_PATH_VALUE_SKIP_DISPATCH;
    }

    @Reference(target = "(osgi.web.symbolicname=com.custom.code.web)")
    protected ServletContext servletContext;
}
\end{verbatim}

The servlet context provides access to the request dispatcher. A servlet
context is automatically created for portlets. It can be created for
other modules by including the following line in your \texttt{bnd.bnd}
file:

\begin{verbatim}
Web-ContextPath: /custom-code-web
\end{verbatim}

Follow these steps to fetch the portlet's servlet context in your custom
MVC render command:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add a \texttt{ServletContext} field.

\begin{verbatim}
protected ServletContext servletContext;
\end{verbatim}
\item
  Add the \texttt{@Reference} annotation to the field and set the
  annotation to filter on the portlet's module. By convention, Liferay
  puts portlets in modules whose symbolic names end in \texttt{.web}.
  For example, this servlet context reference filters on a module whose
  symbolic name is \texttt{com.custom.code.web}.

\begin{verbatim}
@Reference(target = "(osgi.web.symbolicname=com.custom.code.web)")
protected ServletContext servletContext;
\end{verbatim}
\end{enumerate}

Implement your \texttt{render} method this way:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Get a request dispatcher to your module's custom JSP.

\begin{verbatim}
RequestDispatcher requestDispatcher =
    servletContext.getRequestDispatcher("/custom_edit_entry.jsp");
\end{verbatim}
\item
  Include the HTTP servlet request and response in the request
  dispatcher.

\begin{verbatim}
try {
    HttpServletRequest httpServletRequest = 
        PortalUtil.getHttpServletRequest(renderRequest);
    HttpServletResponse httpServletResponse = 
        PortalUtil.getHttpServletResponse(renderResponse);

    requestDispatcher.include
        (httpServletRequest, httpServletResponse);
} catch (Exception e) {
    throw new PortletException
        ("Unable to include custom_edit_entry.jsp", e);
}
\end{verbatim}
\item
  Return the request dispatcher via the constant
  \texttt{MVC\_PATH\_VALUE\_SKIP\_DISPATCH}.

\begin{verbatim}
return MVCRenderConstants.MVC_PATH_VALUE_SKIP_DISPATCH;
\end{verbatim}
\end{enumerate}

After deploying your module, the
\href{/docs/7-1/tutorials/-/knowledge_base/t/adding-logic-to-mvc-commands\#step-2-publish-as-a-component}{portlets
targeted by your custom \texttt{MVCRenderCommand} component} render your
new JSP.

\subsection{Related Topics}\label{related-topics-51}

\href{/docs/7-1/tutorials/-/knowledge_base/t/mvc-render-command}{MVC
Render Command}

\href{/docs/7-1/tutorials/-/knowledge_base/t/adding-logic-to-mvc-commands}{Adding
Logic to MVC Commands}

\href{/docs/7-1/tutorials/-/knowledge_base/t/converting-strutsactionwrappers-to-mvccommands}{Converting
StrutsActionWrappers to MVCCommands}

\section{Overriding
MVCActionCommands}\label{overriding-mvcactioncommands}

In case you want add to a Liferay MVC action command, you can. The OSGi
framework lets you override MVC action commands if you follow the
instructions for
\href{/docs/7-1/tutorials/-/knowledge_base/t/adding-logic-to-mvc-commands}{adding
logic to MVC commands}. It involves
\href{/docs/7-1/tutorials/-/knowledge_base/t/adding-logic-to-mvc-commands\#step-2-publish-as-a-component}{registering
your custom MVC action command as an OSGi component} with the same
properties as the original, but with a higher service ranking.

Custom MVC action commands typically extend the
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/bridges/mvc/BaseMVCActionCommand.html}{\texttt{BaseMVCActionCommand}
class}, and override its \texttt{doProcessAction} method, which returns
\texttt{void}. Add your logic to the original behavior of the action
method by
\href{/docs/7-1/tutorials/-/knowledge_base/t/adding-logic-to-mvc-commands\#step-3-refer-to-the-original-implementation}{getting
a reference to the original service}, and
\href{/docs/7-1/tutorials/-/knowledge_base/t/adding-logic-to-mvc-commands\#step-4-add-the-logic}{calling
it after your own logic}. For example, this \texttt{MVCActionCommand}
override checks whether the \texttt{delete} action is invoked on a blog
entry, and prints a message to the log, before continuing with the
original processing:

\begin{verbatim}
@Component(
    property = { 
        "javax.portlet.name=" + BlogsPortletKeys.BLOGS_ADMIN, 
        "mvc.command.name=/blogs/edit_entry",
        "service.ranking:Integer=100" 
    }, 
    service = MVCActionCommand.class
)
public class CustomBlogsMVCActionCommand extends BaseMVCActionCommand {

    @Override
    protected void doProcessAction
        (ActionRequest actionRequest, ActionResponse actionResponse) 
        throws Exception {

        String cmd = ParamUtil.getString(actionRequest, Constants.CMD);

        if (cmd.equals(Constants.DELETE)) {
            System.out.println("Deleting a Blog Entry");
        }

        mvcActionCommand.processAction(actionRequest, actionResponse);
    }

    @Reference(
        target = "(component.name=com.liferay.blogs.web.internal.portlet.action.EditEntryMVCActionCommand)")
    protected MVCActionCommand mvcActionCommand;

}
\end{verbatim}

Adding MVC action command logic before existing logic is straightforward
and maintains loose coupling between new and old code.

\subsection{Related Topics}\label{related-topics-52}

\href{/docs/7-1/tutorials/-/knowledge_base/t/mvc-action-command}{MVC
Action Command}

\href{/docs/7-1/tutorials/-/knowledge_base/t/adding-logic-to-mvc-commands}{Adding
Logic to MVC Commands}

\href{/docs/7-1/tutorials/-/knowledge_base/t/overriding-mvcrendercommand}{Overriding
MVCRenderCommands}

\href{/docs/7-1/tutorials/-/knowledge_base/t/converting-strutsactionwrappers-to-mvccommands}{Converting
StrutsActionWrappers to MVCCommands}

\section{Overriding
MVCResourceCommands}\label{overriding-mvcresourcecommands}

If you need to add functionality to a Liferay MVC resource command, you
can. The Liferay MVC command framework supports customizing MVC resource
commands. It follows the process for
\href{/docs/7-1/tutorials/-/knowledge_base/t/adding-logic-to-mvc-commands}{adding
logic to MVC commands} and it is similar to the ones described for
\texttt{MVCRenderCommand} and \texttt{MVCActionCommand}. There's a
couple things to keep in mind:

\begin{itemize}
\item
  The service to specify in your component is
  \texttt{MVCResourceCommand.class}
\item
  As with overriding \texttt{MVCRenderCommand}, there's no base
  implementation class to extend. Implement the
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/bridges/mvc/MVCResourceCommand.html}{\texttt{MVCResourceCommand}
  interface} yourself.
\item
  Keep your code decoupled from the original code by adding your logic
  to the original \texttt{MVCResourceCommand}'s logic by getting a
  reference to the original and returning a call to its
  \texttt{serveResource} method:

\begin{verbatim}
  return mvcResourceCommand.serveResource(resourceRequest, resourceResponse);
\end{verbatim}
\end{itemize}

The following example overrides the behavior of
\texttt{com.liferay.login.web.portlet.action.CaptchaMVCResourceCommand},
from the Liferay's Login portlet's \texttt{login-web} module. It simply
prints a line in the console and then executes the original logic:
returning the Captcha image for the account creation screen.

\begin{verbatim}
@Component(
    property = { 
        "javax.portlet.name=" + LoginPortletKeys.LOGIN,
        "mvc.command.name=/login/captcha"
    }, 
    service = MVCResourceCommand.class
)
public class CustomCaptchaMVCResourceCommand implements MVCResourceCommand {

    @Override
    public boolean serveResource
        (ResourceRequest resourceRequest, ResourceResponse resourceResponse) {

        System.out.println("Serving login captcha image");

        return mvcResourceCommand.serveResource(resourceRequest, resourceResponse);
    }

    @Reference(target = 
        "(component.name=com.liferay.login.web.internal.portlet.action.CaptchaMVCResourceCommand)")
    protected MVCResourceCommand mvcResourceCommand;
}
\end{verbatim}

And that, as they say, is that. Even if you don't own the source code of
an application, you can
\href{/docs/7-1/tutorials/-/knowledge_base/t/overriding-mvc-commands}{override
its MVC commands} just by knowing the component class name.

\subsection{Related Topics}\label{related-topics-53}

\href{/docs/7-1/tutorials/-/knowledge_base/t/mvc-resource-command}{MVC
Resource Command}

\href{/docs/7-1/tutorials/-/knowledge_base/t/adding-logic-to-mvc-commands}{Adding
Logic to MVC Commands}

\href{/docs/7-1/tutorials/-/knowledge_base/t/overriding-mvcrendercommand}{Overriding
MVCRenderCommands}

\section{Overriding Liferay DXP's Default YUI and AUI
Modules}\label{overriding-liferay-dxps-default-yui-and-aui-modules}

Liferay DXP contains several default YUI/AUI modules. You may need to
override functionality provided by these module's scripts. To do this,
you must create a custom AUI module containing three things:

\begin{itemize}
\tightlist
\item
  A copy of the original module's JavaScript file containing your
  modifications
\item
  A \texttt{config.js} file that specifies the modified JavaScript
  file's path and the module it overrides
\item
  A \texttt{bnd.bnd} file that tells the OSGi container to override the
  original
\end{itemize}

Follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/starting-module-development\#creating-a-module}{Create
  an OSGi module} to override the original one. For example, you can
  create a module named \texttt{session-js-override-web} to override
  Liferay DXP's \texttt{session.js} file.
\item
  Create a \texttt{src/main/resources/META-INF/resources/js} folder in
  your module, copy the original JavaScript file into it, and rename it.
  For example, create a copy of the \texttt{session.js} module and
  rename it \texttt{session-override.js}.
\item
  Apply your modifications and save the file.
\item
  Next,
  \href{/docs/7-0/tutorials/-/knowledge_base/t/configuring-modules-for-products-loaders\#writing-the-configuration-file}{write
  your module's configuration file} (\texttt{config.js}) to apply your
  override. Add the \texttt{config.js} file to the module's
  \texttt{src/main/resources/META-INF/resources/js} folder. The example
  \texttt{config.js} file below specifies the \texttt{condition} that
  the
  \href{/docs/7-0/tutorials/-/knowledge_base/t/configuring-modules-for-products-loaders\#writing-the-configuration-file}{YUI/AUI
  Loader} should load the custom AUI module
  (\texttt{liferay-session-override}) \texttt{instead} (indicated with
  the \texttt{when} property) of the \texttt{trigger} module
  (\texttt{liferay-session}). You can follow this same pattern to create
  your module's \texttt{config.js} file:

\begin{verbatim}
;(function() {

    var base = MODULE_PATH + '/js/';

    AUI().applyConfig(
        {
            groups: {
                mymodulesoverride: { //mymodulesoverride
                    base: base,
                    combine: Liferay.AUI.getCombine(),
                    filter: Liferay.AUI.getFilterConfig(),
                    modules: {
                        'liferay-session-override': { //my-module-override
                            path: 'session-override.js', //my-module.js
                            condition: {
                                name: 'liferay-session-override', //my-module-override
                                trigger: 'liferay-session', //original module
                                when: 'instead'
                            }
                        }
                    },
                    root: base
                }
            }
        }
    );
})();
\end{verbatim}
\item
  Finally, you must configure your \texttt{bnd.bnd} file. For the system
  to apply the changes, you must specify the \texttt{config.js}'s
  location with the \texttt{Liferay-JS-Config} BND header. The
  \texttt{liferay-session-override} module from the previous example has
  the configuration below in its \texttt{bnd.bnd} file:

\begin{verbatim}
Bundle-Name: session-js-override
Bundle-SymbolicName: session.js.override.web
Bundle-Version: 1.0.0
Liferay-JS-Config:/META-INF/resources/js/config.js
Web-ContextPath: /liferay-session-override-web
\end{verbatim}
\end{enumerate}

Now you know how to override Liferay DXP's default YUI/AUI modules!

\subsection{Related Topics}\label{related-topics-54}

\href{/docs/7-1/tutorials/-/knowledge_base/t/customizing-jsps}{Customizing
JSPs}

\section{Overriding lpkg files}\label{overriding-lpkg-files}

Applications are delivered through Liferay Marketplace as \emph{lpkg}
files. This is a simple compressed file format that contains .jar files
for deploying to Liferay DXP. If you want to examine an application from
Marketplace, all you have to do is unzip its .lpkg file to reveal its
.jar files.

After examining an application, you may want to
\href{/docs/7-1/tutorials/-/knowledge_base/t/customizing}{customize} one
of its .jars. Make your customization in a copy of the .jar, but don't
deploy it the way you'd normally deploy an application. By overriding
the .lpkg file, you can update application modules without modifying the
original .lpgk file. Here are the steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Shut down Liferay DXP.
\item
  Create a folder called \texttt{override} in the
  \texttt{{[}Liferay\ Home{]}/osgi/marketplace}
  folder{]}(/docs/7-0/deploy/-/knowledge\_base/d/installing-product\#liferay-home).
\item
  Name your updated .jar the same as the .jar in the original .lpkg,
  minus the version information. For example, if you're overriding the
  \texttt{com.liferay.amazon.rankings.web-1.0.5.jar} from the
  \texttt{Liferay\ CE\ Amazon\ \ \ \ \ Rankings.lpkg}, you'd name your
  .jar \texttt{com.liferay.amazon.rankings.web.jar}.
\item
  Copy this .jar into the \texttt{override} folder you created in step
  one.
\end{enumerate}

This works for applications from Marketplace, but there's also the
static .lpkg that contains core Liferay technology and third-party
utilities (such as the servlet API, Apache utilities, etc.). To
customize or patch any of these .jar files, follow this process:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Make your customization and package it in a .jar file.
\item
  Name your .jar the same as the original .jar, minus the version
  information. For example, a customized
  \texttt{com.liferay.portal.profile-1.0.4.jar} should be
  \texttt{com.liferay.portal.profile.jar}.
\item
  Copy the .jar into the \texttt{{[}Liferay\ Home{]}/osgi/static}
  folder.
\end{enumerate}

Now start Liferay DXP. Note that any time you add and remove .jars this
way, Liferay DXP must be shut down and then restarted for the changes to
take effect.

If you must roll back your customizations, delete the overriding .jar
files: Liferay DXP uses the original .jar on its next startup.

\section{Creating Model Listeners}\label{creating-model-listeners}

Model Listeners implement the
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/model/ModelListener.html}{\texttt{ModelListener}
interface}. They are used to listen for persistence events on models and
do something in response (either before or after the event).

Model listeners are designed to perform lightweight actions in response
to a \texttt{create}, \texttt{remove}, or \texttt{update} attempt on an
entity's database table or a mapping table (for example,
\texttt{users\_roles}). Here are some supported use cases:

\begin{itemize}
\tightlist
\item
  Audit Listener: In a separate database, record information about
  updates to an entity's database table.
\item
  Cache Clearing Listener: Clear caches that you've added to improve the
  performance of custom code.
\item
  Validation Listener: Perform additional validation on a model's
  attribute values before they are persisted to the database.
\item
  Entity Update Listener: Do some additional processing when an entity
  table is updated. For example, notify users when changes are made to
  their account.
\end{itemize}

There are also use cases that are not recommended, since they're likely
to break unpredictably and give you headaches:

\begin{itemize}
\tightlist
\item
  Setting a model's attributes in an \texttt{onBeforeUpdate} call. If
  some other database table has already been updated with the values
  before your model listener is invoked, your database gets out of sync.
  To change how an entity's attributes are set, consider using a
  \href{/docs/7-1/tutorials/-/knowledge_base/t/customizing-liferay-services-service-wrappers}{service
  wrapper} instead.
\item
  Wrapping a model. Model listeners are not called when fetching records
  from the database.
\item
  Creating worker threads to do parallel processing and querying data
  you updated via your listener. Model listeners are called
  \emph{before} the database transaction is complete (even the
  \texttt{onAfter...} methods), so the queries could be executed before
  the database transaction completes.
\end{itemize}

If there is no existing listener on the model, your model listener is
the only one that runs. However, there can be multiple listeners on a
single model, and the order in which the listeners run cannot be
controlled.

You can create a model listener in a module by doing two simple things:

\begin{itemize}
\tightlist
\item
  Implement \texttt{ModelListener}
\item
  Register the service in Liferay's OSGi runtime
\end{itemize}

\subsection{Creating a Model Listener
Class}\label{creating-a-model-listener-class}

Create a \texttt{-ModelListener} class that extends the
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/model/BaseModelListener.html}{\texttt{BaseModelListener}
class}.

\begin{verbatim}
package ...;

import ...;

public class CustomEntityListener extends BaseModelListener<CustomEntity> {

    // Override one or more methods from the ModelListener interface.
    
}
\end{verbatim}

In the body of the class, override any methods from the
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/model/ModelListener.html}{\texttt{ModelListener}
interface}. The available methods are listed and described at the end of
this article.

In your model listener class, the parameterized type (for example,
\texttt{CustomEntity} in the snippet above) tells the listener's
\texttt{ServiceTrackerCustomizer} which model class to register the
listener against.

\subsection{Register the Model Listener
Service}\label{register-the-model-listener-service}

Register the service with Liferay's OSGi runtime for immediate
activation. If using Declarative Services, set
\texttt{service=\ ModelListener.class} and \texttt{immediate=true} in
the Component.

\begin{verbatim}
@Component(
    immediate = true,
    service = ModelListener.class
)
\end{verbatim}

That's all there is to preparing a model listener. Now learn what model
events you can respond to.

\subsection{Listening For Persistence
Events}\label{listening-for-persistence-events}

The \texttt{ModelListener} interface provides lots of opportunity to
listen for model events:

\begin{itemize}
\tightlist
\item
  \textbf{\texttt{onAfterAddAssociation}:} If there's an association
  between two models (if they have a mapping table), use this method to
  do something after an association record is added.
\item
  \textbf{\texttt{onAfterCreate}:} Use this method to do something after
  the persistence layer's \texttt{create} method is called.
\item
  \textbf{\texttt{onAfterRemove}:} Use this method to do something after
  the persistence layer's \texttt{remove} method is called.
\item
  \textbf{\texttt{onAfterRemoveAssociation}:} If there's an association
  between two models (if they have a mapping table), do something after
  an association record is removed.
\item
  \textbf{\texttt{onAfterUpdate}:} Use this method to do something after
  the persistence layer's \texttt{update} method is called.
\item
  \textbf{\texttt{onBeforeAddAssociation}:} If there's an association
  between two models (if they have a mapping table), do something before
  an addition to the mapping table.
\item
  \textbf{\texttt{onBeforeCreate}:} Use this method to do something
  before the persistence layer's \texttt{create} method is called.
\item
  \textbf{\texttt{onBeforeRemove}:} Use this method to do something
  before the persistence layer's \texttt{remove} method is called.
\item
  \textbf{\texttt{onBeforeRemoveAssociation}:} If there's an association
  between two models (if they have a mapping table), do something before
  a removal from the mapping table.
\item
  \textbf{\texttt{onBeforeUpdate}:} Use this method to do something
  before the persistence layer's \texttt{update} method is called.
\end{itemize}

Look in Liferay source file
\texttt{portal-kernel/src/com/liferay/portal/kernel/service/persistence/impl/BasePersistenceImpl.java},
particularly the \texttt{remove} and \texttt{update} methods, and you'll
see how model listeners are accounted for before (for the
\texttt{onBefore...} case) and after (for the \texttt{onAfter...} case)
the model persistence event.

Now that you know how to create model listeners, keep in mind that
they're useful as standalone projects or inside of your application. If
your application needs to do something (like add a custom entity) every
time a User is added in Liferay, you can include the model listener
inside your application.

\subsection{Related Topics}\label{related-topics-55}

\href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-model-listener-hooks}{Upgrading
Model Listener Hooks}

\href{/docs/7-0/tutorials/-/knowledge_base/t/service-builder}{Service
Builder}

\href{/docs/7-1/tutorials/-/knowledge_base/t/service-builder-persistence}{Service
Builder Persistence}

\chapter{Dynamic Includes}\label{dynamic-includes}

Dynamic includes expose extension points in JSPs for injecting
additional HTML, adding resources, modifying editors, and more. Several
dynamic includes are available. Once you know the dynamic include's key,
you can use it to
\href{/docs/7-1/tutorials/-/knowledge_base/t/customizing-jsps-with-dynamic-includes}{create
a module to inject your content}.

This section of tutorials lists the available dynamic include keys,
along with a description of their use cases and a code example.

The following extension points are covered in this section of tutorials:

\begin{longtable}[]{@{}
  >{\centering\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.4074}}
  >{\centering\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.5926}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\centering
Extension Point
\end{minipage} & \begin{minipage}[b]{\linewidth}\centering
Purpose
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\href{/docs/7-1/tutorials/-/knowledge_base/t/bottom-jsp-dynamic-includes}{bottom}
& Load additional HTML or scripts in the bottom of the theme's body \\
\href{/docs/7-1/tutorials/-/knowledge_base/t/top-head-jsp-dynamic-includes}{top\_head}
& Load additional links in the theme's head \\
\href{/docs/7-1/tutorials/-/knowledge_base/t/top-js-dynamic-include}{top\_js}
& Load additional JS files in the theme's head \\
\href{/docs/7-1/tutorials/-/knowledge_base/t/wysiwyg-editor-dynamic-includes}{WYSIWYG}
& Add resources to the editor, listen to events, update the
configuration, etc. \\
\end{longtable}

\section{WYSIWYG Editor Dynamic
Includes}\label{wysiwyg-editor-dynamic-includes}

All WYSIWYG editors share the same dynamic include extension points for
these things:

\begin{itemize}
\item
  Adding resources, plugins, etc. to the editor:

  com.liferay.frontend.editor.\texttt{editorType}.web\#\texttt{editorName}\#additionalResources
\item
  Accessing the editor instance to listen to events, configure it, etc:

  com.liferay.frontend.editor.\texttt{editorType}.web\#\texttt{editorName}\#onEditorCreate
\end{itemize}

The table below shows the \texttt{editorType}, variable, and
\texttt{editorName}s for each editor:

\begin{longtable}[]{@{}ccc@{}}
\toprule\noalign{}
editorType & variable & editorName \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
alloyeditor & alloyEditor & alloyeditor \\
~ & ~ & alloyeditor\_bbcode \\
~ & ~ & alloyeditor\_creole \\
ckeditor & ckEditor & ckeditor \\
~ & ~ & ckeditor\_bbcode \\
~ & ~ & ckeditor\_creole \\
tinymce & tinyMCEEditor & tinymce \\
~ & ~ & tinymce\_simple \\
\end{longtable}

The example below alerts the user when he/she pastes content into the
CKEditor.

\texttt{*DynamicInclude} Java Class:

\begin{verbatim}
@Component(immediate = true, service = DynamicInclude.class)
public class CKEditorOnEditorCreateDynamicInclude implements DynamicInclude {

    @Override
    public void include(
            HttpServletRequest request, HttpServletResponse response,
            String key)
        throws IOException {

        Bundle bundle = _bundleContext.getBundle();

        URL entryURL = bundle.getEntry(
            "/META-INF/resources/ckeditor/extension/ckeditor_alert.js");

        StreamUtil.transfer(
            entryURL.openStream(), response.getOutputStream(), false);
    }

    @Override
    public void register(
        DynamicInclude.DynamicIncludeRegistry dynamicIncludeRegistry) {

        dynamicIncludeRegistry.register(
            "com.liferay.frontend.editor.ckeditor.web#ckeditor#onEditorCreate");
    }

    @Activate
    protected void activate(BundleContext bundleContext) {
        _bundleContext = bundleContext;
    }

    private BundleContext _bundleContext;

}
\end{verbatim}

Example JavaScript:

\begin{verbatim}
// ckEditor variable is already available in the execution context
ckEditor.on(
    'paste',
    function(event) {
        event.stop();

        alert('Please, do not paste code here!');
    }
);
\end{verbatim}

Now you know how to use the WYSIWYG editor dynamic includes.

\subsection{Related Topics}\label{related-topics-56}

\href{/docs/7-1/tutorials/-/knowledge_base/t/adding-new-behavior-to-an-editor}{Adding
New Behavior to an Editor}

\href{/docs/7-1/tutorials/-/knowledge_base/t/bottom-jsp-dynamic-includes}{Bottom
JSP Dynamic Includes}

\href{/docs/7-1/tutorials/-/knowledge_base/t/top-head-jsp-dynamic-includes}{Top
Head JSP Dynamic Includes}

\href{/docs/7-1/tutorials/-/knowledge_base/t/top-js-dynamic-include}{Top
JS Dynamic Include}

\section{Top Head JSP Dynamic
Includes}\label{top-head-jsp-dynamic-includes}

The \texttt{top\_head.jsp} dynamic includes load additional links in the
theme's head. It uses the following keys:

Load additional links in the theme's head before the existing ones:

\begin{verbatim}
/html/common/themes/top_head.jsp#pre
\end{verbatim}

Alternatively, you can load additional links in the theme's head, after
the existing ones:

\begin{verbatim}
/html/common/themes/top_head.jsp#post
\end{verbatim}

The example below injects a link into the top of the
\texttt{top\_head.jsp}:

\begin{verbatim}
@Component(immediate = true, service = DynamicInclude.class)
public class CssTopHeadDynamicInclude extends BaseDynamicInclude {

    @Override
    public void include(
            HttpServletRequest request, HttpServletResponse response,
            String key)
        throws IOException {

        PrintWriter printWriter = response.getWriter();

        String content = 
    "<link href=\"http://localhost:8080/o/my-custom-dynamic-include/css/mentions.css\" 
    rel=\"stylesheet\" 
    type = \"text/css\" />";
    
        printWriter.println(content);
    }

    @Override
    public void register(DynamicIncludeRegistry dynamicIncludeRegistry) {
        dynamicIncludeRegistry.register("/html/common/themes/top_head.jsp#pre");
    }
  
}
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/dynamic-include-top-head-pre-mentions-css.png}
\caption{The top\_head pre key loads additional CSS and HTML resources
in the head of the theme.}
\end{figure}

Note that the link's \texttt{href} attribute's value
\texttt{/o/my-custom-dynamic-include/} is provided by the OSGi module's
\texttt{Web-ContextPath} (\texttt{/my-custom-dynamic-include} in the
example).

Now you know how to use the \texttt{top\_head.jsp} dynamic includes.

\subsection{Related Topics}\label{related-topics-57}

\href{/docs/7-1/tutorials/-/knowledge_base/t/bottom-jsp-dynamic-includes}{Bottom
JSP Dynamic Includes}

\href{/docs/7-1/tutorials/-/knowledge_base/t/top-js-dynamic-include}{Top
JS Dynamic Include}

\href{/docs/7-1/tutorials/-/knowledge_base/t/wysiwyg-editor-dynamic-includes}{WYSIWYG
Editor Dynamic Includes}

\section{Top JS Dynamic Include}\label{top-js-dynamic-include}

The \texttt{top\_js.jspf} dynamic include adds additional JavaScript
files to the theme's head. For example, you can use this extension point
to include a JS library that you need present in the theme's head:

\begin{verbatim}
/html/common/themes/top_js.jspf#resources
\end{verbatim}

The example below injects a JavaScript file into the top of the
\texttt{top\_js.jspf}:

\texttt{*DynamicInclude} Java Class:

\begin{verbatim}
@Component(immediate = true, service = DynamicInclude.class)
public class JSTopHeadDynamicInclude extends BaseDynamicInclude {

  @Override
    public void include(
            HttpServletRequest request, HttpServletResponse response,
            String key)
        throws IOException {

    PrintWriter printWriter = response.getWriter();

    String content = "<script charset=\"utf-8\" src=\"/o/my-custom-dynamic-include/my_example_javascript.js\" async />";

    printWriter.println(content);
    }

    @Override
    public void register(
        DynamicInclude.DynamicIncludeRegistry dynamicIncludeRegistry) {

        dynamicIncludeRegistry.register(
      "/html/common/themes/top_js.jspf#resources"
    );
    }
}
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/dynamic-include-top-js-example.png}
\caption{The Top JS dynamic include lets you load additional scripts in
the theme's head.}
\end{figure}

Note that the JavaScript \texttt{src} attribute's value
\texttt{/o/my-custom-dynamic-include/...} is provided by the OSGi
module's \texttt{Web-ContextPath} (\texttt{/my-custom-dynamic-include}
in the example).

Now you know how to use the \texttt{top\_js.jspf} dynamic include.

\subsection{Related Topics}\label{related-topics-58}

\href{/docs/7-1/tutorials/-/knowledge_base/t/bottom-jsp-dynamic-includes}{Bottom
JSP Dynamic Includes}

\href{/docs/7-1/tutorials/-/knowledge_base/t/top-head-jsp-dynamic-includes}{Top
Head JSP Dynamic Includes}

\href{/docs/7-1/tutorials/-/knowledge_base/t/wysiwyg-editor-dynamic-includes}{WYSIWYG
Editor Dynamic Includes}

\section{Bottom JSP Dynamic Includes}\label{bottom-jsp-dynamic-includes}

The \texttt{bottom.jsp} dynamic includes load additional HTML or scripts
in the bottom of the theme's body. The following keys are available:

Load additional HTML or scripts in the bottom of the theme's body,
before the existing ones:

\begin{verbatim}
/html/common/themes/bottom.jsp#pre
\end{verbatim}

Alternatively, load HTML or scripts in the bottom of the theme's body,
after the existing ones:

\begin{verbatim}
/html/common/themes/bottom.jsp#post 
\end{verbatim}

The example below includes an additional script for the Simulation panel
in the bottom of the theme's body, after the existing ones.

\texttt{SimulationDeviceDynamicInclude} Java class:

\begin{verbatim}
@Component(immediate = true, service = DynamicInclude.class)
public class SimulationDeviceDynamicInclude extends BaseDynamicInclude {

    @Override
    public void include(
            HttpServletRequest request, HttpServletResponse response,
            String key)
        throws IOException {

        PrintWriter printWriter = response.getWriter();

        printWriter.print(_TMPL_CONTENT);
    }

    @Override
    public void register(DynamicIncludeRegistry dynamicIncludeRegistry) {
        dynamicIncludeRegistry.register("/html/common/themes/bottom.jsp#post");
    }

    private static final String _TMPL_CONTENT = StringUtil.read(
        SimulationDeviceDynamicInclude.class,
        "/META-INF/resources/simulation_device_dynamic_include.tmpl");

}
\end{verbatim}

\texttt{simulation\_device\_dynamic\_include.tmpl}:

\begin{verbatim}
<script type="text/javascript">
    // <![CDATA[
        AUI().use(
            'aui-base',
            function(A) {
                var frameElement = window.frameElement;

                if (frameElement && frameElement.getAttribute('id') === 'simulationDeviceIframe') {
                    A.getBody().addClass('lfr-has-simulation-panel');
                }
            }
        );
    // ]]>
</script>
\end{verbatim}

When the Simulation panel is open, the script adds the
\texttt{lfr-has-simulation-panel} class to the theme's body.

\begin{figure}
\centering
\includegraphics{./images/dynamic-include-bottom-jsp-post-simulation-tmpl.png}
\caption{You can use the bottom JSP dynamic include to inject scripts.}
\end{figure}

Now you know how to use the \texttt{bottom.jsp} dynamic includes.

\subsection{Related Topics}\label{related-topics-59}

\href{/docs/7-1/tutorials/-/knowledge_base/t/top-head-jsp-dynamic-includes}{Top
Head JSP Dynamic Includes}

\href{/docs/7-1/tutorials/-/knowledge_base/t/top-js-dynamic-include}{Top
JS Dynamic Include}

\href{/docs/7-1/tutorials/-/knowledge_base/t/wysiwyg-editor-dynamic-includes}{WYSIWYG
Editor Dynamic Includes}

\chapter{Service Builder}\label{service-builder}

An application without reliable business logic or persistence isn't much
of an application at all. Unfortunately, writing your own persistence
code often takes a great deal of time. Fortunately, Liferay provides the
Liferay Service Builder to generate it for you. You might now be
thinking, ``What?! I hate code generators!'' Not to fear; you can still
write your own persistence code if you wish. And if you choose to use
Service Builder, you can edit and customize the code it generates.
Regardless of how you produce your persistence code, you can then use
Service Builder to implement your app's business logic.

These tutorials shows you how to use Service Builder to generate your
persistence framework and implement your business logic. They also
demonstrate using Spring in your app.

\section{What is Service Builder?}\label{what-is-service-builder-1}

Liferay Service Builder is a model-driven code generation tool that lets
you define custom object models called entities. Service Builder
generates a service layer through object-relational mapping (ORM)
technology that provides a clean separation between your object model
and code for the underlying database. This frees you to add the
necessary business logic for your application. Service Builder takes an
XML file as input and generates the necessary model, persistence, and
service layers for your application. These layers provide a clean
separation of concerns. Service Builder generates most of the common
code needed to implement create, read, update, delete, and find
operations on the database, allowing you to focus on the higher level
aspects of service design. This tutorial explains some of the main
benefits of using Service Builder:

\begin{itemize}
\tightlist
\item
  Integration with Liferay DXP
\item
  Automatically generated model, persistence, and service layers
\item
  Automatically generated local and remote services
\item
  Automatically generated Hibernate and Spring configurations
\item
  Support for generating finder methods for entities and finder methods
  that account for permissions
\item
  Built-in entity caching support
\item
  Support for custom SQL queries and dynamic queries
\item
  Saved development time
\end{itemize}

Liferay DXP uses Service Builder to generate all of its internal
database persistence code. In fact, the services, both local and remote,
are generated by Service Builder. Additionally, the service
\href{https://github.com/liferay/liferay-portal/tree/7.0.x/modules}{modules}
are generated by Service Builder. These things demonstrate Service
Builder to be a robust and reliable tool. It is easy to use and can save
\emph{lots} of development time. Although the number of files Service
Builder generates can seem intimidating at first, you only need to work
with a few files to customize to your applications and add business
logic.

\noindent\hrulefill

\textbf{Note:} You don't have to use Service Builder to develop
applications on Liferay DXP. It's entirely possible to develop them by
writing custom code for database persistence using your persistence
framework of choice. If you so choose, you can work directly with JPA or
Hibernate.

\noindent\hrulefill

One of the main ways Service Builder saves development time is by
completely eliminating the need to write and maintain database access
code. To generate a basic service layer, you only need to create a
\texttt{service.xml} file and run Service Builder. This generates a new
service \texttt{.jar} file for your project. The generated service
\texttt{.jar} file includes a model layer, a persistence layer, a
service layer, and related infrastructure. These distinct layers
represent a healthy separation of concerns. The model layer is
responsible for defining objects to represent your project's entities,
the persistence layer is responsible for saving entities to and
retrieving entities from the database, and the service layer is
responsible for exposing CRUD and related methods for your entities as
an API. The code Service Builder generates is database-agnostic, as is
Liferay DXP itself.

Each entity Service Builder generates contains a model implementation
class. Each entity also contains a local service implementation class, a
remote service implementation class, or both, depending on how you
configure Service Builder in your \texttt{service.xml} file.
Customizations and business logic can be implemented in these three
classes; in fact, these are the only classes generated by Service
Builder that are intended to be customized. Ensuring that all
customizations take place in only a few classes makes Service Builder
projects easy to maintain. The local service implementation class is
responsible for calling the persistence layer to retrieve and store data
entities. Local services contain the business logic and access the
persistence layer. They can be invoked by client code running in the
same Java Virtual Machine. Remote services usually have additional code
for permission checking and are meant to be accessible from anywhere
over the Internet or your local network. Service Builder automatically
generates code that makes the remote services accessible. The remote
services Service Builder generates include SOAP utilities and can be
accessed via SOAP or JSON.

Another way Service Builder saves development time is by providing
Spring and Hibernate configurations for your project. Service Builder
uses Spring dependency injection to make service implementation classes
available at runtime and uses Spring AOP for database transaction
management. Service Builder also uses the Hibernate persistence
framework for object-relational mapping. As a convenience to you,
Service Builder hides the complexities of using these technologies. You
can take advantage of Dependency Injection (DI), Aspect Oriented
Programming (AOP), and Object-Relational Mapping (ORM) in your projects
without having to manually set up a Spring or Hibernate environment or
make any configurations.

Another benefit of using Service Builder is that it generates
\emph{finder methods}. Finder methods retrieve entity objects from the
database based on specified parameters. You just need to specify the
kinds of finder methods to be generated in the \texttt{service.xml}
configuration file and Service Builder does the rest. The generated
finder methods let you, for example, retrieve a list of all entities
associated with a certain site or a list of all entities associated with
a certain site \emph{and} a certain user. Service Builder not only
supports generating these kinds of simple finder methods but also finder
methods that take Liferay's permissions into account. For example, if
you are using Liferay's permissions system to protect access to your
entities, Service Builder can generate a different kind of finder method
that only returns entities that the logged-in user has permission to
view.

Service Builder also provides built-in caching support. Liferay caches
objects at three levels: \emph{entity}, \emph{finder}, and
\emph{Hibernate}. By default, Liferay uses Ehcache as an underlying
cache provider for each of these cache levels. However, this is
configurable via portal properties. All you have to do to enable entity
and finder caching for an entity in your project is to set the
\texttt{cache-enabled=true} attribute of your entity's
\texttt{\textless{}entity\textgreater{}} element in your
\texttt{service.xml} configuration file. Please refer to the
\href{/docs/7-1/deploy/-/knowledge_base/d/enabling-cluster-link}{Liferay
Clustering} documentation for more details about Liferay caching.

Service Builder is a flexible tool. It automates many of the common
tasks associated with creating database persistence code but it doesn't
prevent you from creating custom SQL queries or custom finder methods.
Service Builder lets you define custom SQL queries in an XML file and
implement custom finder methods to run the queries. This is useful, for
example, for retrieving specific pieces of information from multiple
tables via an SQL join. Service Builder also supports retrieving
database information via dynamic query. Liferay's dynamic query API
leverages Hibernate's criteria API.

\noindent\hrulefill

\textbf{Note}: Liferay includes a
\href{https://repository.liferay.com/nexus/content/repositories/liferay-public-releases/com/liferay/com.liferay.portal.tools.service.builder/}{Service
Builder library} and build tool-specific plugins such as the
\href{/docs/7-1/reference/-/knowledge_base/r/service-builder-gradle-plugin}{Gradle
Service Builder plugin}, which includes Liferay's Service Builder
library as a dependency. Service Builder supports Liferay 7's modular
application development style of keeping API and implementation code in
separate modules. The
\href{/docs/7-0/reference/-/knowledge_base/r/service-builder-samples}{Service
Builder sample apps} demonstrate this.

\noindent\hrulefill

In summary, we encourage you to use Service Builder for application
development because it's a proven solution used throughout Liferay DXP
and Liferay DXP applications. It generates distinct model, persistence,
and service layers, local and remote services, Spring and Hibernate
configurations, and related infrastructure without requiring any manual
intervention. It also lets you generate basic SQL queries and finder
methods and methods that filter results, taking Liferay permissions into
account. Service Builder also supports entity and query caching. Each of
these features saves lots of development time, both initial development
time and time that would have to be spent maintaining, extending, or
customizing a project. Finally, Service Builder is not a restrictive
tool: it lets you add custom SQL queries and finder methods and it also
supports dynamic query.

\chapter{Service Builder Persistence}\label{service-builder-persistence}

Liferay's Service Builder can generate your project's persistence layer
by automating the creation of interfaces and classes. Your application's
persistence layer persists data represented by your configured entities
to a database. In fact, your local service implementation classes are
responsible for calling the persistence layer to retrieve and store your
application's data. So instead of taking the time-consuming route of
writing your own persistence layer, you can use Service Builder to
quickly define your entities and generate the layer instantaneously.

Here's what these tutorials cover:

\begin{itemize}
\tightlist
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/defining-an-object-relational-map-with-service-builder}{Defining
  an object-relational map and generating your persistence layer from
  that map}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/running-service-builder}{Running
  Service Builder}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/understanding-the-code-generated-by-service-builder}{Understanding
  and using local and remote services Service Builder generates}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/understanding-servicecontext}{Using
  the \texttt{ServiceContext} class}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/customizing-model-entities-with-model-hints}{Customizing
  model entities with Model Hints}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/custom-sql}{SQL queries}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/dynamic-query}{Using
  Hibernate's criteria API}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/configuring-service-properties}{Configuring
  \texttt{service.properties}}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/connecting-service-builder-to-external-databases}{Connecting
  Service Builder to external data sources}
\end{itemize}

Start with defining an object-relational map.

\chapter{Defining an Object-Relational Map with Service
Builder}\label{defining-an-object-relational-map-with-service-builder}

In this tutorial, you'll learn how to define an object relational map so
your application can persist data. As an example, you'll examine the
existing Liferay Bookmarks application that uses Service Builder.

The Bookmarks application bookmarks assets in Liferay. The application
defines two entities, or model types, to represent an organization's
bookmarks and their folders. These entities are called \emph{bookmark
entries} and \emph{bookmark folders}. Since a bookmark must have a
folder (even if it's a root folder), the entry entity references a
folder entity as one of its attributes.

The Bookmarks application's source code resides in the
\texttt{bookmarks-api}, \texttt{bookmarks-service}, and
\texttt{bookmarks-web} modules. Notice the
\texttt{BookmarksAdminPortlet.java} and \texttt{BookmarksPortlet.java}
files in the \texttt{com.liferay.bookmarks.web.portlet} package in the
\texttt{bookmarks-web} module. These portlet classes extend Liferay's
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/bridges/mvc/MVCPortlet.html}{\texttt{MVCPortlet}
class}. They act as the controllers in the MVC pattern. These classes
contain the business logic that invokes the Service Builder generated
bookmarks services that you'll learn how to create in this section. The
application's view layer is implemented in the JSPs in the
\texttt{bookmarks-web/src/main/resources/META-INF/resources} folder.

This tutorial assumes your application has these types of modules :

\begin{itemize}
\tightlist
\item
  \texttt{*-api}: Service interfaces
\item
  \texttt{*-service}: Service implementations
\item
  \texttt{*-web}: Portlet and controller
\end{itemize}

The parent folder of these modules is the \emph{application folder}. The
\href{/docs/7-1/reference/-/knowledge_base/r/using-the-service-builder-template}{Service
Builder project template} is available for creating the \texttt{*-api}
and \texttt{*-service} modules. Client UI project templates such as the
\href{/docs/7-1/reference/-/knowledge_base/r/using-the-mvc-portlet-template}{MVCPortlet
template} are available for creating the \texttt{*-web} module. You can
create projects from both templates using either Dev Studio DXP or
Blade.

The first step in using Service Builder is to define your model classes
and their attributes in a \texttt{service.xml} file. This file typically
resides in the \texttt{*-service} module's root folder, although you can
configure your build tool to recognize it in other folders. Service
Builder terminology calls model classes \emph{entities}. For example,
the Bookmarks application has two entities: \texttt{BookmarksEntry} and
\texttt{BookmarksFolder}. The requirements for each are defined in the
\texttt{bookmarks-service} module's
\href{https://github.com/liferay/liferay-portal/blob/master/modules/apps/bookmarks/bookmarks-service/service.xml}{service.xml}
listed in the \texttt{\textless{}column\ /\textgreater{}} elements.

Once Service Builder reads the \texttt{service.xml} file, you can define
your entities.
\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-ide}{Liferay Dev
Studio DXP} makes it easy to define entities in your application's
\texttt{service.xml} file. Follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/creating-the-service-xml-file}{Create
  the \texttt{service.xml} file.}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/defining-global-service-information}{Define
  global information for the service.}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/defining-service-entities}{Define
  service entities.}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/defining-the-columns-attributes-for-each-service-entity}{Define
  the columns (attributes) for each service entity.}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/defining-relationships-between-service-entities}{Define
  relationships between entities.}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/defining-ordering-of-service-entity-instances}{Define
  a default order for the entity instances to be retrieved from the
  database.}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/defining-service-entity-finder-methods}{Define
  finder methods that retrieve objects from the database based on
  specified parameters.}
\end{enumerate}

Each step is explained in detail. Start with creating a
\texttt{service.xml} file.

\section{Creating the service.xml
File}\label{creating-the-service.xml-file}

To define a service for your portlet project, you must create a
\texttt{service.xml} file. The DTD (Document Type Declaration) file
\href{https://docs.liferay.com/ce/portal/7.1-latest/definitions/liferay-service-builder_7_1_0.dtd.html}{liferay-service-builder\_7\_1\_0.dtd}
specifies the format and requirements of the XML to use. You can create
your \texttt{service.xml} file manually, or you can use Liferay Dev
Studio DXP. build the \texttt{service.xml} file piece-by-piece, taking
the guesswork out of creating XML that adheres to the DTD.

If you created your project from the Blade or Dev Studio DXP template,
you have a \texttt{service.xml} file in your \texttt{*-service} module's
root folder with an \texttt{entity} element named \emph{Foo}. Remove the
entire
\texttt{\textless{}entity\ name="Foo"\ ...\textgreater{}\ ...\ \textless{}/entity\textgreater{}}
element: it's just an example. It has no practical use for you.

If you don't already have a \texttt{service.xml} file, create one in
your \texttt{*-service} module's root folder and open the file. Liferay
Dev Studio DXP provides a Diagram mode and a Source mode to give you
different perspectives of the service information in your
\texttt{service.xml} file.

\begin{itemize}
\tightlist
\item
  \textbf{Diagram mode} facilitates creating and visualizing
  relationships between service entities.
\item
  \textbf{Source mode} brings up the \texttt{service.xml} file's raw XML
  content in the editor.
\end{itemize}

You can switch between these modes.

Next, you'll specify your service's global information.

\section{Defining Global Service
Information}\label{defining-global-service-information}

A service's global information applies to all its entities, so it's a
good place to start. In Liferay Dev Studio DXP, select the \emph{Service
Builder} node in the upper left corner of the Overview mode of your
\texttt{service.xml} file. The main section of the view now shows the
Service Builder form in which to enter your service's global
information. The fields include the service's

\begin{itemize}
\tightlist
\item
  \hyperref[package-path]{Package path}
\item
  \hyperref[namespace-options]{Namespace options}
\item
  \hyperref[multiversion-concurrency-control-mvcc]{Multiversion
  concurrency control}
\item
  \hyperref[author]{Author}
\end{itemize}

\begin{figure}
\centering
\includegraphics{./images/service-builder-main-form.png}
\caption{This is the Service Builder form from the Bookmarks
application's \texttt{service.xml}.}
\end{figure}

\subsection{Package Path}\label{package-path}

The package path specifies the package in which the service and
persistence classes are generated. The package path for Bookmarks
ensures that the \texttt{*-api} module's service classes are generated
in the \texttt{com.liferay.bookmarks} package. The persistence classes
are generated in a package of the same name in the \texttt{*-service}
module. For example, examine the Bookmarks application's
\href{https://github.com/liferay/liferay-portal/tree/master/modules/apps/bookmarks/bookmarks-api}{bookmarks-api}
and
\href{https://github.com/liferay/liferay-portal/tree/master/modules/apps/bookmarks/bookmarks-service}{bookmarks-service}
modules to see how these are automatically generated for you. A later
tutorial
\href{/docs/7-1/tutorials/-/knowledge_base/t/running-service-builder}{describes
the package content}.

\subsection{Namespace Options}\label{namespace-options}

Service Builder uses the service namespace in naming the database tables
it generates for the service. For example, \emph{Bookmarks} could serve
as the namespace for a Bookmarks application service.

\begin{verbatim}
<namespace>Bookmarks</namespace>
\end{verbatim}

Service Builder uses the namespace in the following SQL scripts it
generates in your \texttt{src/main/resources/sql} folder:

\begin{itemize}
\tightlist
\item
  \texttt{indexes.sql}
\item
  \texttt{sequences.sql}
\item
  \texttt{tables.sql}
\end{itemize}

\noindent\hrulefill

\textbf{Note:} The generated SQL script folder location is configurable.
For example, if you're using Gradle, you can define the \texttt{sqlDir}
setting in the project's Gradle \texttt{build.gradle} file or Maven
\texttt{pom.xml} file, the same way the \texttt{databaseNameMaxLength}
setting is applied in the examples below.

\noindent\hrulefill

Service Builder uses the SQL scripts to create database tables for all
the entities the \texttt{service.xml} defines. The database table names
have the namespace prepended when they are created. Since the example
namespace value is \texttt{Bookmarks}, the database table names created
for the entities start with \texttt{Bookmarks\_} as their prefix. Each
Service Builder project's namespace must be unique. Separate plugins
should use separate namespaces and should not use a namespace already
used by Liferay entities (such as \texttt{Users} or \texttt{Groups}).
Check the table names in Liferay's database to see the namespaces
already in use.

\textbf{Warning:} Use caution when assigning namespace values. Some
databases have strong restrictions on database table and column name
lengths. The Service Builder
\href{/docs/7-1/reference/-/knowledge_base/r/service-builder-gradle-plugin\#task-properties}{Gradle}
and
\href{/docs/7-1/reference/-/knowledge_base/r/service-builder-with-maven\#available-parameters}{Maven}
plugin parameter \texttt{databaseNameMaxLength} sets the maximum length
you can use for your table and column names. Here are paraphrased
examples of setting \texttt{databaseNameMaxLength} in build files:

\textbf{Gradle \texttt{build.gradle}}

\begin{verbatim}
buildService {
    ...
    databaseNameMaxLength = 64
    ...
}
\end{verbatim}

\textbf{Maven \texttt{pom.xml}}

\begin{verbatim}
<configuration>
    ...
    <databaseNameMaxLength>64</databaseNameMaxLength>
    ...
</configuration>
\end{verbatim}

\subsection{Multiversion concurrency control
(MVCC)}\label{multiversion-concurrency-control-mvcc}

The \texttt{service-builder} element's \texttt{mvcc-enabled} attribute
is \texttt{false} by default. Setting \texttt{mvcc-enabled="true"}
(hint: edit \texttt{service.xml} in \emph{Source} view) enables
\href{https://en.wikipedia.org/wiki/Multiversion_concurrency_control}{multiversion
concurrency control} (MVCC) for all of the service's entities. In
systems, concurrent updates are common. Without MVCC people may read or
overwrite data from an invalid state unknowingly. With MVCC, each
modification is made upon a given base version number. When Hibernate
receives the update, it generates an \texttt{update} SQL statement that
uses a \texttt{where} clause to make sure the current data version is
the version you expect.

If the current data version

\begin{itemize}
\item
  \textbf{matches the expected version}, your data operation is based on
  up-to-date data and is accepted.
\item
  \textbf{doesn't match the expected version}, the data you're operating
  on is outdated. Liferay DXP rejects your data operation and throws an
  exception, which you can catch to help the user handle the exception
  (e.g., suggest retrying the operation).
\end{itemize}

\textbf{Important:} Enable MVCC for all your services by setting
\texttt{mvcc-enabled="true"} in your
\texttt{\textless{}service-builder/\textgreater{}} element. When
invoking service entity updates (e.g.,
\texttt{fooService.update(object)}), make sure to do so in transactions.
Propagate rejected transactions to the UI for the user to handle.

\subsection{Author}\label{author}

As the last piece of global information, enter your name as the
service's \emph{author} in your \texttt{service.xml} file. Service
Builder adds \texttt{@author} annotations with the specified name to all
the Java classes and interfaces it generates. Save your
\texttt{service.xml} file. Next, you'll add entities for your services.

\section{Defining Service Entities}\label{defining-service-entities}

Entities are the heart and soul of a service. They represent the map
between the model objects in Java and your database fields and tables.
Service Builder maps the entities you define automatically, giving you a
facility for taking Java objects and persisting them. For the Bookmarks
application, two entities are created according to its
\href{https://github.com/liferay/liferay-portal/blob/master/modules/apps/bookmarks/bookmarks-service/service.xml}{service.xml}
--one for bookmark entries and one for bookmark folders.

Here's a summary of the \texttt{BookmarksEntry} entity information:

\begin{itemize}
\tightlist
\item
  \textbf{Name:} \emph{BookmarksEntry}
\item
  \textbf{Local service:} \emph{yes}
\item
  \textbf{Remote service:} \emph{yes}
\end{itemize}

And here's what is used for the \texttt{BookmarksFolder} entity:

\begin{itemize}
\tightlist
\item
  \textbf{Name:} \emph{BookmarksFolder}
\item
  \textbf{Local service:} \emph{yes}
\item
  \textbf{Remote service:} \emph{yes}
\end{itemize}

Here are steps to create entities using Liferay Dev Studio DXP:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In the outline on the left side of the \texttt{service.xml} editor in
  Overview mode, select the \emph{Entities} node under the Service
  Builder node. In the main part of the view, notice that the Entities
  table is empty.
\item
  Create an entity by clicking on the \emph{Add Entity} icon
  (\includegraphics{./images/icon-add-ide.png}) to the right of the
  table.
\item
  Name your entity and mark whether to generate local and remote
  services for it.
\end{enumerate}

Add as many entities as you need.

\begin{figure}
\centering
\includegraphics{./images/service-add-entity.png}
\caption{Adding service entities in your \texttt{service.xml} file is
easy with Liferay Dev Studio DXP's \emph{Overview} mode.}
\end{figure}

The entity's database table name includes the entity name prefixed with
the namespace. The Bookmarks example creates one database table named
\texttt{Bookmarks\_BookmarksEntry} and another named
\texttt{Bookmarks\_BookmarksFolder}.

Setting \emph{Local Service} (the \texttt{local-service} attribute) to
\texttt{true} instructs Service Builder to generate local interfaces for
the entity's services. Local services are set to \texttt{false} by
default. Local services can only be invoked from the Liferay server on
which they're deployed.

Setting \emph{Remote Service} (the \texttt{remote-service} attribute) to
\texttt{true} instructs Service Builder to generate remote interfaces
for the service. Local services are set to \texttt{true} by default. You
can build a fully-functional application without generating remote
services. In that case, you could set your entity local services to
\texttt{true} and remote services to \texttt{false}. If, however, you
want to enable remote access to your application's services, set both
local service and remote service to \texttt{true}.

\noindent\hrulefill

\textbf{Tip:} Suppose you have an existing Data Access Object (DAO)
service for an entity built using some other framework such as JPA. You
can set local service to \texttt{false} and remote service to
\texttt{true} so that the methods of your remote \texttt{-Impl} class
can call the methods of your existing DAO. This enables your entity to
integrate with Liferay's permission-checking system and provides access
to the web service APIs generated by Service Builder. This is a very
handy, quite powerful, and often used feature of Liferay.

\noindent\hrulefill

Now that you've seen how to create your application's entities, you'll
learn how to describe their attributes using entity \emph{columns}.

\section{Defining the Columns (Attributes) for Each Service
Entity}\label{defining-the-columns-attributes-for-each-service-entity}

An entity's columns represent its attributes. These attributes map table
fields to Java object fields. To add attributes for your entity, drill
down to its columns in the Overview mode outline of the
\texttt{service.xml} file. From the outline, expand the \emph{Entities}
node and expand an entity node. Then select the \emph{Columns} node.
Liferay Dev Studio DXP displays a table of the entity's columns.

\begin{figure}
\centering
\includegraphics{./images/service-builder-entity-columns.png}
\caption{Liferay Dev Studio DXP facilitates defining table columns for
entities.}
\end{figure}

Service Builder creates a database field for each column you add to the
\texttt{service.xml} file. It maps a database field type appropriate to
the Java type specified for each column, and it does this across all the
databases Liferay supports. Once Service Builder runs, it generates a
Hibernate configuration that handles the object-relational mapping.
Service Builder automatically generates getter/setter methods in the
model class for these attributes. The column's Name specifies the name
used in the getters and setters that are created for the entity's Java
field. The column's Type indicates the Java type of this field for the
entity. If a column's Primary (i.e., primary key) attribute value is set
to \texttt{true}, then the column becomes part of the primary key for
the entity. An entity's primary key uniquely identifies the entity. If
only one column has Primary set to \texttt{true}, then that column
represents the entire primary key for the entity. This is the case in
the Bookmarks application. However, it's possible to use multiple
columns as the primary key for an entity. In this case, the combination
of columns makes up a compound primary key for the entity.

\noindent\hrulefill

\textbf{Note:} The
\href{/docs/7-1/tutorials/-/knowledge_base/t/implementing-an-add-method\#step-3-generate-a-primary-key}{Implementing
an Add Method} article demonstrates how to generate unique primary keys
for entity instances.

\noindent\hrulefill

\subsection{Create Entity Columns}\label{create-entity-columns}

Similar to the way you used the form table for adding entities, add
attribute columns for each of your entities.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create each attribute by clicking on the Add icon
  (\includegraphics{./images/icon-add-ide.png}).
\item
  Fill in the attribute's name
\item
  Select the attribute's type. While your cursor is in a column's
  \emph{Type} field, an option icon appears. Click this icon to select
  the appropriate type for the column.
\item
  Specify whether the attribute is a primary key for the entity.
\end{enumerate}

\textbf{Note}: On deploying a \texttt{*service} module, Service Builder
automatically generates indexes for all entity primary keys.

Create a column for each attribute of your entity or entities.

\subsection{Support Multi-tenancy}\label{support-multi-tenancy}

In addition to columns for your entity's primary key and attributes, add
portal instance ID and site ID columns. They let your portlet support
Liferay's multi-tenancy features, so that each portal instance and each
site in a portal instance can have independent sets of portlet data. To
hold the site's ID, add a column called \texttt{groupId} of type
\texttt{long}. To hold the portal instance's ID, add a column called
\texttt{companyId} of type \texttt{long}. To add these columns to your
entities, follow the table below.

\textbf{Portal and site scope columns}

\begin{longtable}[]{@{}ccc@{}}
\toprule\noalign{}
Name & Type & Primary \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{companyId} & long & no \\
\texttt{groupId} & long & no \\
\end{longtable}

\subsection{Track Ownership}\label{track-ownership}

To track each entity instance's owner, add a column called
\texttt{userId} of type \texttt{long}.

\textbf{User column}

\begin{longtable}[]{@{}ccc@{}}
\toprule\noalign{}
Name & Type & Primary \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{userId} & long & no \\
\end{longtable}

\subsection{Audit Entities}\label{audit-entities}

Lastly, you can add columns to help audit your entities. For example,
you could create a column named \texttt{createDate} of type
\texttt{Date} to note an entity instance's creation date. And add a
column named \texttt{modifiedDate} of type \texttt{Date} to track the
last time an entity instance was modified.

\textbf{Audit columns}

\begin{longtable}[]{@{}ccc@{}}
\toprule\noalign{}
Name & Type & Primary \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{userId} & long & no \\
\texttt{createDate} & Date & no \\
\texttt{modifiedDate} & Date & no \\
\end{longtable}

Great! Your entities have columns that not only represent their
attributes, but also support multi-tenancy and entity auditing. Next,
you'll learn how to specify the relationship service entities.

\section{Defining Relationships Between Service
Entities}\label{defining-relationships-between-service-entities}

Referencing one type of entity in the context of another entity is a
common requirement. This is also known as \emph{relating} entities.
Liferay's Bookmarks application defines a relationship between an entry
and its folder.

As mentioned earlier, each bookmark must have a folder. Therefore, each
\texttt{BookmarksEntry} entity must relate to a \texttt{BookmarksFolder}
entity. Liferay @ide@'s Diagram mode for \texttt{service.xml}
facilitates relating entities.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Select Diagram mode for the \texttt{service.xml} file.
\item
  Select the \emph{Relationship} option under \emph{Connections} in the
  palette on the right side of the view. This relationship tool helps
  you draw relationships between entities in the diagram.
\item
  Click your first entity and move your cursor over to the entity you'd
  like to relate it with. Liferay Dev Studio DXP draws a dashed line
  from your selected entity to the cursor.
\item
  Click the second entity to complete drawing the relationship. Liferay
  Dev Studio DXP turns the dashed line into a solid line, with an arrow
  pointing to the second entity.
\item
  Save the \texttt{service.xml} file.
\end{enumerate}

Congratulations! You've related two entities. Their relationship shows
in Diagram mode and looks similar to the relationship in the figure
below.

\begin{figure}
\centering
\includegraphics{./images/service-builder-relate-entities.png}
\caption{Relating entities is a snap in Liferay Dev Studio DXP's
\emph{Diagram} mode for \texttt{service.xml}.}
\end{figure}

Switch to \emph{Source} mode in the editor for your \texttt{service.xml}
file and note that Liferay Dev Studio DXP created a column element in
the first selected entity to hold the ID of the corresponding entity
instance reference. For example, the \texttt{BookmarksEntry} entity uses
this column to relate to a \texttt{BookmarksFolder} entity :

\begin{verbatim}
<column name="folderId" type="long" />
\end{verbatim}

Now that your entity columns are in place and entity relationships are
established, you can specify the default order in which the entity
instances are retrieved from the database.

\section{Defining Ordering of Service Entity
Instances}\label{defining-ordering-of-service-entity-instances}

Often, you want to retrieve multiple instances of a given entity and
list them in a particular order. The \texttt{service.xml} file lets you
specify the default order of your entities.

Suppose you want to return \texttt{BookmarksEntry} entities
alphabetically by name. It's easy to specify these default orderings
using Liferay Dev Studio DXP.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Switch back to \emph{Overview} mode in the \texttt{service.xml} file
  editor.
\item
  Select the \emph{Order} node under the entity node in the outline on
  the left side of the view. The IDE displays a form for ordering the
  chosen entity.
\item
  Check the \emph{Specify ordering} checkbox to show the form for
  specifying the ordering.
\item
  Create an order column by clicking the \emph{Add} icon
  (\includegraphics{./images/icon-add-ide.png}) to the right of the
  table.
\item
  Enter the column name (e.g., \emph{name}, \emph{date}, etc.) to use in
  ordering the entity.
\item
  Click the \emph{Browse icon}
  (\includegraphics{./images/icon-browse-ide.png}) to the right of the
  \emph{By} field and choose the \emph{asc} or \emph{desc} option. This
  orders the entity in ascending or descending order.
\end{enumerate}

Now that you know how to order your service entities, the last thing to
do is to define the finder methods for retrieving entity instances from
the database.

\section{Defining Service Entity Finder
Methods}\label{defining-service-entity-finder-methods}

Finder methods retrieve entity objects from the database based on
specified parameters. You'll probably want to create at least one finder
method for each entity you create in your services. Service Builder
generates several methods based on each finder you create for an entity.
It creates methods to fetch, find, remove, and count entity instances
based on the finder's parameters.

For many applications, it's important to be able to find its entities
per site. You can specify these finders using Liferay Dev Studio DXP's
Overview mode for the \texttt{service.xml} file.

\subsection{Create Finders}\label{create-finders}

Here are the steps for creating a finder node:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Select the \emph{Finders} node under the entity node in the Outline on
  the left side of the screen. The IDE displays an empty \emph{Finders}
  table in the main part of the view.
\item
  Create a new finder by clicking the \emph{Add} icon
  (\includegraphics{./images/icon-add-ide.png}) to the right of the
  table.
\item
  Specify your finder's name and return type. Use the Java camel-case
  naming convention when naming finders since the finder's name is used
  to name the methods that Service Builder creates.
\end{enumerate}

The IDE creates a new finder sub-node under the \emph{Finders} node in
the outline. Next, you'll learn how to specify the finder column for
this node.

\subsection{Create Finder Columns}\label{create-finder-columns}

Under the new finder node, Dev Studio DXP created a \emph{Finder
Columns} node. Here are the steps for creating finder columns:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Select the \emph{Finder Columns} node to specify the columns for your
  finder's parameters.
\item
  Create a new finder column by clicking the \emph{Add} icon and
  specifying the column's name. Keep in mind that you can specify
  multiple finder parameters (columns).
\item
  Save your \texttt{service.xml} file.
\end{enumerate}

\noindent\hrulefill

\textbf{Important}: DO NOT create finders that use entity primary key as
parameters. They're unnecessary as Service Builder automatically
generates \texttt{findByPrimaryKey} and \texttt{fetchByPrimaryKey}
methods for all entity primary keys. On deploying a \texttt{*service}
module, Service Builder creates indexes for all entity primary key
columns and finder columns. Adding finders that use entity primary keys
results in attempts to create multiple indexes for the same
columns---Oracle DB, for example, reports these attempts as errors.

\noindent\hrulefill

\begin{figure}
\centering
\includegraphics{./images/service-builder-finders.png}
\caption{Creating Finder entities is easy with Liferay Dev Studio DXP.}
\end{figure}

If you're creating site-scoped entities (entities whose data should be
unique to each site), follow the steps described above to create finders
by \texttt{groupId} for retrieving your entities.

Service Builder generates finder-related methods (e.g.,
\texttt{fetchByGroupId}, \texttt{findByGroupId},
\texttt{removeByGroupId}, \texttt{countByGroupId}) for the your entities
in the \texttt{*Persistence} and \texttt{*PersistenceImpl} classes. The
first of these classes is the interface; the second is its
implementation. For example, Liferay's Bookmarks application generates
its entity finder methods in the \texttt{-Persistence} classes found in
the
\texttt{/bookmarks-api/src/main/java/com/liferay/bookmarks/service/persistence}
folder and the \texttt{-PersistenceImpl} classes in the
\texttt{/bookmarks-service/src/main/java/com/liferay/bookmarks/service/persistence/impl}
folder.

Now you know to configure Service Builder to create finder methods for
your entity. Terrific!

Now that you've specified the service for your project, you're ready to
\emph{build} the service by running Service Builder. It's time to
\href{/docs/7-1/tutorials/-/knowledge_base/t/running-service-builder}{run
Service Builder and examine the code it generates}.

\section{Running Service Builder}\label{running-service-builder}

This tutorial demonstrates how to run Service Builder. If want to use
Service Builder in your application but haven't yet
\href{/docs/7-1/tutorials/-/knowledge_base/t/defining-an-object-relational-map-with-service-builder}{created
a \texttt{service.xml} file that defines an object-relational map for
you application}, make sure to do so before proceeding with this
tutorial.

There are two ways to build services from a \texttt{service.xml} file:

\begin{itemize}
\tightlist
\item
  \hyperref[using-liferay-dev-studio]{Liferay Dev Studio}
\item
  \hyperref[using-the-command-line]{Command line}
\end{itemize}

Liferay Dev Studio DXP is demonstrated first.

\subsection{Using Liferay Dev Studio}\label{using-liferay-dev-studio}

From the Package Explorer, right-click on your service module and then
select \emph{Liferay} → \emph{build-service}.

\begin{figure}
\centering
\includegraphics{./images/service-builder-ide-build-service.png}
\caption{Liferay Dev Studio DXP facilitates building Service Builder
services via the \emph{build-service} option in the service module's
\emph{Liferay} submenu.}
\end{figure}

Service Builder generates plenty of files. You can run Service Builder
from the command line too.

\subsection{Using the Command Line}\label{using-the-command-line}

Open a command line and navigate to your application folder (the folder
that contains your \texttt{*-api} and \texttt{*-service} modules).

To build your services using Gradle, enter the following command:

\begin{verbatim}
blade gw buildService  
\end{verbatim}

or

\begin{verbatim}
gradlew buildService
\end{verbatim}

Blade's \texttt{gw} command works in any project that has a Gradle
Wrapper available to it--projects generated using Liferay project
templates have a Gradle Wrapper.

\noindent\hrulefill

\textbf{Note:} Liferay Workspace's Gradle Wrapper script is in the
workspace root folder. If your application project folder is located at
\texttt{{[}workspace{]}/modules/{[}application{]}}, for example, the
Gradle Wrapper is available at \texttt{../../gradlew}.

\noindent\hrulefill

If you're using Maven, build the services by running the following
command:

\begin{verbatim}
mvn service-builder:build
\end{verbatim}

\textbf{Important:} The \texttt{mvn\ service-builder:build} command only
works if you're using the
\texttt{com.liferay.portal.tools.service.builder} plugin version
1.0.145+. Maven projects using an earlier version of the Service Builder
plugin should update their POM accordingly. More information is
available on
\href{/docs/7-1/tutorials/-/knowledge_base/t/using-service-builder-in-a-maven-project}{using
Maven to run Service Builder}.

On successfully building the services, Service Builder prints the
message \texttt{BUILD\ SUCCESSFUL}. Many generated files appear in your
project. They represent a model layer, service layer, and persistence
layer for your entities. Don't worry about the number of generated
files--they're explained in the next tutorial. Its time to review the
code Service Builder generates for your entities.

\section{Understanding the Code Generated by Service
Builder}\label{understanding-the-code-generated-by-service-builder}

\href{/docs/7-1/tutorials/-/knowledge_base/t/running-service-builder}{Service
Builder generates code} to support your entities. The files listed under
Local Service and Remote Service below are only generated for an entity
that has both \texttt{local-service} and \texttt{remote-service}
attributes set to \texttt{true}. Service Builder generates services for
these entities in your application's \texttt{*-api} and
\texttt{*-service} modules in the packages you specified in
\texttt{service.xml}. For example, here are the package paths for
Liferay's Bookmarks application:

\begin{itemize}
\tightlist
\item
  \texttt{/bookmarks-api/src/main/java/com/liferay/bookmarks}
\item
  \texttt{/bookmarks-service/src/main/java/com/liferay/bookmarks}
\end{itemize}

The \texttt{bookmarks-api} module's interfaces define the Bookmarks
application API. The \texttt{*-api} module interfaces define the
application's persistence layer, service layer, and model layer.
Whenever you compile and deploy the \texttt{*-api} module, all its
classes and interfaces are packaged in a \texttt{.jar} file called
\texttt{PROJECT\_NAME-api.jar} in the module's \texttt{build/libs}
folder. Deploying this JAR to Liferay \emph{defines} the API as OSGi
services.

The \texttt{bookmarks-service} module classes implement the
\texttt{bookmarks-api} module interfaces. The \texttt{*-service} module
provides the OSGi service implementations to deploy to Liferay's OSGi
framework.

Next, examine the classes and interfaces generated for the entities you
specified. Similar classes are generated for each entity, depending on
how each entity is specified in the \texttt{service.xml}. Here are the
three types of customizable classes:

\begin{itemize}
\tightlist
\item
  \texttt{*LocalServiceImpl}
\item
  \texttt{*ServiceImpl}
\item
  \texttt{*Impl}
\end{itemize}

The \texttt{*} represents the entity name in the classes listed above.

Here are the persistence, service, and model classes:

\begin{itemize}
\tightlist
\item
  Persistence

  \begin{itemize}
  \tightlist
  \item
    \texttt{{[}ENTITY\_NAME{]}Persistence}: Persistence interface that
    defines CRUD methods for the entity such as \texttt{create},
    \texttt{remove}, \texttt{countAll}, \texttt{find}, \texttt{findAll},
    etc.
  \item
    \texttt{{[}ENTITY\_NAME{]}PersistenceImpl}: Persistence
    implementation class that implements
    \texttt{{[}ENTITY\_NAME{]}Persistence}.
  \item
    \texttt{{[}ENTITY\_NAME{]}Util}: Persistence utility class that
    wraps \texttt{{[}ENTITY\_NAME{]}PersistenceImpl} and provides direct
    access to the database for CRUD operations. This utility should only
    be used by the service layer; in your portlet classes, use the
    \texttt{{[}ENTITY\_NAME{]}} class by referencing it with the
    \href{/docs/7-1/tutorials/-/knowledge_base/t/osgi-services-and-dependency-injection-with-declarative-services}{\texttt{@Reference}
    annotation}.
  \end{itemize}

  \begin{figure}
  \centering
  \includegraphics{./images/service-builder-persistence-diagram.png}
  \caption{Service Builder generates these persistence classes and
  interfaces for an example entity called \emph{Event}. You shouldn't
  (and you won't need to) customize any of these classes or interfaces.}
  \end{figure}
\item
  Local Service (generated for an entity only if the entity's
  \texttt{local-service} attribute is set to \texttt{true} in
  \texttt{service.xml})

  \begin{itemize}
  \tightlist
  \item
    \texttt{{[}ENTITY\_NAME{]}LocalService}: Local service interface.
  \item
    \texttt{{[}ENTITY\_NAME{]}LocalServiceImpl} (\textbf{LOCAL SERVICE
    IMPLEMENTATION}): Local service implementation. This is the only
    class in the local service that you should modify manually. You can
    add custom business logic here. For any methods added here, Service
    Builder adds corresponding methods to the
    \texttt{{[}ENTITY\_NAME{]}LocalService} interface the next time you
    run it.
  \item
    \texttt{{[}ENTITY\_NAME{]}LocalServiceBaseImpl}: Local service base
    implementation. This is an abstract class. Service Builder injects a
    number of instances of various service and persistence classes into
    this class. \texttt{@abstract}
  \item
    \texttt{{[}ENTITY\_NAME{]}LocalServiceUtil}: Local service utility
    class which wraps \texttt{{[}ENTITY\_NAME{]}LocalServiceImpl}. This
    class is generated for backwards compatibility purposes only. Use
    the \texttt{*LocalService} class by referencing it with the
    \href{/docs/7-1/tutorials/-/knowledge_base/t/osgi-services-and-dependency-injection-with-declarative-services}{\texttt{@Reference}
    annotation}.
  \item
    \texttt{{[}ENTITY\_NAME{]}LocalServiceWrapper}: Local service
    wrapper which implements \texttt{{[}ENTITY\_NAME{]}LocalService}.
    This class is designed to be extended and it lets you
    \href{/docs/7-1/tutorials/-/knowledge_base/t/customizing-liferay-services-service-wrappers}{customize
    the entity's local services}.
  \end{itemize}

  \begin{figure}
  \centering
  \includegraphics{./images/service-builder-service-diagram.png}
  \caption{Service Builder generates these service classes and
  interfaces. Only the {[}ENTITY\_NAME{]}LocalServiceImpl (e.g.,
  EventLocalServiceImpl for the Event entity) allows custom methods to
  be added to the service layer.}
  \end{figure}
\item
  Remote Service (generated for an entity only if an entity's
  \texttt{remote-service} attribute is \emph{not} set to \texttt{false}
  in \texttt{service.xml})

  \begin{itemize}
  \tightlist
  \item
    \texttt{{[}ENTITY\_NAME{]}Service}: Remote service interface.
  \item
    \texttt{{[}ENTITY\_NAME{]}ServiceImpl} (\textbf{REMOTE SERVICE
    IMPLEMENTATION}): Remote service implementation. This is the only
    class in the remote service that you should modify manually. Here,
    you can write code that adds additional security checks and invokes
    the local services. For any custom methods added here, Service
    Builder adds corresponding methods to the
    \texttt{{[}ENTITY\_NAME{]}Service} interface the next time you run
    it.
  \item
    \texttt{{[}ENTITY\_NAME{]}ServiceBaseImpl}: Remote service base
    implementation. This is an abstract class. \texttt{@abstract}
  \item
    \texttt{{[}ENTITY\_NAME{]}ServiceUtil}: Remote service utility class
    which wraps \texttt{{[}ENTITY\_NAME{]}ServiceImpl}. This class is
    generated for backwards compatibility purposes only. Use the
    \texttt{*Service} class by referencing it with the
    \href{/docs/7-1/tutorials/-/knowledge_base/t/osgi-services-and-dependency-injection-with-declarative-services}{\texttt{@Reference}
    annotation}.
  \item
    \texttt{{[}ENTITY\_NAME{]}ServiceWrapper}: Remote service wrapper
    which implements \texttt{{[}ENTITY\_NAME{]}Service}. This class is
    designed to be extended and it lets you
    \href{/docs/7-1/tutorials/-/knowledge_base/t/customizing-liferay-services-service-wrappers}{customize
    the entity's remote services}.
  \item
    \texttt{{[}ENTITY\_NAME{]}ServiceSoap}: SOAP utility which the
    remote \texttt{{[}ENTITY\_NAME{]}ServiceUtil} remote service utility
    can access.
  \item
    \texttt{{[}ENTITY\_NAME{]}Soap}: SOAP model, similar to
    \texttt{{[}ENTITY\_NAME{]}ModelImpl}.
    \texttt{{[}ENTITY\_NAME{]}Soap} is serializable; it does not
    implement \texttt{{[}ENTITY\_NAME{]}}.
  \end{itemize}
\item
  Model

  \begin{itemize}
  \tightlist
  \item
    \texttt{{[}ENTITY\_NAME{]}Model}: Base model interface. This
    interface and its \texttt{{[}ENTITY\_NAME{]}ModelImpl}
    implementation serve only as a container for the default property
    accessors Service Builder generates. Any helper methods and all
    application logic should be added to
    \texttt{{[}ENTITY\_NAME{]}Impl}.
  \item
    \texttt{{[}ENTITY\_NAME{]}ModelImpl}: Base model implementation.
  \item
    \texttt{{[}ENTITY\_NAME{]}}: \texttt{{[}ENTITY\_NAME{]}} model
    interface which extends \texttt{{[}ENTITY\_NAME{]}Model}.
  \item
    \texttt{{[}ENTITY\_NAME{]}Impl}: (\textbf{MODEL IMPLEMENTATION})
    Model implementation. You can use this class to add helper methods
    and application logic to your model. If you don't add any helper
    methods or application logic, only the auto-generated field getters
    and setters are available. Whenever you add custom methods to this
    class, Service Builder adds corresponding methods to the
    \texttt{{[}ENTITY\_NAME{]}} interface the next time you run it.
  \item
    \texttt{{[}ENTITY\_NAME{]}Wrapper}: Wrapper, wraps
    \texttt{{[}ENTITY\_NAME{]}}. This class is designed to be extended
    and it lets you
    \href{/docs/7-1/tutorials/-/knowledge_base/t/customizing-liferay-services-service-wrappers}{customize
    the entity}.
  \end{itemize}

  \begin{figure}
  \centering
  \includegraphics{./images/service-builder-model-diagram.png}
  \caption{Service Builder generates these model classes and interfaces.
  Only \texttt{{[}ENTITY\_NAME{]}Impl} (e.g., EventImpl for the Event
  entity) allows custom methods to be added to the service layer.}
  \end{figure}
\end{itemize}

\noindent\hrulefill

\textbf{Note:} \texttt{*Util} classes are generated for backwards
compatibility purposes only. Your module applications should avoid
calling the util classes. Use the non-util classes instead--you can
reference them using the
\href{/docs/7-1/tutorials/-/knowledge_base/t/osgi-services-and-dependency-injection-with-declarative-services}{\texttt{@Reference}
annotation}.

\noindent\hrulefill

Each file that Service Builder generates is assembled from an associated
FreeMarker template. The FreeMarker templates are in the
\href{https://repository.liferay.com/nexus/content/repositories/liferay-public-releases/com/liferay/com.liferay.portal.tools.service.builder/}{\texttt{com.liferay.portal.tools.service.builder}
module's}
\texttt{/com/liferay/portal/tools/service/builder/dependencies/} folder.
For example, Service Builder uses the \texttt{service\_impl.ftl}
template to generate the \texttt{*ServiceImpl.java} classes.

You can modify any \texttt{*Impl} class Service Builder generates. The
most common are \texttt{*LocalServiceImpl}, \texttt{*ServiceImpl} and
\texttt{*Impl}. If you manually modify the other classes, Service
Builder overwrites the changes the next time you run it. Whenever you
add methods to, remove methods from, or change a method signature of a
\texttt{*LocalServiceImpl} class, \texttt{*ServiceImpl} class, or
\texttt{*Impl} class, you should run Service Builder again to regenerate
the affected interfaces and the service JAR.

Congratulations! You've generated your application's initial model,
persistence, and service layers and you understand the generated code.

\textbf{Related Topics}

\href{/docs/7-1/tutorials/-/knowledge_base/t/what-is-service-builder}{What
is Service Builder}

\href{/docs/7-1/tutorials/-/knowledge_base/t/running-service-builder}{Running
Service Builder}

\href{/docs/7-1/tutorials/-/knowledge_base/t/understanding-servicecontext}{Understanding
Service Context}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-local-services}{Creating
Local Services}

\section{Iterative Development}\label{iterative-development}

As you develop an application, you might need to add fields to your
database. This is a normal process of iterative development: you get an
idea for a new feature, or it's suggested to you, and that feature
requires additional data in the database. \textbf{New fields added to
\texttt{service.xml} are not automatically added to the database.} To
add the fields, you must do one of two things:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Write an
  \href{/docs/7-1/tutorials/-/knowledge_base/t/creating-an-upgrade-process-for-your-app}{upgrade
  process} to modify the tables and preserve the data, or
\item
  Run the \texttt{cleanServiceBuilder}
  \href{/docs/7-1/reference/-/knowledge_base/r/db-support-gradle-plugin}{Gradle
  task} (also supported on Maven and Ant), which drops your tables so
  they get re-created the next time your app is deployed. The
  \href{/docs/7-1/reference/-/knowledge_base/r/db-support-plugin}{Maven
  DB Support Plugin} reference article explains how to run this command
  from a Maven project.
\end{enumerate}

Use the first option if you have a released application and you must
preserve user data. Use the second option if you're adding new columns
during development.

\subsection{Related Topics}\label{related-topics-60}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-an-upgrade-process-for-your-app}{Upgrade
Processes}

\href{/docs/7-1/reference/-/knowledge_base/r/db-support-gradle-plugin}{Gradle
DB Support Plugin}

\href{/docs/7-1/reference/-/knowledge_base/r/db-support-plugin}{Maven DB
Support Plugin}

\section{Understanding
ServiceContext}\label{understanding-servicecontext}

The \texttt{ServiceContext} class holds contextual information for a
service. It aggregates information necessary for features used
throughout Liferay's portlets, such as permissions, tagging,
categorization, and more. This tutorial covers the following
\texttt{ServiceContext} class topics:

\begin{itemize}
\tightlist
\item
  \hyperref[service-context-fields]{Service Context Fields}
\item
  \hyperref[creating-and-populating-a-service-context]{Creating and
  Populating a Service Context in Java}
\item
  \hyperref[creating-and-populating-a-service-context-in-javascript]{Creating
  and Populating a Service Context in JavaScript}
\item
  \hyperref[accessing-service-context-data]{Accessing Service Context
  Data}
\end{itemize}

The \texttt{ServiceContext} fields are first.

\subsection{Service Context Fields}\label{service-context-fields}

The \texttt{ServiceContext} class has many fields. The
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/service/ServiceContext.html}{\texttt{ServiceContext}
class Javadoc} describes them.

Here's a categorical listing of some commonly used Service Context
fields:

\begin{itemize}
\tightlist
\item
  Actions:

  \begin{itemize}
  \tightlist
  \item
    \texttt{\_command}
  \item
    \texttt{\_workflowAction}
  \end{itemize}
\item
  Attributes:

  \begin{itemize}
  \tightlist
  \item
    \texttt{\_attributes}
  \item
    \texttt{\_expandoBridgeAttributes}
  \end{itemize}
\item
  Classification:

  \begin{itemize}
  \tightlist
  \item
    \texttt{\_assetCategoryIds}
  \item
    \texttt{\_assetTagNames}
  \end{itemize}
\item
  Exception

  \begin{itemize}
  \tightlist
  \item
    \texttt{\_failOnPortalException}
  \end{itemize}
\item
  IDs and Scope:

  \begin{itemize}
  \tightlist
  \item
    \texttt{\_companyId}
  \item
    \texttt{\_portletPreferencesIds}
  \item
    \texttt{\_plid}
  \item
    \texttt{\_scopeGroupId}
  \item
    \texttt{\_userId}
  \item
    \texttt{\_uuid}
  \end{itemize}
\item
  Language:

  \begin{itemize}
  \tightlist
  \item
    \texttt{\_languageId}
  \end{itemize}
\item
  Miscellaneous:

  \begin{itemize}
  \tightlist
  \item
    \texttt{\_headers}
  \item
    \texttt{\_signedIn}
  \end{itemize}
\item
  Permissions:

  \begin{itemize}
  \tightlist
  \item
    \texttt{\_addGroupPermissions}
  \item
    \texttt{\_addGuestPermissions}
  \item
    \texttt{\_deriveDefaultPermissions}
  \item
    \texttt{\_modelPermissions}
  \end{itemize}
\item
  Request

  \begin{itemize}
  \tightlist
  \item
    \texttt{\_request}
  \end{itemize}
\item
  Resources:

  \begin{itemize}
  \tightlist
  \item
    \texttt{\_assetEntryVisible}
  \item
    \texttt{\_assetLinkEntryIds}
  \item
    \texttt{\_assetPriority}
  \item
    \texttt{\_createDate}
  \item
    \texttt{\_formDate}
  \item
    \texttt{\_indexingEnabled}
  \item
    \texttt{\_modifiedDate}
  \item
    \texttt{\_timeZone}
  \end{itemize}
\item
  URLs, paths and addresses:

  \begin{itemize}
  \tightlist
  \item
    \texttt{\_currentURL}
  \item
    \texttt{\_layoutFullURL}
  \item
    \texttt{\_layoutURL}
  \item
    \texttt{\_pathMain}
  \item
    \texttt{\_pathFriendlyURLPrivateGroup}
  \item
    \texttt{\_pathFriendlyURLPrivateUser}
  \item
    \texttt{\_pathFriendlyURLPublic}
  \item
    \texttt{\_portalURL}
  \item
    \texttt{\_remoteAddr}
  \item
    \texttt{\_remoteHost}
  \item
    \texttt{\_userDisplayURL}
  \end{itemize}
\end{itemize}

Are you wondering how the \texttt{ServiceContext} fields get populated?
Good! You'll learn about that next.

\subsection{Creating and Populating a Service
Context}\label{creating-and-populating-a-service-context}

Although all the \texttt{ServiceContext} class fields are optional,
services that store data with scope must at least specify the scope
group ID. Here's an example of creating a \texttt{ServiceContext}
instance and passing it as a parameter to a Liferay service API:

\begin{verbatim}
ServiceContext serviceContext = new ServiceContext();
serviceContext.setScopeGroupId(myGroupId);

...

_blogsEntryService.addEntry(..., serviceContext);
\end{verbatim}

If you invoke the service from a servlet, a Struts action, or any other
front-end class with access to the \texttt{PortletRequest}, use one of
the \texttt{ServiceContextFactory.getInstance(...)} methods. These
methods create a \texttt{ServiceContext} object from the request and
automatically populate its fields with all the values specified in the
request. The above example looks different if you invoke the service
from a servlet:

\begin{verbatim}
ServiceContext serviceContext =
    ServiceContextFactory.getInstance(BlogsEntry.class.getName(), portletRequest);

...

_blogsEntryService.addEntry(..., serviceContext);
\end{verbatim}

You can see an example of populating a \texttt{ServiceContext} with
information from a request object in the code of the
\texttt{ServiceContextFactory.getInstance(...)} methods. The methods
demonstrate how to set parameters like \emph{scope group ID},
\emph{company ID}, \emph{language ID}, and more. They also demonstrate
how to access and populate more complex context parameters like
\emph{tags}, \emph{categories}, \emph{asset links}, \emph{headers}, and
the \emph{attributes} parameter. By calling
\texttt{ServiceContextFactory.getInstance(String\ className,\ PortletRequest\ portletRequest)},
you can assure that your Expando bridge attributes are set on the
\texttt{ServiceContext}. Expandos are the back-end implementation of
custom fields for entities in Liferay.

\subsection{Creating and Populating a Service Context in
JavaScript}\label{creating-and-populating-a-service-context-in-javascript}

Liferay's API can be invoked in languages other than Java. Some methods
require or allow a \texttt{ServiceContext} parameter. If you're invoking
such a method via Liferay's JSON web services, you might want to create
and populate a \texttt{ServiceContext} object in JavaScript. Creating a
\texttt{ServiceContext} object in JavaScript is no different from
creating any other object in JavaScript.

Before examining a JSON web service invocation that uses a
\texttt{ServiceContext} object, it helps to see a simple JSON web
service example in JavaScript:

\begin{verbatim}
Liferay.Service(
    '/user/get-user-by-email-address`,
    {
        companyId: Liferay.ThemeDisplay.getCompanyId(),
        emailAddress: 'test@example.com`
    },
    function(obj) {
        console.log(obj);
    }
);
\end{verbatim}

If you run this code, the \emph{test@example.com} user (JSON object) is
logged to the JavaScript console.

The \texttt{Liferay.Service(...)} function takes three arguments:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  A string representing the service being invoked
\item
  A parameters object
\item
  A callback function
\end{enumerate}

The callback function takes the result of the service invocation as an
argument.

The Liferay JSON web services page (its URL is
\url{localhost:8080/api/jsonws} if you're running Liferay locally on
port 8080) generates example code for invoking web services. To see the
generated code for a particular service, click on the name of the
service, enter the required parameters, and click \emph{Invoke}. The
JSON result of your service invocation appears. There are multiple ways
to invoke Liferay's JSON web services: click on \emph{JavaScript
Example} to see how to invoke the web service via JavaScript, click on
\emph{curl Example} to see how to invoke the web service via curl, or
click on \emph{URL example} to see how to invoke the web service via a
URL.

\begin{figure}
\centering
\includegraphics{./images/jsonws-simple-example.png}
\caption{When you invoke a service from Liferay's JSON web services
page, you can view the result of your service invocation as well as
example code for invoking the service via JavaScript, curl, or URL.}
\end{figure}

To learn more about Liferay's JSON web services, see the
\href{/docs/7-1/tutorials/-/knowledge_base/t/registering-json-web-services}{JSON
Web Services} tutorial.

Next, you'll learn how to access information from a
\texttt{ServiceContext} object.

\subsection{Accessing Service Context
Data}\label{accessing-service-context-data}

In this section, you'll find code snippets from
\texttt{BlogsEntryLocalServiceImpl.addEntry(...,\ ServiceContext)}. This
code demonstrates how to access information from a
\texttt{ServiceContext} and provides an example of how the context
information can be used.

As mentioned above, services for entities with scope must get a scope
group ID from the \texttt{ServiceContext} object. This is true for the
Blogs entry service because the scope group ID provides the scope of the
Blogs entry (the entity being persisted). For the Blogs entry, the scope
group ID is used in the following way:

\begin{itemize}
\tightlist
\item
  It's used as the \texttt{groupId} for the \texttt{BlogsEntry} entity.
\item
  It's used to generate a unique URL for the blog entry.
\item
  It's used to set the scope for comments on the blog entry.
\end{itemize}

Here are the corresponding code snippets:

\begin{verbatim}
long groupId = serviceContext.getScopeGroupId();

...

entry.setGroupId(groupId);

...

entry.setUrlTitle(getUniqueUrlTitle(entryId, groupId, title));

...

// Message boards

if (PropsValues.BLOGS_ENTRY_COMMENTS_ENABLED) {
    mbMessageLocalService.addDiscussionMessage(
        userId, entry.getUserName(), groupId,
        BlogsEntry.class.getName(), entryId,
        WorkflowConstants.ACTION_PUBLISH);
}
\end{verbatim}

Can \texttt{ServiceContext} be used to access the UUID of the blog
entry? Absolutely! Can you use \texttt{ServiceContext} to set the time
the blog entry was added? You sure can. See here:

\begin{verbatim}
entry.setUuid(serviceContext.getUuid());
...
entry.setCreateDate(serviceContext.getCreateDate(now));
\end{verbatim}

Can \texttt{ServiceContext} be used in setting permissions on resources?
You bet! When adding a blog entry, you can add new permissions or apply
existing permissions for the entry, like this:

\begin{verbatim}
// Resources

if (serviceContext.isAddGroupPermissions() ||
    serviceContext.isAddGuestPermissions()) {

    addEntryResources(
        entry, serviceContext.isAddGroupPermissions(),
        serviceContext.isAddGuestPermissions());
}
else {
    addEntryResources(
        entry, serviceContext.getGroupPermissions(),
        serviceContext.getGuestPermissions());
}
\end{verbatim}

\texttt{ServiceContext} helps apply categories, tag names, and the link
entry IDs to asset entries too. Asset links are the back-end term for
related assets in Liferay.

\begin{verbatim}
// Asset

updateAsset(
    userId, entry, serviceContext.getAssetCategoryIds(),
    serviceContext.getAssetTagNames(),
    serviceContext.getAssetLinkEntryIds());
\end{verbatim}

Does \texttt{ServiceContext} also play a role in starting a workflow
instance for the blogs entry? Must you ask?

\begin{verbatim}
// Workflow

if ((trackbacks != null) && (trackbacks.length > 0)) {
    serviceContext.setAttribute("trackbacks", trackbacks);
}
else {
    serviceContext.setAttribute("trackbacks", null);
}

_workflowHandlerRegistry.startWorkflowInstance(
    user.getCompanyId(), groupId, userId, BlogsEntry.class.getName(),
    entry.getEntryId(), entry, serviceContext);
\end{verbatim}

The snippet above also demonstrates the \texttt{trackbacks} attribute, a
standard attribute for the blogs entry service. There may be cases where
you need to pass in custom attributes to your blogs entry service. Use
Expando attributes to carry custom attributes along in your
\texttt{ServiceContext}. Expando attributes are set on the added blogs
entry like this:

\begin{verbatim}
entry.setExpandoBridgeAttributes(serviceContext);
\end{verbatim}

You can see that the \texttt{ServiceContext} can be used to transfer
lots of useful information for your services. Understanding how
\texttt{ServiceContext} is used in Liferay helps you determine when and
how to use \texttt{ServiceContext} in your own Liferay application
development.

\subsection{Related Topics}\label{related-topics-61}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-local-services}{Creating
Local Services}

\href{/docs/7-1/tutorials/-/knowledge_base/t/invoking-local-services}{Invoking
Local Services}

\section{Customizing Model Entities With Model
Hints}\label{customizing-model-entities-with-model-hints}

Once you've used Service Builder to define model entities, you may want
to further refine how users enter that data. For example, model hints
can define a calendar field where only future dates should be
selectable. Model hints provide a single place to specify entity data
restrictions and other formatting.

You define model hints in a file called
\texttt{portlet-model-hints.xml}. If your project has an API module and
a service module like the
\href{/docs/7-1/reference/-/knowledge_base/r/using-the-service-builder-template}{Service
Builder project template}, \texttt{portlet-model-hints.xml} goes in the
service module's \texttt{src/main/resources/META-INF} folder. For
example, in Liferay's Bookmarks application, the
\texttt{portlet-model-hints.xml} file is in the
\texttt{bookmarks-service/src/main/resources/META-INF/} folder.

Model hints define two things:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  How entities are presented to users
\item
  The size of database columns
\end{enumerate}

As Liferay renders your form fields, it customizes the form's input
fields based your configuration.

\noindent\hrulefill

\textbf{Note:} Service Builder generates a number of XML configuration
files in your service module's \texttt{src/main/resources/META-INF}
folder. Service Builder uses most of these files to manage Spring and
Hibernate configurations. Don't modify the Spring or Hibernate
configuration files; changes to them are overwritten when Service
Builder runs. You can, however, safely edit the
\texttt{portlet-model-hints.xml} file.

\noindent\hrulefill

As an example, consider the
\href{https://repository.liferay.com/nexus/content/repositories/liferay-public-releases/com/liferay/com.liferay.bookmarks.service/}{Bookmarks
app service module's} model hints file:

\begin{verbatim}
<?xml version="1.0"?>

<model-hints>
    <model name="com.liferay.bookmarks.model.BookmarksEntry">
        <field name="uuid" type="String" />
        <field name="entryId" type="long" />
        <field name="groupId" type="long" />
        <field name="companyId" type="long" />
        <field name="userId" type="long" />
        <field name="userName" type="String" />
        <field name="createDate" type="Date" />
        <field name="modifiedDate" type="Date" />
        <field name="folderId" type="long" />
        <field name="treePath" type="String">
            <hint name="max-length">4000</hint>
        </field>
        <field name="name" type="String">
            <hint name="max-length">255</hint>
        </field>
        <field name="url" type="String">
            <hint-collection name="URL" />
            <validator name="required" />
            <validator name="url" />
        </field>
        <field name="description" type="String">
            <hint-collection name="TEXTAREA" />
        </field>
        <field name="visits" type="int" />
        <field name="priority" type="int">
            <hint name="display-width">20</hint>
        </field>
        <field name="lastPublishDate" type="Date" />
        <field name="status" type="int" />
        <field name="statusByUserId" type="long" />
        <field name="statusByUserName" type="String" />
        <field name="statusDate" type="Date" />
    </model>
    <model name="com.liferay.bookmarks.model.BookmarksFolder">
        ...
    </model>
</model-hints>
\end{verbatim}

The root-level element is \texttt{model-hints}. Model entities are
represented by \texttt{model} sub-elements of the \texttt{model-hints}
element. Each \texttt{model} element must have a \texttt{name} attribute
specifying the fully-qualified class name. Models have \texttt{field}
elements representing their entity's columns. Lastly, \texttt{field}
elements must have a name and a type. Each \texttt{field} element's name
and type maps to the name and type specified for the entity's column in
the service module's \texttt{service.xml} file. Service Builder
generates all these elements for you, based on the \texttt{service.xml}.

To add hints to a field, add a \texttt{hint} child element. For example,
you can add a \texttt{display-width\ hint} to specify the pixel width to
use in displaying the field. The default pixel width is \texttt{350}. To
show a \texttt{String} field with 50 pixels, you could nest a
\texttt{hint} element named \texttt{display-width} and give it a value
of \texttt{50}.

To see the effect of a hint on a field,
\href{/docs/7-1/tutorials/-/knowledge_base/t/running-service-builder}{run
Service Builder} again and
\href{/docs/7-1/tutorials/-/knowledge_base/t/starting-module-development\#building-and-deploying-a-module}{redeploy
your module}. Note that changing \texttt{display-width} doesn't limit
the number of characters a user can enter into the \texttt{name} field;
it only controls the field's width in the AlloyUI input form.

To configure the maximum size of a model field's database column (i.e.,
the maximum number of characters that can be saved for the field), use
the \texttt{max-length} hint. The default \texttt{max-length} value is
\texttt{75} characters. If you want the \texttt{name} field to persist
up to 100 characters, add a \texttt{max-length} hint to that field:

\begin{verbatim}
<field name="name" type="String">
    <hint name="display-width">50</hint>
    <hint name="max-length">100</hint>
</field>
\end{verbatim}

Remember to run Service Builder and redeploy your project after updating
the \texttt{portlet-model-hints.xml} file.

\subsection{Model Hint Types}\label{model-hint-types}

So far, you've seen a few different hints. The following table describes
the portlet model hints available for use.

\textbf{Model Hint Values and Descriptions}

\noindent\hrulefill

\begin{verbatim}
  Name       | Value Type | Description | Default |
\end{verbatim}

\texttt{auto-escape} \textbar{} boolean \textbar{} sets whether text
values should be escaped via \texttt{HtmlUtil.escape} \textbar{} true
\textbar{} \texttt{autoSize} \textbar{} boolean \textbar{} displays the
field in a for scrollable text area \textbar{} false \textbar{}
\texttt{day-nullable} \textbar{} boolean \textbar{} allows the day to be
null in a date field \textbar{} false \textbar{} \texttt{default-value}
\textbar{} String \textbar{} sets the default value of the form field
rendered using the aui taglib \textbar{} (empty String) \textbar{}
\texttt{display-height} \textbar{} integer \textbar{} sets the display
height of the form field rendered using the aui taglib \textbar{} 15
\textbar{} \texttt{display-width} \textbar{} integer \textbar{} sets the
display width of the form field rendered using the aui taglib \textbar{}
350 \textbar{} \texttt{editor} \textbar{} boolean \textbar{} sets
whether to provide an editor for the input \textbar{} false \textbar{}
\texttt{max-length} \textbar{} integer \textbar{} sets the maximum
column size for SQL file generation \textbar{} 75 \textbar{}
\texttt{month-nullable} \textbar{} boolean \textbar{} allows the month
to be null in a date field \textbar{} false \textbar{} \texttt{secret}
\textbar{} boolean \textbar{} sets whether to hide the characters input
by the user \textbar{} false \textbar{} \texttt{show-time} \textbar{}
boolean \textbar{} sets whether to show the time along with the date
\textbar{} true \textbar{} \texttt{upper-case} \textbar{} boolean
\textbar{} converts all characters to upper case \textbar{} false
\textbar{} \texttt{year-nullable} \textbar{} boolean \textbar{} allows a
date field's year to be null \textbar{} false \textbar{}
\texttt{year-range-delta} \textbar{} integer \textbar{} specifies the
number of years to display from today's date in a date field rendered
with the aui taglib \textbar{} 5 \textbar{} \texttt{year-range-future}
\textbar{} boolean \textbar{} sets whether to include future dates
\textbar{} true \textbar{} \texttt{year-range-past} \textbar{} boolean
\textbar{} sets whether to include past dates \textbar{} true \textbar{}

\noindent\hrulefill

\noindent\hrulefill

\textbf{Note}: The aui taglib is fully supported and not related to
AlloyUI (the JavaScript library) that's deprecated.

\noindent\hrulefill

\noindent\hrulefill

\textbf{Note}: You can use a mix of Clay and aui tags in a form. Model
hints, however, affect aui tags only.

\noindent\hrulefill

Note that Liferay has its own model hints
file--\texttt{portal-model-hints.xml}. It's in
\texttt{portal-impl.jar}'s \texttt{META-INF} folder. This file contains
many hint examples, so you can reference it when creating
\texttt{portlet-model-hints.xml} files.

\subsection{Default Hints}\label{default-hints}

You can use the \texttt{default-hints} element to define a list of hints
to apply to every field of a model. For example, adding the following
element inside a model element applies a \texttt{display-width} of 300
pixels to each field:

\begin{verbatim}
<default-hints>
    <hint name="display-width">300</hint>
</default-hints>
\end{verbatim}

\subsection{Hint Collections}\label{hint-collections}

You can define \texttt{hint-collection} elements inside the
\texttt{model-hints} root-level element to define a list of hints to
apply together. A hint collection must have a name. For example,
Liferay's \texttt{portal-model-hints.xml} defines the following hint
collections:

\begin{verbatim}
<hint-collection name="CLOB">
    <hint name="max-length">2000000</hint>
</hint-collection>
<hint-collection name="EDITOR">
    <hint name="editor">true</hint>
    <hint name="max-length">2000000</hint>
</hint-collection>
<hint-collection name="EMAIL-ADDRESS">
    <hint name="max-length">254</hint>
</hint-collection>
<hint-collection name="HOSTNAME">
    <hint name="max-length">200</hint>
</hint-collection>
<hint-collection name="SEARCHABLE-DATE">
    <hint name="month-nullable">true</hint>
    <hint name="day-nullable">true</hint>
    <hint name="year-nullable">true</hint>
    <hint name="show-time">false</hint>
</hint-collection>
<hint-collection name="TEXTAREA">
    <hint name="display-height">105</hint>
    <hint name="display-width">500</hint>
    <hint name="max-length">4000</hint>
</hint-collection>
<hint-collection name="URL">
    <hint name="max-length">4000</hint>
</hint-collection>
\end{verbatim}

You can apply a hint collection to a model field by referencing the hint
collection's name. For example, if you define a \texttt{SEARCHABLE-DATE}
collection like the one above in your \texttt{model-hints} element, you
can apply it to your model's date field by using a
\texttt{hint-collection} element that references the collection by its
name:

\begin{verbatim}
<field name="date" type="Date">
    <hint-collection name="SEARCHABLE-DATE" />
</field>
\end{verbatim}

Suppose you want to use a couple of model hints in your project. Start
by providing users with an editor for filling in their comment fields.
To apply the same hint to multiple entities, define it as a hint
collection. Then reference the hint collection in each entity.

To define a hint collection, add a \texttt{hint-collection} element
inside the \texttt{model-hints} root element in your
\texttt{portlet-model-hints.xml} file. For example:

\begin{verbatim}
<hint-collection name="COMMENT-TEXTAREA">
    <hint name="display-height">105</hint>
    <hint name="display-width">500</hint>
    <hint name="max-length">4000</hint>
</hint-collection>
\end{verbatim}

To reference a hint collection for a specific field, add the
\texttt{hint-collection} element inside the field's \texttt{field}
element:

\begin{verbatim}
<field name="comment" type="String">
    <hint-collection name="COMMENT-TEXTAREA" />
</field>
\end{verbatim}

After defining hint collections and adding hint collection references,
rebuild your services using Service Builder, redeploy your project, and
check that the hints defined in your hint collection have taken effect.

Nice work! You've learned the art of persuasion through Liferay's model
hints. Now you can not only influence how your model's input fields are
displayed, but you can also can set its database table column sizes. You
can organize hints, insert individual hints directly into your fields,
apply a set of default hints to all of a model's fields, or define
collections of hints to apply at either of those scopes. You've picked
up the ``hints'' on how Liferay model hints specify how to display app
data!

\section{Configuring
service.properties}\label{configuring-service.properties}

This tutorial explains how to use and edit the
\texttt{service.properties} file. It also tells you about the properties
and how to set them to fit your needs.

Service Builder generates a \texttt{service.properties} file in your
\texttt{*-service} module's \texttt{src/main/resources} folder. Liferay
DXP uses this file's properties to alter your service's database schema.
You should not modify this file directly, but rather make any necessary
property overrides in a \texttt{service-ext.properties} file in that
same folder.

Here are some of the properties the \texttt{service.properties} file
includes:

\begin{itemize}
\tightlist
\item
  \texttt{build.namespace}: This is the
  \href{/docs/7-1/tutorials/-/knowledge_base/t/defining-an-object-relational-map-with-service-builder}{namespace
  you defined in your \texttt{service.xml}}. Liferay distinguishes
  different modules from each other using their namespaces.
\item
  \texttt{build.number}: Liferay distinguishes your module's different
  Service Builder builds. Each time you deploy a distinct Service
  Builder build to Liferay, Liferay increments this number.
\item
  \texttt{build.date}: This is the time of your module's latest Service
  Builder build.
\item
  \texttt{include-and-override}: The default value of this property
  defines \texttt{service-ext.properties} as an override file for
  \texttt{service.properties}.
\end{itemize}

\noindent\hrulefill

\textbf{Note}: In Liferay Portal 6.x Service Builder portlets, the
\texttt{build.auto.upgrade} property in \texttt{service.properties}
applies Liferay Service schema changes upon rebuilding services and
redeploying the portlets. As of 7.0, this property is deprecated.

The Build Auto Upgrade feature is now different and is set in a global
property \texttt{schema.module.build.auto.upgrade} in the file
\texttt{{[}Liferay\_Home{]}/portal-developer.properties}. To learn more,
see the tutorial
\href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-data-schemas-in-development}{Upgrading
Data Schemas in Development}.

\noindent\hrulefill

Awesome! You now have all the tools necessary to set up your own
\texttt{service-ext.properties} file.

\subsection{Related Topics}\label{related-topics-62}

\href{/docs/7-1/tutorials/-/knowledge_base/t/what-is-service-builder}{What
is Service Builder?}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-local-services}{Creating
Local Services}

\section{Connecting Service Builder to External
Databases}\label{connecting-service-builder-to-external-databases}

Sometimes you want to use a database other than Liferay DXP's. To do
this, its data source must be defined in \texttt{portal-ext.properties}
or configured as a JNDI data source on the app server. This tutorial
shows how to connect
\href{/docs/7-1/tutorials/-/knowledge_base/t/service-builder}{Service
Builder} to a data source. Here's how:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \hyperref[step-1-specify-the-database-and-data-source-in-your-service-xml]{Specify
  the database and data source in your \texttt{service.xml}.}
\item
  \hyperref[step-2-create-the-database-manually]{Create the Database
  Manually}
\item
  \hyperref[step-3-define-the-data-source]{Define the Data Source}
\item
  \hyperref[step-4-create-a-spring-bean-that-points-to-the-data-source]{Create
  a Spring bean that points to the data source.}
\item
  \hyperref[step-5-set-your-entitys-data-source-to-the-liferaydatasource-alias]{Set
  your entity's data source to the \texttt{liferayDataSource} alias.}
\item
  \hyperref[step-6-run-service-builder]{Run Service Builder.}
\end{enumerate}

\noindent\hrulefill

\textbf{Note}: All entities defined in a Service Builder module's
\texttt{service.xml} file are bound to the same data source. Binding
different entities to different data sources requires defining the
entities in separate Service Builder modules and configuring each of the
modules to use a different data source.

\noindent\hrulefill

\subsection{\texorpdfstring{Step 1: Specify Your Database and a Data
Source Name in Your
\texttt{service.xml}}{Step 1: Specify Your Database and a Data Source Name in Your service.xml}}\label{step-1-specify-your-database-and-a-data-source-name-in-your-service.xml}

In your \texttt{service.xml} file, specify the same arbitrary data
source name for all of the entities, a unique table name for each
entity, and a database column name for each column. Here's an example:

\begin{verbatim}
<?xml version="1.0"?>
<!DOCTYPE service-builder PUBLIC "-//Liferay//DTD Service Builder 7.1.0//EN"
    "http://www.liferay.com/dtd/liferay-service-builder_7_1_0.dtd">

<service-builder package-path="com.liferay.example" >
    <namespace>TestDB</namespace>
    <entity local-service="true" name="Foo" table="testdata" data-source="extDataSource"
            remote-service="false" uuid="false">
           <column name="id" db-name="id" primary="true" type="long" />
           <column name="foo" db-name="foo" type="String" />
           <column name="bar" db-name="bar" type="long" />
    </entity>
</service-builder>
\end{verbatim}

Note the example's \texttt{\textless{}entity\textgreater{}} tag
attributes:

\emph{\texttt{data-source}}: The \texttt{liferayDataSource} alias
\texttt{ext-spring.xml} specifies.

\emph{\texttt{table}}: Your entity's database table.

Also note that your entity's \texttt{\textless{}column\textgreater{}}s
must have a \emph{\texttt{db-name}} attribute set to the column name.

\subsection{Step 2: Create the Database
Manually}\label{step-2-create-the-database-manually}

\href{/docs/7-1/deploy/-/knowledge_base/d/preparing-for-install\#step-1-choose-a-database-server-and-create-a-new-database}{Create
the database} per the database specification in your
\texttt{service.xml}.

Next, use portal properties to set your data source.

\subsection{Step 3: Specify the Data
Source}\label{step-3-specify-the-data-source}

If the application server defines the data source using JNDI, skip this
step. Otherwise, specify the data source in a
\texttt{portal-ext.properties} file. Distinguish it from Liferay's
default data source by giving it a prefix other than
\texttt{jdbc.default.}. This example uses prefix \texttt{jdbc.ext.}:

\begin{verbatim}
jdbc.ext.driverClassName=org.mariadb.jdbc.Driver
jdbc.ext.password=userpassword
jdbc.ext.url=jdbc:mariadb://localhost/external?useUnicode=true&characterEncoding=UTF-8&useFastDateParsing=false
jdbc.ext.username=yourusername
\end{verbatim}

\subsection{Step 4: Create a Spring Bean that Points to the Data
Source}\label{step-4-create-a-spring-bean-that-points-to-the-data-source}

To do this, create a parent context extension
(e.g.,\texttt{ext-spring.xml}) in your Service Builder module's
\texttt{src/main/resources/META-INF/spring/parent} folder or in your
traditional portlet's \texttt{WEB-INF/src/META-INF/parent} folder.
Create this folder if it doesn't exist already.

\noindent\hrulefill

\textbf{Note:} Since Liferay DXP 7.1 Fix Pack 3 (included in Service
Pack 1) and Liferay Portal 7.1 CE GA2, the Spring extender uses two
application contexts for Service Builder \texttt{*-service} modules.
This lets Liferay DXP register extender services earlier and separately
from the Service Builder services and allows disabling features in the
parent application context that may no longer be needed in the future.
For details, see
\href{https://issues.liferay.com/browse/LPS-85683}{LPS-85683}.

If you're using a prior version of Liferay DXP 7.1, put your parent
context extension (e.g.,\texttt{ext-spring.xml}) in your Service Builder
module's \texttt{src/main/resources/META-INF/spring} folder or in your
traditional portlet's \texttt{WEB-INF/src/META-INF} folder.

\noindent\hrulefill

Define the following elements:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  A data source factory Spring bean for the data source. It's different
  based on the type.

  \begin{itemize}
  \item
    \textbf{JNDI}: Specify an arbitrary property prefix and prepend the
    prefix to a JNDI name property key. Here's an example:

\begin{verbatim}
  <bean class="com.liferay.portal.dao.jdbc.spring.DataSourceFactoryBean"
      id="liferayDataSourceFactory">
      <property name="propertyPrefix" value="custom." />
      <property name="properties">
          <props>
              <prop key="custom.jndi.name">jdbc/externalDataSource</prop>
          </props>
      </property>
  </bean>
\end{verbatim}
  \item
    \textbf{Portal Properties}: Specify a property prefix that matches
    the prefix (e.g., \texttt{jdbc.ext.}) you used in
    \texttt{portal-ext.properties}.

\begin{verbatim}
  <bean class="com.liferay.portal.dao.jdbc.spring.DataSourceFactoryBean"
      id="liferayDataSourceFactory">
      <property name="propertyPrefix" value="jdbc.ext." />
  </bean>
\end{verbatim}
  \end{itemize}
\item
  A Liferay data source bean that refers to the data source factory
  Spring bean.
\item
  An alias for the Liferay data source bean.
\end{enumerate}

Here's an example \texttt{ext-spring.xml} that points to a JNDI data
source:

\begin{verbatim}
<?xml version="1.0"?>

<beans default-destroy-method="destroy" default-init-method="afterPropertiesSet"
   xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">

   <!-- To define an external data source, the liferayDataSource Spring bean 
       must be overridden. Other default Spring beans like liferaySessionFactory 
       and liferayTransactionManager may optionally be overridden. 

       liferayDataSourceFactory refers to the data source configured on the
       application server. -->
   <bean class="com.liferay.portal.dao.jdbc.spring.DataSourceFactoryBean"
       id="liferayDataSourceFactory">
       <property name="propertyPrefix" value="custom." />
       <property name="properties">
           <props>
               <prop key="custom.jndi.name">jdbc/externalDataSource</prop>
           </props>
       </property>
   </bean>

   <!-- The data source bean refers to the factory to access the data source.
   -->
   <bean
       class="org.springframework.jdbc.datasource.LazyConnectionDataSourceProxy"
       id="liferayDataSource">
       <property name="targetDataSource" ref="liferayDataSourceFactory" />
   </bean>

   <!-- In service.xml, we associated our entity with the extDataSource. To 
       associate the extDataSource with our overridden liferayDataSource, we define 
       this alias. -->
   <alias alias="extDataSource" name="liferayDataSource" />
</beans>
\end{verbatim}

The \texttt{liferayDataSourceFactory} above refers to a JNDI data source
named \texttt{jdbc/externalDataSource}. If the data source is in a
\texttt{portal-ext.properties} file, the bean requires only a
\texttt{propertyPrefix} property that matches the data source property
prefix.

The data source bean \texttt{liferayDataSource} is overridden with one
that refers to the \texttt{liferayDataSourceFactory} bean. The override
affects this bundle (module or
\href{/docs/7-1/tutorials/-/knowledge_base/t/using-the-wab-generator}{Web
Application Bundle}) only.

The alias \texttt{extDataSource} refers to the
\texttt{liferayDataSource} data source bean.

\noindent\hrulefill

\textbf{Note}: To use an external data source in multiple Service
Builder bundles, you must override the \texttt{liferayDataSource} bean
in each bundle.

\noindent\hrulefill

\subsection{\texorpdfstring{Step 5: Set Your Entity's Data Source to the
\texttt{liferayDataSource}
Alias}{Step 5: Set Your Entity's Data Source to the liferayDataSource Alias}}\label{step-5-set-your-entitys-data-source-to-the-liferaydatasource-alias}

In your \texttt{service.xml} file, set your entity's data source to the
\texttt{liferayDataSource} alias you specified in your
\texttt{ext-spring.xml} file. Here's an example:

\begin{verbatim}
<?xml version="1.0"?>
<!DOCTYPE service-builder PUBLIC "-//Liferay//DTD Service Builder 7.1.0//EN"
    "http://www.liferay.com/dtd/liferay-service-builder_7_1_0.dtd">

<service-builder package-path="com.liferay.example" >
    <namespace>TestDB</namespace>
    <entity local-service="true" name="Foo" table="testdata" data-source="extDataSource"
            remote-service="false" uuid="false">
           <column name="id" db-name="id" primary="true" type="long" />
           <column name="foo" db-name="foo" type="String" />
           <column name="bar" db-name="bar" type="long" />
    </entity>
</service-builder>
\end{verbatim}

Note the example's \texttt{\textless{}entity\textgreater{}} tag
attributes:

\emph{\texttt{data-source}}: The \texttt{liferayDataSource} alias
\texttt{ext-spring.xml} specifies.

\emph{\texttt{table}}: Your entity's database table.

Also note that your entity's \texttt{\textless{}column\textgreater{}}s
must have a \texttt{db-name} attribute set to the column name.

\subsection{Step 6: Run Service
Builder}\label{step-6-run-service-builder}

\href{/docs/7-1/tutorials/-/knowledge_base/t/running-service-builder}{Run
Service Builder}. Now your Service Builder services use the data source.
You can
\href{/docs/7-1/tutorials/-/knowledge_base/t/business-logic-with-service-builder}{use
the services in your business logic} as you always have regardless of
the underlying data source.

Congratulations! You've connected Service Builder to your external data
source.

\subsection{Related Topics}\label{related-topics-63}

\href{/docs/7-1/tutorials/-/knowledge_base/t/connecting-to-data-sources-using-jndi}{Connecting
to JNDI Data Sources}

\href{/docs/7-1/tutorials/-/knowledge_base/t/service-builder}{Service
Builder}

\href{/docs/7-1/tutorials/-/knowledge_base/t/running-service-builder}{Running
Service Builder and Understanding the Generated Code}

\href{/docs/7-1/tutorials/-/knowledge_base/t/business-logic-with-service-builder}{Business
Logic with Service Builder}

\section{Custom SQL}\label{custom-sql}

Service Builder creates finder methods that retrieve entities by their
attributes: their column values. When you add a column as a parameter
for the finder in your \texttt{service.xml} file and run Service
Builder, it generates the finder method in your persistence layer and
adds methods to your service layer that invoke the finder. If your
queries are simple enough, consider using
\href{/docs/7-1/tutorials/-/knowledge_base/t/dynamic-query}{Dynamic
Query} to access Liferay's database. If you want to do something more
complicated like JOINs, you can write your own custom SQL queries.
You'll learn how in this tutorial.

Say you have a Guestbook application with two tables, one for guestbooks
and one for guestbook entries. The entry entity's foreign key to its
guestbook is the guestbook's ID. That is, the entry entity table,
\texttt{GB\_Entry}, tracks an entry's guestbook by its long integer ID
in the table's \texttt{guestbookId} column. If you want to find a
guestbook entry based on its name, message, and guestbook name, you must
access the \emph{name} of the entry's guestbook. Of course, with SQL you
can join the entry and guestbook tables to include the guestbook name.
Service Builder lets you do this by specifying the SQL as \emph{Liferay
custom SQL} and invoking it in your service via a \emph{custom finder
method}.

Liferay custom SQL is a Service Builder-supported method for performing
custom, complex queries against the database by invoking custom SQL from
a finder method in your persistence layer. Service Builder helps you
generate the interfaces to your finder method. It's easy to do by
following these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \hyperref[step-1-specify-your-custom-sql]{Specify your custom SQL.}
\item
  \hyperref[step-2-implement-your-finder-method]{Implement your finder
  method.}
\item
  \hyperref[step-3-access-your-finder-method-from-your-service]{Access
  your finder method from your service.}
\end{enumerate}

Next, using the Guestbook application as an example, you'll learn how to
accomplish these steps.

\subsection{Step 1: Specify Your Custom
SQL}\label{step-1-specify-your-custom-sql}

After you've tested your SQL, you must specify it in a particular file
for Liferay to access it. \texttt{CustomSQL} class (from module
\href{https://repository.liferay.com/nexus/content/repositories/liferay-public-releases/com/liferay/com.liferay.portal.dao.orm.custom.sql.api/}{\texttt{com.liferay.portal.dao.orm.custom.sql.api}})
retrieves SQL from a file called \texttt{default.xml} in your service
module's \texttt{src/main/resources/META-INF/custom-sql/} folder. You
must create the \texttt{custom-sql} folder and create the
\texttt{default.xml} file in that \texttt{custom-sql} folder. The
\texttt{default.xml} file must adhere to the following format:

\begin{verbatim}
<custom-sql>
    <sql id="[fully-qualified class name + method]">
    SQL query wrapped in <![CDATA[...]]>
    No terminating semi-colon
    </sql>
</custom-sql>
\end{verbatim}

Create a \texttt{custom-sql} element for every SQL query you want in
your application, and give each query a unique ID. The recommended
convention to use for the ID value is the fully-qualified class name of
the finder followed by a dot (\texttt{.}) character and the name of the
finder method. More detail on the finder class and finder methods is
provided in Step 2.

For example, in the Guestbook application, you could use the following
ID value to specify a query:

\begin{verbatim}
com.liferay.docs.guestbook.service.persistence.\
EntryFinder.findByEntryNameEntryMessageGuestbookName
\end{verbatim}

Custom SQL must be wrapped in character data (\texttt{CDATA}) for the
\texttt{sql} element. Importantly, do not terminate the SQL with a
semi-colon. Following these rules, the \texttt{default.xml} file of the
Guestbook application specifies an SQL query that joins the
\texttt{GB\_Entry} and \texttt{GB\_Guestbook} tables:

\begin{verbatim}
<?xml version="1.0" encoding="UTF-8"?>
<custom-sql>
    <sql id="com.liferay.docs.guestbook.service.persistence.EntryFinder.findByEntryNameEntryMessageGuestbookName">
        <![CDATA[
            SELECT GB_Entry.*
            FROM GB_Entry
            INNER JOIN 
                GB_Guestbook ON GB_Entry.guestbookId = GB_Guestbook.guestbookId
            WHERE
                (GB_Entry.name LIKE ?) AND
                (GB_Entry.message LIKE ?) AND
                (GB_Guestbook.name LIKE ?)
        ]]>
    </sql>
</custom-sql>
\end{verbatim}

Now that you've specified some custom SQL, the next step is to implement
a finder method to invoke it. The method name for the finder should
match the ID you just specified for the \texttt{sql} element.

\subsection{Step 2: Implement Your Finder
Method}\label{step-2-implement-your-finder-method}

Next, implement the finder method in your persistence layer to invoke
your custom SQL query. Service Builder generates the interface for the
finder in your API module but you must create the implementation.

The first step is to create a \texttt{*FinderImpl} class in the service
persistence package. For the Guestbook application, you could create a
\texttt{EntryFinderImpl} class in the
\texttt{com.liferay.docs.guestbook.service.persistence.impl} package.
Your class should extend
\texttt{BasePersistenceImpl\textless{}Entry\textgreater{}}.

\href{/docs/7-1/tutorials/-/knowledge_base/t/running-service-builder}{Run
Service Builder} to generate the \texttt{*Finder} interface based on the
\texttt{*FinderImpl} class. Modify your \texttt{*FinderImpl} class to
have it implement the \texttt{*Finder} interface you just generated:

\begin{verbatim}
public class EntryFinderImpl extends BasePersistenceImpl<Event>
    implements EntryFinder {

}
\end{verbatim}

Now you can create a finder method in your \texttt{EntryFinderImpl}
class. Add your finder method and static field to the
\texttt{*FinderImpl} class. For example, here's how you could write the
\texttt{EntryFinderImpl} class:

\begin{verbatim}
public List<Entry> findByEntryNameEntryMessageGuestbookName(
    String entryName, String entryMessage, String guestbookName,
    int begin, int end) {

    Session session = null;
    try {
        session = openSession();

        String sql = _customSQL.get(
            getClass(),
            FIND_BY_ENTRYNAME_ENTRYMESSAGE_GUESTBOOKNAME);

        SQLQuery q = session.createSQLQuery(sql);
        q.setCacheable(false);
        q.addEntity("GB_Entry", EntryImpl.class);

        QueryPos qPos = QueryPos.getInstance(q);
        qPos.add(entryName);
        qPos.add(entryMessage);
        qPos.add(guestbookName);

        return (List<Entry>) QueryUtil.list(q, getDialect(), begin, end);
    }
    catch (Exception e) {
        try {
            throw new SystemException(e);
        }
        catch (SystemException se) {
            se.printStackTrace();
        }
    }
    finally {
        closeSession(session);
    }

    return null;
}

public static final String FIND_BY_ENTRYNAME_ENTRYMESSAGE_GUESTBOOKNAME =
    EntryFinder.class.getName() +
        ".findByEntryNameEntryMessageGuestbookName";

@ServiceReference(type=CustomSQL.class)
private CustomSQL _customSQL;
\end{verbatim}

The custom finder method opens a new Hibernate session and uses
Liferay's
\texttt{CustomSQL.get(Class\textless{}?\textgreater{}\ clazz,\ String\ id)}
method to get the custom SQL to use for the database query. The
\texttt{FIND\_BY\_ENTRYNAME\_ENTRYMESSAGE\_GUESTBOOKNAME} static field
contains the custom SQL query's ID. The
\texttt{FIND\_BY\_EVENTNAME\_EVENTDESCRIPTON\_LOCATIONNAME} string is
based on the fully-qualified class name of the \texttt{*Finder}
interface (\texttt{EventFinder}) and the name of the finder method
(\texttt{findByEntryNameEntryMessageGuestbookName}).

Awesome! Your custom SQL is in place and your finder method is
implemented. Next, you'll call the finder method from your service.

\subsection{Step 3: Access Your Finder Method from Your
Service}\label{step-3-access-your-finder-method-from-your-service}

So far, you've created a \texttt{*FinderImpl} class, generated the
\texttt{*Finder} interface, and created a custom finder method that gets
your custom SQL. Your last step is to add a service method that calls
your finder.

When you ran Service Builder after defining your custom finder method,
the \texttt{*Finder} interface was generated (e.g.,
\texttt{GuestbookFinder}). Your portlet class, however, should not call
the \texttt{*Finder} interface: only a local or remote service
implementation (i.e., \texttt{*LocalServiceImpl} or
\texttt{*ServiceImpl}) in your service module should invoke the
\texttt{*Finder} class. This encourages a proper separation of concerns:
the portlet classes in your application's web module invoke the business
logic of the services published from your application's service module.
The services, in turn, access the data model using the persistence
layer's finder classes.

\noindent\hrulefill

\textbf{Note:} Liferay Portal 6.2 made finder methods accessible via
static \texttt{*FinderUtil} utility classes. Finder methods are now
injected into your app's local services, removing the need to call
finder utilities.

\noindent\hrulefill

So you'll add a method in the \texttt{*LocalServiceImpl} class that
invokes the finder method implementation via the \texttt{*Finder} class.
Then you'll rebuild your application's service layer so that the portlet
classes and JSPs in your web module can access the services.

For example, for the Guestbook application, you'd add the following
method to the \texttt{EntryLocalServiceImpl} class:

\begin{verbatim}
public List<Entry> findByEntryNameGuestbookName(String entryName,
    String guestbookName) throws SystemException {

    return entryFinder.findByEntryNameGuestbookName(String entryName,
        String guestbookName);
}
\end{verbatim}

After you've added your \texttt{findBy-} method to your
\texttt{*LocalServiceImpl} class, run Service Builder to generate the
interface and make the finder method available in the
\texttt{EntryLocalService} class.

Now you can indirectly call the finder method from your portlet class or
a JSP in your web module. For example, to call the finder method in the
Guestbook application, just call
\texttt{entryLocalService.findByEntryNameEntryMessageGuestbookName(...)}!

Congratulations on developing a custom SQL query and custom finder for
your application!

\subsection{Related Topics}\label{related-topics-64}

\href{/docs/7-1/tutorials/-/knowledge_base/t/customizing-liferay-services-service-wrappers}{Customizing
Liferay Services}

\href{/docs/7-1/tutorials/-/knowledge_base/t/service-builder-web-services}{Service
Builder Web Services}

\chapter{Dynamic Query}\label{dynamic-query}

Though you can use custom SQL queries with Service Builder to retrieve
data from the database, sometimes it's more convenient to build queries
dynamically at runtime. You can do this with Liferay's Dynamic Query
API, which wraps Hibernate's Criteria API. The Dynamic Query API lets
you build queries without writing any SQL. It helps you think in terms
of objects and member variables instead of tables and columns. Complex
queries can be significantly easier to understand and maintain than the
equivalent custom SQL (or HQL) queries. While you technically don't need
to know SQL to construct Dynamic Queries, you still must take care to
construct efficient queries. For information on Hibernate's Criteria
API, please see
\href{http://docs.jboss.org/hibernate/orm/5.0/userguide/html_single/chapters/query/criteria/Criteria.html}{Hibernate's
manual}. This tutorial demonstrates creating custom finders for Liferay
applications using Service Builder and Dynamic Query API.

To use Liferay's Dynamic Query API, you need to create a finder
implementation for your model entity. You can
\href{/docs/7-1/tutorials/-/knowledge_base/t/defining-an-object-relational-map-with-service-builder}{define
model entities in \texttt{service.xml}} and
\href{/docs/7-1/tutorials/-/knowledge_base/t/running-service-builder}{run
Service Builder} to generate model, persistence, and service layers for
your application. This tutorial assumes that you're creating a Liferay
application consisting of a service module, an API module, and a web
module. Once you've used Service Builder to generate model, persistence,
and service layers for your application, follow these steps to call
custom finders using the Dynamic Query API:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/defining-a-custom-finder-method}{Define
  a custom finder method}.
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/implementing-a-custom-finder-method-using-dynamic-query}{Implement
  your finder using the Dynamic Query API}.
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/accessing-your-custom-finder-method-from-the-service-layer}{Add
  a method to your \texttt{*LocalServiceImpl} class that invokes your
  finder method}.
\end{enumerate}

Once you've taken these steps, you can access your custom finder as a
service method. Note: You can create multiple or overloaded
\texttt{findBy*} finder methods in your \texttt{*FinderImpl} class.
Next, you'll examine these steps in more detail.

\section{Defining a Custom Finder
Method}\label{defining-a-custom-finder-method}

Dynamic queries belong in finder methods. You implement them and then
make them available through an interface. This tutorial demonstrates
defining the finder method in an implementation class, generating its
interface and tying the implementation to the interface.

An example of this is a Guestbook application with two entities:
guestbook and entry. Each entry belongs to a guestbook so the entry
entity has a \texttt{guestbookId} field as a foreign key. If you need a
finder to search for guestbook entries by entry name and guestbook name,
you'd add a finder method to \texttt{GuestbookFinderImpl} and name it
\texttt{findByEntryNameGuestbookName}. The full method signature would
be
\texttt{findByEntryNameGuestbookName(String\ entryName,\ String\ guestbookName)}.
The steps are below.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a \texttt{{[}Entity{]}FinderImpl} class in the
  \texttt{{[}package\ \ \ \ \ \ path{]}.service.persistence.impl}
  package of your service module's \texttt{src/main/java} folder. Recall
  that you specify the \texttt{{[}package\ path{]}} in your
  \texttt{service.xml} file. Here's an example:

\begin{verbatim}
<service-builder package-path="com.liferay.docs.guestbook">
    ...
</service-builder>
\end{verbatim}
\item
  Define a \texttt{findBy*} finder method in the class you created. Make
  sure to add any required arguments to your finder method signature.
\item
  Run Service Builder to generate the appropriate interface in the
  \texttt{{[}package\ \ \ \ \ \ path{]}.service.persistence} package in
  the \texttt{service} folder of your API and service modules.

  For example, after adding
  \texttt{findByEntryNameGuestbookName(String\ entryName,\ String\ guestbookName)}
  to \texttt{GuestbookFinderImpl} and running Service Builder, the
  interface
  \texttt{com.liferay.docs.guestbook.service.persistence.GuestbookFinder}
  is generated.
\item
  Make the finder class a component (annotated with
  \href{https://docs.osgi.org/javadoc/osgi.cmpn/7.0.0/org/osgi/service/component/annotations/Component.html}{\texttt{@Component}})
  that implements the finder interface. For example, the class
  declaration should look like this:

\begin{verbatim}
@Component(service = GuestbookFinder.class)
public class GuestbookFinderImpl extends BasePersistenceImpl<Guestbook> implements GuestbookFinder
\end{verbatim}
\end{enumerate}

Your next step is to implement the query in your finder method using the
Dynamic Query API.

\section{Implementing a Custom Finder Method Using Dynamic
Query}\label{implementing-a-custom-finder-method-using-dynamic-query}

Once you've
\href{/docs/7-1/tutorials/-/knowledge_base/t/defining-a-custom-finder-method}{defined
your custom finder method}, you can use the Dynamic Query API to
implement your query in it. Here's what you must do in your finder
method:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \hyperref[using-a-hibernate-session]{Open a Hibernate Session}
\item
  \hyperref[creating-dynamic-queries]{Create a dynamic query using these
  Hibernate features}:

  \begin{itemize}
  \tightlist
  \item
    \emph{Restrictions}: Similar to \texttt{where} clauses of an SQL
    query, restrictions limit results based on criteria.
  \item
    \emph{Projections}: Modify the kind of results the query returns.
  \item
    \emph{Orders}: Organize results.
  \end{itemize}
\item
  \hyperref[executing-the-dynamic-query]{Execute the Dynamic Query and
  return the results}
\end{enumerate}

Before implementing a dynamic query in your own finder method, it can be
helpful to examine an example. The following example method uses
multiple dynamic queries and all the Hibernate features. Instructions
for implementing your own finder method follow the example.

\subsection{Example Finder Method:
findByGuestbookNameEntryName}\label{example-finder-method-findbyguestbooknameentryname}

This finder method for the Guestbook application retrieves a list of
Guestbook entries that have a specific name and that also belong to a
Guestbook of a specific name:

\begin{verbatim}
public List<Entry> findByEntryNameGuestbookName(String entryName, String guestbookName) {

    Session session = null;
    try {
        session = openSession();

        ClassLoader classLoader = getClass().getClassLoader();

        DynamicQuery guestbookQuery = DynamicQueryFactoryUtil.forClass(Guestbook.class, classLoader)
            .add(RestrictionsFactoryUtil.eq("name", guestbookName))
            .setProjection(ProjectionFactoryUtil.property("guestbookId"));

        Order order = OrderFactoryUtil.desc("modifiedDate");

        DynamicQuery entryQuery = DynamicQueryFactoryUtil.forClass(Entry.class, classLoader))
            .add(RestrictionsFactoryUtil.eq("name", entryName))
            .add(PropertyFactoryUtil.forName("guestbookId").in(guestbookQuery))
            .addOrder(order);

        List<Entry> entries = _entryLocalService.dynamicQuery(entryQuery);

        return entries;
    }
    catch (Exception e) {
        try {
            throw new SystemException(e);
        }
        catch (SystemException se) {
            se.printStackTrace();
        }
    }
    finally {
        closeSession(session);
    }
}
\end{verbatim}

The method first opens a Hibernate session. While the session is open in
the \texttt{try} block, it creates and executes a dynamic query, which
returns results (a list of guestbook \texttt{Entry} objects) if all goes
well.

The finder method has two distinct dynamic queries.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  The first query retrieves a list of guestbook IDs corresponding to
  guestbook names that match the \texttt{guestbookName} parameter of the
  finder method.
\item
  The second query retrieves a list of guestbook entries with entry
  names that match the \texttt{entryName} parameter and have
  \texttt{guestbookId} foreign keys belonging to the list returned by
  the first query.
\end{enumerate}

Here's the first query:

\begin{verbatim}
DynamicQuery guestbookQuery = DynamicQueryFactoryUtil.forClass(Guestbook.class, classLoader))
    .add(RestrictionsFactoryUtil.eq("name", guestbookName))
    .setProjection(ProjectionFactoryUtil.property("guestbookId"));
\end{verbatim}

By default,
\texttt{DynamicQueryFactoryUtil.forClass(Guestbook.class,\ classLoader))}
returns a query that retrieves a list of all guestbook entities. Adding
the \texttt{.add(RestrictionsFactoryUtil.eq("name",\ guestbookName))}
restriction limits the results to only those guestbooks whose guestbook
names match the \texttt{guestbookName} parameter. The
\texttt{.setProjection(ProjectionFactoryUtil.property("guestbookId"))}
projection changes the result set from a list of guestbook entries to a
list of guestbook IDs. This is useful since guestbook IDs are much less
expensive to retrieve than full guestbook entities, and the entry query
only needs the guestbook IDs.

Next appears an order:

\begin{verbatim}
Order order = OrderFactoryUtil.desc("modifiedDate");
\end{verbatim}

This arranges the results list in descending order of the query entity's
\texttt{modifiedDate} attribute. Thus the most recently modified
entities (guestbook entries, in our example) appear first and the least
recently modified entities appear last.

Here's the second query:

\begin{verbatim}
DynamicQuery entryQuery = DynamicQueryFactoryUtil.forClass(Entry.class, classLoader))
    .add(RestrictionsFactoryUtil.eq("name", entryName))
    .add(PropertyFactoryUtil.forName("guestbookId").in(guestbookQuery))
    .addOrder(order);
\end{verbatim}

By default,
\texttt{DynamicQueryFactoryUtil.forClass(Entry.class,\ classLoader))}
returns a list of all guestbook entry entities. The
\texttt{.add(RestrictionsFactoryUtil.eq("name",\ entryName))}
restriction limits the results to only those guestbook entries whose
names match the finder method's \texttt{entryName} parameter.
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/dao/orm/PropertyFactoryUtil.html}{\texttt{PropertyFactoryUtil}}
is a Liferay utility class whose method
\texttt{forName(String\ propertyName)} returns the specified property.
This property can be passed to another Liferay dynamic query. This is
exactly what happens in the following line of our example:

\begin{verbatim}
.add(PropertyFactoryUtil.forName("guestbookId").in(guestbookQuery))
\end{verbatim}

Here, the code makes sure that the guestbook IDs (foreign keys) of the
entry entities in the \texttt{entityQuery} belong to the list of
guestbook IDs returned by the \texttt{guestbookQuery}. Declaring that an
entity property in one query must belong to the result list of another
query is a way to use the dynamic query API to create complex queries,
similar to SQL joins.

Lastly, the order defined earlier is applied to the entries returned by
the \texttt{findByEntryNameGuestbookName} finder method:

\begin{verbatim}
.addOrder(order);
\end{verbatim}

This orders the list of guestbook entities by the \texttt{modifiedDate}
attribute, from most recent to least recent.

Lastly, the dynamic query is invoked on the \texttt{EntryLocalService}
instance. It returns a list of \texttt{Entry} objects which are then
returned by the finder method.

\begin{verbatim}
List<Entry> entries = _entryLocalService.dynamicQuery(entryQuery);

return entries;
\end{verbatim}

It's time to implement your finder method to use Dynamic Query. Start
with opening and managing a Hibernate session.

\subsection{Using a Hibernate Session}\label{using-a-hibernate-session}

Your first step in implementing your custom finder method in your
\texttt{*FinderImpl} class is to open a new Hibernate session. Since
your \texttt{*FinderImpl} class extends
\texttt{BasePersistenceImpl\textless{}Entity\textgreater{}}, and
\texttt{BasePersistenceImpl\textless{}Entity\textgreater{}} contains a
session factory object and an
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/service/persistence/impl/BasePersistenceImpl.html\#openSession--}{\texttt{openSession}}
method, you can simply invoke the \texttt{openSession} method of your
\texttt{*FinderImpl}'s parent class to open a new Hibernate session. The
structure of your finder method should look like this:

\begin{verbatim}
public List<Entity> findBy-(...) {

    Session session = null;
    try {
            session = openSession();
            
            /*
            create a dynamic
            query to retrieve and return the desired list of entity
            objects
            */
    }
    catch (Exception e) {
            // Exception handling
    }
    finally {
            closeSession(session);
    }

    return null;
    /*
    Return null only if there was an error returning the
    desired list of entity objects in the try block
    */

}
\end{verbatim}

Next, in the try block, create your dynamic query objects.

\subsection{Creating Dynamic Queries}\label{creating-dynamic-queries}

In Liferay, you don't create criteria objects directly from the
Hibernate session. Instead, you create dynamic query objects using
Liferay's
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/dao/orm/DynamicQueryFactoryUtil.html}{\texttt{DynamicQueryFactoryUtil}}
service. Thus, instead of

\begin{verbatim}
Criteria entryCriteria = session.createCriteria(Entry.class);
\end{verbatim}

you use

\begin{verbatim}
DynamicQuery entryQuery = DynamicQueryFactoryUtil.forClass(Entry.class, classLoader));
\end{verbatim}

In your finder method, initialize your dynamic query for your entity
class.

Most features of Hibernate's Criteria API, including restrictions,
projections, and orders, can be used on Liferay dynamic query objects.
Each criteria can be applied to your query. The restriction criteria
type is described first.

\subsubsection{Restriction Criteria}\label{restriction-criteria}

Restrictions in Hibernate's Criteria API roughly correspond to the
\texttt{where} clause of an SQL query: they offer a variety of ways to
limit the results returned by the query. You can use restrictions, for
example, to cause a query to return only results where a certain field
has a particular value, or a value in a certain range, or a non-null
value, etc.

When you need to add restrictions to a dynamic query, don't call
Hibernate's \texttt{Restrictions} class directly. Instead, use the
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/dao/orm/RestrictionsFactoryUtil.html}{\texttt{RestrictionsFactoryUtil}}
service. \texttt{RestrictionsFactoryUtil} has the same methods that
you're used to from Hibernate's \texttt{Restrictions} class:
\texttt{in}, \texttt{between}, \texttt{like}, \texttt{eq}, \texttt{ne},
\texttt{gt}, \texttt{ge}, \texttt{lt}, \texttt{le}, etc.

Thus, instead of using the following call to specify that a guestbook
must have a certain name,

\begin{verbatim}
entryCriteria.add(Restrictions.eq("name", guestbookName));
\end{verbatim}

you use

\begin{verbatim}
entryQuery.add(RestrictionsFactoryUtil.eq("name", guestbookName));
\end{verbatim}

The restriction above limits the results to guestbook entries whose
\texttt{name} attribute matches the value of the variable
\texttt{guestbookName}. Add the restrictions you need to get the results
you want.

Projections are the next criteria type. They let you transform the query
results to return the field type you desire.

\subsubsection{Projection Criteria}\label{projection-criteria}

Projections in Hibernate's Criteria API let you modify the kind of
results returned by a query. For example, if you don't want your query
to return a list of entity objects (the default), you can set a
projection on a query to return only a list of the values of a certain
entity field, or fields. You can also use projections on a query to
return the maximum or minimum value of an entity field, or the sum of
all the values of a field, or the average, etc. For more information on
restrictions and projections, please refer to Hibernate's
\href{http://docs.jboss.org/hibernate/orm/3.6/reference/en-US/html/querycriteria.html}{documentation}.

Similarly, to set projections, create properties via Liferay's
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/dao/orm/PropertyFactoryUtil.html}{PropertyFactoryUtil}
service instead of through Hibernate's \texttt{Property} class. Thus,
instead of

\begin{verbatim}
entryCriteria.setProjection(Property.forName("guestbookId"));
\end{verbatim}

you use

\begin{verbatim}
entryQuery.setProjection(PropertyFactoryUtil.forName("guestbookId"));
\end{verbatim}

The projection above specifies the \texttt{guestbookId} entity field to
changes the result set to a list of those field values. If you want to
return a specific field type from your entities, add a projection for
it.

The last criteria type lets you organize results your way.

\subsubsection{Order Criteria}\label{order-criteria}

Orders in Hibernate's Criteria API let you control the order of the
elements in the list a query returns. You can choose the property or
properties to which an order applies as well as whether they're in
ascending or descending order.

This code creates an order by the entity's \texttt{modifiedDate}
attribute:

\begin{verbatim}
Order order = OrderFactoryUtil.desc("modifiedDate");
\end{verbatim}

When you apply this order, the results are arranged in descending order
of the query entity's \texttt{modifiedDate} attribute. Thus the most
recently modified entities (guestbook entries, in our example) appear
first and the least recently modified entities appear last.

Like Hibernate criteria, Liferay's dynamic queries are
\emph{chain-able}: you can add criteria to, set projections on, and add
orders to Liferay's dynamic query objects just by appending the
appropriate method calls to the query object. For example, the following
snippet demonstrates chaining a restriction criterion and a projection
to a dynamic query object declaration:

\begin{verbatim}
DynamicQuery guestbookQuery = DynamicQueryFactoryUtil.forClass(Guestbook.class)
    .add(RestrictionsFactoryUtil.eq("name", guestbookName))
    .setProjection(ProjectionFactoryUtil.property("guestbookId"));
\end{verbatim}

It's time to execute your dynamic query.

\subsection{Executing the Dynamic
Query}\label{executing-the-dynamic-query}

In the previous tutorial, you ran Service Builder after
\href{/docs/7-1/tutorials/-/knowledge_base/t/defining-a-custom-finder-method}{defining
your custom finder}. Service Builder generated a
\texttt{dynamicQuery(DynamicQuery\ dynamicQuery)} method in your
\texttt{*LocalServiceBaseImpl} class. Using a \texttt{*LocalService}
instance, invoke \texttt{dynamicQuery} method, passing it your dynamic
query. Here's an example dynamic query execution.

\begin{verbatim}
List<Entity> entities = _someLocalService.dynamicQuery(entityQuery);

return entities;
\end{verbatim}

The dynamic query execution returns a list of entities and the finder
method returns that list.

\noindent\hrulefill

\textbf{Note:} Service Builder not only generates a
\texttt{public\ List\ \ dynamicQuery(DynamicQuery\ dynamicQuery)} method
in \texttt{*LocalServiceBaseImpl} but it also generates
\texttt{public\ List\ dynamicQuery(DynamicQuery\ dynamicQuery,\ int\ \ start,\ int\ end)}
and
\texttt{public\ List\ dynamicQuery(DynamicQuery\ dynamicQuery,\ int\ \ start,\ int\ end,\ OrderByComparator\ orderByComparator)}
methods. You can go back to
\href{/docs/7-1/tutorials/-/knowledge_base/t/defining-a-custom-finder-method}{defining
custom finder methods} and either modify your finder method or create
overloaded versions of it to take advantage of these extra methods and
their parameters. The \texttt{int\ start} and \texttt{int\ \ end}
parameters are useful when paginating a result list. \texttt{start} is
the lower bound of the range of model entity instances and \texttt{end}
is the upper bound. The \texttt{OrderByComparator\ orderByComparator} is
the comparator by which to order the results.

\noindent\hrulefill

To use the overloaded \texttt{dynamicQuery} methods of your
\texttt{*LocalServiceBaseImpl} class in the (optionally overloaded)
custom finders of your \texttt{*FinderImpl} class, just choose the
appropriate methods for running the dynamic queries:
\texttt{dynamicQuery(entryQuery)}, or
\texttt{dynamicQuery(entryQuery,\ start,\ end)} or
\texttt{dynamicQuery(entryQuery,\ start,\ end,\ orderByComparator)}.

Great! You've now created a finder method using Liferay's Dynamic Query
API. Your last step is to add a service method that calls your finder.

\section{Accessing Your Custom Finder Method from the Service
Layer}\label{accessing-your-custom-finder-method-from-the-service-layer}

So far, you've created a \texttt{*FinderImpl} class, defined a
\texttt{findBy*} finder method in that class, and implemented the finder
method using Dynamic Query. Now how do you call your finder method from
the service layer?

When you ran Service Builder, the \texttt{*Finder} interface was
generated (e.g., \texttt{GuestbookFinder}). For proper separation of
concerns, only a local or remote service implementation (i.e.,
\texttt{*LocalServiceImpl} or \texttt{*ServiceImpl}) in your service
module should invoke the \texttt{*Finder} class. The portlet classes in
your application's web module invoke the business logic of the services
published from your application's service module. The services, in turn,
access the data model using the persistence layer's finder classes.

\noindent\hrulefill

\textbf{Note:} In previous versions of Liferay Portal, your finder
methods were accessible via \texttt{*FinderUtil} utility classes. Finder
methods are now injected into your app's local services, removing the
need to call finder utilities.

\noindent\hrulefill

You'll add a method in the \texttt{*LocalServiceImpl} class that invokes
the finder method implementation via the \texttt{*Finder} class. Then
you'll rebuild your application's service layer so that the portlet
classes and JSPs in your web module can access the services.

For example, for the Guestbook application, you'd add the following
method to the \texttt{EntryLocalServiceImpl} class:

\begin{verbatim}
public List<Entry> findByEntryNameGuestbookName(String entryName,
    String guestbookName) throws SystemException {

    return entryFinder.findByEntryNameGuestbookName(String entryName,
        String guestbookName);
}
\end{verbatim}

After you've added your \texttt{findBy*} method to your
\texttt{*LocalServiceImpl} class, run Service Builder to generate the
interface and make the finder method available in the
\texttt{EntryLocalService} class.

Now you can indirectly call the finder method from your portlet class or
from a JSP by calling
\texttt{\_entryLocalService.findByEntryNameGuestbookName(...)}!

Congratulations on following the three step process of developing a
dynamic query in a custom finder and exposing it as a service for your
portlet!

\subsection{Related Topics}\label{related-topics-65}

\href{/docs/7-1/tutorials/-/knowledge_base/t/service-builder-web-services}{Service
Builder Web Services}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-local-services}{Creating
Local Service}

\href{/docs/7-1/tutorials/-/knowledge_base/t/invoking-local-services}{Invoking
Local Services}

\section{Actionable Dynamic Queries}\label{actionable-dynamic-queries}

Suppose you have over a million users, and you want to perform some kind
of mass update to some of them. One approach might be to use a dynamic
query to retrieve the list of users in question. Once loaded into
memory, you could loop through the list and update each user. However,
with over a million users, the memory cost of such an operation would be
too great. In general, retrieving large numbers of Service Builder
entities using dynamic queries requires too much memory and time.

Liferay actionable dynamic queries solve this problem. Actionable
dynamic queries use a pagination strategy to load only small numbers of
entities into memory at a time and perform processing (i.e., perform an
\emph{action}) on each entity. So instead of trying to use a dynamic
query to load a million users into memory and then perform some
processing on each of them, a much better strategy is to use an
actionable dynamic query. This way, you can still process your million
users, but only small numbers are loaded into memory at a time.

Here's how to use actionable dynamic query:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Get an
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/dao/orm/ActionableDynamicQuery.html}{\texttt{ActionableDynamicQuery}}
  from your \texttt{*LocalService} by invoking its
  \texttt{getActionableDynamicQuery} method.
\item
  Add query criteria and constraints, using the query's
  \texttt{setAddCriteriaMethod} and \texttt{setAddOrderCriteriaMethod}
  methods.
\item
  Set an action to perform on the matching entities, using
  \texttt{setPerformActionMethod}.
\item
  Execute the action on each matching entity, by invoking the query's
  \texttt{performActions} method.
\end{enumerate}

This method from a sample portlet creates an actionable dynamic query,
adds a query restriction and an action, and executes the query:

\begin{verbatim}
protected void massUpdate() {
    ActionableDynamicQuery adq = _barLocalService.getActionableDynamicQuery();
    
    adq.setAddCriteriaMethod(new ActionableDynamicQuery.AddCriteriaMethod() {
        
        @Override
        public void addCriteria(DynamicQuery dynamicQuery) {
            dynamicQuery.add(RestrictionsFactoryUtil.lt("field3", 100));
        }
        
    });
    
    adq.setPerformActionMethod(new ActionableDynamicQuery.PerformActionMethod<Bar>() {
        
        @Override
        public void performAction(Bar bar) {
            int field3 = bar.getField3();
            field3++;
            bar.setField3(field3);
            _barLocalService.updateBar(bar);
        }
        
    });
    
    try {
        adq.performActions();
    }
    catch (Exception e) {
        e.printStackTrace();
    }
}
\end{verbatim}

The example method demonstrates executing an actionable dynamic query on
\texttt{Bar} entities that match certain criteria.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Retrieve an
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/dao/orm/ActionableDynamicQuery.html}{\texttt{ActionableDynamicQuery}}
  from local service \texttt{BarLocalService}.

\begin{verbatim}
ActionableDynamicQuery adq = _barLocalService.getActionableDynamicQuery();
\end{verbatim}
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** Service Builder generates method `getActionableDynamicQuery()` in
 each entity's `*LocalService` interface and implements it in each entity's
 `*BaseLocalServiceImpl` class.
 
     @Transactional(propagation = Propagation.SUPPORTS, readOnly = true)
     public ActionableDynamicQuery getActionableDynamicQuery();
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\item
  Set query criteria to match \texttt{field3} values less than
  \texttt{100}.

\begin{verbatim}
adq.setAddCriteriaMethod(new ActionableDynamicQuery.AddCriteriaMethod() {

     @Override
     public void addCriteria(DynamicQuery dynamicQuery) {
         dynamicQuery.add(RestrictionsFactoryUtil.lt("field3", 100));
     }

 });
\end{verbatim}
\item
  Set an action to perform. The action increments the matching entity's
  \texttt{field3} value.

\begin{verbatim}
adq.setPerformActionMethod(new ActionableDynamicQuery.PerformActionMethod<Bar>() {

     @Override
     public void performAction(Bar bar) {
         int field3 = bar.getField3();
         field3++;
         bar.setField3(field3);
         _barLocalService.updateBar(bar);
     }

 });
\end{verbatim}
\item
  Execute the action on each matching entity.

\begin{verbatim}
try {
    adq.performActions();
}
catch (Exception e) {
    e.printStackTrace();
}
\end{verbatim}
\end{enumerate}

Actionable dynamic queries let you act on large numbers of entities in
smaller groups. It's an efficient and high performing way to update
entities.

\subsection{Related Topics}\label{related-topics-66}

\href{/docs/7-1/tutorials/-/knowledge_base/t/service-builder-web-services}{Service
Builder Web Services}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-local-services}{Creating
Local Service}

\href{/docs/7-1/tutorials/-/knowledge_base/t/invoking-local-services}{Invoking
Local Services}

\chapter{Business Logic with Service
Builder}\label{business-logic-with-service-builder}

Once you've
\href{/docs/7-1/tutorials/-/knowledge_base/t/defining-an-object-relational-map-with-service-builder}{defined
your application's entities} and
\href{/docs/7-1/tutorials/-/knowledge_base/t/running-service-builder}{run
Service Builder} to generate your service and persistence layers, you
can begin adding business logic. Each entity generated by Service
Builder contains a model implementation, local service implementation,
and optionally a remote service implementation class. Your application's
business logic can be implemented in these classes. The generated
service layer contains default methods for CRUD operations, but often
times it's necessary to implement additional methods. Once you've added
your business logic, running Service Builder again regenerates your
application's interfaces and makes your new logic available for
invocation.

In this section of tutorials, you'll learn about creating and invoking
your application's local services, finding and invoking Liferay's
services, and customizing Liferay services.

\chapter{Creating Local Services}\label{creating-local-services}

The heart of your service is its \texttt{*LocalServiceImpl} class. This
class is your entity's local service extension point. Local services are
invoked from your application or by other applications running on the
same instance as your application.

These tutorials walk you through creating local services:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Deciding to Create Local and Remote Services.
\item
  Implementing the \texttt{add} Method.
\item
  Implementing the \texttt{update} and \texttt{delete} Methods.
\item
  Implementing Finder and Counter Methods
\item
  Implementing Other Business Logic
\item
  Integrating with Liferay's Services.
\end{enumerate}

Start with deciding the service types you need.

\section{Deciding to Create Local and Remote
Services}\label{deciding-to-create-local-and-remote-services}

\href{/docs/7-1/tutorials/-/knowledge_base/t/defining-an-object-relational-map-with-service-builder}{Defining
your object model} involves choosing whether to generate local and or
remote service interfaces. Local services can only be invoked from the
Liferay server on which they're deployed. Remote services are accessible
to clients outside of the Liferay server. Before implementing local or
remote services, consider the best practices described here:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  If you plan to have remote services, enable local services too.
\item
  Implement your business logic in \texttt{*LocalServiceImpl}.
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/creating-remote-services}{Create
  corresponding remote services methods} in your \texttt{*ServiceImpl}.
\item
  Use the remote service methods to call the local service, wrapping the
  calls in permission checks.
\item
  In your application, call only the remote services. This ensures that
  your service methods are secured and that you don't have to duplicate
  permissions code.
\end{enumerate}

If you are turning on local or remote services in your
\texttt{service.xml} file just now, make sure to
\href{/docs/7-1/tutorials/-/knowledge_base/t/running-service-builder}{run
Service Builder} again to generate the service interfaces.

\section{Implementing an Add Method}\label{implementing-an-add-method}

Your \texttt{*LocalServiceImpl} operates on the entities your
\texttt{service.xml} defines. The first method to implement, therefore,
is one that creates entities. Liferay's convention is to implement this
in an \texttt{add*} method, where the part after \texttt{add} is the
entity name (or a shortened version of it). Here are the steps for
implementing an \texttt{add*} method:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Declare an \texttt{add*} method with parameters for creating the
  entity.
\item
  Validate the parameters.
\item
  Generate a primary key.
\item
  Create an entity instance.
\item
  Populate the entity attributes.
\item
  Persist the entity.
\item
  Return the entity instance.
\end{enumerate}

This tutorial refers to the Bookmarks application's \texttt{addEntry}
method from
\href{https://github.com/liferay/liferay-portal/blob/master/modules/apps/bookmarks/bookmarks-service/src/main/java/com/liferay/bookmarks/service/impl/BookmarksEntryLocalServiceImpl.java}{\texttt{BookmarksEntryLocalServiceImpl}}
as an example. To keep things simple, we have excluded the code that
integrates with Liferay services, such as assets, social bookmarks, and
more.

Here's the Bookmarks application's \texttt{addEntry} method:

\begin{verbatim}
public BookmarksEntry addEntry(
        long userId, long groupId, long folderId, String name, String url,
        String description, ServiceContext serviceContext)
    throws PortalException {

    // Entry

    User user = userLocalService.getUser(userId);

    if (Validator.isNull(name)) {
        name = url;
    }

    validate(url);

    long entryId = counterLocalService.increment();

    BookmarksEntry entry = bookmarksEntryPersistence.create(entryId);

    entry.setUuid(serviceContext.getUuid());
    entry.setGroupId(groupId);
    entry.setCompanyId(user.getCompanyId());
    entry.setUserId(user.getUserId());
    entry.setUserName(user.getFullName());
    entry.setFolderId(folderId);
    entry.setTreePath(entry.buildTreePath());
    entry.setName(name);
    entry.setUrl(url);
    entry.setDescription(description);
    // More assignments ... 

    bookmarksEntryPersistence.update(entry);

    // Integrate with more Liferay services here ...

    return entry;
}
\end{verbatim}

This method uses the parameters to create \texttt{BookmarksEntry}. It
validates the parameters, creates an entry with a generated entry ID
(primary key), populates the entry, persists the entry, and returns it.
You can refer to this method as you create your own \texttt{add*}
method.

\subsection{Step 1: Declare an add method with parameters for creating
the
entity}\label{step-1-declare-an-add-method-with-parameters-for-creating-the-entity}

Create a public method for \emph{adding} (creating) your application's
entity. Make it a public method that returns the entity it creates.

\begin{verbatim}
public [ENTITY] add[ENTITY](...) {
    
} 
\end{verbatim}

For example, here's the \texttt{addEntry} method signature:

\begin{verbatim}
public BookmarksEntry addEntry(
        long userId, long groupId, long folderId, String name, String url,
        String description, ServiceContext serviceContext)
    throws PortalException {
        ...
}
\end{verbatim}

This method specifies all the parameters needed to create and populate a
\texttt{BookmarksEntry}. It throws a \texttt{PortalException} in case
the parameters are invalid or a processing exception occurs (more on
this in a later step).

Your add method must specify parameters that satisfy the entity's
attributes specified in your \texttt{service.xml} file. Make sure to
account for primary keys of other related entities. For example, the
\texttt{addEntry} method above includes a parameter
\texttt{long\ folderId} to associate the new \texttt{BookmarksEntry} to
a \texttt{BookmarksFolder}.

\subsection{Step 2: Validate the
parameters}\label{step-2-validate-the-parameters}

Validate the parameters as needed. You might need to make sure a
parameter is not empty or \texttt{null}, or that a parameter value is
within a valid range. Throw a
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/exception/PortalException.html}{\texttt{PortalException}}
or an extension of \texttt{PortalException} for any invalid parameters.

For example, the \texttt{addEntry} method invokes the following
\texttt{validate} method to check if the URL parameter is \texttt{null}.

\begin{verbatim}
protected void validate(String url) throws PortalException {
    if (!Validator.isUrl(url)) {
        throw new EntryURLException();
    }
}
\end{verbatim}

Next, generate a primary key for the entity instance you're creating.

\subsection{Step 3: Generate a primary
key}\label{step-3-generate-a-primary-key}

Every entity instance needs a unique primary key. Liferay's
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/counter/kernel/service/CounterLocalService.html}{\texttt{CounterLocalService}}
generates them per entity. Every \texttt{*BaseLocalServiceImpl} has a
\texttt{counterLocalService} field that references a
\texttt{CounterLocalService} object for the entity. Invoke the counter
service's \texttt{increment} method to generate a primary key for your
entity instance.

\begin{verbatim}
long id = counterLocalService.increment();
\end{verbatim}

Now you have a unique ID for your entity instance.

\subsection{Step 4: Create an entity
instance}\label{step-4-create-an-entity-instance}

The \texttt{*Peristence} instance associated with your entity has a
\texttt{create(long\ id)} method that constructs an entity instance with
the given ID. Every \texttt{*BaseLocalServiceImpl} has a
\texttt{*Persistence} field that references a \texttt{*Persistence}
object for the entity. For example,
\href{https://github.com/liferay/liferay-portal/blob/master/modules/apps/bookmarks/bookmarks-service/src/main/java/com/liferay/bookmarks/service/impl/BookmarksEntryLocalServiceImpl.java}{\texttt{BookmarksEntryLocalServiceImpl}}
can access
\href{https://github.com/liferay/liferay-portal/blob/master/modules/apps/bookmarks/bookmarks-service/src/main/java/com/liferay/bookmarks/service/base/BookmarksEntryLocalServiceBaseImpl.java}{\texttt{BookmarksEntryLocalServiceBaseImpl}}'s
field \texttt{bookmarksEntryPersistence}, which is a reference to a
\texttt{BookmarksEntryPersistence} instance.

\begin{verbatim}
@BeanReference(type = BookmarksEntryPersistence.class)
protected BookmarksEntryPersistence bookmarksEntryPersistence;
\end{verbatim}

\texttt{BookmarksEntryLocalServiceImpl}'s \texttt{addEntry} method
creates a \texttt{BookmarksEntry} instance using this call:

\begin{verbatim}
BookmarksEntry entry = bookmarksEntryPersistence.create(entryId);
\end{verbatim}

To create an instance of your entity, invoke the \texttt{create} method
on the \texttt{*Persistence} field associated with the entity, making
sure to pass in the entity primary key you generated in the previous
step.

\begin{verbatim}
 [ENTITY_NAME] entity = [ENTITY_NAME]Persistence.create(id);
\end{verbatim}

It's time to populate the new entity instance.

\subsection{Step 5: Populate the entity
attributes}\label{step-5-populate-the-entity-attributes}

Use the \texttt{add*} method parameter values and the entity's setter
methods to populate your entity's attributes. For example, here are the
\texttt{BookmarksEntry} attribute assignments:

\begin{verbatim}
entry.setUuid(serviceContext.getUuid());
entry.setGroupId(groupId);
entry.setCompanyId(user.getCompanyId());
entry.setUserId(user.getUserId());
entry.setUserName(user.getFullName());
entry.setFolderId(folderId);
entry.setTreePath(entry.buildTreePath());
entry.setName(name);
entry.setUrl(url);
entry.setDescription(description);
\end{verbatim}

Note that the \texttt{ServiceContext} is commonly used to carry an
entity's UUID and the \texttt{User} is associated to a company.

\subsection{Step 6: Persist the entity}\label{step-6-persist-the-entity}

It's time to store the entity. Invoke the \texttt{*Persistence} field's
\texttt{update} method, passing in the entity object. For example,
here's how the new \texttt{BookmarksEntry} is persisted:

\begin{verbatim}
bookmarksEntryPersistence.update(entry);
\end{verbatim}

Your entity is persisted for the application.

\subsection{Step 7: Return the entity}\label{step-7-return-the-entity}

Finally, return the entity you just created so the caller can use it.

\href{/docs/7-1/tutorials/-/knowledge_base/t/running-service-builder}{Run
Service Builder} to propagate your new service method to the
\texttt{*LocalService} interface.

You've implemented your local service's \texttt{add*} method to create
and persist your application's entities.

\section{Implementing update and delete
Methods}\label{implementing-update-and-delete-methods}

After you've implementing an
\href{/docs/7-1/tutorials/-/knowledge_base/t/implementing-an-add-method}{\texttt{add*}
method} for creating service entities, you'll want to create
\hyperref[implementing-an-update-method]{\texttt{update*}} and
\hyperref[implementing-a-delete-method]{\texttt{delete*}} methods for
updating and deleting them. They're easy to implement. The main
difference between them and the \texttt{add*} method is they must know
which entity they're updating or deleting.

\subsection{Implementing an update
method}\label{implementing-an-update-method}

An \texttt{update*} method for a local service resembles an
\href{/docs/7-1/tutorials/-/knowledge_base/t/implementing-an-add-method}{\texttt{add*}
method} most because it has parameters for setting entity attribute
values. Create an \texttt{update*} method this way:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Declare an \texttt{update*} method with parameters for updating the
  entity.
\item
  Validate the parameters.
\item
  Retrieve the entity instance, if necessary.
\item
  Update the entity attributes.
\item
  Persist the updated entity.
\item
  Run Service Builder.
\end{enumerate}

The following code snippets from
\href{https://github.com/liferay/liferay-portal/blob/master/modules/apps/bookmarks/bookmarks-service/src/main/java/com/liferay/bookmarks/service/impl/BookmarksEntryLocalServiceImpl.java}{\texttt{BookmarksEntryLocalServiceImpl}}'s
\texttt{updateEntry} method are helpful to examine.

\begin{verbatim}
public BookmarksEntry updateEntry(
        long userId, long entryId, long groupId, long folderId, String name,
        String url, String description, ServiceContext serviceContext)
    throws PortalException {

    // Entry

    BookmarksEntry entry = bookmarksEntryPersistence.findByPrimaryKey(
        entryId);

    if (Validator.isNull(name)) {
        name = url;
    }

    validate(url);

    entry.setFolderId(folderId);
    entry.setTreePath(entry.buildTreePath());
    entry.setName(name);
    entry.setUrl(url);
    entry.setDescription(description);
    //...

    bookmarksEntryPersistence.update(entry);

    // Integrate with more Liferay services here ...

    return entry;
}
\end{verbatim}

This method has all the makings of a good \texttt{update*} method:

\begin{itemize}
\tightlist
\item
  parameter for looking up the entity instance
\item
  parameters for updating the entity attributes
\item
  parameter validation
\item
  entity attribute updates
\item
  entity persistence
\item
  returns the entity instance
\end{itemize}

Refer to the example method above as you follow the steps to create your
own \texttt{update*} method.

\subsubsection{Step 1: Declare an update method with parameters for
updating the
entity}\label{step-1-declare-an-update-method-with-parameters-for-updating-the-entity}

Create a public method for updating your application's entity.

\begin{verbatim}
public [ENTITY] update[ENTITY](...)
    throws PortalException {
    
} 
\end{verbatim}

Replace \texttt{{[}ENTITY{]}} with your entity's name or nickname.
Create a parameter list that satisfies the entity attributes you're
updating. Include an entity instance parameter or an ID parameter for
fetching the entity instance.

For example, the \texttt{BookmarksEntryLocalServiceImpl}'s
\texttt{updateEntry} method signature has an ID parameter
(\texttt{entryId}) for fetching the \texttt{BookmarksEntry} entity
instance. Also it has parameters \texttt{folderId}, \texttt{name},
\texttt{url}, and \texttt{description} for updating the
\texttt{BookmarksEntry}'s respective attributes.

\begin{verbatim}
public BookmarksEntry updateEntry(
        long userId, long entryId, long groupId, long folderId, String name,
        String url, String description, ServiceContext serviceContext)
    throws PortalException {...} 
\end{verbatim}

Note, user ID, group ID, and service context parameters are useful for
integrating with Liferay's services. More on that later.

\subsubsection{Step 2: Validate the
parameters}\label{step-2-validate-the-parameters-1}

Similar to validating the
\href{/docs/7-1/tutorials/-/knowledge_base/t/implementing-an-add-method}{\texttt{add*}
method} parameters, validate your \texttt{update*} parameters. Your
\texttt{add*} and \texttt{update*} methods might be able to use the same
validation code. Throw a
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/exception/PortalException.html}{\texttt{PortalException}}
or an extension of \texttt{PortalException} for any invalid parameters.

\subsubsection{Step 3: Retrieve the entity
instance}\label{step-3-retrieve-the-entity-instance}

If you're passing in an entity instance, you can update it directly.
Otherwise, pass in the entity ID (the primary key). The
\texttt{*Persistence} class Service Builder injects into
\texttt{*BaseLocalServiceImpl} classes has a
\texttt{findByPrimaryKey(long)} method that retrieves instances by ID.
For example, the
\href{https://github.com/liferay/liferay-portal/blob/master/modules/apps/bookmarks/bookmarks-service/src/main/java/com/liferay/bookmarks/service/impl/BookmarksEntryLocalServiceImpl.java}{\texttt{BookmarksEntryLocalServiceImpl}}
retrieves the \texttt{BookmarksEntry} that matches the primary key
\texttt{entryId}.

\begin{verbatim}
BookmarksEntry entry = bookmarksEntryPersistence.findByPrimaryKey(
    entryId);
\end{verbatim}

Invoke the \texttt{findByPrimaryKey(long\ id)} method of your
\texttt{*Persistence} class to retrieve the entity instance that matches
your primary key parameter.

\begin{verbatim}
 [ENTITY] entity = [ENTITY]Persistence.findByPrimaryKey(id);
\end{verbatim}

It's time to update the entity attributes.

\subsubsection{Step 4: Update the entity
attributes}\label{step-4-update-the-entity-attributes}

Invoke the entity's setter methods to replace its attribute values.

\subsubsection{Step 5: Persist and return the updated entity
instance}\label{step-5-persist-and-return-the-updated-entity-instance}

Persist the updated entity to the database and return the instance to
the caller.

\begin{verbatim}
[ENTITY]Persistence.update(entity);

...

return entity;
\end{verbatim}

\subsubsection{Step 6: Run Service
Builder}\label{step-6-run-service-builder-1}

Finally, run Service Builder to propagate your new service method to the
\texttt{*LocalService} interface.

You've created a service method to update your entity. If you thought
that was easy, implementing a \texttt{delete*} method is even easier.

\subsection{Implementing a delete
method}\label{implementing-a-delete-method}

The \texttt{remove} method of an entity's \texttt{*Persistence} class
deletes an entity instance from the database. Use it in your local
service's \texttt{delete*} method. Here's what a \texttt{delete*} method
looks like:

\begin{verbatim}
public [ENTITY] delete[ENTITY](ENTITY entity) throws PortalException
{
    [ENTITY]Persistence.remove(entity);

    // Clean up related to additional Liferay services goes here ... 

    return entity;
}
\end{verbatim}

Make sure to replace \texttt{{[}ENTITY{]}} with your entity's name or
nickname.

For example, here's paraphrased code from
\href{https://github.com/liferay/liferay-portal/blob/master/modules/apps/bookmarks/bookmarks-service/src/main/java/com/liferay/bookmarks/service/impl/BookmarksEntryLocalServiceImpl.java}{\texttt{BookmarksEntryLocalServiceImpl}}'s
\texttt{deleteEntry} method:

\begin{verbatim}
public BookmarksEntry deleteEntry(BookmarksEntry entry)
    throws PortalException {

    bookmarksEntryPersistence.remove(entry);

    // Clean up related to additional Liferay services goes here ...  

    return entry;
}
\end{verbatim}

After implementing your \texttt{delete*} method, run Service Builder to
propagate your new service method to the \texttt{*LocalService}
interface.

\subsection{Related Topics}\label{related-topics-67}

\href{/docs/7-1/tutorials/-/knowledge_base/t/implementing-an-add-method}{Implementing
an add method}

Implementing getter and counter methods

Integrating with Liferay services

\section{Implementing Methods to Get and Count
Entities}\label{implementing-methods-to-get-and-count-entities}

Service Builder generates \texttt{findBy*} methods and \texttt{countBy*}
methods in your
\href{/docs/7-1/tutorials/-/knowledge_base/t/understanding-the-code-generated-by-service-builder}{\texttt{*Persistence}
classes} based on your \texttt{service.xml} file's
\href{/docs/7-1/tutorials/-/knowledge_base/t/defining-service-entity-finder-methods}{finders}.
You can leverage finder methods in your local services to get and count
entities.

\begin{itemize}
\tightlist
\item
  \hyperref[getter-methods]{Getters}: \texttt{get*} methods return
  entity instances matching criteria.
\item
  \hyperref[counter-methods]{Counters}: \texttt{get*Count} methods
  return the number of instances matching criteria
\end{itemize}

Start with getting entities that match criteria.

\subsection{Getter Methods}\label{getter-methods}

The \texttt{findByPrimaryKey} methods and \texttt{findBy*} methods
search for and return entity instances based on criteria. Your local
service implementation must only wrap calls to the finder methods that
get what you want.

Here's how to create a method that gets an entity based on an ID
(primary key):

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a method using this format:

\begin{verbatim}
public [ENTITY] get[ENTITY_NAME](long id) {
    return [ENTITY]Persistence.findByPrimaryKey(id);
}
\end{verbatim}
\item
  Replace \texttt{{[}ENTITY{]}} and \texttt{{[}ENTITY\_NAME{]}} with the
  respective entity type and entity name (or nickname).
\item
  Run Service Builder to propagate the method to your local service
  interface.
\end{enumerate}

Here's how to get entities based on criteria:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Identify the criteria for finding the entity instance(s).
\item
  If there is no
  \href{/docs/7-1/tutorials/-/knowledge_base/t/defining-service-entity-finder-methods}{\texttt{finder}
  element} for the criteria, create one for it and run Service Builder.
\item
  Determine the
  \href{/docs/7-1/tutorials/-/knowledge_base/t/understanding-the-code-generated-by-service-builder}{\texttt{*Persistence}
  class} \texttt{findBy*} method you want to call. Depending on your
  \texttt{finder} element columns, Service Builder might overload the
  method to include these parameters:

  \begin{itemize}
  \tightlist
  \item
    \texttt{int\ start} and \texttt{int\ end} parameters for specifying
    a range of entities.
  \item
    \texttt{com.liferay.portal.kernel.util.OrderByComparator\ orderByComparator}
    parameter for arranging the matching entities.
  \end{itemize}
\item
  Specify your \texttt{get*} method signature, making sure to account
  for the \texttt{*Persistence} class \texttt{findBy*} method parameters
  you must satisfy. Use this method format:

\begin{verbatim}
public List<[ENTITY]> get[DESCRIBE_THE_ENTITIES](...) {

}
\end{verbatim}

  Replace \texttt{{[}ENTITY{]}} with the entity type. Replace
  \texttt{{[}DESCRIBE\_THE\_ENTITIES{]}} with a descriptive name for the
  entities you're getting.
\item
  Call the \texttt{*Persistence} class \texttt{findBy*} method and
  return the list of matching entities.
\item
  Run Service Builder.
\end{enumerate}

For example, method \texttt{getGroupEntries} from
\href{https://github.com/liferay/liferay-portal/blob/7.1.0-a1/modules/apps/collaboration/bookmarks/bookmarks-service/src/main/java/com/liferay/bookmarks/service/impl/BookmarksEntryLocalServiceImpl.java}{\texttt{BookmarksEntryLocalServiceImpl}}
returns a range of \texttt{BookmarksEntry}s associated with a
\texttt{Group} primary key:

\begin{verbatim}
public List<BookmarksEntry> getGroupEntries(
    long groupId, int start, int end) {

    return bookmarksEntryPersistence.findByG_S(
        groupId, WorkflowConstants.STATUS_APPROVED, start, end,
        new EntryModifiedDateComparator());
}
\end{verbatim}

Of the \texttt{BookmarksEntry}s associated with workflows, this method
only matches approved ones
(\texttt{WorkflowConstants.STATUS\_APPROVED}). It uses a new
\texttt{EntryModifiedDateComparator} to order the matching
\texttt{BookmarksEntry}s by modification date.

Now you know how to leverage finder methods to get entities. Methods
that count entities are next.

\subsection{Counter Methods}\label{counter-methods}

Counting entities is just as easy as getting them. Your
\texttt{*Persistence} class \texttt{countBy*} methods do all the work.
Service Builder generates \texttt{countBy*} methods based on each finder
and its columns.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Identify the criteria for entity instances you're counting and
  determine the
  \href{/docs/7-1/tutorials/-/knowledge_base/t/understanding-the-code-generated-by-service-builder}{\texttt{*Persistence}
  class} \texttt{countBy*} method that satisfies the criteria.
\item
  Create a \texttt{get*Count} method signature following this format:

\begin{verbatim}
public int get[DESCRIBE_THE_ENTITIES]Count(...) {

}
\end{verbatim}

  Replace \texttt{{[}DESCRIBE\_THE\_ENTITIES{]}} with a descriptive name
  for the entities you're counting.
\item
  Call the \texttt{*Persistence} class' \texttt{countBy} method and
  return the value. For example, the method \texttt{getEntriesCount}
  from
  \href{https://github.com/liferay/liferay-portal/blob/7.1.0-a1/modules/apps/collaboration/bookmarks/bookmarks-service/src/main/java/com/liferay/bookmarks/service/impl/BookmarksEntryLocalServiceImpl.java}{\texttt{BookmarksEntryLocalServiceImpl}}
  returns the number of \texttt{BookmarksEntry}s that have a workflow
  status of \texttt{status} and that are associated with a group
  (matching \texttt{groupId}) and a folder (matching \texttt{folderId}).

\begin{verbatim}
public int getEntriesCount(long groupId, long folderId, int status) {
    return bookmarksEntryPersistence.countByG_F_S(
        groupId, folderId, status);
}
\end{verbatim}
\end{enumerate}

Now your local service can get entities matching your criteria and
return quick entity counts.

\subsection{Related Topics}\label{related-topics-68}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-local-services}{Creating
Local Services}

\href{/docs/7-1/tutorials/-/knowledge_base/t/implementing-an-add-method}{Implementing
an add method}

\href{/docs/7-1/tutorials/-/knowledge_base/t/defining-service-entity-finder-methods}{Defining
Service Entity Finder Methods}

\href{/docs/7-1/tutorials/-/knowledge_base/t/understanding-the-code-generated-by-service-builder}{Understanding
the Code Generated by Service Builder}

\section{Implementing Any Other Business
Logic}\label{implementing-any-other-business-logic}

This section's earlier local service tutorials focus on CRUD methods:
methods that \textbf{c}reate (add), \textbf{r}ead (get),
\textbf{u}pdate, and \textbf{d}elete entities. But you might also need
methods that provide business logic.

For example, Liferay Bookmarks application users \emph{open} bookmarks
(navigate to a URLs) by clicking on them.
\href{https://github.com/liferay/liferay-portal/blob/7.1.0-a1/modules/apps/collaboration/bookmarks/bookmarks-service/src/main/java/com/liferay/bookmarks/service/impl/BookmarksEntryLocalServiceImpl.java}{\texttt{BookmarksEntryLocalServiceImpl}}'s
\texttt{openEntry} method supports this functionality:

\begin{verbatim}
public BookmarksEntry openEntry(long userId, BookmarksEntry entry) {
    entry.setVisits(entry.getVisits() + 1);

    bookmarksEntryPersistence.update(entry);

    assetEntryLocalService.incrementViewCounter(
        userId, BookmarksEntry.class.getName(), entry.getEntryId(), 1);

    return entry;
}
\end{verbatim}

The \texttt{openEntry} method tracks and persists the number of visits
to the \texttt{BookmarksEntry}'s URL, increments the number of views for
the \texttt{BookmarksEntry} as an asset, and returns the
\texttt{BookmarksEntry}. This method implements required business logic
that compliments the CRUD methods.

\emph{Convenience methods} might also be appropriate for your app.
They're easier to use because they typically have these characteristics:

\begin{itemize}
\tightlist
\item
  Shorter parameter list
\item
  Intuitive name
\end{itemize}

Short parameter lists are easier to satisfy, and methods that have
intuitive names are easier to find in Javadoc.

For example, the Bookmarks application lets users move bookmarks to
different folders. Moving a bookmark can be done using the service's
\texttt{updateEntry(...)} method, but its long parameter list is
overkill since all the operation requires is the bookmarks entry and the
folder where it's going. Compare the following \texttt{update*} method
call to a convenience method call.

\textbf{Update method}:

\begin{verbatim}
bookmarksEntryLocalService.updateEntry(userId, entryId, groupId, folderId, name, url, description, serviceContext);
\end{verbatim}

\textbf{Convenience method}:

\begin{verbatim}
bookmarksEntryLocalService.moveEntry(entryId, folderId);
\end{verbatim}

Convenience methods are typically straightforward to write. Here's the
\href{https://github.com/liferay/liferay-portal/blob/7.1.0-a1/modules/apps/collaboration/bookmarks/bookmarks-service/src/main/java/com/liferay/bookmarks/service/impl/BookmarksEntryLocalServiceImpl.java}{\texttt{moveEntry}
method}:

\begin{verbatim}
public BookmarksEntry moveEntry(long entryId, long parentFolderId)
    throws PortalException {

    BookmarksEntry entry = getBookmarksEntry(entryId);

    entry.setFolderId(parentFolderId);
    entry.setTreePath(entry.buildTreePath());

    bookmarksEntryPersistence.update(entry);

    return entry;
}
\end{verbatim}

The \texttt{moveEntry} method retrieves the \texttt{BookmarksEntry}
entity by its ID, assigns it a new parent folder, updates its tree path,
persists all the entity's changes, and returns the entity. Convenience
methods like this one facilitate updating a subset of the entity's
attributes.

After implementing your custom business methods,
\href{/docs/7-1/tutorials/-/knowledge_base/t/running-service-builder}{run
Service Builder} to propagate them to the interface.

In your local services, you can implement business logic methods that
suit your application.

\textbf{Related Topics}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-local-services}{Creating
Local Services}

\href{/docs/7-1/tutorials/-/knowledge_base/t/invoking-local-services}{Invoking
Local Services}

\href{/docs/7-1/tutorials/-/knowledge_base/t/invoking-services-from-service-builder-code}{Invoking
Services from Service Builder Code}

\section{Integrating with Liferay's
Frameworks}\label{integrating-with-liferays-frameworks}

New car buyers expect certain features to be standard: power windows,
cruise control, floor mats (at least the cheap ones), and so on.
Similarly, users expect applications to have certain features and expect
those features to behave consistently across applications.

For example, a user might expect the app's content can be shared
socially on Twitter and Facebook. The user might expect a way to tag and
rate the app content, and a way to comment on it. You must meet, and
even exceed, these expectations. Liferay's frameworks implement these
features users know and love. Integrating with the frameworks is
straightforward and the frameworks provide intuitive, consistent user
experiences.

Here are some of Liferay's most popular frameworks:

\begin{itemize}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/defining-application-permissions}{Permissions}:
  Defines resource for entities and actions for performing on the
  resources.
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/configurable-applications}{Configurable
  Applications}: Makes applications configurable from within the Control
  Panel.
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/workflow}{Workflow}:
  Equips entities for reviewing in workflows before publishing.
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/item-selector}{Item
  Selector}: Provides a consistent developer experience for browsing and
  selecting entities.
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/asset-framework}{Asset
  Framework}: Makes entities more descriptive enabling users to tag,
  categorize, rate, prioritize, and comment on them. It enables users to
  relate entities to each other as assets and it allows the entities to
  be published in the Asset Publisher.

  \begin{itemize}
  \tightlist
  \item
    \href{/docs/7-1/tutorials/-/knowledge_base/t/implementing-asset-categorization-and-tagging}{Tags
    and Categories}: Enables users to tag entities and categorize the
    tagged entities.
  \item
    \href{/docs/7-1/tutorials/-/knowledge_base/t/implementing-asset-priority}{Priority}:
    Users can ascribe numerical priorities to entities.
  \item
    \href{/docs/7-1/tutorials/-/knowledge_base/t/relating-assets}{Related
    Assets}: Users can associate one entity with another as an asset.
  \item
    \href{/docs/7-1/tutorials/-/knowledge_base/t/rendering-an-asset}{Asset
    Renderer}: Enables displaying entities in the Asset Publisher.
  \item
    \href{/docs/7-1/tutorials/-/knowledge_base/t/adding-comments-to-your-app}{Comments}:
    Lets users comment on entities.
  \item
    \href{/docs/7-1/tutorials/-/knowledge_base/t/rating-assets}{Ratings}:
    Enables rating systems, such as five stars or thumbs up/down, on
    entities.
  \item
    \href{/docs/7-1/tutorials/-/knowledge_base/t/flagging-inappropriate-asset-content}{Flags}:
    Users can flag entity content as inappropriate.
  \item
    \emph{Social Bookmarks}: Users can share entity content on Twitter,
    Facebook, and more.
    (\href{https://issues.liferay.com/browse/LRDOCS-4531}{Tutorials} are
    coming soon.)
  \end{itemize}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/export-import-and-staging}{Export/Import}:
  Lets users export entity data to and import entity data from files
  (\texttt{.lpkg} files). Exported data can be imported to another
  portal instance or saved for later use.
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/export-import-and-staging}{Staging}:
  Lets users change entities behind the scenes without affecting the
  live site.
\item
  \emph{Search}: Enables entities to be found and shown in Liferay DXP
  search results.
  (\href{https://issues.liferay.com/browse/LRDOCS-4372}{Tutorials} are
  coming soon.)
\item
  \emph{Recycle Bin}: Entities can be moved from the application and put
  them into the Recycle Bin. Entities can be restored from the Recycle
  Bin or deleted permanently (manually or per a schedule).
  (\href{https://issues.liferay.com/browse/LRDOCS-4505}{Tutorials} are
  coming soon.)
\end{itemize}

Liferay's frameworks are rich with features users expect in
applications. Click on the framework tutorial links to start leveraging
the frameworks. Next are tutorials on invoking local services.

\subsection{Related Topics:}\label{related-topics-69}

\href{/docs/7-1/tutorials/-/knowledge_base/t/internationalization}{Internationalization}

\href{/docs/7-1/tutorials/-/knowledge_base/t/javascript-module-loaders}{JavaScript
Module Loaders}

\href{/docs/7-1/tutorials/-/knowledge_base/t/front-end-taglibs}{Front-End
Taglibs}

\href{/docs/7-1/tutorials/-/knowledge_base/t/data-upgrades}{Data
Upgrades}

\section{Invoking Local Services}\label{invoking-local-services}

Once you deploy your services module, those services are available in
the container. Service Builder generates local and remote service
classes as OSGi Declarative Services (DS) components. These components
are accessible to other DS components, so you can invoke them from other
components, such as your web application. Here's how:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \hyperref[step-1-reference-the-local-service-component]{Add a
  reference to the local service component.}
\item
  \hyperref[step-2-call-the-components-methods]{Call the component's
  methods.}
\end{enumerate}

There's a Blade sample called
\href{/docs/7-1/reference/-/knowledge_base/r/service-builder-samples}{Basic
Service Builder}. Its \texttt{basic-web} module has a \texttt{Portlet}
service component that demonstrates referencing a local service
component. This module also has JSPs that invoke the component's
methods. Your first step is to add a reference to the local service
component object.

\subsection{Step 1: Reference the Local Service
Component}\label{step-1-reference-the-local-service-component}

Your application's Service Builder-generated local services are DS
components that you can inject into your application's other DS
components (classes annotated with \texttt{@Component})
\href{/docs/7-1/tutorials/-/knowledge_base/t/osgi-services-and-dependency-injection-with-declarative-services}{using
the \texttt{@Reference} annotation}. The \texttt{basic-web} module's
\texttt{JSPPortlet} class is a \texttt{Portlet} service component that
references the \texttt{FooLocalService} local service as a DS component.

\begin{verbatim}
@Reference
private volatile FooLocalService _fooLocalService;
\end{verbatim}

The OSGi service registry wires the service implementation object to
your class that references it. The \texttt{JSPPortlet} sample class
declares the \texttt{\_fooLocalService} field to be volatile, but making
a field volatile is completely optional.

\noindent\hrulefill

\textbf{Note}: Service Builder generates \texttt{*LocalServiceImpl},
\texttt{*ServiceImpl}, \texttt{*PersistenceImpl}, and
\texttt{{[}ENTITY\_NAME{]}Impl} classes for your entities as Service
Builder Spring Beans---not OSGi Declarative Services.
\href{/docs/7-1/tutorials/-/knowledge_base/t/invoking-services-from-service-builder-code}{Service
Builder Spring Beans must use means other than the \texttt{@Reference}
annotation to reference Liferay services and OSGi services}.

\noindent\hrulefill

\textbf{Important:} You should never invoke \texttt{*LocalServiceImpl}
objects directly. You should only invoke them indirectly through their
\texttt{*LocalService} service interface. The OSGi service registry
wires the service implementation object to your class.

You can make a service object available to JSPs by associating it with a
\texttt{RenderRequest} attribute. For example, the \texttt{JSPPortlet}'s
\texttt{render} method associates the \texttt{FooLocalService} object
with an attribute called \texttt{fooLocalService}.

\begin{verbatim}
@Override
public void render(RenderRequest request, RenderResponse response)
    throws IOException, PortletException {

    //set service bean
    request.setAttribute("fooLocalService", getFooLocalService());

    super.render(request, response);
}

public FooLocalService getFooLocalService() {
    return _fooLocalService;
}
\end{verbatim}

If your JSP declares the
\texttt{\textless{}portlet:defineObjects\ /\textgreater{}} tag, it can
retrieve the service object from the \texttt{RenderRequest} attribute.
For example, the \texttt{JSPPortlet}'s \texttt{init.jsp} file retrieves
the \texttt{FooLocalService} object from the \texttt{"fooLocalService"}
attribute.

\begin{verbatim}
...
<%@
page import="com.liferay.blade.samples.servicebuilder.service.FooLocalService" %>
...

<liferay-theme:defineObjects />

<portlet:defineObjects />

<%
...

//get service bean
FooLocalService fooLocalService = (FooLocalService)request.getAttribute("fooLocalService");
%>
\end{verbatim}

All JSPs that include the above \texttt{init.jsp} can use the
\texttt{fooLocalService} variable to invoke the local service
component's methods.

\subsection{Step 2: Call the Component's
Methods}\label{step-2-call-the-components-methods}

Now that you have the service component object, you can invoke its
methods as you would any Java object's methods.

The \texttt{basic-web} sample module's \texttt{view.jsp} and
\texttt{edit\_foo.jsp} files include the \texttt{init.jsp} shown in the
previous section. Therefore, they can access the
\texttt{fooLocalService} variable which references the service component
object. The \texttt{view.jsp} file uses the component's
\texttt{getFoosCount} method and \texttt{getFoos} method in a Liferay
Search Container that lists \texttt{Foo} instances.

\begin{verbatim}
<liferay-ui:search-container
    total="<%= fooLocalService.getFoosCount() %>"
>
    <liferay-ui:search-container-results
        results="<%= fooLocalService.getFoos(searchContainer.getStart(), searchContainer.getEnd()) %>"
    />
    ...
</liferay-ui:search-container>
\end{verbatim}

The \texttt{edit\_foo.jsp} file calls \texttt{getFoo(long\ id)} to
retrieve a \texttt{Foo} entity based on the entity instance's ID.

\begin{verbatim}
long fooId = ParamUtil.getLong(request, "fooId");
Foo foo = null;
if (fooId > 0) {
    foo = fooLocalService.getFoo(fooId);
}
\end{verbatim}

\noindent\hrulefill

\textbf{Important:} When invoking service entity updates (e.g.,
\texttt{fooService.update(object)}) for services that have MVCC enabled,
make sure to do so in transactions. Propagate rejected transactions to
the UI for the user to handle. For details, see
\href{/docs/7-1/tutorials/-/knowledge_base/t/defining-global-service-information\#multiversion-concurrency-control-mvcc}{Multiversion
concurrency control (MVCC)}.

\noindent\hrulefill

Using the \texttt{@Reference} annotation, you can inject your
application's OSGi DS components (such as a portlet DS component) with
instances of your application's Service Builder-generated local service
components. Also you can provide your JSPs access to the component
instances via \texttt{RenderRequest} attributes.

\subsection{Related Topics}\label{related-topics-70}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-local-services}{Creating
Local Services}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-remote-services}{Creating
Remote Services}

\href{/docs/7-1/tutorials/-/knowledge_base/t/invoking-remote-services}{Invoking
Remote Services}

\href{/docs/7-1/tutorials/-/knowledge_base/t/service-security-layers}{Service
Security Layers}

\href{/docs/7-1/tutorials/-/knowledge_base/t/invoking-services-from-service-builder-code}{Invoking
Services from Service Builder Code}

\href{/docs/7-1/tutorials/-/knowledge_base/t/osgi-services-and-dependency-injection-with-declarative-services}{OSGi
Services and Dependency Injection with Declarative Services}

\section{Invoking Services from Service Builder
Code}\label{invoking-services-from-service-builder-code}

All the services created within a Service Builder application are wired
using an internal Spring Application Context. This uses AOP proxies to
adapt the services for transactions, indexing, and security. In a
module's \texttt{module-spring.xml} Spring Application Context file,
Service Builder defines each entity's \texttt{*LocalServiceImpl},
\texttt{*ServiceImpl}, and \texttt{*PersistenceImpl} classes as Spring
Beans. For example, Service Builder defines Spring Beans for the
\texttt{Foo} entity in the
\href{/docs/7-1/reference/-/knowledge_base/r/service-builder-samples}{Liferay
Blade Service Builder \texttt{basic-service} sample module's}
\texttt{src/main/resources/META-INF/spring/module-spring.xml} file:

\begin{verbatim}
<?xml version="1.0"?>

<beans
    default-destroy-method="destroy"
    default-init-method="afterPropertiesSet"
    xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"
>
    <bean class="com.liferay.blade.samples.servicebuilder.service.impl.FooLocalServiceImpl" id="com.liferay.blade.samples.servicebuilder.service.FooLocalService" />
    <bean class="com.liferay.blade.samples.servicebuilder.service.impl.FooServiceImpl" id="com.liferay.blade.samples.servicebuilder.service.FooService" />
    <bean class="com.liferay.blade.samples.servicebuilder.service.persistence.impl.FooPersistenceImpl" id="com.liferay.blade.samples.servicebuilder.service.persistence.FooPersistence" parent="basePersistence" />
</beans>
\end{verbatim}

Here's a summary of the beans the example context defines:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.4118}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.5882}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
\textbf{Interface ID}
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\textbf{Implementation Class}
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{com.liferay.blade.samples.servicebuilder.service.FooLocalService}
&
\texttt{com.liferay.blade.samples.servicebuilder.service.impl.FooLocalServiceImpl} \\
\texttt{com.liferay.blade.samples.servicebuilder.service.FooService} &
\texttt{com.liferay.blade.samples.servicebuilder.service.impl.FooServiceImpl} \\
\texttt{com.liferay.blade.samples.servicebuilder.service.persistence.FooPersistence}
&
\texttt{com.liferay.blade.samples.servicebuilder.service.persistence.impl.FooPersistenceImpl} \\
\end{longtable}

Since these classes are Spring Beans and NOT OSGi Declarative Services
components, they use annotations other than the \texttt{@Reference}
Declarative Services annotation to inject Spring Beans and OSGi
services. Here are the recommended Liferay annotations a Service Builder
Spring Bean can use.

\begin{itemize}
\tightlist
\item
  \hyperref[referencing-a-spring-bean-that-is-in-the-application-context]{Use
  \texttt{@BeanReference} to reference a Spring Bean that is in the
  Application Context.}
\item
  \hyperref[referencing-osgi-services]{Use \texttt{@ServiceReference} to
  reference an OSGi service.}
\end{itemize}

\noindent\hrulefill

\textbf{Important:} When invoking service entity updates (e.g.,
\texttt{fooService.update(object)}) for services that have MVCC enabled,
make sure to do so in transactions. Propagate rejected transactions to
the UI for the user to handle. For details, see
\href{/docs/7-1/tutorials/-/knowledge_base/t/defining-global-service-information\#multiversion-concurrency-control-mvcc}{Multiversion
concurrency control (MVCC)}.

\noindent\hrulefill

The \texttt{@BeanReference} annotation is explained first.

\subsection{Referencing a Spring Bean that is in the Application
Context}\label{referencing-a-spring-bean-that-is-in-the-application-context}

A Service Builder Spring Bean class, such as a
\texttt{*LocalServiceImpl} class, should use Liferay's
\texttt{@BeanReference} annotation to access other Spring Beans the
module's Spring Application Context defines.

For example, if your service module's \texttt{service.xml} file defines
local services for entities named \texttt{Foo} and \texttt{Bar}, Service
Builder generates a \texttt{module-spring.xml} file that defines local
service Spring Beans for both entities. To inject the
\texttt{BarLocalService} Spring Bean into the
\texttt{FooLocalServiceImpl} class, for example, the
\texttt{FooLocalServiceImpl} class would declare a
\texttt{BarLocalService} field and apply an \texttt{@BeanReference}
annotation to it.

\begin{verbatim}
@BeanReference
private BarLocalService _barLocalService;
\end{verbatim}

The \texttt{@BeanReference} lets Liferay's AOP treat the bean reference
for use in transactions, search indexing, or security, if needed. The
referencing class can invoke the Spring Bean class's methods.

Besides the services Service Builder makes available for your
application, Service Builder Spring Bean classes can also access any
service published in the OSGi Registry. This means the following
services are available:

\begin{itemize}
\tightlist
\item
  Beans defined in Liferay's core
\item
  Beans created in other module app contexts
\item
  Services declared using OSGi Declarative Services
\item
  Services registered using the OSGi low level API
\end{itemize}

These are all OSGi services. The next section demonstrates a Service
Builder Spring Bean referencing OSGi services.

\subsection{Referencing OSGi Services}\label{referencing-osgi-services}

In many cases, your Service Builder code (Spring Beans) must use
external services. Liferay's \texttt{@ServiceReference} annotation lets
Liferay Spring Beans reference OSGi services.

Suppose you're building an application with a simple entity your service
module defines in its \texttt{service.xml} file. The application must
send an SMS every time a new entity is created, and the
\texttt{SMSService} is provided by a module installed in the system.

Your \texttt{*LocalServiceImpl} (Spring Bean) could use an
\texttt{@ServiceReference} annotation to reference the \emph{external}
service.

\begin{verbatim}
@ServiceReference
private SMSService _smsService;
\end{verbatim}

This annotation retrieves a reference to the OSGi service and provides
some nice benefits. None of the Spring context is created until the
\texttt{SMSService} service is available. Likewise, if the
\texttt{SMSService} suddenly disappears, the whole Spring Application
Context is destroyed. This makes Liferay Spring apps much more robust
and versatile.

Fortunately, Service Builder generates this kind of code for every
entity your \texttt{service.xml} file references. For example, the
\href{/docs/7-1/reference/-/knowledge_base/r/service-builder-samples}{Liferay
Blade Service Builder sample project} \texttt{basic-service} module's
\texttt{service.xml} file defines a \texttt{Foo} entity that references
an \texttt{AssetEntry} entity:

\begin{verbatim}
<reference entity="AssetEntry" package-path="com.liferay.portlet.asset" />
\end{verbatim}

Service Builder generated the \texttt{FooLocalServiceBaseImpl} class
(the base class is part of the \texttt{FooLocalServiceImpl} class's
hierarchy), which references the \texttt{AssetEntry} entity's local
service \texttt{AssetEntryLocalService} using a field annotated with
\texttt{@ServiceReference}:

\begin{verbatim}
@ServiceReference(type = com.liferay.asset.kernel.service.AssetEntryLocalService.class)
protected com.liferay.asset.kernel.service.AssetEntryLocalService assetEntryLocalService;
\end{verbatim}

Great! You now know how to add a reference to any OSGi service to a
Service Builder Spring Bean. You also know how to add a reference to any
other Spring Bean in the Application Context of your Service Builder
Spring Bean.

\subsection{Related Topics}\label{related-topics-71}

\href{/docs/7-1/tutorials/-/knowledge_base/t/invoking-local-services}{Invoking
Local Services}

\href{/docs/7-1/tutorials/-/knowledge_base/t/invoking-remote-services}{Invoking
Remote Services}

\href{/docs/7-1/tutorials/-/knowledge_base/t/json-web-services-invoker}{JSON
Web Services Invoker}

\href{/docs/7-1/tutorials/-/knowledge_base/t/service-trackers}{Service
Trackers}

\chapter{Application Security}\label{application-security}

Liferay's development framework provides an application security
platform that's got years of experience behind it. You don't need to
roll your own security for your applications. Instead, you can specify
security for your applications using Liferay's framework.

Beyond security for applications, there are many ways to extend the
default security model by customizing the authentication process. This
group of tutorials teaches you about them:

\begin{itemize}
\tightlist
\item
  Resources, Roles, and Permissions
\item
  Custom SSO Providers
\item
  Authentication Pipelines
\item
  Service Access Policies
\item
  Authentication Verifiers
\end{itemize}

\section{Defining Application
Permissions}\label{defining-application-permissions}

When you're writing an application, there are almost always parts of the
application or its data that should be protected by permissions. Some
users should access all the functions or data, but most users shouldn't.

On many platforms, developers have to create the security model
themselves. On Liferay DXP, an application security model has been
provided for you; you only need to make use of it.

Fortunately, no matter what your application does, access to it and to
its content can be controlled with permissions. Read on to learn about
Liferay's permissions system and how add permissions to your
application.

The permissions system has three parts: \emph{Resources},
\emph{Actions}, and \emph{Permissions}.

\textbf{Action}: An operation that can be performed by a user. For
example, users can perform these actions on the Bookmarks application:
\texttt{ADD\_TO\_PAGE}, \texttt{CONFIGURATION}, and \texttt{VIEW}. Users
can perform these actions on Bookmarks entry entities:
\texttt{ADD\_ENTRY}, \texttt{DELETE}, \texttt{PERMISSIONS},
\texttt{UPDATE}, and \texttt{VIEW}.

\textbf{Resource}: A generic representation of any application or entity
on which an action can be performed. Resources are used for permission
checking. For example, resources could include the RSS application with
instance ID \texttt{hF5f}, a globally scoped Wiki page, a Bookmarks
entry of the site X, and a Message Boards post with the ID
\texttt{5052}.

\textbf{Permission}: A flag that determines whether an action can be
performed on a resource. In the database, resources and actions are
saved in pairs. Each entry in the \texttt{ResourceAction} table contains
both the name of a portlet or entity and the name of an action. For
example, the \texttt{VIEW} action with respect to \emph{viewing the
Bookmarks application} is associated with the
\texttt{com\_liferay\_bookmarks\_web\_portlet\_BookmarksPortlet} portlet
ID. The \texttt{VIEW} actions with respect to \emph{viewing a Bookmarks
Folder} or \emph{viewing a Bookmarks entry} are associated with the
\texttt{com.liferay.bookmarks.model.BookmarksFolder} and
\texttt{com.liferay.bookmarks.model.BookmarksEntry} entities,
respectively.

To do permissions, therefore, you define \emph{Users} (Roles) who have
\emph{Permission} to perform \emph{Actions} on \emph{Resources}. User
definition is done by administrators once your application is deployed;
developers define resources, actions, and default permissions.

You can implement permissions in your applications in four steps that
spell the acronym \emph{DRAC}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Define all resources and their permissions.
\item
  Register all defined resources in the permissions system.
\item
  Associate the necessary permissions with resources.
\item
  Check permission before returning resources.
\end{enumerate}

The next four tutorials show these steps in detail.

\section{Defining Resources and
Permissions}\label{defining-resources-and-permissions}

Your first step in implementing permissions is to define the resources
and the permissions that protect them. There are two different kinds of
resources: \emph{portlet resources} and \emph{model resources}.

Portlet resources represent portlets. The names of portlet resources are
the portlet IDs from the portlets' \texttt{@Component} properties or if
you're using a WAR file, \texttt{portlet.xml} files. Model resources
refer to model objects, usually persisted as entities to a database. The
names of model resources are their fully qualified class names. In the
XML displayed below, permission implementations are first defined for
the \emph{portlet} resource and then for the \emph{model} resources.

Model resources represent models, such as blog entries. Resources are
named using the fully qualified class names of the entities they
represent.

\noindent\hrulefill

\textbf{Note:} For each resource, there are four scopes to which the
permissions can be applied: company, group, group-template, or
individual. Because these are called \emph{portlet resources} here and
in the code, this can be confusing. The other scopes are mostly used
internally for various Liferay constructs (such as Sites or Categories).

\noindent\hrulefill

You define resources and their permissions using an XML file. By
convention, this file is called \texttt{default.xml} and exists in a
module's \texttt{src/main/resources/resource-actions} folder.

Because of the two different types of resources, you'll have two of
these files: one in your portlet module to define the portlet resources
and one in your service module to define the model resources.

\subsection{Defining Portlet Resource
Permissions}\label{defining-portlet-resource-permissions}

Define the portlet resources first; here's an example using Liferay's
Blogs application.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Start with the DTD declaration:

\begin{verbatim}
<?xml version="1.0"?>
<!DOCTYPE resource-action-mapping PUBLIC "-//Liferay//DTD Resource Action Mapping 7.1.0//EN" "http://www.liferay.com/dtd/liferay-resource-action-mapping_7_0_0.dtd">
\end{verbatim}
\item
  The root tag contains all the resources to be declared:

\begin{verbatim}
<resource-action-mapping>

</resource-action-mapping> 
\end{verbatim}
\item
  Inside these tags, define your resources. The Blogs application
  defines two portlet resources:

\begin{verbatim}
<portlet-resource>
    <portlet-name>com_liferay_blogs_web_portlet_BlogsAdminPortlet</portlet-name>
    <permissions>
        <supports>
            <action-key>ACCESS_IN_CONTROL_PANEL</action-key>
            <action-key>CONFIGURATION</action-key>
            <action-key>VIEW</action-key>
        </supports>
        <site-member-defaults>
            <action-key>VIEW</action-key>
        </site-member-defaults>
        <guest-defaults>
            <action-key>VIEW</action-key>
        </guest-defaults>
        <guest-unsupported>
            <action-key>ACCESS_IN_CONTROL_PANEL</action-key>
            <action-key>CONFIGURATION</action-key>
        </guest-unsupported>
    </permissions>
</portlet-resource>
<portlet-resource>
    <portlet-name>com_liferay_blogs_web_portlet_BlogsPortlet</portlet-name>
    <permissions>
        <supports>
            <action-key>ADD_PORTLET_DISPLAY_TEMPLATE</action-key>
            <action-key>ADD_TO_PAGE</action-key>
            <action-key>CONFIGURATION</action-key>
            <action-key>VIEW</action-key>
        </supports>
        <site-member-defaults>
            <action-key>VIEW</action-key>
        </site-member-defaults>
        <guest-defaults>
            <action-key>VIEW</action-key>
        </guest-defaults>
        <guest-unsupported>
            <action-key>ADD_PORTLET_DISPLAY_TEMPLATE</action-key>
            <action-key>CONFIGURATION</action-key>
        </guest-unsupported>
    </permissions>
</portlet-resource>
\end{verbatim}
\end{enumerate}

The Blogs application comprises two portlets: the Blogs portlet itself
and the Blogs Admin portlet that appears in the Site menu for
administrators. Define your portlets by their names, and then list the
permissions for the portlet. The Blogs portlet, for example, supports
four permissions: ADD\_PORTLET\_DISPLAY\_TEMPLATE, ADD\_TO\_PAGE,
CONFIGURATION, and VIEW. The Blogs Admin portlet has an additional
permission: ACCESS\_IN\_CONTROL\_PANEL, which defines who can see the
entry in the Site menu.

Once you've defined permissions at the portlet level, you can set
default permissions for different types of users. The DTD allows for
site member and guest defaults. Since guests are users that aren't
logged in, there's also a \texttt{guest-unsupported} tag for defining
permissions guests can \emph{never} have (in other words, the user must
be logged in and identifiable).

That's all there is to it! Your next task is to define permissions for
your model resources.

\subsection{Defining Model Resource
Permissions}\label{defining-model-resource-permissions}

Defining permissions for models is a similar process. Create a
\texttt{default.xml} file in your service module's
\texttt{src/main/resources/resource-actions} folder. In this file, you
must define top-level function permissions and individual entity
permissions using the same
\texttt{\textless{}model-resource\textgreater{}} tag.

This can be confusing, so some explanation is in order. Model
permissions for what Liferay calls the \emph{root model} are defined
separately from permissions on stored entities, which Liferay calls the
\emph{model}. This makes sense when you think about the functions users
can perform:

\begin{itemize}
\tightlist
\item
  Creating something new
\item
  Editing something that exists
\end{itemize}

Creating something new (like adding a new Blog entry) is different from
accessing something that exists. A Blog owner should be able to create
or edit a Blog entry, but a User or guest should have read permission
for existing entries and no permission to create them.

Permission to create something new that doesn't yet exist is a
\emph{root model} permission, whether that functionality is exposed in a
portlet or not. Permission on an existing resource is a \emph{model}
permission.

Now you're ready to define both your root model and model permissions.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  First, create the skeleton for your file:

\begin{verbatim}
<?xml version="1.0"?>
<!DOCTYPE resource-action-mapping PUBLIC "-//Liferay//DTD Resource Action Mapping 7.1.0//EN" "http://www.liferay.com/dtd/liferay-resource-action-mapping_7_0_0.dtd">

<resource-action-mapping>

</resource-action-mapping> 
\end{verbatim}
\item
  Inside the \texttt{\textless{}resource-action-mapping\textgreater{}}
  tags, use a \texttt{\textless{}model-resource\textgreater{}} tag to
  define permissions for the root model:

\begin{verbatim}
<model-resource>
    <model-name>com.liferay.blogs</model-name>
    <portlet-ref>
        <portlet-name>com_liferay_blogs_web_portlet_BlogsAdminPortlet</portlet-name>
        <portlet-name>com_liferay_blogs_web_portlet_BlogsPortlet</portlet-name>
    </portlet-ref>
    <root>true</root>
    <weight>1</weight>
    <permissions>
        <supports>
            <action-key>ADD_ENTRY</action-key>
            <action-key>PERMISSIONS</action-key>
            <action-key>SUBSCRIBE</action-key>
        </supports>
        <site-member-defaults>
            <action-key>SUBSCRIBE</action-key>
        </site-member-defaults>
        <guest-defaults />
        <guest-unsupported>
            <action-key>ADD_ENTRY</action-key>
            <action-key>PERMISSIONS</action-key>
            <action-key>SUBSCRIBE</action-key>
        </guest-unsupported>
    </permissions>
</model-resource>
\end{verbatim}

  The model name (\texttt{com.liferay.blogs}) is just a package name.
  The
  \texttt{\textless{}root\textgreater{}true\textless{}/root\textgreater{}}
  tag defines this as a root model. The
  \texttt{\textless{}portlet-ref\textgreater{}} element is the name of
  the portlet that uses the model. The
  \texttt{\textless{}weight\textgreater{}} tag defines the order of
  these permissions in the GUI. The permissions defined are ADD\_ENTRY
  (add a Blog entry), PERMISSIONS (set permissions on Blog entries), and
  SUBSCRIBE (receive notifications when Blog entries are created). These
  are all root model permissions, because no primary key in the database
  can be assigned to any of these functions. The default permissions
  (for both model and portlet resources) are added when the portlet
  defined by the \texttt{\textless{}portlet-ref\textgreater{}} tag
  initializes.
\item
  Finally, define your model permissions:

\begin{verbatim}
<model-resource>
    <model-name>com.liferay.blogs.model.BlogsEntry</model-name>
    <portlet-ref>
        <portlet-name>com_liferay_blogs_web_portlet_BlogsAdminPortlet</portlet-name>
        <portlet-name>com_liferay_blogs_web_portlet_BlogsPortlet</portlet-name>
    </portlet-ref>
    <weight>2</weight>
    <permissions>
        <supports>
            <action-key>ADD_DISCUSSION</action-key>
            <action-key>DELETE</action-key>
            <action-key>DELETE_DISCUSSION</action-key>
            <action-key>PERMISSIONS</action-key>
            <action-key>UPDATE</action-key>
            <action-key>UPDATE_DISCUSSION</action-key>
            <action-key>VIEW</action-key>
        </supports>
        <site-member-defaults>
            <action-key>ADD_DISCUSSION</action-key>
            <action-key>VIEW</action-key>
        </site-member-defaults>
        <guest-defaults>
            <action-key>ADD_DISCUSSION</action-key>
            <action-key>VIEW</action-key>
        </guest-defaults>
        <guest-unsupported>
            <action-key>DELETE</action-key>
            <action-key>DELETE_DISCUSSION</action-key>
            <action-key>PERMISSIONS</action-key>
            <action-key>UPDATE</action-key>
            <action-key>UPDATE_DISCUSSION</action-key>
        </guest-unsupported>
    </permissions>
</model-resource>
\end{verbatim}

  Note the lack of a \texttt{\textless{}root\textgreater{}} tag, the
  fully qualified class name for the model, and the permissions that
  operate on an entity with a primary key.
\end{enumerate}

\subsection{Enabling Your Permissions
Configuration}\label{enabling-your-permissions-configuration}

Your last step is to enable your permission definitions. Each module
that contains a \texttt{default.xml} permissions definition file must
also have a \texttt{portlet.properties} file with a property that
defines where to find the permissions definition file. For your service
and your web modules, create a \texttt{portlet.properties} file in
\texttt{src/main/resources} and make sure it has this property:

\begin{verbatim}
resource.actions.configs=resource-actions/default.xml
\end{verbatim}

Once you've defined portlet permissions, root model permissions, and
model permissions, you've completed step 1 (the \emph{D} in DRAC).
Congratulations! You're now ready to \emph{register} the resources
you've now defined in the permissions system.

\section{Registering Permissions}\label{registering-permissions}

Defining permissions was your first step; now you're ready to register
the permissions you've defined. You must register your entities both in
the database and in the permissions service running in the OSGi
container.

\subsection{Registering Permissions Resources in the
Database}\label{registering-permissions-resources-in-the-database}

All this takes is a call to Liferay's resource service in your service
layer. If you're using Service Builder, this is very easy to do.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open your \texttt{-LocalServiceImpl} class.
\item
  In your method that adds an entity, add a call to add a resource with
  the entity. For example, Liferay's Blogs application adds resources
  this way:

\begin{verbatim}
resourceLocalService.addResources(
    entry.getCompanyId(), entry.getGroupId(), entry.getUserId(),
    BlogsEntry.class.getName(), entry.getEntryId(), false,
    addGroupPermissions, addGuestPermissions);
\end{verbatim}

  This method requires passing in the company ID, the group ID, the user
  ID, the entity's class name, the entity's primary key, and some
  boolean settings. In order, these settings define

  \begin{itemize}
  \tightlist
  \item
    Whether the permission is a portlet resource
  \item
    Whether the default group permissions defined in
    \texttt{default.xml} should be added
  \item
    Whether the default guest permissions defined in
    \texttt{default.xml} should be added
  \end{itemize}
\end{enumerate}

Note that the resource local service is injected automatically into your
Service Builder-generated service.

If you're not using Service Builder, but you are using OSGi modules for
your application, you should be able to inject the resource service with
an \texttt{@Reference} annotation. If you're building a WAR-style
plugin, you need a
\href{/docs/7-1/tutorials/-/knowledge_base/t/service-trackers}{service
tracker} to gain access to the service. Note that your model classes
must also implement Liferay's \texttt{ClassedModel} interface.

Similarly, when you delete an entity, you should also delete its
associated resource. Here's how the Blogs application does it in its
\texttt{deleteEntry()} method:

\begin{verbatim}
    resourceLocalService.deleteResource(
        entry.getCompanyId(), BlogsEntry.class.getName(),
        ResourceConstants.SCOPE_INDIVIDUAL, entry.getEntryId());
\end{verbatim}

As with adding resources, the method needs to know the entity's company
ID, class, and primary key. Most of the time, its scope is an individual
entity of your own choosing. Other scopes available as constants are for
company, group, or group template (site template). These are used
internally for those objects, so you'd only use them if you were
customizing functionality for creating and deleting them.

Now you're ready to register your entities with the permissions service.

\subsection{Registering Entities to the Permissions
Service}\label{registering-entities-to-the-permissions-service}

The permissions service that's running must know about your entities and
how to check permissions for them. This requires creating a permissions
registrar class.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In your service bundle, create a package that by convention ends in
  \texttt{internal.security.permission.resource}. For example, the Blogs
  application's package is named
  \texttt{com.liferay.blogs.internal.security.permission.resource}.
\item
  Create a class in this package called
  \texttt{{[}Entity\ \ \ \ \ Name{]}ModelResourcePermissionRegistrar}.
  For example, the Blogs application's class is named
  \texttt{BlogsEntryModelResourcePermissionRegistrar}.
\item
  This class is a component class that requires overriding the
  \texttt{activate} method to register the permissions logic you want
  for your entities. For example, this is how the Blogs application
  registers its permissions:

\begin{verbatim}
@Component(immediate = true)
public class BlogsEntryModelResourcePermissionRegistrar {

    @Activate
    public void activate(BundleContext bundleContext) {
        Dictionary<String, Object> properties = new HashMapDictionary<>();

        properties.put("model.class.name", BlogsEntry.class.getName());

        _serviceRegistration = bundleContext.registerService(
            ModelResourcePermission.class,
            ModelResourcePermissionFactory.create(
                BlogsEntry.class, BlogsEntry::getEntryId,
                _blogsEntryLocalService::getEntry, _portletResourcePermission,
                (modelResourcePermission, consumer) -> {
                    consumer.accept(
                        new StagedModelPermissionLogic<>(
                            _stagingPermission, BlogsPortletKeys.BLOGS,
                            BlogsEntry::getEntryId));
                    consumer.accept(
                        new WorkflowedModelPermissionLogic<>(
                            _workflowPermission, modelResourcePermission,
                            BlogsEntry::getEntryId));
                }),
            properties);
    }

    @Deactivate
    public void deactivate() {
        _serviceRegistration.unregister();
    }

    @Reference
    private BlogsEntryLocalService _blogsEntryLocalService;

    @Reference(target = "(resource.name=" + BlogsConstants.RESOURCE_NAME + ")")
    private PortletResourcePermission _portletResourcePermission;

    private ServiceRegistration<ModelResourcePermission> _serviceRegistration;

    @Reference
    private StagingPermission _stagingPermission;

    @Reference
    private WorkflowPermission _workflowPermission;

}
\end{verbatim}
\end{enumerate}

We call these types of classes Registrars because the classes' job is to
configure, register and unregister the \texttt{ModelResourcePermission}.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  The \texttt{model.class.name} is set in the properties so that other
  modules' service trackers can find this model resource permission by
  its type when it's needed. Liferay has several service trackers
  checking for model resource permissions. The \texttt{service.ranking}
  property can also be set to a value greater than zero to override
  other module's model resource permissions.
\item
  This registrar uses two portal-kernel permission logic classes for
  Staging and Workflow. Custom logic classes can be reused or composed
  inline since \texttt{ModelResourcePermissionLogic} is a
  \texttt{@FunctionalInterface}. Permission logic classes are executed
  in order of when they are accepted in the \texttt{Consumer}.
\item
  \texttt{ModelResourcePermissionLogic} classes return \texttt{true}
  when users have permission for the action, \texttt{false} when they
  are denied permission for the action, and \texttt{null} when wanting
  to delegate responsibility to the next permission logic. If all
  permission logics return null then the
  \texttt{PermissionChecker.hasPermission} method is called to determine
  if the action is allowed for the user.
\end{enumerate}

This class uses an \texttt{@Reference} with the target filter to inject
the appropriate \texttt{PortletResourcePermission}.
\texttt{BlogsConstants.RESOURCE\_NAME} evaluates to
\texttt{com.liferay.blogs}, which is defined in the \texttt{default.xml}
you created earlier. If you were to reference this
\texttt{ModelResourcePermission}, you'd use a target filter matching the
\texttt{model.class.name} property set in the \texttt{activate} method.

Note that you specify your entity's class, primary key, and the entity
itself for the factory so it can create permission objects specific to
your entity.

Great! You've now completed step 2 in \emph{DRAC} by registering your
permissions. Now you're ready to provide users the interface to
associate permissions with resources.

\section{Associating Permissions with
Resources}\label{associating-permissions-with-resources}

Now that you've defined and registered permissions, you must expose the
permissions interface so users can set permissions.

To allow permissions to be configured for model resources, you must add
the permissions interface to the UI. Add these two Liferay UI tags to
your JSP:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \texttt{\textless{}liferay-security:permissionsURL\textgreater{}}:
  Returns a URL to the permission settings configuration page.
\item
  \texttt{\textless{}liferay-ui:icon\textgreater{}}: Shows an icon to
  the user. These are defined in the theme and one of them (see below)
  is used for permissions.
\end{enumerate}

The Blogs application uses these tags like this:

\begin{verbatim}
    <liferay-security:permissionsURL
                modelResource="<%= BlogsEntry.class.getName() %>"
                modelResourceDescription="<%= BlogsEntryUtil.getDisplayTitle(resourceBundle, entry) %>"
                resourceGroupId="<%= String.valueOf(entry.getGroupId()) %>"
                resourcePrimKey="<%= String.valueOf(entry.getEntryId()) %>"
                var="permissionsEntryURL"
                windowState="<%= LiferayWindowState.POP_UP.toString() %>"
            />

            <liferay-ui:icon
                label="<%= true %>"
                message="permissions"
                method="get"
                url="<%= permissionsEntryURL %>"
                useDialog="<%= true %>"
            />
\end{verbatim}

For the
\texttt{\textless{}liferay-security:permissionsURL\ /\textgreater{}}
tag, specify these attributes:

\texttt{modelResource}: The fully qualified class name of the entity
class. This class name gets translated into a more readable name as
specified in \texttt{Language.properties}.

\texttt{Language.properties}: The entity class in the example above is
the Blogs entry class for which the fully qualified class name is
\texttt{com.liferay.blogs.model.BlogsEntry}.

\texttt{modelResourceDescription}: You can enter anything that best
describes this model instance. In the example above, the Blog title is
used for the model resource description.

\texttt{resourcePrimKey}: Your entity's primary key.

\texttt{var}: The name of the variable to which the resulting URL string
is assigned. The variable is then passed to the
\texttt{\textless{}liferay-ui:icon\textgreater{}} tag so the permission
icon has the proper URL link.

There's an optional attribute called \texttt{redirect} that's available
if you want to override the default behavior of the upper right arrow
link. That's it; now your users can configure the permission settings
for model resources!

You've completed step 3 in \emph{DRAC}. Your next step is to check for
permissions in the appropriate areas of your application.

\section{Checking Permissions}\label{checking-permissions}

Now that you've defined your permissions, registered resources in the
database and with the OSGi container, and enabled users to associate
permissions with resources, you're ready to add permission checks in the
appropriate places in your application. This takes three steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add permission checks to your service calls.
\item
  Create permission helper classes in your web module.
\item
  Add permission checks to your web application.
\end{enumerate}

These things are covered next.

\subsection{Add Permission Checks to Your Service
Calls}\label{add-permission-checks-to-your-service-calls}

A best practice is to create methods in your \texttt{-ServiceImpl}
classes that call the same methods in your \texttt{-LocalServiceImpl}
classes, but wrap those calls in permission checks. If you expose your
services as web services, then any client calling those services must
have permission to call the service. In this way, you separate your
business logic (contained in the \texttt{-LocalServiceImpl} class) from
your permissions logic (contained in the \texttt{-ServiceImpl} class).

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open your entity's \texttt{-ServiceImpl} class.
\item
  Use the \texttt{ModelResourcePermissionFactory} and the
  \texttt{PortletResourcePermissionFactory} to reference permission
  checkers that can check permissions as you've defined them in
  \texttt{default.xml}. Here's how the Blogs portlet does this:

\begin{verbatim}
private static volatile ModelResourcePermission<BlogsEntry>
    _blogsEntryFolderModelResourcePermission =
        ModelResourcePermissionFactory.getInstance(
            BlogsEntryServiceImpl.class,
            "_blogsEntryFolderModelResourcePermission", BlogsEntry.class);
private static volatile PortletResourcePermission
    _portletResourcePermission =
        PortletResourcePermissionFactory.getInstance(
            BlogsEntryServiceImpl.class, "_portletResourcePermission",
            BlogsConstants.RESOURCE_NAME);
\end{verbatim}

  You declare the class, the variable, and for the portlet resource, the
  resource name from \texttt{default.xml}. In the Blogs application,
  \texttt{BlogsConstants.RESOURCE\_NAME} is a \texttt{String} with the
  value \texttt{com.liferay.blogs}.

  You must use \texttt{ModelResourcePermissionFactory.getInstance()} in
  the service because Service Builder is wired with Spring, so
  \texttt{@Reference} can't be used. Make sure to use the correct
  service class and the name of the field that's being set (in this case
  \texttt{"\_blogsEntryFolderModelResourcePermission"}), because it's
  set with reflection when the service is registered. If you get the
  field wrong, it'll be set wrong. The field must be \texttt{static} and
  \texttt{volatile}, and should never be used outside of
  \texttt{-ServiceImpl} classes.
\item
  Check permissions in the appropriate places. For example, adding a
  blog entry requires the \texttt{ADD\_ENTRY} permission, so the Blogs
  application does this:

\begin{verbatim}
@Override
public BlogsEntry addEntry(
        String title, String subtitle, String description, String content,
        int displayDateMonth, int displayDateDay, int displayDateYear,
        int displayDateHour, int displayDateMinute, boolean allowPingbacks,
        boolean allowTrackbacks, String[] trackbacks,
        String coverImageCaption, ImageSelector coverImageImageSelector,
        ImageSelector smallImageImageSelector,
        ServiceContext serviceContext)
    throws PortalException {

    _portletResourcePermission.check(
        getPermissionChecker(), serviceContext.getScopeGroupId(),
        ActionKeys.ADD_ENTRY);

    return blogsEntryLocalService.addEntry(
        getUserId(), title, subtitle, description, content,
        displayDateMonth, displayDateDay, displayDateYear, displayDateHour,
        displayDateMinute, allowPingbacks, allowTrackbacks, trackbacks,
        coverImageCaption, coverImageImageSelector, smallImageImageSelector,
        serviceContext);
}
\end{verbatim}

  The check throws an exception if it fails, preventing the local
  service call that adds the entry. A convention Liferay uses is to
  place the action keys from \texttt{default.xml} as constants in an
  \texttt{ActionKeys} class. If \texttt{ActionKeys} doesn't have an
  action key appropriate for your application, extend Liferay's class
  and add your own keys.
\end{enumerate}

Add permission checks where necessary to protect your application's
functions at the service level. Next, you'll learn how to create
permission helper classes for your web module.

\subsection{Create Permission Helper Classes in Your Web
Module}\label{create-permission-helper-classes-in-your-web-module}

A helper class can make it easier to check permissions in your portlet
application. You can create helper classes for both portlet permissions
and model permissions. Here's how to create a portlet permission helper:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a package with the suffix
  \texttt{web.internal.security.permission.resource}. For example, the
  Blogs application has the package
  \texttt{com.liferay.blogs.web.internal.security.permission.resource}.
\item
  Create a component class with at least one static method for checking
  permissions. For example, here's the \texttt{BlogsPermission} class:

\begin{verbatim}
@Component(immediate = true)
public class BlogsPermission {

    public static boolean contains(
        PermissionChecker permissionChecker, long groupId, String actionId) {

        return _portletResourcePermission.contains(
            permissionChecker, groupId, actionId);
    }

    @Reference(
        target = "(resource.name=" + BlogsConstants.RESOURCE_NAME + ")",
        unbind = "-"
    )
    protected void setPortletResourcePermission(
        PortletResourcePermission portletResourcePermission) {

        _portletResourcePermission = portletResourcePermission;
    }

    private static PortletResourcePermission _portletResourcePermission;

}
\end{verbatim}

  Note the \texttt{@Reference} annotation that tells the OSGi container
  to supply an object via the permission registrar you created
  previously. The \texttt{\_portletResourcePermission} field is static,
  while the setter method is an instance method: this is how Liferay
  avoids having service references in JSPs.
\end{enumerate}

The procedure for creating a model permission helper is similar:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In the same package, create a component class with at least one static
  method for checking permissions. For example, here's the
  \texttt{BlogsEntryPermission} class:

\begin{verbatim}
@Component(immediate = true)
public class BlogsEntryPermission {

    public static boolean contains(
            PermissionChecker permissionChecker, BlogsEntry entry,
            String actionId)
        throws PortalException {

        return _blogsEntryFolderModelResourcePermission.contains(
            permissionChecker, entry, actionId);
    }

    public static boolean contains(
            PermissionChecker permissionChecker, long entryId, String actionId)
        throws PortalException {

        return _blogsEntryFolderModelResourcePermission.contains(
            permissionChecker, entryId, actionId);
    }

    @Reference(
        target = "(model.class.name=com.liferay.blogs.model.BlogsEntry)",
        unbind = "-"
    )
    protected void setEntryModelPermission(
        ModelResourcePermission<BlogsEntry> modelResourcePermission) {

        _blogsEntryFolderModelResourcePermission = modelResourcePermission;
    }

    private static ModelResourcePermission<BlogsEntry>
        _blogsEntryFolderModelResourcePermission;

}
\end{verbatim}

  As you can see, this class is almost the same as the portlet
  permission class. The real difference is in the \texttt{@Reference}
  annotation that specifies the fully qualified class name of the model,
  rather than the resource name from \texttt{default.xml}.
\item
  Save both files.
\end{enumerate}

Now you're ready to use these helper classes to check permissions in
your web module.

\subsection{Add Permission Checks to Your Web
Application}\label{add-permission-checks-to-your-web-application}

You can use the permission helper classes to check for permissions
before displaying UI elements. If the element never appears, a user
can't access it (though you should also protect your services as
described above). Here's how to do that:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  When you have a function you want to protect, wrap it in an
  \texttt{if} statement that uses the permission helper class. For
  example, the Blogs application has many functions protected by
  permissions, including \texttt{ADD\_ENTRY} and \texttt{SUBSCRIBE}.
  Clearly, only blog owners should be able to add blog entries. The
  button for this, therefore, should only appear if a user has
  permission to add entries:

\begin{verbatim}
<c:if test="<%= BlogsPermission.contains(permissionChecker, scopeGroupId, ActionKeys.ADD_ENTRY) %>">
    <div class="button-holder">
        <portlet:renderURL var="editEntryURL" windowState="<%= WindowState.MAXIMIZED.toString() %>">
            <portlet:param name="mvcRenderCommandName" value="/blogs/edit_entry" />
            <portlet:param name="redirect" value="<%= currentURL %>" />
        </portlet:renderURL>

        <aui:button href="<%= editEntryURL %>" icon="icon-plus" value="add-blog-entry" />
    </div>
</c:if>
\end{verbatim}
\item
  Do this for any function. For example, the Permissions function you
  added in
  \href{/docs/7-1/tutorials/-/knowledge_base/t/associating-permissions-with-resources}{step
  3} should definitely be protected by permissions:

\begin{verbatim}
<c:if test="<%= BlogsEntryPermission.contains(permissionChecker, entry, ActionKeys.PERMISSIONS) %>">
    <liferay-security:permissionsURL
        modelResource="<%= BlogsEntry.class.getName() %>"
        modelResourceDescription="<%= BlogsEntryUtil.getDisplayTitle(resourceBundle, entry) %>"
        resourceGroupId="<%= String.valueOf(entry.getGroupId()) %>"
        resourcePrimKey="<%= String.valueOf(entry.getEntryId()) %>"
        var="permissionsEntryURL"
        windowState="<%= LiferayWindowState.POP_UP.toString() %>"
    />

    <liferay-ui:icon
        label="<%= true %>"
        message="permissions"
        method="get"
        url="<%= permissionsEntryURL %>"
        useDialog="<%= true %>"
    />
</c:if>
\end{verbatim}

  This prevents anyone without the permission to set permissions from
  seeing the permissions button. Say that three times fast!
\end{enumerate}

That's all there is to it! You've now learned all the steps in
\emph{DRAC}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Define permissions
\item
  Register permissions
\item
  Associate permissions with resources
\item
  Check permissions
\end{enumerate}

Follow these steps, and your applications can take advantage of
Liferay's integrated and well-tested permissions system.

\section{Using JSR Roles in a
Portlet}\label{using-jsr-roles-in-a-portlet}

Roles in Liferay DXP are the primary means for granting or restricting
access to content. If you've decided \emph{not} to use Liferay's
permissions system, you can use the basic system offered by the JSR 168,
286, and 362 specifications that map Roles in a portlet to Roles
provided by the portal.

\subsection{JSR Portlet Security}\label{jsr-portlet-security}

The portlet specification defines a means to specify Roles used by
portlets in their \texttt{docroot/WEB-INF/portlet.xml} descriptors. The
Role names themselves, however, are not standardized. When these
portlets run in Liferay DXP, the Role names defined in the portlet must
be mapped to Roles that exist in the Portal.

For example, consider a Guestbook project that contains two portlets:
The Guestbook portlet and the Guestbook Admin portlet. The WAR version
of the Guestbook project's \texttt{portlet.xml} file references the
\emph{administrator}, \emph{guest}, \emph{power-user}, and \emph{user}
Roles:

\begin{verbatim}
<?xml version="1.0"?>
<portlet-app xmlns="http://java.sun.com/xml/ns/portlet/portlet-app_2_0.xsd" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/portlet/portlet-app_2_0.xsd http://java.sun.com/xml/ns/portlet/portlet-app_2_0.xsd" version="2.0">

<portlet>
    <portlet-name>guestbook</portlet-name>
    <display-name>Guestbook</display-name>
    <portlet-class>
        com.liferay.docs.guestbook.portlet.GuestbookPortlet
    </portlet-class>
    <init-param>
        <name>view-template</name>
        <value>/html/guestbook/view.jsp</value>
    </init-param>
    <expiration-cache>0</expiration-cache>
    <supports>
        <mime-type>text/html</mime-type>
        <portlet-mode>view</portlet-mode>
    </supports>
    <portlet-info>
        <title>Guestbook</title>
        <short-title>Guestbook</short-title>
        <keywords></keywords>
    </portlet-info>
    <security-role-ref>
        <role-name>administrator</role-name>
    </security-role-ref>
    <security-role-ref>
        <role-name>guest</role-name>
    </security-role-ref>
    <security-role-ref>
        <role-name>power-user</role-name>
    </security-role-ref>
    <security-role-ref>
        <role-name>user</role-name>
    </security-role-ref>
</portlet>
<portlet>
    <portlet-name>guestbook-admin</portlet-name>
    <display-name>Guestbook Admin</display-name>
    <portlet-class>
        com.liferay.docs.guestbook.portlet.GuestbookAdminPortlet
    </portlet-class>
    <init-param>
        <name>view-template</name>
        <value>/html/guestbookadmin/view.jsp</value>
    </init-param>
    <expiration-cache>0</expiration-cache>
    <supports>
        <mime-type>text/html</mime-type>
        <portlet-mode>view</portlet-mode>
    </supports>
    <portlet-info>
        <title>Guestbook Admin</title>
        <short-title>Guestbook Admin</short-title>
        <keywords></keywords>
    </portlet-info>
    <security-role-ref>
        <role-name>administrator</role-name>
    </security-role-ref>
    <security-role-ref>
        <role-name>guest</role-name>
    </security-role-ref>
    <security-role-ref>
        <role-name>power-user</role-name>
    </security-role-ref>
    <security-role-ref>
        <role-name>user</role-name>
    </security-role-ref>
</portlet>
\end{verbatim}

An OSGi-based \texttt{guestbook-web} module project defines Roles
without an XML file, in the portlet class's \texttt{@Component}
annotation:

\begin{verbatim}
@Component(
    immediate = true,
    property = {
        "com.liferay.portlet.display-category=category.sample",
        "com.liferay.portlet.instanceable=true",
        "javax.portlet.init-param.template-path=/",
        "javax.portlet.init-param.view-template=/view.jsp",
        "javax.portlet.name=" + GuestbookPortletKeys.Guestbook,
        "javax.portlet.resource-bundle=content.Language",
        "javax.portlet.security-role-ref=power-user,user"
    },
    service = Portlet.class
)
\end{verbatim}

If you are using an OSGi-based MVC Portlet, you must use Liferay's
permissions system, as the only way to map JSR-362 Roles to Liferay
Roles is to place them in the Liferay WAR file's \texttt{portlet.xml}.

Your \texttt{portlet.xml} Roles must be mapped to specific Roles that
have been created. These mappings allow Liferay DXP to resolve conflicts
between Roles with the same name that are from different portlets
(e.g.~portlets from different developers).

\noindent\hrulefill

\textbf{Note:} Each Role named in a portlet's
\texttt{\textless{}security-role-ref\textgreater{}} element is given
permission to add the portlet to a page.

\noindent\hrulefill

\subsection{Mapping Portlet Roles to Portal
Roles}\label{mapping-portlet-roles-to-portal-roles}

To map the Roles to Liferay DXP, you must use the
\texttt{docroot/WEB-INF/liferay-portlet.xml} Liferay-specific
configuration file. For an example, see the mapping defined in the
Guestbook project's \texttt{liferay-portlet.xml} file.

\begin{verbatim}
<role-mapper>
    <role-name>administrator</role-name>
    <role-link>Administrator</role-link>
</role-mapper>
<role-mapper>
    <role-name>guest</role-name>
    <role-link>Guest</role-link>
</role-mapper>
<role-mapper>
    <role-name>power-user</role-name>
    <role-link>Power User</role-link>
</role-mapper>
<role-mapper>
    <role-name>user</role-name>
    <role-link>User</role-link>
</role-mapper>
\end{verbatim}

If a portlet definition references the Role \texttt{power-user}, that
portlet is mapped to the Liferay Role called \emph{Power User} that's
already in Liferay's database.

As stated above, there is no standardization with portal Role names. If
you deploy a portlet with Role names different from the above default
Liferay names, you must add the names to the \texttt{system.roles}
property in your \texttt{portal-ext.properties} file:

\begin{verbatim}
system.roles=my-role,your-role,our-role
\end{verbatim}

This prevents Roles from being created accidentally.

Once Roles are mapped to the portal, you can use methods as defined in
the portlet specification:

\begin{itemize}
\tightlist
\item
  \texttt{getRemoteUser()}
\item
  \texttt{isUserInRole()}
\item
  \texttt{getUserPrincipal()}
\end{itemize}

For example, you can use the following code to check if the current User
has the \texttt{power-user} Role:

\begin{verbatim}
if (renderRequest.isUserInRole("power-user")) {
    // ...
}
\end{verbatim}

By default, Liferay doesn't use the \texttt{isUserInRole()} method in
any built-in portlets. Liferay uses its own permission system directly
to achieve more fine-grained security. If you don't intend on deploying
your portlets to other portal servers, we recommend using Liferay's
permission system, because it offers a much more robust way of tailoring
your application's permissions.

\subsection{Related Topics}\label{related-topics-72}

\href{/docs/7-1/tutorials/-/knowledge_base/t/defining-application-permissions}{Liferay
Permissions}

\href{/docs/7-1/tutorials/-/knowledge_base/t/asset-framework}{Asset
Framework}

\href{/docs/7-2/tutorials/-/knowledge_base/t/portlets}{Portlets}

\href{/docs/7-1/tutorials/-/knowledge_base/t/understanding-servicecontext}{Understanding
ServiceContext}

\chapter{Authentication Pipelines}\label{authentication-pipelines}

The authentication process is a pipeline through which users can be
validated by one or several systems. As a developer, you can
authenticate users to anything you wish, rather than be limited by what
Liferay DXP supports out of the box.

Here's how authentication works under most circumstances:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Users provide their credentials to the Login Portlet to begin an
  authenticated session in a browser.
\item
  Alternatively, credentials are provided to Liferay DXP's API
  endpoints, where they are sent in an HTTP BASIC Auth header.
\item
  Alternatively, credentials can be provided by another system. These
  are managed by \texttt{AutoLogin} components.
\item
  Credentials are checked by default against the database, but they can
  be delegated to other systems instead of or in addition to it. This is
  called an \emph{Authentication Pipeline}. You can add
  \texttt{Authenticator}s to the pipeline to support any system.
\item
  You can also customize the Login Portlet to support whatever user
  interface any of these systems need. This gives you full flexibility
  over the entire authentication process.
\end{enumerate}

This structure lets you support an authentication mechanism and/or
accept credentials from a system that Liferay DXP doesn't yet support.
If you don't like the user interface for signing in, you can replace it
with your own.

These tutorials guide you through these customizations. You'll discover
three kinds of customizations:

\begin{itemize}
\item
  \textbf{Auto Login:} the easiest of the three, this lets you
  authenticate to Liferay DXP using credentials provided in the HTTP
  header from another system.
\item
  \textbf{Authentication Pipelines:} if you need to check credentials
  against other systems instead of or in addition to Liferay DXP's
  database, you can create a pipeline.
\item
  \textbf{Custom Login Portlet:} if you want to change the user's
  sign-in experience completely, you can implement your own Login
  portlet.
\end{itemize}

Read on to discover how to customize your users' sign-in experience.

\section{Auto Login}\label{auto-login}

While Liferay DXP supports a wide variety of
\href{/docs/7-0/deploy/-/knowledge_base/d/liferay-portal-security}{authentication
mechanisms}, you may use a home-grown system or some other product to
authenticate users. To do so, you can write an Auto Login component to
support your authentication system.

Auto Login components can check if the request contains something (a
cookie, an attribute) that can be associated with a user in any way. If
the component can make that association, it can authenticate that user.

\subsection{Creating an Auto Login
Component}\label{creating-an-auto-login-component}

Create a
\href{/docs/7-0/tutorials/-/knowledge_base/t/creating-modules-with-liferay-ide\#creating-component-classes}{Declarative
Services component}. The component should implement the
\texttt{com.liferay.portal.kernel.security.auto.login.AutoLogin}
interface. Here's an example template:

\begin{verbatim}
import com.liferay.portal.kernel.security.auto.login.AutoLogin;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.osgi.service.component.annotations.Component;

@Component(immediate = true)
public class MyAutoLogin implements Autologin {

    public String[] handleException(
            HttpServletRequest request, HttpServletResponse response,
            Exception e)
        throws AutoLoginException {

        /* This method is no longer used in the interface and can be 
      left empty */

    }

    public String[] login(
            HttpServletRequest request, HttpServletResponse response)
        throws AutoLoginException {

        /* Your Code Goes Here */

    }

}
\end{verbatim}

As you can see, you have access to the \texttt{HttpServletRequest} and
the \texttt{HttpServletResponse} objects. If your sign-on solution
places anything here that identifies a user such as a cookie, an
attribute, or a parameter, you can retrieve it and take whatever action
you need to retrieve the user information and authenticate that user.

For example, say that there's a request attribute that contains the
encrypted value of a user key. This can only be there if the user has
authenticated with a third party system that knew the value of the user
key, encrypted it, and added it as a request attribute. You could write
code that reads the value, decrypts it using the same pre-shared key,
and uses the value to look up and authenticate the user.

The \texttt{login} method is where this all happens. This method must
return a \texttt{String} array with three items in this order:

\begin{itemize}
\tightlist
\item
  The user ID
\item
  The user password
\item
  A boolean flag that's \texttt{true} if the password is encrypted and
  \texttt{false} if it's not (\texttt{Boolean.TRUE.toString()} or
  \texttt{Boolean.FALSE.toString()}).
\end{itemize}

Sending redirects is an optional \texttt{AutoLogin} feature. Since
\texttt{AutoLogin}s are part of the servlet filter chain, you have two
options. Both are implemented by setting attributes in the request. Here
are the attributes:

\begin{itemize}
\item
  \texttt{AutoLogin.AUTO\_LOGIN\_REDIRECT}: This key causes
  \texttt{AutoLoginFilter} to stop the filter chain's execution and
  redirect immediately to the location specified in the attribute's
  value.
\item
  \texttt{AutoLogin.AUTO\_LOGIN\_REDIRECT\_AND\_CONTINUE}: This key
  causes \texttt{AutoLoginFilter} to set the redirect and continue
  executing the remaining filters in the chain.
\end{itemize}

Auto Login components are useful ways of providing an authentication
mechanism to a system that Liferay DXP doesn't yet support. You can
write them fairly quickly to provide the integration you need.

\subsection{Related Topics}\label{related-topics-73}

\href{/docs/7-0/tutorials/-/knowledge_base/t/password-based-authentication-pipelines}{Password-Based
Authentication Pipelines}

\href{/docs/7-0/tutorials/-/knowledge_base/t/writing-a-custom-login-portlet}{Writing
a Custom Login Portlet}

\section{Password-Based Authentication
Pipelines}\label{password-based-authentication-pipelines}

By default, once a user submits credentials, those credentials are
checked against Liferay DXP's database, though you can also delegate
authentication to an LDAP server. To use some other system in your
environment instead of or in addition to checking credentials against
the database, you can write an \texttt{Authenticator} and insert it as a
step in the authentication pipeline.

Because the \texttt{Authenticator} is checked by the Login Portlet, you
can't use this approach if the user must be redirected to the external
system or needs a token to authenticate. In those cases, you should use
an \href{/docs/7-0/tutorials/-/knowledge_base/t/auto-login}{Auto Login}
or an
\href{/docs/7-0/deploy/-/knowledge_base/d/authentication-verifiers}{Auth
Verifier}.

\texttt{Authenticator}s let you do these things:

\begin{itemize}
\tightlist
\item
  Log into Liferay DXP with a user name and password maintained in an
  external system
\item
  Make secondary user authentication checks
\item
  Perform additional processing when user authentication fails
\end{itemize}

Read on to learn how to create an \texttt{Authenticator}.

\subsection{Anatomy of an
Authenticator}\label{anatomy-of-an-authenticator}

\texttt{Authenticator}s are implemented for various steps in the
authentication pipeline. Here are the steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \texttt{auth.pipeline.pre}: Comes before default authentication to the
  database. In this step, you can skip credential validation against the
  database. Implemented by \texttt{Authenticator}.
\item
  Default (optional) authentication to the database.
\item
  \texttt{auth.pipeline.post}: Further (secondary, tertiary)
  authentication checks. Implemented by \texttt{Authenticator}.
\item
  \texttt{auth.failure}: Perform additional processing after
  authentication fails. Implemented by \texttt{AuthFailure}.
\end{enumerate}

To create an \texttt{Authenticator}, create a module and add a component
that implements the interface:

\begin{verbatim}
@Component(
    immediate = true, property = {"key=auth.pipeline.post"},
    service = Authenticator.class
)
public class MyCustomAuth implements Authenticator {

    public int authenticateByEmailAddress(
            long companyId, String emailAddress, String password,
            Map<String, String[]> headerMap, Map<String, String[]> parameterMap)
        throws AuthException {

return Authenticator.SUCCESS;
}

    public int authenticateByScreenName(
            long companyId, String screenName, String password,
            Map<String, String[]> headerMap, Map<String, String[]> parameterMap)
        throws AuthException {

return Authenticator.SUCCESS;
    }

    public int authenticateByUserId(
            long companyId, long userId, String password,
            Map<String, String[]> headerMap, Map<String, String[]> parameterMap)
        throws AuthException {

return Authenticator.SUCCESS;
    }
}
\end{verbatim}

This example has been stripped down so you can see its structure. First,
note the \texttt{@Component} annotation's contents:

\begin{itemize}
\tightlist
\item
  \texttt{immediate\ =\ true}: sets the component to start immediately
\item
  \texttt{key=auth.pipeline.post}: sets the \texttt{Authenticator} to
  run in the \texttt{auth.pipeline.post} phase. To run the
  \texttt{auth.pipeline.pre} phase, substitute
  \texttt{auth.pipeline.pre}.
\item
  \texttt{service\ =\ Authenticator.class}: implements the
  \texttt{Authenticator} service. All \texttt{Authenticator}s must do
  this.
\end{itemize}

The three methods below the annotation run based on how you've
configured authentication: by email address (the default), by screen
name, or by user ID. All the methods throw an \texttt{AuthException} in
case the \texttt{Authenticator} can't perform its task: if the system
it's authenticating against is unavailable or if some dependency can't
be found. The methods in this barebones example return success in all
cases. If you deploy its module, it has no effect. Naturally, you'll
want to provide more functionality. Next is an example that shows you
how to do that.

\subsection{Creating an Authenticator}\label{creating-an-authenticator}

This example is an \texttt{Authenticator} that only allows users whose
email addresses end with \emph{@example.com} or \emph{@example.com}. You
can implement this using one module that does everything. If you think
other modules might use the functionality that validates the email
addresses, you should create two modules: one to implement the
\texttt{Authenticator} and one to validate email addresses. This example
shows the two module approach.

To create an \texttt{Authenticator}, create a module for your
implementation. The most appropriate Blade template for this is the
\href{/docs/7-0/reference/-/knowledge_base/r/using-the-service-template}{service
template}. Once you have the module, creating the \texttt{Activator} is
straightforward:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add the \texttt{@Component} annotation to bind your \texttt{Activator}
  to the appropriate authentication pipeline phase.
\item
  Implement the \texttt{Authenticator} interface and provide the
  functionality you need.
\item
  Deploy your module. If you're using
  \href{/docs/7-0/tutorials/-/knowledge_base/t/blade-cli}{Blade CLI}, do
  this via \texttt{blade\ deploy}.
\end{enumerate}

For this example, you'll do this twice: once for the email address
validator module and once for the \texttt{Authenticator} itself. The
\texttt{Authenticator} project contains the interface for the validator,
and the validator project contains the implementation. Here's what the
\texttt{Authenticator} module structure looks like:

\begin{figure}
\centering
\includegraphics{./images/auth-pipeline-authenticator-project.png}
\caption{The Authenticator module contains the validator's interface and
the authenticator.}
\end{figure}

Since the \texttt{Authenticator} is the most relevant, examine it first:

\begin{verbatim}
package com.liferay.docs.emailaddressauthenticator;

import java.util.Map;

import com.liferay.docs.emailaddressauthenticator.validator.EmailAddressValidator;
import com.liferay.portal.kernel.log.Log;
import com.liferay.portal.kernel.log.LogFactoryUtil;
import com.liferay.portal.kernel.security.auth.AuthException;
import com.liferay.portal.kernel.security.auth.Authenticator;
import com.liferay.portal.kernel.service.UserLocalService;

import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Reference;
import org.osgi.service.component.annotations.ReferenceCardinality;
import org.osgi.service.component.annotations.ReferencePolicy;

@Component(
    immediate = true,
    property = {"key=auth.pipeline.post"},
    service = Authenticator.class
)
public class EmailAddressAuthenticator implements Authenticator {

    @Override
    public int authenticateByEmailAddress(long companyId, String emailAddress,
            String password, Map<String, String[]> headerMap,
            Map<String, String[]> parameterMap) throws AuthException {
        
        return validateDomain(emailAddress);
    }

    @Override
    public int authenticateByScreenName(long companyId, String screenName,
            String password, Map<String, String[]> headerMap,
            Map<String, String[]> parameterMap) throws AuthException {
        
        String emailAddress = 
            _userLocalService.fetchUserByScreenName(companyId, screenName).getEmailAddress();
        
        return validateDomain(emailAddress);
    }

    @Override
    public int authenticateByUserId(long companyId, long userId,
            String password, Map<String, String[]> headerMap,
            Map<String, String[]> parameterMap) throws AuthException {
        
        String emailAddress = 
            _userLocalService.fetchUserById(userId).getEmailAddress();
        
        return validateDomain(emailAddress);
    }
    
    private int validateDomain(String emailAddress) throws AuthException {
        
        if (_emailValidator == null) {
            
            String msg = "Email address validator is unavailable, cannot authenticate user";            
            _log.error(msg);
            
            throw new AuthException(msg);
        }
        
        if (_emailValidator.isValidEmailAddress(emailAddress)) {        
            return Authenticator.SUCCESS;
        }
        return Authenticator.FAILURE;
    }
    
    @Reference
    private volatile UserLocalService _userLocalService;
    
    @Reference(
        policy = ReferencePolicy.DYNAMIC,
        cardinality = ReferenceCardinality.OPTIONAL
    )
    private volatile EmailAddressValidator _emailValidator;
    
    private static final Log _log = LogFactoryUtil.getLog(EmailAddressAuthenticator.class);
}
\end{verbatim}

This time, rather than stubs, the three authentication methods contain
functionality. The \texttt{authenticateByEmailAddress} method directly
checks the email address provided by the Login Portlet. The other two
methods, \texttt{authenticateByScreenName} and
\texttt{authenticateByUserId} call \texttt{UserLocalService} to look up
the user's email address before checking it. The OSGi container injects
this service because of the \texttt{@Reference} annotation. Note that
the validator is also injected in this same manner, though it's
configured not to fail if the implementation can't be found. This allows
this module to start regardless of its dependency on the validator
implementation. In this case, this is safe because the error is handled
by throwing an \texttt{AuthException} and logging the error.

Why would you want to do it this way? To err gracefully. Because this is
an \texttt{auth.pipeline.post} \texttt{Authenticator}, you presumably
have other \texttt{Authenticator}s checking credentials before this one.
If this one isn't working, you want to inform administrators with an
error message rather than catastrophically failing and preventing users
from logging in.

The only other Java code in this module is the Interface for the
validator:

\begin{verbatim}
package com.liferay.docs.emailaddressauthenticator.validator;

import aQute.bnd.annotation.ProviderType;

@ProviderType
public interface EmailAddressValidator {

    public boolean isValidEmailAddress(String emailAddress);
}
\end{verbatim}

This defines a single method for checking the email address.

Next, you'll address the validator module.

\begin{figure}
\centering
\includegraphics{./images/auth-pipeline-validator-project.png}
\caption{The validator project implements the Validator Interface and
depends on the authenticator module.}
\end{figure}

This module contains only one class. It implements the Validator
interface:

\begin{verbatim}
package com.liferay.docs.emailaddressvalidator.impl;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;
import org.osgi.service.component.annotations.Component;
import com.liferay.docs.emailaddressauthenticator.validator.EmailAddressValidator;

@Component(
    immediate = true,
    property = {
    },
    service = EmailAddressValidator.class
)
public class EmailAddressValidatorImpl implements EmailAddressValidator {

    @Override
    public boolean isValidEmailAddress(String emailAddress) {

        if (_validEmailDomains.contains(
            emailAddress.substring(emailAddress.indexOf('@')))) {

            return true;
        }
        return false;
    }

    private Set<String> _validEmailDomains = 
        new HashSet<String>(Arrays.asList(new String[] {"@example.com", "@example2.com"}));
}
\end{verbatim}

This code checks to make sure that the email address is from the
\emph{@example.com} or \emph{@example.com} domains. The only other
interesting part of this module is the Gradle build script, because it
defines a compile-only dependency between the two projects. This is
divided into two files: a \texttt{settings.gradle} and a
\texttt{build.gradle}.

The \texttt{settings.gradle} file defines the location of the project
(the \texttt{Authenticator}) the validator depends on:

\begin{verbatim}
include ':emailAddressAuthenticator'
project(':emailAddressAuthenticator').projectDir = new File(settingsDir, '../com.liferay.docs.emailAddressAuthenticator')
\end{verbatim}

Since this project contains the interface, it must be on the classpath
at compile time, which is when \texttt{build.gradle} is running:

\begin{verbatim}
buildscript {
    dependencies {
        classpath group: "com.liferay", name: "com.liferay.gradle.plugins", version: "3.0.23"
    }

    repositories {
        mavenLocal()

        maven {
            url "https://repository-cdn.liferay.com/nexus/content/groups/public"
        }
    }
}

apply plugin: "com.liferay.plugin"

dependencies {
    compileOnly group: "com.liferay.portal", name: "com.liferay.portal.kernel", version: "2.0.0"
    compileOnly group: "org.osgi", name: "org.osgi.compendium", version: "5.0.0"

    compileOnly project(":emailAddressAuthenticator")
}

repositories {
    mavenLocal()

    maven {
        url "https://repository-cdn.liferay.com/nexus/content/groups/public"
    }
}
\end{verbatim}

Note the line in the dependencies section that refers to the
\texttt{Authenticator} project defined in \texttt{settings.gradle}.

When these projects are deployed, the \texttt{Authenticator} you defined
runs, enforcing logins for the two domains specified in the validator.

If you want to examine these projects further, you can download them
\href{https://portal.liferay.dev/documents/113763090/114000186/auth-pipelines-authenticator.zip}{in
this ZIP file}.

\subsection{Related Topics}\label{related-topics-74}

\href{/docs/7-0/tutorials/-/knowledge_base/t/auto-login}{Auto Login}

\href{/docs/7-0/tutorials/-/knowledge_base/t/writing-a-custom-login-portlet}{Writing
a Custom Login Portlet}

\section{Writing a Custom Login
Portlet}\label{writing-a-custom-login-portlet}

If you need to customize your users' authentication experience
completely, you can write your own Login Portlet. The mechanics of this
on the macro level are no different from writing any other portlet, so
if you need to familiarize yourself with that, please see the
\href{/docs/7-0/tutorials/-/knowledge_base/t/portlets}{portlets section
of tutorials}.

This tutorial shows only the relevant parts of a
\href{/docs/7-0/tutorials/-/knowledge_base/t/liferay-mvc-portlet}{Liferay
MVC Portlet} that authenticates the user. You'll learn how to call the
\href{/docs/7-0/tutorials/-/knowledge_base/t/authentication-pipelines}{authentication
pipeline} and then redirect the user to a location of your choice.

\subsection{Authenticating to Liferay
DXP}\label{authenticating-to-liferay-dxp}

You can use the example project
\href{https://portal.liferay.dev/documents/113763090/114000186/MyCustomLoginPortlet.zip}{in
this ZIP file} as a starting point for your own.

\noindent\hrulefill

\textbf{Note:} When using the example project, set the session timeout
portal property like this:

\begin{verbatim}
 session.timeout.auto.extend.offset=45
\end{verbatim}

This is needed because the default (as of
\href{https://issues.liferay.com/browse/LPS-68543}{LPS-68543}) setting
is \texttt{0}, causing the browser to execute an
\texttt{extend\_session} call. This may force users attempting to log in
to make the attempt twice.

\noindent\hrulefill

It has only one view, which is used for logging in or showing the user
who is already logged in:

\begin{verbatim}
<%@ include file="/init.jsp" %>

<p>
    <b><liferay-ui:message key="myloginportlet_MyLogin.caption"/></b>
</p>

<c:choose>
    <c:when test="<%= themeDisplay.isSignedIn() %>">

        <%
        String signedInAs = HtmlUtil.escape(user.getFullName());

        if (themeDisplay.isShowMyAccountIcon() && (themeDisplay.getURLMyAccount() != null)) {
            String myAccountURL = String.valueOf(themeDisplay.getURLMyAccount());

            signedInAs = "<a class=\"signed-in\" href=\"" + HtmlUtil.escape(myAccountURL) + "\">" + signedInAs + "</a>";
        }
        %>

        <liferay-ui:message arguments="<%= signedInAs %>" key="you-are-signed-in-as-x" translateArguments="<%= false %>" />
    </c:when>
    <c:otherwise>
    
        <%
        String redirect = ParamUtil.getString(request, "redirect");
        %>
    
        <portlet:actionURL name="/login/login" var="loginURL">
            <portlet:param name="mvcRenderCommandName" value="/login/login" />
        </portlet:actionURL>
        
        <aui:form action="<%= loginURL %>" autocomplete='on' cssClass="sign-in-form" method="post" name="loginForm">
        
            <aui:input name="saveLastPath" type="hidden" value="<%= false %>" />
            <aui:input name="redirect" type="hidden" value="<%= redirect %>" />
                    
            <aui:input autoFocus="true" cssClass="clearable" label="email-address" name="login" showRequiredLabel="<%= false %>" type="text" value="">
                <aui:validator name="required" />
            </aui:input>

            <aui:input name="password" showRequiredLabel="<%= false %>" type="password">
                <aui:validator name="required" />
            </aui:input>
            
            <aui:button-row>
                <aui:button cssClass="btn-lg" type="submit" value="sign-in" />
            </aui:button-row>
                
        </aui:form>
    </c:otherwise>
</c:choose>
\end{verbatim}

Note that in the form, authentication by email address (the default
setting) is hard-coded, as this is an example project. The current page
is sent as a hidden field on the form so the portlet can redirect the
user to it, but you can of course set this to any value you want.

The portlet handles all processing of this form using a single
\href{/docs/7-0/tutorials/-/knowledge_base/t/mvc-action-command}{Action
Command} (imports left out for brevity):

\begin{verbatim}
@Component(
    property = {
        "javax.portlet.name=MyLoginPortlet",
        "mvc.command.name=/login/login"
    },
    service = MVCActionCommand.class
)
public class MyLoginMVCActionCommand extends BaseMVCActionCommand {

    @Override
    protected void doProcessAction(ActionRequest actionRequest,
            ActionResponse actionResponse) throws Exception {

        ThemeDisplay themeDisplay = (ThemeDisplay)actionRequest.getAttribute(
            WebKeys.THEME_DISPLAY);
        
        HttpServletRequest request = PortalUtil.getOriginalServletRequest(
            PortalUtil.getHttpServletRequest(actionRequest));
        
        HttpServletResponse response = PortalUtil.getHttpServletResponse(
            actionResponse);

        String login = ParamUtil.getString(actionRequest, "login");
        String password = actionRequest.getParameter("password");
        boolean rememberMe = ParamUtil.getBoolean(actionRequest, "rememberMe");
        String authType = CompanyConstants.AUTH_TYPE_EA;
        
        AuthenticatedSessionManagerUtil.login(
            request, response, login, password, rememberMe, authType);
        
        actionResponse.sendRedirect(themeDisplay.getPathMain());
    }

}
\end{verbatim}

The only tricky/unusual code here is the need to grab the
\texttt{HttpServletRequest} and the \texttt{HttpServletResponse}. This
is necessary to call Liferay DXP's API for authentication. At the end of
the Action Command, the portlet sends a redirect that sends the user to
the same page. You can of course make this any page you want.

Implementing your own login portlet gives you complete control over the
authentication process.

\subsection{Related Topics}\label{related-topics-75}

\href{/docs/7-0/tutorials/-/knowledge_base/t/password-based-authentication-pipelines}{Password-Based
Authentication Pipelines}

\href{/docs/7-0/tutorials/-/knowledge_base/t/auto-login}{Auto Login}

\section{Service Access Policies}\label{service-access-policies}

Service access policies provide web service security beyond user
authentication to remote services. Together with
\href{/docs/7-1/tutorials/-/knowledge_base/t/defining-application-permissions}{permissions},
service access policies limit remote service access by remote client
applications. This forms an additional security layer that protects user
data from unauthorized access and modification.

To connect to a web service, remote clients must authenticate with
credentials in that instance. This grants the remote client the
permissions assigned to those credentials in the Liferay DXP
installation. Service access policies further limit the remote client's
access to the services specified in the policy. Without such policies,
authenticated remote clients are treated like users: they can call any
remote API and read or modify data on behalf of the authenticated user.
Since remote clients are often intended for a specific use case,
granting them access to everything the user has permissions for poses a
security risk.

For example, consider a mobile app (client) that displays a user's
appointments from the Liferay Calendar app. This client app doesn't need
access to the API that updates the user profile, even though the user
has such permissions on the server. The client app doesn't even need
access to the Calendar API methods that create, update, and delete
appointments. It only needs access to the remote service methods for
finding and retrieving appointments. A service access policy on the
server can restrict the client's access to only these service methods.
Since the client doesn't perform other operations, having access to them
is a security risk if the mobile device is lost or stolen or the client
app is compromised by an attacker.

\subsection{How Service Access Policies
Work}\label{how-service-access-policies-work}

A remote client's request to a web service contains the user's
credentials or an authorization token. An authentication module
recognizes the client based on the credentials/token and grants the
appropriate service access policy to the request. The service access
policy authorization layer then processes all granted policies and lets
the request access the remote service(s) permitted by the policy.

\begin{figure}
\centering
\includegraphics{./images/service-access-policies-arch.png}
\caption{The authorization module maps the credentials or token to the
proper Service Access Policy.}
\end{figure}

Service Access policies are created in the Control Panel by
administrators. If you want to start creating policies yourself, see
\href{/docs/7-1/deploy/-/knowledge_base/d/service-access-policies}{this
article on service access policies} that documents creating them in the
UI.

There may be cases, however, when your server-side Liferay app must use
the service access policies API:

\begin{itemize}
\item
  It uses
  \href{/docs/7-1/tutorials/-/knowledge_base/t/auto-login}{custom remote
  API authentication} (tokens) and require certain services to be
  available for clients using the tokens.
\item
  It requires its services be made available to guest users, with no
  authentication necessary.
\item
  It contains a
  \href{/docs/7-1/tutorials/-/knowledge_base/t/password-based-authentication-pipelines}{remote
  service authorization layer} that needs to drive access to remote
  services based on granted privileges.
\end{itemize}

\subsection{API Overview}\label{api-overview}

Liferay provides an Interface and a \texttt{ThreadLocal} if you don't
want to roll your own policies. If you want to get low level, an API is
provided that Liferay itself has used to implement
\href{/docs/7-1/user/-/knowledge_base/u/administering-liferay-sync}{Liferay
Sync}.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  The Interface and \texttt{ThreadLocal} are available in the
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/security/service/access/policy/package-summary.html}{package
  \texttt{com.liferay.portal.kernel.security.service.access.policy}}.
  This package provides classes for basic access to policies. For
  example, you can use the
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/security/service/access/policy/ServiceAccessPolicyManagerUtil.html}{singleton
  \texttt{ServiceAccessPolicyManagerUtil}} to obtain Service Access
  Policies configured in the system. You can also use the
  \href{https://docs.liferay.com/portal/7.0/javadocs/portal-kernel/com/liferay/portal/kernel/security/service/access/policy/ServiceAccessPolicyThreadLocal.html}{\texttt{ServiceAccessPolicyThreadLocal}
  class} to set and obtain Service Access Policies granted to the
  current request thread.

  At this level, you can get a list of the configured policies to let
  your app/client choose a policy for accessing services. Also, apps
  like OAuth can offer a list of available policies during the
  authorization step in the OAuth workflow and allow the user to choose
  the policy to assign to the remote application. You can also grant a
  policy to a current request thread. When a remote client accesses an
  API, something must tell the Liferay instance which policies are
  assigned to this call. This something is in most cases an
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/security/auth/verifier/AuthVerifier.html}{\texttt{AuthVerifier}
  implementation}. For example, in the case of the OAuth app, an
  \texttt{AuthVerifier} implementation assigns the policy chosen by the
  user in the authorization step.
\item
  The API ships with the product as OSGi modules:
\end{enumerate}

\begin{itemize}
\item
  \texttt{com.liferay.portal.security.service.access.policy.api.jar}
\item
  \texttt{com.liferay.portal.security.service.access.policy.service.jar}
\item
  \texttt{com.liferay.portal.security.service.access.policy.web.jar}

  These OSGi modules are active by default, and you can use them to
  manage Service Access Policies programmatically. You can find their
  source code
  \href{https://github.com/liferay/liferay-portal/tree/master/modules/apps/portal-security}{here
  in GitHub}. Each module publishes a list of packages and services that
  can be consumed by other OSGi modules.
\end{itemize}

You can use both tools to develop a token verification module (a module
that implements custom security token verification for use in
authorizing remote clients) for your app to use. For example, this
module may contain a JSON Web Token implementation for Liferay DXP's
remote API. A custom token verification module must use the Service
Access Policies API during the remote API/web service call to grant the
associated policy during the request. The module

\begin{itemize}
\item
  can use
  \texttt{com.liferay.portal.security.service.access.policy.api.jar} and
  \texttt{com.liferay.portal.security.service.access.policy.service.jar}
  to create policies programmatically.
\item
  should use the method
  \texttt{ServiceAccessPolicyThreadLocal.addActiveServiceAccessPolicyName()}
  to grant the associated policy during a web service request.
\item
  can use \texttt{ServiceAccessPolicyManagerUtil} to display list of
  supported policies when authorizing the remote application, to
  associate the token with an existing policy.
\end{itemize}

\subsection{Service Access Policy
Example}\label{service-access-policy-example}

\href{https://www.liferay.com/supporting-products/liferay-sync}{Liferay
Sync's} \texttt{sync-security} module is a service access policy module.
It uses
\texttt{com.liferay.portal.security.service.access.policy.service} to
create the \texttt{SYNC\_DEFAULT} and \texttt{SYNC\_TOKEN} policies
programmatically. For service calls to Sync's remote API, these policies
grant access to Sync's
\texttt{com.liferay.sync.service.SyncDLObjectService\#getSyncContext}
and \texttt{com.liferay.sync.service.*}, respectively. Here's the code
in the \texttt{sync-security} module that defines and creates these
policies:

\begin{verbatim}
@Component(immediate = true)
public class SyncSAPEntryActivator {

    // Define the policies
    public static final Object[][] SAP_ENTRY_OBJECT_ARRAYS = new Object[][] {
        {
            "SYNC_DEFAULT",
            "com.liferay.sync.service.SyncDLObjectService#getSyncContext", true
        },
        {"SYNC_TOKEN", "com.liferay.sync.service.*", false}
    };

    ...

    // Create the policies
    protected void addSAPEntry(long companyId) throws PortalException {
            for (Object[] sapEntryObjectArray : SAP_ENTRY_OBJECT_ARRAYS) {
                String name = String.valueOf(sapEntryObjectArray[0]);
                String allowedServiceSignatures = String.valueOf(
                    sapEntryObjectArray[1]);
                boolean defaultSAPEntry = GetterUtil.getBoolean(
                    sapEntryObjectArray[2]);

                SAPEntry sapEntry = _sapEntryLocalService.fetchSAPEntry(
                    companyId, name);

                if (sapEntry != null) {
                    continue;
                }

                Map<Locale, String> map = new HashMap<>();

                map.put(LocaleUtil.getDefault(), name);

                _sapEntryLocalService.addSAPEntry(
                    _userLocalService.getDefaultUserId(companyId),
                    allowedServiceSignatures, defaultSAPEntry, true, name, map,
                    new ServiceContext());
            }
    }

    ...

}
\end{verbatim}

This class creates the policies when the module starts. Note that this
module is included and enabled by default. You can access these and
other policies in \emph{Control Panel} → \emph{Configuration} →
\emph{Service Access Policy}.

The \texttt{sync-security} module must then grant the appropriate policy
when needed. Since every authenticated call to Liferay Sync's remote API
requires access to \texttt{com.liferay.sync.service.*}, the module must
grant the \texttt{SYNC\_TOKEN} policy to such calls. The module does
this with the method
\texttt{ServiceAccessPolicyThreadLocal.addActiveServiceAccessPolicyName},
as shown in this code snippet:

\begin{verbatim}
if ((permissionChecker != null) && permissionChecker.isSignedIn()) {
    ServiceAccessPolicyThreadLocal.addActiveServiceAccessPolicyName(
        String.valueOf(
            SyncSAPEntryActivator.SAP_ENTRY_OBJECT_ARRAYS[1][0]));
}
\end{verbatim}

Now every authenticated call to Sync's remote API, regardless of
authentication method, has access to
\texttt{com.liferay.sync.service.*}. To see the full code example,
\href{https://github.com/liferay/liferay-portal/blob/7.1.x/modules/apps/sync/sync-security/src/main/java/com/liferay/sync/security/servlet/filter/SyncAuthFilter.java}{click
here}.

Nice! Now you know how to integrate your apps with the Service Access
Policies.

\chapter{Web Services}\label{web-services}

It's important for apps on different machines to communicate. To enable
this, an app can expose APIs so remote components (other apps or
devices) can access the app's features. For example, one service could
have a client app presenting information to users, a server app
processing data in B2B setting, and an IoT device requesting data to do
its work. Exposing web APIs lets external applications or devices
communicate with yours.

Because Liferay DXP contains so many apps and features, it's prudent for
Liferay to let developers access those apps and features from external
apps and devices by exposing their APIs. Additionally, Liferay's
development platform makes it easy to extend them and create new ones.

There are two different approaches for clients to connect to Liferay
DXP's web APIs:

\textbf{Headless REST APIs:} You can consume RESTful web services
independent of Liferay DXP's front end (hence \emph{headless}). These
APIs conform to the
\href{https://swagger.io/docs/specification/about/}{OpenAPI}
specification. This is the modern, preferred way to work with web
services in Liferay DXP.

\textbf{Plain Web/REST Services:} This is the old way to build and
consume web services in Liferay DXP, but is still supported. For
example, you can use
\href{/docs/7-1/tutorials/-/knowledge_base/t/jax-rs}{JAX-RS},
\href{/docs/7-1/tutorials/-/knowledge_base/t/jax-ws}{JAX-WS}, or
\href{/docs/7-1/tutorials/-/knowledge_base/t/service-builder-web-services}{Service
Builder} to implement plain REST or SOAP web services.

The tutorials that follow show you how to consume and create web
services in Liferay DXP, beginning with headless REST APIs.

\section{Headless REST APIs}\label{headless-rest-apis}

Liferay DXP's headless REST APIs follow the
\href{https://swagger.io/docs/specification/about/}{OpenAPI}
specification and let your apps consume RESTful web services. What's
more, you can consume these APIs without being tied to Liferay DXP's UI
(hence the term \emph{headless}). This gives you a great deal of freedom
when designing and developing your apps.

The articles in this section show you how to navigate and consume
Liferay DXP's headless REST APIs. But first, you'll learn the design
approach for these APIs.

\subsection{API Vocabulary}\label{api-vocabulary}

When defining an API, the developer must decide how to expose the
representation of its resources. This determines its ease of use and how
it can evolve. Traditionally, there are two approaches:

\textbf{Contract Last:} The code is written first and features are
exposed as web or REST services. This approach is typically easier for
developers, as they must only implement and expose the business logic.
\href{/docs/7-1/tutorials/-/knowledge_base/t/service-builder-web-services}{Service
Builder} is an example of this.

\textbf{Contract First:} The structure for client-server messages is
written before the code that implements the services. Such messages are
defined independent of the code. This avoids tight coupling and is less
likely to break clients as APIs evolve.

Liferay DXP's headless web APIs use a mixture of both approaches. An
OpenAPI profile uses a contract first approach by defining the paths and
schemas before writing any code. It then generates an API automatically
based on that profile, using the contract-last characteristic of code
generation (like Service Builder). This allows fast development for
developers.

This mixed approach delivers the best of both worlds, allowing a step of
conscious API design and then simplifying the developer experience by
exposing only the business logic to implement.

When writing the OpenAPI profile, the main focus should be on defining
how client-server messages represent the APIs' resources. In other
words, the APIs' schemas are defined first and the attributes,
resources, and operations are named to clearly define what they
represent and how they should be used.

\section{Get Started: Discover the
API}\label{get-started-discover-the-api}

To begin consuming web services, you must first know where they are
(e.g., a service catalog), what operations you can invoke, and how to
invoke them. Because Liferay DXP's headless REST APIs leverage
\href{https://en.wikipedia.org/wiki/OpenAPI_Specification}{OpenAPI}
(originally known as Swagger), you don't need a service catalog. You
only need to know the OpenAPI profile from which to discover the rest of
the API.

Liferay DXP's headless APIs are available in SwaggerHub at
\href{https://app.swaggerhub.com/organizations/liferayinc}{\texttt{https://app.swaggerhub.com/organizations/liferayinc}}.
Each API has its own URL in SwaggerHub. For example, you can access the
delivery API definition at
\href{https://app.swaggerhub.com/apis/liferayinc/headless-delivery/v1.0}{\texttt{https://app.swaggerhub.com/apis/liferayinc/headless-delivery/v1.0}}.

Each OpenAPI profile is also deployed dynamically in your portal
instance under this schema:

\begin{verbatim}
http://[host]:[port]/o/[insert-headless-api]/[version]/openapi.yaml
\end{verbatim}

For example, if you're running Liferay DXP locally on port
\texttt{8080}, the home URL for discovering the headless delivery API
is:

\begin{verbatim}
http://localhost:8080/o/headless-delivery/v1.0/openapi.yaml
\end{verbatim}

You must be logged in to access this URL, or use basic authentication
and a browser or other tool like
\href{https://www.getpostman.com}{Postman},
\href{https://install.advancedrestclient.com/install}{Advanced REST
Client}, or even the \texttt{curl} command in your system console.

For simplicity, the examples in this documentation use the \texttt{curl}
command and send requests to a Liferay DXP instance running locally on
port \texttt{8080}.

Run this \texttt{curl} command to access the home URL:

\begin{verbatim}
curl http://localhost:8080/o/headless-delivery/v1.0/openapi.yaml -u test@example.com:test
\end{verbatim}

You should get a response like this:

\begin{verbatim}
openapi: 3.0.1
info:
  title: Headless Delivery
  version: v1.0
paths:
  /v1.0/blog-posting-images/{blogPostingImageId}:
    get:
      tags:
      - BlogPostingImage
      operationId: getBlogPostingImage
      parameters:
      - name: blogPostingImageId
        in: path
        required: true
        schema:
          type: integer
          format: int64
      responses:
        default:
          description: default response
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/BlogPostingImage'
(...)
\end{verbatim}

This response follows the OpenAPI version 3.0 syntax to specify the
endpoints (URLs) of the API and schemas returned. You can also open the
OpenAPI profile in an OpenAPI editor like the
\href{https://editor.swagger.io}{Swagger Editor}. You can use this
editor to inspect the documentation and parameters and make requests to
the API.

There are also many other tools that support OpenAPI, such as client
generators, validators, parsers, and more. See
\href{https://openapi.tools/}{OpenAPI.Tools} for a comprehensive list.
Leveraging OpenAPI provides standards support, extensive
\href{https://swagger.io/docs/}{documentation}, and industry-wide
conventions.

\subsection{Related Topics}\label{related-topics-76}

\href{/docs/7-1/tutorials/-/knowledge_base/t/get-started-invoke-a-service}{Get
Started: Invoke a Service}

\section{Get Started: Invoke a
Service}\label{get-started-invoke-a-service}

Once you know which API you want to call via the
\href{/docs/7-1/tutorials/-/knowledge_base/t/get-started-discover-the-api}{OpenAPI
profile}, you can send a request to that resource's URL. For example,
suppose you want to retrieve all the blog entries from a Site. If you
consult the OpenAPI profile for Liferay DXP's delivery API, you can find
this endpoint:

\begin{verbatim}
"/sites/{siteId}/blog-postings":
        get:
            operationId: getSiteBlogPostingsPage
            parameters:
                - in: path
                  name: siteId
                  required: true
                  schema:
                      format: int64
                      type: integer
                - in: query
                  name: filter
                  schema:
                      type: string
                - in: query
                  name: page
                  schema:
                      type: integer
                - in: query
                  name: pageSize
                  schema:
                      type: integer
                - in: query
                  name: search
                  schema:
                      type: string
                - in: query
                  name: sort
                  schema:
                      type: string
            responses:
                200:
                    content:
                        application/json:
                            schema:
                                items:
                                    $ref: "#/components/schemas/BlogPosting"
                                type: array
                    description: ""
            tags: ["BlogPosting"]
\end{verbatim}

The only required parameter is \texttt{siteId}, the ID of the blog
postings' Site. Internally, the \texttt{siteId} is a \texttt{groupId}
that you can retrieve from the database, a URL, or Liferay DXP's UI via
the Site Administration menu. The following GET request gets the site's
blog postings by providing the site ID (\texttt{20124}) in the URL:

\begin{verbatim}
curl "http://localhost:8080/o/headless-delivery/v1.0/sites/20124/blog-postings/" -u 'test@example.com:test'
\end{verbatim}

If you send such a request to a site that contains some blog entries,
the response should look like this:

\begin{verbatim}
{
  "items": [
    {
      "alternativeHeadline": "The power of OpenAPI & Liferay",
      "articleBody": "<p>We are happy to announce...</p>",
      "creator": {
        "familyName": "Test",
        "givenName": "Test",
        "id": 20130,
        "name": "Test Test",
        "profileURL": "/web/test"
      },
      "dateCreated": "2019-04-22T07:04:47Z",
      "dateModified": "2019-04-22T07:04:51Z",
      "datePublished": "2019-04-22T07:02:00Z",
      "encodingFormat": "text/html",
      "friendlyUrlPath": "new-headless-apis",
      "headline": "New Headless APIs",
      "id": 59301,
      "numberOfComments": 0,
      "siteId": 20124
    }
  ],
  "lastPage": 1,
  "page": 1,
  "pageSize": 20,
  "totalCount": 1
}
\end{verbatim}

This response is a JSON object with information about the collection of
blogs. The response's attributes contain information about the resource
(blogs, in this case). Also note that the results are paginated. The
\texttt{*page*} attributes refer to pages of results. Here's a
description of some common attributes:

\texttt{id}: Each item has an ID. You can use the ID to retrieve more
information about that item. For example, there are two \texttt{id}
attributes in the above response: one for the blog posting
(\texttt{59301}) and one for the blog post's creator (\texttt{20130}).

\texttt{lastPage}: The page number of the final page of results. The
above response only contains a single page, so its last page is
\texttt{1}.

\texttt{page}: The page number of the current page. The page in the
above response is \texttt{1}.

\texttt{pageSize}: The possible number of this resource's items to be
included in a single page. In the above response this is \texttt{20}.

\texttt{totalCount}: The total number of this resource's existing items
(independent of pagination). The above response lists the total number
of blog postings (\texttt{1}) in a Site.

To get information on a specific blog posting, send a GET request to the
\texttt{blogPostingId} resource's URL with the blog posting's ID
(\texttt{/blog-postings/\{blogPostingId\}}). For example, the URL for
such a request to the blog posting in the above response is
\texttt{/blog-postings/59301}. Here's an example response:

\begin{verbatim}
{
  "alternativeHeadline": "The power of OpenAPI & Liferay",
  "articleBody": "<p>We are happy to announce...</p>",
  "creator": {
    "familyName": "Test",
    "givenName": "Test",
    "id": 20130,
    "name": "Test Test",
    "profileURL": "/web/test"
  },
  "dateCreated": "2019-04-22T07:04:47Z",
  "dateModified": "2019-04-22T07:04:51Z",
  "datePublished": "2019-04-22T07:02:00Z",
  "encodingFormat": "text/html",
  "friendlyUrlPath": "new-headless-apis",
  "headline": "New Headless APIs",
  "id": 59301,
  "numberOfComments": 0,
  "siteId": 20124
}
\end{verbatim}

Although this response is JSON, the API's consumer can select other
formats to use (like XML). For more information, see
\href{/docs/7-1/tutorials/-/knowledge_base/t/api-formats-and-content-negotiation}{API
Formats and Content Negotiation}.

\subsection{Related Topics}\label{related-topics-77}

\href{/docs/7-1/tutorials/-/knowledge_base/t/get-started-discover-the-api}{Get
Started: Discover the API}

\href{/docs/7-1/tutorials/-/knowledge_base/t/api-formats-and-content-negotiation}{API
Formats and Content Negotiation}

\section{Making Authenticated
Requests}\label{making-authenticated-requests}

To make an authenticated request, you must authenticate as a specific
user.

There are two authentication mechanisms available when invoking web
APIs:

\textbf{Basic Authentication:} Sends the user credentials as an encoded
user name and password pair. This is the simplest authentication
protocol (available since HTTP/1.0).

\textbf{OAuth 2.0:} In 7.0, you can use OAuth 2.0 for authentication.
See the \href{/docs/7-1/deploy/-/knowledge_base/d/oauth-2-0}{OAuth 2.0
documentation} for more information.

First, you'll learn how send requests with basic authentication.

\subsection{Basic Authentication}\label{basic-authentication}

Basic authentication requires that you send an HTTP
\texttt{Authorization} header containing the encoded user name and
password. You must first get that encoded value. To do so, you can use
\texttt{openssl} or a \texttt{Base64} encoder. Either way, you must
encode the \texttt{user:password} string. Here's an example of the
\texttt{openssl} command for encoding the \texttt{user:password} string
for a user \texttt{test@example.com} with the password \texttt{Liferay}:

\begin{verbatim}
openssl base64 <<< test@example.com:Liferay
\end{verbatim}

This returns the encoded value:

\begin{verbatim}
dGVzdEBleGFtcGxlLmNvbTpMaWZlcmF5Cg==
\end{verbatim}

If you don't have \texttt{openssl} installed, try the \texttt{base64}
command:

\begin{verbatim}
base64 <<< test@example.com:Liferay
\end{verbatim}

\noindent\hrulefill

\textbf{Warning:} Encoding a string as shown here does not encrypt the
resulting string. Such an encoded string can easily be decoded by
executing
\texttt{base64\ \textless{}\textless{}\textless{}\ the-encoded-string},
which returns the original string.

Anyone listening to your request could therefore decode the
\texttt{Authorization} header and reveal your user name and password. To
prevent this, ensure that all communication is made through HTTPS, which
encrypts the entire message (including headers).

\noindent\hrulefill

Use the encoded value for the HTTP Authorization header when sending the
request:

\begin{verbatim}
curl -H "Authorization: Basic dGVzdEBleGFtcGxlLmNvbTpMaWZlcmF5Cg==" http://localhost:8080/o/headless-delivery/v1.0/sites/{siteId}/blog-postings/
\end{verbatim}

The response contains data instead of the 403 error that an
unauthenticated request receives. For more information on the response's
structure, see
\href{/docs/7-1/tutorials/-/knowledge_base/t/working-with-collections-of-data}{Working
with Collections of Data}.

\begin{verbatim}
{
  "items": [
    {
      "alternativeHeadline": "The power of OpenAPI & Liferay",
      "articleBody": "<p>We are happy to announce...</p>",
      "creator": {
        "familyName": "Test",
        "givenName": "Test",
        "id": 20130,
        "name": "Test Test",
        "profileURL": "/web/test"
      },
      "dateCreated": "2019-04-22T07:04:47Z",
      "dateModified": "2019-04-22T07:04:51Z",
      "datePublished": "2019-04-22T07:02:00Z",
      "encodingFormat": "text/html",
      "friendlyUrlPath": "new-headless-apis",
      "headline": "New Headless APIs",
      "id": 59301,
      "numberOfComments": 0,
      "siteId": 20124
    },
    {
      "alternativeHeadline": "How to work with OAuth",
      "articleBody": "<p>To configure OAuth...</p>",
      "creator": {
        "familyName": "Test",
        "givenName": "Test",
        "id": 20130,
        "name": "Test Test",
        "profileURL": "/web/test"
      },
      "dateCreated": "2019-04-22T09:35:09Z",
      "dateModified": "2019-04-22T09:35:09Z",
      "datePublished": "2019-04-22T09:34:00Z",
      "encodingFormat": "text/html",
      "friendlyUrlPath": "authenticated-requests",
      "headline": "Authenticated requests",
      "id": 59309,
      "numberOfComments": 0,
      "siteId": 20124
    }
  ],
  "lastPage": 1,
  "page": 1,
  "pageSize": 20,
  "totalCount": 2
}
\end{verbatim}

\subsection{OAuth 2.0 Authentication}\label{oauth-2.0-authentication}

7.0 supports authorization via OAuth 2.0, which is a token-based
authentication mechanism. For more details, see
\href{/docs/7-1/deploy/-/knowledge_base/d/oauth-2-0}{Liferay DXP's OAuth
2.0 documentation}. The following sections show you how to use OAuth 2.0
to authenticate web API requests.

\subsubsection{Obtaining the OAuth 2.0
Token}\label{obtaining-the-oauth-2.0-token}

Before using OAuth 2.0 to invoke a web API, you must register your
application (your web API's consumer) as an authorized OAuth client. To
do this, follow the instructions in the
\href{/docs/7-1/deploy/-/knowledge_base/d/oauth-2-0\#creating-an-application}{Creating
an Application} section of the OAuth 2.0 documentation. When creating
the application, fill in the form as follows:

\textbf{Application Name:} Your application's name.

\textbf{Client Profile:} Headless Server.

\textbf{Allowed Authorization Types:} Check \emph{Client Credentials}.

After clicking \emph{Save} to finish creating the application, write
down the Client ID and Client Secret values that appear at the top of
the form.

Next, you must get an OAuth 2.0 access token. To do this, see the
tutorial
\href{/docs/7-1/deploy/-/knowledge_base/d/authorizing-account-access-with-oauth2}{Authorizing
Account Access with OAuth 2}.

\subsubsection{Invoking the Service with an OAuth 2.0
Token}\label{invoking-the-service-with-an-oauth-2.0-token}

Once you have a valid OAuth 2.0 token, include it in the request's
\texttt{Authorization} header, specifying that the authentication type
is a \href{https://tools.ietf.org/html/rfc6750}{bearer token}. For
example:

\begin{verbatim}
curl -H "Authorization: Bearer d5571ff781dc555415c478872f0755c773fa159" http://localhost:8080/o/headless-delivery/v1.0/sites/{siteId}/blog-postings/
\end{verbatim}

The response contains the resources that the authenticated user has
permission to access, just like the response from Basic authentication.

\subsection{Making Unauthenticated
Requests}\label{making-unauthenticated-requests}

Unauthenticated requests are disabled by default in Liferay DXP's
headless REST APIs. You can, however, enable them manually by following
these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Create the config file
  \texttt{com.liferay.headless.delivery.internal.jaxrs.application.HeadlessDeliveryApplication-default.config}
  and add this code to it:
\end{enumerate}

\begin{verbatim}
oauth2.scopechecker.type="none"
auth.verifier.auth.verifier.BasicAuthHeaderAuthVerifier.urls.includes="*"
auth.verifier.auth.verifier.OAuth2RestAuthVerifier.urls.includes="*"
auth.verifier.guest.allowed="true"
\end{verbatim}

\begin{verbatim}
Note that the last property (`auth.verifier.guest.allowed`) lets guests 
access public content via the APIs. To turn this off, set the property to 
`false`. 
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\item
  Deploy the config file to \texttt{{[}Liferay\ Home{]}/osgi/configs}.
  Note that
  \href{/docs/7-1/deploy/-/knowledge_base/d/installing-liferay\#liferay-home}{Liferay
  Home} is typically the application server's parent folder.
\item
  Test the APIs by making a request to an OpenAPI profile URL:
\end{enumerate}

\begin{verbatim}
curl "http://localhost:8080/o/headless-delivery/v1.0/openapi.yaml"
\end{verbatim}

You should get the OpenAPI profile for the API you sent the request to.

\subsection{Related Topics}\label{related-topics-78}

\href{/docs/7-1/tutorials/-/knowledge_base/t/get-started-invoke-a-service}{Get
Started: Invoke a Service}

\href{/docs/7-1/tutorials/-/knowledge_base/t/working-with-collections-of-data}{Working
with Collections of Data}

\section{Working with Collections of
Data}\label{working-with-collections-of-data}

Collection resources are common in Liferay DXP web APIs. If you followed
along with the previous examples that sent requests to the portal's
\texttt{blog-postings} resource URL, you've already seen collections in
action: the \texttt{BlogPosting} resource is a collection.

Here, you'll learn more detailed information about working with
collection resources. But first you should learn about how collections
are returned in pages.

\subsection{Pagination}\label{pagination}

A small collection can be transmitted in a single response without
difficulty. Transmitting a large collection all at once, however, can
consume too much bandwidth, time, and memory. It can also overwhelm the
user with too much data. It's therefore best to get and display the
elements of a large collection in discrete chunks, or pages.

Liferay DXP's headless REST APIs return paginated collections by
default. The following attributes in the responses also contain the
information needed to navigate between those pages:

\texttt{totalCount}: The total number of this resource's items.

\texttt{pageSize}: The number of this resource's items to be included in
this response.

\texttt{page}: The current page's number.

\texttt{lastPage}: The last page's number.

\texttt{items}: The collection elements present in this page. Each
element also contains the data of the object it represents, so there's
no need for additional requests for individual elements.

\texttt{id}: Each item's identifier. You can use this, if necessary, to
get more information on a specific item.

For examples of working with collection pages, see
\href{/docs/7-1/tutorials/-/knowledge_base/t/pagination}{Pagination}.

\section{Getting Collections}\label{getting-collections}

Requests for collection resources are the same as those for
non-collection resources. For example, an
\href{/docs/7-1/tutorials/-/knowledge_base/t/making-authenticated-requests}{authenticated
request} to the \texttt{UserAccount} endpoint returns a collection
containing the portal's users. When sending this request, use the
credentials of an administrative user who has permission to view other
portal users:

\begin{verbatim}
curl "http://localhost:8080/o/headless-admin-user/v1.0/user-accounts"  -u 'test@example.com:test'
\end{verbatim}

The response (below) has two main parts:

\begin{itemize}
\item
  The list of collection elements, inside the \texttt{items} attribute.
  This example contains data on two users: an administrator (Test), and
  a user named Javier Gamarra.
\item
  A set of metadata about the collection. This is the rest of the data
  in the response. This lets clients know how to use the collection.
\end{itemize}

This response is in JSON, which is the default response format for web
APIs in Liferay DXP. For information on specifying other response
formats, see
\href{/docs/7-1/tutorials/-/knowledge_base/t/api-formats-and-content-negotiation}{API
Formats and Content Negotiation}.

\begin{verbatim}
{
  "items": [
    {
      "alternateName": "test",
      "birthDate": "1970-01-01T00:00:00Z",
      "contactInformation": {},
      "dashboardURL": "/user/test",
      "dateCreated": "2019-04-17T20:37:19Z",
      "dateModified": "2019-04-22T09:56:35Z",
      "emailAddress": "test@example.com",
      "familyName": "Test",
      "givenName": "Test",
      "id": 20130,
      "name": "Test Test",
      "profileURL": "/web/test",
      ...
    },
    {
      "alternateName": "nhpatt",
      "birthDate": "1970-01-01T00:00:00Z",
      "contactInformation": {},
      "dateCreated": "2019-04-22T10:38:36Z",
      "dateModified": "2019-04-22T10:38:37Z",
      "emailAddress": "nhpatt@gmail.com",
      "familyName": "Gamarra",
      "givenName": "Javier",
      "id": 59347,
      "name": "Javier Gamarra",
      ...
    }
  ],
  "lastPage": 1,
  "page": 1,
  "pageSize": 20,
  "totalCount": 2
}
\end{verbatim}

\subsection{Related Topics}\label{related-topics-79}

\href{/docs/7-1/tutorials/-/knowledge_base/t/pagination}{Pagination}

\href{/docs/7-1/tutorials/-/knowledge_base/t/making-authenticated-requests}{Making
Authenticated Requests}

\href{/docs/7-1/tutorials/-/knowledge_base/t/api-formats-and-content-negotiation}{API
Formats and Content Negotiation}

\section{Pagination}\label{pagination-1}

Collection resources are returned in pages of information.
\href{/docs/7-1/tutorials/-/knowledge_base/t/working-with-collections-of-data}{Working
with Collections of Data} explains this in more detail. Here, you'll
learn how to work with collection pages.

For example, suppose that there are 123 users your portal and you want
to get information on them. To do this, send an
\href{/docs/7-1/tutorials/-/knowledge_base/t/making-authenticated-requests}{authenticated
request} to the UserAccount URL:

\begin{verbatim}
curl "http://localhost:8080/o/headless-admin-user/v1.0/user-accounts"  -u 'test@example.com:test'
\end{verbatim}

The response contains the first 30 users and IDs for navigating the rest
of the collection. Note that most of the contents of the \texttt{items}
attribute, which contains the users, are omitted here so you can focus
on the metadata for navigating the collection:

\begin{verbatim}
{
      "items": [
        {
          "id": 20130,
          ...
        },
        {
          "id": 59347,
          ...
        }
      ],
      "lastPage": 5,
      "page": 1,
      "pageSize": 30,
      "totalCount": 123
    }
\end{verbatim}

The attributes \texttt{page} and \texttt{pageSize} allow client
applications to navigate through the results. For example, such a client
could send a request for a specific page. This example gets the second
page (\texttt{?page=2}) of documents that exist on the site with the ID
\texttt{20124}:

\begin{verbatim}
curl "http://localhost:8080/o/headless-delivery/v1.0/sites/20124/documents?page=2"  -u 'test@example.com:test'
\end{verbatim}

Similarly, you can customize the number of elements per page via the
optional parameter \texttt{pageSize} (e.g., \texttt{?pageSize=20}).

\subsection{Related Topics}\label{related-topics-80}

\href{/docs/7-1/tutorials/-/knowledge_base/t/working-with-collections-of-data}{Working
with Collections of Data}

\href{/docs/7-1/tutorials/-/knowledge_base/t/making-authenticated-requests}{Making
Authenticated Requests}

\section{Navigating from a Collection to its
Elements}\label{navigating-from-a-collection-to-its-elements}

When you
\href{/docs/7-1/tutorials/-/knowledge_base/t/getting-collections}{get a
collection}, you can use the response to get an element of that
collection. Follow these steps to do so:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Get a collection. This example gets a list of users by sending
  \href{/docs/7-1/tutorials/-/knowledge_base/t/making-authenticated-requests}{an
  authenticated request} to the \texttt{user-accounts} collection:

\begin{verbatim}
curl "http://localhost:8080/o/headless-admin-user/v1.0/user-accounts"  -u 'test@example.com:test'
\end{verbatim}

  Recall from
  \href{/docs/7-1/tutorials/-/knowledge_base/t/getting-collections}{Getting
  Collections} that the response's \texttt{items} attribute contains the
  collection elements. In this case, the collection contains two users:
  Test Test and Javier Gamarra:

  \texttt{json\ \{\ \ \ \ \ "totalItems":\ 2,\ \ \ \ \ "numberOfItems":\ 2,\ \ \ \ \ "view":\ \{\ \ \ \ \ \ \ \ \ \{\ \ \ \ \ \ \ \ \ \ \ "items":\ {[}\ \ \ \ \ \ \ \ \ \ \ \ \ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "alternateName":\ "test",\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "birthDate":\ "1970-01-01T00:00:00Z",\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "contactInformation":\ \{\},\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "dashboardURL":\ "/user/test",\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "dateCreated":\ "2019-04-17T20:37:19Z",\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "dateModified":\ "2019-04-22T09:56:35Z",\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "emailAddress":\ "test@example.com",\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "familyName":\ "Test",\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "givenName":\ "Test",\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "id":\ 20130,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "name":\ "Test\ Test",\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "profileURL":\ "/web/test",\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "roleBriefs":\ {[}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "id":\ 20108,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "name":\ "Administrator"\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \},\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "id":\ 20111,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "name":\ "Power\ User"\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \},\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "id":\ 20112,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "name":\ "User"\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ {]},\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "siteBriefs":\ {[}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "id":\ 20128,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "name":\ "Global"\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \},\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "id":\ 20124,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "name":\ "Guest"\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ {]}\ \ \ \ \ \ \ \ \ \ \ \ \ \},\ \ \ \ \ \ \ \ \ \ \ \ \ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "alternateName":\ "nhpatt",\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "birthDate":\ "1970-01-01T00:00:00Z",\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "contactInformation":\ \{\},\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "dateCreated":\ "2019-04-22T10:38:36Z",\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "dateModified":\ "2019-04-22T10:38:37Z",\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "emailAddress":\ "nhpatt@gmail.com",\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "familyName":\ "Gamarra",\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "givenName":\ "Javier",\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "id":\ 59347,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "name":\ "Javier\ Gamarra",\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "roleBriefs":\ {[}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "id":\ 20112,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "name":\ "User"\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ {]},\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "siteBriefs":\ {[}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "id":\ 20128,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "name":\ "Global"\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \},\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "id":\ 20124,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "name":\ "Guest"\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ {]}\ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ {]},\ \ \ \ \ \ \ \ \ \ \ "lastPage":\ 1,\ \ \ \ \ \ \ \ \ \ \ "page":\ 1,\ \ \ \ \ \ \ \ \ \ \ "pageSize":\ 20,\ \ \ \ \ \ \ \ \ \ \ "totalCount":\ 2\ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \}}
\item
  In the response, locate the ID of the element you want and look in the
  OpenAPI profile for the appropriate GET item endpoint. For example,
  the \texttt{user-accounts} GET item endpoint is
  \texttt{/user-accounts/\{userAccountId\}}.
\item
  Send a GET request to that endpoint. For example, this request gets
  information for the user with the ID \texttt{59347} (Javier Gamarra):

\begin{verbatim}
curl "http://localhost:8080/o/headless-admin-user/v1.0/user-accounts/59347"  -u 'test@example.com:test'
\end{verbatim}
\end{enumerate}

\subsection{Related Topics}\label{related-topics-81}

\href{/docs/7-1/tutorials/-/knowledge_base/t/getting-collections}{Getting
Collections}

\href{/docs/7-1/tutorials/-/knowledge_base/t/pagination}{Pagination}

\href{/docs/7-1/tutorials/-/knowledge_base/t/making-authenticated-requests}{Making
Authenticated Requests}

\section{API Formats and Content
Negotiation}\label{api-formats-and-content-negotiation}

The responses in the preceding examples use a standard JSON format,
which is the default response format for Liferay DXP's headless REST
APIs. You can also use other formats like XML. Formats typically differ
in the resource metadata's structure or semantics. There's no best
format; use the one that best fits your use case.

You use \emph{content negotiation} to specify different formats for use.
Content negotiation is how the client and server establish the format
they use to exchange messages. The client tells the server its preferred
format via the HTTP headers \texttt{Accept} and \texttt{Content-Type}.
Each format has a string identifier (its MIME type) that you can use in
the HTTP headers to specify the format. The following table lists the
MIME type for each supported format.

\noindent\hrulefill

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.2812}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.7188}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
API Format
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
~MIME Type
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
application/json &
\href{https://www.iana.org/assignments/media-types/application/json}{application/json} \\
application/xml &
\href{https://www.iana.org/assignments/media-types/application/xml}{application/xml} \\
\end{longtable}

\noindent\hrulefill

When you send a request without specifying the API format, the server
responds with the default JSON. For example, here's such a request for a
list of folders from the Site with the ID \texttt{20124}:

\begin{verbatim}
curl "http://localhost:8080/o/headless-delivery/v1.0/sites/20124/document-folders" -u 'test@example.com:test'
\end{verbatim}

\begin{verbatim}
{
  "items": [
    {
      "creator": {
        "familyName": "Test",
        "givenName": "Test",
        "id": 20130,
        "name": "Test Test",
        "profileURL": "/web/test"
      },
      "dateCreated": "2019-04-22T10:21:20Z",
      "dateModified": "2019-04-22T10:21:20Z",
      "id": 59319,
      "name": "REST APIs Documentation",
      "numberOfDocumentFolders": 0,
      "numberOfDocuments": 0,
      "siteId": 20124
    }
  ],
  "lastPage": 1,
  "page": 1,
  "pageSize": 20,
  "totalCount": 1
}
\end{verbatim}

If you request the headers, the \texttt{Content-Type} response attribute
lists the content type's format (JSON, in this case):

\begin{verbatim}
curl "http://localhost:8080/o/headless-delivery/v1.0/sites/20124/document-folders" -u 'test@example.com:test' --head
\end{verbatim}

\begin{verbatim}
HTTP/1.1 200 
X-Content-Type-Options: nosniff
X-Frame-Options: SAMEORIGIN
X-XSS-Protection: 1
Set-Cookie: JSESSIONID=9F61AEB8721DD9149BD577ECBC31AE3F; Path=/; HttpOnly
Expires: Thu, 01 Jan 1970 00:00:00 GMT
Cache-Control: private, no-cache, no-store, must-revalidate
Pragma: no-cache
Set-Cookie: COOKIE_SUPPORT=true; Max-Age=31536000; Expires=Tue, 21-Apr-2020 10:23:57 GMT; Path=/; HttpOnly
Set-Cookie: GUEST_LANGUAGE_ID=en_US; Max-Age=31536000; Expires=Tue, 21-Apr-2020 10:23:57 GMT; Path=/; HttpOnly
Date: Mon, 22 Apr 2019 10:23:57 GMT
Content-Type: application/json
Transfer-Encoding: chunked
\end{verbatim}

To get the response in XML instead, specify \texttt{application/xml} in
the request's \texttt{Accept} header. Note that the XML response
includes the same information as JSON, but is structured differently:

\begin{verbatim}
curl "http://localhost:8080/o/headless-delivery/v1.0/documents/59203"  -H 'Accept: application/xml'  -u 'test@example.com:test'
\end{verbatim}

\begin{verbatim}
    <Page>
        <items>
            <items>
                <creator>
                    <familyName>Test</familyName>
                    <givenName>Test</givenName>
                    <id>20130</id>
                    <name>Test Test</name>
                    <profileURL>/web/test</profileURL>
                    </creator>
                <dateCreated>2019-04-22T10:21:20Z</dateCreated>
                <dateModified>2019-04-22T10:21:20Z</dateModified>
                <id>59319</id>
                <name>REST APIs Documentation</name>
                <numberOfDocumentFolders>0</numberOfDocumentFolders>
                <numberOfDocuments>0</numberOfDocuments>
                <siteId>20124</siteId>
            </items>
        </items>
        <lastPage>1</lastPage>
        <page>1</page>
        <pageSize>20</pageSize>
        <totalCount>1</totalCount>
    </Page>
\end{verbatim}

Requesting the headers, you can see that the response is in XML
(\texttt{application/xml}):

\begin{verbatim}
curl "http://localhost:8080/o/headless-delivery/v1.0/documents/59203"  -H 'Accept: application/xml'  -u 'test@example.com:test' --head
\end{verbatim}

\begin{verbatim}
HTTP/1.1 200 
X-Content-Type-Options: nosniff
X-Frame-Options: SAMEORIGIN
X-XSS-Protection: 1
Expires: Thu, 01 Jan 1970 00:00:00 GMT
Cache-Control: private, no-cache, no-store, must-revalidate
Pragma: no-cache
Date: Mon, 22 Apr 2019 10:26:21 GMT
Content-Type: application/xml
Transfer-Encoding: chunked
\end{verbatim}

\subsection{Language Negotiation}\label{language-negotiation}

The same mechanism used for requesting another response format (content
negotiation) is used for requesting content in another language.

APIs that are available in different languages return the options in a
block called \texttt{availableLanguages}. For example, this block in the
following response lists U.S. English (\texttt{en-US}) and
Spain/Castilian Spanish (\texttt{es-ES}):

\begin{verbatim}
{
  "availableLanguages": [
    "en-US",
    "es-ES"
  ],
  "contentFields": [
    {
      "dataType": "html",
      "name": "content",
      "repeatable": false,
      "value": {
        "data": "<p>The main reason is because Headless APIs have been designed with real use cases in mind...</p>"
      }
    }
  ],
  "contentStructureId": 36801,
  "creator": {
    "familyName": "Test",
    "givenName": "Test",
    "id": 20130,
    "name": "Test Test",
    "profileURL": "/web/test"
  },
  "dateCreated": "2019-04-22T10:29:40Z",
  "dateModified": "2019-04-22T10:30:31Z",
  "datePublished": "2019-04-22T10:28:00Z",
  "friendlyUrlPath": "why-headless-apis-are-better-than-json-ws-services-",
  "id": 59325,
  "key": "59323",
  "numberOfComments": 0,
  "renderedContents": [
    {
      "renderedContentURL": "http://localhost:8080/o/headless-delivery/v1.0/structured-contents/59325/rendered-content/36804",
      "templateName": "Basic Web Content"
    }
  ],
  "siteId": 20124,
  "title": "Why Headless APIs are better than JSON-WS services?",
  "uuid": "e1c4c152-e47c-313f-2d16-2ee4eba5cd26"
}
\end{verbatim}

To request the content in another language, specify your desired locale
in the request's \texttt{Accept-Language} header:

\begin{verbatim}
curl "http://localhost:8080/o/headless-delivery/v1.0/structured-contents/59325"  -H 'Accept-Language: es-ES'  -u 'test@example.com:test'
\end{verbatim}

\begin{verbatim}
    {
      "availableLanguages": [
        "en-US",
        "es-ES"
      ],
      "contentFields": [
        {
          "dataType": "html",
          "name": "content",
          "repeatable": false,
          "value": {
            "data": "<p>La principal razón es porque las APIs Headless se han diseñado pensando en casos de uso reales...</p>"
          }
        }
      ],
      "contentStructureId": 36801,
      "creator": {
        "familyName": "Test",
        "givenName": "Test",
        "id": 20130,
        "name": "Test Test",
        "profileURL": "/web/test"
      },
      "dateCreated": "2019-04-22T10:29:40Z",
      "dateModified": "2019-04-22T10:30:31Z",
      "datePublished": "2019-04-22T10:28:00Z",
      "friendlyUrlPath": "%C2%BFpor-qu%C3%A9-las-apis-headless-son-mejores-que-json-ws-",
      "id": 59325,
      "key": "59323",
      "numberOfComments": 0,
      "renderedContents": [
        {
          "renderedContentURL": "http://localhost:8080/o/headless-delivery/v1.0/structured-contents/59325/rendered-content/36804",
          "templateName": "Contenido web básico"
        }
      ],
      "siteId": 20124,
      "title": "¿Por qué las APIs Headless son mejores que JSON-WS?",
      "uuid": "e1c4c152-e47c-313f-2d16-2ee4eba5cd26"
    }
\end{verbatim}

\subsubsection{Creating Content with Different
Languages}\label{creating-content-with-different-languages}

By default, when sending a POST/PUT request, the
\texttt{Accept-Language} header is used as the content's language.
However, there is one exception. Some entities require the first POST to
be in the Site's default language. In such cases, a POST request for a
different language results in an error.

After creating a new resource, PUT requests in a different language add
that translation. PATCH requests return an error (you are expected to
update, not create, in a PATCH request).

\subsection{Related Topics}\label{related-topics-82}

\href{/docs/7-1/tutorials/-/knowledge_base/t/get-started-discover-the-api}{Get
Started: Discover the API}

\href{/docs/7-1/tutorials/-/knowledge_base/t/get-started-invoke-a-service}{Get
Started: Invoke a Service}

\section{OpenAPI Profiles}\label{openapi-profiles}

All the APIs exposed by Liferay DXP are available under the
\href{https://app.swaggerhub.com/organizations/liferayinc}{liferayinc
SwaggerHub organization}.

Liferay DXP's headless APIs are categorized in two different use cases:

\begin{itemize}
\tightlist
\item
  Delivering content (delivery APIs)
\item
  Managing and administering content (admin APIs)
\end{itemize}

The available APIs demonstrate this categorization.

\subsection{Headless Delivery}\label{headless-delivery}

The following table lists the APIs that
\href{https://app.swaggerhub.com/apis/liferayinc/headless-delivery/v1.0}{Headless
Delivery} contains. Note that the second column shows which internal
model in Liferay DXP that the API maps to.

\noindent\hrulefill

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.2812}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.7188}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
API
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
~Internal Model
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{BlogPosting} & \texttt{BlogsEntry} \\
\texttt{BlogPostingImage} & \texttt{DLFileEntry} (associated with a
\texttt{BlogsEntry}) \\
\texttt{Comment} & \texttt{DiscussionComment} \\
\texttt{ContentDocument} & \texttt{DLFileEntry} (associated with a
\texttt{JournalArticle}) \\
\texttt{ContentSet} & \texttt{AssetListEntry} \\
\texttt{ContentStructure} & \texttt{DDMStructure} \\
\texttt{Document} & \texttt{DLFileEntry} \\
\texttt{DocumentFolder} & \texttt{Folder} \\
\texttt{KnowledgeBaseArticle} & \texttt{KBArticle} \\
\texttt{KnowledgeBaseAttachment} & \texttt{FileEntry} (associated with a
\texttt{KBArticle}) \\
\texttt{KnowledgeBaseFolder} & \texttt{KBFolder} \\
\texttt{MessageBoardAttachment} & \texttt{FileEntry} (associated with a
\texttt{MBMessage}) \\
\texttt{MessageBoardMessage} & \texttt{MBMessage} \\
\texttt{MessageBoardSection} & \texttt{MBCategory} \\
\texttt{MessageBoardThread} & \texttt{MBThread} \\
\texttt{Rating} & \texttt{RatingsEntry} \\
\texttt{StructuredContent} & \texttt{JournalArticle} \\
\texttt{StructuredContentFolder} & \texttt{JournalFolder} \\
\end{longtable}

\noindent\hrulefill

\subsection{Headless Administration}\label{headless-administration}

There are several headless admin APIs, each containing its own set of
APIs. The following tables list these, as well as any internal models in
Liferay DXP that each API maps to.

\href{https://app.swaggerhub.com/apis/liferayinc/headless-admin-user/1.0}{Headless
Admin User} contains the following APIs for retrieving and managing
information about users and organizations.

\noindent\hrulefill

\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
API & ~Internal Model \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{EmailAddress} & N/A \\
\texttt{Organization} & N/A \\
\texttt{Phone} & N/A \\
\texttt{PostalAddress} & \texttt{Address} \\
\texttt{Role} & N/A \\
\texttt{Segment} & \texttt{SegmentEntry} \\
\texttt{SegmentUser} & N/A \\
\texttt{SiteBrief} & N/A \\
\texttt{UserAccount} & \texttt{User} \\
\texttt{WebUrl} & \texttt{WebSite} \\
\end{longtable}

\noindent\hrulefill

\href{https://app.swaggerhub.com/apis/liferayinc/headless-admin-taxonomy/1.0}{Headless
Admin Taxonomy} contains the following APIs for managing asset
categories, asset vocabularies, and asset tags.

\noindent\hrulefill

\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
API & ~Internal Model \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{Keyword} & \texttt{AssetTag} \\
\texttt{TaxonomyCategory} & \texttt{AssetCategory} \\
\texttt{TaxonomyVocabulary} & \texttt{AssetVocabulary} \\
\end{longtable}

\noindent\hrulefill

\href{https://app.swaggerhub.com/apis/liferayinc/headless-admin-workflow/1.0}{Headless
Admin Workflow} contains APIs for transitioning workflows.

\subsection{Related Topics}\label{related-topics-83}

\href{/docs/7-1/tutorials/-/knowledge_base/t/api-formats-and-content-negotiation}{API
Formats and Content Negotiation}

\section{Filter, Sort, and Search}\label{filter-sort-and-search}

You can use Liferay DXP's headless REST APIs to search for content
you're interested in. You can also sort and filter content. Here, you'll
learn how.

\subsection{Filter}\label{filter}

It's often useful to filter large collections for the exact data that
you need. Not all collections, however, allow filtering. The ones that
support it contain the optional parameter \texttt{filter} in their
OpenAPI profile. To filter a collection based on the value of one or
more fields, use the \texttt{filter} parameter following a subset of the
oData standard.

Filtering mainly applies to fields indexed as keywords in Liferay DXP's
search. To find content by terms contained in fields indexed as text,
you should instead use \hyperref[search]{search}.

\subsubsection{Comparison Operators}\label{comparison-operators}

\noindent\hrulefill

Operator \textbar{} Description \textbar{} Example \textbar{}
\texttt{eq} \textbar{} Equal \textbar{}
\texttt{addressLocality\ eq\ \textquotesingle{}Redmond\textquotesingle{}}
\textbar{} \textbar{} Equal null \textbar{}
\texttt{addressLocality\ eq\ null} \textbar{} \texttt{ne} \textbar{} Not
equal \textbar{}
\texttt{addressLocality\ ne\ \textquotesingle{}London\textquotesingle{}}
\textbar{} \textbar{} Not null \textbar{}
\texttt{addressLocality\ ne\ null} \textbar{} \texttt{gt} \textbar{}
Greater than \textbar{} \texttt{price\ gt\ 20} \textbar{} \texttt{ge}
\textbar{} Greater than or equal \textbar{} \texttt{price\ ge\ 10}
\textbar{} \texttt{lt} \textbar{} Less than \textbar{}
\texttt{dateCreated\ lt\ 2018-02-13T12:33:12Z} \textbar{} \texttt{le}
\textbar{} Less than or equal \textbar{}
\texttt{dateCreated\ le\ 2012-05-29T09:13:28Z} \textbar{}
\texttt{startsWith} \textbar{} Starts with \textbar{}
\texttt{addressLocality\ startsWith\ \textquotesingle{}Lond\textquotesingle{}}
\textbar{}

\noindent\hrulefill

\subsubsection{Logical Operators}\label{logical-operators}

\noindent\hrulefill

\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Operator & Description & Example \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{and} & Logical and &
\texttt{price\ le\ 200\ and\ price\ gt\ 3.5} \\
\texttt{or} & Logical or &
\texttt{price\ le\ 3.5\ or\ price\ gt\ 200} \\
\texttt{not} & Logical not & \texttt{not\ (price\ le\ 3.5)} \\
\end{longtable}

\noindent\hrulefill

Note that the \texttt{not} operator needs a space character after it.

\subsubsection{Grouping Operators}\label{grouping-operators}

\noindent\hrulefill

Operator \textbar{} Description \textbar{} Example \textbar{}
\texttt{(\ )} \textbar{} Precedence grouping \textbar{}
\texttt{(price\ eq\ 5)\ or\ (addressLocality\ eq\ \textquotesingle{}London\textquotesingle{})}
\textbar{}

\noindent\hrulefill

\subsubsection{String Functions}\label{string-functions}

\noindent\hrulefill

\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Function & Description & Example \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{contains} & Contains &
\texttt{contains(title,\textquotesingle{}edmon\textquotesingle{})} \\
\end{longtable}

\noindent\hrulefill

\subsubsection{Lambda Operators}\label{lambda-operators}

Lambda operators evaluate a boolean expression on a collection. They
must be prepended with a navigation path that identifies a collection.

\noindent\hrulefill

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.2206}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.1618}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.6176}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Lambda Operator
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Description
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Example
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{any} & Any &
\texttt{keywords/any(k:contains(k,\textquotesingle{}substring1\textquotesingle{}))} \\
\end{longtable}

\noindent\hrulefill

The \texttt{any} operator applies a boolean expression to each
collection element and evaluates to \texttt{true} if the expression is
true for any element.

\subsubsection{Escaping in Queries}\label{escaping-in-queries}

You can escape a single quote in a value by adding another single quote.
For example, to filter for a blog posting whose headline is
\texttt{New\ Headless\ APIs}, append this filter string to the request
URL:

\begin{verbatim}
?filter=headline eq 'New Headless APIs'
\end{verbatim}

Here's an example of the full request:

\begin{verbatim}
curl "http://localhost:8080/o/headless-delivery/v1.0/sites/20124/blog-postings/?filter=headline%20eq%20%27New%20Headless%20APIs%27"  -u 'test@example.com:test'
\end{verbatim}

\begin{verbatim}
{
  "items": [
    {
      "alternativeHeadline": "The power of OpenAPI & Liferay",
      "articleBody": "<p>We are happy to announce...</p>",
      "creator": {
        "familyName": "Test",
        "givenName": "Test",
        "id": 20130,
        "name": "Test Test",
        "profileURL": "/web/test"
      },
      "dateCreated": "2019-04-22T07:04:47Z",
      "dateModified": "2019-04-22T07:04:51Z",
      "datePublished": "2019-04-22T07:02:00Z",
      "encodingFormat": "text/html",
      "friendlyUrlPath": "new-headless-apis",
      "headline": "New Headless APIs",
      "id": 59301,
      "numberOfComments": 0,
      "siteId": 20124
    }
  ],
  "lastPage": 1,
  "page": 1,
  "pageSize": 20,
  "totalCount": 1
}
\end{verbatim}

\subsubsection{Filtering in Structured Content Fields
(ContentField)}\label{filtering-in-structured-content-fields-contentfield}

To filter for a \texttt{ContentField} value (dynamic values created by
the end user), you must use the endpoints that are scoped to an
individual \texttt{ContentStructure}. To do so, find the ID of the
\texttt{ContentStructure} and use it in place of
\texttt{\{contentStructureId\}} in this URL:

\begin{verbatim}
"/content-structures/{contentStructureId}/structured-contents"
\end{verbatim}

\subsection{Search}\label{search}

It's often useful to search large collections with keywords. Use search
when you want results from any field, rather than specific ones. To
perform a search, use the optional parameter \texttt{search} followed by
the search terms. For example, this request searches for all the
\texttt{BlogEntry} fields containing OAuth:

\begin{verbatim}
curl "http://localhost:8080/o/headless-delivery/v1.0/sites/20124/blog-postings/?search=OAuth"  -u 'test@example.com:test'
\end{verbatim}

\begin{verbatim}
{
  "items": [
    {
      "alternativeHeadline": "How to work with OAuth",
      "articleBody": "<p>To configure OAuth...</p>",
      "creator": {
        "familyName": "Test",
        "givenName": "Test",
        "id": 20130,
        "name": "Test Test",
        "profileURL": "/web/test"
      },
      "dateCreated": "2019-04-22T09:35:09Z",
      "dateModified": "2019-04-22T09:35:09Z",
      "datePublished": "2019-04-22T09:34:00Z",
      "encodingFormat": "text/html",
      "friendlyUrlPath": "authenticated-requests",
      "headline": "Authenticated requests",
      "id": 59309,
      "numberOfComments": 0,
      "siteId": 20124
    }
  ],
  "lastPage": 1,
  "page": 1,
  "pageSize": 20,
  "totalCount": 1
}
\end{verbatim}

\subsection{Sorting}\label{sorting}

Sorting collection results is another common task. Note, however, that
not all collections allow sorting. The ones that support it contain the
optional parameter \texttt{\{lb\}?sort\{rb\}} in their OpenAPI profile.

To get sorted collection results, append
\texttt{?sort=\textless{}param-name\textgreater{}} to the request URL.
For example, appending \texttt{?sort=title} to the request URL sorts the
results by title.

The default sort order is ascending (0-1, A-Z). To perform a descending
sort, append \texttt{:desc} to the parameter name. For example, to
perform a descending sort by title, append \texttt{?sort=title:desc} to
the request URL.

To sort by more than one parameter, separate the parameter names by
commas and put them in order of priority. For example, to sort first by
title and then by creation date, append \texttt{?sort=title,dateCreated}
to the request URL.

To specify a descending sort for only one parameter, you must explicitly
specify ascending sort order (\texttt{:asc}) for the other parameters.
For example:

\begin{verbatim}
?sort=headline:desc,dateCreated:asc
\end{verbatim}

\subsection{Flatten}\label{flatten}

Some collections (as defined in their OpenAPI profile) allow the query
parameter \texttt{flatten}, which returns all resources and disregards
folders or other hierarchical classifications. This parameter's default
value is \texttt{false}, so a document query to the root folder returns
only the documents in that folder. With \texttt{flatten} set to
\texttt{true}, the same query also returns documents in any subfolders,
regardless of how deeply those folders are nested. In other words,
setting \texttt{flatten} set to \texttt{true} and querying for documents
in a Site's root folder returns all the documents in the Site.

\subsection{Related Topics}\label{related-topics-84}

\href{/docs/7-1/tutorials/-/knowledge_base/t/making-authenticated-requests}{Making
Authenticated Requests}

\href{/docs/7-1/tutorials/-/knowledge_base/t/api-formats-and-content-negotiation}{API
Formats and Content Negotiation}

\href{/docs/7-1/tutorials/-/knowledge_base/t/working-with-collections-of-data}{Working
with Collections of Data}

\section{Restrict Properties}\label{restrict-properties}

Retrieving large entities or collections increases the response's size
and uses more bandwidth. You can alleviate this by telling the server
via the request which fields it should include in the response. This is
known as \emph{sparse fieldsets}. To make a request with sparse
fieldsets, include the \texttt{fields} parameter in the URL with the
name of each field's attribute.

For example, this request doesn't use sparse fieldsets and therefore
returns all the fields of a blog posting:

\begin{verbatim}
curl "http://localhost:8080/o/headless-delivery/v1.0/blog-postings/59301"  -u 'test@example.com:test'
\end{verbatim}

\begin{verbatim}
{
  "alternativeHeadline": "The power of OpenAPI & Liferay",
  "articleBody": "<p>We are happy to announce...</p>",
  "creator": {
    "familyName": "Test",
    "givenName": "Test",
    "id": 20130,
    "name": "Test Test",
    "profileURL": "/web/test"
  },
  "dateCreated": "2019-04-22T07:04:47Z",
  "dateModified": "2019-04-22T07:04:51Z",
  "datePublished": "2019-04-22T07:02:00Z",
  "encodingFormat": "text/html",
  "friendlyUrlPath": "new-headless-apis",
  "headline": "New Headless APIs",
  "id": 59301,
  "numberOfComments": 0,
  "siteId": 20124
}
\end{verbatim}

To get only the headline, creation date, and creator, append the
\texttt{fields} parameter to the URL with the fields \texttt{headline},
\texttt{dateCreated}, and \texttt{creator}:

\begin{verbatim}
curl "http://localhost:8080/o/headless-delivery/v1.0/blog-postings/59301?fields=headline,dateCreated,creator"  -u 'test@example.com:test'
\end{verbatim}

\begin{verbatim}
{
  "creator": {
    "familyName": "Test",
    "givenName": "Test",
    "id": 20130,
    "name": "Test Test",
    "profileURL": "/web/test"
  },
  "dateCreated": "2019-04-22T07:04:47Z",
  "headline": "New Headless APIs"
}
\end{verbatim}

In the response, the \texttt{creator} attribute is a nested JSON object.
To return only the creator's name, specify that nested field via dot
notation (\texttt{creator.name}):

\begin{verbatim}
curl "http://localhost:8080/o/headless-delivery/v1.0/blog-postings/59301?fields=headline,dateCreated,creator.name"  -u 'test@example.com:test'
\end{verbatim}

\begin{verbatim}
{
  "creator": {
    "name": "Test Test"
  },
  "dateCreated": "2019-04-22T07:04:47Z",
  "headline": "New Headless APIs"
}
\end{verbatim}

The \texttt{fields} parameter also works with collection resources to
return the specified attributes for every collection item. For example,
this request gets the headlines for all the blog postings in the Site
with the ID \texttt{20124}:

\begin{verbatim}
curl "http://localhost:8080/o/headless-delivery/v1.0/sites/20124/blog-postings/?fields=headline"  -u 'test@example.com:test'
\end{verbatim}

\begin{verbatim}
{
  "items": [
    {
      "headline": "New Headless APIs"
    },
    {
      "headline": "Authenticated requests"
    }
  ],
  "lastPage": 1,
  "page": 1,
  "pageSize": 20,
  "totalCount": 2
}
\end{verbatim}

\subsection{Related Topics}\label{related-topics-85}

\href{/docs/7-1/tutorials/-/knowledge_base/t/making-authenticated-requests}{Making
Authenticated Requests}

\href{/docs/7-1/tutorials/-/knowledge_base/t/api-formats-and-content-negotiation}{API
Formats and Content Negotiation}

\href{/docs/7-1/tutorials/-/knowledge_base/t/working-with-collections-of-data}{Working
with Collections of Data}

\section{Multipart Requests}\label{multipart-requests}

Several operations accept a binary file via a multipart request. For
example, the definition for posting a file to a \texttt{DocumentFolder}
specifies a multipart request:

\begin{verbatim}
post:
    operationId: postDocumentFolderDocument
    parameters:
        - in: path
          name: documentFolderId
          required: true
          schema:
              format: int64
              type: integer
    requestBody:
        content:
            multipart/form-data:
                schema:
                    properties:
                        document:
                            $ref: "#/components/schemas/Document"
                        file:
                            format: binary
                            type: string
                    type: object
    responses:
        200:
            content:
                application/json:
                    schema:
                        $ref: "#/components/schemas/Document"
                application/xml:
                    schema:
                        $ref: "#/components/schemas/Document"
            description: ""
    tags: ["Document"]
\end{verbatim}

This operation returns a \texttt{Document} (in JSON or XML). To create
this \texttt{Document}, you must supply the operation's multipart
request with 2 components:

\begin{itemize}
\tightlist
\item
  A binary file (bytes) via the \texttt{file} property
\item
  A JSON string with the binary file's metadata, via the
  \texttt{document} property
\end{itemize}

To send this request, the \texttt{Content-Type} must be
\texttt{multipart/form-data}, and you must also specify a boundary name
(the boundary name can be arbitrary).

Here's an example request (without the file's bytes) that creates a
document in the folder with the ID \texttt{38549}:

\begin{verbatim}
curl -X "POST" "http://localhost:8080/o/headless-delivery/v1.0/document-folders/38549/documents" \
     -H 'Accept: application/json' \
     -H 'Content-Type: multipart/form-data; boundary=PART' \
     -u 'test@example.com:test' \
     -F "file=" \
     -F "document={\"title\": \"podcast\"}"
\end{verbatim}

And here's the response:

\begin{verbatim}
{
  "contentUrl": "/documents/20123/38549/podcast.mp3/e978e316-620c-df9f-e0bd-7cc0447cca49?version=1.0&t=1556100111417",
  "creator": {
    "familyName": "Test",
    "givenName": "Test",
    "id": 20129,
    "name": "Test Test",
    "profileURL": "/web/test"
  },
  "dateCreated": "2019-04-24T10:01:51Z",
  "dateModified": "2019-04-24T10:01:51Z",
  "documentFolderId": 38549,
  "encodingFormat": "audio/mpeg",
  "fileExtension": "mp3",
  "id": 38553,
  "numberOfComments": 0,
  "sizeInBytes": 28482097,
  "title": "podcast"
}
\end{verbatim}

\subsection{Related Topics}\label{related-topics-86}

\href{/docs/7-1/tutorials/-/knowledge_base/t/making-authenticated-requests}{Making
Authenticated Requests}

\href{/docs/7-1/tutorials/-/knowledge_base/t/api-formats-and-content-negotiation}{API
Formats and Content Negotiation}

\href{/docs/7-1/tutorials/-/knowledge_base/t/working-with-collections-of-data}{Working
with Collections of Data}

\chapter{Service Builder Web
Services}\label{service-builder-web-services}

Service Builder can generate local and remote services for your Liferay
apps.
\href{/docs/7-1/tutorials/-/knowledge_base/t/what-is-service-builder}{The
section of tutorials on Service Builder} gives a general introduction to
Service Builder, as well as instructions on generating your app's local
services. But Service Builder can also generate remote web services
automatically. Here, you'll learn how to both generate and invoke remote
JSON and SOAP web services. Because Liferay's web services are created
this way, knowing how to invoke these services opens many development
possibilities. This section includes the following tutorials:

\begin{itemize}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/creating-remote-services}{Creating
  Remote Services}: Use Service Builder to generate your app's JSON and
  SOAP web services.
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/invoking-remote-services}{Invoking
  Remote Services}: Learn the basics of invoking JSON and SOAP web
  services in Liferay.
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/service-security-layers}{Service
  Security Layers}: Learn how Liferay secures web services, and how to
  invoke them with proper authentication.
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/registering-json-web-services}{Registering
  JSON Web Services}: Learn some of the details behind how Service
  Builder generates JSON web services, and how you can tailor this
  process to your needs.
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/invoking-json-web-services}{Invoking
  JSON Web Services}: Learn how to invoke Liferay's JSON web services
  API via URL. This includes information on passing URL parameters,
  troubleshooting, and more.
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/json-web-services-invoker}{JSON
  Web Services Invoker}: Learn how to use Liferay's JSON Web Services
  Invoker to optimize your JSON web service calls.
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/configuring-json-web-services}{Configuring
  JSON Web Services}: Learn which properties you can use to control how
  JSON web services behave in your Liferay instance.
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/soap-web-services}{SOAP
  Web Services}: Learn how SOAP web services work in Liferay.
\end{itemize}

\section{Creating Remote Services}\label{creating-remote-services}

Many default Liferay DXP services are published as JSON and SOAP web
services. If you run the portal locally on port 8080, visit this URL to
browse the default JSON web services:

\begin{verbatim}
http://localhost:8080/api/jsonws/
\end{verbatim}

Visit this URL to browse the default SOAP web services:

\begin{verbatim}
http://localhost:8080/api/axis
\end{verbatim}

These web services APIs can be accessed by many different kinds of
clients, including non-portlet and even non-Java clients. You can use
Service Builder to generate similar remote services for your projects'
entities. When you run Service Builder with the \texttt{remote-service}
attribute set to \texttt{true} for an entity, all the classes,
interfaces, and files required to support both SOAP and JSON web
services are generated for that entity. Service Builder generates
methods that call existing services, but it's up to you to implement the
methods that are exposed remotely. In this tutorial, you'll learn how to
generate remote services for your application. When you're done, your
application's remote service methods can be called remotely via JSON and
SOAP web services.

\subsection{Using Service Builder to Generate Remote
Services}\label{using-service-builder-to-generate-remote-services}

Remember that you should implement your application's local service
methods in \texttt{*LocalServiceImpl}. You should implement your
application's remote service methods in \texttt{*ServiceImpl}.

\noindent\hrulefill

\textbf{Best Practice:} If your application needs both local and remote
services, determine the service methods that your application needs for
working with your entity model. Add these service methods to
\texttt{*LocalServiceImpl}. Then create corresponding remote services
methods in \texttt{*ServiceImpl}. Add permission checks to the remote
service methods and make the remote service methods invoke the local
service methods. The remote service methods can have the same names as
the local service methods they call. Within your application, only call
the remote services. This ensures that your service methods are secured
and that you don't have to duplicate permissions code.

\noindent\hrulefill

For example, consider Web Content articles. Web Content articles are
represented by the \texttt{JournalArticle} entity. This entity is
declared in the \texttt{journal-service} module's
\href{https://github.com/liferay/liferay-portal/blob/7.1.x/modules/apps/journal/journal-service/service.xml}{\texttt{service.xml}
file} with the \texttt{remote-service} attribute set to \texttt{true}.
Service Builder therefore generates
\href{https://github.com/liferay/liferay-portal/blob/7.1.x/modules/apps/journal/journal-service/src/main/java/com/liferay/journal/service/impl/JournalArticleServiceImpl.java}{the
remote service class \texttt{JournalArticleServiceImpl}} to hold the
remote service method implementations. If you were developing this app
from scratch, this class would initially be empty; you must use it to
implement the entity's remote service methods. Also, note that the
remote service method implementations in
\texttt{JournalArticleServiceImpl} follow the best practice of checking
permissions and calling the corresponding local service method. For
example, each \texttt{addArticle} method in
\texttt{JournalArticleServiceImpl} checks permissions and then calls the
local service's matching \texttt{addArticle} method:

\begin{verbatim}
@Override
public JournalArticle addArticle(...)
    throws PortalException {

    ModelResourcePermissionHelper.check(
        _journalFolderModelResourcePermission, getPermissionChecker(),
        groupId, folderId, ActionKeys.ADD_ARTICLE);

    return journalArticleLocalService.addArticle(...);
}
\end{verbatim}

Note the use of \texttt{ModelResourcePermissionHelper.check(...)}. This
handy helper class was introduced in Liferay 7.1. For model resource
permission checks, you can use this helper class instead of using a
custom permissions helper class. Also note that the local service is
called via the \texttt{journalArticleLocalService} field. This is a
Spring bean of type \texttt{JournalArticleLocalServiceImpl} that's
injected into \texttt{JournalArticleServiceImpl} by Service Builder.
Your Service Builder-generated classes do the same thing.

After you've finished adding remote service methods to your
\texttt{*ServiceImpl} class, save it and run Service Builder again.
After running Service Builder, deploy your project and check the JSON
web services URL \url{http://localhost:8080/api/jsonws/} to make sure
that your remote services appear when you select your application's
context path.

Nice work! You've successfully used Service Builder to generate your
app's remote services. To make these services available via SOAP,
however, you must build and deploy your app's Web Service Deployment
Descriptor (WSDD). The next section shows you how to do this. If you
don't need to generate SOAP web services, you can move on to the
tutorial
\href{/docs/7-1/tutorials/-/knowledge_base/t/invoking-remote-services}{Invoking
Remote Services}.

\subsection{Generating Your App's WSDD}\label{generating-your-apps-wsdd}

Liferay DXP uses Apache Axis to make SOAP web services available. Since
Axis requires a WSDD to make an app's remote services available via
SOAP, you must build and deploy a WSDD for your app. To create your
WSDD, you must install Liferay's WSDD Builder Gradle plugin in your
app's project. How you do this, however, depends on what kind of project
you have. For multi-module projects like a Service Builder project in a
Liferay Workspace, you'll install the plugin via the workspace's
\texttt{settings.gradle} file. This applies the WSDD Builder plugin to
every module in the workspace that uses Service Builder (typically the
\texttt{*-api} and \texttt{*-service} modules). If you have a standalone
\texttt{*-service} module that uses Service Builder, however, you'll
install the WSDD Builder plugin in the module's \texttt{build.gradle}
file.

The next section shows you how to install the WSDD builder in a
multi-module project. If you have a standalone module project, skip
ahead to the section \emph{Installing the WSDD Builder Plugin in a
Standalone Module Project}.

\subsubsection{Installing the WSDD Builder Plugin in a Multi-module
Project}\label{installing-the-wsdd-builder-plugin-in-a-multi-module-project}

To install the WSDD Builder plugin in a multi-module project like a
Service Builder project in a Liferay Workspace, modify the workspace's
\texttt{settings.gradle} file:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add the \texttt{ServiceBuilderPlugin} and \texttt{WSDDBuilderPlugin}
  imports to the top of the file:

\begin{verbatim}
import com.liferay.gradle.plugins.service.builder.ServiceBuilderPlugin
import com.liferay.gradle.plugins.wsdd.builder.WSDDBuilderPlugin
\end{verbatim}
\item
  In the \texttt{repositories} block, add the Liferay CDN repository via
  Maven:

\begin{verbatim}
repositories {
    maven {
        url "https://repository-cdn.liferay.com/nexus/content/groups/public"
    }
}
\end{verbatim}

  This repository hosts the WSDD Builder library, its transitive
  dependencies, and other Liferay libraries. Note that if you created
  your Service Builder project with the \texttt{service-builder}
  template in Blade CLI or Liferay Dev Studio DXP, your
  \texttt{settings.gradle} file should already contain this.
\item
  Add this code to the end of the file:

\begin{verbatim}
gradle.beforeProject {
    project ->

    project.plugins.withType(ServiceBuilderPlugin) {
        project.apply plugin: WSDDBuilderPlugin
    }
}
\end{verbatim}

  This is the code that applies the WSDD Builder plugin in every module
  in the Liferay Workspace that uses Service Builder. Your
  \texttt{settings.gradle} file should now look like this:

\begin{verbatim}
import com.liferay.gradle.plugins.service.builder.ServiceBuilderPlugin
import com.liferay.gradle.plugins.wsdd.builder.WSDDBuilderPlugin

buildscript {
    dependencies {
        classpath group: "com.liferay", name: "com.liferay.gradle.plugins.workspace", version: "1.2.0"
    }

    repositories {
        maven {
            url "https://repository-cdn.liferay.com/nexus/content/groups/public"
        }
    }
}

apply plugin: "com.liferay.workspace"

gradle.beforeProject {
    project ->

    project.plugins.withType(ServiceBuilderPlugin) {
        project.apply plugin: WSDDBuilderPlugin
    }
}
\end{verbatim}
\item
  Refresh the Liferay Workspace's Gradle project. Close and restart
  Liferay Dev Studio DXP if you're using it.
\end{enumerate}

Now that you've installed the WSDD Builder plugin, you're ready to build
and deploy the WSDD. For instructions on this, proceed to the section
\emph{Building and Deploying the WSDD}.

\subsubsection{Installing the WSDD Builder Plugin in a Standalone Module
Project}\label{installing-the-wsdd-builder-plugin-in-a-standalone-module-project}

To install the WSDD Builder plugin in a standalone \texttt{*-service}
module that uses Service Builder, modify the module's
\texttt{build.gradle} file:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add the plugin as a dependency in your \texttt{buildscript}.
\item
  Add the Liferay CDN repository via Maven.
\item
  Apply the plugin to your project.
\end{enumerate}

For example, the following part of an example \texttt{build.gradle} file
in a standalone \texttt{*-service} module includes the WSDD Builder
plugin and applies it to the project:

\begin{verbatim}
buildscript {
    dependencies {
        classpath group: "com.liferay", name: "com.liferay.gradle.plugins.wsdd.builder", version: "1.0.9"
    }

    repositories {
        maven {
            url "https://repository-cdn.liferay.com/nexus/content/groups/public"
        }
    }
}

apply plugin: "com.liferay.portal.tools.wsdd.builder"
\end{verbatim}

Now you're ready to build and deploy the WSDD. The next section shows
you how to do this.

\subsection{Building and Deploying the
WSDD}\label{building-and-deploying-the-wsdd}

To build the WSDD, you must run the \texttt{buildWSDD} Gradle task in
your \texttt{*-service} module. Exactly how you do this depends on your
development tools:

\begin{itemize}
\tightlist
\item
  \textbf{Liferay Dev Studio DXP:} From the Liferay Workspace
  perspective's \emph{Gradle Tasks} pane (typically on the right), open
  your \texttt{*-service} module's \emph{build} folder and double-click
  \emph{buildWSDD}.
\item
  \textbf{Command Line:} Navigate to your \texttt{*-service} module and
  run \texttt{../../../gradlew\ buildWSDD}. Note that the exact location
  of the Gradle wrapper (\texttt{gradlew}) may vary. For Liferay
  Workspace projects, it's typically in the root workspace folder.
\end{itemize}

So what should you do if \texttt{buildWSDD} fails? A common cause of
\texttt{buildWSDD} failures is not satisfying the dependencies needed by
the WSDD Builder for your \texttt{*-service} module. Note that these
dependencies vary depending on your project's code---there's no standard
set. That said, the following dependencies are often required for
portlet development:

\begin{verbatim}
compileOnly group: "javax.portlet", name: "portlet-api", version: "3.0.0"
compileOnly group: "javax.servlet", name: "javax.servlet-api", version: "3.0.1"
compileOnly group: "com.liferay", name: "com.liferay.registry.api", version: "2.0.0"
\end{verbatim}

\href{/docs/7-1/tutorials/-/knowledge_base/t/configuring-dependencies}{Click
here} for more information on finding and configuring dependencies for
your apps.

In your \texttt{*-service} project's \texttt{build/libs} folder, the
\texttt{buildWSDD} task generated a
\texttt{*-service-wsdd-{[}version{]}.jar} file that contains your WSDD.
Deploy this JAR to your Liferay DXP instance. Your SOAP web services are
then available at a URL that uses the following pattern:

\begin{verbatim}
yourportaladdress/o/your.apps.service.module.context/api/axis
\end{verbatim}

For example, if an app called \emph{Foo} consists of the modules
\texttt{foo-api}, \texttt{foo-service}, and \texttt{foo-web}, then the
app's service module context is \texttt{foo-service}. If this app is
deployed to a local Liferay DXP instance running at
\texttt{http://localhost:8080}, you could access its SOAP services at:

\begin{verbatim}
http://localhost:8080/o/foo-service/api/axis
\end{verbatim}

If you don't know an app's \texttt{*-service} module context, you can
find it by searching for the app in the App Manager where the app is
running. For example, the following screenshot shows the Foo app's
modules in the App Manager. The name of the \texttt{*-service} module in
the App Manager, \texttt{foo-service}, is also its context. Also note
that the app's WSDD module is grayed out and listed as Resolved instead
of Active. This is normal. WSDD modules are OSGi fragments, which can't
be activated. They still work as intended, though.

Next, you'll learn how to build the WSDD module for built-in apps that
don't include a WSDD by default. If you don't need to do this, you can
move on to the tutorial
\href{/docs/7-1/tutorials/-/knowledge_base/t/invoking-remote-services}{Invoking
Remote Services}.

\subsection{Building the WSDD for Built-in
Apps}\label{building-the-wsdd-for-built-in-apps}

Liferay DXP doesn't provide WSDD modules for built-in apps that exist
outside of the portal context. This means that by default you can't
access SOAP web services for apps like Wiki or Blogs. To make SOAP web
services available for such an app, you must build and deploy its WSDD
from the
\href{https://github.com/liferay/liferay-portal}{\texttt{liferay-portal}
GitHub repository}. The apps are in the
\texttt{liferay-portal/modules/apps} folder. Note that to build WSDDs
for these apps, you must first download the \texttt{liferay-portal}
source code to your machine. You'll run the WSDD build from your local
\texttt{liferay-portal} copy.

When you build an app's WSDD, make sure to use \texttt{gradlew} in
\texttt{liferay-portal} instead of the \texttt{gradle} on your machine.
After building, you can find the WSDD JAR in the \texttt{tools/sdk/dist}
folder of your local \texttt{liferay-portal} copy. Otherwise, building
an app's WSDD is the same as in the preceding section.

For example, to build the WSDD for the Bookmarks app, first navigate to
the \texttt{liferay-portal/modules/apps/bookmarks/bookmarks-service}
folder in your terminal. Then run the following command:

\begin{verbatim}
../../../../../gradlew buildWSDD
\end{verbatim}

Next, deploy the
\texttt{liferay-portal/tools/sdk/dist/com.liferay.bookmarks.service-wsdd-{[}version{]}.jar}.
If your instance is running locally on \texttt{localhost:8080}, you
should then be able to view the Bookmarks app's SOAP services at
\url{http://localhost:8080/o/com.liferay.bookmarks.service/api/axis}.

Fantastic! Once you've created remote web services, you'll want to know
how to invoke them. To learn how, see the tutorial
\href{/docs/7-1/tutorials/-/knowledge_base/t/invoking-remote-services}{Invoking
Remote Services}.

\subsection{Related Topics}\label{related-topics-87}

\href{/docs/7-1/tutorials/-/knowledge_base/t/invoking-remote-services}{Invoking
Remote Services}

\href{/docs/7-1/tutorials/-/knowledge_base/t/invoking-json-web-services}{Invoking
JSON Web Services}

\href{/docs/7-1/tutorials/-/knowledge_base/t/json-web-services-invoker}{JSON
Web Services Invoker}

\href{/docs/7-1/tutorials/-/knowledge_base/t/what-is-service-builder}{What
is Service Builder?}

\section{Invoking Remote Services}\label{invoking-remote-services}

You can invoke the remote services of any installed Liferay application
the same way you invoke your local services. Doing so could be described
as ``invoking remote services locally.'' One reason to invoke a remote
service instead of the corresponding local service is to take advantage
of the remote service's permission checks. Consider the following common
scenario:

\begin{itemize}
\tightlist
\item
  Both a local service implementation and a remote service
  implementation have been created for a particular service.
\item
  The remote service performs a permission check and then invokes the
  corresponding local service.
\end{itemize}

In the above scenario, it's a best practice to invoke the remote service
instead of the local service. Doing so ensures that you don't need to
duplicate permission checking code. This is the practice followed by the
services in
\href{https://github.com/liferay/liferay-portal/blob/7.1.x/modules/apps/journal/journal-service/src/main/java/com/liferay/journal/service/impl/JournalArticleServiceImpl.java}{Liferay's
Web Content app}. Notice that the \texttt{addArticle} methods invoke
\texttt{journalArticleLocalService.addArticle} after a permission check.

Of course, the main reason for creating remote services is to invoke
them remotely. Service Builder can expose your project's remote web
services both via a JSON API and via SOAP. By default, running Service
Builder with \texttt{remote-service} set to \texttt{true} for your
entities generates a JSON web services API for your project. You can
access your project's JSON-based RESTful services through a convenient
web interface.

\subsection{Invoking Liferay Services
Remotely}\label{invoking-liferay-services-remotely}

Many default Liferay services are available as web services. Liferay
exposes its web services via SOAP and JSON web services. If you're
running Liferay locally on port 8080, visit the following URL to browse
Liferay's default SOAP web services:

\begin{verbatim}
http://localhost:8080/api/axis
\end{verbatim}

To browse Liferay's default JSON web services, visit this URL:

\begin{verbatim}
http://localhost:8080/api/jsonws/
\end{verbatim}

By default, the context path is set to \texttt{/} which means that core
Liferay services are listed. By default, the
\emph{http://localhost:8080/api/jsonws/} page shows the JSON web
services in the \texttt{portal} context. You can select a different
context in the \emph{Context Name} selector menu. For example, selecting
\texttt{journal} in \emph{Context Name} shows you the JSON web services
in Liferay's Web Content app (this app's entities all begin with
\texttt{Journal*}). You can also access a context's JSON web services
via a direct URL. For example, the URL for the Web Content app's JSON
web services is
\url{http://localhost:8080/api/jsonws?contextName=journal}.

\noindent\hrulefill

\textbf{Important:} To invoke Liferay services remotely, your Liferay
instance must be configured to allow remote web service access. Please
see the
\href{/docs/7-1/tutorials/-/knowledge_base/t/service-security-layers}{Understanding
Liferay's Service Security Model} tutorial for details.

\noindent\hrulefill

Each entity's available service methods appear in the left column of the
JSON web services page. To view details about a service method, click
it. The full package path to the service's \texttt{*Impl} class appears
along with the method's parameters, return type, and possible
exceptions. You can also invoke the service from this page. For example,
in the \texttt{portal} context click the \texttt{AnnouncementsEntry}
entity's \texttt{get-entry} method. This brings up that service method's
details page, where you can also invoke the service.

\begin{figure}
\centering
\includegraphics{./images/jsonws-details.png}
\caption{The JSON web services page for an entity's remote service
method also lets you invoke that service.}
\end{figure}

The only parameter required to invoke the \texttt{get-entry} method is
an \texttt{entryId}. To invoke this web service, you could enter an
announcement entry's ID in the \texttt{entryId} field and then click
\emph{Invoke}. Liferay returns feedback from each invocation that
indicates, for example, whether the service invocation succeeded or
failed. Invoking remote services in this manner is a great way to test
your app's remote services.

Service Builder can also make your project's web services available via
SOAP using Apache Axis. After you've built your \texttt{*-service}
project's WSDD (web service deployment descriptor) and deployed your
project's modules, its services are available on your Liferay server.
You can use your browser to view the SOAP services of Liferay and
Liferay apps as described in the tutorial
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-remote-services}{Creating
Remote Services}.

When viewing your SOAP services in a browser, Liferay lists the services
available for all your entities and provides links to their WSDL
documents. For example, clicking on the WSDL link for the User service
takes you to the following URL:

\begin{verbatim}
http://localhost:8080/api/axis/Portal_UserService?wsdl
\end{verbatim}

This WSDL document lists the entity's SOAP web services. Once the web
service's WSDL is available, any SOAP web service client can access it.
To see examples of SOAP web service client implementations, see the
tutorial
\href{/docs/7-1/tutorials/-/knowledge_base/t/soap-web-services}{SOAP Web
Services}.

Liferay web services are designed to be invoked by client applications.
Liferay's web services APIs can be accessed by many different kinds of
clients, including non-portlet and even non-Java clients. For
information on how to develop client applications that can access
Liferay's JSON web services, please see the
\href{/docs/7-1/tutorials/-/knowledge_base/t/invoking-json-web-services}{Invoking
JSON Web Services} tutorial. For information on how to develop client
applications that access Liferay's SOAP web services, please see the
\href{/docs/7-1/tutorials/-/knowledge_base/t/soap-web-services}{SOAP Web
Services} tutorial. To learn how to create remote web services for your
own application, please refer to the
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-remote-services}{Creating
Remote Services} tutorial.

For more information on Liferay services, see the Liferay Portal CE
Javadocs at
{[}https://docs.liferay.com/dxp/portal/7.0-latest/javadocs/{]}( \#\#\#
Related Topics

\href{/docs/7-1/tutorials/-/knowledge_base/t/invoking-json-web-services}{Invoking
JSON Web Services}

\href{/docs/7-1/tutorials/-/knowledge_base/t/json-web-services-invoker}{JSON
Web Services Invoker}

\href{/docs/7-1/tutorials/-/knowledge_base/t/soap-web-services}{SOAP Web
Services}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-remote-services}{Creating
Remote Services}

\section{Service Security Layers}\label{service-security-layers}

Liferay's remote services are secured by default, because they only
allow local connections. Enabling remote access requires peeling away
several layers of security, first by IP address, then by user
authentication and verification. Users invoking web services must have
the proper permissions (as defined by Liferay's permissions system) for
the remote service invocation to complete successfully. This tutorial
explains these processes.

The first layer of security is called \emph{invoker IP filtering}.
Imagine that you have have a batch job that runs on another machine in
your network. This job polls a shared folder on your network and uses
Liferay's web services to upload documents to your Liferay Site's
\emph{Documents and Media} app on a regular basis. To get your batch job
through the IP filter, you must grant web service access to the machine
where the batch job runs. For example, if your batch job uses Liferay's
SOAP web services to upload the documents, you must add the IP address
of the machine where the batch job runs to the
\texttt{axis.servlet.hosts.allowed} property. A typical entry might look
like this:

\begin{verbatim}
axis.servlet.hosts.allowed=192.168.100.100, 127.0.0.1, [SERVER_IP]
\end{verbatim}

If the IP address of the machine where the batch job runs is listed as
an authorized host for the service, the machine can connect to Liferay's
web services, pass in the appropriate user credentials, and upload the
documents.

\noindent\hrulefill

\textbf{Note:} The \texttt{portal-ext.properties} file resides on the
Liferay server and is controlled by its administrator. Administrators
can configure security settings for the Axis Servlet, the Liferay Tunnel
Servlet, the Spring Remoting Servlet, the JSON Servlet, the JSON Web
Service Servlet, and the WebDAV Servlet. The
\href{https://docs.liferay.com/dxp/portal/7.1-latest/propertiesdoc/portal.properties.html}{\texttt{portal.properties}
file} describes these properties.

\noindent\hrulefill

Next, if you invoke the remote service via web services, a two step
process of authentication and authentication verification takes place.
Each call to a Liferay web service must be accompanied by a user
authentication token: \texttt{p\_auth}. It's up to the web service
caller to produce the token (e.g., through Liferay's utilities or
through some third-party software). Liferay verifies that there is a
Liferay user matching the token. If the credentials are invalid, the web
service invocation is aborted. Otherwise, processing enters Liferay's
user permission layer.

The user permission layer is the last security layer triggered for
remote services. It's used for every object, regardless of whether a
local or remote service is involved. The user ID associated with a web
service invocation must have permission to operate on the objects it's
trying to access. A remote exception is thrown if the user ID doesn't
have permission. An instance administrator can grant users access to
these resources.

For example, suppose you created a Documents and Media Library folder
called \emph{Documents} in a Site, created a Role called \emph{Document
Uploaders}, and granted this Role the rights to add documents to your
new folder. If your batch job accesses Liferay's web services to upload
documents into the folder, you must call the web service using a user ID
with this Role (or using the user ID of a user with individual rights to
add documents to this folder, such as an instance administrator). If you
don't, Liferay denies you access to the web service.

When invoking remote services from a non-browser client, you can specify
the user credentials using HTTP basic authentication. For security
reasons, you must be logged in and supply a valid \texttt{p\_auth}
authentication token to invoke a web service via a browser. Since you
should never pass credentials over the network unencrypted, use HTTPS
whenever accessing Liferay services. Most HTTP clients (like
\href{http://curl.haxx.se/}{cURL}) let you specify the basic
authentication credentials in the URL: this is very handy for testing.

\noindent\hrulefill

\textbf{Important:} To invoke a Liferay web service via your browser,
you must be logged in to Liferay. You must also supply an authentication
token (the \texttt{p\_auth} parameter). If you navigate to your Liferay
instance's JSON web services API page ( \url{localhost:8080/api/jsonws},
by default) and click on a remote service method, you'll see the
\texttt{p\_auth} token for your browser session. This token is supplied
automatically when you invoke a Liferay web service via the JSON web
services API page or via JavaScript using \texttt{Liferay.Service(...)}.

\noindent\hrulefill

Use the following syntax to call the Axis web service using credentials.

\begin{verbatim}
http://" + emailAddressOrScreenNameOrUserIdAsString + ":" + password + "@[server.com]:\
[port]/api/axis/" + serviceName
\end{verbatim}

The \texttt{emailAddressOrScreenNameOrUserIdAsString} should be the
user's email address, screen name, or user ID. The Liferay instance's
authentication type setting determines which one to use. Authentication
by email address is the default. A user can find his or her user ID by
logging in as the user and accessing \emph{My Account} → \emph{Account
Settings} from the User Menu. On this interface, the user ID appears
below the user's profile picture and above the birthday field.

Suppose that you've defined authentication by user ID, and that there's
a user with an ID of \texttt{2} and a password of \texttt{test}. You can
access Liferay's remote Organization service with the following URL:

\begin{verbatim}
http://2:test@localhost:8080/api/axis/Portal_OrganizationService
\end{verbatim}

Note that if an email address appears in the URL path, it must be
URL-encoded (e.g.~\texttt{test@example.com} becomes
\texttt{test\%40liferay.com}).

Suppose that you've now defined authentication by email address. To call
the same web service for the same user, change the URL to this:

\begin{verbatim}
http://test%40liferay.com:test@localhost:8080/api/axis/Portal_OrganizationService
\end{verbatim}

As mentioned, the authentication type you've defined dictates the
authentication type you'll use to access your web service. The
authentication type can be set to email address, screen name, or user
ID.

You can set the authentication type via the Control Panel or via the
\texttt{portal-ext.properties} file. To set the authentication type via
the Control Panel, navigate to \emph{Control Panel} →
\emph{Configuration} → \emph{Instance Settings}, and select the
\emph{General} tab under \emph{Authentication}. Choose your
authentication type in the \emph{How do users authenticate?} menu. To
set the authentication type via properties file, add the following lines
to your Liferay instance's \texttt{portal-ext.properties} file and
uncomment the line for the appropriate authentication type:

\begin{verbatim}
#company.security.auth.type=emailAddress
#company.security.auth.type=screenName
#company.security.auth.type=userId
\end{verbatim}

You should also review your password policies, since they're enforced on
your administrative user. If a password policy requires them to change
their passwords on a periodic basis, the password for an administrative
user accessing web services in a batch job expires too.

To prevent a password from expiring, add a new password policy that
doesn't enforce password expiration, and then add your administrative
user to the policy. Then your batch job can run as many times as you
need it to, without the password expiring.

To summarize, accessing Liferay remotely requires you to pass the
following layers of security checks:

\begin{itemize}
\tightlist
\item
  \emph{IP permission layer}: The IP address must be pre-configured in
  the server's portal properties.
\item
  \emph{Authentication/verification layer (web services only)}: Liferay
  verifies that the caller's authorization token can be associated with
  an instance user.
\item
  \emph{User permission layer}: The user needs permission to access the
  related resources.
\end{itemize}

If you want to develop client applications that can invoke Liferay's web
services, make sure that your Liferay instance's web service security
settings have been configured to allow access.

\textbf{Related Topics}

\href{/docs/7-1/tutorials/-/knowledge_base/t/configuring-json-web-services}{Configuring
JSON Web Services}

\href{/docs/7-1/tutorials/-/knowledge_base/t/invoking-remote-services}{Invoking
Remote Services}

\href{/docs/7-1/tutorials/-/knowledge_base/t/invoking-json-web-services}{Invoking
JSON Web Services}

\href{/docs/7-1/tutorials/-/knowledge_base/t/json-web-services-invoker}{JSON
Web Services Invoker}

\href{/docs/7-1/tutorials/-/knowledge_base/t/soap-web-services}{SOAP Web
Services}

\section{Registering JSON Web
Services}\label{registering-json-web-services}

Liferay's developers use a tool called \emph{Service Builder} to build
services. When you build services with Service Builder, all
remote-enabled services (i.e., \texttt{service.xml} entities with the
property \texttt{remote-service="true"}) are exposed as JSON web
services. When each \texttt{*Service.java} interface is created for a
remote-enabled service, the \texttt{@JSONWebService} annotation is added
to that interface at the class level. All the public methods of that
interface become registered and available as JSON web services.

Liferay scans all OSGi bundles registered with the \texttt{@Component}
annotation or in a \texttt{*BundleActivator} class for remote services.
Each class that uses the \texttt{@JSONWebService} annotation is examined
and its methods become exposed via the JSON web services API.

\noindent\hrulefill

\textbf{Note:} Liferay's developers use \emph{Service Builder} to expose
their services via JSON automatically. If you haven't used Service
Builder before, please see the
\href{/docs/7-1/tutorials/-/knowledge_base/t/what-is-service-builder}{Service
Builder tutorials}.

\noindent\hrulefill

Next, you'll see how to register your application's remote services as
JSON web services. Keep in mind that Liferay uses this same mechanism.
This is why Liferay's remote services are exposed as JSON web services
out-of-the-box.

\subsection{Registering an App's JSON Web
Services}\label{registering-an-apps-json-web-services}

For example, say your app named \texttt{SupraSurf} has some services you
want exposed as remote services. After enabling the
\texttt{remote-service} attribute on its \texttt{SurfBoard} entity, you
rebuild the services. Service Builder regenerates the
\texttt{SurfBoardService} interface, adding the \texttt{@JSONWebService}
annotation to it. This annotation tells Liferay that the interface's
public methods are to be exposed as JSON web services, making them a
part of the app's JSON API. Start your Liferay instance, and then deploy
your app to Liferay.

To get some feedback from your Liferay instance on registering your
application's services, configure the instance to log the application's
informational messages (i.e., its \texttt{INFO\ ...} messages). See the
tutorials on Liferay's
\href{/docs/7-1/user/-/knowledge_base/u/server-administration}{logging
system} for details.

To test Liferay's JSON web service registration process, add a simple
method to your app's services. Edit your \texttt{*ServiceImpl} class and
add this method:

\begin{verbatim}
public String helloWorld(String worldName) {
    return "Hello world: " + worldName;
}
\end{verbatim}

Rebuild the services and re-deploy your app's modules. You can now
invoke this service method via JSON. For instructions on doing this, see
the JSON invocation tutorials listed
\href{/docs/7-1/tutorials/-/knowledge_base/t/service-builder-web-services}{here}.

This same mechanism registers Liferay's own services. They're enabled by
default, so you don't have to configure them.

Next, you'll learn how to form a mapped URL for the remote service so
you can predictably access it.

\subsection{Mapping and Naming
Conventions}\label{mapping-and-naming-conventions}

You can form the mapped URL of an exposed service by following the
naming convention below:

\begin{verbatim}
http://[server]:[port]/api/jsonws/[context-path].[service-class-name]/[service-method-name]
\end{verbatim}

Look at the last three bracketed items more closely:

\begin{itemize}
\item
  \texttt{context-name} is the app's context name (e.g.,
  \texttt{suprasurf}). Its value is specified via the
  \texttt{json.web.service.context.path} property in the
  \texttt{@OSGiBeanProperties} annotation. For example, for Liferay web
  content articles, Liferay's \texttt{JournalArticleService} class
  includes this annotation (among others):

\begin{verbatim}
  @OSGiBeanProperties(property =  {
      "json.web.service.context.name=journal", "json.web.service.context.path=JournalArticle"}, service = JournalArticleService.class)
\end{verbatim}
\item
  \texttt{service-class-name} is generated from the service's class name
  in lower case, minus its \texttt{Service} or \texttt{ServiceImpl}
  suffix. For example, specify \texttt{surfboard} as the
  \texttt{app-context-name} for the \texttt{SurfBoardService} class.
\item
  \texttt{service-method-name} is generated from the service's method
  name by converting its camel case to lower case and using dashes
  (\texttt{-}) to separate words.
\end{itemize}

The following example demonstrates these naming conventions by mapping a
service method's URL using the naming conventions both on a custom
service and on a Liferay service.

For the custom service method, the URL looks like

\begin{verbatim}
http://localhost:8080/api/jsonws/suprasurf.surfboard/hello-world
\end{verbatim}

Note the context name part of the URL. For Liferay, it's similar. Here's
a Liferay service method:

\begin{verbatim}
@JSONWebService
public interface UserService {
    public com.liferay.portal.model.User getUserById(long userId) {...}
\end{verbatim}

Here's that Liferay service method's URL:

\begin{verbatim}
http://localhost:8080/api/jsonws/user/get-user-by-id
\end{verbatim}

Each service method is bound to one HTTP method type. Any method with a
name starting with \texttt{get}, \texttt{is}, or \texttt{has} is a
read-only method and is mapped as a \emph{GET HTTP} method by default.
All other methods are mapped as \emph{POST HTTP} methods.

In the list of JSON web services at
\url{http://localhost:8080/api/jsonws}, when you select a method, the
part of its HTTP method URL that follows
\texttt{http://{[}server{]}:{[}port{]}/api/jsonws} appears at the top of
the screen.

Conveniently, remote service requests can use authentication credentials
associated with the user's current session.

Next, you'll learn how to prevent a method from being exposed as a
service.

\subsection{Ignoring a Method}\label{ignoring-a-method}

To keep a method from being exposed as a service, annotate the method
with the following option:

\begin{verbatim}
@JSONWebService(mode = JSONWebServiceMode.IGNORE)
\end{verbatim}

Methods with this annotation don't become part of the JSON Web Service
API. Next, you'll learn how to define custom HTTP method and URL names.

\subsection{HTTP Method and URL Names}\label{http-method-and-url-names}

At the method level, you can define custom HTTP method names and URL
names. Just use an annotation like this one:

\begin{verbatim}
@JSONWebService(value = "add-board-wow", method = "PUT")
public boolean addBoard(
\end{verbatim}

In this example, the application's service method \texttt{addBoard} is
mapped to URL method name \texttt{add-board-wow}. Its complete URL is
now
\texttt{http://localhost:8080/api/jsonws/suprasurf.surfboard/add-board-wow}
and can be accessed using the HTTP PUT method.

If the URL method name in a JSON web service annotation starts with a
slash character (\texttt{/}), only the method name is used to form the
service URL; the class name is ignored:

\begin{verbatim}
@JSONWebService("/add-something-very-specific")
public boolean addBoard(
\end{verbatim}

Similarly, you can change the class name part of the URL by setting the
value in a class-level annotation:

\begin{verbatim}
@JSONWebService("sbs")
public class SurfBoardServiceImpl extends SurfBoardServiceBaseImpl {
\end{verbatim}

This maps all the service's methods to a URL class name \texttt{sbs}
instead of the default class name \texttt{surfboard}.

Next, you'll learn a different approach to exposing your methods via
manual registration.

\subsection{Manual Registration Mode}\label{manual-registration-mode}

Up to now, it's assumed that you want to expose most of your service
methods, while hiding some specific methods (the \emph{blacklist}
approach). Sometimes, however, you want the opposite: to explicitly
specify only the methods you want to expose (the \emph{whitelist}
approach). This is possible by specifying a class-level annotation with
\emph{manual mode}. Then it's up to you to annotate only those methods
you want to expose:

\begin{verbatim}
@JSONWebService(mode = JSONWebServiceMode.MANUAL)
public class SurfBoardServiceImpl extends SurfBoardServiceBaseImpl{
    ...
    @JSONWebService
    public boolean addBoard(
\end{verbatim}

Now only the \texttt{addBoard} method and any other method annotated
with \texttt{@JSONWebService} are part of the JSON Web Service API; all
other methods are excluded from the API.

\subsection{Related Topics}\label{related-topics-88}

\href{/docs/7-1/tutorials/-/knowledge_base/t/invoking-json-web-services}{Invoking
JSON Web Services}

\href{/docs/7-1/tutorials/-/knowledge_base/t/json-web-services-invoker}{JSON
Web Services Invoker}

\section{Invoking JSON Web Services}\label{invoking-json-web-services}

If you know the URL and are connected to the Internet, you can invoke
Liferay's JSON web service API in any language you want or directly with
the URL or \href{http://curl.haxx.se/}{cURL}. Additionally, Liferay
provides a handy JSON web services page that allows you to browse and
invoke service methods.

If you're running Liferay locally on port 8080, you can find the JSON
web services page at \url{http://localhost:8080/api/jsonws}. You can use
this page to generate example code for invoking web services. When you
invoke a service on this page as described in the tutorial
\href{/docs/7-1/tutorials/-/knowledge_base/t/invoking-remote-services}{Invoking
Remote Services}, the JSON result of your service invocation appears.
Click on the \emph{JavaScript Example}, \emph{curl Example}, or
\emph{URL Example} tabs to see different ways of invoking the web
service.

\begin{figure}
\centering
\includegraphics{./images/jsonws-javascript.png}
\caption{When you invoke a service from Liferay's JSON web services
page, you can view the result of your service invocation as well as
example code for invoking the service via JavaScript, curl, or URL.}
\end{figure}

This tutorial explains techniques for working with JSON web services and
includes details about invoking them via URL.

There are multiple ways to invoke a JSON web service since there are
different ways to supply parameters. In this tutorial, you'll learn how
to include parameters in web service invocations. First, you must
understand how your invocation is matched to a method, especially in the
case of overloaded service methods.

The general rule is that you provide the service method's name and
\emph{all} the service method's parameters---even if you only provide
\texttt{null} values. It's important to provide all parameters, but it
doesn't matter \emph{how} you do it (e.g., as part of the URL line, as
request parameters, etc.). The order of the parameters doesn't matter
either.

\noindent\hrulefill

\textbf{Note:} An authentication related token (\texttt{p\_auth}) must
accompany each Liferay web service invocation. For details, see the
\href{/docs/7-1/tutorials/-/knowledge_base/t/service-security-layers}{Service
Security Layers} tutorial. Also, see the note in the following section
to learn how to find the \texttt{p\_auth} token value that corresponds
to your Liferay session.

\noindent\hrulefill

Exceptions abound in life, and there's an exception to the rule that
\emph{all} parameters are required. When using numeric \emph{hints} to
match methods, not all of the parameters are required. You'll learn to
use hints next.

\subsection{Using Hints When Invoking a Service via
URL}\label{using-hints-when-invoking-a-service-via-url}

Numeric hints specify how many method arguments a service has.
Syntactically, you can add hints as numbers separated by a dot in the
method name. Here's an example:

\begin{verbatim}
/foo/get-bar.2/param1/123/-param2
\end{verbatim}

Here, the \texttt{.2} is a numeric hint specifying that only service
methods with two arguments are matched; others are ignored for matching.

There's an important distinction to make between matching with hints and
matching without hints. When a hint is specified, you don't have to
specify all of the parameters. Any missing arguments are treated as
\texttt{null}. The previous example may be called like this:

\begin{verbatim}
/foo/get-bar.2/param1/123
\end{verbatim}

In this example, \texttt{param2} is automatically set to \texttt{null}.

Here's a real Liferay example:

\begin{verbatim}
http://localhost:8080/api/jsonws/bookmarks.bookmarksfolder/add-folder.4/parent-folder-id/0/name/News?p_auth=[value]
\end{verbatim}

In this example, the hint number is \texttt{4} because there are four
parameters: \texttt{parentFolderId}, \texttt{name},
\texttt{description}, and \texttt{p\_auth}. Since the
\texttt{description} parameter is omitted, its value is assumed to be
\texttt{null}. If you try to invoke this web service with another hint
number such as \texttt{3} or \texttt{5}, you'll get an exception since
there is no \texttt{bookmarks/add-folder} method that takes that number
of parameters. The authentication parameter \texttt{p\_auth} is
associated with your Liferay session. See below for more information.

\noindent\hrulefill

\textbf{Important:} When invoking a Liferay web service by entering a
URL into your browser, you must be logged into Liferay with an account
that has permission to invoke the web service. You must also supply an
authentication token as a URL parameter. This authentication token is
associated with your browser session and is called \texttt{p\_auth}.
Using this authentication token helps prevent CSRF attacks.

\noindent\hrulefill

Here are two easy ways to find the \texttt{p\_auth} token:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Go to Liferay's JSON web services page and click on any service
  method. The value of the \texttt{p\_auth} token appears under the
  Execute heading.
\item
  If you're working from a JavaScript context and have access to the
  \texttt{Liferay} object, invoking \texttt{Liferay.authToken} provides
  the value of the \texttt{p\_auth} parameter.
\end{enumerate}

For example, if your \texttt{p\_auth} parameter's value is
\texttt{n35K1pb2}, you could invoke the preceding URL examples like
this:

\begin{verbatim}
http://localhost:8080/api/jsonws/bookmarks.bookmarksfolder/add-folder.4/parent-folder-id/0/name/News?p_auth=n35K1pb2
\end{verbatim}

For simplicity, the remainder of this tutorial omits the
\texttt{p\_auth} parameter from the example URLs for invoking web
services. Remember that you must include it if you want to invoke
services from your browser!

Next, you'll learn how to pass parameters as part of the URL path.

\subsection{Passing Parameters as Part of a URL
Path}\label{passing-parameters-as-part-of-a-url-path}

Specify parameters in name-value pairs after the service URL. Parameter
names must be formed from method argument names by converting them from
camel case to all lower case, dash-separated names. For example, this
returns all top-level bookmark folders from the specified site:

\begin{verbatim}
http://localhost:8080/api/jsonws/bookmarks.bookmarksfolder/get-folders/group-id/20181/parent-folder-id/0
\end{verbatim}

You can pass parameters in any order; you need not follow the order of
the arguments in the method signatures.

When a method name is overloaded, the \emph{best match} is used. The
method that contains the least number of undefined arguments is chosen
and invoked for you.

You can also pass parameters in a URL query. The next section shows you
how to do this.

\subsection{Passing Parameters as a URL
Query}\label{passing-parameters-as-a-url-query}

To pass in parameters as request parameters, specify them as-is (camel
case) and set them equal to their argument value. For example:

\begin{verbatim}
http://localhost:8080/api/jsonws/bookmarks.bookmarksfolder/add-folder?parentFolderId=0&name=News&description=news
\end{verbatim}

As with passing parameters as part of a URL path, the parameter order is
not important and the best match rule applies for overloaded methods.

Now you know a few different ways to pass parameters. You can also pass
URL parameters in a mixed way. For example, some can be part of the URL
path while others can be specified as request parameters.

Parameter values are sent as strings using the HTTP protocol. Before a
matching Java service method is invoked, each parameter value is
converted from a \texttt{String} to its target Java type. Liferay uses a
third party open source library to convert each object to its
appropriate common type. Although it's possible to add or change the
conversion for certain types, this tutorial only covers the standard
conversion process.

Conversion for common types (e.g., \texttt{long}, \texttt{String},
\texttt{boolean}) happens directly. Dates can be given in milliseconds.
Locales can be passed as locale names (e.g.~\texttt{en} and
\texttt{en\_US}). To pass in an array of numbers, send a string of
comma-separated numbers (e.g.~the string \texttt{4,8,15,16,23,42} can be
converted to \texttt{long{[}{]}} type). You get the picture!

In addition to the common types, arguments can be of type \texttt{List}
or \texttt{Map}. To pass a \texttt{List} argument, send a JSON array. To
pass a \texttt{Map} argument, send a JSON object. These types of
conversions are performed in two steps:

\begin{itemize}
\tightlist
\item
  \emph{Step 1--JSON deserialization}: JSON arrays are converted into
  \texttt{List\textless{}String\textgreater{}}, and JSON objects are
  converted to \texttt{Map\textless{}String,\ String\textgreater{}}. For
  security reasons, it's forbidden to instantiate any type within JSON
  deserialization.
\item
  \emph{Step 2--Generification}: Each \texttt{String} element of the
  \texttt{List} and \texttt{Map} is converted to its target type (the
  argument's generic Java type specified in the method signature). This
  step is only executed if the Java argument type uses generics.
\end{itemize}

For example, consider the conversion of a \texttt{String} array
\texttt{{[}en,fr{]}} as JSON web service parameters for a
\texttt{List\textless{}Locale\textgreater{}} Java method argument type:

\begin{itemize}
\item
  \emph{Step 1--JSON deserialization}: The JSON array is deserialized to
  a \texttt{List\textless{}String\textgreater{}} containing
  \texttt{String}s \texttt{en} and \texttt{fr}.
\item
  \emph{Step 2--Generification}: Each \texttt{String} is converted to
  the \texttt{Locale} (the generic type), resulting in the
  \texttt{List\textless{}Locale\textgreater{}} Java argument type.
\end{itemize}

Next, you'll learn how to specify an argument as \texttt{null}.

\subsection{Sending Null Values}\label{sending-null-values}

To pass a \texttt{null} value for an argument, prefix the parameter name
with a dash. Here's an example:

\begin{verbatim}
http://localhost:8080/api/jsonws/bookmarks.bookmarksfolder/add-folder/parent-folder-id/0/name/News/-description
\end{verbatim}

Here's the equivalent example using URL query parameters instead of URL
path parameters:

\begin{verbatim}
http://localhost:8080/api/jsonws/bookmarks.bookmarksfolder/add-folder?parentFolderId=0&name=News&-description
\end{verbatim}

The \texttt{description} parameter is interpreted as \texttt{null}. Note
that this parameter doesn't have to be last in the URL.

Null parameters don't have specified values. When a null parameter is
passed as a request parameter, its value is ignored and \texttt{null} is
used instead:

\begin{verbatim}
<input type="hidden" name="-description" value=""/>
\end{verbatim}

When using JSON-RPC (see the JSON-RPC section below), you can send null
values explicitly, even without a prefix. Here's an example:

\begin{verbatim}
"description":null
\end{verbatim}

Next, you'll learn about encoding parameters.

\subsection{Encoding Parameters}\label{encoding-parameters}

There's a difference between URL encoding and query (i.e., request
parameters) encoding. The difference lies in how the space character is
encoded. When the space character is part of the URL path, it's encoded
as \texttt{\%20}; when it's part of the query it's encoded as a plus
sign (\texttt{+}).

All these encoding rules apply to ASCII and international (non-ASCII)
characters. Since Liferay works in UTF-8 mode, parameter values must be
encoded as UTF-8 values. Liferay doesn't decode request URLs and request
parameter values to UTF-8 itself; it relies on the web server. When
accessing services through JSON-RPC, encoding parameters to UTF-8 isn't
enough---you need to send the encoding type in a Content-Type header
(e.g.~\texttt{Content-Type\ :\ "text/plain;\ charset=utf-8"}).

For example, suppose you want to pass the value ``Супер'' (``Super'' in
Cyrillic) to a JSON web service method. This name must first be
converted to UTF-8 (resulting in an array of 10 bytes) and then encoded
for URLs or request parameters. The resulting value is the string
\texttt{\%D0\%A1\%D1\%83\%D0\%BF\%D0\%B5\%D1\%80} that can be passed to
your service method. When received, this value is first translated to an
array of 10 bytes (URL decoded), and then converted to a UTF-8 string of
the 5 original characters.

Next, you'll learn how to send files as arguments.

\subsection{Sending Files as
Arguments}\label{sending-files-as-arguments}

Files can be uploaded using multi-part forms and requests. Here's an
example:

\begin{verbatim}
<form
 action="http://localhost:8080/api/jsonws/dlapp/add-file-entry"
 method="POST"
 enctype="multipart/form-data">
    <input type="hidden" name="repositoryId" value="10172"/>
    <input type="hidden" name="folderId" value="0"/>
    <input type="hidden" name="title" value="test.jpg"/>
    <input type="hidden" name="description" value="File upload example"/>
    <input type="hidden" name="changeLog" value="v1"/>
    <input type="file" name="file"/>
    <input type="submit" value="addFileEntry(file)"/>
</form>
\end{verbatim}

This is a common upload form that invokes the \texttt{DLAppService}
class's \texttt{addFileEntry} method.

Now you'll learn how to invoke JSON web services using JSON-RPC.

\subsection{JSON-RPC}\label{json-rpc}

You can invoke JSON Web Service using
\href{http://json-rpc.org}{JSON-RPC}. Most of the JSON-RPC 2.0
specification is supported in Liferay JSON web services. One important
limitation is that parameters must be passed in as \emph{named}
parameters. Positional parameters aren't supported, as there are too
many overloaded methods for convenient use of positional parameters.

Here's an example of invoking a JSON web service using JSON-RPC:

\begin{verbatim}
POST http://localhost:8080/api/jsonws/dlapp
{
    "method":"get-folders",
    "params":{"repositoryId":10172, "parentFolderId":0},
    "id":123,
    "jsonrpc":"2.0"
}
\end{verbatim}

Next, you'll learn about parameters that are made available to secure
JSON web services by default.

\subsection{Default Parameters}\label{default-parameters}

When accessing secure JSON web services (i.e., services for which the
user must be authenticated), some parameters are made available to the
web services by default. All of Liferay's web services are secured by
default. Unless you want to change the available parameters' values to
something other than their defaults, you don't have to specify them
explicitly.

Here are the available default parameters:

\begin{itemize}
\tightlist
\item
  \texttt{userId}: The primary key of the authenticated user
\item
  \texttt{user}: The full user object
\item
  \texttt{companyId}: The primary key of the user's company
\item
  \texttt{serviceContext}: The empty service context object
\end{itemize}

Next, you'll learn about object parameters.

\subsection{Object Parameters}\label{object-parameters}

Most services accept simple parameters like numbers and strings.
However, sometimes you might need to provide an object (a non-simple
type) as a service parameter.

To create an instance of an object parameter, prefix the parameter with
a plus sign, \texttt{+} and don't assign it any other parameter value.
This is similar to specifying a null parameter by prefixing the
parameter with a dash symbol, \texttt{-}.

Here's an example:

\begin{verbatim}
/jsonws/foo/get-bar/zap-id/10172/start/0/end/1/+foo
\end{verbatim}

To create an instance of an object parameter as a request parameter,
make sure you encode the \texttt{+} symbol:

\begin{verbatim}
/jsonws/foo/get-bar?zapId=10172&start=0&end=1&%2Bfoo
\end{verbatim}

Here's an alternative syntax:

\begin{verbatim}
<input type="hidden" name="+foo" value=""/>
\end{verbatim}

If a parameter is an abstract class or an interface, it can't be
instantiated as such. Instead, a concrete implementation class must be
specified to create the argument value. You can do this by specifying
the \texttt{+} prefix before the parameter name, followed by specifying
the concrete implementation class. Here's an example:

\begin{verbatim}
/jsonws/foo/get-bar/zap-id/10172/start/0/end/1/+foo:com.liferay.impl.FooBean
\end{verbatim}

Here's another way of doing it:

\begin{verbatim}
<input type="hidden" name="+foo:com.liferay.impl.FooBean" value=""/>
\end{verbatim}

The examples above specify that a \texttt{com.liferay.impl.FooBean}
object, presumed to implement the class of the parameter named
\texttt{foo}, is created.

You can also set a concrete implementation as a value. Here's an
example:

\begin{verbatim}
<input type="hidden" name="+foo" value="com.liferay.impl.FooBean"/>
\end{verbatim}

In JSON-RPC, here's what it looks like:

\begin{verbatim}
"+foo" : "com.liferay.impl.FooBean"
\end{verbatim}

All the preceding examples specify a concrete implementation for the
\texttt{foo} service method parameter.

Once you pass in an object parameter, you might want to populate the
object. Find out how next.

\subsection{Inner Parameters}\label{inner-parameters}

When you pass in an object parameter, you'll often need to populate its
inner parameters (i.e., fields). Consider a default parameter
\texttt{serviceContext} of type \texttt{ServiceContext}. To make an
appropriate call to JSONWS, you might need to set the
\texttt{serviceContext} parameter's \texttt{addGroupPermissions} and
\texttt{scopeGroupId} fields.

You can pass inner parameters by using dot notation to specify them.
Append the name of the parameter with a dot (i.e., a period,
\texttt{.}), followed by the inner parameter's name. For the
\texttt{ServiceContext} inner parameters mentioned previously, you'll
specify \texttt{serviceContext.addGroupPermissions} and
\texttt{serviceContext.scopeGroupId}. These are recognized as inner
parameters and their values are injected into existing parameters before
the API service method is executed.

Inner parameters aren't counted as regular parameters for matching
methods and are ignored during matching.

You can extend the JSON-RPC object parameter example above by populating
its inner parameters:

\begin{verbatim}
"+foo" : "com.liferay.impl.FooBean",
"foo.field1" : "test",
"foo.field2" : "true",
"foo.field3" : 123
\end{verbatim}

Here's the same with JavaScript (assuming we have a remote service under
the \texttt{foo} context which accepts one argument with type
\texttt{com.liferay.impl.FooBean} and it has the specified fields):

\begin{verbatim}
    Liferay.Service(
        '/foo/update-foo',
    {
            "+foo": "com.liferay.impl.FooBean",
        "foo.field1" : "test",
        "foo.field2" : "true",
        "foo.field3": 123
        },
        function(obj) {
            console.log(obj);
        }
    );
\end{verbatim}

\noindent\hrulefill

\textbf{Tip:} Use inner parameters with object parameters to set inner
contents of created object parameter instances!

\noindent\hrulefill

Next, you'll examine returned values when a JSON web service is invoked.

\subsection{Returned Values}\label{returned-values}

No matter how a JSON web service is invoked, it returns a JSON string
that represents the service method result. Returned objects are
\emph{loosely} serialized to a JSON string and returned to the caller.

Here's an example. To make it easy, you'll use the test form provided
with the JSON web service in our browser.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Sign in to a local Liferay instance as an administrator and then point
  your browser to the JSON web service method that adds a
  \texttt{BookmarksFolder}:

\begin{verbatim}
http://localhost:8080/api/jsonws?contextName=bookmarks&signature=%2Fbookmarks.bookmarksfolder%2Fadd-folder-4-parentFolderId-name-description-serviceContext
\end{verbatim}

  Alternatively, navigate to it by starting at
  \texttt{http://localhost:8080/api/jsonws} and then scrolling down to
  the section for \emph{BookmarksFolder}. Then click \emph{add-folder}.
\item
  In the \texttt{parentFolderId} field, enter \texttt{0}. Top-level
  bookmarks folders have a \texttt{parentFolderId} value of \texttt{0}.
  Set the name to an arbitrary value like \emph{News}. Set the
  description to something like \emph{Created via JSON WS}.
\item
  Click \emph{Invoke} and you'll get a result like this:

\begin{verbatim}
{
  "companyId": "20202",
  "createDate": 1459969296960,
  "description": "Created via JSON WS",
  "folderId": "31001",
  "groupId": "20233",
  "lastPublishDate": null,
  "modifiedDate": 1459969297005,
  "name": "News",
  "parentFolderId": "0",
  "resourceBlockId": "1",
  "status": 0,
  "statusByUserId": "0",
  "statusByUserName": "",
  "statusDate": null,
  "treePath": "/31001/",
  "userId": "20250",
  "userName": "Joe Bloggs",
  "uuid": "0682170c-f9d7-f295-aa67-26ceea37a6e5"
}
\end{verbatim}
\end{enumerate}

The returned \texttt{String} represents the \texttt{BookmarksFolder}
object you just created, serialized into a JSON string. To find out more
about JSON strings, go to \href{http://www.json.org/}{json.org}. Also,
note that Liferay provides a
\href{https://github.com/liferay/liferay-portal/blob/7.1.x/portal-kernel/src/com/liferay/portal/kernel/json/JSONFactory.java}{\texttt{JSONFactory}}
service that allows developers to create JSON objects and arrays,
serialize and deserialize JSON strings, and perform other JSON-related
operations.

\subsection{Common JSON Web Service
Errors}\label{common-json-web-service-errors}

While working with JSON web services, you may encounter errors. Some
common errors are listed here:

\begin{itemize}
\item
  \emph{Authenticated access required}

  If you see this error, it means you don't have permission to invoke
  the remote service. Double-check that you're signed in as a user with
  the appropriate permissions. If necessary, sign in as an administrator
  to invoke the remote service.
\item
  \emph{Missing value for parameter}

  If you see this error, you didn't pass a parameter value with the
  parameter name in your URL path. The parameter value must follow the
  parameter name. This is wrong:

\begin{verbatim}
/api/jsonws/user/get-user-by-id/userId
\end{verbatim}

  The path above specifies a parameter named \texttt{userId}, but
  doesn't specify the parameter's value. You can resolve this error by
  providing the parameter value after the parameter name:

\begin{verbatim}
/api/jsonws/user/get-user-by-id/userId/173
\end{verbatim}
\item
  \emph{No JSON web service action associated}

  This error means that no service method could be matched with the
  provided data (method name and argument names). This can be due to
  various reasons. For example, arguments may be misspelled, the method
  name may be formatted incorrectly, and so on. Since JSON web services
  reflect the underlying Java API, any changes there are automatically
  propagated to the JSON web services. For example, if a new argument is
  added to a method or an existing argument is removed from a method,
  the parameter data must match the new method signature.
\item
  \emph{Unmatched argument type}

  This error appears when you try to instantiate a method argument using
  an incompatible argument type.
\end{itemize}

\subsection{Related Topics}\label{related-topics-89}

\href{/docs/7-1/tutorials/-/knowledge_base/t/json-web-services-invoker}{JSON
Web Services Invoker}

\href{/docs/7-1/tutorials/-/knowledge_base/t/service-security-layers}{Service
Security Layers}

\href{/docs/7-1/tutorials/-/knowledge_base/t/invoking-remote-services}{Invoking
Remote Services}

\section{JSON Web Services Invoker}\label{json-web-services-invoker}

With JSON web services, you send a request to a service method with
parameters, and you receive the result as a JSON object. As
straightforward as this seems, it can be improved. In this tutorial,
you'll learn how.

Say you're working with two related objects: a \texttt{User} and its
corresponding \texttt{Contact}. Normally you first call the user service
to get the user object, and then you use that object's contact ID to
call the contact service. This sends two HTTP requests to get two
separate JSON objects. There's no contact information in the user object
(i.e.~no \texttt{user.contact}). This approach is suboptimal with
respect to performance (sending two HTTP calls) and usability (manually
managing the relationship between two objects). It'd be nicer if you had
a tool to address these inefficiencies. Fortunately, the JSON Web
Service Invoker does just that!

Liferay's JSON Web Service Invoker helps optimize your JSON Web Services
use.

\subsection{Simple Invoker Calls}\label{simple-invoker-calls}

The Invoker is accessible from the following fixed address:

\begin{verbatim}
http://[address]:[port]/api/jsonws/invoke
\end{verbatim}

It only accepts a \texttt{cmd} request parameter---this is the Invoker's
command. If the command request parameter is missing, the request body
is used as the command. So you can specify the command by using the
request parameter \texttt{cmd} or the request body.

The Invoker command is a plain JSON map that describes how JSON web
services are called and how the results are managed. Here's an example
of how to call a simple service using the Invoker:

\begin{verbatim}
{
    "/user/get-user-by-id": {
        "userId": 123,
        "param1": null
    }
}
\end{verbatim}

The service call is defined as a JSON map. The key specifies the service
URL (i.e.~the service method to be invoked) and the key's value
specifies a map of service parameter names (i.e.~\texttt{userId} and
\texttt{param1}) and their values. In the example above, the retrieved
user is returned as a JSON object. Since the command is a JSON string,
null values can be specified by explicitly using the \texttt{null}
keyword or by placing a dash before the parameter name and leaving the
value empty
(e.g.~\texttt{"-param1":\ \textquotesingle{}\textquotesingle{}}).

The example Invoker calls functions exactly the same way as the
following standard JSON Web Service call:

\begin{verbatim}
/user/get-user-by-id?userId=123&-param1
\end{verbatim}

If you're running Liferay locally on port \texttt{8080}, here's how you
invoke a JSON web service:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Collect your credentials. Here's an example:

  \begin{itemize}
  \tightlist
  \item
    Email: \texttt{test@example.com}
  \item
    User ID: \texttt{20127}
  \item
    Authorization Token: \texttt{htXjvt5d}
  \end{itemize}
\item
  Invoke the service:

\begin{verbatim}
http://localhost:8080/api/jsonws/invoke?cmd={%22/user/get-user-by-id%22:{%22userId%22:20172}}&p_auth=htXjvt5d
\end{verbatim}
\end{enumerate}

This URL uses the following JSON map. Note that it's supplied in the URL
by using the \texttt{cmd} URL parameter:

\begin{verbatim}
{
    "/user/get-user-by-id": {
        "userId": 20172
    }
}
\end{verbatim}

In the URL, the double quotes are URL-encoded. To find your user ID,
check the User Menu under \emph{My Account} → \emph{Account Settings}.
To find your \texttt{p\_auth} authentication token, navigate to
\href{http://localhost:8080/api/jsonws}{Liferay's JSON web services API
page} and click on any method in the list. The value of your
\texttt{p\_auth} token appears under the Execute heading along with any
other parameters of the selected API method.

Use JSON syntax to supply values for objects and arrays as parameters.
To supply a value for an object, use curly brackets: \texttt{\{} and
\texttt{\}}. To supply a value for an array, use square brackets:
\texttt{{[}} and \texttt{{]}}.

If you want to pass an array as a parameter using the same credential
token as above, here's an example how, using two vocabularies with
vocabulary IDs of \texttt{20783} and \texttt{20784}:

\begin{verbatim}
http://localhost:8080/api/jsonws/invoke?cmd={%22/assetvocabulary/get-vocabularies%22:{%22vocabularyIds%22:[20783,20784]}}&p_auth=htXjvt5d
\end{verbatim}

This URL uses the following JSON map:

\begin{verbatim}
{
    "/assetvocabulary/get-vocabularies": {
        "vocabularyIds": [20783,20784]
    }
}
\end{verbatim}

As before, the double quotes in the URL are URL-encoded. Also, the
\texttt{vocabularyIds} parameter is an array, so its value is supplied
as a JSON array.

Finally, here's one more Liferay JSON web service invoker example that
demonstrates how to pass an object containing an array as a parameter:

\begin{verbatim}
http://localhost:8080/api/jsonws/invoke?cmd={%22/user/add-user%22:{%22companyId%22:20127,%22autoPassword%22:false,%22password1%22:%22test%22,%22password2%22:%22test%22,%22autoScreenName%22:false,%22screenName%22:%22joe.bloggs%22,%22emailAddress%22:%22joe.bloggs@example.com%22,%22facebookId%22:0,%22openId%22:%22%22,%22locale%22:%22en_US%22,%22firstName%22:%22Joe%22,%22middleName%22:%22T%22,%22lastName%22:%22Bloggs%22,%22prefixId%22:0,%22suffixId%22:0,%22male%22:true,%22birthdayMonth%22:1,%22birthdayDay%22:1,%22birthdayYear%22:1970,%22jobTitle%22:%22Tester%22,%22groupIds%22:null,%22organizationIds%22:null,%22roleIds%22:null,%22userGroupIds%22:null,%22sendEmail%22:false,%22serviceContext%22:{%22assetTagNames%22:[%22test%22]}}}&p_auth=htXjvt5d
\end{verbatim}

This URL uses the following JSON map:

\begin{verbatim}
{
    "/user/add-user": {
        "companyId": 20127,
        "autoPassword": false,
        "password1": "test",
        "password2": "test",
        "autoScreenName": false,
        "screenName": "joe.bloggs",
        "emailAddress": "joe.bloggs@example.com",
        "facebookId": 0,
        "openId": "",
        "locale": "en_US",
        "firstName": "Joe",
        "middleName": "T",
        "lastName": "Bloggs",
        "prefixId": 0,
        "suffixId": 0,
        "male": true,
        "birthdayMonth": 1,
        "birthdayDay": 1,
        "birthdayYear": 1970,
        "jobTitle": "Tester",
        "groupIds": null,
        "organizationIds": null,
        "roleIds": null,
        "userGroupIds": null,
        "sendEmail": false,
        "serviceContext": {"assetTagNames":["test"]}
    }
}
\end{verbatim}

The \texttt{serviceContext} is the object containing an array in this
example. It contains the array \texttt{assetTagNames}.

Of course, the JSON Web Service Invoker handles calls to plugin methods
as well:

\begin{verbatim}
{
    "/suprasurf/hello-world": {
        "worldName": "Mavericks"
    }
}
\end{verbatim}

The code above calls the (fictitious) SupraSurf application's remote
service.

You can use variables to reference objects returned from service calls.
Variable names must start with a dollar sign, \texttt{\$}. In the
previous example, the service call returned a user object you can assign
to a variable:

\begin{verbatim}
{
    "$user = /user/get-user-by-id": {
        "userId": 123,
    }
}
\end{verbatim}

The \texttt{\$user} variable holds the returned user object. You can
reference the user's contact ID using the syntax
\texttt{\$user.contactId}.

Next, see how you can use nested service calls to join information from
two related objects.

\subsection{Nesting Service Calls}\label{nesting-service-calls}

With nested service calls, you can bind information from related objects
together in a JSON object. You can call other services within the same
HTTP request and nest returned objects in a convenient way. Here's a
nested service call in action:

\begin{verbatim}
{
    "$user = /user/get-user-by-id": {
        "userId": 123,
        "$contact = /contact/get-contact-by-id": {
            "@contactId": "$user.contactId"
        }
    }
}
\end{verbatim}

This command defines two service calls: the contact object returned from
the second service call is nested in (i.e.~injected into) the user
object, as a property named \texttt{contact}. Now you can bind the user
and his or her contact information together!

Now you'll see what the Invoker does in the background when using a
single HTTP request to make the preceding nested service call:

\begin{itemize}
\tightlist
\item
  First, the Invoker calls the Java service mapped to
  \texttt{/user/get-user-by-id}, passing in a value for the
  \texttt{userId} parameter.
\item
  Next, the resulting user object is assigned to the variable
  \texttt{\$user}.
\item
  The nested service calls are invoked.
\item
  The Invoker calls the Java service mapped to
  \texttt{/contact/get-contact-by-id} by using the \texttt{contactId}
  parameter, with the \texttt{\$user.contactId} value from the object
  \texttt{\$user}.
\item
  The resulting contact object is assigned to the variable
  \texttt{\$contact}.
\item
  Lastly, the Invoker injects the contact object referenced by
  \texttt{\$contact} into the user object's property named
  \texttt{contact}.
\end{itemize}

\noindent\hrulefill

\textbf{Note:} You must flag parameters that take values from existing
variables. To flag a parameter, insert the \texttt{@} prefix before the
parameter name.

\noindent\hrulefill

Next, you'll learn about filtering object properties so that only the
properties you need are returned when you invoke a service.

\subsection{Filtering Results}\label{filtering-results}

Many of Liferay's model objects are rich with properties. If you only
need a handful of an object's properties for your business logic, making
a web service invocation that returns all of an object's properties is a
waste of network bandwidth. With the JSON Web Service Invoker, you can
define a whitelist of properties: only the specific properties you
request in the object are returned from your web service call. Here's
how you whitelist the properties you need:

\begin{verbatim}
{
    "$user[firstName,emailAddress] = /user/get-user-by-id": {
        "userId": 123,
        "$contact = /contact/get-contact-by-id": {
            "@contactId": "$user.contactId"
        }
    }
}
\end{verbatim}

In this example, the returned user object has only the
\texttt{firstName} and \texttt{emailAddress} properties (it still has
the \texttt{contact} property, too). To specify whitelist properties,
place the properties in square brackets (e.g., \texttt{{[}whiteList{]}})
immediately following the name of your variable.

Next, you'll learn about making calls in batch.

\subsection{Making Batch Calls}\label{making-batch-calls}

When nesting service calls, you invoke multiple services with a single
HTTP request. This is helpful for gathering related information from the
service call results, but it you can also use a single request to invoke
multiple unrelated service calls by batching service calls together to
improve performance. Do this by passing in a JSON array of commands:

\begin{verbatim}
[
    {/* first command */},
    {/* second command */}
]
\end{verbatim}

The result is a JSON array populated with results from each command. The
commands are collectively invoked in a single HTTP request, one after
another.

Great! Now you know how to use Liferay's JSON Web Service Invoker to
simplify your JSON calls to Liferay.

\subsection{Related Topics}\label{related-topics-90}

\href{/docs/7-1/tutorials/-/knowledge_base/t/invoking-remote-services}{Invoking
Remote Services}

\href{/docs/7-1/tutorials/-/knowledge_base/t/invoking-json-web-services}{Invoking
JSON Web Services}

\section{Configuring JSON Web
Services}\label{configuring-json-web-services}

JSON web services are enabled in Liferay by default. If you must disable
them, specify this portal property setting in a
\texttt{portal-ext.properties} file:

\begin{verbatim}
json.web.service.enabled=false
\end{verbatim}

This tutorial presents other properties that you can use to fine-tune
exactly how JSON web services work in your Liferay instance. You can
find these, and other properties, in
\href{https://docs.liferay.com/dxp/portal/7.1-latest/propertiesdoc/portal.properties.html}{the
portal properties reference documentation}. As with the preceding
property, you should set portal properties in a
\texttt{portal-ext.properties} file.

First, you'll learn about setting whether JSON web services are
discoverable via the API page.

\subsection{Discoverability}\label{discoverability}

By default, JSON web services are discoverable via the API page at
\texttt{http://{[}address{]}:{[}port{]}/api/jsonws}. To disable this,
set the following property:

\begin{verbatim}
jsonws.web.service.api.discoverable=false
\end{verbatim}

Next, you'll learn how to disable HTTP methods.

\subsection{Disabling HTTP Methods}\label{disabling-http-methods}

When strict HTTP method mode is enabled, you can filter web service
access based on HTTP methods used by the services. For example, set your
Liferay instance's JSON web services to work in read-only mode by
disabling HTTP methods other than \texttt{GET}:

\begin{verbatim}
jsonws.web.service.invalid.http.methods=DELETE,POST,PUT
\end{verbatim}

With this setting, all requests that use \texttt{DELETE}, \texttt{POST},
or \texttt{PUT} HTTP methods are ignored.

Next, you'll learn how to restrict public access to exposed JSON APIs.

\subsection{Strict HTTP Methods}\label{strict-http-methods}

All JSON web services are mapped to either \texttt{GET} or \texttt{POST}
HTTP methods. If a service method name starts with \texttt{get},
\texttt{is} or \texttt{has}, the service is assumed to be read-only and
is bound to the \texttt{GET} method. Otherwise, it's bound to
\texttt{POST}.

By default, Liferay doesn't check \texttt{HTTP} methods when invoking a
service call; it works in non-strict http method mode, where services
may be invoked using any HTTP method. If you need the strict mode, you
can set it as follows:

\begin{verbatim}
jsonws.web.service.strict.http.method=true
\end{verbatim}

When using strict mode, you must use the correct HTTP methods to call
service methods. When strict HTTP mode is enabled, you still might need
to disable HTTP methods. You'll learn how next.

\subsection{Controlling Public Access}\label{controlling-public-access}

Each service method knows whether a given user has permission to invoke
the chosen action. If you're concerned about security, you can restrict
access to exposed JSON APIs by explicitly permitting or restricting
certain JSON web service paths.

The property \texttt{jsonws.web.service.paths.includes} denotes patterns
for JSON web service action paths that are allowed. Set a blank pattern
to allow any service action path.

The property \texttt{jsonws.web.service.paths.excludes} denotes patterns
for JSON web service action paths that aren't allowed even if they match
one of the patterns set in \texttt{jsonws.web.service.paths.includes}.

Note that these properties support wildcards. For example, if you set
\texttt{jsonws.web.service.paths.includes=get*,has*,is*}, Liferay makes
all read-only JSON methods publicly accessible. All other JSON methods
are disabled. To disable access to all exposed methods, you can leave
the right side of the \texttt{=} symbol empty. To enable access to all
exposed methods, specify \texttt{*}. Remember that if a path matches
both the \texttt{jsonws.web.service.paths.includes} and
\texttt{jsonws.web.service.paths.excludes} properties, the
\texttt{jsonws.web.service.paths.excludes} property takes precedence.

\subsection{Related Topics}\label{related-topics-91}

\href{/docs/7-1/tutorials/-/knowledge_base/t/registering-json-web-services}{Registering
JSON Web Services}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-remote-services}{Creating
Remote Services}

\href{/docs/7-1/tutorials/-/knowledge_base/t/invoking-remote-services}{Invoking
Remote Services}

\section{SOAP Web Services}\label{soap-web-services}

You can access Liferay's web services via Simple Object Access Protocol
(SOAP) over HTTP. The packaging protocol is SOAP, and the transport
protocol is HTTP.

\noindent\hrulefill

\textbf{Note:} An authentication token must accompany each Liferay web
service invocation. For details, see the tutorial on
\href{/docs/7-1/tutorials/-/knowledge_base/t/service-security-layers}{Service
Security Layers}.

\noindent\hrulefill

As an example, consider some example SOAP web service clients for
Liferay's \texttt{Company}, \texttt{User}, and \texttt{UserGroup}
services that perform these tasks:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  List each user group the user with the screenname \emph{test} belongs
  to.
\item
  Add a new user group named \emph{MyGroup}.
\item
  Add your Liferay instance's administrative user to the new user group.
  For demonstration purposes, you'll use an administrative user whose
  email address is \texttt{test@example.com}.
\end{enumerate}

You'll use these SOAP related classes:

\begin{verbatim}
import com.liferay.portal.kernel.model.CompanySoap;
import com.liferay.portal.kernel.model.CompanySoap;
import com.liferay.portal.kernel.model.UserGroupSoap;
import com.liferay.portal.kernel.model.UserGroupSoap;
import com.liferay.portal.service.http.CompanyServiceSoap;
import com.liferay.portal.service.http.CompanyServiceSoapServiceLocator;
import com.liferay.portal.service.http.UserGroupServiceSoap;
import com.liferay.portal.service.http.UserGroupServiceSoapServiceLocator;
import com.liferay.portal.service.http.UserServiceSoap;
import com.liferay.portal.service.http.UserServiceSoapServiceLocator;
\end{verbatim}

Can you see the naming convention for SOAP related classes? These
classes have either \texttt{-ServiceSoapServiceLocator},
\texttt{-ServiceSoap}, or \texttt{-Soap} as suffixes. The
\texttt{-ServiceSoapServiceLocator} class finds the
\texttt{-ServiceSoap} class via the service's URL you provide. The
\texttt{-ServiceSoap} class is the interface to the services specified
in the Web Services Definition Language (WSDL) file for each service.
The \texttt{-Soap} classes are the serializable implementations of the
models.

So how do you determine the URLs for these services? This is a most
excellent question! You can see a list of the services deployed on your
Liferay instance by opening your browser to the following URL:

\begin{verbatim}
http://[host]:[port]/api/axis
\end{verbatim}

Note that this URL only lists services in the portal context. To learn
how to find services in other contexts in your Liferay instance, see the
SOAP sections in the tutorial
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-remote-services}{Creating
Remote Services}.

Regardless of the context you're viewing SOAP services in, each web
service is listed with its name, operations, and a link to its WSDL
file. For example, here's the list of secure web services listed for
\texttt{UserGroup}:

\begin{itemize}
\tightlist
\item
  \texttt{Portal\_UserGroupService} (wsdl)

  \begin{itemize}
  \tightlist
  \item
    \texttt{addGroupUserGroups}
  \item
    \texttt{addTeamUserGroups}
  \item
    \texttt{addUserGroup}
  \item
    \texttt{deleteUserGroup}
  \item
    \texttt{fetchUserGroup}
  \item
    \texttt{getUserGroup}
  \item
    \texttt{getUserGroups}
  \item
    \texttt{getUserUserGroups}
  \item
    \texttt{unsetGroupUserGroups}
  \item
    \texttt{unsetTeamUserGroups}
  \item
    \texttt{updateUserGroup}
  \end{itemize}
\end{itemize}

Note that some of these methods are overloaded.

Liferay uses Service Builder to automatically generate JSON and SOAP web
service interfaces. If you haven't used Service Builder before, see this
\href{/docs/7-1/tutorials/-/knowledge_base/t/what-is-service-builder}{introductory
tutorial}.

The WSDL file is written in XML and provides a model for describing and
locating the web service. Here's a WSDL excerpt of the
\texttt{addUserGroup} operation of \texttt{UserGroup}:

\begin{verbatim}
<wsdl:operation name="addUserGroup" parameterOrder="name description">
    <wsdl:input message="intf:addUserGroupRequest" name="addUserGroupRequest"/>
    <wsdl:output message="intf:addUserGroupResponse" name="addUserGroupResponse"/>
</wsdl:operation>
\end{verbatim}

To use the service, you pass in the WSDL URL along with your login
credentials to the SOAP service locator for your service. The next
section shows you an example of this.

\subsection{SOAP Java Client}\label{soap-java-client}

Now you'll learn how to invoke Liferay's SOAP web services. As an
example, you'll do this by setting up a Java web services client in
Eclipse. You can use Eclipse's Web Service Client wizard to either
create a new web service client project or add a client to an existing
project. You must add a new web service client to your project for each
service that you want to consume in your client code. For this example,
you'll build a web service client to invoke Liferay's \texttt{Company},
\texttt{User}, and \texttt{UserGroup} services.

To create a new web service client project in Eclipse, click \emph{File}
→ \emph{New} → \emph{Other\ldots{}}, then expand the \emph{Web Services}
category. Select \emph{Web Service Client}.

For each client you create, you're prompted to enter the service
definition (WSDL) for the desired service. Since your example web
service client needs Liferay's \texttt{Company}, \texttt{User}, and
\texttt{UserGroup} services, enter the following WSDLs:

\begin{verbatim}
http://localhost:8080/api/axis/Portal_CompanyService?wsdl

http://localhost:8080/api/axis/Portal_UserService?wsdl

http://localhost:8080/api/axis/Portal_UserGroupService?wsdl
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/api-web-svc-wsdl.png}
\caption{Service Definition}
\end{figure}

When you specify a WSDL, Eclipse automatically adds the auxiliary files
and libraries required to consume that web service. After you've created
your web service client project using one of the above WSDLs, you need
to create additional clients in the project using the remaining WSDLs.
To create an additional client in an existing project, right-click on
the project and select \emph{New} → \emph{Other} → \emph{Web Service
Client}. Click \emph{Next}, enter the WSDL, and complete the wizard.

The following code locates and invokes operations to create a new user
group named \texttt{MyUserGroup} and add a user with the screen name
\emph{test} to it. Create a \texttt{LiferaySoapClient.java} file in your
web service client project and add this code to it. If you create this
class in a package other than the one that's specified in this code,
replace the package with your package. To run the client from Eclipse,
make sure that your Liferay server is running, right-click the
\texttt{LiferaySoapClient.java} class, and select \emph{Run as Java
application}. Check your console to check that your service calls
succeeded.

\begin{verbatim}
package com.liferay.test;

import java.net.URL;

import com.liferay.portal.kernel.model.CompanySoap;
import com.liferay.portal.kernel.model.UserGroupSoap;
import com.liferay.portal.service.http.CompanyServiceSoap;
import com.liferay.portal.service.http.CompanyServiceSoapServiceLocator;
import com.liferay.portal.service.http.UserGroupServiceSoap;
import com.liferay.portal.service.http.UserGroupServiceSoapServiceLocator;
import com.liferay.portal.service.http.UserServiceSoap;
import com.liferay.portal.service.http.UserServiceSoapServiceLocator;

public class LiferaySoapClient {

    public static void main(String[] args) {

        try {
            String remoteUser = "test";
            String password = "test";
            String virtualHost = "localhost";

            String groupName = "MyUserGroup";

            String serviceCompanyName = "Portal_CompanyService";
            String serviceUserName = "Portal_UserService";
            String serviceUserGroupName = "Portal_UserGroupService";

            long userId = 0;

            // Locate the Company
            CompanyServiceSoapServiceLocator locatorCompany =
                new CompanyServiceSoapServiceLocator();

            CompanyServiceSoap soapCompany =
                locatorCompany.getPortal_CompanyService(
                    _getURL(remoteUser, password, serviceCompanyName,
                            true));

            CompanySoap companySoap =
                soapCompany.getCompanyByVirtualHost(virtualHost);

            // Locate the User service
            UserServiceSoapServiceLocator locatorUser =
                new UserServiceSoapServiceLocator();
            UserServiceSoap userSoap = locatorUser.getPortal_UserService(
                _getURL(remoteUser, password, serviceUserName, true));

            // Get the ID of the remote user
            userId = userSoap.getUserIdByScreenName(
                companySoap.getCompanyId(), remoteUser);
            System.out.println("userId for user named " + remoteUser +
                    " is " + userId);

            // Locate the UserGroup service
            UserGroupServiceSoapServiceLocator locator =
                new UserGroupServiceSoapServiceLocator();
            UserGroupServiceSoap usergroupsoap =
                locator.getPortal_UserGroupService(
                    _getURL(remoteUser, password, serviceUserGroupName,
                            true));

            // Get the user's user groups
            UserGroupSoap[] usergroups = usergroupsoap.getUserUserGroups(
                    userId);

            System.out.println("User groups for userId " + userId + " ...");
            for (int i = 0; i < usergroups.length; i++) {
                System.out.println("\t" + usergroups[i].getName());
            }

            // Adds the user group if it does not already exist
            String groupDesc = "My new user group";
            UserGroupSoap newUserGroup = null;

            boolean userGroupAlreadyExists = false;
            try {
                newUserGroup = usergroupsoap.getUserGroup(groupName);
                if (newUserGroup != null) {
                    System.out.println("User with userId " + userId +
                            " is already a member of UserGroup " +
                                    newUserGroup.getName());
                    userGroupAlreadyExists = true;
                }
            } catch (Exception e) {
                // Print cause, but continue
                System.out.println(e.getLocalizedMessage());
            }

            if (!userGroupAlreadyExists) {
                newUserGroup = usergroupsoap.addUserGroup(
                        groupName, groupDesc);
                System.out.println("Added user group named " + groupName);

                long users[] = {userId};
                userSoap.addUserGroupUsers(newUserGroup.getUserGroupId(),
                        users);
            }

            // Get the user's user groups
            usergroups = usergroupsoap.getUserUserGroups(userId);

            System.out.println("User groups for userId " + userId + " ...");
            for (int i = 0; i < usergroups.length; i++) {
                System.out.println("\t" + usergroups[i].getName());
            }
        }
        catch (Exception e) {
            e.getLocalizedMessage();
        }
    }

        private static URL _getURL(String remoteUser, String password,
                        String serviceName, boolean authenticate)
                        throws Exception {

                // Unauthenticated url
                String url = "http://localhost:8080/api/axis/" + serviceName;

                // Authenticated url
                if (authenticate) {
                        url = "http://" + remoteUser + ":" + password
                                        + "@localhost:8080/api/axis/"
                                        + serviceName;
                }

                return new URL(url);
        }

}
\end{verbatim}

Running this client should produce output like this:

\begin{verbatim}
userId for user named test is 10196
User groups for user 10196 ...
java.rmi.RemoteException: No UserGroup exists with the key {companyId=10154,
name=MyUserGroup}
Added user group named
Added user to user group named MyUserGroup
User groups for user 10196 ...
    MyUserGroup
\end{verbatim}

The output tells you the user had no groups, but was added to the user
group \texttt{MyUserGroup}.

You might be thinking, ``But an error was thrown! Something is wrong!''
Yes, an error is thrown (\texttt{java.rmi.RemoteException:}), but you
can sit here as cool as an ice cream sandwich all the same. The
exception is thrown because the \texttt{UserGroup} check is invoked
before the \texttt{UserGroup} is created. Because the very next line of
the output says \texttt{Added\ user\ group\ named...}, you're okay. The
SOAP web service invocations worked!

Here are a few things to note about this example:

\begin{itemize}
\tightlist
\item
  Authentication is done using HTTP Basic Authentication, which isn't
  appropriate for a production environment since the password is
  unencrypted. It's simply used for convenience in this example. In
  production, you should use SSL. Refer to Liferay's
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/propertiesdoc/portal.properties.html}{\texttt{portal.properties}}
  file and look up the \texttt{company.security.auth.requires.https} and
  \texttt{web.server.protocol} properties for more information.
\item
  The screen name and password are passed in the URL as credentials.
\item
  The name of the service (e.g.~\texttt{Portal\_UserGroupService}) is
  specified at the end of the URL. Remember that the service name can be
  found in the web service listing.
\end{itemize}

The operations \texttt{getCompanyByVirtualHost()},
\texttt{getUserIdByScreenName()}, \texttt{getUserUserGroups()},
\texttt{addUserGroup()} and \texttt{addUserGroupUsers()} are specified
for the \texttt{-ServiceSOAP} classes \texttt{CompanyServiceSoap},
\texttt{UserServiceSoap} and \texttt{UserGroupServiceSoap} in the WSDL
files. Information on parameter types, parameter order, request type,
response type, and return type are conveniently specified in the WSDL
for each Liferay web service. It's all there for you!

Next, you'll learn how to implement a web service client in PHP.

\subsection{SOAP PHP Client}\label{soap-php-client}

You can write your client in any language that supports web services
invocation. The following example code invokes the same operations as
before, but uses PHP and a PHP SOAP client instead of Java:

\begin{verbatim}
<?php
    $userGroupName = "MyUserGroup2";
    $userName = "test";
    $clientOptions = array('login' => $userName, 'password' => 'test');

    // Add user group
    $userGroupClient = new 
        SoapClient(
            "http://localhost:8080/api/axis/Portal_UserGroupService?wsdl", 
            $clientOptions);
    $userGroup = $userGroupClient->addUserGroup($userGroupName,
        "This user group was created by the PHP client! ");
    print ("User group ID is $userGroup->userGroupId ");

    // Add user to user group
    $companyClient = new SoapClient(
        "http://localhost:8080/api/axis/Portal_CompanyService?wsdl",
        $clientOptions);
    $company = $companyClient->getCompanyByVirtualHost("localhost");
    $userClient = new SoapClient(
        "http://localhost:8080/api/axis/Portal_UserService?wsdl",
        $clientOptions);
    $userId = $userClient->getUserIdByScreenName($company->companyId,
        $userName);
    print ("User ID for $userName is $userId ");
    $users = array($userId);
    $userClient->addUserGroupUsers($userGroup->userGroupId, $users);

    // Print the user groups to which the user belongs
    $userGroups = $userGroupClient->getUserUserGroups($userId);
    print ("User groups for user $userId ... ");
    foreach($userGroups as $ug)
        print ("$ug->name, $ug->userGroupId ")
?>
\end{verbatim}

Remember, you can implement a web service client in any language that
supports SOAP web services.

\subsection{Related Topics}\label{related-topics-92}

\href{/docs/7-1/tutorials/-/knowledge_base/t/service-security-layers}{Service
Security Layers}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-remote-services}{Creating
Remote Services}

\href{/docs/7-1/tutorials/-/knowledge_base/t/invoking-remote-services}{Invoking
Remote Services}

\href{/docs/7-1/tutorials/-/knowledge_base/t/what-is-service-builder}{What
is Service Builder?}

\chapter{JAX-RS and JAX-WS}\label{jax-rs-and-jax-ws}

You can deploy JAX-RS and JAX-WS web services and consume them much as
you would outside of Liferay DXP. There are, however, a few things you
should know, particularly with regard to deploying them into Liferay
DXP's OSGi container. The tutorials in this section discuss these things
and show you how to use JAX-RS and JAX-WS in Liferay DXP.

\section{JAX-RS}\label{jax-rs}

JAX-RS web services work in Liferay modules the same way they work
outside of Liferay. The only difference is that you must register the
class in the OSGi framework. Liferay's development tools make this easy
by providing a template.

In Liferay Developer Studio, create a new module using the \emph{rest}
template:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Click \emph{File} → \emph{New} → \emph{Liferay Module Project}.
\item
  Give the project a name and select the \emph{rest} template.
\item
  Select \emph{Next} and enter a class name and a package name for your
  service.
\item
  Click \emph{Finish}.
\end{enumerate}

Alternatively, use
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-projects-with-blade-cli}{Blade
CLI} to create the project.

\noindent\hrulefill

\textbf{Note:} The initial release of 7.0's development tools created a
project with an invalid configuration. If your class contains an
\texttt{@ApplicationPath} annotation, you must update the following
files:

\textbf{Your Java Class:}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add the following import:

\begin{verbatim}
import org.osgi.service.jaxrs.whiteboard.JaxrsWhiteboardConstants;
\end{verbatim}
\item
  Remove the \texttt{@ApplicationPath} annotation.
\item
  Modify the \texttt{@Component} annotation so it looks like this:

\begin{verbatim}
@Component(
  property = {
  JaxrsWhiteboardConstants.JAX_RS_APPLICATION_BASE + "=/greetings",
  JaxrsWhiteboardConstants.JAX_RS_NAME + "=Greetings.Rest"
  },
\end{verbatim}

  service = Application.class)
\end{enumerate}

\textbf{build.gradle:}

Add the following dependency:

\begin{verbatim}
     compileOnly group: "org.osgi", name: "org.osgi.service.jaxrs", version: "1.0.0"
\end{verbatim}

\textbf{Files to delete:}

Delete everything under \texttt{src/main/resources/configuration}.

\noindent\hrulefill

The class that's generated contains a working JAX-RS web service. You
can deploy it and use it immediately.

While it's beyond the scope of this article to cover
\href{https://blog.osgi.org/2018/03/osgi-r7-highlights-jax-rs-whiteboard.html}{JAX-RS
Whiteboard} in its entirety, essentially it's JAX-RS unchanged except
for configuration properties in the \texttt{@Component} annotation.
These properties declare two things:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  The endpoint for the service
\item
  The service name as it appears in the OAuth 2.0 configuration
\end{enumerate}

The generated class contains this configuration:

\begin{verbatim}
@Component(
        property = {
            JaxrsWhiteboardConstants.JAX_RS_APPLICATION_BASE + "=/greetings",
            JaxrsWhiteboardConstants.JAX_RS_NAME + "=Greetings.Rest"
        },
        service = Application.class)
\end{verbatim}

This configuration registers the service at this endpoint:

\begin{verbatim}
https://[server-name]:[port]/o/greetings
\end{verbatim}

If you're testing this locally on Tomcat, the URL is

\begin{verbatim}
https://localhost:8080/o/greetings
\end{verbatim}

As you might guess, you don't have access to the service by just calling
the URL above. You must authenticate first, which you'll learn how to do
next.

\subsection{Using OAuth 2.0 to Invoke a JAX-RS Web
Service}\label{using-oauth-2.0-to-invoke-a-jax-rs-web-service}

Your JAX-RS web service requires authorization by default. To enable
this, you must create an
\href{/docs/7-1/deploy/-/knowledge_base/d/oauth-2-0\#creating-an-application}{OAuth
2.0 application} to provide a way to grant access to your service:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Go to the \emph{Control Panel} → \emph{Configuration} → \emph{OAuth2
  Administration} and click the \includegraphics{./images/icon-add.png}
  button to add an application.
\item
  Give your application a descriptive name.
\item
  Choose the Client Profile appropriate for this service. These are
  templates that auto-select the appropriate authorization types or
  ``flows'' from the OAuth 2 standard. For this example choose the
  \emph{Headless Server} profile, which auto-selects the \emph{Client
  Credentials} authorization type.
\item
  Click \emph{Save}.
\end{enumerate}

The form now reappears with two additional generated fields: Client ID
and Client Secret. You'll use these to authenticate to your web service.

To make your service accessible,

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Click the \emph{Scopes} tab.
\item
  You'll see an entry for your deployed \texttt{Greetings.Rest} service.
  Expand it by clicking the arrow.
\item
  Check the box labeled \emph{read data on your behalf}.
\item
  Click \emph{Save}.
\end{enumerate}

\begin{figure}
\centering
\includegraphics{./images/jax-rs-oauth2-scope.png}
\caption{Enable the scope to grant access to the service.}
\end{figure}

For simplicity, the examples below use \href{https://curl.haxx.se}{Curl}
to authenticate. You need the two pieces of information generated for
your application: the Client ID and the Client Secret. For example, say
those fields contain these values:

\textbf{Client ID:} \texttt{id-12e14a84-e558-35a7-cf9a-c64aafc7f}

\textbf{Client Secret:}
\texttt{secret-93f14320-dc39-d67f-9dec-97717b814f}

First, you must request an OAuth token. If you're testing locally, you'd
make a request like this:

\begin{verbatim}
curl http://localhost:8080/o/oauth2/token -d 'grant_type=client_credentials&client_id=id-12e14a84-e558-35a7-cf9a-c64aafc7f&client_secret=secret-93f14320-dc39-d67f-9dec-97717b814f'
\end{verbatim}

The response is JSON:

\begin{verbatim}
{"access_token":"a7f12bef7f2e578cf64bce4085db8f17b6a3c2963f865a65b374e89784bbca5","token_type":"Bearer","expires_in":600,"scope":"GET POST PUT"}
\end{verbatim}

It contains a token, generated for this client. It expires in 600
seconds, and it grants GET, POST, and PUT for this web service.

When you want to call the service, you must supply the token in the HTTP
header, like this:

\begin{verbatim}
curl --header "Authorization: Bearer a7f12bef7f2e578cf64bce4085db8f17b6a3c2963f865a65b374e89784bbca5" http://localhost:8080/o/greetings/morning
\end{verbatim}

With authorization, your web service can be called and responds to the
request:

\begin{verbatim}
Good morning!
\end{verbatim}

Of course, this is only one of the authorization flows for OAuth 2.0. If
you're creating a web-based client whose back-end is a JAX-RS web
service hosted on Liferay DXP, you'd want one of the other flows. See
the \href{/docs/7-1/deploy/-/knowledge_base/d/oauth-2-0}{OAuth 2.0
documentation} for further information. Additionally, OAuth 2.0 assumes
the use of HTTPS for its security: the above URLs are only for local
testing purposes. You certainly would not want to pass OAuth tokens
between clients and servers in the clear. Make sure that in production
your server uses HTTPS.

Great! Now you know how to create, deploy, and invoke JAX-RS web
services on Liferay DXP's platform!

\subsection{Related Topics}\label{related-topics-93}

\href{/docs/7-1/tutorials/-/knowledge_base/t/service-builder-web-services}{Service
Builder Web Services}

\section{JAX-WS}\label{jax-ws}

Liferay supports
\href{https://en.wikipedia.org/wiki/Java_API_for_XML_Web_Services}{JAX-WS}
via the \href{http://cxf.apache.org/}{Apache CXF} implementation. Apps
can publish JAX-WS web services to the CXF endpoints defined in your
Liferay instance. CXF endpoints are effectively context paths the JAX-WS
web services are deployed to and accessible from. To publish any kind of
JAX-WS web service, one or more CXF endpoints must be defined. To access
JAX-WS web services, an \emph{extender} must also be configured in your
Liferay instance. Extenders specify where the services are deployed and
whether they are augmented with handlers, providers, and so on.

\textbf{SOAP Extenders:} Required to publish JAX-WS web services. Each
SOAP extender can deploy the services to one or more CXF endpoints and
can use a set of
\href{https://jax-ws.java.net/articles/handlers_introduction.html}{JAX-WS
handlers} to augment the services.

SOAP extenders are subsystems that track the services the app developer
registers in OSGi (those matching the provided
\href{https://osgi.org/javadoc/r6/core/org/osgi/framework/Filter.html}{OSGi
filters}), and deploy them under the specified CXF endpoints. For
example, if you create the CXF endpoint \texttt{/soap}, you could later
create a SOAP extender for \texttt{/soap} that publishes SOAP services.
Of course, this is only a rough example: you can fine tune things to
your liking.

CXF endpoints and extenders can be created programmatically or with
Liferay's Control Panel. This tutorial shows you how to do both, and
then shows you how to publish JAX-WS web services. The following topics
are covered:

\begin{itemize}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/jax-ws\#configuring-endpoints-and-extenders-with-the-control-panel}{Configuring
  Endpoints and Extenders with the Control Panel}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/jax-ws\#configuring-endpoints-and-extenders-programmatically}{Configuring
  Endpoints and Extenders Programmatically}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/jax-ws\#publishing-jax-ws-web-services}{Publishing
  JAX-WS Web Services}
\end{itemize}

\subsection{Configuring Endpoints and Extenders with the Control
Panel}\label{configuring-endpoints-and-extenders-with-the-control-panel}

Liferay's Control Panel lets administrators configure endpoints and
extenders for JAX-WS web services. Note that you must be an
administrator in your Liferay instance to access the settings here.
First, you'll learn how to create CXF endpoints.

To configure a CXF endpoint with the Control Panel, first go to
\emph{Control Panel} → \emph{Configuration} → \emph{System Settings} →
\emph{Web API}. Then select \emph{CXF Endpoints} from the list. If there
are any existing CXF endpoints, they're shown here. To add a new one,
click the \emph{Add} button. The form that appears lets you configure a
new CXF endpoint by filling out these fields:

\textbf{Context Path:} The path the JAX-WS web services are deployed to
on the Liferay server. For example, if you define the context path
\texttt{/web-services}, any services deployed there are available at
\texttt{http://your-server:your-port/o/web-services}.

\textbf{\texttt{AuthVerifier} properties:} Any properties defined here
are passed as-is to the \texttt{AuthVerifier} filter. See the
\href{/docs/7-1/deploy/-/knowledge_base/d/authentication-verifiers}{\texttt{AuthVerifier}
documentation} for more details.

\textbf{Required Extensions:} CXF normally loads its default extension
classes, but in some cases you can override them to replace the default
behavior. In most cases, you can leave this field blank: overriding
extensions isn't common. By specifying custom extensions here via
\href{https://osgi.org/javadoc/r6/core/org/osgi/framework/Filter.html}{OSGi
filters}, Liferay waits until those extensions are registered in the
OSGi framework before creating the CXF servlet and passing the
extensions to the servlet.

\begin{figure}
\centering
\includegraphics{./images/cxf-endpoint-form.png}
\caption{Fill out this form to create a CXF endpoint.}
\end{figure}

For an app to deploy JAX-WS web services, you must configure a SOAP
extender. To configure a SOAP extender with the Control Panel, first go
to \emph{Control Panel} → \emph{Configuration} → \emph{System Settings}
→ \emph{Web API}. Then select \emph{SOAP Extenders} from the list. If
there are any existing SOAP extenders, they're shown here. To add a new
one, click on the \emph{Add} button. The form that appears lets you
configure a new SOAP extender by filling out these fields:

\textbf{Context paths:} Specify at least one CXF endpoint here. This is
where the services affected by this extender are deployed. In the
preceding CXF endpoint example, this would be \texttt{/web-services}.
Note that you can specify more than one CXF endpoint here.

\textbf{jax.ws.handler.filters:} Here you can specify a set of
\href{https://osgi.org/javadoc/r6/core/org/osgi/framework/Filter.html}{OSGi
filters} that select certain services registered in the OSGi framework.
The selected services should implement JAX-WS handlers and augment the
JAX-WS services specified in the \emph{jax.ws.service.filters} property.
These JAX-WS handlers apply to each service selected in this extender.

\textbf{jax.ws.service.filters:} Here you can specify a set of OSGi
filters that select the services registered in the OSGi framework that
are deployed to the CXF endpoints. These OSGi services must be
\href{https://docs.oracle.com/javaee/7/tutorial/jaxws001.htm}{proper
JAX-WS services}.

\textbf{soap.descriptor.builder:} Leave this option empty to use JAX-WS
annotations to describe the SOAP service. To use a different way to
describe the SOAP service, you can provide an OSGi filter here that
selects an implementation of
\texttt{com.liferay.portal.remote.soap.extender.SoapDescriptorBuilder}.

\begin{figure}
\centering
\includegraphics{./images/soap-extenders-form.png}
\caption{Fill out this form to create a SOAP extender.}
\end{figure}

Next, you'll learn how to create endpoints and extenders
programmatically.

\subsection{Configuring Endpoints and Extenders
Programmatically}\label{configuring-endpoints-and-extenders-programmatically}

To configure endpoints or extenders programmatically, you must use
Liferay's configurator extender. The configurator extender provides a
way for OSGi modules to deploy default configuration values. Modules
that use the configurator extender must provide a
\texttt{ConfigurationPath} header that points to the configuration
files' location inside the module. For example, the following
configuration sets the \texttt{ConfigurationPath} to
\texttt{src/main/resources/configuration}:

\begin{verbatim}
Bundle-Name: Liferay Export Import Service JAX-WS
Bundle-SymbolicName: com.liferay.exportimport.service.jaxws
Bundle-Version: 1.0.0
Liferay-Configuration-Path: /configuration
Include-Resource: configuration=src/main/resources/configuration
Liferay-Releng-Module-Group-Description:
Liferay-Releng-Module-Group-Title: Data Management
\end{verbatim}

Note that Liferay-specific Bnd instructions are prefixed with
\texttt{Liferay} to avoid conflicts.

There are two different configuration types in
\href{https://osgi.org/javadoc/r4v42/org/osgi/service/cm/ConfigurationAdmin.html}{OSGi's
\texttt{ConfigurationAdmin}}: single, and factory. Factory
configurations can have several configuration instances per factory
name. Liferay DXP uses factory configurations. You must provide a
factory configuration's default values in a \texttt{*.properties} file.
In this properties file, use a suffix on the end of the PID (persistent
identifier) and then provide your settings. For example, the following
code uses the \texttt{-staging} suffix on the PID and creates a CXF
endpoint at the context path \texttt{/staging-ws}:

\begin{verbatim}
com.liferay.portal.remote.cxf.common.configuration.CXFEndpointPublisherConfiguration-staging.properties:

contextPath=/staging-ws
\end{verbatim}

As another example, the following code uses the suffix
\texttt{-stagingjaxws} on the PID and creates a SOAP extender at the
context path \texttt{/staging-ws}. This code also includes settings for
the configuration fields \texttt{jaxWsHandlerFilterStrings} and
\texttt{jaxWsServiceFilterStrings}:

\begin{verbatim}
com.liferay.portal.remote.soap.extender.configuration.SoapExtenderConfiguration-stagingjaxws.properties:

contextPaths=/staging-ws
jaxWsHandlerFilterStrings=(staging.jax.ws.handler=true)
jaxWsServiceFilterStrings=(staging.jax.ws.service=true)
\end{verbatim}

You must then use these configuration fields in the configuration class.
For example, the \texttt{SoapExtenderConfiguration} interface below
contains the configuration fields \texttt{contextPaths},
\texttt{jaxWsHandlerFilterStrings}, and
\texttt{jaxWsServiceFilterStrings}:

\begin{verbatim}
@ExtendedObjectClassDefinition(
    category = "foundation", factoryInstanceLabelAttribute = "contextPaths"
)
@Meta.OCD(
    factory = true,
    id = "com.liferay.portal.remote.soap.extender.configuration.SoapExtenderConfiguration",
    localization = "content/Language", name = "soap.extender.configuration.name"
)
public interface SoapExtenderConfiguration {

    @Meta.AD(required = false)
    public String[] contextPaths();

    @Meta.AD(name = "jax.ws.handler.filters", required = false)
    public String[] jaxWsHandlerFilterStrings();

    @Meta.AD(name = "jax.ws.service.filters", required = false)
    public String[] jaxWsServiceFilterStrings();

    @Meta.AD(name = "soap.descriptor.builder", required = false)
    public String soapDescriptorBuilderFilter();

}
\end{verbatim}

Next, you'll learn how to publish JAX-WS web services.

\subsection{Publishing JAX-WS Web
Services}\label{publishing-jax-ws-web-services}

To publish JAX-WS web services via SOAP in a module, annotate the class
and its methods with standard JAX-WS annotations, and then register it
as a service in the OSGi framework. For example, the following class
uses the \texttt{@WebService} annotation for the class and
\texttt{@WebMethod} annotations for its methods. You must also set the
\texttt{jaxws} property to \texttt{true} in the OSGi \texttt{@Component}
annotation:

\begin{verbatim}
import javax.jws.WebMethod;
import javax.jws.WebService;

import org.osgi.service.component.annotations.Component;

@Component(
    immediate = true, property = "jaxws=true", service = Calculator.class
)
@WebService
public class Calculator {

    @WebMethod
    public int divide(int a, int b) {
        return a / b;
    }

    @WebMethod
    public int multiply(int a, int b) {
        return a * b;
    }

    @WebMethod
    public int subtract(int a, int b) {
        return a - b;
    }

    @WebMethod
    public int sum(int a, int b) {
        return a + b;
    }

}
\end{verbatim}

You should also make sure that you include \texttt{org.osgi.core} and
\texttt{org.osgi.service.component.annotations} as dependencies to your
project.

\chapter{Search}\label{search-1}

Liferay stores its information in a database, so why not search the
database directly? Why add the complexity of a search engine? First,
because database table merges are expensive! Documents in a search index
often contain searchable fields from multiple tables in the database.
Traversing the date in this way takes too long.

In addition to the performance problem, search engines provide access to
additional features, like relevance and scoring. By contrast, databases
do not support features like fuzzy searching or relevancy. Moreover,
search engines can apply algorithms such as ``More Like This'' to return
similar content. Search engines also support geolocation, faceting of
search results, and multi-lingual searching.

This section contains information on extending Liferay's search
functionality, enabling your custom entities to be indexed and searched
in Liferay DXP, and configuring the developer-friendly embedded
Elasticsearch server to suit your needs. First, some basic search
concepts.

\section{Basic Search Concepts}\label{basic-search-concepts}

\textbf{Indexing}: During indexing, a document is sent to the search
engine. This document contains a collection of fields of various types
(string, etc.). The search engine processes each field within the
document. For each field, the search engine determines whether it needs
to simply store the field or if it needs to undertake special analysis
(index time analysis). Index time analysis can be configured for each
field (see Mapping Definitions).

For fields requiring analysis, the search engine first tokenizes the
value to obtain individual words or tokens. Following tokenization, the
search engine passes each token through a series of analyzers. Analyzers
perform different functions. Some remove common words or stop words
(e.g., ``the'', ``and'', ``or'') while others perform operations like
lowercasing all characters.

\textbf{Searching}: Searching involves sending a search query and
obtaining results (a.k.a. hits) from the search engine. The search query
may be comprised of both queries and filters (more on this later). Each
query or filter specifies a field to search within and the value to
match against. Upon receiving the search query, the search engine
iterates through each field within the nested queries and filters.
During this process, the engine may perform special analysis prior to
executing the query (search time analysis). Search time analysis can be
configured for each field (see Mapping Definitions).

\section{Mapping Definitions}\label{mapping-definitions}

Search engines are semi-intelligent, automatically deciphering how to
process documents passed to them. However, there are instances where
it's desirable to configure explicitly how to process a field.

\emph{Mappings} control how a search engine processes a given field. For
instance, if a field name ends in ``es\_ES'', we want to process the
field values as Spanish, removing any common Spanish words like ``si''.

In Elasticsearch and Solr, the two supported search engines for Liferay
Portal, mappings are defined in \texttt{liferay-type-mappings.json} and
\texttt{schema.xml}, respectively.

The Elasticsearch mapping JSON file can be seen in the Liferay DXP
\href{https://www.liferay.com/downloads-community}{source code}, in the
\texttt{portal-search-elasticsearch6} module:

\begin{verbatim}
portal-search-elasticsearch6-impl/src/main/resources/META-INF/mappings/liferay-type-mappings.json
\end{verbatim}

The Solr \texttt{schema.xml} can be seen in the
\texttt{portal-search-solr7} module's source code:

\begin{verbatim}
portal-search-solr7-impl/src/main/resources/META-INF/resources/schema.xml
\end{verbatim}

Access the Solr 7 module's source code from the \texttt{liferay-portal}
repository
\href{https://github.com/liferay/liferay-portal/blob/7.1.x/modules/apps/portal-search-solr7/portal-search-solr7-impl/src/main/resources/META-INF/resources/schema.xml}{here}

These are default mapping files that are shipped with the product. You
can further customize these mappings to fit your needs. For example, you
might want to use a special analyzer for a custom inventory number
field.

\section{Liferay Search
Infrastructure}\label{liferay-search-infrastructure}

Search engines already provide native APIs. Why does Liferay provide
search infrastructure to wrap the search engine? Liferay's search
infrastructure does several things:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Index documents with the fields Liferay needs
  (\texttt{entryClassName}, \texttt{entryClassPK},
  \texttt{assetTagNames}, \texttt{assetCategories}, \texttt{companyId},
  \texttt{groupId}, staging status, etc.).
\item
  Apply the right filters to search queries (e.g., for scoping results).
\item
  Apply permission checking on the results.
\item
  Summarizing returned results.
\end{enumerate}

That's just a taste of Liferay's Search Infrastructure. Continue reading
to learn more.

\section{Elasticsearch Logging}\label{elasticsearch-logging}

When you first start Liferay DXP, an embedded Elasticsearch server
starts so that search works out of the box. The embedded search engine
is not suitable for production, but is useful for testing and
development.

In Fix Pack 3 and CE GA2, the Liferay log was slimmed down by removing
INFO level Elasticsearch logs for the embedded Elasticsearch. WARN and
ERROR logs are still displayed. If you miss hearing from Elasticsearch
during startup, you can enable the INFO log level for the embedded
Elasticsearch server.

\noindent\hrulefill

\textbf{Note:} These instructions show you how to adjust the embedded
Elasticsearch server's logs. Logging for Liferay DXP's search
functionality is configurable via the
\href{/docs/7-1/user/-/knowledge_base/u/server-administration}{Log
Levels} screen at Control Panel → Configuration → Server Administration
→ Log Levels tool. Narrow down the list to include only the search
classes and packages by searching for \emph{com.liferay.portal.search}.

To adjust logging for a remote Elasticsearch server, see
\href{https://www.elastic.co/guide/en/elasticsearch/reference/6.1/logging.html}{Elastic's
documentation}.

\noindent\hrulefill

Here's an example log message that \emph{is} displayed by default:

\begin{verbatim}
2018-09-13 16:49:24.442 WARN  [Elasticsearch initialization thread][EmbeddedElasticsearchConnection:315]
\end{verbatim}

Manage the log levels for the \texttt{EmbeddedElasticsearchConnection}
in Server Administration.

Here's an example Elasticsearch log message that \emph{isn't} displayed
by default:

\begin{verbatim}
[2018-09-05T17:25:30,107][WARN ][o.e.d.i.m.MapperService  ] [unmapped_type:string] should be replaced with [unmapped_type:keyword]
\end{verbatim}

To adjust logging for the \texttt{o.e.d.i.m.MapperService} and other
Elasticsearch classes,

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a \texttt{config} folder in
  \texttt{Liferay\ Home/data/elasticsearch6/}.
\item
  Create a \texttt{log4j2.properties} file in the new folder.
\item
  To enable INFO level logging, populate the \texttt{log4j2.properties}
  file with these contents:

\begin{verbatim}
appender.console.layout.pattern=[%d{ISO8601}][%-5p][%-25c{1.}] %marker%m%n
appender.console.layout.type=PatternLayout
appender.console.name=console
appender.console.type=Console
logger.action.level=info
logger.action.name=org.elasticsearch.action
rootLogger.appenderRef.console.ref=console
rootLogger.level=info
status=error
\end{verbatim}

  Read the Elasticsearch
  \href{https://www.elastic.co/guide/en/elasticsearch/reference/6.x/logging.html}{logging
  documentation} for more information.
\item
  Restart the Liferay DXP server or just the embedded Elasticsearch.
\item
  To restart just the embedded Elasticsearch server, create a file
  called

\begin{verbatim}
com.liferay.portal.bundle.blacklist.internal.BundleBlacklistConfiguration.config 
\end{verbatim}

  in \texttt{Liferay\ Home/osgi/configs} directory and populate it with

\begin{verbatim}
blacklistBundleSymbolicNames="com.liferay.portal.search.elasticsearch6.impl"
\end{verbatim}
\item
  Save the \texttt{.config} file and the bundle is stopped. Once you see
  the \texttt{{[}STOPPED{]}} message in the logs, restart the bundle by
  commenting the line out and re-saving the file:

\begin{verbatim}
#blacklistBundleSymbolicNames="com.liferay.portal.search.elasticsearch6.impl"
\end{verbatim}
\end{enumerate}

Once this is accomplished, the embedded Elasticsearch server displays
Elasticsearch logs at the INFO level and above.

Two common Elasticsearch logs can be configured further: the Slow Log
and the JVM's Garbage Collection log.

\subsection{Configuring Slow Log}\label{configuring-slow-log}

Read about Elasticsearch's Slow Log
\href{https://www.elastic.co/guide/en/elasticsearch/reference/6.1/index-modules-slowlog.html}{here}.

Configure the Slow Log for the embedded Elasticsearch server in the
Elasticsearch 6 entry in System Settings. Add these settings to the
Additional Index Configurations property:

\begin{verbatim}
index.indexing.slowlog.threshold.index.debug: 2s
index.indexing.slowlog.threshold.index.info: 5s
index.indexing.slowlog.threshold.index.trace: 500ms
index.indexing.slowlog.threshold.index.warn: 10s

index.search.slowlog.threshold.fetch.debug: 500ms
index.search.slowlog.threshold.fetch.info: 800ms
index.search.slowlog.threshold.fetch.trace: 200ms
index.search.slowlog.threshold.fetch.warn: 1s

index.search.slowlog.threshold.query.debug: 2s
index.search.slowlog.threshold.query.info: 5s
index.search.slowlog.threshold.query.trace: 500ms
index.search.slowlog.threshold.query.warn: 10s
\end{verbatim}

These are example values. Adjust as needed.

\subsection{Configuring JVM Garbage Collection
Logging}\label{configuring-jvm-garbage-collection-logging}

As with the Slow Log configuration, Elasticsearch's JVM Garbage
Collection logging is adjustable in the Elasticsearch 6 entry in System
Settings. Add these settings to the Additional Configurations property:

\begin{verbatim}
monitor.jvm.gc.enabled: true
monitor.jvm.gc.overhead.debug: 40
monitor.jvm.gc.overhead.info: 70
monitor.jvm.gc.overhead.warn: 90
\end{verbatim}

These are example values. Adjust as needed.

\section{Indexing Framework}\label{indexing-framework}

Unless you're searching for model entities using database queries (not
recommended in most cases), each asset in Liferay DXP must be indexed in
the search engine. The indexing code is specific to each asset, as the
asset's developers know what fields to index and what filters to apply
to the search query.

In past versions of Liferay DXP, when your asset required indexing, you
would implement a new Indexer by extending
\texttt{com.liferay.portal.kernel.search.BaseIndexer\textless{}T\textgreater{}}.
7.0 introduces a new pattern that relies on
\href{https://stackoverflow.com/questions/2399544/difference-between-inheritance-and-composition}{composition
instead of inheritance}. If you want to use the old approach, feel free
to extend \texttt{BaseIndexer}. It's still supported.

\subsection{Search and Indexing
Overview}\label{search-and-indexing-overview}

Liferay's original Search API was built around the Lucene search and
indexing library. To this day, familiarity with Lucene will jump-start
your understanding of Liferay's Search API. However, starting with the
7.0 version of Liferay DXP, the Search API is being reworked, so that
the parts closely tied to Lucene are becoming more generic.
Elasticsearch support was added (in addition to Solr), and most of the
newer searching and indexing APIs aim to leverage/map Elasticsearch
APIs. This means that in many cases (for example the \texttt{Query}
types) there is a one-to-one mapping between the Liferay and
Elasticsearch APIs.

In addition to the Elasticsearch centered APIs, Liferay's Search
Infrastructure includes additional APIs serving these purposes:

\begin{itemize}
\tightlist
\item
  Indexed documents include the fields needed by Liferay DXP (e.g.,
  \texttt{entryClassName}, \texttt{entryClassPK},
  \texttt{assetTagNames}, \texttt{assetCategories}, \texttt{companyId},
  \texttt{groupId}, staging status).
\item
  It ensures the scope of returned search results is appropriate by
  applying the right filters to search requests.
\item
  It provides permission checking and hit summaries to display in the
  search portlet.
\end{itemize}

To understand how search and indexing code makes your custom models
seamlessly searchable, you must know how to influence each portion of
the search and indexing cycle.

\subsubsection{Indexing}\label{indexing}

Model entities store data fields in the database. For example,
Guestbooks store a \emph{name} field. During the cycle's Indexing step,
you prepare the model entity to be searchable by defining the model's
fields that are sent to the search engine, later used during a search.

\textbf{To control how model entity fields are indexed in search engine
documents,}

\href{https://github.com/liferay/liferay-portal/blob/7.1.1-ga2/modules/apps/portal-search/portal-search-spi/src/main/java/com/liferay/portal/search/spi/model/index/contributor/ModelDocumentContributor.java}{\texttt{ModelDocumentContributor}}
classes specify which database fields are indexed in the model entity's
search engine document. This class's \texttt{contribute} method is
called each time the \texttt{add} and \texttt{update} methods in the
entity's service layer are called.

\href{https://github.com/liferay/liferay-portal/blob/7.1.1-ga2/modules/apps/portal-search/portal-search-spi/src/main/java/com/liferay/portal/search/spi/model/index/contributor/ModelIndexerWriterContributor.java}{\texttt{ModelIndexerWriterContributor}}
classes configure the re-indexing and batch re-indexing behavior for the
model entity. This class's method is called when a re-index is triggered
from the Search administrative application found in Control Panel →
Configuration → Search, or when a CRUD operation is made on the entity,
\emph{if} the \texttt{modelIndexed} method is implemented in your
contributor.

\texttt{DocumentContributor} classes (without any
\texttt{indexer.class.name} component property or type parameter)
contribute certain fields to every index document, regardless of what
base entity is being indexed. For example, the
\href{https://github.com/liferay/liferay-portal/blob/7.1.1-ga2/modules/apps/portal-search/portal-search/src/main/java/com/liferay/portal/search/internal/contributor/document/GroupedModelDocumentContributor.java}{\texttt{GroupedModelDocumentContributor}}
contributes the \texttt{GROUP\_ID} and \texttt{SCOPE\_GROUP\_ID} fields
for all documents with a backing entity that's also a
\texttt{GroupedModel}.

\subsubsection{Searching}\label{searching}

Searches start with a user entering keywords into a search bar. The
entered keywords are processed by the back-end search infrastructure,
transformed into a \emph{query} the search engine can understand, and
used to match against each search document's fields.

\textbf{To control the way model entity documents are searched,}

\href{https://github.com/liferay/liferay-portal/blob/7.1.1-ga2/modules/apps/portal-search/portal-search-spi/src/main/java/com/liferay/portal/search/spi/model/query/contributor/KeywordQueryContributor.java}{\texttt{KeywordQueryContributor}}
classes contribute clauses to the ongoing search query. This is called
at search time and ensures that all the fields you indexed are also the
ones searched. For example, if you index fields with the Site locale
appended to them (\texttt{title\_en\_us}, for example), you want the
search query to include the same locale when the document is searched.
If the search query contains another locale (like
\texttt{title\_es\_ES}) or searches the plain field (\texttt{title}),
inaccurate results are returned.

To contribute query clauses to every search, regardless of what base
entity is being searched, implement a \texttt{KeywordQueryContributor}
class registered without an \texttt{indexer.class.name} component
property. For example, see
\href{https://github.com/liferay/liferay-portal/blob/7.1.0-ga1/modules/apps/portal-search/portal-search/src/main/java/com/liferay/portal/search/internal/contributor/query/AlwaysPresentFieldsKeywordQueryContributor.java}{\texttt{AlwaysPresentFieldsKeywordQueryContributor}}.

\href{https://github.com/liferay/liferay-portal/blob/7.1.1-ga2/modules/apps/portal-search/portal-search-spi/src/main/java/com/liferay/portal/search/spi/model/query/contributor/ModelPreFilterContributor.java}{\texttt{ModelPreFilterContributor}s}
control how search results are filtered before they're returned from the
search engine. For example, adding the workflow status to the query
ensures that an entity in the trash isn't returned in the search
results.

To contribute Filter clauses to every search, regardless of what base
entity is being searched, implement a
\texttt{QueryPreFilterContributor}. \texttt{QueryPreFilterContributor}
is constructed only once under the root filter during a search. For
example, see
\href{https://github.com/liferay/liferay-portal/blob/7.1.0-ga1/modules/apps/portal-search/portal-search/src/main/java/com/liferay/portal/search/internal/contributor/query/AssetCategoryTitlesKeywordQueryContributor.java}{\texttt{AssetCategoryTitlesKeywordQueryContributor}}.

What's the difference between \texttt{QueryPreFilterContributor} and
\texttt{ModelPreFilterContributor}? \texttt{QueryPreFilterContributor}
is constructed only once under the root filter during a search, while
\texttt{ModelPreFilterContributor} is constructed once per model entity,
and added under each specific entity's subfilter.

\subsubsection{Returning Results}\label{returning-results}

When a model entity's indexed search document is obtained during a
search request, it's converted into a summary of the model entity.

\textbf{To control the result summaries for model entity documents,}

\href{https://github.com/liferay/liferay-portal/blob/7.1.1-ga2/modules/apps/portal-search/portal-search-spi/src/main/java/com/liferay/portal/search/spi/model/result/contributor/ModelSummaryContributor.java}{\texttt{ModelSummaryContributor}}
classes get the \texttt{Summary} object created for each search
document, so you can manipulate it by adding specific fields or setting
the length of the displayed content.

\href{https://github.com/liferay/liferay-portal/blob/7.1.1-ga2/modules/apps/portal-search/portal-search-spi/src/main/java/com/liferay/portal/search/spi/model/result/contributor/ModelVisibilityContributor.java}{\texttt{ModelVisibilityContributor}}
classes control the visibility of model entities that can be attached to
other asset types (for example, File Entries can be attached to Wiki
Pages), in the search context.

One important step must occur to make sure the above classes are
discovered by the search framework.

\subsubsection{Search Service
Registration}\label{search-service-registration}

\textbf{To register model entities with Liferay's search framework,}

\texttt{SearchRegistrar}s use the
\href{https://github.com/liferay/liferay-portal/tree/7.1.1-ga2/modules/apps/portal-search/portal-search-spi/src/main/java/com/liferay/portal/search/spi/model/registrar}{search
framework's registry} to define certain things about your model entity's
\href{https://github.com/liferay/liferay-portal/blob/7.1.1-ga2/modules/apps/portal-search/portal-search-spi/src/main/java/com/liferay/portal/search/spi/model/registrar/ModelSearchDefinition.java}{\texttt{ModelSearchDefinition}}:
which fields are used by default to retrieve documents from the search
engine, and which optional search services are registered for your
entity. Registration occurs as soon as the Component is activated
(during portal startup or deployment of the bundle).

\subsection{\texorpdfstring{Mapping the Composite Search and Indexing
Framework to \texttt{Indexer}/\texttt{BaseIndexer}
Code}{Mapping the Composite Search and Indexing Framework to Indexer/BaseIndexer Code}}\label{mapping-the-composite-search-and-indexing-framework-to-indexerbaseindexer-code}

If you're used to the old way of indexing custom entities (extending
\texttt{BaseIndexer}, the abstract implementation of \texttt{Indexer}),
the table below provides a quick overview about how the methods of the
\texttt{Indexer} interface were decomposed into several new classes and
methods.

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.3857}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.3857}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.2286}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Indexer/BaseIndexer method
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Composite Indexer Equivalent
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Example
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Class Constructor & \texttt{SearchRegistrar} &
\href{/docs/7-1/tutorials/-/knowledge_base/t/registering-guestbooks-with-the-search-framework}{\texttt{GuestbookSearchRegistrar}} \\
\texttt{setDefaultSelectedFieldNames} &
\texttt{SearchRegistrar.activate} &
\href{/docs/7-1/tutorials/-/knowledge_base/t/registering-guestbooks-with-the-search-framework}{\texttt{GuestbookSearchRegistrar}} \\
\texttt{setDefaultSelectedLocalizedFieldNames} &
\texttt{SearchRegistrar.activate} &
\href{/docs/7-1/tutorials/-/knowledge_base/t/registering-guestbooks-with-the-search-framework}{\texttt{GuestbookSearchRegistrar}} \\
\texttt{setPermissionAware} & \texttt{ModelResourcePermissionRegistrar}
&
\href{/docs/7-1/tutorials/-/knowledge_base/t/registering-your-defined-permissions\#registering-your-entities-with-the-permissions-service}{\texttt{GuestbookModelResourcePermissionRegistrar}} \\
\texttt{setFilterSearch} & \texttt{ModelResourcePermissionRegistrar} &
\href{/docs/7-1/tutorials/-/knowledge_base/t/registering-your-defined-permissions\#registering-your-entities-with-the-permissions-service}{\texttt{GuestbookModelResourcePermissionRegistrar}} \\
\texttt{getDocument}/\texttt{doGetDocument} &
\texttt{ModelDocumentContributor} &
\href{/docs/7-1/tutorials/-/knowledge_base/t/indexing-guestbooks\#implementing-modeldocumentcontributor}{\texttt{GuestbookModelDocumentContributor}} \\
\texttt{reindex}/\texttt{doReindex} &
\texttt{ModelIndexerWriterContributor} &
\href{/docs/7-1/tutorials/-/knowledge_base/t/indexing-guestbooks\#implementing-modelindexerwritercontributor}{\texttt{GuestbookModelIndexerWriterContributor}} \\
\texttt{addRelatedEntryFields} & \texttt{RelatedEntryIndexer} &
\href{https://github.com/liferay/liferay-portal/blob/7.1.1-ga2/modules/apps/document-library/document-library-service/src/main/java/com/liferay/document/library/internal/search/DLFileEntryRelatedEntryIndexer.java}{\texttt{DLFileEntryRelatedEntryIndexer}} \\
\texttt{postProcessContextBooleanFilter}/\texttt{PostProcessContextQuery}
& \texttt{ModelPreFilterContributor} &
\href{https://github.com/liferay/liferay-portal/blob/7.1.1-ga2/modules/apps/document-library/document-library-service/src/main/java/com/liferay/document/library/internal/search/DLFileEntryModelPreFilterContributor.java}{\texttt{DLFileEntryModelPreFilterContributor}} \\
\texttt{postProcessSearchQuery} & \texttt{KeywordQueryContributor} &
\href{/docs/7-1/tutorials/-/knowledge_base/t/querying-for-guestbook-documents\#implementing-keywordquerycontributor}{\texttt{GuestbookKeywordQueryContributor}} \\
\texttt{getFullQuery} & \texttt{SearchContextContributor} &
\href{https://github.com/liferay/liferay-portal/blob/7.1.1-ga2/modules/apps/document-library/document-library-service/src/main/java/com/liferay/document/library/internal/search/DLFileEntryModelSearchContextContributor.java}{\texttt{DLFileEntryModelSearchContextContributor}} \\
\texttt{isVisible}/\texttt{isVisibleRelatedEntry} &
\texttt{ModelVisibilityContributor} &
\href{https://github.com/liferay/liferay-portal/blob/7.1.1-ga2/modules/apps/document-library/document-library-service/src/main/java/com/liferay/document/library/internal/search/DLFileEntryModelVisibilityContributor.java}{\texttt{DLFileEntryModelVisibilityContributor}} \\
\texttt{getSummary}/\texttt{createSummary}/\texttt{doGetSummary} &
\texttt{ModelSummaryContributor} &
\href{/docs/7-1/tutorials/-/knowledge_base/t/generating-results-summaries}{\texttt{GuestbookModelSummaryContributor}} \\
\texttt{Indexer.search}/\texttt{searchCount} & No change &
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-a-search-results-jsp-for-the-guestbook-portlet}{Guestbook
\texttt{view\_search.jsp}} \\
\texttt{Indexer.delete}/\texttt{doDelete} & No change &
\href{https://github.com/liferay/liferay-portal/blob/7.1.1-ga2/modules/apps/message-boards/message-boards-service/src/main/java/com/liferay/message/boards/service/impl/MBMessageLocalServiceImpl.java\#L687}{\texttt{MBMessageLocalServiceImpl.deleteDiscussionMessages}} \\
\end{longtable}

In addition, you can index \texttt{ExpandoBridge} attributes. This was
previously accomplished in \texttt{BaseIndexer}'s
\texttt{getBaseModelDocument}. Now you implement an
\texttt{ExpandoBridgeRetriever}. See
\href{https://github.com/liferay/liferay-portal/blob/7.1.1-ga2/modules/apps/document-library/document-library-service/src/main/java/com/liferay/document/library/internal/search/DLFileEntryExpandoBridgeRetriever.java}{\texttt{DLFileEntryExpandoBridgeRetriever}}
for an example implementation.

\subsection{Permissions Aware Searching and
Indexing}\label{permissions-aware-searching-and-indexing}

In previous versions of Liferay DXP, search was only \emph{permissions
aware} (indexed with the entity's permissions and searched with those
permissions intact) if the application developer specified this line in
the \texttt{Indexer} class's constructor:

\begin{verbatim}
setPermissionAware(true);
\end{verbatim}

Now, search is permissions aware by default \emph{if the new permissions
approach}, as described in
\href{/docs/7-1/tutorials/-/knowledge_base/t/defining-application-permissions}{these
tutorials}, is implemented for an application.

\subsection{Annotating Service Methods to Trigger
Indexing}\label{annotating-service-methods-to-trigger-indexing}

Having entities translated into database entities \emph{and} search
engine documents means that there's a possibility for a state mismatch
between the database and search engine. For example, when a Blogs entry
is added, updated or removed from the database, corresponding changes
must be made in the search engine. To do this, intervention must be made
into the service layer. For Service Builder entities, this occurs in the
\texttt{LocalServiceImpl} classes. There's an annotation that simplifies
this: \texttt{@Indexable}. It takes a \texttt{type} property that can
have two values: \texttt{REINDEX} or \texttt{DELETE}. Commonly, a
\texttt{deleteEntity} method in the service layer is annotated like
this:

\begin{verbatim}
@Indexable(type = IndexableType.DELETE)
@Override
@SystemEvent(type = SystemEventConstants.TYPE_DELETE)
public BlogsEntry deleteEntry(BlogsEntry entry) throws PortalException {
    ...
}
\end{verbatim}

The \texttt{@Indexable} annotation is executed by Liferay's Spring
infrastructure, so if you have a method with that annotation, you must
call it using a service instance variable with the spring wrapped logic.
The reference is available by default in Service Builder generated
\texttt{*LocalServiceImpl} classes because of this declaration in the
parent \texttt{*LocalServiceBaseImpl}:

\begin{verbatim}
@BeanReference(type = BlogsEntryLocalService.class)
    protected BlogsEntryLocalService blogsEntryLocalService;
\end{verbatim}

This means that in the \texttt{*LocalServiceImpl}, you must not call

\begin{verbatim}
this.deleteEntry(...) 
\end{verbatim}

The annotation won't be executed and you'll be left with a state
mismatch between the search engine document and the database column.
Instead follow the pattern in Liferay DXP's code, using the service
instance variable to call service methods:

\begin{verbatim}
blogsEntryLocalService.deleteEntry(entry);
\end{verbatim}

For step-by-step instructions on indexing model entities, visit the
\href{/docs/7-1/tutorials/-/knowledge_base/t/search-and-indexing}{Search
and Indexing section of the Developing a Web Application tutorials}.

\chapter{Asset Framework}\label{asset-framework}

The asset framework powers the core Liferay features so you can add them
to your application. For example, if you build an event management
application that displays a list of upcoming events, you can use the
asset framework to let users add tags, categories, or comments to make
entries more self-descriptive.

As background, the term \emph{asset} refers to any type of content in
the portal. This could be text, a file, a URL, an image, documents, blog
entries, bookmarks, wiki pages, or anything you create in your
applications.

The asset framework tutorials assume that you've used Liferay's Service
Builder to generate your persistence layer, that you've implemented
permissions on the entities that you're persisting, and that you've
enabled them for search and indexing. You can learn more about Liferay's
Service Builder and how to use it in the
\href{/docs/7-1/tutorials/-/knowledge_base/t/service-builder}{Service
Builder} tutorial section.

The tutorials that follow in this section explore how to leverage the
asset framework's various features. Here are some features that you'll
give your users as you implement them in your app:

\begin{itemize}
\tightlist
\item
  Extensively render your assets.
\item
  Associate tags to custom content types. Users can create and assign
  new tags or use existing tags.
\item
  Associate categories to custom content types.
\item
  Manage tags from the Control Panel. Administrators can even merge
  tags.
\item
  Manage categories from the Control Panel. This includes the ability to
  create category hierarchies.
\item
  Relate assets to one another.
\end{itemize}

Before diving head first into the tutorials, you must implement a way to
let the framework know whenever any of your custom content entries is
added, updated, or deleted. The next tutorial covers that. From that
point onward, each tutorial shows you how to leverage a particular asset
framework feature in your UI. It's time to start your asset framework
training!

\section{Related Topics}\label{related-topics-94}

\href{/docs/7-1/tutorials/-/knowledge_base/t/what-is-service-builder}{What
is Service Builder}

\href{/docs/7-1/tutorials/-/knowledge_base/t/service-builder-persistence}{Service
Builder Persistence}

\href{/docs/7-1/tutorials/-/knowledge_base/t/configurable-applications}{Configurable
Applications}

\section{Adding, Updating, and Deleting
Assets}\label{adding-updating-and-deleting-assets}

To use Liferay's asset framework with an entity, you must inform the
asset framework about each entity instance you create, modify, and
delete. In this sense, it's similar to informing
\href{/docs/7-1/tutorials/-/knowledge_base/t/defining-application-permissions}{Liferay's
permissions framework} about a new resource. All you have to do is
invoke a method of the asset framework that associates an
\texttt{AssetEntry} with the entity so Liferay can keep track of the
entity as an asset. When it's time to update the entity, you update the
asset at the same time.

To leverage assets, you must also implement indexers for your portlet's
entities. Liferay's asset framework uses indexers to manage assets.

This tutorial shows you how to enable assets for your custom entities
and implement indexes for them. It's time to get started!

\subsection{Preparing Your Project for the Asset
Framework}\label{preparing-your-project-for-the-asset-framework}

In your project's \texttt{service.xml} file, add an asset entry entity
reference for your custom entity. Add the following \texttt{reference}
tag before your custom entity's closing
\texttt{\textless{}/entity\textgreater{}} tag.

\begin{verbatim}
<reference package-path="com.liferay.portlet.asset" entity="AssetEntry" />
\end{verbatim}

Then
\href{/docs/7-1/tutorials/-/knowledge_base/t/running-service-builder}{run
Service Builder.}

Now you're ready to implement adding and updating assets!

\subsection{Adding and Updating
Assets}\label{adding-and-updating-assets}

Your \texttt{-LocalServiceImpl} Java class inherits from its parent base
class an \texttt{AssetEntryLocalService} instance; it's assigned to the
variable \texttt{assetEntryLocalService}. To add your custom entity as a
Liferay asset, you must invoke the \texttt{assetEntryLocalService}'s
\texttt{updateEntry} method.

Here's what the
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-impl/com/liferay/portlet/asset/service/impl/AssetEntryLocalServiceImpl.html\#updateEntry-long-long-java.util.Date-java.util.Date-java.lang.String-long-java.lang.String-long-long:A-java.lang.String:A-boolean-boolean-java.util.Date-java.util.Date-java.util.Date-java.util.Date-java.lang.String-java.lang.String-java.lang.String-java.lang.String-java.lang.String-java.lang.String-int-int-java.lang.Double-}{\texttt{updateEntry}}
method's signature looks like:

\begin{verbatim}
AssetEntry updateEntry(
    long userId, long groupId, Date createDate, Date modifiedDate,
    String className, long classPK, String classUuid, long classTypeId,
    long[] categoryIds, String[] tagNames, boolean listable,
    boolean visible, Date startDate, Date endDate, Date publishDate,
    Date expirationDate, String mimeType, String title,
    String description, String summary, String url, String layoutUuid,
    int height, int width, Double priority)
throws PortalException
\end{verbatim}

Here are descriptions of each of the \texttt{updateEntry} method's
parameters:

\begin{itemize}
\tightlist
\item
  \texttt{userId}: identifies the user updating the content.
\item
  \texttt{groupId}: identifies the scope of the created content. If your
  content doesn't support scopes (extremely rare), pass \texttt{0} as
  the value.
\item
  \texttt{createDate}: the date the entity was created.
\item
  \texttt{modifiedDate}: the date of this change to the entity.
\item
  \texttt{className}: identifies the entity's class. The recommended
  convention is to use the name of the Java class that represents your
  content type. For example, you can pass in the value returned from
  \texttt{{[}YourClassName{]}.class.getName()}.
\item
  \texttt{classPK}: identifies the specific entity instance,
  distinguishing it from other instances of the same type. It's usually
  the primary key of the table where the entity is stored.
\item
  \texttt{classUuid}: serves as a secondary identifier that's guaranteed
  to be universally unique. It correlates entity instances across
  scopes. It's especially useful if your content is exported and
  imported across separate portals.
\item
  \texttt{classTypeId}: identifies the particular variation of this
  class, if it has any variations. Otherwise, use \texttt{0}.
\item
  \texttt{categoryIds}: represent the categories selected for the
  entity. The asset framework stores them for you.
\item
  \texttt{tagNames}: represent the tags selected for the entity. The
  asset framework stores them for you.
\item
  \texttt{listable}: specifies whether the entity can be shown in
  dynamic lists of content (such as asset publisher configured
  dynamically).
\item
  \texttt{visible}: specifies whether the entity is approved.
\item
  \texttt{startDate}: the entity's publish date. You can use it to
  specify when an Asset Publisher should show the entity's content.
\item
  \texttt{endDate}: the date the entity is taken down. You can use it to
  specify when an Asset Publisher should stop showing the entity's
  content.
\item
  \texttt{publishDate}: the date the entity will start to be shown.
\item
  \texttt{expirationDate}: the date the entity will no longer be shown.
\item
  \texttt{mimetype}: the Multi-Purpose Internet Mail Extensions type,
  such as
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/util/ContentTypes.html\#TEXT_HTML}{ContentTypes.TEXT\_HTML},
  used for the content.
\item
  \texttt{title}: the entity's name.
\item
  \texttt{description}: a \texttt{String}-based textual description of
  the entity.
\item
  \texttt{summary}: a shortened or truncated sample of the entity's
  content.
\item
  \texttt{url}: a URL to optionally associate with the entity.
\item
  \texttt{layoutUuid}: the universally unique ID of the layout of the
  entry's default display page.
\item
  \texttt{height}: this can be set to \texttt{0}.
\item
  \texttt{width}: this can be set to \texttt{0}.
\item
  \texttt{priority}: specifies how the entity is ranked among peer
  entity instances. Low numbers take priority over higher numbers.
\end{itemize}

The following code from Liferay's Wiki application's
\href{https://github.com/liferay/liferay-portal/blob/master/modules/apps/wiki/wiki-service/src/main/java/com/liferay/wiki/service/impl/WikiPageLocalServiceImpl.java}{\texttt{WikiPageLocalServiceImpl}}
Java class demonstrates invoking the \texttt{updateEntry} method on the
wiki page entity called \texttt{WikiPage}. In your \texttt{add-} method,
you could invoke \texttt{updateEntry} after adding your entity's
resources. Likewise, in your \texttt{update-} method, you could invoke
\texttt{updateEntry} after calling the \texttt{super.update-} method.
The code below is called in the \texttt{WikiPageLocalServiceImpl}
class's \texttt{updateStatus(...)} method.

\begin{verbatim}
AssetEntry assetEntry = assetEntryLocalService.updateEntry(
    userId, page.getGroupId(), page.getCreateDate(),
    page.getModifiedDate(), WikiPage.class.getName(),
    page.getResourcePrimKey(), page.getUuid(), 0,
    assetCategoryIds, assetTagNames, true, true, null, null,
    page.getCreateDate(), null, ContentTypes.TEXT_HTML,
    page.getTitle(), null, null, null, null, 0, 0, null);

Indexer<WikiPage> indexer = IndexerRegistryUtil.nullSafeGetIndexer(
    WikiPage.class);

indexer.reindex(page);
\end{verbatim}

Immediately after invoking the \texttt{updateEntry} method, you must
update the respective asset and index the entity instance. The above
code calls the indexer to index (or re-index, if updating) the entity.
That's all there is to it.

\noindent\hrulefill

\textbf{Tip:} The current user's ID and the scope group ID are commonly
made available in service context parameters. If the service context you
use contains them, then you can access them in calls like these:

long userId = serviceContext.getUserId(); long groupId =
serviceContext.getScopeGroupId();

\noindent\hrulefill

Next, you'll learn what's needed to delete an entity that's associated
with an asset.

\subsection{Deleting Assets}\label{deleting-assets}

When deleting your entities, you should delete the associated assets and
indexes at the same time. This cleans up stored asset and index
information, which keeps the Asset Publisher from showing information
for the entities you've deleted.

In your \texttt{-LocalServiceImpl} Java class, open your
\texttt{delete-} method. After the code that deletes the entity's
resource, delete the entity instance's asset entry and index.

Here's some code which deletes an asset entry and an index associated
with a portlet's entity.

\begin{verbatim}
assetEntryLocalService.deleteEntry(
    ENTITY.class.getName(), assetEntry.getEntityId());

Indexer<ENTITY> indexer = IndexerRegistryUtil.nullSafeGetIndexer(ENTITY.class);
indexer.delete(assetEntry);
\end{verbatim}

In your \texttt{-LocalServiceImpl} class, you can write similar code.
Replace the \emph{ENTITY} class name and variable with your entity's
name.

\noindent\hrulefill

\textbf{Important:} For Liferay's Asset Publisher application to show
your entity, the entity must have an Asset Renderer.

Note also that an Asset Renderer is how you show a user the components
of your entity in the Asset Publisher. On deploying your portlet with
asset, indexer, and asset rendering implementations in place, an Asset
Publisher can show your custom entities!

\noindent\hrulefill

\begin{figure}
\centering
\includegraphics{./images/basic-asset-in-asset-publisher.png}
\caption{It can be useful to show custom entities, like this wiki page
entity, in a JSP or in an Asset Publisher.}
\end{figure}

Great! Now you know how to add, update, and delete assets in your apps!

\subsection{Related Topics}\label{related-topics-95}

\href{/docs/7-1/tutorials/-/knowledge_base/t/relating-assets}{Relating
Assets}

\href{/docs/7-1/tutorials/-/knowledge_base/t/what-is-service-builder}{What
is Service Builder?}

\section{Implementing Asset Categorization and
Tagging}\label{implementing-asset-categorization-and-tagging}

In this tutorial, you'll enable tags and categories entities in the UI
through a set of JSP tags. Before beginning, your entities should be
\href{/docs/7-1/tutorials/-/knowledge_base/t/adding-updating-and-deleting-assets}{asset-enabled}
and you should have asset renderers enabled for them.

\begin{figure}
\centering
\includegraphics{./images/asset-fw-categories-and-tags-options.png}
\caption{Adding category and tag input options lets authors aggregate
and label custom entities.}
\end{figure}

Now it's time to get started!

\subsection{Adding Tags and
Categories}\label{adding-tags-and-categories}

You can use the following tags in the JSPs you provide for
adding/editing custom entities. Here's what the tags look like in the
\href{https://github.com/liferay/liferay-portal/blob/master/modules/apps/blogs/blogs-web/src/main/resources/META-INF/resources/blogs/edit_entry.jsp}{edit\_entry.jsp}
for the Blogs portlet:

\begin{verbatim}
<liferay-ui:asset-categories-error />
<liferay-ui:asset-tags-error />
...
<aui:fieldset-group markupView="lexicon">
    ...
    <aui:fieldset collapsed="<%= true %>" collapsible="<%= true %>" label="categorization">
        <liferay-asset:asset-categories-selector name="categories" type="assetCategories" />

        <liferay-asset:asset-tags-selector name="tags" type="assetTags" />
    </aui:fieldset>
    ...
</aui:fieldset-group>
\end{verbatim}

The \texttt{liferay-asset:asset-categories-selector} and
\texttt{liferay-asset:asset-tags-selector} tags generate form controls
that let users browse/select categories for the entity, browse/select
tags, and/or create new tags to associate with the entity.

The \texttt{liferay-ui:asset-categories-error} and
\texttt{liferay-ui:asset-tags-error} tags show messages for errors
occurring during the asset category or tag input process. The
\texttt{aui:fieldset} tag uses a container that lets users hide or show
the category and tag input options.

For styling purposes, the \texttt{aui:fieldset-group} tag is given the
\texttt{lexicon} markup view.

\subsection{Displaying Tags and
Categories}\label{displaying-tags-and-categories}

Tags and categories should be displayed with the content of the asset.
Here's how to display the tags and categories:

\begin{verbatim}
<p><liferay-ui:message key="categories" />:</p>

<div class="entry-categories">
    <liferay-ui:asset-categories-summary
        className="<%= BlogsEntry.class.getName() %>"
        classPK="<%= entry.getEntryId() %>"
        portletURL="<%= renderResponse.createRenderURL() %>"
    />
</div>

...

<div class="entry-tags">
    <p><liferay-ui:message key="tags" />:</p>

    <liferay-ui:asset-tags-summary
        className="<%= BlogsEntry.class.getName() %>"
        classPK="<%= entry.getEntryId() %>"
        portletURL="<%= renderResponse.createRenderURL() %>"
    />
</div>
\end{verbatim}

The \texttt{portletURL} parameter is used for both tags and categories.
Each tag that uses this parameter becomes a link containing the
\texttt{portletURL} \emph{and} \texttt{tag} or \texttt{categoryId}
parameter value. To implement this, you must implement the look-up
functionality in your portlet code. Do this by reading the values of
those two parameters and using \texttt{AssetEntryService} to query the
database for entries based on the specified tag or category.

Deploy your changes and add/edit a custom entity in your UI. Your form
shows the categorization and tag input options in a panel that the user
can hide/show.

Great! Now you know how to make category and tag input options available
to your app's content authors.

\subsection{Related Topics}\label{related-topics-96}

\href{/docs/7-1/tutorials/-/knowledge_base/t/relating-assets}{Relating
Assets}

\href{/docs/7-1/tutorials/-/knowledge_base/t/adding-updating-and-deleting-assets}{Adding,
Updating, and Deleting Assets}

\href{/docs/7-1/tutorials/-/knowledge_base/t/what-is-service-builder}{What
is Service Builder?}

\section{Relating Assets}\label{relating-assets}

Relating assets connects individual pieces of content across your site
or portal. This helps users discover related content, particularly when
there's an abundance of other available content. For example, assets
related to a web content article appear alongside that entry in the
Asset Publisher application.

\begin{figure}
\centering
\includegraphics{./images/asset-related-content-asset-publisher.png}
\caption{You and your users can find it helpful to relate assets to
entities, such as this blogs entry.}
\end{figure}

Now you'll learn how to provide a way for authors to relate content.
This tutorial assumes that you've
\href{/docs/7-1/tutorials/-/knowledge_base/t/adding-updating-and-deleting-assets}{Adding,
Updating, and Deleting Assets} your application. If you've already done
this, go ahead and begin relating your assets!

\subsection{Relating Assets in the Service
Layer}\label{relating-assets-in-the-service-layer}

First, you must make some modifications to your portlet's service layer.
You must implement persisting your entity's asset relationships.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In your portlet's \texttt{service.xml}, put the following line of code
  below any finder method elements and then
  \href{/docs/7-1/tutorials/-/knowledge_base/t/running-service-builder}{run}
  Service Builder:

\begin{verbatim}
<reference package-path="com.liferay.portlet.asset" entity="AssetLink" />
\end{verbatim}
\item
  Modify the \texttt{add-}, \texttt{delete-}, and \texttt{update-}
  methods in your \texttt{-LocalServiceImpl} to persist the asset
  relationships. You'll use your \texttt{-LocalServiceImpl}'s
  \texttt{assetLinkLocalService} instance variable to execute
  persistence actions.

  For example, consider the Wiki application. When you update wiki
  assets and statuses, both methods utilize the \texttt{updateLinks} via
  your instance variable \texttt{assetLinkLocalService}. Here's the
  \texttt{updateLinks} invocation in the Wiki application's
  \texttt{WikiPageLocalServiceImpl.updateStatus(...)} method:

\begin{verbatim}
assetLinkLocalService.updateLinks(
    userId, assetEntry.getEntryId(), assetLinkEntryIds,
    AssetLinkConstants.TYPE_RELATED);
\end{verbatim}

  To call the \texttt{updateLinks} method, you must pass in the current
  user's ID, the asset entry's ID, the asset link entries' IDs, and the
  link type. Invoke this method after creating the asset entry. If you
  assign to an \texttt{AssetEntry} variable (e.g., one called
  \texttt{assetEntry}) the value returned from invoking
  \texttt{assetEntryLocalService.updateEntry}, you can get the asset
  entry's ID for updating its asset links. Lastly, in order to specify
  the link type parameter, make sure to import
  \texttt{com.liferay.portlet.asset.model.AssetLinkConstants}.
\item
  In your \texttt{-LocalServiceImpl} class' \texttt{delete-} method, you
  must delete the asset's relationships before deleting the asset. For
  example, you could delete your existing asset link relationships by
  using the following code:

\begin{verbatim}
AssetEntry assetEntry = assetEntryLocalService.fetchEntry(
    ENTITY.class.getName(), ENTITYId);

assetLinkLocalService.deleteLinks(assetEntry.getEntryId());
\end{verbatim}
\end{enumerate}

Make sure to replace the \emph{ENTITY} place holders for your custom
\texttt{-delete} method.

Super! Now your portlet's service layer can handle related assets. Even
so, there's still nothing in your portlet's UI that lets your users
relate assets. You'll take care of that in the next step.

\subsection{Relating Assets in the UI}\label{relating-assets-in-the-ui}

The UI for linking assets should be in the JSP where users create and
edit your entity. This way only content creators can relate other assets
to the entity. Related assets are implemented in the JSP by using the
Liferay UI tag \texttt{liferay-ui:input-asset-links} inside a
collapsible panel. This code is placed inside the \texttt{aui:fieldset}
tags of the JSP.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add the \texttt{liferay-ui:input-asset-links} tag to your form. Here's
  how it's added in the Blogs application:

\begin{verbatim}
<aui:fieldset collapsed="<%= true %>" collapsible="<%= true %>" label="related-assets">
    <liferay-ui:input-asset-links
        className="<%= BlogsEntry.class.getName() %>"
        classPK="<%= entryId %>"
    />
\end{verbatim}

  The following screenshot shows the Related Assets menu for an
  application. Note that it is contained in a collapsible panel titled
  Related Assets.

  \begin{figure}
  \centering
  \includegraphics{./images/related-assets-select-menu.png}
  \caption{Your portlet's entity is now available in the Related Assets
  \emph{Select} menu.}
  \end{figure}
\item
  Unfortunately, the Related Assets menu shows your entity's fully
  qualified class name. To replace it with a simplified name for your
  entity, add a language key with the fully qualified class name for the
  key and the name you want for the value. Put the language key in file
  \texttt{docroot/WEB-INF/src/content/Language.properties} in your
  portlet. You can refer to the
  \href{/docs/7-1/tutorials/-/knowledge_base/t/overriding-language-keys}{Overriding
  Language Keys} tutorial for more documentation on using language
  properties.

  Upon redeploying your portlet, the value you assigned to the fully
  qualified class name in your \texttt{Language.properties} file shows
  in the Related Assets menu.
\end{enumerate}

Awesome! Now content creators and editors can relate the assets of your
application. The next thing you need to do is reveal any such related
assets to the rest of your application's users. After all, you don't
want to give everyone edit access just so they can view related assets!

\subsection{Showing Related Assets}\label{showing-related-assets}

You can show related assets in your application's view of that entity
or, if you've implemented asset rendering for your custom entity, you
can show related assets in the full content view of your entity for
users to view in an Asset Publisher portlet.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  You must get the \texttt{AssetEntry} object associated with your
  entity:

\begin{verbatim}
<%
long insultId = ParamUtil.getLong(renderRequest, "insultId");
Insult ins = InsultLocalServiceUtil.getInsult(insultId);
AssetEntry assetEntry = AssetEntryLocalServiceUtil.getEntry(Insult.class.getName(), ins.getInsultId());
%>
\end{verbatim}
\item
  Use the \texttt{liferay-ui:asset-links} tag to show the entity's
  related assets. For this tag, you should retrieve the entity's class
  name and the variable holding your instance object, so you can return
  its ID. The example code below uses the example entity class
  \texttt{Insult} and an instance object variable called \texttt{ins}:

\begin{verbatim}
<liferay-ui:asset-links
    assetEntryId="<%=(assetEntry != null) ? assetEntry.getEntryId() : 0%>"
    className="<%=Insult.class.getName()%>"
    classPK="<%=ins.getInsultId()%>" />
\end{verbatim}
\end{enumerate}

Great! Now you have the JSP that lets your users view related assets.
Related assets, if you've created any yet, should be visible near the
bottom of the page.

Excellent! Now you know how to implement related assets in your apps.

\subsection{Related Topics}\label{related-topics-97}

\href{/docs/7-1/tutorials/-/knowledge_base/t/adding-updating-and-deleting-assets}{Adding,
Updating, and Deleting Assets}

\href{/docs/7-1/tutorials/-/knowledge_base/t/what-is-service-builder}{What
is Service Builder?}

\href{/docs/7-1/user/-/knowledge_base/u/defining-content-relationships}{Defining
Content Relationships}

\section{Implementing Asset Priority}\label{implementing-asset-priority}

The \href{/docs/7-1/user/-/knowledge_base/u/publishing-assets}{Asset
Publisher} lets you order assets by priority. For this to work, however,
users must be able to set the asset's priority when creating or editing
the asset. For example, when creating or editing web content, users can
assign a priority in the Metadata section's Priority field.

\begin{figure}
\centering
\includegraphics{./images/web-content-categorization.png}
\caption{The Priority field lets users set an asset's priority.}
\end{figure}

This field isn't enabled when you create an asset. You must manually add
support for it. Fortunately, this is very straightforward. This tutorial
shows you how. Onwards!

\subsection{Add the Priority Field to Your
JSP}\label{add-the-priority-field-to-your-jsp}

In the JSP for adding and editing your asset, add the following input
field that lets users set the asset's priority. This example also
validates the input to make sure the value the user sets is a number
higher than zero:

\begin{verbatim}
<aui:input label="priority" name="assetPriority" type="text" value="<%= priority %>">
    <aui:validator name="number" />

    <aui:validator name="min">[0]</aui:validator>
</aui:input>
\end{verbatim}

That's it for the view layer! Now when users create or edit your asset,
they can enter its priority. Next, you'll learn how to use that value in
your service layer.

\subsection{Using the Priority Value in Your Service
Layer}\label{using-the-priority-value-in-your-service-layer}

To make the priority value functional, you must retrieve it from the
view and add it to the asset in your database. The priority value is
automatically available in your service layer via the
\texttt{ServiceContext} variable \texttt{serviceContext}. Retrieve it
with \texttt{serviceContext.getAssetPriority()}, and then pass it as the
last argument to the \texttt{assetEntryLocalService.updateEntry} call in
your \texttt{-LocalServiceImpl}. You can see an example of this in
\href{https://github.com/liferay/liferay-portal/blob/master/modules/apps/blogs/blogs-service/src/main/java/com/liferay/blogs/service/impl/BlogsEntryLocalServiceImpl.java}{the
\texttt{BlogsEntryLocalServiceImpl} class} of Liferay DXP's Blogs app.
The \texttt{updateAsset} method takes a \texttt{priority} argument,
which it passes as the last argument to its
\texttt{assetEntryLocalService.updateEntry} call:

\begin{verbatim}
@Override
public void updateAsset(
        long userId, BlogsEntry entry, long[] assetCategoryIds,
        String[] assetTagNames, long[] assetLinkEntryIds, Double priority)
    throws PortalException {

    ...

    AssetEntry assetEntry = assetEntryLocalService.updateEntry(
        userId, entry.getGroupId(), entry.getCreateDate(),
        entry.getModifiedDate(), BlogsEntry.class.getName(),
        entry.getEntryId(), entry.getUuid(), 0, assetCategoryIds,
        assetTagNames, true, visible, null, null, null, null,
        ContentTypes.TEXT_HTML, entry.getTitle(), entry.getDescription(),
        summary, null, null, 0, 0, priority);

    ...
}
\end{verbatim}

The \texttt{BlogsEntryLocalServiceImpl} class calls this
\texttt{updateAsset} method when adding or updating a blog entry. Note
that \texttt{serviceContext.getAssetPriority()} retrieves the priority:

\begin{verbatim}
updateAsset(
        userId, entry, serviceContext.getAssetCategoryIds(),
        serviceContext.getAssetTagNames(),
        serviceContext.getAssetLinkEntryIds(),
        serviceContext.getAssetPriority());
\end{verbatim}

Sweet! Now you know how to enable priorities for your app's assets.

\subsection{Related Topics}\label{related-topics-98}

\href{/docs/7-1/tutorials/-/knowledge_base/t/adding-updating-and-deleting-assets}{Adding,
Updating, and Deleting Assets}

\href{/docs/7-1/tutorials/-/knowledge_base/t/implementing-asset-categorization-and-tagging}{Implementing
Asset Categorization and Tagging}

\href{/docs/7-1/tutorials/-/knowledge_base/t/relating-assets}{Relating
Assets}

\href{/docs/7-1/tutorials/-/knowledge_base/t/rendering-an-asset}{Rendering
an Asset}

\href{/docs/7-1/user/-/knowledge_base/u/publishing-assets}{Publishing
Assets}

\chapter{Rendering an Asset}\label{rendering-an-asset}

Before you create a way to render your asset, make sure it's added to
the asset framework by following the
{[}\href{/docs/7-1/tutorials/-/knowledge_base/t/adding-updating-and-deleting-assets}{Adding,
Updating, and Deleting Assets} tutorial. Once you add your asset to the
framework, you can render the asset using the Asset Publisher
application. The default render, however, only displays the asset's
title and description text. Anything else requires additional coding.
For instance, you might want these additional things:

\begin{itemize}
\tightlist
\item
  An edit feature for modifying an asset.
\item
  View an asset in its original context (e.g., a blog in the Blogs
  application; a post in the Message Boards application).
\item
  Embed images, videos, and audio.
\item
  Restrict access to users who do not have permissions to interact with
  the asset.
\item
  Allow users to comment on the asset.
\end{itemize}

You can dictate your asset's rendering capabilities by providing the
\emph{Asset Renderer} framework. There are two things you must do to get
your asset renderer functioning properly for your asset:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create an asset renderer for your custom asset.
\item
  Create an asset renderer factory to create an instance of the asset
  renderer for each asset entity.
\end{enumerate}

\begin{figure}
\centering
\includegraphics{./images/asset-renderer-diagram.png}
\caption{The asset renderer factory creates an asset renderer for each
asset instance.}
\end{figure}

You'll learn how to create an asset renderer and an asset renderer
factory by studying a Liferay asset that already uses both by default:
Blogs. The Blogs application offers many different ways to access and
render a blogs asset. You'll learn how a blogs asset provides an edit
feature, comment section, original context viewing (i.e., viewing an
asset from the Blogs application), workflow, and more. You'll also learn
how it uses JSP templates to display various blog views. The Blogs
application is an extensive example of how an asset renderer can be
customized to fit your needs.

If you want to create an asset and make it do more than display its
title and description, read on!

\section{Prerequisites for Asset Enabling and
Application}\label{prerequisites-for-asset-enabling-and-application}

To asset-enable your application, you need two things:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  The application must store asset data. Applications that store a data
  model meet this requirement.
\item
  The application must contain at least one non-instanceable portlet.
  \texttt{Edit} links for the asset cannot be generated without a
  non-instanceable portlet.
\end{enumerate}

Some applications may consist of only one non-instanceable portlet,
while others may consist of a both instanceable and non-instanceable
portlets. If your application does not currently include a
non-instanceable portlet, adding a configuration interface through a
panel app both enhances the usability of the application, and meets the
requirement for adding a non-instanceable portlet to the application.
See our tutorial on
\href{/knowledge_base/7-1/customizing-the-product-menu\#adding-custom-panel-apps}{Adding
Custom Panel Apps} to learn how to add one.

Now you're ready to create an Asset Renderer.

\section{Creating an Asset Renderer}\label{creating-an-asset-renderer}

In this tutorial, you'll learn how to create an \texttt{Asset\ Renderer}
and associate your JSP templates with it, along with configuring several
other options.

To learn how an asset renderer is created, you'll create the
pre-existing
\href{https://github.com/liferay/liferay-portal/blob/7.1.3-ga4/modules/apps/blogs/blogs-web/src/main/java/com/liferay/blogs/web/asset/BlogsEntryAssetRenderer.java}{\texttt{BlogsEntryAssetRenderer}}
class, which configures the asset renderer framework for the Blogs
application.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a new package in your existing project for your asset-related
  classes. For instance, the \texttt{BlogsEntryAssetRenderer} class
  resides in the \texttt{com.liferay.blogs.web} module's
  \texttt{com.liferay.blogs.web.asset} package.
\item
  Create your \texttt{-AssetEntry} class for your application in the new
  \texttt{-.asset} package and have it implement the
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/asset/kernel/model/AssetEntry.html}{\texttt{AssetEntry}}
  interface. Consider the \texttt{BlogsEntryAssetRenderer} class as an
  example:

\begin{verbatim}
public class BlogsEntryAssetRenderer
    extends BaseJSPAssetRenderer<BlogsEntry> implements TrashRenderer {
\end{verbatim}

  The \texttt{BlogsEntryAssetRenderer} class extends the
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/asset/kernel/model/BaseJSPAssetRenderer.html}{\texttt{BaseJSPAssetRenderer}},
  which is an extension class intended for those who plan on using JSP
  templates to generate their asset's HTML. The
  \texttt{BaseJSPAssetRenderer} class implements the
  \texttt{AssetRenderer} interface. You'll notice the asset renderer is
  also implementing the
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/trash/TrashRenderer.html}{\texttt{TrashRenderer}}
  interface. This is a common practice for many applications, so they
  can use Liferay DXP's Recycle Bin.
\item
  Define the asset renderer class's constructor, which typically sets
  the asset object to use in the asset renderer class.

\begin{verbatim}
public BlogsEntryAssetRenderer(
    BlogsEntry entry, ResourceBundleLoader resourceBundleLoader) {

    _entry = entry;
    _resourceBundleLoader = resourceBundleLoader;
}
\end{verbatim}

  The \texttt{BlogsEntryAssetRenderer} also sets the resource bundle
  loader, which loads the language keys for a module. You can learn more
  about the resource bundle loader in the
  \href{/docs/7-0/tutorials/-/knowledge_base/t/overriding-language-keys}{Overriding
  Language Keys} tutorial.

  Also, make sure to define the \texttt{\_entry} and
  \texttt{\_resourceBundleLoader} fields in the class:

\begin{verbatim}
private final BlogsEntry _entry;
private final ResourceBundleLoader _resourceBundleLoader;
\end{verbatim}
\item
  Now that your class declaration and constructor are defined for the
  blogs asset renderer, you must begin connecting your asset renderer to
  your asset. The following getter methods accomplish this:

\begin{verbatim}
@Override
public BlogsEntry getAssetObject() {
    return _entry;
}

@Override
public String getClassName() {
    return BlogsEntry.class.getName();
}

@Override
public long getClassPK() {
    return _entry.getEntryId();
}

@Override
public long getGroupId() {
    return _entry.getGroupId();
}

@Override
public String getType() {
    return BlogsEntryAssetRendererFactory.TYPE;
}

@Override
public String getUuid() {
    return _entry.getUuid();
}
\end{verbatim}

  The \texttt{getAssetObject()} method sets the \texttt{BlogsEntry} that
  was set in the constructor as your asset to track. Likewise, the
  \texttt{getType()} method references the blogs asset renderer factory
  for the type of asset your asset renderer renders. Of course, the
  asset renderer type is \texttt{blog}, which you'll set in the factory
  later.
\item
  Your asset renderer must link to the portlet that owns the entity. In
  the case of a blogs asset, its portlet ID should be linked to the
  Blogs application.

\begin{verbatim}
@Override
public String getPortletId() {
    AssetRendererFactory<BlogsEntry> assetRendererFactory =
        getAssetRendererFactory();

    return assetRendererFactory.getPortletId();
}
\end{verbatim}

  The \texttt{getPortletId()} method instantiates an asset renderer
  factory for a \texttt{BlogsEntry} and retrieves the portlet ID for the
  portlet used to display blogs entries.
\item
  If you're interested in enabling workflow for your asset, add the
  following method similar to what was done for the Blogs application:

\begin{verbatim}
@Override
public int getStatus() {
    return _entry.getStatus();
}
\end{verbatim}

  This method retrieves the workflow status for the asset.
\item
  Another popular feature many developers want for their asset is to
  comment on it. This is enabled for the Blogs application with the
  following method:

\begin{verbatim}
@Override
public String getDiscussionPath() {
    if (PropsValues.BLOGS_ENTRY_COMMENTS_ENABLED) {
        return "edit_entry_discussion";
    }
    else {
        return null;
    }
}
\end{verbatim}

  A comments section is an available option if it returns a non-null
  value. For the comments section to display for your asset, you must
  enable it in the Asset Publisher's \emph{Options}
  (\includegraphics{./images/icon-app-options.png}) →
  \emph{Configuration} → \emph{Setup} → \emph{Display Settings} section.
\item
  At a minimum, you should create a title and summary for your asset.
  Here's how the \texttt{BlogsEntryAssetRenderer} does it:

\begin{verbatim}
@Override
public String getSummary(
    PortletRequest portletRequest, PortletResponse portletResponse) {

    int abstractLength = AssetUtil.ASSET_ENTRY_ABSTRACT_LENGTH;

    if (portletRequest != null) {
        abstractLength = GetterUtil.getInteger(
            portletRequest.getAttribute(
                WebKeys.ASSET_ENTRY_ABSTRACT_LENGTH),
            AssetUtil.ASSET_ENTRY_ABSTRACT_LENGTH);
    }

    String summary = _entry.getDescription();

    if (Validator.isNull(summary)) {
        summary = HtmlUtil.stripHtml(
            StringUtil.shorten(_entry.getContent(), abstractLength));
    }

    return summary;
}

@Override
public String getTitle(Locale locale) {
    ResourceBundle resourceBundle =
        _resourceBundleLoader.loadResourceBundle(
            LanguageUtil.getLanguageId(locale));

    return BlogsEntryUtil.getDisplayTitle(resourceBundle, _entry);
}
\end{verbatim}

  These two methods return information about your asset, so the asset
  publisher can display it. The title and summary can be anything.

  The \texttt{getSummary(...)} method for Blogs returns the abstract
  description for a blog asset. If the abstract description does not
  exist, the content of the blog is used as an abstract. You'll learn
  more about abstracts and other content specifications later.

  The \texttt{getTitle(...)} method for Blogs uses the resource bundle
  loader you configured in the constructor to load your module's
  resource bundle and return the display title for your asset.
\item
  If you want to provide a unique URL for your asset, you can specify a
  URL title. A URL title is the URL used to access your asset directly
  (e.g., localhost:8080/-/this-is-my-blog-asset). You can do this by
  providing the following method:

\begin{verbatim}
@Override
public String getUrlTitle() {
    return _entry.getUrlTitle();
}
\end{verbatim}
\item
  Insert the \texttt{isPrintable()} method, which enables the Asset
  Publisher's printing capability for your asset.

\begin{verbatim}
@Override
public boolean isPrintable() {
    return true;
}
\end{verbatim}

  This displays a Print icon when your asset is displayed in the Asset
  Publisher. For the icon to appear, you must enable it in the Asset
  Publisher's \emph{Options} → \emph{Configuration} → \emph{Setup} →
  \emph{Display Settings} section.

  \begin{figure}
  \centering
  \includegraphics{./images/asset-publisher-printing.png}
  \caption{Enable printing in the Asset Publisher to display the Print
  icon for your asset.}
  \end{figure}
\item
  If your asset is protected by permissions, you can set permissions for
  the asset via the asset renderer. See the logic below for an example
  used in the \texttt{BlogsEntryAssetRenderer} class:

\begin{verbatim}
@Override
public long getUserId() {
    return _entry.getUserId();
}

@Override
public String getUserName() {
    return _entry.getUserName();
}

public boolean hasDeletePermission(PermissionChecker permissionChecker) {
    return BlogsEntryPermission.contains(
        permissionChecker, _entry, ActionKeys.DELETE);
}

@Override
public boolean hasEditPermission(PermissionChecker permissionChecker) {
    return BlogsEntryPermission.contains(
        permissionChecker, _entry, ActionKeys.UPDATE);
}

@Override
public boolean hasViewPermission(PermissionChecker permissionChecker) {
    return BlogsEntryPermission.contains(
        permissionChecker, _entry, ActionKeys.VIEW);
}
\end{verbatim}

  Before you can check if a user has permission to view your asset, you
  must use the \texttt{getUserId()} and \texttt{getUserName()} to
  retrieve the entry's user ID and username, respectively. Then there
  are three boolean permission methods that check if the user can view,
  edit, or delete your blogs entry. These permissions are for specific
  entity instances. Global permissions for blog entries are implemented
  in the factory, which you'll do later.
\end{enumerate}

Awesome! You've learned how to set up the blogs asset renderer to

\begin{itemize}
\tightlist
\item
  connect to an asset
\item
  connect to the asset's portlet
\item
  use workflow management
\item
  use a comments section
\item
  retrieve the asset's title and summary
\item
  generate the asset's unique URL
\item
  display a print icon
\item
  check permissions for the asset
\end{itemize}

Now you need to create the templates to render the HTML. The
\texttt{BlogsEntryAssetRenderer} is configured to use JSP templates to
generate HTML for the Asset Publisher. You'll learn more about how to do
this next.

\section{Configuring JSP Templates for an Asset
Renderer}\label{configuring-jsp-templates-for-an-asset-renderer}

An asset can be displayed in several different ways in the Asset
Publisher. There are three templates to implement provided by the
\texttt{AssetRenderer} interface:

\begin{itemize}
\tightlist
\item
  \texttt{abstract}
\item
  \texttt{full\_content}
\item
  \texttt{preview}
\end{itemize}

Besides these supported templates, you can also create JSPs for buttons
you'd like to provide for direct access and manipulation of the asset.
For example,

\begin{itemize}
\tightlist
\item
  Edit
\item
  View
\item
  View in Context
\end{itemize}

The \texttt{BlogsEntryAssetRenderer} customizes the
\texttt{AssetRenderer}'s provided JSP templates and adds a few other
features using JSPs. You'll inspect how the blogs asset renderer is put
together to satisfy JSP template development requirements.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add the \texttt{getJspPath(...)} method to your asset renderer. This
  method should return the path to your JSP, which is rendered inside
  the Asset Publisher. This is how the \texttt{BlogsEntryAssetRenderer}
  uses this method:

\begin{verbatim}
@Override
public String getJspPath(HttpServletRequest request, String template) {
    if (template.equals(TEMPLATE_ABSTRACT) ||
        template.equals(TEMPLATE_FULL_CONTENT)) {

        return "/blogs/asset/" + template + ".jsp";
    }
    else {
        return null;
    }
}
\end{verbatim}

  Blogs assets provide \texttt{abstract.jsp} and
  \texttt{full\_content.jsp} templates. This means that a blogs asset
  can render a blog's abstract description or the blog's full content in
  the Asset Publisher. Those templates are located in the
  \texttt{com.liferay.blogs.web} module's
  \texttt{src/main/resources/META-INF/resources/blogs/asset} folder. You
  could create a similar folder for your JSP templates used for this
  method. The other template provided by the \texttt{AssetRenderer}
  interface, \texttt{preview.jsp}, is not customized by the blogs asset
  renderer, so its default template is implemented.

  You must create a link to display the full content of the asset.
  You'll do this later.
\item
  Now that you've added the path to your JSP, you must include that JSP.
  Since the \texttt{BlogsEntryAssetRenderer} class extends the
  \texttt{BaseJSPAssetRenderer}, it already has an \texttt{include(...)}
  method to render a specific JSP. You must override this method to set
  an attribute in the request to use in the blog's views:

\begin{verbatim}
@Override
public boolean include(
        HttpServletRequest request, HttpServletResponse response,
        String template)
    throws Exception {

    request.setAttribute(WebKeys.BLOGS_ENTRY, _entry);

    return super.include(request, response, template);
}
\end{verbatim}

  The attribute includes the blogs entry object. Adding the blog object
  this way is not mandatory; you could obtain the blog entry directly
  from the view. Using the \texttt{include(...)} method, however,
  follows the best practice for MVC portlets.

  \begin{figure}
  \centering
  \includegraphics{./images/blogs-asset-views.png}
  \caption{The abstract and full content views are rendererd differently
  for blogs.}
  \end{figure}
\end{enumerate}

Terrific! You've learned how to apply JSPs supported by the Asset
Publisher for your asset. That's not all you can do with JSP templates,
however! The asset renderer framework provides several other methods
that let you render convenient buttons for your asset.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Blogs assets provide an Edit button that lets you edit the asset.
  Provide this by adding the following method to the
  \texttt{BlogsEntryAssetRenderer} class:

\begin{verbatim}
@Override
public PortletURL getURLEdit(
        LiferayPortletRequest liferayPortletRequest,
        LiferayPortletResponse liferayPortletResponse)
    throws Exception {

    Group group = GroupLocalServiceUtil.fetchGroup(_entry.getGroupId());

    PortletURL portletURL = PortalUtil.getControlPanelPortletURL(
        liferayPortletRequest, group, BlogsPortletKeys.BLOGS, 0, 0,
        PortletRequest.RENDER_PHASE);

    portletURL.setParameter("mvcRenderCommandName", "/blogs/edit_entry");
    portletURL.setParameter("entryId", String.valueOf(_entry.getEntryId()));

    return portletURL;
}
\end{verbatim}

  The Asset Publisher loads the blogs asset using the Blogs application.
  Then the \texttt{edit\_entry.jsp} template generates the HTML for an
  editing UI. Once the necessary edits are made to the asset, it can be
  saved from the Asset Publisher. Pretty cool, right?
\item
  You can specify how to view your asset by providing methods similar to
  the methods outlined below in the \texttt{BlogsEntryAssetRenderer}
  class:

\begin{verbatim}
@Override
public String getURLView(
        LiferayPortletResponse liferayPortletResponse,
        WindowState windowState)
    throws Exception {

    AssetRendererFactory<BlogsEntry> assetRendererFactory =
        getAssetRendererFactory();

    PortletURL portletURL = assetRendererFactory.getURLView(
        liferayPortletResponse, windowState);

    portletURL.setParameter("mvcRenderCommandName", "/blogs/view_entry");
    portletURL.setParameter("entryId", String.valueOf(_entry.getEntryId()));
    portletURL.setWindowState(windowState);

    return portletURL.toString();
}

@Override
public String getURLViewInContext(
    LiferayPortletRequest liferayPortletRequest,
    LiferayPortletResponse liferayPortletResponse,
    String noSuchEntryRedirect) {

    return getURLViewInContext(
        liferayPortletRequest, noSuchEntryRedirect, "/blogs/find_entry",
        "entryId", _entry.getEntryId());
}
\end{verbatim}

  The \texttt{getURLView(...)} method generates a URL that displays the
  full content of the asset in the Asset Publisher. This is assigned to
  the clickable asset name. The \texttt{getURLViewInContext(...)} method
  provides a similar URL assigned to the asset name, but the URL
  redirects to the original context of the asset (e.g., viewing a blogs
  asset in the Blogs application). Deciding which view to render is
  configurable by navigating to the Asset Publisher's \emph{Options} →
  \emph{Configuration} → \emph{Setup} → \emph{Display Settings} section
  and choosing between \emph{Show Full Content} and \emph{View in
  Context} for the Asset Link Behavior drop-down menu.
\end{enumerate}

The Blogs application provides \texttt{abstract} and
\texttt{full\_content} JSP templates that override the ones provided by
the \texttt{AssetRenderer} interface. The third template,
\texttt{preview}, could also be customized. You can view the default
\texttt{preview.jsp} template rendered in the \emph{Add} →
\emph{Content} menu.

\begin{figure}
\centering
\includegraphics{./images/preview-template-asset-renderer.png}
\caption{The \texttt{preview} template displays a preview of the asset
in the Content section of the Add menu.}
\end{figure}

You've learned all about implementing the \texttt{AssetRenderer}'s
provided templates and customizing them to fit your needs. Next, you'll
put your asset renderer into action by creating a factory.

\section{Creating a Factory for the Asset
Renderer}\label{creating-a-factory-for-the-asset-renderer}

You've successfully created an asset renderer, but you must create a
factory class to generate asset renderers for each asset instance. For
example, the blogs asset renderer factory instantiates
\texttt{BlogsEntryAssetRenderer} for each blogs asset displayed in an
Asset Publisher.

You'll continue the blogs asset renderer example by creating the blogs
asset renderer factory.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create an \texttt{-AssetRenderFactory} class in the same folder as its
  asset renderer class. For blogs, the
  \href{https://github.com/liferay/liferay-portal/blob/7.1.3-ga4/modules/apps/blogs/blogs-web/src/main/java/com/liferay/blogs/web/asset/BlogsEntryAssetRendererFactory.java}{\texttt{BlogsEntryAssetRendererFactory}}
  class resides in the \texttt{com.liferay.blogs.web} module's
  \texttt{com.liferay.blogs.web.asset} package. The factory class should
  extend the \texttt{BaseAssetRendererFactory} class and the asset type
  should be specified as its parameter. You can see how this was done in
  the \texttt{BlogsEntryAssetRendererFactory} class below

\begin{verbatim}
public class BlogsEntryAssetRendererFactory
    extends BaseAssetRendererFactory<BlogsEntry> {
\end{verbatim}
\item
  Create an \texttt{@Component} annotation section above the class
  declaration. This annotation is responsible for registering the
  factory instance for the asset.

\begin{verbatim}
@Component(
    immediate = true,
    property = {"javax.portlet.name=" + BlogsPortletKeys.BLOGS},
    service = AssetRendererFactory.class
)
public class BlogsEntryAssetRendererFactory
    extends BaseAssetRendererFactory<BlogsEntry> {
\end{verbatim}

  There are a few annotation elements you should set:

  \begin{itemize}
  \tightlist
  \item
    The \texttt{immediate} element directs the factory to start in
    Liferay DXP when its module starts.
  \item
    The \texttt{property} element sets the portlet that is associated
    with the asset. The Blogs portlet is specified, since this is the
    Blogs asset renderer factory.
  \item
    The \texttt{service} element should point to the
    \texttt{AssetRendererFactory.class} interface.
  \end{itemize}
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** In previous versions of Liferay DXP, you had to register the asset
 renderer factory in a portlet's `liferay-portlet.xml` file. The registration
 process is now completed automatically by OSGi using the `@Component`
 annotation.
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\item
  Create a constructor for the factory class that presets private
  attributes of the factory.

\begin{verbatim}
public BlogsEntryAssetRendererFactory() {
    setClassName(BlogsEntry.class.getName());
    setCategorizable(true);
    setLinkable(true);
    setPortletId(BlogsPortletKeys.BLOGS);
    setSearchable(true);
    setSelectable(true);
}
\end{verbatim}

  \begin{itemize}
  \tightlist
  \item
    \emph{linkable}: other assets can select blogs assets as their
    related assets.
  \item
    \emph{categorizable}: blogs can be used to delimit the scope of a
    vocabulary from the Categories Administration.
  \item
    \emph{searchable}: blogs can be found when searching for assets.
  \item
    \emph{selectable}: blogs can be selected when choosing assets to
    display in the Asset Publisher.
  \end{itemize}

  Setting the class name and portlet ID links the asset renderer factory
  to the entity.
\item
  Create the asset renderer for your asset. This is done by calling its
  constructor.

\begin{verbatim}
@Override
public AssetRenderer<BlogsEntry> getAssetRenderer(long classPK, int type)
    throws PortalException {

    BlogsEntry entry = _blogsEntryLocalService.getEntry(classPK);

    BlogsEntryAssetRenderer blogsEntryAssetRenderer =
        new BlogsEntryAssetRenderer(entry, _resourceBundleLoader);

    blogsEntryAssetRenderer.setAssetRendererType(type);
    blogsEntryAssetRenderer.setServletContext(_servletContext);

    return blogsEntryAssetRenderer;
}
\end{verbatim}

  For blogs, the asset is retrieved by calling the Blogs application's
  local service. Then the asset renderer is instantiated using the blogs
  asset and resource bundle loader. Next, the type and servlet context
  is set for the asset renderer. Finally, the configured asset renderer
  is returned.

  There are a few variables in the \texttt{getAssetRenderer(...)} method
  you must create. You'll set those variables and learn what they're
  doing next.

  \begin{enumerate}
  \def\labelenumii{\alph{enumii}.}
  \item
    You must get the entry by calling the Blogs application's local
    service. You can instantiate this service by creating a private
    field and setting it using a setter method:

    @Reference(unbind = ``-'') protected void setBlogsEntryLocalService(
    BlogsEntryLocalService blogsEntryLocalService) \{

\begin{verbatim}
 _blogsEntryLocalService = blogsEntryLocalService;
\end{verbatim}

    \}

    private BlogsEntryLocalService \_blogsEntryLocalService;
  \end{enumerate}

  The setter method is annotated with the \texttt{@Reference} tag. Visit
  the
  \href{/docs/7-0/tutorials/-/knowledge_base/t/invoking-local-services}{Invoking
  Local Services} tutorial for more information.

  \begin{enumerate}
  \def\labelenumii{\alph{enumii}.}
  \setcounter{enumii}{1}
  \item
    You must specify the resource bundle loader since it was specified
    in the \texttt{BlogsEntryAssetRenderer}'s constructor:

    @Reference( target =
    ``(bundle.symbolic.name=com.liferay.blogs.web)'', unbind = ``-'' )
    public void setResourceBundleLoader( ResourceBundleLoader
    resourceBundleLoader) \{

\begin{verbatim}
 _resourceBundleLoader = resourceBundleLoader;
\end{verbatim}

    \}

    private ResourceBundleLoader \_resourceBundleLoader;
  \end{enumerate}

  Make sure the \texttt{osgi.web.symbolicname} in the \texttt{target}
  property of the \texttt{@Reference} annotation is set to the same
  value as the \texttt{Bundle-SymbolicName} defined in the
  \texttt{bnd.bnd} file of the module the factory resides in.

  \begin{enumerate}
  \def\labelenumii{\alph{enumii}.}
  \setcounter{enumii}{2}
  \item
    The asset renderer \texttt{type} integer is set for the asset
    renderer, but why an integer? Liferay DXP needs to differentiate
    when it should display the latest \emph{approved} version of the
    asset, or the latest version, even if it's unapproved (e.g.,
    unapproved versions would be displayed for reviewers of the asset in
    a workflow). For these situations, the asset renderer factory should
    receive either

    \begin{itemize}
    \tightlist
    \item
      \texttt{0} for the latest version of the asset
    \item
      \texttt{1} for the latest approved version of the asset
    \end{itemize}
  \item
    Since the Blogs application provides its own JSPs, it must pass a
    reference of the servlet context to the asset renderer. This is
    always required when using custom JSPs in an asset renderer:

    @Reference( target =
    ``(osgi.web.symbolicname=com.liferay.blogs.web)'', unbind = ``-'' )
    public void setServletContext(ServletContext servletContext) \{
    \_servletContext = servletContext; \}

    private ServletContext \_servletContext;
  \end{enumerate}
\item
  Set the type of asset that the asset factory associates with and
  provide a getter method to retrieve that type. Also, provide another
  getter to retrieve the blogs entry class name, which is required:

\begin{verbatim}
public static final String TYPE = "blog";

@Override
public String getType() {
    return TYPE;
}

@Override
public String getClassName() {
    return BlogsEntry.class.getName();
}
\end{verbatim}
\item
  Set the Lexicon icon for the asset:

\begin{verbatim}
@Override
public String getIconCssClass() {
    return "blogs";
}
\end{verbatim}

  You can find a list of all available Lexicon icons at
  \url{https://liferay.github.io/clay/content/icons-lexicon/}.
\item
  Add methods that generate URLs to add and view the asset.

\begin{verbatim}
@Override
public PortletURL getURLAdd(
    LiferayPortletRequest liferayPortletRequest,
    LiferayPortletResponse liferayPortletResponse, long classTypeId) {

    PortletURL portletURL = PortalUtil.getControlPanelPortletURL(
        liferayPortletRequest, getGroup(liferayPortletRequest),
        BlogsPortletKeys.BLOGS, 0, 0, PortletRequest.RENDER_PHASE);

    portletURL.setParameter("mvcRenderCommandName", "/blogs/edit_entry");

    return portletURL;
}

@Override
public PortletURL getURLView(
    LiferayPortletResponse liferayPortletResponse,
    WindowState windowState) {

    LiferayPortletURL liferayPortletURL =
        liferayPortletResponse.createLiferayPortletURL(
            BlogsPortletKeys.BLOGS, PortletRequest.RENDER_PHASE);

    try {
        liferayPortletURL.setWindowState(windowState);
    }
    catch (WindowStateException wse) {
    }

    return liferayPortletURL;
}
\end{verbatim}

  If you're paying close attention, you may have noticed the
  \texttt{getURLView(...)} method was also implemented in the
  \texttt{BlogsEntryAssetRenderer} class. The asset renderer's
  \texttt{getURLView(...)} method creates a URL for the specific asset
  instance, whereas the factory uses the method to create a generic URL
  that only points to the application managing the assets (e.g., Blogs
  application).
\item
  Set the global permissions for all blogs assets:

\begin{verbatim}
@Override
public boolean hasAddPermission(
        PermissionChecker permissionChecker, long groupId, long classTypeId)
    throws Exception {

    return BlogsPermission.contains(
        permissionChecker, groupId, ActionKeys.ADD_ENTRY);
}

@Override
public boolean hasPermission(
        PermissionChecker permissionChecker, long classPK, String actionId)
    throws Exception {

    return BlogsEntryPermission.contains(
        permissionChecker, classPK, actionId);
}
\end{verbatim}
\end{enumerate}

Great! You've finished creating the Blogs application's asset renderer
factory! Now you have the knowledge to implement an asset renderer and
produce an asset renderer for each asset instance using a factory!

\chapter{Themes and Layout Templates}\label{themes-and-layout-templates}

A Theme provides the overall look and feel for a site.
\href{/docs/7-1/reference/-/knowledge_base/r/understanding-the-page-layout}{Understanding
the page layout} is crucial to targeting the correct markup for styling,
organizing your content, and creating your site. Once you understand how
the page is organized, you can develop your theme.

If you want to design a website, you must have three key components:
CSS, JavaScript, and HTML. Liferay DXP provides
\href{/docs/7-1/reference/-/knowledge_base/r/theme-components-and-workflow\#css-frameworks-and-extensions}{CSS
extensions and patterns out-of-the-box} and supports SASS, as well as
multiple JavaScript frameworks. The HTML, however, is rendered via
\href{https://freemarker.apache.org/}{FreeMarker} theme templates.

Liferay DXP provides several
\href{/docs/7-1/reference/-/knowledge_base/r/theme-components-and-workflow\#theme-templates}{default
FreeMarker templates} that each handle a key piece of functionality for
the page. To help make the development process easier, Liferay DXP also
provides several
\href{/docs/7-1/reference/-/knowledge_base/r/theme-components-and-workflow\#theme-template-utilities}{theme
template utilities} that you can use in your theme templates to include
portlets, use taglibs, access theme objects, and more.

There are several mechanisms for
\href{/docs/7-1/reference/-/knowledge_base/r/theme-components-and-workflow\#theme-customizations-and-extensions}{customizing
and extending themes}, from color schemes to reusable pieces of code.
Likewise, there are several mechanisms for
\href{/docs/7-1/reference/-/knowledge_base/r/theme-components-and-workflow\#portlet-customizations-and-extensions}{customizing
and extending portlets}.

In this section of tutorials, you'll learn how to develop themes and
layout templates, customize portlets, and more.

\chapter{Themes}\label{themes-1}

Themes let you customize the default look and feel of your site. Liferay
DXP provides several mechanisms for customizing, developing, and
extending themes. See the
\href{/docs/7-1/reference/-/knowledge_base/r/theme-components-and-workflow}{Theme
Components and Workflow} reference guide for a top-level overview of how
themes work in Liferay DXP.

This section of tutorials shows how to create and develop themes for
Liferay DXP.

\chapter{Creating Themes}\label{creating-themes}

The Liferay Theme Generator lets you create themes, themelets, layout
templates and more. It is just one of Liferay JS Theme Toolkit's
\href{https://github.com/liferay/liferay-themes-sdk/tree/master/packages}{tools}.
There are a few dependencies required to run the generator. If you have
NodeJS installed, you're already one step ahead.

Follow these steps to install the Liferay Theme Generator and generate a
theme:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Install \href{http://nodejs.org/}{Node.js}. We recommend installing
  \href{https://nodejs.org/download/release/v8.10.0/}{v8.10.0}, which is
  the version Liferay Portal 7.1 supports. Note that Node Package
  Manager (npm) is installed with this as well. You'll use npm to
  install the remaining dependencies and generator. Make sure to
  \href{/docs/7-1/reference/-/knowledge_base/r/setting-up-your-npm-environment}{set
  up your npm environment} before moving to the next step. Failing to do
  this can lead to permissions issues later on.
\item
  Use npm to install \href{http://yeoman.io/}{Yeoman} and
  \href{https://gulpjs.com/}{gulp}:

\begin{verbatim}
npm install -g yo
\end{verbatim}
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** Gulp is included as a local dependency in generated themes, so you
 are not required to install it. It can be accessed by running
 `node_modules\.bin\gulp` followed by the Gulp task from a generated theme's
 root folder.
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\tightlist
\item
  Install the Liferay Theme Generator. A few versions of the Liferay
  Theme Generator are available. The version you must install depends on
  the version of Liferay DXP you're developing on. The required versions
  are listed in the table below:
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 Liferay Version | Liferay Theme Generator Version | Command |
 --- | --- | --- |
 6.2 | 7.x.x | `npm install -g generator-liferay-theme@^7.x.x` |
 7.0 | 7.x.x or 8.x.x | Same as above or below |
 7.1 | 8.x.x | `npm install -g generator-liferay-theme@^8.x.x` |
\end{verbatim}

\noindent\hrulefill

\begin{verbatim}
If you're on Windows, follow the instructions in step 4 to install Sass, 
otherwise you can skip to step 5.
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{3}
\item
  The generator uses node-sass. If you are on Windows, you must also
  install
  \href{https://github.com/nodejs/node-gyp\#installation}{node-gyp and
  Python}.
\item
  Run the generator and follow the prompts to create your theme:

\begin{verbatim}
yo liferay-theme
\end{verbatim}

  \begin{figure}
  \centering
  \includegraphics{./images/theme-generator-theme-prompt.png}
  \caption{You can generate a theme by answering just a few
  configuration questions.}
  \end{figure}
\item
  Navigate to your theme folder and run \texttt{gulp\ deploy} to deploy
  your new theme to the server.
\end{enumerate}

Now you have a powerful theme development tool at your disposal. The sky
is the limit!

\begin{figure}
\centering
\includegraphics{./images/theme-generator-theme-example.png}
\caption{The tools are in your hands to create any theme you can
imagine.}
\end{figure}

\chapter{Developing Themes}\label{developing-themes}

Theme projects created using the
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-themes}{Liferay
Theme Generator} have access to several
\href{https://www.npmjs.com/package/gulp}{gulp} tasks you can execute to
manage and develop your theme. This section of tutorials covers the
available actions that these tasks provide, as well as other information
you may find useful while developing your theme.

\section{Using Developer Mode with
Themes}\label{using-developer-mode-with-themes}

Do you want to develop themes without having to redeploy to see your
modifications? Use Developer Mode! In Developer Mode, all caches are
removed, so any changes you make are visible right away. Also, you don't
have to reboot the server as often in Developer Mode.

How does Developer Mode let you see your changes more quickly? By
default, Liferay DXP is optimized for performance. Developer mode
optimizes your configuration for development instead. Here is a list of
Developer Mode's key behavior changes and the
\href{https://docs.liferay.com/portal/7.1-latest/propertiesdoc/portal.properties.html}{Portal
Property} override settings that trigger them (if applicable):

\begin{itemize}
\tightlist
\item
  CSS files are loaded individually rather than being combined and
  loaded as a single CSS file (\texttt{theme.css.fast.load=false}).
\item
  Layout template caching is disabled
  (\texttt{layout.template.cache.enabled=false}).
\item
  The server does not launch a browser when starting
  (\texttt{browser.launcher.url=}).
\item
  FreeMarker Templates for themes and web content are not cached, so
  changes are applied immediately (via the system setting in your
  Liferay DXP instance).
\item
  Minification of CSS and JavaScript resources is disabled
  (\texttt{minifier.enabled=false}).
\end{itemize}

Individual file loading of your styling and behaviors, combined with
disabled caching for layout and FreeMarker templates, lets you see your
changes more quickly. These developer settings are defined in the
\href{https://github.com/liferay/liferay-portal/blob/7.1.x/portal-impl/src/portal-developer.properties}{\texttt{portal-developer.properties}
file}. To use these settings, you can include them in your
\texttt{portal-ext.properties} file or copy them over to your
\texttt{portal-ext.properties} file and override specific properties as
needed. These configurations are covered in this tutorial.

First, you can explore how it's done in Dev Studio DXP.

\subsection{Setting Developer Mode for Your Server in Dev
Studio}\label{setting-developer-mode-for-your-server-in-dev-studio}

To enable Developer Mode for your server in Dev Studio DXP, follow these
steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Double-click on your server in the \emph{Servers} window and open the
  \emph{Liferay Launch} section.
\item
  Select \emph{Custom Launch Settings} and check the \emph{Use developer
  mode} option.
\item
  Save the changes and start your server.
\end{enumerate}

\begin{figure}
\centering
\includegraphics{./images/developer-mode-ide.png}
\caption{The \emph{Use developer mode} option lets you enable Developer
Mode for your server in Dev Studio DXP.}
\end{figure}

\noindent\hrulefill

\textbf{Warning:} Only change the Server settings from the runtime
environment's Liferay Launch section.

\noindent\hrulefill

When starting your server for the first time, it creates a
\texttt{portal-ext.properties} file in your server's directory. This
properties file contains the property setting
\texttt{include-and-override=portal-developer.properties}, which enables
Developer Mode. Most of the configuration is provided by the
\texttt{portal-developer.properties} file, but you still have to
configure the FreeMarker template setting. Follow the steps in the
\href{/docs/7-1/tutorials/-/knowledge_base/t/using-developer-mode-with-themes\#configuring-freemarker-system-settings}{Configuring
FreeMarker System Settings} section to configure the FreeMarker template
cache.

If you're not using Dev Studio DXP, manual configuration for Developer
Mode is covered next.

\subsection{Setting Developer Mode for Your Server Using
portal-developer.properties}\label{setting-developer-mode-for-your-server-using-portal-developer.properties}

To set Developer Mode manually, you must point to
\texttt{portal-developer.properties} as shown in the last section. Add
the \texttt{portal-ext.properties} file to the root folder of your app
server's bundle and add the following line:

\begin{verbatim}
include-and-override=portal-developer.properties
\end{verbatim}

Developer Mode is enabled upon starting your app server.
\texttt{portal-developer.properties} provides the majority of the
settings you'll need for smooth development. To disable the cache for
FreeMarker templates, you must update the System Setting covered in the
next section.

\subsection{Configuring FreeMarker System
Settings}\label{configuring-freemarker-system-settings}

FreeMarker Templates for themes and web content are cached by default.
Therefore, any changes you make to your FreeMarker theme templates
aren't immediately displayed. You can change this behavior through
System Settings. Follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open the Control Panel and go to \emph{Configuration} → \emph{System
  Settings}.
\item
  Select \emph{Template Engines} under the \emph{PLATFORM} heading.
\item
  By default, the \emph{Resource modification check} (the time in
  milliseconds that the template is cached) is set to \texttt{60000}.
  Set this value to \texttt{0} to disable caching.
\end{enumerate}

Your FreeMarker templates are ready for development. Next you can learn
how you can improve JavaScript file loading for development.

\subsection{JavaScript Fast Loading}\label{javascript-fast-loading}

By default, JavaScript fast loading is enabled in Developer Mode
(\texttt{javascript.fast.load=true}). This loads the packed version of
files listed in the
\href{https://docs.liferay.com/portal/7.1-latest/propertiesdoc/portal.properties.html\#JavaScript}{Portal
Properties} \texttt{javascript.barebone.files} or
\texttt{javascript.everything.files}. You can, however, disable
JavaScript fast loading for easier debugging for development. Just set
\texttt{javascript.fast.load} to \texttt{false} in your
\texttt{portal.properties}, or you can disable fast loading by setting
the URL parameter \texttt{js\_fast\_load} to \texttt{0}.

\noindent\hrulefill

\textbf{Note:} JavaScript fast loading is retrieved from one of three
places: the request (determined by the current URL:
\texttt{http://localhost:8080/web/guest/home?js\_fast\_load=1}(on) or
\texttt{...?js\_fast\_load=0}(off)), the Session, or the Portal Property
(\texttt{javascript.fast.load=true}). Preference is given in the order
of request, session, and then Portal Properties. This lets you change
\texttt{js\_fast\_load}'s value from the default in
\texttt{portal.properties} without having to manually re-enter
\texttt{js\_fast\_load} into the URL upon every new page load.

\noindent\hrulefill

Great! You've set up your server for Developer Mode. Now, when you
modify your theme's file directly in your bundle, you can see your
changes applied immediately on redeploying your theme!

\subsection{Related Topics}\label{related-topics-99}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-layout-templates-manually}{Creating
Layout Templates Manually}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-themes-with-liferay-ide}{Creating
Themes with Dev Studio DXP}

\section{Building Your Theme's Files}\label{building-your-themes-files}

The \texttt{gulp\ build} task generates the base theme files, compiles
Sass into CSS, and zips all theme files into a WAR file that you can
deploy to your server.

\noindent\hrulefill

\textbf{Note:} Gulp is included as a local dependency in generated
themes, so you are not required to install it. It can be accessed by
running \texttt{node\_modules\textbackslash{}.bin\textbackslash{}gulp}
followed by the Gulp task from a generated theme's root folder.

\noindent\hrulefill

Follow these steps to build your theme's files:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Navigate to your theme's root folder and run \texttt{gulp\ build}.

  \begin{figure}
  \centering
  \includegraphics{./images/theme-dev-building-themes-gulp-build.png}
  \caption{Run the \texttt{gulp\ build} task to build your theme's
  files.}
  \end{figure}
\item
  A new \texttt{build} folder is created with all your theme's files.
  You can copy these files and folders to your theme's \texttt{src}
  folder to modify the theme.

  \begin{figure}
  \centering
  \includegraphics{./images/theme-dev-building-themes-build-folder.png}
  \caption{The build folder contains all your theme's files.}
  \end{figure}
\item
  Your theme's files are zipped into a \texttt{war} file in a new
  \texttt{dist} folder. Deploy the \texttt{war} file to your app server
  to make it available.
\end{enumerate}

\begin{figure}
\centering
\includegraphics{./images/theme-dev-building-themes-dist-folder.png}
\caption{The dist folder contains your theme's WAR file.}
\end{figure}

\subsection{Related Topics}\label{related-topics-100}

\href{/docs/7-1/tutorials/-/knowledge_base/t/automatically-deploying-theme-changes}{Automatically
Deploying Theme Changes}

\href{/docs/7-1/tutorials/-/knowledge_base/t/copying-an-existing-themes-files}{Copying
an Existing Theme's Files}

\href{/docs/7-1/tutorials/-/knowledge_base/t/deploying-your-theme}{Deploying
Themes}

\section{Deploying Your Theme}\label{deploying-your-theme}

To deploy your theme to your app server, run the \texttt{gulp\ deploy}
task. The \texttt{gulp\ \ deploy} task
\href{/docs/7-1/tutorials/-/knowledge_base/t/building-your-themes-files}{builds
your theme's files}, and deploys the generated WAR file to the
\href{/docs/7-1/tutorials/-/knowledge_base/t/configuring-your-themes-app-server}{app
server you configured} when you
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-themes}{created
the theme}.

\noindent\hrulefill

\textbf{Note:} If you're running the
\href{/docs/7-0/reference/-/knowledge_base/r/using-the-felix-gogo-shell}{Felix
Gogo shell}, you can also deploy your theme using the
\texttt{gulp\ deploy:gogo} command.

\noindent\hrulefill

\noindent\hrulefill

\textbf{Note:} Gulp is included as a local dependency in generated
themes, so you are not required to install it. It can be accessed by
running \texttt{node\_modules\textbackslash{}.bin\textbackslash{}gulp}
followed by the Gulp task from a generated theme's root folder.

\noindent\hrulefill

Follow these steps to deploy your theme:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Navigate to your theme's root folder and run \texttt{gulp\ deploy}.

  \begin{figure}
  \centering
  \includegraphics{./images/theme-dev-deploying-themes-gulp-deploy.png}
  \caption{Run the \texttt{gulp\ deploy} task to build your theme's
  files and deploy it to your app server.}
  \end{figure}
\item
  Your server's log displays that the OSGi bundle is started.

  \begin{figure}
  \centering
  \includegraphics{./images/theme-dev-deploying-themes-server-log.png}
  \caption{Your server's log notifies you when the theme's bundle has
  started.}
  \end{figure}
\item
  You can apply your theme through the \emph{Navigation} → \emph{Site
  Pages} menu in the Control Menu. Select the \emph{Configure} option
  for your site pages, and click the \emph{Change Current Theme} button
  to apply your theme.

  \begin{figure}
  \centering
  \includegraphics{./images/theme-dev-deploying-themes-install-theme.png}
  \caption{Run the \texttt{gulp\ deploy} task to build your theme's
  files and deploy it to your app server.}
  \end{figure}
\end{enumerate}

\subsection{Related Topics}\label{related-topics-101}

\href{/docs/7-1/tutorials/-/knowledge_base/t/automatically-deploying-theme-changes}{Automatically
Deploying Theme Changes}

\href{/docs/7-1/tutorials/-/knowledge_base/t/copying-an-existing-themes-files}{Copying
an Existing Theme's Files}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-reusable-pieces-of-code-for-your-themes}{Creating
Reusable Pieces of Code for Your Themes}

\section{Changing Your Base Theme}\label{changing-your-base-theme}

Once your theme is
\href{/docs/7-1/tutorials/-/knowledge_base/t/building-your-themes-files}{built},
you can use the \texttt{gulp\ extend} task to change your theme's base
theme.

\noindent\hrulefill

\textbf{Note:} Gulp is included as a local dependency in generated
themes, so you are not required to install it. It can be accessed by
running \texttt{node\_modules\textbackslash{}.bin\textbackslash{}gulp}
followed by the Gulp task from a generated theme's root folder.

\noindent\hrulefill

Follow these steps to change your base theme:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Navigate to your theme's root folder and run \texttt{gulp\ extend} and
  choose option 1 to change the base theme your theme extends.

  \begin{figure}
  \centering
  \includegraphics{./images/theme-dev-changing-base-themes-gulp-extend-base-theme.png}
  \caption{Run the \texttt{gulp\ extend} task to change your base theme
  or install a themelet.}
  \end{figure}
\item
  Choose which base theme you want to extend. By default, themes created
  with the
  \href{https://github.com/liferay/generator-liferay-theme}{Liferay
  Theme Generator} are based off of the
  \href{https://www.npmjs.com/package/liferay-theme-styled}{styled
  theme}. You can extend the styled or unstyled base theme, a globally
  installed theme, a theme published on the npm registry, or you can
  specify a package URL. Enter the number for the option you wish to
  select.
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** You can retrieve the URL for a package by running 
 `npm show package-name dist.tarball`. 
\end{verbatim}

\noindent\hrulefill

\begin{verbatim}
![ You can extend the styled or unstyled base theme, a globally installed theme, or a theme published to the npm registry.](./images/theme-dev-changing-base-themes-gulp-extend-base-theme-choice.png)
\end{verbatim}

\noindent\hrulefill

\begin{verbatim}
 **Note:** The Classic theme is an implementation of an existing base theme
 and is therefore not meant to be extended. Extending Liferay's Classic theme
 is strongly discouraged.
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\item
  Your theme's \texttt{package.json} contains the updated base theme
  configuration :

\begin{verbatim}
{
  ...
    "liferayTheme": {
        "baseTheme": "styled",
        "screenshot": "",
        "rubySass": false,
        "templateLanguage": "ftl",
        "version": "7.1"
    },
  ...
}
\end{verbatim}
\end{enumerate}

When you
\href{/docs/7-1/tutorials/-/knowledge_base/t/building-your-themes-files}{build
your theme's files} or
\href{/docs/7-1/tutorials/-/knowledge_base/t/deploying-your-theme}{deploy
it}, your theme will inherit the updated base theme's files.

\subsection{Related Topics}\label{related-topics-102}

\href{/docs/7-1/tutorials/-/knowledge_base/t/configuring-your-themes-app-server}{Configuring
Your Theme's App Server}

\href{/docs/7-1/tutorials/-/knowledge_base/t/deploying-your-theme}{Deploying
Themes}

\href{/docs/7-1/tutorials/-/knowledge_base/t/listing-your-themes-extensions}{Listing
Your Theme's Extensions}

\section{Copying an Existing Theme's
Files}\label{copying-an-existing-themes-files}

If you want to jump start developing your theme, you can copy an
existing theme's files and build on top of them. The
\texttt{gulp\ kickstart} task automates this process for you. It copies
another theme's css, images, js, and templates into the \texttt{src}
directory of your own. While this is similar to extending your theme
with a base theme or a themelet, kickstarting from another theme is a
one time inheritance, whereas extending from another theme is a dynamic
inheritance that applies your \texttt{src} files on top of the base
theme on every build.

\noindent\hrulefill

\textbf{Note:} The gulp kickstart task copies an existing theme's files
into your own, which can potentially overwrite files with the same name.
Proceed with caution.

\noindent\hrulefill

\noindent\hrulefill

\textbf{Note:} Gulp is included as a local dependency in generated
themes, so you are not required to install it. It can be accessed by
running \texttt{node\_modules\textbackslash{}.bin\textbackslash{}gulp}
followed by the Gulp task from a generated theme's root folder.

\noindent\hrulefill

To kickstart your theme, follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Navigate to your theme's root folder and run \texttt{gulp\ kickstart}.

  \begin{figure}
  \centering
  \includegraphics{./images/theme-dev-kickstarting-themes-gulp-kickstart.png}
  \caption{Run the \texttt{gulp\ kickstart} task to copy a theme's files
  into your own theme.}
  \end{figure}
\item
  Select where the theme is located. You can copy files from globally
  installed themes or themes published on the npm registry.
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** To globally install a theme, run the `npm link` command from the
 theme's root folder.
\end{verbatim}

\noindent\hrulefill

\begin{verbatim}
![ You can copy files from  globally installed themes.](./images/theme-dev-kickstarting-themes-global-theme.png)
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\item
  The theme's files are copied into your own theme, jump starting
  development.

  \begin{figure}
  \centering
  \includegraphics{./images/theme-dev-kickstarting-themes-copied-files.png}
  \caption{The kickstart tasks copies another theme's files into your
  own, potentially overwriting files.}
  \end{figure}
\end{enumerate}

\subsection{Related Topics}\label{related-topics-103}

\href{/docs/7-1/tutorials/-/knowledge_base/t/building-your-themes-files}{Building
Your Theme's files}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-reusable-pieces-of-code-for-your-themes}{Creating
Reusable Pieces of Code for Your Themes}

\href{/docs/7-1/tutorials/-/knowledge_base/t/deploying-your-theme}{Deploying
Themes}

\section{Configuring Your Theme's App
Server}\label{configuring-your-themes-app-server}

When your theme was first created with the
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-themes}{Liferay
Theme Generator}, you had to specify the app server's location. This was
done with the \texttt{gulp\ init} task. Your theme uses this information
to deploy to the proper server. If your app server or site changes
during development, you can update their configuration information by
manually running the \texttt{gulp\ init} task.

\noindent\hrulefill

\textbf{Note:} Gulp is included as a local dependency in generated
themes, so you are not required to install it. It can be accessed by
running \texttt{node\_modules\textbackslash{}.bin\textbackslash{}gulp}
followed by the Gulp task from a generated theme's root folder.

\noindent\hrulefill

Follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Navigate to your theme's root folder and run \texttt{gulp\ init}.

  \begin{figure}
  \centering
  \includegraphics{./images/theme-dev-server-configuration-gulp-init.png}
  \caption{Run the \texttt{gulp\ init} task to update your app server
  configuration.}
  \end{figure}
\item
  Enter the path to your app server and site.

  \begin{figure}
  \centering
  \includegraphics{./images/theme-dev-server-configuration-gulp-init-config.png}
  \caption{You can also run the \texttt{gulp\ init} task to update your
  site's URL.}
  \end{figure}
\item
  Your theme's \texttt{liferay-theme.json} file contains the updated
  server configuration information:

\begin{verbatim}
{
  "LiferayTheme": {
    "appServerPath": "C:\\Users\\liferay\\opt\\Liferay\\bundles\\7.1-master-bundle\\bundles\\tomcat-8.0.32",
    "deployPath": "C:\\Users\\liferay\\opt\\Liferay\\bundles\\7.1-master-bundle\\bundles\\deploy",
    "url": "http://localhost:8080",
    "appServerPathPlugin": "C:\\Users\\liferay\\opt\\Liferay\\bundles\\7.1-master-bundle\\bundles\\tomcat-8.0.32\\webapps\\my-liferay-theme",
    "deployed": false,
    "pluginName": "my-liferay-theme"
  }
}
\end{verbatim}
\end{enumerate}

\subsection{Related Topics}\label{related-topics-104}

\href{/docs/7-1/tutorials/-/knowledge_base/t/automatically-deploying-theme-changes}{Automatically
Deploying Theme Changes}

\href{/docs/7-1/tutorials/-/knowledge_base/t/changing-your-base-theme}{Changing
Your Base Theme}

\href{/docs/7-1/tutorials/-/knowledge_base/t/listing-your-themes-extensions}{Listing
Your Theme's Extensions}

\section{Listing Your Theme's
Extensions}\label{listing-your-themes-extensions}

Do you need to know what base theme/themelets your theme extends?
There's a gulp task for that. While you can manually check your theme's
\texttt{package.json} for this information, the \texttt{gulp\ status}
task displays this information for you. Navigate to your theme's root
folder and run \texttt{gulp\ status} to display your theme's extensions.

\begin{figure}
\centering
\includegraphics{./images/theme-dev-listing-theme-extensions.png}
\caption{Run the \texttt{gulp\ status} task to list your theme's current
extensions.}
\end{figure}

\noindent\hrulefill

\textbf{Note:} Gulp is included as a local dependency in generated
themes, so you are not required to install it. It can be accessed by
running \texttt{node\_modules\textbackslash{}.bin\textbackslash{}gulp}
followed by the Gulp task from a generated theme's root folder.

\noindent\hrulefill

\subsection{Related Topics}\label{related-topics-105}

\href{/docs/7-1/tutorials/-/knowledge_base/t/changing-your-base-theme}{Changing
Your Base Theme}

\href{/docs/7-1/tutorials/-/knowledge_base/t/configuring-your-themes-app-server}{Configuring
Your Theme's App Server}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-reusable-pieces-of-code-for-your-themes}{Creating
Reusable Pieces of Code for Your Themes}

\section{Automatically Deploying Theme
Changes}\label{automatically-deploying-theme-changes}

You may have noticed that you have to deploy your theme manually each
time you make a change. This can become tedious during the development
process. The \texttt{gulp\ watch} task lets you preview changes to your
theme without requiring a full redeploy.

\noindent\hrulefill

\textbf{Note:} Gulp is included as a local dependency in generated
themes, so you are not required to install it. It can be accessed by
running \texttt{node\_modules\textbackslash{}.bin\textbackslash{}gulp}
followed by the Gulp task from a generated theme's root folder.

\noindent\hrulefill

Follow these steps to preview changes to your theme automatically:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Enable
  \href{/docs/7-1/tutorials/-/knowledge_base/t/using-developer-mode-with-themes}{Developer
  Mode} in your server. Without this enabled, the gulp watch task
  \textbf{will not work}.
\item
  Navigate to your theme's root folder and run \texttt{gulp\ watch}.
  This sets up a proxy for your app server
  (\texttt{http://localhost:9080}) and opens it in a new window in the
  browser. It also provides an IP address for you to view your app
  server across all devices connected to the local network. The browser
  is synced across all devices that use the given IP address.
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** Live changes are only viewable on port `9080`
 (`http://localhost:9080`). Live changes **are not viewable** on your app
 server (e.g. `http://localhost:8080`). 
\end{verbatim}

\noindent\hrulefill

\begin{verbatim}
![ Run the `gulp watch` task to automatically deploy any changes to your theme.](./images/theme-dev-watching-themes-gulp-watch-startup.png)
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\item
  Make a change to your theme and save the file. The updated files are
  built, compiled, and copied directly to port \texttt{9080}. CSS
  changes are deployed live, so no page reload is needed. For JS and
  template changes, \textbf{you must} reload the browser to see the
  changes.

  \begin{figure}
  \centering
  \includegraphics{./images/theme-dev-watching-themes-gulp-watch-auto-deploy.png}
  \caption{The watch task notifies you that the changes are deployed.}
  \end{figure}
\item
  Once you're happy with the previewed changes, deploy your theme to
  your app server to apply the changes.
\end{enumerate}

\subsection{Related Topics}\label{related-topics-106}

\href{/docs/7-1/tutorials/-/knowledge_base/t/configuring-your-themes-app-server}{Configuring
Your Theme's App Server}

\href{/docs/7-1/tutorials/-/knowledge_base/t/copying-an-existing-themes-files}{Copying
an Existing Theme's Files}

\href{/docs/7-1/tutorials/-/knowledge_base/t/deploying-your-theme}{Deploying
Themes}

\section{Creating Reusable Pieces of Code for Your
Themes}\label{creating-reusable-pieces-of-code-for-your-themes}

Themelets are small, extendable, and reusable pieces of code. Whereas
themes require multiple components, a themelet only requires the files
you wish to extend. This creates a more modular approach to theme design
that lends itself well to collaboration and reduces the need for
duplicated code in your theme.

Themelets let developers easily share code snippets across their themes
with other developers. A themelet can consist of CSS and JavaScript.
Themelets \textbf{do not support} theme templates.

Themelets are very flexible, and therefore they have a number of
possible uses. You can make a themelet to modify the appearance of the
admin tools, or a themelet that uses a custom JavaScript component for
responsive embedded videos, and everything in between. For example, the
\href{https://www.npmjs.com/package/lfr-product-menu-animation-themelet}{Liferay
Product Menu Animation Themelet} simply alters the animation for the
Product Menu.

\begin{figure}
\centering
\includegraphics{./images/product-menu-animation-themelet.png}
\caption{Themelets can be used to modify one aspect of the UI, that you
can then reuse in your other themes.}
\end{figure}

If there is something you have to manually code for every theme you
create, it's a good candidate for a themelet.

This tutorial demonstrates how to:

\begin{itemize}
\item
  Create a themelet to extend your theme
\item
  Install a Themelet
\end{itemize}

To create a themelet, you need a theme to extend and the Liferay Theme
Generator and dependencies installed, as explained in the
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-themes}{Creating
Themes} tutorial.

\subsection{Creating a Themelet}\label{creating-a-themelet}

Follow these steps to create a themelet:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open the Command Line and navigate to the folder you want to create
  your themelet in.
\item
  Run \texttt{yo\ liferay-theme:themelet} and follow the prompts to
  generate the themelet.

  \begin{figure}
  \centering
  \includegraphics{./images/themelet-prompt.png}
  \caption{The Themelet sub-generator automates the themelet creation
  process, making it quick and easy.}
  \end{figure}
\item
  The generated themelet contains a \texttt{package.json} file with
  configuration information and a \texttt{src/css} folder that contains
  a \texttt{\_custom.scss} file. Just like a theme, add your CSS changes
  to the \texttt{src/css} folder, and add your JavaScript changes to the
  \texttt{src/js} folder.
\item
  To use your themelet, you must install it globally first. This makes
  the themelet visible to the generator. To install your themelet
  globally, navigate into its root folder and run \texttt{npm\ link}.
  Note, you may need to run the command using \texttt{sudo\ npm\ link}.
  This creates a globally-installed symbolic link for the themelet in
  your npm packages folder. Now your themelet is available to install in
  your themes.
\end{enumerate}

Now that your themelet is developed, you can install it in your theme.

\subsection{Installing a Themelet}\label{installing-a-themelet}

After you've developed your themelet, follow the steps below to install
it into your theme.

\noindent\hrulefill

\textbf{Note:} Gulp is included as a local dependency in generated
themes, so you are not required to install it. It can be accessed by
running \texttt{node\_modules\textbackslash{}.bin\textbackslash{}gulp}
followed by the Gulp task from a generated theme's root folder.

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Navigate to your theme's root folder and run the following command:

\begin{verbatim}
gulp extend
\end{verbatim}
\item
  Choose \emph{Themelet} as the theme asset to extend.
\item
  Select \emph{Search globally installed npm modules}, \emph{Search npm
  registry}, or \emph{Specify a package URL} to locate the themelet.

  \begin{figure}
  \centering
  \includegraphics{./images/install-themelet.png}
  \caption{You can extend your theme using globally installed npm
  modules, published npm modules, or via a package URL.}
  \end{figure}
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** You can retrieve the URL for a package by running 
 `npm show package-name dist.tarball`.
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{3}
\item
  Highlight your themelet, press spacebar to activate it, and press
  \emph{Enter} to install it.
\item
  Run \texttt{gulp\ deploy} to build and deploy your theme with the new
  themelet updates.
\end{enumerate}

Your themelet is installed! As you can see, themelets are a handy tool
to add to your theme development bag o' tricks.

\subsection{Related Topics}\label{related-topics-107}

\href{/docs/7-1/tutorials/-/knowledge_base/t/importing-resources-with-a-theme}{Importing
Resources with Your Themes}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-themes}{Creating
Themes}

\section{Creating a Thumbnail Preview for Your
Theme}\label{creating-a-thumbnail-preview-for-your-theme}

When you apply a theme to your site pages, you have to choose from the
list of available themes in the site selector. The only identification
for each theme is the theme's name, along with a small thumbnail preview
image that gives a brief impression of the theme. By default, themes
don't provide a thumbnail image, so you must create one. This is even
more important when developing color schemes for a theme. Names are not
displayed for color schemes, so a thumbnail preview is required to
identify them.

\begin{figure}
\centering
\includegraphics{./images/theme-dev-theme-thumbnail-default.png}
\caption{Your theme thumbnail is displayed with the rest of the
available themes.}
\end{figure}

Follow these steps to create a thumbnail preview for your theme:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  With your theme applied to your site and an optional color scheme
  chosen, take a screenshot that best represents it.
\item
  Crop any unwanted areas and re-size the screenshot to 150 pixels high
  by 120 pixels wide. Your thumbnail \emph{must be} these exact
  dimensions to display properly.
\item
  Save the image as a \texttt{.png} file named \texttt{thumbnail.png}
  and place it in the theme's \texttt{src/images} folder (create this
  folder if it doesn't already exist). On redeployment, the
  \texttt{thumbnail.png} file automatically becomes the theme's
  thumbnail.
\end{enumerate}

\noindent\hrulefill

\textbf{Note:} The
\href{/docs/7-1/reference/-/knowledge_base/r/theme-builder-gradle-plugin}{Theme
Builder Gradle plugin} doesn't recognize a \texttt{thumbnail.png} file.
If you're using this plugin to build your theme instead, you must create
a \texttt{screenshot.png} file in your theme's \texttt{images} folder
that is 1080 pixels high by 864 pixels wide. The thumbnail is
automatically generated from the screenshot for you when the theme is
built.

\noindent\hrulefill

Now, when you apply the theme, its thumbnail displays along with the
other themes that are available to your site.

\begin{figure}
\centering
\includegraphics{./images/theme-dev-theme-thumbnail-custom.png}
\caption{Your theme thumbnail is displayed with the rest of the
available themes.}
\end{figure}

\subsection{Related Topics}\label{related-topics-108}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-themes}{Creating
Themes}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-reusable-pieces-of-code-for-your-themes}{Creating
Reusable Pieces of Code for Your Themes}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-color-schemes-for-your-theme}{Creating
Color Schemes for Your Theme}

\section{Creating Color Schemes for Your
Theme}\label{creating-color-schemes-for-your-theme}

Color schemes give your theme additional color palettes. They only
require a small amount of changes to your theme's CSS. This is an easy
way to subtly change the look of your theme, while maintaining the same
design and feel to it.

Follow these steps to create color schemes for your theme:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a folder to hold color schemes (\texttt{color\_schemes} for
  example) in the theme's \texttt{css} folder and add a \texttt{.scss}
  file to it for each color scheme your theme supports.
\item
  Choose a CSS class to identify each color scheme, and specify this
  class in the color scheme's styles. The color scheme's name is a good
  choice. This class is added to the site's
  \texttt{\textless{}body\textgreater{}} element when the color scheme
  is applied, so you \emph{must} specify this class in the color schemes
  styles for them to work. For example, you could specify \texttt{.day}
  for a color scheme CSS file named \texttt{\_day.scss}:

\begin{verbatim}
body.day { background-color: #DDF; }
.day a { color: #66A; }
\end{verbatim}
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** The default color scheme uses the theme's `_custom.scss` for
 styling, so you don't need to specify its name in its styles.
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\item
  Import the color scheme \texttt{.scss} files into the theme's
  \texttt{\_custom.scss} file. The example below imports
  \texttt{\_day.scss} and \texttt{\_night.scss} files:

\begin{verbatim}
@import "color_schemes/day";
@import "color_schemes/night";
\end{verbatim}
\item
  Create a folder for each color scheme in your theme's \texttt{images}
  folder, and add
  \href{/docs/7-1/tutorials/-/knowledge_base/t/creating-a-thumbnail-preview-for-your-theme}{a
  thumbnail preview} for each color scheme. The folder name \emph{must
  match} the color scheme's CSS class name you specified in step 2.
\item
  Open the theme's \texttt{liferay-look-and-feel.xml} file and follow
  the pattern below to add the default color scheme. A default color
  scheme is required so users can return to the theme's default look and
  feel after choosing a different color scheme. Note that the color
  scheme's \texttt{name} value is arbitrary, but the
  \texttt{\textless{}css-class\textgreater{}} element's value \emph{must
  match} the CSS class you specified in step 2. If the default color
  scheme styling is in the theme's \texttt{\_custom.scss} file, use
  \texttt{default} for the \texttt{\textless{}css-class\textgreater{}}.
  Also note the inclusion of the
  \texttt{\textless{}color-scheme-images-path\textgreater{}} element.
  This specifies the theme thumbnail image location. Place this element
  in the first color scheme to configure the images path for all the
  color schemes:

\begin{verbatim}
<theme id="my-theme-id" name="My Theme Name">
   <color-scheme id="01" name="My Default Color Scheme Name">
       <default-cs>true</default-cs>
       <css-class>default</css-class>

       <color-scheme-images-path>
           ${images-path}/my_color_schemes_folder_name/${css-class}
       </color-scheme-images-path>
   </color-scheme>
   ...
</theme>
\end{verbatim}
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** Color schemes are sorted alphabetically by `name` rather than `id`.
 For example, a color scheme named `Clouds` and `id` `02` would be selected
 by default over a color scheme named `Day` with `id` `01`. The
 `<default-cs>` element overrides the alphabetical sorting and sets the color
 scheme that is selected by default when the theme is chosen.
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{5}
\item
  Add the remaining color schemes below the default color scheme, using
  the pattern below:

\begin{verbatim}
<color-scheme id="id-number" name="Color Scheme Name">
   <css-class>color-scheme-css-class</css-class>
</color-scheme>
\end{verbatim}
\end{enumerate}

An example \texttt{liferay-look-and-feel.xml} file is shown below:

\begin{verbatim}
<look-and-feel>
    <compatibility>
        <version>7.1.0+</version>
    </compatibility>
    <theme id="my-liferay-theme" name="My Liferay Theme">
        <template-extension>ftl</template-extension>
        <color-scheme id="01" name="Default">
            <default-cs>true</default-cs>
            <css-class>default</css-class>
            <color-scheme-images-path>
                ${images-path}/color_schemes/${css-class}
            </color-scheme-images-path>
        </color-scheme>
        <color-scheme id="02" name="Red">
            <css-class>red</css-class>
        </color-scheme>
        <color-scheme id="03" name="Green">
            <css-class>green</css-class>
        </color-scheme>
    </theme>
</look-and-feel>
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/theme-dev-color-schemes.png}
\caption{Color schemes give administrators some choices for your theme's
look.}
\end{figure}

There you have it. Now you can go color scheme crazy with your themes!

\subsection{Related Topics}\label{related-topics-109}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-layout-templates-with-the-themes-generator}{Creating
Layout Templates}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-a-thumbnail-preview-for-your-theme}{Creating
a Thumbnail Preview for Your Theme}

\section{Making Configurable Theme
Settings}\label{making-configurable-theme-settings}

Every time you want to make a change to a theme, you must make the
change and then deploy it to your server. For a Site Administrator, this
process is tedious, especially if it's a minor change to a theme, such
as a banner color change. What happens when it must be changed back? It
must be deployed again. For larger theme changes, this process is
unavoidable, but for smaller changes, there's a better way: configurable
theme settings. The Theme Developer can control the visibility and value
of theme elements and provide variations of theme elements for the Site
Administrator to configure and choose in the Control Panel. This
tutorial covers how to create configurable theme settings for your
theme.

Follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open your theme's \texttt{WEB-INF/liferay-look-and-feel.xml} file, or
  create it if it doesn't exist, and follow the pattern below to nest a
  \texttt{\textless{}setting/\textgreater{}} element inside the parent
  \texttt{\textless{}settings\textgreater{}} element for each setting
  the theme requires:

\begin{verbatim}
<look-and-feel>
    <compatibility>
        <version>7.1.0+</version>
    </compatibility>
    <theme id="your-theme-name" name="Your Theme Name">
        <template-extension>ftl</template-extension>
    <settings>
      <setting configurable="true" key="theme-setting-key"
      options="true,false" type="select" value="true" />
      <setting configurable="true" key="theme-setting-key"
      type="text" value="My placeholder text" />
    </settings>
    <portlet-decorator>
      portlet decorators...
        </portlet-decorator>
    </theme>
</look-and-feel>
\end{verbatim}

  The example configuration below adds a text input setting for custom
  text:

\begin{verbatim}
<settings>
  <setting configurable="true" key="my-custom-text"
  type="text" value="Liferay rocks!" />
</settings>
\end{verbatim}

  The available theme \texttt{\textless{}setting\textgreater{}}
  attributes are shown below:

  \texttt{configurable}: whether the setting is configurable or static

  \texttt{key}: the language key that identifies the theme setting

  \texttt{options}: sets the options for the select menu if the
  \texttt{type} is \texttt{select}

  \texttt{type}: the type of UI to render to control the theme setting.
  Possible values are \texttt{checkbox}, \texttt{select}, \texttt{text},
  or \texttt{textarea}.

  \texttt{value}: sets the default value for the theme setting

  You can find more information about setting attributes and all other
  configurations for the \texttt{liferay-look-and-feel.xml} in its
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/definitions/liferay-look-and-feel_7_1_0.dtd.html\#settings}{DTD
  docs}.
\item
  Add \texttt{init\_custom.ftl} to your theme templates if it doesn't
  already exist, and follow the patterns below to define your theme
  setting variables in it:

  Booleans (a select box with the options \texttt{true} and
  \texttt{false} or a checkbox with values \texttt{yes} and
  \texttt{no}):

\begin{verbatim}
<#assign my_variable_name =
getterUtil.getBoolean(themeDisplay.getThemeSetting("theme-setting-key"))/>
\end{verbatim}

  Strings (a text input or text area input):

\begin{verbatim}
<#assign my_variable_name =
getterUtil.getString(themeDisplay.getThemeSetting("theme-setting-key"))/>
\end{verbatim}

  The example configuration below adds the custom text setting:

\begin{verbatim}
<#assign my_custom_text =
getterUtil.getString(themeDisplay.getThemeSetting("my-custom-text"))/>
\end{verbatim}
\item
  Apply your theme settings to the theme template. The example
  configuration below prints the value for the \texttt{my\_custom\_text}
  variable in a \texttt{\textless{}p\textgreater{}} element:

  \texttt{portal\_normal.ftl}:

\begin{verbatim}
<p>${my_custom_text}</p>
\end{verbatim}
\item
  Deploy and install the theme, and open the \emph{Control Menu} →
  \emph{Site Administration} → \emph{Build} → \emph{Pages}. From this
  point, you can configure theme settings for two scopes:

  \begin{itemize}
  \item
    \textbf{Public or private page set:} \emph{Click} the gear icon next
    to the page set you want to configure. Then, under the \emph{Look
    and Feel} tab, choose your settings and click \emph{Save} to apply
    the changes to the page set.
  \item
    \textbf{An individual page:} Open the Actions menu next to the page
    and select \emph{Configure}. Then, click the \emph{Look and Feel}
    tab and select the \emph{Define a Specific look and feel for this
    page} option. Choose your settings and click \emph{Save} to apply
    the changes to the page.
  \end{itemize}
\end{enumerate}

\begin{figure}
\centering
\includegraphics{./images/theme-dev-configurable-theme-settings.png}
\caption{Here are examples of configurable settings for the site Admin.}
\end{figure}

Now you know how to make configurable theme settings for your themes!

\subsection{Related Topics}\label{related-topics-110}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-reusable-pieces-of-code-for-your-themes}{Creating
Reusable Pieces of Code for Your Themes}

\href{/docs/7-1/tutorials/-/knowledge_base/t/listing-your-themes-extensions}{Listing
Your Theme's Extensions}

\href{/docs/7-1/tutorials/-/knowledge_base/t/importing-resources-with-a-theme}{Importing
Resources with a Theme}

\section{Overwriting and Extending Liferay Theme
Tasks}\label{overwriting-and-extending-liferay-theme-tasks}

Themes created with the Liferay Theme Generator have access to several
default gulp theme tasks that provide the standard features required to
develop and build your theme (build, deploy, watch, etc.). You may,
however, want to run additional processes---such as minifying your
JavaScript files---on your theme's files prior to deploying the theme to
the server. The Liferay Theme Generator's APIs expose a \texttt{hookFn}
property that lets you hook into the default gulp theme tasks to inject
your own logic.

Follow these steps to hook into the default Liferay theme tasks:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Identify the gulp task or sub task that you want to hook into or
  overwrite. The tasks and their sub tasks are listed in their
  \texttt{{[}task-name{]}.js} file in the
  \href{https://github.com/liferay/liferay-themes-sdk/tree/master/packages/liferay-theme-tasks/tasks}{\texttt{tasks}
  folder} of the
  \href{https://github.com/liferay/liferay-themes-sdk/tree/master/packages/liferay-theme-tasks}{\texttt{liferay-theme-tasks}}
  package. For example, the gulp \texttt{build} task and sub tasks are
  defined in the
  \href{https://github.com/liferay/liferay-themes-sdk/blob/master/packages/liferay-theme-tasks/tasks/build.js\#L25-L39}{\texttt{build.js}
  file}:

\begin{verbatim}
'build:clean',
'build:base',
'build:src',
'build:web-inf',
'build:liferay-look-and-feel',
'build:hook',
'build:themelets',
'build:rename-css-dir',
'build:prep-css',
'build:compile-css',
'build:fix-url-functions',
'build:move-compiled-css',
'build:remove-old-css-dir',
'build:fix-at-directives',
'build:r2',
'build:war',
\end{verbatim}
\item
  Open your theme's \texttt{gulpfile.js} file and locate the
  \texttt{liferayThemeTasks.registerTasks()} method. This method
  registers the default gulp theme tasks. Add the \texttt{hookFn}
  property to the \texttt{registerTasks()} method's configuration
  object, making sure to pass in the \texttt{gulp} instance:

\begin{verbatim}
liferayThemeTasks.registerTasks({
  gulp: gulp,
  hookFn: function(gulp) {

  }
});
\end{verbatim}
\item
  Inside the \texttt{hookFn()} function, use the \texttt{gulp.hook()}
  method to specify the theme task or sub task that you want to hook
  into. You can inject your code before or after a task by prefixing it
  with the \texttt{before:} or \texttt{after:} keywords. Alternatively,
  you can use the \texttt{gulp.task()} method to overwrite a gulp task.
  Both methods have two parameters: the task or sub task you want to
  hook into and a callback function that invokes \texttt{done} or
  returns a stream with the logic that you want to inject. A few example
  configuration patterns are shown below:

\begin{verbatim}
liferayThemeTasks.registerTasks({
  gulp: gulp,
  hookFn: function(gulp) {
    gulp.hook('before:build:src', function(done) {
      // Fires before build:src task
    });

    gulp.hook('after:build', function(done) {
      // Fires after build task
    });

    gulp.task('build:base', function(done) {
      // Overwrites build:base task
    });
  }
});   
\end{verbatim}
\end{enumerate}

The example below fires before the \texttt{build:war} sub-task and reads
the JavaScript files in the theme's \texttt{build} folder, minifies them
with the \texttt{gulp-uglify} module, places them back in the
\texttt{./build/js} folder, invokes \texttt{done}, and finally logs that
the JavaScript was minified. To follow along, replace your theme's
\texttt{gulpfile.js} with the contents shown below, install the
\href{https://www.npmjs.com/package/gulp-uglify}{gulp-uglify} module and
the \href{https://www.npmjs.com/package/fancy-log}{fancy-log} module,
and run \texttt{gulp\ deploy}:

\begin{verbatim}
'use strict';

var gulp = require('gulp');
var log = require('fancy-log');
var uglify = require('gulp-uglify');
var liferayThemeTasks = require('liferay-theme-tasks');

liferayThemeTasks.registerTasks({
   gulp: gulp,
   hookFn: function(gulp) {
     gulp.hook('before:build:war', function(done) {
      // Fires before build `war` task
      gulp.src('./build/js/*.js')
      .pipe(uglify())
      .pipe(gulp.dest('./build/js'))
      .on('end', done);
      log('Your JS is now minified...');
      });
   }
});
\end{verbatim}

You should see something similar to the output shown below:

\begin{verbatim}
[15:58:07] Finished 'build:r2' after 198 ms
[15:58:07] Starting 'build:war'...
[15:58:07] Your JS is now minified...
[15:58:07] Starting 'plugin:version'...
[15:58:07] Finished 'plugin:version' after 2.52 ms
\end{verbatim}

\noindent\hrulefill

\textbf{Note:} The \texttt{hook} callback function must invoke the
\texttt{done} argument or return a stream.

\noindent\hrulefill

Now you know how to hook into and overwrite the default Liferay theme
tasks!

\subsection{Related Topics}\label{related-topics-111}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-themes}{Creating
Themes}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-reusable-pieces-of-code-for-your-themes}{Creating
Reusable Pieces of Code for Your Themes}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-developer-mode-with-themes}{Using
Developer Mode with Themes}

\section{Compiling and Building Themes with Ant, Gradle, and
Maven}\label{compiling-and-building-themes-with-ant-gradle-and-maven}

Liferay's Theme Builder gives developers who aren't using
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-themes}{Liferay's
Theme Generator} (e.g., Gradle or Maven) a way to compile and build a
theme WAR file. To use the Theme Builder, you must apply it to your
project. If you're unsure how to structure themes for Liferay DXP, see
the
\href{/docs/7-1/tutorials/-/knowledge_base/t/introduction-to-themes}{Introduction
to Themes} tutorial.

Follow the instructions below to apply the Theme Builder plugin and
build your theme WAR.

\subsection{Step 1: Apply the Theme Builder Plugin to Your Theme
Project}\label{step-1-apply-the-theme-builder-plugin-to-your-theme-project}

Liferay provides two Theme Builder plugins depending on your build tool:

\begin{itemize}
\tightlist
\item
  \href{https://repository.liferay.com/nexus/content/repositories/liferay-public-releases/com/liferay/com.liferay.portal.tools.theme.builder/}{com.liferay.portal.tools.theme.builder}
  (Ant, Maven, etc.)
\item
  \href{https://repository.liferay.com/nexus/content/repositories/liferay-public-releases/com/liferay/com.liferay.gradle.plugins.theme.builder/}{com.liferay.gradle.plugins.theme.builder}
  (Gradle)
\end{itemize}

If you want to apply the Theme Builder plugin to an Ant project, examine
the \texttt{build.xml} file as an example below:

\begin{verbatim}
<?xml version="1.0"?>
<!DOCTYPE project>

<project>
    <path id="theme.builder.classpath">
        <fileset dir="[PATH_TO_THEME_BUILDER_JAR]" includes="com.liferay.portal.tools.theme.builder-*.jar" />
    </path>

    <taskdef classpathref="theme.builder.classpath" resource="com/liferay/portal/tools/theme/builder/ant/taskdefs.properties" />

    <target name="build-theme">
        <build-theme
            diffsDir="diffs"
            outputDir="../dist"
            parentDir="[PATH_TO_STYLED_THEME]/classes/META-INF/resources/_styled"
            parentName="_styled"
            unstyledDir="[PATH_TO_UNSTYLED_THEME]/classes/META-INF/resources/_unstyled"
        />
    </target>
</project>
\end{verbatim}

You should first supply the path to the Theme Builder JAR. The above
code configures the literal path to the JAR on your local machine. As an
alternative, you could configure \href{http://ant.apache.org/ivy/}{Ivy}
to do this for you behind the scenes. Then create an Ant target (e.g.,
\texttt{build-theme}) that configures the required parameters to build
your theme.

For assistance applying the Theme Builder plugin for a Gradle or Maven
project, see the
\href{/docs/7-1/reference/-/knowledge_base/r/theme-builder-gradle-plugin}{Theme
Builder Gradle Plugin} or
\href{/docs/7-1/tutorials/-/knowledge_base/t/building-themes-in-a-maven-project}{Building
Themes in a Maven Project} articles, respectively.

\subsection{Step 2: Build Your Theme}\label{step-2-build-your-theme}

Execute the appropriate command based on your build tool:

\begin{itemize}
\tightlist
\item
  \emph{Ant:} \texttt{ant\ build-theme}
\item
  \emph{Gradle:} \texttt{gradlew\ buildTheme}
\item
  \emph{Maven:} \texttt{mvn\ verify}
\end{itemize}

The WAR is generated in the following folder, depending on the build
tool you used:

\begin{itemize}
\tightlist
\item
  \emph{Ant:} \texttt{/dist}
\item
  \emph{Gradle:} \texttt{/build}
\item
  \emph{Maven:} \texttt{/target}
\end{itemize}

That's it! You've successfully configured and leveraged the Theme
Builder in your project. You can also use the Theme Builder to migrate a
Plugins SDK theme to Liferay Workspace. See the
\href{/docs/7-0/tutorials/-/knowledge_base/t/migrating-a-theme-from-the-plugins-sdk-to-workspace}{Migrating
a Theme from the Plugins SDK to Workspace} tutorial for details.

\subsection{Related Topics}\label{related-topics-112}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-themes}{Creating
Themes}

\href{/docs/7-0/reference/-/knowledge_base/r/theme-template}{Theme
Template}

\section{Injecting Additional Context Variables and Functionality into
Your
Templates}\label{injecting-additional-context-variables-and-functionality-into-your-templates}

JSP templates are the predominant templating framework in Liferay DXP.
Themes, application display templates (ADTs), DDM templates, and more
make use of JSPs as a templating engine. JSPs, however, are not the only
templating language supported by Liferay DXP. Since many developers
prefer other templating frameworks (e.g., FreeMarker), Liferay DXP
enables you to use other template formats by offering the Context
Contributors framework.

Because JSPs are ``native'' to Java EE, they have access to all the
contextual objects inherent to the platform, like the request and the
session. Through these objects, developers can normally obtain Liferay
DXP-specific context information by accessing container objects like
\texttt{themeDisplay} or \texttt{serviceContext}.

Template formats like FreeMarker aren't native to Java EE, so they don't
have access to these objects. If your template needs contextual
information such as the current user, the page, or anything else, Java
EE won't make it available to the template like it does for JSPs: you
must inject it yourself into the template. Liferay DXP, however, gives
you a head start by injecting a \texttt{contextObjects} map of common
variables (e.g., \texttt{themeDisplay}, \texttt{locale}, \texttt{user},
etc.) by default into FreeMarker templates (e.g., themes). This map is
usually referred to as the \emph{context} of a template. If you need to
access some other context object that Liferay DXP doesn't provide by
default, you must modify or add to a template's context. To do that, you
create a context contributor.

Context contributors modify a template's context by injecting variables
and functionality usable by the template framework. This lets you use
non-JSP templating languages for themes, ADTs, and any other templates
used in Liferay DXP. For example, suppose you want your theme to change
color based on the user's organization. You could create a context
contributor to inject the user's organization to your theme's context,
and then determine the theme's color based on that information.

Context contributors are already used in Liferay DXP by default. Liferay
DXP's Product Menu display is determined by a variable injected by a
context contributor. You'll learn more about this later.

First, you'll learn how to create your own context contributor, and then
you'll examine one example of how Liferay DXP uses context contributors.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a generic OSGi module using your favorite third party tool, or
  use \href{/docs/7-1/tutorials/-/knowledge_base/t/blade-cli}{Blade
  CLI}.
\item
  Create a unique package name in the module's \texttt{src} directory
  and create a new Java class in that package. To follow naming
  conventions, begin the class name with the entity you want to inject
  context-specific variables for, followed by
  \emph{TemplateContextContributor} (e.g.,
  \texttt{ProductMenuTemplateContextContributor}).
\item
  Directly above the class's declaration, insert the following
  annotation:

\begin{verbatim}
@Component(
    immediate = true,
    property = {"type=" + TemplateContextContributor.[Type of Contributor]},
    service = TemplateContextContributor.class
)
\end{verbatim}

  The \texttt{immediate} element instructs the module to start
  immediately once deployed to Liferay DXP. The \texttt{type} property
  should be set to one of the two fields defined in the
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/template/TemplateContextContributor.html}{TemplateContextContributor}
  interface: \texttt{TYPE\_GLOBAL} or \texttt{TYPE\_THEME}. The
  \texttt{TYPE\_THEME} field should be set if you only wish to inject
  context-specific variables for your theme; otherwise, setting the
  \texttt{TYPE\_GLOBAL} field affects every context execution in Liferay
  DXP, like themes, ADTs, DDM templates, etc. Finally, your
  \texttt{service} element should be set to
  \texttt{TemplateContextContributor.class}.

  The \texttt{ProductMenuTemplateContextContributor} class's
  \texttt{@Component} annotation follows a similar layout:

\begin{verbatim}
@Component(
    immediate = true,
    property = {"type=" + TemplateContextContributor.TYPE_THEME},
    service = TemplateContextContributor.class
)
\end{verbatim}
\item
  Implement the
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/template/TemplateContextContributor.html}{TemplateContextContributor}
  interface in your \texttt{-TemplateContextContributor} class. This
  only requires implementing the
  \texttt{prepare(Map\textless{}String,Object\textgreater{},\ HttpServletRequest)}
  method.

  Notice that the \texttt{prepare} method receives the
  \texttt{contextObjects} map as a parameter. This is your template's
  context that was described earlier. This method should be used to edit
  the context by injecting new or modified variables into the
  \texttt{contextObjects} map.
\end{enumerate}

For a quick example of how you can implement the
\texttt{TemplateContextContributor} interface to inject variables into a
template's context, examine the
\texttt{ProductMenuTemplateContextContributor} class used by Liferay DXP
by default. This class injects variables into Liferay DXP's FreeMarker
theme and determines whether the Product Menu is displayed in the
current theme.

The \texttt{ProductMenuTemplateContextContributor} class implements the
\texttt{prepare(...)} method, which injects a modified variable
(\texttt{bodyCssClass}) and a new variable
(\texttt{liferay\_product\_menu\_state}) into the theme context:

\begin{verbatim}
@Override
public void prepare(
    Map<String, Object> contextObjects, HttpServletRequest request) {

    if (!isShowProductMenu(request)) {
        return;
    }

    String cssClass = GetterUtil.getString(
        contextObjects.get("bodyCssClass"));
    String productMenuState = SessionClicks.get(
        request,
        ProductNavigationProductMenuWebKeys.
            PRODUCT_NAVIGATION_PRODUCT_MENU_STATE,
        "closed");

    contextObjects.put(
        "bodyCssClass", cssClass + StringPool.SPACE + productMenuState);

    contextObjects.put("liferay_product_menu_state", productMenuState);
}
\end{verbatim}

This method prepares the context contributor to inject variables into
the theme to be used by the Product Menu. For this example, the
\texttt{cssClass} and \texttt{productMenuState} variables are defined
and then placed in the \texttt{contextObjects} map. By doing this, these
variables have been injected into the theme context, making them
accessible to the theme. Specifically, the \texttt{cssClass} variable
provides styling for the Product Menu and the \texttt{productMenuState}
variable determines whether the visible Product Menu should be open or
closed.

The \texttt{prepare} method above also determines whether to show the
Product Menu or not with the following if statement:

\begin{verbatim}
if (!isShowProductMenu(request)) {
    return;
}
\end{verbatim}

The \texttt{isShowProductMenu(...)} method injects functionality into
the theme's context by providing an option to show/hide the Product
Menu. This method is also included in the
\texttt{ProductMenuTemplateContextContributor} class:

\begin{verbatim}
protected boolean isShowProductMenu(HttpServletRequest request) {
    ThemeDisplay themeDisplay = (ThemeDisplay)request.getAttribute(
        WebKeys.THEME_DISPLAY);

    if (themeDisplay.isImpersonated()) {
        return true;
    }

    if (!themeDisplay.isSignedIn()) {
        return false;
    }

    User user = themeDisplay.getUser();

    if (!user.isSetupComplete()) {
        return false;
    }

    return true;
}
\end{verbatim}

The \texttt{ProductMenuTemplateContextContributor} provides an easy way
to inject variables into Liferay DXP's theme directly related to the
Product Menu. You can do the same with your custom context contributor.
With the power to inject additional variables to any context in Liferay
DXP, you're free to fully harness the power of your chosen templating
language.

\subsection{Related Topics}\label{related-topics-113}

\href{/docs/7-1/tutorials/-/knowledge_base/t/customizing-the-product-menu}{Customizing
the Product Menu}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-themes}{Creating
Themes}

\href{/docs/7-1/tutorials/-/knowledge_base/t/packaging-independent-ui-resources-for-your-site}{Theme
Contributors}

\section{Packaging Independent UI Resources for Your
Site}\label{packaging-independent-ui-resources-for-your-site}

If you want to package UI resources independent of a specific theme and
include them on a Liferay DXP page, Theme Contributors are your best
option. If, instead, you'd like to include separate UI resources on a
Liferay DXP page that are attached to a theme, you should look into
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-reusable-pieces-of-code-for-your-themes}{themelets}.

A Theme Contributor is a
\href{/docs/7-1/tutorials/-/knowledge_base/t/fundamentals\#modules}{module}
that contains UI resources to use in Liferay DXP. Once a Theme
Contributor is deployed to Liferay DXP, it's scanned for all valid CSS
and JS files, and then its resources are included on the page. You can,
therefore, style these UI components as you like, and the styles are
applied for the current theme.

This tutorial demonstrates how to

\begin{itemize}
\tightlist
\item
  Identify a Theme Contributor module.
\item
  Create a Theme Contributor module.
\end{itemize}

Next, you'll learn how to create a Theme Contributor.

\subsection{Creating Theme
Contributors}\label{creating-theme-contributors}

The standard UI for User menus and navigation are packaged as Theme
Contributors. For example, the Control Menu, Product Menu, and
Simulation Panel are packaged as Theme Contributor modules in Liferay
DXP, separating them from the theme. This means that these UI components
must be handled outside the theme.

\begin{figure}
\centering
\includegraphics{./images/theme-contributor-menus-diagram.png}
\caption{The Control Menu, Product Menu, and Simulation Panel are
packaged as Theme Contributor modules.}
\end{figure}

If you want to edit or style these standard UI components, you'll need
to create your own Theme Contributor and add your modifications on top.
You can also add new UI components to Liferay DXP by creating a Theme
Contributor.

To create a Theme Contributor module, follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a generic OSGi module using your favorite third party tool, or
  use \href{/docs/7-1/tutorials/-/knowledge_base/t/blade-cli}{Blade
  CLI}. You can also use the
  \href{/docs/7-1/reference/-/knowledge_base/r/theme-contributor-template}{Blade
  Template} to create your module, in which case you can skip step 2.
\item
  To identify your module as a Theme Contributor, add the
  \texttt{Liferay-Theme-Contributor-Type} and \texttt{Web-ContextPath}
  headers to your module's \texttt{bnd.bnd} file. For example, see the
  \href{https://search.maven.org/search?q=a:com.liferay.product.navigation.control.menu.theme.contributor}{Control
  Menu module's} \texttt{bnd.bnd}:

\begin{verbatim}
Bundle-Name: Liferay Product Navigation Product Menu Theme Contributor
Bundle-SymbolicName: com.liferay.product.navigation.product.menu.theme.contributor
Bundle-Version: 3.0.4
Liferay-Theme-Contributor-Type: product-navigation-product-menu
Web-ContextPath: /product-navigation-product-menu-theme-contributor
\end{verbatim}

  The Theme Contributor type helps Liferay DXP better identify your
  module. For example, if you're creating a Theme Contributor to
  override an existing Theme Contributor, you should try to use the same
  type to maximize compatibility with future developments. The
  \texttt{Web-ContextPath} header sets the context from which the Theme
  Contributor's resources are hosted.
\item
  Because you'll often be overriding CSS of another Theme Contributor,
  you should load your CSS after theirs. You can do this by setting a
  weight for your Theme Contributor. In your \texttt{bnd.bnd} file, add
  the following header:

\begin{verbatim}
Liferay-Theme-Contributor-Weight: [value]
\end{verbatim}

  The higher the value, the higher the priority. If your Theme
  Contributor has a weight of 100, it will be loaded after one with a
  weight of 99, allowing your CSS to override theirs.
\item
  Create a \texttt{src/main/resources/META-INF/resources} folder in your
  module and place your resources (CSS and JS) in that folder.
\item
  Build and deploy your module to see your modifications applied to
  Liferay DXP pages and themes.
\end{enumerate}

That's all you need to do to create a Theme Contributor for your site.
Remember, with great power comes great responsibility, so use Theme
Contributors wisely. The UI contributions affect every page and aren't
affected by theme deployments.

\subsection{Related Topics}\label{related-topics-114}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-themes}{Creating
Themes}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-reusable-pieces-of-code-for-your-themes}{Themelets}

\href{/docs/7-1/tutorials/-/knowledge_base/t/importing-resources-with-a-theme}{Importing
Resources with Your Themes}

\href{/docs/7-1/reference/-/knowledge_base/r/theme-contributor-template}{Theme
Contributor Template}

\section{Using Liferay DXP's Macros in Your
Theme}\label{using-liferay-dxps-macros-in-your-theme}

\href{https://freemarker.apache.org/docs/ref_directive_macro.html}{Macros}
can assign theme template fragments to a variable. This keeps your theme
templates from becoming cluttered and makes them easier to read. Liferay
DXP defines several macros in
\href{https://github.com/liferay/liferay-portal/blob/7.1.x/modules/apps/portal-template/portal-template-freemarker/src/main/resources/FTL_liferay.ftl}{\texttt{FTL\_Liferay.ftl}
template} that you can use in your FreeMarker theme templates to include
theme resources, standard portlets, and more. Liferay DXP also exposes
its taglibs as FreeMarker macros. See the corresponding
\href{/docs/7-1/tutorials/-/knowledge_base/t/front-end-taglibs}{taglib
tutorial} for more information on using the taglib in your FreeMarker
templates. This tutorial shows how to use macros in your FreeMarker
theme templates.

Follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Select one of the macros shown in the table below:
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 Macro | Parameters | Description | Example |
 --- | --- | --- | --- |
 breadcrumbs | default_preferences | Adds the Breadcrumbs portlet with optional preferences | `<@liferay.breadcrumbs />` |
 control_menu | N/A | Adds the Control Menu portlet | `<@liferay.control_menu />` |
 css | file_name | Adds an external stylesheet with the specified file name location | `<@liferay.css file_name="${css_folder}/mycss.css"/>` |
 date | format | Prints the date in the current locale with the given format | `<@liferay.date format="/yyyy/MM/dd/HH/" />` |
 js | file_name | Adds an external JavaScript file with the specified file name source | `<@liferay.js file_name="${javascript_folder}/myJs.js"/>` |
 language | key | Prints the specified language key in the current locale | `<@liferay.language key="last-modified" />` |
 language_format | arguments<br/>key | Formats the given language key with the specified arguments. For example, passing `go-to-x` as the key and `Mars` as the arguments prints *Go to Mars*. | `<@liferay.language_format arguments="${site_name}" key="go-to-x" />` |
 languages | default_preferences | Adds the Languages portlet with optional preferences | `<@liferay.languages />` |
 navigation_menu | default_preferences<br/>instance_id | Adds the Navigation Menu portlet with optional preferences and instance ID. | `<@liferay.navigation_menu />` |
 search | default_preferences | Adds the Search portlet with optional preferences | `<@liferay.search />` |
 search_bar | default_preferences | Adds the Search Bar portlet with optional preferences | `<@liferay.search_bar />` |
 user_personal_bar | N/A | Adds the User Personal Bar portlet | `<@liferay.user_personal_bar />` |
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\item
  Call the macro in your theme template. Liferay DXP's default
  FreeMarker macro calls are namespaced with \texttt{liferay}. For
  example, to include the Search Bar portlet, you would add the macro
  call shown below:

\begin{verbatim}
<@liferay.search_bar>
\end{verbatim}
\item
  Include any required or optional arguments, such as
  \href{/docs/7-1/tutorials/-/knowledge_base/t/embedding-portlets-in-themes\#setting-default-preferences-for-an-embedded-portlet}{portlet
  preferences}, in the macro call. For example, Liferay DXP's
  \texttt{language} macro directive includes a language key parameter:

\begin{verbatim}
<#macro language
  key
>
  ${languageUtil.get(locale, key)}
</#macro>
\end{verbatim}

  You can pass an argument in the macro call like this:

\begin{verbatim}
<@liferay.language key="powered-by" />
\end{verbatim}

  The example below sets the Search portlet's
  \href{/docs/7-1/tutorials/-/knowledge_base/t/creating-configurable-styles-for-portlet-wrappers}{Portlet
  Decorator} to barebone:

\begin{verbatim}
<@liferay.search default_preferences=
  freeMarkerPortletPreferences.getPreferences(
    "portletSetupPortletDecoratorId", "barebone"
  ) 
/>
\end{verbatim}

  You can also pass multiple portlet preferences in an object, as shown
  in the example below for the Navigation Menu portlet:

\begin{verbatim}
<#assign secondaryNavigationPreferencesMap = 
  {
    "displayStyle": "ddmTemplate_NAVBAR-BLANK-JUSTIFIED-FTL", 
    "portletSetupPortletDecoratorId": "barebone", 
    "rootLayoutType": "relative", 
    "siteNavigationMenuId": "0", 
    "siteNavigationMenuType": "1"
  } 
/>

<@liferay.navigation_menu
  default_preferences=
  freeMarkerPortletPreferences.getPreferences(secondaryNavigationPreferencesMap)
  instance_id="main_navigation_menu"
/>
\end{verbatim}
\end{enumerate}

\noindent\hrulefill

\textbf{Note:} Portlet preferences are unique to each portlet, so first
you must determine which preferences you want to configure. There are
two ways to determine the proper key/value pair for a portlet
preference. The first is to set the portlet preference manually, and
then check the values in the \texttt{portletPreferences.preferences}
column of the database as a hint for what to configure.

Another approach is to search each app in your bundle for the keyword
\texttt{preferences-\/-}. This returns app JSPs that have the portlet
preferences defined for the portlet.

\noindent\hrulefill

Now you know how to use Liferay DXP's macros in your theme templates!

\subsection{Related Topics}\label{related-topics-115}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-themes}{Creating
Themes}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-reusable-pieces-of-code-for-your-themes}{Creating
Reusable Pieces of Code for Your Themes}

\href{/docs/7-1/reference/-/knowledge_base/r/theme-reference-guide}{Theme
Reference Guide}

\chapter{Importing Resources with a
Theme}\label{importing-resources-with-a-theme}

To truly appreciate a theme, you must view it with content. Showcasing a
theme in the proper context is key to communicating the true intentions
of its design. Who better to do this than the theme's designer?
Designers can provide a sample context that optimizes the design of
their themes. The Resources Importer does this for you.

\noindent\hrulefill

\textbf{Note:} The Resources Importer is deprecated as of 7.0.

\noindent\hrulefill

The Resources Importer module lets theme developers import files and web
content with a theme. Administrators can use the site or site template
created by the Resources Importer to showcase the theme. In fact, all
standalone themes that are uploaded to Liferay Marketplace \textbf{must
use} the Resources Importer. This ensures a uniform experience for
Marketplace users: a user can download a theme from Marketplace, install
it, go to Sites or Site Templates in the Control Panel and immediately
see their new theme in action.

Using the Resources Importer involves the following steps:

\begin{itemize}
\tightlist
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/preparing-and-organizing-web-content-for-the-resources-importer}{Preparing
  and Organizing Resources}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/creating-a-sitemap-for-the-resources-importer}{Creating
  a Sitemap for the Resources Importer}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/defining-assets-for-the-resources-importer}{Defining
  Assets for the Resources Importer} (optional)
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/specifying-where-to-import-your-themes-resources}{Specifying
  Where to Import Your Theme's Resources}
\end{itemize}

This section of tutorials explains how to use the Resources Importer to
import resources with your theme.

\section{Preparing and Organizing Web Content for the Resources
Importer}\label{preparing-and-organizing-web-content-for-the-resources-importer}

You must create the resources to import with your theme. You can create
resources from scratch and/or bring in resources that you've already
created. This tutorial covers how to prepare and organize your resources
for the Resources Importer.

First, you must prepare your web content for the Resources Importer.

\subsection{Preparing Your Web
Content}\label{preparing-your-web-content}

You can leverage your HTML (basic web content), JSON (structures), or VM
or FTL (templates) files with the Resource Importer. All web content
articles require a structure and template. Note that some articles may
share the same structure and perhaps even the same template---this is
the case for all basic web content articles. Follow these steps to
prepare your web content articles:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Select \emph{Edit} from the article's options menu, click the
  \emph{Options} icon at the top right of the page and select \emph{View
  Source}. Copy the article's raw XML into an XML file locally. Create a
  folder for the article under
  \texttt{resources-importer/journal/articles/} and rename it as
  desired. The web content article's XML fills in the data required by
  the structure. An example web content article's XML is shown below:

\begin{verbatim}
<?xml version="1.0"?>

<root available-locales="en_US" default-locale="en_US">
  <dynamic-element name="content" type="text_area" index-type="keyword" index="0">
    <dynamic-content language-id="en_US">
        <![CDATA[
            <center>
            <p><img alt="" src="[$FILE=space-program-history.jpg$]" /></p>
            </center>

            <p>In the mid-20th century, after two of the 
            most violent wars in history, mankind turned 
            its gaze upwards to the stars. Instead of 
            continuing to strive against one another, 
            man choose instead to strive against the 
            limits that we had bound ourselves to. And 
            so the Great Space Race began.</p>

            <p>At first the race was to reach space--get 
            outside the earth's atmosphere, and when 
            that had been reached, we shot for the moon. 
            After sending men to the moon, robots to 
            Mars, and probes beyond the reaches of our 
            solar system, it seemed that there was 
            nowhere left to go.</p>

            <p>The Space Program aims to change that. 
            Beyond national boundaries, beyond what 
            anyone can imagine that we can do. The sky 
            is not the limit.</p>
        ]]>
    </dynamic-content>
  </dynamic-element>
</root>
\end{verbatim}
\item
  Download the web content article's structure. Open the structure and
  click the \emph{Source} tab to view the structure's file. Copy and
  paste its contents into a new JSON file in the
  \texttt{resources-importer/journal/structures/} folder. The structure
  JSON sets a wireframe, or blueprint, for an article's data. If you're
  saving a basic web content article, you can copy the structure below
  (replace \texttt{en\_US} with your language):

\begin{verbatim}
{
    "availableLanguageIds": [
        "en_US"
    ],
    "defaultLanguageId": "en_US",
    "fields": [
        {
            "label": {
                "en_US": "Content"
            },
            "predefinedValue": {
                "en_US": ""
            },
            "style": {
                "en_US": ""
            },
            "tip": {
                "en_US": ""
            },
            "dataType": "html",
            "fieldNamespace": "ddm",
            "indexType": "text",
            "localizable": true,
            "name": "content",
            "readOnly": false,
            "repeatable": false,
            "required": false,
            "showLabel": true,
            "type": "ddm-text-html"
        }
    ]
}
\end{verbatim}
\item
  Download the structure's matching template. Open the Actions menu for
  the structure and select \emph{Manage Templates} to view the templates
  that use it. Create a folder for the template under
  \texttt{resources-importer/journal/templates/} and copy and paste its
  contents into a new FTL file. The template defines how the data should
  be displayed. If you're saving a basic web content article, you can
  copy the FreeMarker template below:

\begin{verbatim}
${content.getData()}
\end{verbatim}
\end{enumerate}

Repeat the steps above for each web content article you have. Note that
some web content articles may share the same structure and template; In
these cases, only one copy of the structure and template is required for
all web content articles that use them. Once your web content articles
are saved, you can place them in their proper folder structure.

\subsection{Organizing Your Resources}\label{organizing-your-resources}

Add your resources under the
\texttt{{[}theme-name{]}/src/WEB-INF/src/resources-importer} folder and
its subfolders. Place your resources in the folders outlined below:

\begin{itemize}
\tightlist
\item
  \texttt{{[}theme-name{]}/src/WEB-INF/src/resources-importer/}

  \begin{itemize}
  \tightlist
  \item
    \texttt{sitemap.json} - defines the pages, layout templates, and
    portlets
  \item
    \texttt{assets.json} - (optional) specifies details on the assets
  \item
    \texttt{document\_library/}

    \begin{itemize}
    \tightlist
    \item
      \texttt{documents/} - contains documents and media files (assets)
    \end{itemize}
  \item
    \texttt{journal/}

    \begin{itemize}
    \tightlist
    \item
      \texttt{articles/} - contains web content (HTML) and folders
      grouping web content articles (XML) by template. Each folder name
      must match the file name of the corresponding template. For
      example, create folder \texttt{Template\ 1/} to hold an article
      based on template file \texttt{Template\ 1.ftl}.
    \item
      \texttt{structures/} - contains structures (JSON) and folders of
      child structures. Each folder name must match the file name of the
      corresponding parent structure. For example, create folder
      \texttt{Structure\ 1/} to hold a child of structure file
      \texttt{Structure\ 1.json}.
    \item
      \texttt{templates/} - groups templates (VM or FTL) into folders by
      structure. Each folder name must match the file name of the
      corresponding structure. For example, create folder
      \texttt{Structure\ 1/} to hold a template for structure file
      \texttt{Structure\ 1.json}.
    \end{itemize}
  \end{itemize}
\end{itemize}

\subsection{Related Topics}\label{related-topics-116}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-a-sitemap-for-the-resources-importer}{Creating
a Sitemap for the Resources Importer}

\href{/docs/7-1/tutorials/-/knowledge_base/t/defining-assets-for-the-resources-importer}{Defining
Assets for the Resources Importer}

\href{/docs/7-1/tutorials/-/knowledge_base/t/specifying-where-to-import-your-themes-resources}{Specifying
Where to Import Your Theme's Resources}

\chapter{Creating a Sitemap for the Resources
Importer}\label{creating-a-sitemap-for-the-resources-importer}

You have two options for specifying resources to be imported with your
theme: a sitemap or an
\href{/docs/7-1/tutorials/-/knowledge_base/t/archiving-your-sites-resources}{archive
LAR file}. Using a \texttt{sitemap.json} file is the most flexible
approach, so we recommend it; unlike LAR files, a \texttt{sitemap.json}
can be created in one version of Liferay DXP and used in another. LAR
files are version-specific, and can only be imported in the same version
in which they were created.

The \texttt{sitemap.json} specifies the site pages, layout templates,
web content, assets, and portlet configurations provided with the theme.
This file describes the contents and hierarchy of the site to import as
a site or site template. If you're developing themes for Liferay
Marketplace, you must use the \texttt{sitemap.json} to specify resources
to be imported with your theme. Even if you're not familiar with JSON,
the \texttt{sitemap.json} file is easy to understand. An example
\texttt{sitemap.json} file is shown below:

\begin{verbatim}
{
    "layoutTemplateId": "2_columns_ii",
    "privatePages": [
        {
            "friendlyURL": "/private-page",
            "name": "Private Page",
            "title": "Private Page"
        }
    ],
    "publicPages": [
        {
            "columns": [
                [
                    {
                        "portletId": "com_liferay_login_web_portlet_LoginPortlet"
                    },
                    {
                        "portletId": 
                        "com_liferay_site_navigation_menu_web_portlet_SiteNavigationMenuPortlet"
                    },
                    {
                        "portletId": 
                        "com_liferay_journal_content_web_portlet_JournalContentPortlet",
                        "portletPreferences": {
                            "articleId": "Without Border.html",
                            "groupId": "${groupId}",
                            "portletSetupPortletDecoratorId": "borderless"
                        }
                    },
                    {
                        "portletId": "com_liferay_journal_content_web_portlet_JournalContentPortlet",
                        "portletPreferences": {
                            "articleId": "Custom Title.html",
                            "groupId": "${groupId}",
                            "portletSetupPortletDecoratorId": "decorate",
                            "portletSetupTitle_en_US": "Web Content Display with Custom Title",
                            "portletSetupUseCustomTitle": "true"
                        }
                    }
                ],
                [
                    {
                        "portletId": "com_liferay_hello_world_web_portlet_HelloWorldPortlet"
                    },
                    {
                        "portletId": 
                        "com_liferay_site_navigation_menu_web_portlet_SiteNavigationMenuPortlet_INSTANCE_${groupId}",
                        "portletPreferences": {
                            "displayStyle": "[custom]",
                            "headerType": "root-layout",
                            "includedLayouts": "all",
                            "nestedChildren": "1",
                            "rootLayoutLevel": "3",
                            "rootLayoutType": "relative"
                        }
                    },
                        "Web Content with Image.html",
                    {
                        "portletId": "com_liferay_nested_portlets_web_portlet_NestedPortletsPortlet",
                        "portletPreferences": {
                            "columns": [
                                [
                                    {
                                        "portletId": 
                                        "com_liferay_journal_content_web_portlet_JournalContentPortlet",
                                        "portletPreferences": {
                                            "articleId": "Child Web Content 1.xml",
                                            "groupId": "${groupId}",
                                            "portletSetupPortletDecoratorId": "decorate",
                                            "portletSetupTitle_en_US": 
                                            "Web Content Display with Child Structure 1",
                                            "portletSetupUseCustomTitle": "true"
                                        }
                                    }
                                ],
                                [
                                    {
                                        "portletId": 
                                        "com_liferay_journal_content_web_portlet_JournalContentPortlet",
                                        "portletPreferences": {
                                            "articleId": "Child Web Content 2.xml",
                                            "groupId": "${groupId}",
                                            "portletSetupPortletDecoratorId": "decorate",
                                            "portletSetupTitle_en_US": 
                                            "Web Content Display with Child Structure 2",
                                            "portletSetupUseCustomTitle": "true"
                                        }
                                    }
                                ]
                            ],
                            "layoutTemplateId": "2_columns_i"
                        }
                    }
                ]
            ],
            "friendlyURL": "/home",
            "nameMap": {
                "en_US": "Welcome",
                "fr_FR": "Bienvenue"
            },
            "title": "Welcome"
        },
        {
            "columns": [
                [
                    {
                        "portletId": "com_liferay_login_web_portlet_LoginPortlet"
                    }
                ],
                [
                    {
                        "portletId": "com_liferay_hello_world_web_portlet_HelloWorldPortlet"
                    }
                ]
            ],
            "friendlyURL": "/layout-prototypes-parent-page", 
            "layouts": [
                {
                    "friendlyURL": "/layout-prototypes-page-1",
                    "layoutPrototypeLinkEnabled": "true",
                    "layoutPrototypeUuid": "371647ba-3649-4039-bfe6-ae32cf404737",
                    "name": "Layout Prototypes Page 1",
                    "title": "Layout Prototypes Page 1"
                },
                {
                    "friendlyURL": "/layout-prototypes-page-2",
                    "layoutPrototypeUuid": "c98067d0-fc10-9556-7364-238d39693bc4",
                    "name": "Layout Prototypes Page 2",
                    "title": "Layout Prototypes Page 2"
                }
            ],
            "name": "Layout Prototypes",
            "title": "Layout Prototypes"
        },
        {
            "columns": [
                [
                    {
                        "portletId": "com_liferay_login_web_portlet_LoginPortlet"
                    }
                ],
                [
                    {
                        "portletId": "com_liferay_hello_world_web_portlet_HelloWorldPortlet"
                    }
                ]
            ],
            "friendlyURL": "/parent-page",
            "layouts": [
                {
                    "friendlyURL": "/child-page-1",
                    "name": "Child Page 1",
                    "title": "Child Page 1"
                },
                {
                    "friendlyURL": "/child-page-2",
                    "name": "Child Page 2",
                    "title": "Child Page 2"
                }
            ],
            "name": "Parent Page",
            "title": "Parent Page"
        },
        {
            "friendlyURL": "/url-page",
            "name": "URL Page",
            "title": "URL Page",
            "type": "url"
        },
        {
            "friendlyURL": "/link-page",
            "name": "Link to another Page",
            "title": "Link to another Page",
            "type": "link_to_layout",
            "typeSettings": "linkToLayoutId=1"
        },
        {
            "friendlyURL": "/hidden-page",
            "name": "Hidden Page",
            "title": "Hidden Page",
            "hidden": "true"
        }
    ]
}
\end{verbatim}

If you don't understand the sitemap at this point, don't worry. This
section of tutorials covers how to create a sitemap for your theme, from
\href{/docs/7-1/tutorials/-/knowledge_base/t/defining-pages-in-a-sitemap}{defining
pages} to
\href{/docs/7-1/tutorials/-/knowledge_base/t/defining-portlets-in-a-sitemap}{defining
portlets}.

\section{Defining Layout Templates in a
Sitemap}\label{defining-layout-templates-in-a-sitemap}

The first thing you should declare in your \texttt{sitemap.json} file is
a default layout template ID so the target site or site template can
reference the layout template to use for its pages. When defined outside
the scope of a page, the \texttt{layoutTemplateId} sets the default
layout template for the theme's pages:

\begin{verbatim}
{
  "layoutTemplateId": "2_columns_ii",
  "publicPages": [
    {
      "friendlyURL": "/my-page",
      "name": "My Page",
      "title": "My Page"
    }
  ]  
}
\end{verbatim}

When placed inside a page configuration, the \texttt{layoutTemplateId}
sets the layout template for the individual page. In the example below,
the Hidden Page and the Welcome page both use the default
\texttt{2\_columns\_ii} layout template, while the Custom Layout Page
overrides the default layout template and uses the
\texttt{2\_columns\_i} layout template instead:

\begin{verbatim}
{
  "layoutTemplateId":"2_columns_ii",
  "publicPages": [
      {
        "friendlyURL": "/welcome-page",
        "name": "Welcome",
        "title": "Welcome"
      },
      {
        "friendlyURL": "/custom-layout-page",
        "name": "Custom Layout Page",
        "title": "Custom Layout Page",
        "layoutTemplateId": "2_columns_i"
      },
      {
        "friendlyURL": "/hidden-page",
        "name": "Hidden Page",
        "title": "Hidden Page",
        "hidden": "true"
      }
  ]
}
\end{verbatim}

\subsection{Related Topics}\label{related-topics-117}

\href{/docs/7-1/tutorials/-/knowledge_base/t/preparing-and-organizing-web-content-for-the-resources-importer}{Preparing
and Organizing Web Content for the Resources Importer}

\href{/docs/7-1/tutorials/-/knowledge_base/t/defining-portlets-in-a-sitemap}{Defining
Portlets in a Sitemap}

\href{/docs/7-1/tutorials/-/knowledge_base/t/specifying-where-to-import-your-themes-resources}{Specifying
Where to Import Your Theme's Resources}

\section{Defining Pages in a Sitemap}\label{defining-pages-in-a-sitemap}

A sitemap defines the layouts---pages---that your site or site template
uses. This tutorial covers the configuration options that are available
for pages in a sitemap.

\noindent\hrulefill

\textbf{Note:} Pages are imported into a site template by default. Site
templates only support the importing of either public page sets or
private page sets, not both.

If you want to import both public and private page sets, as shown in the
example \texttt{sitemap.json} below, you must
\href{/docs/7-1/tutorials/-/knowledge_base/t/specifying-where-to-import-your-themes-resources\#importing-resources-into-existing-site-templates-and-sites}{import
your resources into a site}.

\noindent\hrulefill

You can specify a name for a page, title, friendly URL, whether it is
hidden, and much more. The example below defines a
\href{/docs/7-1/tutorials/-/knowledge_base/t/defining-layout-templates-in-a-sitemap}{default
layout template} and both public and private page sets to import into a
site:

\begin{verbatim}
{
  "layoutTemplateId": "2_columns_ii",
  "privatePages": [
      {
        "friendlyURL": "/private-page",
            "name": "Private Page",
            "title": "Private Page"
      }
  ],
  "publicPages": [
      {
        "friendlyURL": "/welcome-page",
        "nameMap": {
            "en_US": "Welcome",
            "fr_FR": "Bienvenue"
        },
        "title": "Welcome"
      },
      {
        "friendlyURL": "/custom-layout-page",
        "name": "Custom Layout Page",
        "title": "Custom Layout Page",
        "layoutTemplateId": "2_columns_i"
      },
      {
        "friendlyURL": "/hidden-page",
        "name": "Hidden Page",
        "title": "Hidden Page",
        "hidden": "true"
      }
  ]
}
\end{verbatim}

You can create child pages by configuring the \texttt{layouts} element
for a page configuration:

\begin{verbatim}
{      
"friendlyURL": "/parent-page",
"layouts": [
    {
        "friendlyURL": "/child-page-1",
        "name": "Child Page 1",
        "title": "Child Page 1"
    },
    {
        "friendlyURL": "/child-page-2",
        "name": "Child Page 2",
        "title": "Child Page 2"
    }
],
"name": "Parent Page",
"title": "Parent Page"
}
\end{verbatim}

These examples use some of the available page configuration attributes.
The full list is shown below.

\textbf{colorSchemeId:} Specifies a different color scheme (by ID) than
the default color scheme to use for the page.

\textbf{columns:} Specifies the column contents for the page.

\textbf{friendlyURL:} Sets the page's friendly URL.

\textbf{hidden:} Sets whether the page is hidden.

\textbf{layoutCss:} Sets custom CSS for the page to load after the
theme.

\textbf{layoutPrototypeLinkEnabled:} Sets whether the page inherits
changes made to the page template (if the page has one).

\textbf{layoutPrototypeName:} Specifies the page template (by name) to
use for the page. If this is defined, the page template's UUID is
retrieved using the name, and \texttt{layoutPrototypeUuid} is not
required.

\textbf{layoutPrototypeUuid:} Specifies the page template (by UUID) to
use for the page. If \texttt{layoutPrototypeName} is defined, this is
not required.

\textbf{layouts:} Specifies child pages for a page set.

\textbf{name:} The page's name.

\textbf{nameMap:} Passes a name object with multiple name key/value
pairs. You can use this to pass translations for a page's title, as
shown in the example above.

\textbf{privatePages:} Specifies private pages.

\textbf{publicPages:} Specifies public pages.

\textbf{themeId:} Specifies a different theme (by ID) than the default
theme bundled with the \texttt{sitemap.json} to use for the page.

\textbf{title:} The page's title.

\textbf{type:} Sets the page type. The default value is \texttt{portlet}
(empty page). Possible values are \texttt{copy} (copy of a page of this
site), \texttt{embedded}, \texttt{full\_page\_application},
\texttt{link\_to\_layout}, \texttt{node} (page set), \texttt{panel},
\texttt{portlet}, and \texttt{url} (link to URL).

\textbf{typeSettings:} Specifies settings (using key/value pairs) for
the page \texttt{type}.

\subsection{Related Topics}\label{related-topics-118}

\href{/docs/7-1/tutorials/-/knowledge_base/t/preparing-and-organizing-web-content-for-the-resources-importer}{Preparing
and Organizing Web Content for the Resources Importer}

\href{/docs/7-1/tutorials/-/knowledge_base/t/defining-layout-templates-in-a-sitemap}{Defining
Layout Templates in a Sitemap}

\href{/docs/7-1/tutorials/-/knowledge_base/t/specifying-where-to-import-your-themes-resources}{Specifying
Where to Import Your Theme's Resources}

\section{Defining Portlets in a
Sitemap}\label{defining-portlets-in-a-sitemap}

You can embed portlets in a sitemap for the pages you define. You can
embed them with the default settings or provide portlet preferences for
a more custom look and feel. This tutorial covers both these options.

Follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Note the portlet's ID. This is the \texttt{javax.portlet.name}
  attribute of the portlet spec. For convenience, The IDs for portlets
  available out-of-the-box are listed in the
  \href{/docs/7-1/reference/-/knowledge_base/r/fully-qualified-portlet-ids}{Fully
  Qualified Portlet IDs} reference guide. For custom portlets, this
  property is listed in the portlet class as the
  \texttt{javax.portlet.name=} service property.
\item
  List the portlet ID in the column of the layout you want to display
  the portlet on. An example configuration is shown below:

\begin{verbatim}
{
    "layoutTemplateId": "2_columns_ii",
    "publicPages": [
        {
            "columns": [
                [
                    {
                        "portletId": "com_liferay_login_web_portlet_LoginPortlet"
                    },
                    {
                        "portletId": 
                        "com_liferay_site_navigation_menu_web_portlet_SiteNavigationMenuPortlet"
                    }
                ],
                [
                    {
                        "portletId": "com_liferay_hello_world_web_portlet_HelloWorldPortlet"
                    }
                ]
            ],
            "friendlyURL": "/home",
            "nameMap": {
                "en_US": "Welcome",
                "fr_FR": "Bienvenue"
            },
            "title": "Welcome"
        }
    ]
}
\end{verbatim}

  This approach embeds the portlet with its default settings. To
  customize the portlet, you must configure the portlet's preferences,
  as described in the next step.
\item
  Optionally specify portlet preferences for a portlet with the
  \texttt{portletPreferences} key. Below is an example for the Web
  Content Display portlet:

\begin{verbatim}
{
    "portletId": "com_liferay_journal_content_web_portlet_JournalContentPortlet",
    "portletPreferences": {
        "articleId": "Custom Title.xml",
        "groupId": "${groupId}",
        "portletSetupPortletDecoratorId": "decorate",
        "portletSetupTitle_en_US": "Web Content Display with Custom Title",
        "portletSetupUseCustomTitle": "true"
    }
}
\end{verbatim}

  \textbf{portletSetupPortletDecoratorId:} Specifies the portlet
  decorator to use for the portlet (\texttt{borderless}
  \textbar\textbar{} \texttt{barebone} \textbar\textbar{}
  \texttt{decorate}). See the
  \href{/docs/7-1/tutorials/-/knowledge_base/t/applying-portlet-decorators-to-embedded-portlets}{Applying
  Portlet Decorators to Embedded Portlets} tutorial for more info.
\end{enumerate}

\noindent\hrulefill

\textbf{Tip:} You can specify an
\href{/docs/7-1/user/-/knowledge_base/u/styling-apps-and-assets}{application
display template} (ADT) for a portlet in the \texttt{sitemap.json} file
by setting the \texttt{displayStyle} and \texttt{displayStyleGroupId}
portlet preferences, as shown in the example below:

\begin{verbatim}
 "portletId": "com_liferay_asset_publisher_web_portlet_AssetPublisherPortlet",
     "portletPreferences": {
         "displayStyleGroupId": "10197",
         "displayStyle": "ddmTemplate_6fe4851b-53bc-4ca7-868a-c836982836f4"
 }
\end{verbatim}

\noindent\hrulefill

Portlet preferences are unique to each portlet, so first you must
determine which preferences you want to configure. There are two ways to
determine the proper key/value pair for a portlet preference. The first
is to set the portlet preference manually, and then check the values in
the \texttt{portletPreferences.preferences} column of the database as a
hint for what to configure in your \texttt{sitemap.json}. For example,
you can configure the Asset Publisher to display assets that match the
specified asset tags, using the following configuration:

\begin{verbatim}
"queryName0": "assetTags",
"queryValues0": "MyAssetTagName"
\end{verbatim}

Another approach is to search each app in your bundle for the keyword
\texttt{preferences-\/-}. This returns some of the app's JSPs that have
the portlet preferences defined for the portlet.

\noindent\hrulefill

\textbf{Note:} Portlet preferences that require an existing
configuration, such as a tag or category, may require you to create the
configuration on the Global site first, so that the Resources Importer
finds a match when deployed with the theme.

\noindent\hrulefill

\subsection{Related Topics}\label{related-topics-119}

\href{/docs/7-1/tutorials/-/knowledge_base/t/preparing-and-organizing-web-content-for-the-resources-importer}{Preparing
and Organizing Web Content for the Resources Importer}

\href{/docs/7-1/tutorials/-/knowledge_base/t/defining-pages-in-a-sitemap}{Defining
Pages in a Sitemap}

\href{/docs/7-1/tutorials/-/knowledge_base/t/specifying-where-to-import-your-themes-resources}{Specifying
Where to Import Your Theme's Resources}

\section{Retrieving Portlet IDs with the Gogo
Shell}\label{retrieving-portlet-ids-with-the-gogo-shell}

To
\href{/docs/7-1/tutorials/-/knowledge_base/t/defining-portlets-in-a-sitemap}{include
a portlet in a sitemap}, you must have its ID. For convenience, IDs for
out-of-the-box portlets appear in the
\href{/docs/7-1/reference/-/knowledge_base/r/fully-qualified-portlet-ids}{Fully
Qualified Portlet IDs} reference guide. If you've installed purchased or
developed portlets, you can retrieve their IDs using the Gogo Shell, as
this tutorial instructs.

Follow these steps to use the Gogo Shell to retrieve a portlet ID:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open the Control Panel and go to Configuration → Gogo Shell.
\item
  Run the command \texttt{lb\ {[}app\ prefix{]}}, and locate the app's
  web bundle. For example, run \texttt{lb\ blogs} to find the blogs web
  bundle.

\begin{verbatim}
100|Active     |   10|Liferay Blogs Web (3.0.7)
\end{verbatim}
\item
  Run the command \texttt{scr:list\ {[}bundle\ ID{]}}, and locate the
  app's component ID. The blogs portlet entry is shown below. The last
  number preceding the bundle's state is the component ID:

\begin{verbatim}
[ 100] com.liferay.blogs.web.internal.portlet.BlogsPortlet enabled 
[ 196] [active] 
\end{verbatim}
\item
  Run the command \texttt{scr:info\ {[}component\ ID{]}} to list the
  portlet's information. For example, to list the info for the blogs
  portlet component, run \texttt{scr:info\ 196}. Note that the bundle
  and/or component ID may be different for your instance.
\item
  Search for \texttt{javax.portlet.name} in the results.
  \texttt{javax.portlet.name}'s value is the portlet ID required for the
  sitemap. The blogs portlet's ID is shown below:

\begin{verbatim}
javax.portlet.name = com_liferay_blogs_web_portlet_BlogsPortlet
\end{verbatim}
\end{enumerate}

\begin{figure}
\centering
\includegraphics{./images/resources-importer-gogo-shell.png}
\caption{Portlet IDs can be found via the Gogo Shell.}
\end{figure}

\subsection{Related Topics}\label{related-topics-120}

\href{/docs/7-1/tutorials/-/knowledge_base/t/defining-pages-in-a-sitemap}{Defining
Pages in a Sitemap}

\href{/docs/7-1/tutorials/-/knowledge_base/t/defining-portlets-in-a-sitemap}{Defining
Portlets in a Sitemap}

\href{/docs/7-1/tutorials/-/knowledge_base/t/preparing-and-organizing-web-content-for-the-resources-importer}{Preparing
and Organizing Web Content for the Resources Importer}

\section{Defining Assets for the Resources
Importer}\label{defining-assets-for-the-resources-importer}

The \texttt{sitemap.json} file defines the pages of the site or site
template to import---along with the layout templates, portlets, and
portlet preferences of these pages. You may also want to provide details
about the assets you include with the theme. An \texttt{assets.json}
file lets you provide this information. Create the \texttt{assets.json}
in your theme's
\texttt{{[}theme-name{]}/src/WEB-INF/src/resources-importer} folder.

Tags can be applied to any asset. Abstract summaries and small images
can be applied to web content articles. For example, the following
\texttt{assets.json} file specifies two tags for the
\texttt{company\_logo.png} image, one tag for the
\texttt{Custom\ Title.xml} web content article, and an abstract summary
and small image for the \texttt{Child\ Web\ Content\ 1.json} article
structure:

\begin{verbatim}
{
    "assets": [
        {
            "name": "company_logo.png",
            "tags": [
                "logo",
                "company"
            ]
        },
        {
            "name": "Custom Title.xml",
            "tags": [
                "web content"
            ]
        },
        {
            "abstractSummary": "This is an abstract summary.",
            "name": "Child Web Content 1.json",
            "smallImage": "company_logo.png"
        }
    ]
}
\end{verbatim}

Now you know how to configure assets for your web content!

\subsection{Related Topics}\label{related-topics-121}

\href{/docs/7-1/tutorials/-/knowledge_base/t/preparing-and-organizing-web-content-for-the-resources-importer}{Preparing
and Organizing Web Content for the Resources Importer}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-a-sitemap-for-the-resources-importer}{Creating
a Sitemap for the Resources Importer}

\href{/docs/7-1/tutorials/-/knowledge_base/t/specifying-where-to-import-your-themes-resources}{Specifying
Where to Import Your Theme's Resources}

\section{Specifying Where to Import Your Theme's
Resources}\label{specifying-where-to-import-your-themes-resources}

By default, resources are imported into a new site template named after
the theme, but you can also import resources into a new site or existing
sites or site templates. This tutorial covers all these options.

First you must enable Developer Mode for the Resources Importer.

\subsection{Enabling Developer Mode}\label{enabling-developer-mode}

Before specifying where to import your resources, you must enable
Developer Mode in your theme. To do this, add the following property to
your theme's \texttt{liferay-plugin-package.properties} file:

\begin{verbatim}
`resources-importer-developer-mode-enabled=true`
\end{verbatim}

This is enabled by default for themes generated with the
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-themes}{Liferay
Theme Generator}. This is a convenience feature for theme developers.
With this setting enabled, importing resources into a site or site
template that already exists recreates the site or site template.
Importing resources into a site template reapplies the site template and
its resources to the sites that are based on the site template. Without
\texttt{resources-importer-developer-mode-enabled=true}, you must
manually delete the sites or site templates built by the Resources
Importer each time you want to apply changes from your theme's
\texttt{src/WEB-INF/src/resources-importer} folder.

\noindent\hrulefill

\textbf{Warning:} the
\texttt{resources-importer-developer-mode-enabled=true} setting can be
dangerous since it involves \emph{deleting} (and re-creating) the
affected site or site template. It's only intended to be used during
development. \textbf{Never use it in production.}

\noindent\hrulefill

With Developer Mode enabled in the Resource Importer, you can choose
where you want to import your theme's resources.

\subsection{Importing Resources into Existing Site Templates and
Sites}\label{importing-resources-into-existing-site-templates-and-sites}

By default, resources are imported into a new site template named after
the theme. If you want your resources to be imported into an existing
site template, you must specify a value for the
\texttt{resources-importer-target-value} property in your theme's
\texttt{liferay-plugin-package.properties} file:

\begin{verbatim}
#resources-importer-target-class-name

resources-importer-target-value=[site-template-name]
\end{verbatim}

\textbf{You must} import your resources into a site if you define both
public and private page sets in your \texttt{sitemap.json}. To import
resources into an existing site, uncomment the
\texttt{resources-importer-target-class-name} property and set it to
\texttt{com.liferay.portal.kernel.model.Group}:

\begin{verbatim}
resources-importer-target-class-name=com.liferay.portal.kernel.model.Group

resources-importer-target-value=[site-name] 
\end{verbatim}

Double check the name that you're specifying. If you specify the wrong
value, you could end up deleting (and re-creating) the wrong site or
site template!

\noindent\hrulefill

\textbf{Warning:} It's safer to import theme resources into a site
template than into an actual site. The
\texttt{resources-importer-target-class-name=com.liferay.portal.kernel.model.Group}
setting can be handy for development and testing but should be used
cautiously. Don't use this setting in a theme deployed to a production
Liferay instance or a theme submitted to Liferay Marketplace. To prepare
a theme for deployment to a production Liferay instance, use the default
setting so that the resources are imported into a site template. You can
do this explicitly by setting
\texttt{resources-importer-target-class-name=com.liferay.portal.kernel.model.LayoutSetPrototype}
or implicitly by commenting out or removing the
\texttt{resources-importer-target-class-name} property.

\noindent\hrulefill

To view your theme and its resources, deploy the theme, log in as an
administrator, and check the Sites or Site Templates section of the
Control Panel to make sure your resources were deployed correctly. From
the Control Panel you can easily view your theme and its resources:

\begin{itemize}
\tightlist
\item
  If you imported into a site template, open its actions menu and select
  \emph{View Pages} to see it.
\item
  If you imported directly into a site, open its actions menu and select
  \emph{Go to Public Pages} to see it.
\end{itemize}

It's just that easy to import resources with your theme!

\subsection{Related Topics}\label{related-topics-122}

\href{/docs/7-1/tutorials/-/knowledge_base/t/preparing-and-organizing-web-content-for-the-resources-importer}{Preparing
and Organizing Web Content for the Resources Importer}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-a-sitemap-for-the-resources-importer}{Creating
a Sitemap for the Resources Importer}

\href{/docs/7-1/tutorials/-/knowledge_base/t/defining-assets-for-the-resources-importer}{Defining
Assets for the Resources Importer}

\section{Archiving Site Resources}\label{archiving-site-resources}

Although a \texttt{sitemap.json} is the recommended approach for
including resources with a theme, you can also export your site's data
in a LAR (Liferay Archive) file. A LAR file is version-specific; it
won't work on any version of Liferay DXP other than the one from which
it was exported. This approach does, however, require less
configuration, since it does not require a sitemap or other files. So,
if you're using the exported resources in the same version of Liferay
DXP and it's not for a theme on Liferay Marketplace, you may prefer a
LAR file.

To create an \texttt{archive.lar}, export the contents of a site using
the site scope. Then place the \texttt{archive.lar} file in your theme's
\texttt{{[}theme-name{]}/src/WEB-INF/src/resources-importer} folder. A
LAR archive does not require a \texttt{sitemap.json} file or any other
files in your
\texttt{{[}theme-name{]}/src/WEB-INF/src/resources-importer} folder.

\subsection{Related Topics}\label{related-topics-123}

\chapter{Upgrading Your Theme from Liferay Portal 6.2 to
7.1}\label{upgrading-your-theme-from-liferay-portal-6.2-to-7.1}

This section guides you through the process of upgrading your 6.2 theme
to run on 7.0. While you're at it, you should leverage theme
improvements, including support for Sass, Bootstrap 4 and Lexicon 2.0.

Theme upgrades involve these steps:

\begin{itemize}
\tightlist
\item
  Updating project metadata
\item
  Updating CSS
\item
  Updating theme templates
\item
  Updating resources importer configuration and content
\item
  Applying Clay design patterns
\end{itemize}

As an example, these tutorials apply the steps to a theme called the
Lunar Resort theme developed in the Liferay Portal 6.2
\href{/docs/6-2/tutorials/-/knowledge_base/t/developing-a-liferay-theme}{Developing
a Liferay Theme} Learning Path. It's similar to many Liferay Portal 6.2
themes, as it extends the
\href{https://github.com/liferay/liferay-portal/tree/6.2.x/portal-web/docroot/html/themes/_styled}{\texttt{\_styled}
theme}, adds configurable settings, and incorporats a responsive design
that leverages Font Awesome icons and Bootstrap. The theme
\href{/documents/10184/656312/lunar-resort-theme-migration-6.2.zip}{ZIP
file} contains its original source code.

\begin{figure}
\centering
\includegraphics{./images/finished-7-1-theme.png}
\caption{The Lunar Resort example theme upgraded in this tutorial uses a
clean, minimal design.}
\end{figure}

Before upgrading a theme, consider
\href{/docs/7-1/tutorials/-/knowledge_base/t/running-the-upgrade-task-for-6-2-themes}{migrating
the theme} to use the
\href{https://github.com/liferay/liferay-themes-sdk/tree/master/packages}{Liferay
JS Theme Toolkit}. 7.0 doesn't require this migration, but the Liferay
JS Theme Toolkit's Gulp \texttt{upgrade} task automates many upgrade
steps. Themes that use the Liferay JS Theme Toolkit can also leverage
exclusive features, such as
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-reusable-pieces-of-code-for-your-themes}{Themelets}.

If your theme uses Bootstrap 3 and Lexicon CSS, you can still use
Bootstrap 3 and Lexicon CSS alongside Bootstrap 4 and Clay CSS markup,
thanks to Liferay DXP's
\href{/docs/7-1/tutorials/-/knowledge_base/t/using-the-bootstrap-3-lexicon-css-compatibility-layer}{compatibility
layer}.

\noindent\hrulefill

\textbf{Note:} The compatibility layer is meant as a short-term solution
to ensure that your Bootstrap 3 and Lexicon CSS components aren't broken
while you update your theme to use
\href{https://getbootstrap.com/docs/4.3/migration/}{Bootstrap 4} and
\href{https://clayui.com/docs/css-framework/scss.html}{Clay CSS}. It
will be disabled in a future release. Migrate your theme to use
Bootstrap 4 and Clay CSS as soon as you're able to.

\noindent\hrulefill

Follow the steps in the
\href{/docs/7-1/tutorials/-/knowledge_base/t/running-the-upgrade-task-for-6-2-themes}{Running
the 6.2 theme upgrade task} tutorial to learn how to migrate your theme
to use the Liferay JS Theme Toolkit, including its Gulp \texttt{upgrade}
task. Otherwise, you must follow the steps in the remaining tutorials in
this section to upgrade your 6.2 theme to 7.1 manually.

\section{Running the Gulp Upgrade Task for 6.2
Themes}\label{running-the-gulp-upgrade-task-for-6.2-themes}

You can upgrade Liferay Portal 6.2 theme 7.0, regardless of the
development environment (Plugins SDK, Maven, etc.) you used. If you
migrate your theme to use the Liferay JS Theme Toolkit, you can leverage
the theme's Gulp \texttt{upgrade} task.

Without the Liferay JS Theme Toolkit, you must follow the directions in
the remaining tutorials in this section to upgrade your theme manually.

Here's what the Upgrade Task does:

\begin{itemize}
\tightlist
\item
  Updates the theme's Liferay version
\item
  Updates the theme's Bootstrap version
\item
  Updates the theme's Lexicon version
\item
  Suggests specific code updates
\end{itemize}

Here are the steps for using the Gulp \texttt{upgrade} task:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Migrate your 6.2 theme to use the Liferay JS Theme Toolkit. Note that
  \textbf{you must} have the
  \href{/docs/7-1/tutorials/-/knowledge_base/t/creating-themes}{Liferay
  Theme Generator} installed to migrate your theme to use the Liferay JS
  Theme Toolkit:

\begin{verbatim}
yo liferay-theme:import
\end{verbatim}

  \textbf{You must} provide the absolute path to your 6.2 theme's root
  folder. The import task does not work for relative paths.
\item
  Navigate to your theme's root directory and run the command below to
  initially upgrade your 6.2 theme to 7.0:

\begin{verbatim}
gulp upgrade
\end{verbatim}

  Here's what the 6.2 to 7.0 upgrade task does:

  \begin{itemize}
  \tightlist
  \item
    Updates the theme's Liferay version
  \item
    Updates the CSS
  \item
    Suggests specific code updates
  \end{itemize}

  The task continues upgrading CSS files, prompting you to update CSS
  file names. For 7.0, Sass files should use the \texttt{.scss}
  extension and file names for Sass partials should start with an
  underscore (e.g., \texttt{\_custom.scss}). The \texttt{upgrade} task
  prompts you for each CSS file to rename.
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note**: The `gulp upgrade` task overwrites the theme's files. We recommend
 that you backup your theme's files before running it.
\end{verbatim}

\noindent\hrulefill

\begin{verbatim}
The upgrade task automatically upgrades CSS code that it can identify. For 
everything else, it suggests upgrades. 
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\item
  Run the \texttt{gulp\ upgrade} command again to upgrade the 7.0 theme
  to 7.1.

  Here's what it does:

  \begin{itemize}
  \tightlist
  \item
    Creates core code for generating theme base files
  \item
    Collects removed Bootstrap and Lexicon variables
  \item
    Updates Bootstrap version references
  \item
    Updates Lexicon version references
  \item
    Updates Liferay version references
  \end{itemize}
\end{enumerate}

The Gulp \texttt{upgrade} task lists any deprecated or removed
variables. For other areas of the code it suspects might need updates,
it logs suggestions. The task also reports changes that may affect
\href{/docs/7-1/tutorials/-/knowledge_base/t/updating-6-2-theme-templates}{theme
templates}.

The Gulp \texttt{upgrade} task jump-starts the upgrade process, but it
doesn't complete it. Manual updates are required.

The rest of the tutorials in this section explain all the 6.2 theme
upgrade steps, regardless of whether the Gulp \texttt{upgrade} task
performs them. Steps the upgrade task performs are noted in context.
Even if you've already executed the upgrade task, it's best to learn all
the steps and make sure they're applied to your theme.

\subsection{Related Topics}\label{related-topics-124}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-themes}{Creating
Themes}

\href{/docs/7-1/tutorials/-/knowledge_base/t/updating-6-2-project-metadata}{Updating
6.2 Project Metadata}

\section{Updating 6.2 Project
Metadata}\label{updating-6.2-project-metadata}

If your theme uses the
\href{https://github.com/liferay/liferay-themes-sdk/tree/master/packages}{Liferay
JS Theme Toolkit}, the
\href{/docs/7-1/tutorials/-/knowledge_base/t/running-the-upgrade-task-for-6-2-themes}{Gulp
\texttt{upgrade} task} automatically updates some of your theme's
metadata as part of the upgrade process. Follow the steps below to
update your theme's metadata manually:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open your theme's \texttt{liferay-plugin-package.properties} file and
  change the \texttt{liferay-versions} property value to
  \texttt{7.1.0+}:

\begin{verbatim}
liferay-versions=7.1.0+
\end{verbatim}
\item
  Open the \texttt{liferay-look-and-feel.xml} file and specify
  \texttt{7.1.0+} as the compatibility version:

\begin{verbatim}
<look-and-feel>
        <compatibility>
                <version>7.1.0+</version>
        </compatibility>

        ...

</look-and-feel>
\end{verbatim}
\item
  While you're updating \texttt{liferay-look-and-feel.xml}, enable your
  theme to use
  \href{/docs/7-1/tutorials/-/knowledge_base/t/adding-portlet-decorators-to-a-theme}{Portlet
  Decorators}.
\item
  If your theme uses the Liferay JS Theme Toolkit, the
  \href{/docs/7-1/tutorials/-/knowledge_base/t/running-the-upgrade-task-for-6-2-themes}{Gulp
  \texttt{upgrade} task} updates the \texttt{package.json} file's
  Liferay version references to \texttt{7.1}, and it updates the
  \texttt{liferayTheme}'s \texttt{templateLanguage} to \texttt{ftl}
  (since Velocity theme templates are no longer supported):

\begin{verbatim}
"liferayTheme": {
    ...
    "templateLanguage": "ftl",
    "version": "7.1"
},
\end{verbatim}
\end{enumerate}

Your theme's Liferay version references are updated for 7.0.

\subsection{Related Topics}\label{related-topics-125}

\href{/docs/7-1/tutorials/-/knowledge_base/t/updating-6-2-css-code}{Updating
6.2 CSS Code}

\href{/docs/7-1/tutorials/-/knowledge_base/t/developing-themes}{Developing
Themes}

\chapter{Updating 6.2 CSS Code}\label{updating-6.2-css-code}

7.0's UI improvements required these CSS-related changes:

\begin{itemize}
\tightlist
\item
  Renaming CSS files
\item
  Removing unneeded CSS files
\item
  Updating CSS rules and imports
\item
  Modifications to CSS responsiveness tokens
\end{itemize}

The theme upgrade process involves conforming to these changes. Here's
how to update your theme's CSS to leverage the styling improvements.

\section{Updating CSS File Names for Clay and
Sass}\label{updating-css-file-names-for-clay-and-sass}

Although Sass was available in Liferay Portal 6.2, only Sass partial
files followed the Sass naming convention (using file suffix
\texttt{.scss}). In 7.0 themes, all Sass files must end in
\texttt{scss}, and \texttt{aui} filename prefixes have been replaced
with \texttt{clay} to reflect the introduction of
\href{https://clayui.com/docs/getting-started/clay.html}{Clay}
(previously Lexicon CSS).

\noindent\hrulefill

\textbf{Note}: The
\href{/docs/7-1/tutorials/-/knowledge_base/t/running-the-upgrade-task-for-6-2-themes}{Gulp
\texttt{upgrade} task} renames CSS files automatically.

\noindent\hrulefill

Follow these steps to update your CSS file names manually:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Change each CSS file name's suffix in your theme from \texttt{.css} to
  \texttt{.scss}, then prepend an underscore (\texttt{\_}) to all Sass
  partial file names, except \texttt{main.scss} and \texttt{aui.scss}.
  The Lunar Resort's updated files are shown below:

\begin{verbatim}
- `css/`
  - `_aui_variables.scss`
  - `_custom.scss`
\end{verbatim}
\item
  Rename any CSS files that use the name \texttt{aui} in your theme to
  use the name \texttt{clay} instead. Below are the Lunar Resort's
  updated CSS file names:

\begin{verbatim}
- `css/`
  - `_clay_variables.scss`
  - `_custom.scss` 
\end{verbatim}
\end{enumerate}

The full list of core files to rename is shown below for reference. If
you modified a CSS file shown in the table below, \textbf{you must}
update its name. If you didn't modify the file, no action is required:

\textbf{CSS File Name Updates}

\noindent\hrulefill

Original CSS File Name \textbar{} ~Updated CSS File Name \textbar{}

\noindent\hrulefill \texttt{application.css} \textbar{}
\texttt{\_application.scss}\textbar{} \texttt{aui.css} \textbar{}
\texttt{clay.scss}\textbar{} \texttt{base.css} \textbar{}
\texttt{\_base.scss}\textbar{} \texttt{custom.css} \textbar{}
\texttt{\_custom.scss}\textbar{} \texttt{dockbar.css} \textbar{}
removed\textbar{} \texttt{extras.css} \textbar{}
\texttt{\_extras.scss}\textbar{} \texttt{layout.css} \textbar{}
\texttt{\_layout.scss}\textbar{} \texttt{main.css} \textbar{}
\texttt{main.scss}\textbar{} \texttt{navigation.css} \textbar{}
\texttt{\_navigation.scss}\textbar{} \texttt{portal.css} \textbar{}
\texttt{\_portal.scss}\textbar{} \texttt{portlet.css} \textbar{}
\texttt{\_portlet.scss}\textbar{} \texttt{taglib.css} \textbar{}
\texttt{\_taglib.scss}\textbar{}

\subsection{Related Topics}\label{related-topics-126}

\href{/docs/7-1/tutorials/-/knowledge_base/t/running-the-upgrade-task-for-6-2-themes}{Running
the Gulp Upgrade Task for 6.2 Themes}

\href{/docs/7-1/tutorials/-/knowledge_base/t/updating-6-2-css-rules-and-imports}{Updating
6.2 CSS Rules}

\section{Updating 6.2 CSS Rules and
Imports}\label{updating-6.2-css-rules-and-imports}

7.0 uses Bootstrap 4's CSS rule syntax. Font Awesome icons have also
been moved, requiring changes to your imports. If your theme uses the
Liferay JS Theme Toolkit, the Gulp \texttt{upgrade} task reports
automatic CSS updates and suggests manual updates. For example, here is
part of the task log for the Lunar Resort theme upgrade from 6.2 to 7.0.
For each update performed and suggested, the task reports a file name
and line number range:

\begin{verbatim}
----------------------------------------------------------------
 Bootstrap Upgrade (2 to 3)
----------------------------------------------------------------

File: src/css/_aui_variables.scss
    Line 5: "$white" has been removed
    Line 11: "$baseBorderRadius" has changed to "$border-radius-base"
    Line 15: "$btnBackground" has changed to "$btn-default-bg"
    Line 16: "$btnBackgroundHighlight" has been removed
    Line 17: "$btnBorder" has changed to "$btn-default-border"
    ...
File: src/css/custom.css
    Line 201: Padding no longer affects width or height, you may need to
    change your rule (lines 201-227)
    Line 207: Padding no longer affects width or height, you may need to
    change your rule (lines 207-226)
    Line 212: You would change height from "62px" to "82px"
    ...
\end{verbatim}

\subsection{Manually Updating CSS
Rules}\label{manually-updating-css-rules}

Follow these steps to update your theme's CSS rules manually:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Since Bootstrap 3 adopted the \texttt{box-sizing:\ border-box}
  property for all elements and pseudo-elements (e.g., \texttt{:before}
  and \texttt{:after}), padding no longer affects dimensions.
  \href{https://getbootstrap.com/docs/3.3/css/\#less-mixins-box-sizing}{Bootstrap's
  documentation} describes the box sizing changes. In all CSS rules that
  use padding, make sure to update the width and height. For example,
  examine the \texttt{height} value change in this CSS rule for the
  Lunar Resort theme's \texttt{\_custom.scss} file:

  Original:

\begin{verbatim}
#reserveBtn {
    background-color: #00C4FB;
    border-radius: 10px;
    color: #FFF;
    font-size: 1.5em;
    height: 62px;
    margin: 30px;
    padding: 10px 0;
    ...
}
\end{verbatim}

  Updated:

\begin{verbatim}
#reserveBtn {
    background-color: #00C4FB;
    border-radius: 10px;
    color: #FFF;
    font-size: 1.5em;
    height: 82px;
    margin: 30px;
    padding: 10px 0;
    ...
}
\end{verbatim}
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** For individual elements, you can overwrite the
 `box-sizing:border-box` rule with `box-sizing:content-box`.
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\item
  The following variables are removed in Bootstrap 4. Remove any of
  these if they are used in your theme:

\begin{verbatim}
$line-height-computed
$padding-base-horizontal
$padding-base-vertical
$padding-large-horizontal
$padding-large-vertical
$padding-small-horizontal
$padding-small-vertical
$padding-xs-horizontal
$padding-xs-vertical
$gray-base
$gray-darker
$gray-dark
$gray
$gray-light
$gray-lighter
$brand-primary
$brand-success
$brand-info
$brand-warning
$brand-danger
$state-success-text
$state-success-bg
$state-success-border
$state-info-text
$state-info-bg
$state-info-border
$state-warning-text
$state-warning-bg
$state-warning-border
$state-danger-text
$state-danger-bg
$state-danger-border
\end{verbatim}
\end{enumerate}

See the
\href{http://getbootstrap.com/migration/\#migrating-from-2x-to-30}{Migrating
from 2.x to 3.0 guide} for CSS rules that changed in Bootstrap 3.
Likewise, you can refer to the
\href{https://getbootstrap.com/docs/4.0/migration/}{Migrating to v4
guide} for updating CSS rules to Bootstrap 4.

\subsection{Updating Font Awesome
Imports}\label{updating-font-awesome-imports}

Font Awesome icons were moved to their own file
(\texttt{font-awesome.scss}) to avoid the IE9 CSS selector limitation.
If you include these imports in your \texttt{\_custom.scss} file, you
must remove them:

\begin{verbatim}
@import "aui/alloy-font-awesome/scss/mixins-alloy";
@import "aui/alloy-font-awesome/scss/variables";
\end{verbatim}

\subsection{Related Topics}\label{related-topics-127}

\href{/docs/7-1/tutorials/-/knowledge_base/t/updating-the-6-2-responsiveness}{Updating
6.2 CSS Responsiveness}

\href{/docs/7-1/tutorials/-/knowledge_base/t/copying-an-existing-themes-files}{Copying
an Existing Theme's Files}

\section{Updating the Responsiveness}\label{updating-the-responsiveness}

Bootstrap 4 explicit media queries replaced the Bootstrap 2
\texttt{respond-to} mixins for CSS responsiveness. Follow these steps to
update your theme's responsiveness:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open your \texttt{\_custom.scss} file.
\item
  Replace all \texttt{respond-to} mixins with corresponding media
  queries shown below. Note that some of the dimensions are slightly
  different:

  \textbf{Media Query Replacements}
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 Liferay Portal 6.2 Mixin                            |  &nbsp;7.0 Media Query                                     |
\end{verbatim}

\noindent\hrulefill --------------------------------------
\textbar:----------------------------------------------------------
\textbar{} \texttt{@include\ respond-to(phone)} (max-width: 767px)
\textbar{} \texttt{@include\ media-breakpoint-down(sm)} (max-width:
767px) \textbar{} \texttt{@include\ respond-to(tablet)} (min-width:
768px, max-width: 979px) \textbar{}
\texttt{@include\ media-breakpoint-only(md)} (min-width: 768px,
max-width: 991px) \textbar{}
\texttt{@include\ respond-to(phone,\ tablet)} (max-width: 979px)
\textbar{} \texttt{@include\ media-breakpoint-down(md)} (max-width:
991px) \textbar{} \texttt{@include\ respond-to(desktop,\ tablet)}
(min-width: 768px) \textbar{} \texttt{@include\ media-breakpoint-up(md)}
(min-width: 768px) \textbar{} \texttt{@include\ respond-to(desktop)}
(min-width: 980px) \textbar{} \texttt{@include\ media-breakpoint-up(lg)}
(min-width: 992px) \textbar{}

For example, here is a comparison between the Lunar Resort theme's
original and updated syntax:

Original:

\begin{verbatim}
@include respond-to(phone, tablet) {
    html #wrapper #banner #navigation {
    ...
    }
    ...
}
\end{verbatim}

Updated:

\begin{verbatim}
@include media-breakpoint-down(md) {
    html #wrapper #banner #navigation {
    ...
    }
    ...
}
\end{verbatim}

\subsection{Related Topics}\label{related-topics-128}

\href{/docs/7-1/tutorials/-/knowledge_base/t/updating-6-2-theme-templates}{Updating
6.2 Theme Templates}

\href{/docs/7-1/tutorials/-/knowledge_base/t/updating-css-file-names-for-clay-and-sass}{Updating
CSS File Names for Clay and Sass}

\section{Updating 6.2 Theme
Templates}\label{updating-6.2-theme-templates}

7.0 theme templates are essentially the same as Liferay Portal 6.2 theme
templates. Here are the main changes:

\begin{itemize}
\item
  Velocity templates were deprecated in Liferay Portal CE 7.0 and are
  now removed in favor of FreeMarker templates in Liferay DXP. Below are
  the key reasons for this move:

  \begin{itemize}
  \item
    FreeMarker is developed and maintained regularly, while Velocity is
    no longer actively being developed.
  \item
    FreeMarker is faster and supports more sophisticated macros.
  \item
    FreeMarker supports using taglibs directly rather than requiring a
    method to represent them. You can pass body content to them,
    parameters, etc.
  \end{itemize}
\item
  The Dockbar has been replaced and reorganized into a set of three
  distinct menus:

  \begin{itemize}
  \item
    \emph{The Product Menu}: Manage Site and page navigation, content,
    settings and pages for the current Site, and navigate to user
    account settings, etc.
  \item
    \emph{The Control Menu}: Configure and add content to the page and
    view the page in a simulation window.
  \item
    \emph{The User Personal Bar}: Display notifications and the user's
    avatar and name.
  \end{itemize}

  \begin{figure}
  \centering
  \includegraphics{./images/upgrading-themes-dockbar.png}
  \caption{The Dockbar was removed in 7.0 and must be replaced with the
  new Control Menu.}
  \end{figure}
\end{itemize}

Start by converting your Velocity theme templates to FreeMarker. You can
refer to Apache's
\href{https://freemarker.apache.org/docs/ref.html}{FreeMarker
documentation} for help. Common Liferay DXP FreeMarker variables and
macros can be found in
\href{https://github.com/liferay/liferay-portal/blob/7.1.x/modules/apps/portal-template/portal-template-freemarker/src/main/resources/FTL_liferay.ftl}{\texttt{FTL\_liferay.ftl}}

If you used the \href{running-the-upgrade-task-for-6.2-themes}{Gulp
\texttt{upgrade} task}, it reports the required theme template changes
in the log. For example, here are the 6.2 to 7.0 upgrade log and 7.0 to
7.1 upgrade log for the Lunar Resort theme:

\begin{verbatim}
----------------------------------------------------------------
 Liferay Upgrade (6.2 to 7)
----------------------------------------------------------------

File: portal_normal.ftl
    Warning: <@liferay.dockbar /> is deprecated, replace with 
    <@liferay.control_menu /> for new admin controls.
    Warning: not all admin controls will be visible without 
    <@liferay.control_menu />
    Warning: ${theme} variable is no longer available in Freemarker 
    templates, see https://goo.gl/9fXzYt for more information.
[18:57:23] Finished 'upgrade:log-changes' after 5.61 ms
[18:57:23] Finished 'upgrade' after 19 s

----------------------------------------------------------------
 Liferay Upgrade (7.0 to 7.1)
----------------------------------------------------------------

Renamed aui.scss to clay.scss
[19:16:54] Finished 'upgrade:log-changes' after 2.53 ms
[19:16:54] Finished 'upgrade' after 16 min
\end{verbatim}

The log warns about removed and deprecated code and suggests
replacements when applicable.

Next, you'll learn how to update various theme templates to 7.0. If you
didn't modify any theme templates, you can skip these sections.

\subsection{Updating Portal Normal
FTL}\label{updating-portal-normal-ftl}

If you didn't customize \texttt{portal\_normal.ftl}, you can skip this
section. Follow these steps to update \texttt{portal\_normal.ftl}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open your modified \texttt{portal\_normal.ftl} file and replace the
  following 6.2 directives with the updated syntax. This change is
  described in the
  \href{/docs/7-0/reference/-/knowledge_base/r/breaking-changes\#taglibs-are-no-longer-accessible-via-the-theme-variable-in-freemarker}{7.0
  Breaking Changes} reference document:

  \begin{longtable}[]{@{}
    >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.2209}}
    >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.7791}}@{}}
  \toprule\noalign{}
  \begin{minipage}[b]{\linewidth}\raggedright
  6.2
  \end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
  ~Updated
  \end{minipage} \\
  \midrule\noalign{}
  \endhead
  \bottomrule\noalign{}
  \endlastfoot
  \texttt{\$\{theme.include(top\_head\_include)\}} &
  \texttt{\textless{}@liferay\_util{[}"include"{]}\ page=top\_head\_include\ /\textgreater{}} \\
  \texttt{\$\{theme.include(body\_top\_include)\}} &
  \texttt{\textless{}@liferay\_util{[}"include"{]}\ page=body\_top\_include\ /\textgreater{}} \\
  \texttt{\$\{theme.include(content\_include)\}} &
  \texttt{\textless{}@liferay\_util{[}"include"{]}\ page=content\_include\ /\textgreater{}} \\
  \texttt{\$\{theme.wrapPortlet("portlet.ftl",\ content\_include)\}} &
  \texttt{\textless{}@liferay\_theme{[}"wrap-portlet"{]}\ page="portlet.ftl"\textgreater{}\ \textless{}@liferay\_util{[}"include"{]}\ page=content\_include\ /\textgreater{}\ \textless{}/@\textgreater{}} \\
  \texttt{\$\{theme.include(body\_bottom\_include)\}} &
  \texttt{\textless{}@liferay\_util{[}"include"{]}\ page=body\_bottom\_include\ /\textgreater{}} \\
  \texttt{\$\{theme.include(bottom\_include)\}} &
  \texttt{\textless{}@liferay\_util{[}"include"{]}\ page=bottom\_include\ /\textgreater{}} \\
  \texttt{\$\{theme\_settings{[}"my-theme-setting"{]}\}} &
  \texttt{\$\{themeDisplay.getThemeSetting("my-theme-setting")\}} \\
  \texttt{\$\{theme.runtime("56",\ "articleId="\ +\ my\_article\_id)\}}
  &
  \texttt{\textless{}@liferay\_portlet{[}"runtime"{]}\ portletName=}\texttt{"com\_liferay\_journal\_content\_web\_portlet\_JournalContentPortlet"}
  \texttt{queryString="articleId="\ +\ my\_article\_id\ /\textgreater{}} \\
  \end{longtable}
\item
  Optionally remove the breadcrumbs and page title code:

\begin{verbatim}
<nav id="breadcrumbs">      
    <@liferay.breadcrumbs />        
</nav>
...
<h2 class="page-title">
    <span>${the_title}</span>
</h2>
\end{verbatim}
\item
  If you used the split Dockbar in your Liferay Portal 6.2 theme, remove
  \texttt{dockbar-split} from the \texttt{body} element's \texttt{class}
  value so it matches the markup below:

\begin{verbatim}
<body class="${css_class}">
\end{verbatim}
\item
  Find the
  \texttt{\textless{}a\ href="\#main-content"\ id="skip-to-content"\textgreater{}\textless{}@liferay.language\ key="skip-to-content"\ /\textgreater{}\textless{}/a\textgreater{}}
  element and replace it with the updated Liferay UI quick access macro
  shown below:

\begin{verbatim}
<@liferay_ui["quick-access"] contentId="#main-content" />
\end{verbatim}
\item
  Replace the \texttt{\textless{}@liferay.dockbar\ /\textgreater{}}
  macro with the updated Control menu macro:

\begin{verbatim}
<@liferay.control_menu />
\end{verbatim}
\item
  Add the
  \texttt{\textless{}\#if...\textgreater{}\textless{}/\#if\textgreater{}}
  wrappers to the \texttt{navigation.ftl} theme template include:

\begin{verbatim}
<#if has_navigation && is_setup_complete>
    <#include "${full_templates_path}/navigation.ftl" />
</#if>
\end{verbatim}
\item
  Replace the \texttt{content} \texttt{\textless{}div\textgreater{}}
  with an HTML 5 \texttt{section} element. The \texttt{section} element
  is more accurate and provides better accessibility for screen readers:

\begin{verbatim}
<section id="content">
\end{verbatim}
\item
  Add the
  \texttt{\textless{}h1\ class="hide-accessible"\textgreater{}\$\{the\_title\}\textless{}/h1\textgreater{}}
  header element just inside the \texttt{content}
  \texttt{\textless{}section\textgreater{}} to support accessibility.
\end{enumerate}

If you modified the navigation template for your theme, follow the steps
in the next section.

\subsection{Updating Navigation FTL}\label{updating-navigation-ftl}

Follow these steps to update your modified \texttt{navigation.ftl} file:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Below the
  \texttt{\textless{}nav\ class="\$\{nav\_css\_class\}"\ id="navigation"\ role="navigation"\textgreater{}}
  element, add the following hidden heading for accessibility screen
  readers:

\begin{verbatim}
<h1 class="hide-accessible">
    <@liferay.language key="navigation" />
</h1>
\end{verbatim}
\item
  To access the layout, add the following variable declaration below the
  \texttt{\textless{}\#assign\ nav\_item\_css\_class\ =\ ""\ /\textgreater{}}
  variable declaration:

\begin{verbatim}
<#assign nav_item_layout = nav_item.getLayout() />
\end{verbatim}
\item
  Replace the \texttt{\$\{nav\_item.icon()\}}variable in the
  \texttt{\textless{}a\ aria-labelledby="layout\_\$\{nav\_item.getLayoutId()\}"...\textless{}/a\textgreater{}}
  anchor with the following element:

\begin{verbatim}
<@liferay_theme["layout-icon"] layout=nav_item_layout />
\end{verbatim}
\end{enumerate}

The navigation template is updated. You can update \texttt{portlet.ftl}
next.

\subsection{Updating Portlet FTL}\label{updating-portlet-ftl}

Follow these steps to update your modified \texttt{portlet.ftl} file:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Find the
  \texttt{\textless{}a\ class="icon-monospaced\ portlet-icon-back\ text-default"\ \ \ \ \ \ href="\$\{portlet\_back\_url\}"\ title="\textless{}@liferay.language\ \ \ \ \ \ key="return-to-full-page"\ /\textgreater{}"\textgreater{}}
  element and add the \texttt{list-unstyled} class to it:

\begin{verbatim}
<a 
  class="icon-monospaced list-unstyled portlet-icon-back text-default" 
  href="${portlet_back_url}" 
  title="<@liferay.language key="return-to-full-page" />"
>
\end{verbatim}
\item
  Find the
  \texttt{\textless{}div\ class="autofit-float\ autofit-row"\textgreater{}}
  element and add the \texttt{portlet-header} class to it:

\begin{verbatim}
<div class="autofit-float autofit-row portlet-header">
\end{verbatim}
\end{enumerate}

The portlet template is updated. You can update
\texttt{init\_custom.ftl} next.

\subsection{Updating Init Custom FTL}\label{updating-init-custom-ftl}

If your theme uses
\href{/docs/7-1/tutorials/-/knowledge_base/t/making-configurable-theme-settings}{configurable
theme settings}, update them to use the new syntax, following the
patterns below.

Original syntax:

\begin{verbatim}
<#assign theme_setting_variable = 
getterUtil.getBoolean(theme_settings["theme-setting-key"])>

<#assign theme_setting_variable = 
getterUtil.getString(theme_settings["theme-setting-key"])>
\end{verbatim}

Updated syntax:

\begin{verbatim}
<#assign theme_setting_variable =
getterUtil.getBoolean(themeDisplay.getThemeSetting("theme-setting-key"))/>

<#assign theme_setting_variable = 
themeDisplay.getThemeSetting("theme-setting-key")/>
\end{verbatim}

For example, here are the Lunar Resort theme's updated theme settings:

\begin{verbatim}
<#assign show_breadcrumbs = 
getterUtil.getBoolean(themeDisplay.getThemeSetting("show-breadcrumbs"))/>

<#assign show_page_title = 
getterUtil.getBoolean(themeDisplay.getThemeSetting("show-page-title"))/>
\end{verbatim}

That covers most, if not all, of the theme template changes. If you
modified any other FreeMarker theme templates, compare them with
templates in the
\href{https://github.com/liferay/liferay-portal/tree/7.1.x/modules/apps/frontend-theme/frontend-theme-unstyled/src/main/resources/META-INF/resources/_unstyled/templates}{\texttt{\_unstyled}
theme}. If your theme uses the Liferay JS Theme Toolkit, refer to the
suggested changes that the Gulp \texttt{upgrade} task reports.

\subsection{Related Topics}\label{related-topics-129}

\href{/docs/7-1/tutorials/-/knowledge_base/t/updating-6-2-css-code}{Updating
CSS Code}

\href{/docs/7-1/tutorials/-/knowledge_base/t/making-configurable-theme-settings}{Making
Configurable Theme Settings}

\section{Updating the Resources
Importer}\label{updating-the-resources-importer}

The Resources Importer is now an OSGi module in Liferay's Web Experience
application suite. Since the suite is bundled with Liferay DXP, you
don't have to download the Resources Importer separately. The following
components have been updated and are the focus of this tutorial:

\begin{itemize}
\tightlist
\item
  Plugin properties
\item
  Web content article files and folder structure
\item
  Sitemap
\end{itemize}

\noindent\hrulefill

\textbf{Note:} Due to the page and article import order, articles that
link to pages in the Site's layout cause a null pointer exception
\href{https://issues.liferay.com/browse/LPS-64859}{issue}. These links
have been removed from the example Lunar Resort theme's web content
articles to avoid this issue.

\noindent\hrulefill

Start updating the plugin properties for the Resources Importer.

\subsection{Updating
liferay-plugin-package.properties}\label{updating-liferay-plugin-package.properties}

Follow the steps in this section to upgrade Plugins SDK themes. Skip to
the next section for all other themes.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open the
  \texttt{src\textbackslash{}WEB-INF\textbackslash{}liferay-plugin-package.properties}
  file and remove the \texttt{required-deployment-contexts} property.
  This is no longer needed since the Resources Importer is bundled with
  Liferay DXP.
\item
  The group model class's fully-qualified class name has changed.
  Replace the \texttt{resources-importer-target-class-name} property's
  value with the updated one below:

\begin{verbatim}
com.liferay.portal.kernel.model.Group
\end{verbatim}
\end{enumerate}

Now that your \texttt{liferay-plugin-package.properties} is updated, you
can update your theme's web content.

\subsection{Updating Web Content}\label{updating-web-content}

All web content articles must be written in XML and have a structure for
article creation and a template for rendering.

\noindent\hrulefill

\textbf{Note:} The example Lunar Resort theme's updated XML articles are
in the ZIP file's
\texttt{/resources-importer/journal/articles/Basic\ Web\ Content/}
folder for reference.

\noindent\hrulefill

Follow these steps to update your web content:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a subfolder, for example \texttt{BASIC\_WEB\_CONTENT}, in the
  \texttt{/resources-importer/journal/articles/} folder, and move all
  the basic HTML articles (articles that did not require a structure or
  template previously) into it.
\item
  Create a subfolder in the
  \texttt{/resources-importer/journal/templates/} folder with the same
  name as the folder you created in step 1. The articles and template
  folder names must match for the web content to import properly.
\item
  XML article structures are now written in JSON. Create a file, for
  example \texttt{BASIC\_WEB\_CONTENT.json}, in the
  \texttt{/resources-importer/journal/structures/} folder. The structure
  name \textbf{must match} the folder names you created in the previous
  steps. To ensure the syntax is correct for web content articles that
  used a structure and template before, we recommend that you recreate
  the structure and template in Liferay DXP.
\item
  In the JSON file you just created, add a JSON structure for the basic
  web content that follows the pattern below:

\begin{verbatim}
{
    "availableLanguageIds": [
        "en_US"
    ],
    "defaultLanguageId": "en_US",
    "fields": [
        {
            "label": {
                "en_US": "Content"
            },
            "predefinedValue": {
                "en_US": ""
            },
            "style": {
                "en_US": ""
            },
            "tip": {
                "en_US": ""
            },
            "dataType": "html",
            "fieldNamespace": "ddm",
            "indexType": "keyword",
            "localizable": true,
            "name": "content",
            "readOnly": false,
            "repeatable": false,
            "required": false,
            "showLabel": true,
            "type": "ddm-text-html"
        }
    ]
}
\end{verbatim}
\item
  For basic web content, create a FreeMarker template file (e.g.,
  \texttt{{[}template-folder-name{]}.ftl}) in the template subfolder you
  created in step 2, and add the method below to retrieve the article's
  data:

\begin{verbatim}
${content.getData()}
\end{verbatim}
\item
  Use this syntax to migrate basic web content articles from HTML to
  XML. \textbf{Remember} to change your \texttt{.html} file extension to
  \texttt{.xml}:

\begin{verbatim}
<?xml version="1.0"?>

<root available-locales="en_US" default-locale="en_US">
        <dynamic-element name="content" type="text_area"
        index-type="keyword" index="0">
                <dynamic-content language-id="en_US">
                        <![CDATA[
                        ORIGINAL HTML CONTENT GOES HERE
                        ]]>
                </dynamic-content>
        </dynamic-element>
</root>
\end{verbatim}
\item
  7.0's updated Bootstrap requires that you replace all
  \texttt{span{[}number{]}} classes with the updated syntax below:

\begin{verbatim}
col-[device-size]-[number]
\end{verbatim}

  \texttt{{[}device-size{]}} can be \texttt{xs}, \texttt{sm},
  \texttt{md}, or \texttt{lg}. \texttt{md} works for most cases. The
  original and updated classes for the Lunar Resort's
  \texttt{2\ column\ description.xml} article are shown below for
  reference:

  Original:

\begin{verbatim}
<?xml version="1.0"?>

<root available-locales="en_US" default-locale="en_US">
    <dynamic-element name="content" type="text_area"
    index-type="keyword" index="0">
        <dynamic-content language-id="en_US">
            <![CDATA[
                <div class="container-fluid">
                    <div class="span4" id="columnLeft">
                        Out of This World
                    </div>
                    <div class="span8" id="columnRight">
                        Come to the Lunar Resort...
                    </div>
                </div>
            ]]>
        </dynamic-content>
    </dynamic-element>
</root>
\end{verbatim}

  Updated:

\begin{verbatim}
<?xml version="1.0"?>

<root available-locales="en_US" default-locale="en_US">
    <dynamic-element name="content" type="text_area"
    index-type="keyword" index="0">
        <dynamic-content language-id="en_US">
            <![CDATA[
                <div class="container-fluid">
                    <div class="col-md-4" id="columnLeft">
                        Out of This World
                    </div>
                    <div class="col-md-8" id="columnRight">
                        Come to the Lunar Resort...
                    </div>
                </div>
            ]]>
        </dynamic-content>
    </dynamic-element>
</root>
\end{verbatim}

  Bootstrap's
  \href{https://getbootstrap.com/docs/4.0/layout/grid/}{documentation}
  explains the updated grid system.
\end{enumerate}

Next, you must update your theme's sitemap file.

\subsection{Updating the Sitemap}\label{updating-the-sitemap}

In Liferay Portal 6.2, portlet IDs were incremental numbers. In 7.0,
they're explicit class names. Update your \texttt{sitemap.json} file
with the new portlet IDs.

Some common portlet IDs are specified in the \texttt{sitemap.json}
example in the
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-a-sitemap-for-the-resources-importer}{Creating
a Sitemap for the Resources Importer} tutorial.

You can also retrieve a portlet's ID from the UI:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In the portlet's \emph{Options} menu, select \emph{Look and Feel
  Configuration}.

  \begin{figure}
  \centering
  \includegraphics{./images/upgrading-themes-look-and-feel-menu.png}
  \caption{You can find the portlet ID in the \emph{Look and Feel
  Configuration} menu.}
  \end{figure}
\item
  Select the \emph{Advanced Styling} tab.

  The \texttt{Portlet\ ID} value appears in the blue box.
\end{enumerate}

\begin{figure}
\centering
\includegraphics{./images/upgrading-themes-portlet-id.png}
\caption{The portlet ID appears within the blue box in the
\emph{Advanced Styling} tab.}
\end{figure}

The
\href{/docs/7-1/reference/-/knowledge_base/r/fully-qualified-portlet-ids}{Portlet
ID Quick Reference Guide} shows all the default portlet IDs. Check
\texttt{liferay-portlet.xml} for the portlet ID number in 6.2 and
replace it with the updated ID in the quick reference Guide.

\noindent\hrulefill

\textbf{Remember} to use the updated \texttt{.xml} extension for your
web content articles in your sitemap.

\noindent\hrulefill

\subsection{Related Topics}\label{related-topics-130}

\href{/docs/7-1/tutorials/-/knowledge_base/t/updating-6-2-css-code}{Updating
6.2 CSS Code}

\href{/docs/7-1/tutorials/-/knowledge_base/t/applying-clay-design-patterns-to-6-2-themes}{Applying
Clay Design Patterns to 6.2 Themes}

\section{Applying Clay Design
Patterns}\label{applying-clay-design-patterns}

7.0 uses \href{https://liferay.github.io/clay/}{Clay}, a web
implementation of Liferay's \href{https://lexicondesign.io/}{Lexicon
Experience Language}. The Lexicon Experience Language provides styling
guidelines and best practices for application UIs. Clay's CSS, HTML, and
JavaScript components enable developers to build fully-realized UIs
quickly and effectively. Liferay DXP's
\href{/docs/7-1/tutorials/-/knowledge_base/t/using-the-bootstrap-3-lexicon-css-compatibility-layer}{compatibility
layer} let's you use \href{https://lexiconcss.wedeploy.io/}{Lexicon CSS}
markup alongside \href{https://clayui.com/}{Clay CSS}.

\noindent\hrulefill

\textbf{Note:} The compatibility layer is meant as a short-term solution
to ensure that your Bootstrap 3 and Lexicon CSS components aren't broken
while you update your theme to use
\href{https://getbootstrap.com/docs/4.3/migration/}{Bootstrap 4} and
\href{https://clayui.com/docs/css-framework/scss.html}{Clay CSS}. It
will be disabled in a future release. Migrate your theme to use
Bootstrap 4 and Clay CSS as soon as you're able to.

\noindent\hrulefill

This section demonstrates how to apply Clay to your HTML markup. For
example, this is the Liferay Portal 6.2 Lunar Resort's reservation form:

\begin{verbatim}
<p>
Thanks for choosing to stay at the Liferay Lunar Resort! Please fill out the 
form below to book your stay. We know you have a choice in where to stay on 
the Moon... 
oh wait no you don't. Thanks for picking us anyways. We'll see you soon on 
the Moon!
</p>

<form class="form-horizontal">
        <fieldset>
          <legend>Reservation Form</legend>
          <div class="control-group">
              <label class="control-label" for="inputName">Name</label>
              <div class="controls">
                      <input type="text" id="inputName"
                      placeholder="Enter your Name here" required="required">
                  </div>
          </div>
          <div class="control-group">
              <label class="control-label" for="inputEmail">Email</label>
              <div class="controls">
                  <input type="email" id="inputEmail"
                  placeholder="Enter your E-Mail here" required="required">
              </div>
          </div>
          <div class="control-group">
              <div class="controls">
                  <button type="submit" class="btn">Submit</button>
              </div>
          </div>
        </fieldset>
</form>

<p style="padding-bottom:25px;">
Thanks again for booking with Liferay. When you book with Liferay, you 
remember your stay. Please take a moment to fill out our guestbook below. 
</p>
\end{verbatim}

The HTML code above uses Bootstrap 2's markup and CSS classes. Here's
the Lunar Resort form's updated Clay markup:

\begin{verbatim}
<p>
Thanks for choosing to stay at the Liferay Lunar Resort! Please fill out the 
form below to book your stay. We know you have a choice in where to stay on 
the Moon... 
oh wait no you don't. Thanks for picking us anyways. We'll see you soon on 
the Moon!
</p>

<form role="form-horizontal">
        <fieldset>
          <legend>Reservation Form</legend>
          <div class="form-group">
              <label for="inputName">Name</label>
              <input type="text" id="inputName" class="form-control"
              placeholder="Enter your Name here" required="required">
          </div>
          <div class="form-group">
              <label for="inputEmail">Email</label>
              <input type="email" id="inputEmail" class="form-control"
              placeholder="Enter your E-Mail here" required="required">
          </div>
          <div class="form-group">
                  <button type="submit" class="btn btn-primary">Submit
                  </button>
          </div>
        </fieldset>
</form>

<p style="padding-bottom:25px;">Thanks again for booking with Liferay. When 
you book with Liferay, you remember your stay. Please take a moment to fill 
out our guestbook below.</p>
\end{verbatim}

The Clay updates applied to the form are as follows:

\begin{itemize}
\tightlist
\item
  The \texttt{control-group} classes were updated to \texttt{form-group}
  classes.
\item
  The \texttt{control-label} classes were removed from the
  \texttt{label} elements.
\item
  The \texttt{\textless{}div\ class=""controls\textgreater{}} elements
  were removed.
\item
  The \texttt{form-control} class was added to each \texttt{input}
  element.
\item
  To emphasize the form's submit button, the \texttt{btn-primary} class
  was added.
\end{itemize}

You can apply similar Clay patterns to your theme's HTML files.

You've updated your theme to 7.0! You can deploy it from your theme
project. Now your users can continue enjoying the visual styles you've
created in your upgraded themes.

\subsection{Related Topics}\label{related-topics-131}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-themes}{Liferay
Theme Generator}

\href{/docs/7-1/deploy/-/knowledge_base/d/upgrading-to-liferay-71}{Upgrading
to 7.0}

\chapter{Upgrading Your Theme from Liferay Portal 7.0 to
7.1}\label{upgrading-your-theme-from-liferay-portal-7.0-to-7.1}

This section of tutorials guides you through the process of upgrading
your 7.0 theme to run on 7.0. While you're at it, you should leverage
theme improvements, including support for Bootstrap 4 and Lexicon 2.0.

Theme upgrades involve these steps:

\begin{itemize}
\tightlist
\item
  Updating project metadata
\item
  Updating CSS
\item
  Updating theme templates
\end{itemize}

No matter the environment in which you're developing your theme, these
tutorials explain everything required to upgrade it. The easiest option
is to use the gulp \texttt{upgrade} task. This, however, is only
available for themes created with the
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-themes}{Liferay
Theme Generator}. If you're upgrading in an environment other than the
themes generator, follow the other tutorials in this section to upgrade
your theme manually.

\section{Upgrading Themes Created With the Liferay Theme
Generator}\label{upgrading-themes-created-with-the-liferay-theme-generator}

A Liferay Portal 7.0 theme can be upgraded to 7.0, regardless of its
project environment (Liferay Theme Generator, Plugins SDK, Maven, etc.).
But a theme created with the Liferay Theme Generator can leverage the
theme's \texttt{gulp\ upgrade} task. If you're developing your theme in
an environment other than the Themes Generator, the
\texttt{gulp\ upgrade} task doesn't work for your theme. Please follow
the manual directions in the remaining tutorials in this section to
upgrade your theme manually.

Here's what the Upgrade Task does:

\begin{itemize}
\tightlist
\item
  Updates the theme's Liferay version
\item
  Updates the theme's Bootstrap version
\item
  Updates the theme's Lexicon version
\item
  Suggests specific code updates
\end{itemize}

Here are the steps for using the theme Gulp \texttt{upgrade} task:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Navigate to your theme's root directory.
\item
  Update the path of your Liferay DXP server in your theme's
  \texttt{liferay-theme.json} file to point to your 7.1 Liferay DXP
  server. You can use the \texttt{gulp\ init} task to update the path to
  your server.
\item
  Run the command below to update liferay-theme-tasks to the latest
  version:

\begin{verbatim}
npm update liferay-theme-tasks
\end{verbatim}
\item
  Run the command below to upgrade the theme:

\begin{verbatim}
gulp upgrade
\end{verbatim}

  Here's what it does:

  \begin{itemize}
  \tightlist
  \item
    Copies the existing theme to a folder called \texttt{\_backup}
  \item
    Creates core code for generating theme base files
  \item
    Collects removed Bootstrap and Lexicon variables
  \item
    Updates Bootstrap version references
  \item
    Updates Lexicon version references
  \item
    Updates Liferay version references
  \end{itemize}
\end{enumerate}

\noindent\hrulefill

\textbf{Note}: The \texttt{gulp\ upgrade} task overwrites the theme's
files. We recommend that you backup your theme's files before running
it.

\noindent\hrulefill

The Gulp task list any deprecated or removed variables. For other areas
of the code it suspects might need updates, it logs suggestions. The
task also reports changes that may affect
\href{/docs/7-1/tutorials/-/knowledge_base/t/updating-theme-templates}{theme
templates}.

The Gulp \texttt{upgrade} task jump-starts the upgrade process, but it
doesn't complete it. Manual updates are required.

The rest of the tutorials in this section explain all the theme upgrade
steps, regardless of whether the \texttt{gulp\ upgrade} task performs
them. Steps the upgrade task performs are noted in context. Even if
you've already executed the upgrade task, it's best to learn all the
steps and make sure they're applied to your theme.

\subsection{Related Topics}\label{related-topics-132}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-themes}{Creating
Themes}

\href{/docs/7-1/tutorials/-/knowledge_base/t/updating-project-metadata}{Updating
Project Metadata}

\section{Updating Project Metadata}\label{updating-project-metadata}

If your theme uses the
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-themes}{Liferay
Theme Generator}, the
\href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-themes-created-with-the-theme-generator}{gulp
upgrade task} automatically updates your theme's metadata as part of the
upgrade process. If you're developing your theme in an environment other
than the themes generator, follow the steps below to update your theme's
metadata manually:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open your theme's \texttt{liferay-plugin-package.properties} file and
  change the \texttt{liferay-versions} property value to
  \texttt{7.1.0+}:

\begin{verbatim}
liferay-versions=7.1.0+
\end{verbatim}
\item
  Open the \texttt{liferay-look-and-feel.xml} file and specify
  \texttt{7.1.0+} as the compatibility version:

\begin{verbatim}
<look-and-feel>
        <compatibility>
                <version>7.1.0+</version>
        </compatibility>

        ...

</look-and-feel>
\end{verbatim}
\item
  If your theme uses the Liferay Theme Generator, open the
  \texttt{package.json} file and update the file's Liferay version
  references to \texttt{7.1}. Update the \texttt{liferayTheme}'s
  \texttt{templateLanguage} to \texttt{ftl} (since Velocity theme
  templates are no longer supported), and update its \texttt{version} to
  \texttt{7.1}:

\begin{verbatim}
"liferayTheme": {
    ...
    "templateLanguage": "ftl",
    "version": "7.1"
},
\end{verbatim}
\item
  Update the \texttt{liferay-theme-deps-7-0} dependency to
  \texttt{liferay-theme-deps-7.1} with the version below, and add the
  \texttt{liferay-theme-tasks} dependency as shown in the example
  configuration below:

\begin{verbatim}
"devDependencies": {
    "gulp": "3.9.1",
    "liferay-theme-tasks": "8.0.0-alpha.6",
    "liferay-theme-deps-7.1": "8.0.0-alpha.6"
},
\end{verbatim}
\end{enumerate}

Your theme's Liferay version references are updated for 7.0.

\subsection{Related Topics}\label{related-topics-133}

\href{/docs/7-1/tutorials/-/knowledge_base/t/updating-css-code}{Updating
CSS Code}

\href{/docs/7-1/tutorials/-/knowledge_base/t/developing-themes}{Developing
Themes}

\section{Updating CSS Code}\label{updating-css-code}

7.0's UI improvements required these CSS-related changes:

\begin{itemize}
\tightlist
\item
  Renaming CSS files
\item
  Class variable changes
\item
  Updating core imports
\end{itemize}

The theme upgrade process involves conforming to these changes. Now
you'll update your theme's CSS files to reflect these changes. Start
with updating CSS file names.

\subsection{Updating CSS File Names for
Clay}\label{updating-css-file-names-for-clay}

Some of the CSS filenames have changed to reflect the introduction of
Clay (previously Lexicon CSS). The filename changes for the unstyled
theme are listed below. Refer to the
\href{/docs/7-1/reference/-/knowledge_base/r/theme-reference-guide}{Theme
Reference Guide} for a complete list of expected theme CSS files.

The old 7.0 aui filenames are shown below:

\begin{itemize}
\tightlist
\item
  \texttt{css/}

  \begin{itemize}
  \tightlist
  \item
    \texttt{\_aui\_custom.scss}
  \item
    \texttt{\_aui\_variables.scss}
  \item
    \texttt{aui.scss}
  \end{itemize}
\end{itemize}

Rename the aui files to match the updated 7.1 clay filenames shown
below:

\begin{itemize}
\tightlist
\item
  \texttt{css/}

  \begin{itemize}
  \tightlist
  \item
    \texttt{\_clay\_custom.scss}
  \item
    \texttt{\_clay\_variables.scss}
  \item
    \texttt{clay.scss}
  \end{itemize}
\end{itemize}

Next, you can note the removed and deprecated variables and mixins for
Bootstrap 4 and Lexicon.

\subsection{Class Variable Changes}\label{class-variable-changes}

7.0 uses Bootstrap 4's CSS rule syntax. The new syntax lets developers
leverage Bootstrap 4 features and improvements. If your theme does not
use the Liferay Theme Generator, you can refer to the
\href{https://getbootstrap.com/docs/4.0/migration/}{Migrating to v4
guide} for updating CSS rules to Bootstrap 4.

If your theme uses the Liferay Theme Generator, the
\texttt{gulp\ upgrade} task suggests manual updates. For example, here
is part of the task log for the 7.0 Westeros Bank theme:

\begin{verbatim}
    ----------------------------------------------------------------
     Lexicon Upgrade (1.0 to 2.0)
    ----------------------------------------------------------------

    File: _variables_custom.scss
        $brand-default was deprecated in Lexicon CSS 1.x.x and has been removed 
            in the new Clay 2.x.x version
\end{verbatim}

The log lists removed and/or deprecated variables and suggests possible
changes. For each update performed or suggested, the task reports a file
name. For reference, here's the full list of variable changes:

The following variables were removed in Bootstrap 4:

\begin{verbatim}
    $line-height-computed
    $padding-base-horizontal
    $padding-base-vertical
    $padding-large-horizontal
    $padding-large-vertical
    $padding-small-horizontal
    $padding-small-vertical
    $padding-xs-horizontal
    $padding-xs-vertical
    $gray-base
    $gray-darker
    $gray-dark
    $gray
    $gray-light
    $gray-lighter
    $brand-primary
    $brand-success
    $brand-info
    $brand-warning
    $brand-danger
    $state-success-text
    $state-success-bg
    $state-success-border
    $state-info-text
    $state-info-bg
    $state-info-border
    $state-warning-text
    $state-warning-bg
    $state-warning-border
    $state-danger-text
    $state-danger-bg
    $state-danger-border
\end{verbatim}

See \href{https://getbootstrap.com/docs/4.0/migration/}{Bootstrap
Migration Guide} for a full list of the changes.

The following Lexicon variables were deprecated in Lexicon CSS 1.x.x and
are removed in the new Clay 2.x.x version:

\begin{verbatim}
    $atlas-theme
    $box-shadow-default
    $box-shadow-default-bg
    $box-shadow-default-blur
    $box-shadow-default-spread
    $box-shadow-default-x
    $box-shadow-default-y
    $brand-danger-active
    $brand-danger-hover
    $brand-default
    $brand-default-active
    $brand-default-hover
    $brand-info-active
    $brand-info-hover
    $brand-primary-active
    $brand-primary-hover
    $brand-success-active
    $brand-success-hover
    $brand-warning-active
    $brand-warning-hover
    $inverse-active-bg
    $inverse-active-border
    $inverse-active-color
    $inverse-bg
    $inverse-border
    $inverse-color
    $inverse-disabled-color
    $inverse-header-bg
    $inverse-header-border
    $inverse-header-color
    $inverse-hover-bg
    $inverse-hover-border
    $inverse-hover-color
    $inverse-link-color
    $inverse-link-hover-color
    $state-danger-bg
    $state-danger-border
    $state-danger-text
    $state-default-bg
    $state-default-border
    $state-default-text
    $state-info-bg
    $state-info-border
    $state-info-text
    $state-primary-bg
    $state-primary-border
    $state-primary-text
    $state-success-bg
    $state-success-border
    $state-success-text
    $state-warning-bg
    $state-warning-border
    $state-warning-text
\end{verbatim}

The following Lexicon mixins are removed in Clay 2.x.x:

\texttt{@mixin\ color-placeholder}:

Lexicon's
\texttt{color-placeholder(\$element,\ \$color:\ \$input-color-placeholder)}
mixin is deprecated as of v1.0.9 and was removed in v2.0.0. Please use
\texttt{placeholder(\$color:\ \$input-color-placeholder)} instead.

\texttt{@mixin\ select-box-icon}:

Lexicon's \texttt{select-box-icon(\$color)} mixin is deprecated as of
v1.0.10 and was removed in v2.0.0. Please use
\texttt{background-image:\ lx-icon(\$name,\ \$color)} instead.

Note that if the \texttt{gulp\ upgrade} task detects any variables in
your theme that have been removed in Clay from the previous LexiconCSS
version, it adds the \texttt{\_variables\_deprecated.scss} file to your
theme with the variables to make sure the theme compiles and to decouple
it from future upgrades. If you wish to include this file manually, here
are its contents for reference:

\begin{verbatim}
@warn "You're using deprecated variables. Please refer to the update guides 
to remove its usage";

// Deprecated `$brand-*-*` as of v1.0.24, removed in v2.0.0
$brand-default: #869CAD !default; // Atlas
$brand-default-active: darken($brand-default, 12%) !default; // Atlas
$brand-default-hover: darken($brand-default, 8%) !default; // Atlas

$brand-primary: #65B6F0 !default;
$brand-primary-active: darken($brand-primary, 12%) !default; // Atlas
$brand-primary-hover: darken($brand-primary, 8%) !default; // Atlas

$brand-success: #76BD4A !default;
$brand-success-active: darken($brand-success, 12%) !default; // Atlas
$brand-success-hover: darken($brand-success, 8%) !default; // Atlas

$brand-info: #1E5EC8 !default;
$brand-info-active: darken($brand-info, 12%) !default; // Atlas
$brand-info-hover: darken($brand-info, 8%) !default; // Atlas

$brand-warning: #F5984C !default;
$brand-warning-active: darken($brand-warning, 12%) !default; // Atlas
$brand-warning-hover: darken($brand-warning, 8%) !default; // Atlas

$brand-danger: #C67 !default;
$brand-danger-active: darken($brand-danger, 12%) !default; // Atlas
$brand-danger-hover: darken($brand-danger, 8%) !default; // Atlas

// Box Shadow
// Defines global box-shadows

// Deprecated `$box-shadow-default-*` as of v1.0.24, removed in v2.0.0
$box-shadow-default-x: 0 !default; // Atlas
$box-shadow-default-y: 0 !default; // Atlas
$box-shadow-default-blur: 3px !default; // Atlas
$box-shadow-default-spread: 1px !default; // Atlas
$box-shadow-default-bg: rgba(0, 0, 0, 0.2) !default; // Atlas
$box-shadow-default: $box-shadow-default-x $box-shadow-default-y $box-shadow-default-blur $box-shadow-default-spread $box-shadow-default-bg !default; // Atlas

// Inverse Colors

// Deprecated `$inverse-*` as of v1.0.24, removed in v2.0.0
$inverse-bg: #1F282E !default; // Atlas
$inverse-border: darken($inverse-bg, 10%) !default; // Atlas
$inverse-color: #869CAD !default; // Atlas

$inverse-active-bg: #3A4D5A !default; // Atlas
$inverse-active-border: darken($inverse-active-bg, 1%) !default; // Atlas
$inverse-active-color: #FFF !default; // Atlas

$inverse-disabled-color: #394956 !default; // Atlas

$inverse-hover-bg: #1C252C !default; // Atlas
$inverse-hover-border: darken($inverse-hover-bg, 1%) !default; // Atlas
$inverse-hover-color: $inverse-color !default; // Atlas

$inverse-header-bg: #1B2228 !default; // Atlas
$inverse-header-border: darken($inverse-header-bg, 1%) !default; // Atlas
$inverse-header-color: $inverse-color !default; // Atlas

$inverse-link-color: #FFF !default; // Atlas
$inverse-link-hover-color: $inverse-link-color !default; // Atlas

// States for Form and alert

// Deprecated `$state-*-*` as of v1.0.24, removed in v2.0.0
$state-default-text: $brand-default !default; // Atlas
$state-default-bg: lighten($state-default-text, 34%) !default; // Atlas
$state-default-border: $state-default-text !default; // Atlas

$state-primary-text: $brand-primary !default; // Atlas
$state-primary-bg: lighten($state-primary-text, 12%) !default; // Atlas
$state-primary-border: $state-primary-text !default; // Atlas

$state-success-text: $brand-success !default;

$state-success-bg: lighten($state-success-text, 34%) !default;
$state-success-border: $state-success-text !default;

$state-info-text: $brand-info !default;

$state-info-bg: lighten($state-info-text, 34%) !default;
$state-info-border: $state-info-text !default;

$state-warning-text: $brand-warning !default;

$state-warning-bg: #F8F4D5 !default;
$state-warning-border: $state-warning-text !default;

$state-danger-text: $brand-danger !default;

$state-danger-bg: lighten($state-danger-text, 34%) !default;
$state-danger-border: $state-danger-text !default;
\end{verbatim}

After updating your theme's CSS variables and mixins, you should update
the Font Awesome Icon imports.

\subsection{Updating Font Awesome Icon
Imports}\label{updating-font-awesome-icon-imports}

Originally in Liferay Portal CE 7.0 and Liferay DXP, Font Awesome icons
were imported in \texttt{\_aui\_variables.scss} (now renamed
\texttt{\_clay\_variables.scss}). Font Awesome icons were later moved to
the
\href{/docs/7-1/tutorials/-/knowledge_base/t/using-the-bootstrap-3-lexicon-css-compatibility-layer}{compatibility
layer}. If your 7.0 theme was made prior to this move and you modified
\texttt{\_aui\_variables.scss}, you must remove the Font Awesome imports
shown below:

\begin{verbatim}
    // Icon paths
    $FontAwesomePath: "aui/lexicon/fonts/alloy-font-awesome/font";
    $font-awesome-path: "aui/lexicon/fonts/alloy-font-awesome/font";
    $icon-font-path: "aui/lexicon/fonts/";
\end{verbatim}

Next you can update the core imports.

\subsection{Updating Core Imports}\label{updating-core-imports}

Update the old aui lexicon paths to use the clay paths instead, as shown
in the table below:

\noindent\hrulefill

Pattern\textbar Replacement\textbar{}
\texttt{@import\ "/aui/lexicon/bootstrap/mixins/";}\textbar removed\textbar{}
\texttt{@import\ "/aui/lexicon/lexicon-base/mixins/";}\textbar removed\textbar{}
\texttt{@import\ "/aui/lexicon/atlas-theme/mixins/";}\textbar removed\textbar{}
\texttt{@import\ "aui/lexicon/atlas-variables";}\textbar{}\texttt{@import\ "clay/atlas-variables";}\textbar{}
\texttt{@import\ "aui/lexicon/atlas";}\textbar{}\texttt{@import\ "clay/atlas";}\textbar{}

\noindent\hrulefill

\subsection{Related Topics}\label{related-topics-134}

\href{/docs/7-1/tutorials/-/knowledge_base/t/updating-theme-templates}{Updating
Theme Templates}

\href{/docs/7-1/tutorials/-/knowledge_base/t/copying-an-existing-themes-files}{Copying
an Existing Theme's Files}

\section{Updating Theme Templates}\label{updating-theme-templates}

7.0 theme templates are essentially the same as Liferay Portal 7.0 theme
templates. Here are the main changes:

\begin{itemize}
\tightlist
\item
  Velocity templates were deprecated in Liferay Portal CE 7.0 and are
  now removed in favor of FreeMarker templates in Liferay DXP.
\end{itemize}

Key reasons for using FreeMarker templates and removing Velocity
templates are these:

\begin{itemize}
\item
  FreeMarker is developed and maintained regularly, while Velocity is no
  longer actively being developed.
\item
  FreeMarker is faster and supports more sophisticated macros.
\item
  FreeMarker supports using taglibs directly rather than requiring a
  method to represent them. You can pass body content to them,
  parameters, etc.
\end{itemize}

You should start by addressing the Velocity theme templates. Since
Velocity theme templates are no longer supported, \textbf{you must
convert your Velocity theme templates to FreeMarker}.

If you're using the Liferay Theme Generator, the \texttt{gulp\ upgrade}
command reports the required theme template changes in the log.

For example, here is the \texttt{gulp\ upgrade} log for the Westeros
Bank theme:

\begin{verbatim}
----------------------------------------------------------------
 Liferay Upgrade (7.0 to 7.1)
----------------------------------------------------------------

Renamed aui.scss to clay.scss
File: footer.ftl
    Warning: .container-fluid-1280 has been deprecated. Please use 
    .container-fluid.container-fluid-max-xl instead.
File: portal_normal.ftl
    Warning: .navbar-header has been removed. This container should be 
    removed in most cases. Please, use your own container if necessary.
\end{verbatim}

The log warns about removed and deprecated code and suggests
replacements when applicable. For reference, the main changes appear
below:

\begin{itemize}
\item
  List items inside a container with the \texttt{list-inline} class
  \href{https://getbootstrap.com/docs/4.0/migration/\#typography}{now
  require} the \texttt{list-inline-item} class.
\item
  The \texttt{container-fluid-1280} class has been deprecated. Please
  use \texttt{container-fluid\ container-fluid-max-xl} instead.
\item
  Responsive navbar behaviors
  \href{https://getbootstrap.com/docs/4.0/migration/\#navbar}{are now
  applied} to the \texttt{navbar} class via the required
  \texttt{navbar-expand-\{breakpoint\}} class.
\item
  The \texttt{navbar-toggle} class is now \texttt{navbar-toggler} and
  \href{https://getbootstrap.com/docs/4.0/migration/\#navbar}{has
  different inner markup}.
\item
  The \texttt{navbar-header} class has been removed. This container
  should be removed in most cases. Please, use your own container if
  necessary.
\end{itemize}

Next, you'll learn how to update various theme templates to 7.0. If you
didn't modify any theme templates, you can skip these sections.

\subsection{Updating Portal Normal
FTL}\label{updating-portal-normal-ftl-1}

The first one to update is the \texttt{portal\_normal.ftl} theme
template. If you didn't customize \texttt{portal\_normal.ftl}, you can
skip this section. Follow the steps below to update
\texttt{portal\_normal.ftl}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open your modified \texttt{portal\_normal.ftl} file and remove the
  breadcrumbs:

\begin{verbatim}
<nav id="breadcrumbs">      
    <@liferay.breadcrumbs />        
</nav>
\end{verbatim}
\item
  Remove \texttt{id="main-surface"} from the \texttt{body} tag. This is
  not needed for SPA to work properly:

\begin{verbatim}
<body class="${css_class}" id="main-surface">
\end{verbatim}
\end{enumerate}

If you modified the portlet template for your theme, follow the steps in
the next section.

\subsection{Updating Portlet FTL}\label{updating-portlet-ftl-1}

Follow these steps to update your modified \texttt{portlet.ftl} file:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Find the
  \texttt{\textless{}a\ class="icon-monospaced\ portlet-icon-back\ text-default"\ \ \ \ \ \ href="\$\{portlet\_back\_url\}"\ title="\textless{}@liferay.language\ \ \ \ \ \ key="return-to-full-page"\ /\textgreater{}"\textgreater{}}
  element and add the \texttt{list-unstyled} class to it:

\begin{verbatim}
<a 
  class="icon-monospaced list-unstyled portlet-icon-back text-default" 
  href="${portlet_back_url}" 
  title="<@liferay.language key="return-to-full-page" />"
>
\end{verbatim}
\item
  Find the
  \texttt{\textless{}div\ class="autofit-float\ autofit-row"\textgreater{}}
  element and add the \texttt{portlet-header} class to it:

\begin{verbatim}
<div class="autofit-float autofit-row portlet-header">
\end{verbatim}
\end{enumerate}

The portlet template is updated. That covers most, if not all, of the
required theme template changes. If you modified any other FreeMarker
theme templates, you can compare them with templates in the
\href{https://github.com/liferay/liferay-portal/tree/7.1.x/modules/apps/frontend-theme/frontend-theme-unstyled/src/main/resources/META-INF/resources/_unstyled/templates}{\texttt{\_unstyled}
theme}. If your theme uses the Liferay Theme Generator, refer to the
suggested changes that the \texttt{gulp\ upgrade} task reports.

\subsection{Related Topics}\label{related-topics-135}

\href{/docs/7-1/tutorials/-/knowledge_base/t/updating-css-code}{Updating
CSS Code}

\href{/docs/7-1/tutorials/-/knowledge_base/t/making-configurable-theme-settings}{Making
Configurable Theme Settings}

\section{Using the Bootstrap 3 Lexicon CSS Compatibility
Layer}\label{using-the-bootstrap-3-lexicon-css-compatibility-layer}

By default, Liferay DXP includes Bootstrap 4 out-of-the-box. Bootstrap 4
has been completely rewritten and therefore includes some
\href{https://getbootstrap.com/docs/4.1/migration/}{notable changes} and
\href{http://getbootstrap.com/docs/4.1/getting-started/browsers-devices/}{compatibility
updates} that may be cause for concern if your theme uses Bootstrap 3 or
Lexicon CSS. Not to worry though. To ensure that your upgrade runs
smoothly, Liferay DXP includes a compatibility layer so you can use
Bootstrap 3 markup and Lexicon CSS markup alongside the new Bootstrap 4
and Clay CSS. The bundled icon fonts (Font Awesome v3.2.1 and Glyphicons
3) were moved to the compatibility layer's
\href{https://github.com/liferay/liferay-portal/blob/7.1.x/modules/apps/frontend-theme/frontend-theme-styled/src/main/resources/META-INF/resources/_styled/css/compat/_components.scss\#L3-L4}{\texttt{\_components.scss}}
file as well. If your theme extends the
\href{https://github.com/liferay/liferay-portal/tree/7.1.x/modules/apps/frontend-theme/frontend-theme-styled}{Styled
base theme}, this compatibility layer is included by default.

\noindent\hrulefill

\textbf{Note:} The compatibility layer is meant as a short-term solution
to ensure that your Bootstrap 3 and Lexicon CSS components aren't broken
while you update your theme to use
\href{https://getbootstrap.com/docs/4.3/migration/}{Bootstrap 4} and
\href{https://clayui.com/docs/css-framework/scss.html}{Clay CSS}. It
will be disabled in a future release. Migrate your theme to use
Bootstrap 4 and Clay CSS as soon as you're able to.

\noindent\hrulefill

Follow these guidelines to update your markup:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  See how your theme looks with the compatibility layer enabled (it's
  enabled by default).
\item
  Individually disable the component(s) in the compatibility layer that
  you don't need. These are listed in the
  \href{https://github.com/liferay/liferay-portal/blob/7.1.x/modules/apps/frontend-theme/frontend-theme-styled/src/main/resources/META-INF/resources/_styled/css/compat/_variables.scss}{\texttt{css/compat/\_variables.scss}}
  file. For convenience, the components are listed below:

\begin{verbatim}
// Compatibility layer components config

$compat-alerts: true !default;
$compat-basic_search: true !default;
$compat-breadcrumbs: true !default;
$compat-button_groups: true !default;
$compat-buttons: true !default;
$compat-cards: true !default;
$compat-component_animations: true !default;
$compat-dropdowns: true !default;
$compat-figures: true !default;
$compat-form_validation: true !default;
$compat-forms: true !default;
$compat-grid: true !default;
$compat-icons: true !default;
$compat-labels: true !default;
$compat-liferay: true !default;
$compat-list_groups: true !default;
$compat-management_bar: true !default;
$compat-modals: true !default;
$compat-nav_tabs: true !default;
$compat-navbar: true !default;
$compat-navs: true !default;
$compat-pager: true !default;
$compat-pagination: true !default;
$compat-panels: true !default;
$compat-progress_bars: true !default;
$compat-responsive_utilities: true !default;
$compat\noindent\hrulefill: true !default;
$compat-simple_flexbox_grid: true !default;
$compat-stickers: true !default;
$compat-tables: true !default;
$compat-toggle_card: true !default;
$compat-toggle_switch: true !default;
$compat-toolbar: true !default;
$compat-user_icons: true !default;
$compat-utilities: true !default;
\end{verbatim}

  To disable a component, add the component you want to remove
  compatibility for to \texttt{/src/css/\_clay\_custom.scss} (create
  this file if it doesn't exist) and set its value to \texttt{false}.
  The example below removes compatibility for alerts and cards:

\begin{verbatim}
$compat-alerts: false !default;
$compat-cards: false !default;
\end{verbatim}
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** Some Liferay DXP components haven't been migrated to Bootstrap 4.
 Disabling certain components might cause portions of the UI to break.
 Therefore, after upgrading your markup, we recommend that you re-enable any
 components you disable. Proceed with caution.
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\item
  Update your markup to Bootstrap 4 and Clay CSS until you're satisfied
  with the result.
\item
  Re-enable any components you disabled in the compatibility layer by
  removing any components you set to false in
  \texttt{/src/css/\_clay\_custom.scss}. This ensures that Liferay DXP's
  UI isn't broken.
\end{enumerate}

Now you know how to use the Bootstrap 3 and Lexicon CSS compatibility
layer to provide a smooth transition during your theme upgrade.

\subsection{Related Topics}\label{related-topics-136}

\href{/docs/7-1/tutorials/-/knowledge_base/t/updating-css-code}{Updating
CSS Code}

\href{/docs/7-1/tutorials/-/knowledge_base/t/updating-project-metadata}{Updating
Project Metadata}

\chapter{Layout Templates}\label{layout-templates}

Layout templates define how content can be placed on a page. Liferay DXP
includes several default layout templates out-of-the-box that you can
use to organize content on your pages:

\begin{figure}
\centering
\includegraphics{./images/page-select-layout.png}
\caption{There are many default layout templates to choose from.}
\end{figure}

If you require a layout for your content that's not provided, you can
create your own layout templates. In this section of tutorials, you'll
learn how to develop layout templates for Liferay DXP.

\section{Creating Layout Templates}\label{creating-layout-templates}

Layout Templates specify how content is arranged on your site pages, as
shown in the \emph{1-2-1 Columns} layout below:

\begin{figure}
\centering
\includegraphics{./images/layout-template-1-2-1-columns.png}
\caption{The \emph{1-2-1 Columns} page layout creates a nice flow for
your content.}
\end{figure}

The
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-themes}{Liferay
Theme Generator} provides a Layouts sub-generator that helps automate
layout template creation. This tutorial covers how to use this tool to
create layout templates. Install the Liferay Theme Generator if it's not
already installed, then follow these steps to create a layout template:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open the Command Line and navigate to the folder you want to create
  your layout template in.
\item
  Run The Layouts sub-generator and follow the prompts to create your
  layout:

\begin{verbatim}
`yo liferay-theme:layout`
\end{verbatim}

  \begin{figure}
  \centering
  \includegraphics{./images/layout-prompt.png}
  \caption{The Layouts sub-generator automates the layout creation
  process.}
  \end{figure}
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** Run the Layouts sub-generator from the theme's root folder to
 bundle it with the theme. This adds the layout template to the theme's
 `src/layouttpl/custom` folder. This **only works** for generated themes.
\end{verbatim}

\noindent\hrulefill

\begin{verbatim}
Every row consists of 12 sections, so columns can range in size from 1 to 12. 
Once you've entered a value, the generator asks the size you want your row 
and column to be and presents you with the available width(s).

![ You must specify the width for each column in the row.](./images/layout-column-widths.png)

Choose from the available option(s) with your arrow keys and press Enter to 
make your selection. Repeat this process for the remaining columns.

The Layouts sub-generator provides the following options for layout 
templates:

- *Add a row:* Adds a row below the last row.

- *Insert row:* Displays a vi to insert your row. Use your arrow keys to 
choose where to insert your row, highlighted in blue, then press Enter to 
insert the row.

![ Rows can be inserted using the layout vi.](./images/insert-row.png)

- *Remove row:* Displays a vi to remove your row. Use your arrow keys to 
select the row you want to remove, highlighted in red, then press Enter to 
remove the row.

![ Rows are removed using the layout vi.](./images/remove-row.png)

![ Select the *Finish layout* option to complete your design.](./images/finish-layout.png)
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\tightlist
\item
  Run \texttt{gulp\ deploy} to deploy your layout template to the server
  you specified. If the layout is bundled with your theme, deploy the
  theme to deploy the layout template.
\end{enumerate}

\subsection{Related Topics}\label{related-topics-137}

\href{/docs/7-1/tutorials/-/knowledge_base/t/importing-resources-with-a-theme}{Importing
Resources with Your Themes}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-themes}{Creating
Themes}

\section{Creating Layout Templates
Manually}\label{creating-layout-templates-manually}

Although you can
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-layout-templates-with-the-themes-generator}{generate
layout templates with the Liferay Theme Generator},\\
you may prefer to create or modify them manually using your own tools.
In this tutorial you'll learn the anatomy of Liferay DXP's layout
templates so you can create layout templates manually or modify existing
ones.

\subsection{Understanding the Anatomy}\label{understanding-the-anatomy}

Layout templates are made of rows and columns. The design you create
specifies where users can place portlets on the page. An example row's
HTML markup is shown below:

\begin{verbatim}
<div class="portlet-layout row">
        <div class="col-md-4 col-sm-6 portlet-column portlet-column-first" 
        id="column-1">
                ${processor.processColumn("column-1", 
                "portlet-column-content portlet-column-content-first")}
        </div>
        <div class="col-md-8 col-sm-6 portlet-column portlet-column-last" 
        id="column-2">
                ${processor.processColumn("column-2", 
                "portlet-column-content portlet-column-content-last")}
        </div>
</div>
\end{verbatim}

Each row has a \texttt{div}, with the classes \texttt{portlet-layout}
and \texttt{row}, that contains child \texttt{div}s for each column.
Each column is indicated with the class \texttt{portlet-column}, as well
as a class that specifies whether it is the first
(\texttt{portlet-column-first}), last (\texttt{portlet-column-last}), or
only column in the row (\texttt{portlet-column-only}).

Columns use the
\href{https://getbootstrap.com/docs/4.0/layout/grid/}{Bootstrap grid
system} and can therefore range in width from 1 to 12. Sizes are
indicated with the number that follows the \texttt{col-{[}breakpoint{]}}
class prefix (e.g.~\texttt{col-md-6}). These specify two things: the
percentage based width of the element and the media query breakpoint
(\texttt{xs}, \texttt{sm}, \texttt{md}, or \texttt{lg}) for when this
element expands to 100\% width. 12 is the maximum amount, so
\texttt{col-md-6} indicates \texttt{6/12} width, or \texttt{50\%}. These
classes can also be mixed to achieve more advanced layouts, as shown
above. In the example, medium sized viewports display \texttt{column-1}
at 33.33\% width and \texttt{column-2} at 66.66\% width, but on small
sized view ports both \texttt{column-1} and \texttt{column-2} are 50\%
width.

The processor (\texttt{\$\{processor.processColumn()\}}) processes each
column's content, taking two arguments: the column's \texttt{id}, and
the classes \texttt{portlet-column-content} and
\texttt{portlet-column-content-{[}case{]}} (if applicable), where
\texttt{{[}case{]}} refers to the \texttt{first}, \texttt{last}, or
\texttt{only} column in the row.

\noindent\hrulefill

\textbf{Note:} Velocity layout templates are supported, but deprecated
as of 7.0. We recommend that you convert your Velocity layout templates
to FreeMarker at your earliest convenience.

\noindent\hrulefill

Now that you understand a layout template's anatomy, you can write your
own Liferay DXP layout templates!

\subsection{Related Topics}\label{related-topics-138}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-layout-templates-with-the-themes-generator}{Layout
Templates with the Liferay Theme Generator}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-themes}{Creating
Themes}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-custom-layout-template-thumbnail-previews}{Creating
Custom Layout Template Thumbnail Previews}

\section{Creating Custom Layout Template Thumbnail
Previews}\label{creating-custom-layout-template-thumbnail-previews}

If you
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-layout-templates-with-the-themes-generator}{created
a layout template with the Theme Generator}, it generated a default
thumbnail preview for your layout template. Follow these steps to create
a custom preview thumbnail for a layout template:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open the Command-line and navigate to the
  \texttt{docroot/layouttpl/custom} folder of your layout template. If
  you created the layout template in a theme created with the Liferay
  Theme Generator, the thumbnail is located in your theme's
  \texttt{src/layouttpl/custom} folder.
\item
  Replace the thumbnail PNG file, if it exists, with a custom thumbnail
  PNG with the same dimensions (120 x 120 px), or create a new one.
\item
  If including the layout template with a theme, specify the thumbnail's
  location in your theme's \texttt{liferay-look-and-feel.xml}, using the
  \texttt{\textless{}thumbnail-path\textgreater{}} tag. Below is an
  example configuration for the Porygon theme:

\begin{verbatim}
<layout-template id="porygon_50_50_width_limited" 
name="Porygon 2 Columns (50/50) width limited">
    <template-path>
        /layoutttpl/custom/porygon_50_50_width_limited.ftl
    </template-path>
    <thumbnail-path>
        /layoutttpl/custom/porygon_50_50_width_limited.png
    </thumbnail-path>
</layout-template>
\end{verbatim}
\end{enumerate}

Deploy your layout template to your app server to use it. If your layout
template is
\href{/docs/7-1/tutorials/-/knowledge_base/t/including-layout-templates-with-a-theme}{bundled
with a theme}, it deploys when the theme is deployed. Now you know how
to create a custom thumbnail preview for your Liferay DXP layout
templates!

\subsection{Related topics}\label{related-topics-139}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-layout-templates-with-the-themes-generator}{Layout
Templates with the Liferay Theme Generator}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-layout-templates-manually}{Creating
Layout Templates Manually}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-themes}{Creating
Themes}

\section{Including Layout Templates with a
Theme}\label{including-layout-templates-with-a-theme}

Although you can deploy a layout template by itself, you can also bundle
it with a theme. To include a layout template with a theme, follow these
steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open your theme's \texttt{liferay-look-and-feel.xml} file, and nest
  \texttt{\textless{}layout-templates\textgreater{}} tags in between the
  \texttt{\textless{}theme\textgreater{}...\textless{}/theme\textgreater{}}
  tags so it matches the configuration below:

\begin{verbatim}
<theme id="my-theme-name" name="My Theme Name">
    ...
      <layout-templates>
        <custom>
            //layout template code goes here
        </custom>
      </layout-templates>
    ...
</theme>  
\end{verbatim}
\item
  Place the layout template in between the
  \texttt{\textless{}custom\textgreater{}...\textless{}/custom\textgreater{}}
  tags, using the \texttt{\textless{}layout-template\textgreater{}} tag.
  The \texttt{\textless{}layout-template\textgreater{}} tag's
  \texttt{id} attribute \textbf{must match} the layout template's
  filename. Below is an example configuration:

\begin{verbatim}
<layout-template id="my_liferay_layout_template" 
name="My Liferay Layout Template">
\end{verbatim}
\item
  Specify the layout template's path with a
  \texttt{\textless{}template-path\textgreater{}} tag, as shown below:

\begin{verbatim}
<template-path>
    /layoutttpl/custom/my_liferay_layout_template.ftl
</template-path>
\end{verbatim}
\item
  Specify the
  \href{/docs/7-1/tutorials/-/knowledge_base/t/creating-custom-layout-template-thumbnail-previews}{layout
  template thumbnail's} path with a
  \texttt{\textless{}thumbnail-path\textgreater{}} tag, as shown below:

\begin{verbatim}
<thumbnail-path>
    /layoutttpl/custom/my_liferay_layout_template.png
</thumbnail-path>
\end{verbatim}
\item
  Place the completed layout in your theme's \texttt{src/layouttpl}
  folder. Below is an example \texttt{liferay-look-and-feel}
  configuration:

\begin{verbatim}
<theme id="my-theme-name" name="My Theme Name">
    ...
      <layout-templates>
        <custom>
          <layout-template id="my_liferay_layout_template" 
          name="My Liferay Layout Template">
            <template-path>
                /layoutttpl/custom/my_liferay_layout_template.ftl
            </template-path>
            <thumbnail-path>
                /layoutttpl/custom/my_liferay_layout_template.png
            </thumbnail-path>
          </layout-template>
        </custom>
      </layout-templates>
    ...
</theme>
\end{verbatim}
\end{enumerate}

Now you know how to include layout templates with your Liferay DXP
themes!

\subsection{Related topics}\label{related-topics-140}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-custom-layout-template-thumbnail-previews}{Creating
Custom Layout Template Thumbnail Previews}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-layout-templates-with-the-themes-generator}{Layout
Templates with the Liferay Theme Generator}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-layout-templates-manually}{Creating
Layout Templates Manually}

\section{Upgrading 6.2 Layout Templates to
7.1}\label{upgrading-6.2-layout-templates-to-7.1}

Upgrading your Liferay DXP 6.2 layout template to 7.0 a few updates:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Open your layout template's \texttt{liferay-plugin-package.properties}
  file and update the \texttt{liferay-versions} property to
  \texttt{7.1.0+}:
\end{enumerate}

\begin{verbatim}
liferay-versions=7.1.0+
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\item
  Update the Bootstrap \texttt{span{[}number{]}} classes to use the
  newer \texttt{col-{[}size{]}-{[}number{]}} classes. See
  \href{/docs/7-1/tutorials/-/knowledge_base/t/creating-layout-templates-manually}{Creating
  Layout Templates Manually} for more information on Bootstrap's grid
  system.
\item
  Save the changes.
\end{enumerate}

\noindent\hrulefill

\textbf{Note:} Velocity layout templates are supported, but deprecated
as of 7.0. We recommend that you convert your Velocity layout templates
to FreeMarker at your earliest convenience. See
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-layout-templates-manually\#understanding-the-anatomy}{Creating
Layout Templates Manually} for an example of the updated syntax.

\noindent\hrulefill

\subsection{Related Topics}\label{related-topics-141}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-layout-templates-with-the-themes-generator}{Layout
Templates with the Liferay Theme Generator}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-layout-templates-manually}{Creating
Layout Templates Manually}

\href{/docs/7-1/tutorials/-/knowledge_base/t/including-layout-templates-with-a-theme}{Including
Layout Templates with a Theme}

\section{Upgrading 7.0 Layout Templates to
7.1}\label{upgrading-7.0-layout-templates-to-7.1}

If you're upgrading your Liferay DXP 7.0 layout template to 7.0, you
must upgrade your layout template version to 7.1:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open your layout template's \texttt{liferay-plugin-package.properties}
  file.
\item
  Update the \texttt{liferay-versions} property to \texttt{7.1.0+}:
\end{enumerate}

\begin{verbatim}
liferay-versions=7.1.0+
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\tightlist
\item
  Save the changes.
\end{enumerate}

\noindent\hrulefill

\textbf{Note:} Velocity layout templates are supported, but deprecated
as of 7.0. We recommend that you convert your Velocity layout templates
to FreeMarker at your earliest convenience. See
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-layout-templates-manually\#understanding-the-anatomy}{Creating
Layout Templates Manually} for an example of the updated syntax.

\noindent\hrulefill

\subsection{Related Topics}\label{related-topics-142}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-layout-templates-with-the-themes-generator}{Layout
Templates with the Liferay Theme Generator}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-layout-templates-manually}{Creating
Layout Templates Manually}

\href{/docs/7-1/tutorials/-/knowledge_base/t/including-layout-templates-with-a-theme}{Including
Layout Templates with a Theme}

\chapter{Portlets and Themes}\label{portlets-and-themes}

The default theme sets the basic look and feel for all your portlets,
and, through Portlet Decorators, gives you a way to fine-tune the look
of individual portlets with the click of a mouse. But you aren't limited
to defaults. The following sections explain

\begin{itemize}
\item
  how to modify themes to create custom templates for your portlets
\item
  how to create your own decorators to customize the look of your
  portlets individually
\item
  how to embed portlets in your themes, a function that lets you choose
  portlets to deploy automatically on any page where a given theme is
  used.
\end{itemize}

\section{Theming Portlets}\label{theming-portlets}

Themes can provide additional styles for your apps. You can change the
markup for portlet containers by modifying the theme's
\texttt{portlet.ftl} file.

This tutorial demonstrates how to style portlets with your themes.

\subsection{Portlet FTL}\label{portlet-ftl}

Although you can individually style a portlet via the theme's CSS or the
portlet's
\href{/docs/7-1/user/-/knowledge_base/u/look-and-feel-configuration}{Look
and Feel Configuration} menu, you may want to modify the default look
and feel for all portlets in your site. A portlet's template--its
container, CSS classes, and overall HTML Markup--is defined via the
theme's \texttt{portlet.ftl} file. To provide a custom style for all
portlets, use the CSS classes in this file for the various container
elements, in conjunction with the portlet decorators to achieve the
desired look and feel. Be cautious: changes to \texttt{portlet.ftl}
affect all the portlets in your site when the theme is applied.

To help you with your bearings as you modify your portlet's template,
below is a quick look at the
\href{https://github.com/liferay/liferay-portal/blob/7.1.x/modules/apps/frontend-theme/frontend-theme-classic/src/templates/portlet.ftl}{\texttt{portlet.ftl}}
file that's included in the default theme of 7.0.

\begin{verbatim}
<#assign
    portlet_display = portletDisplay
    portlet_back_url = htmlUtil.escapeHREF(portlet_display.getURLBack())
    portlet_content_css_class = "portlet-content"
    portlet_display_name = htmlUtil.escape(portlet_display.getPortletDisplayName())
    portlet_display_root_portlet_id = htmlUtil.escapeAttribute(portlet_display.getRootPortletId())
    portlet_id = htmlUtil.escapeAttribute(portlet_display.getId())
    portlet_title = htmlUtil.escape(portlet_display.getTitle())
/>
\end{verbatim}

The variables shown above are used throughout the template, so its
important that you understand them before modifying the file:

\begin{itemize}
\tightlist
\item
  \texttt{portletDisplay}: is fetched from the \texttt{themeDisplay}
  object and contains information about the portlet.
\item
  \texttt{portlet\_back\_url}: URL to return to the previous page when
  the portlet \texttt{WindowState} is maximized.
\item
  \texttt{portlet\_display\_name}: The ``friendly'' name of the portlet
  as displayed in the GUI.
\item
  \texttt{portlet\_display\_root\_portlet\_id}: The root portlet ID of
  the portlet.
\item
  \texttt{portlet\_id}: The ID of the portlet (not the same as the
  portlet namespace)
\item
  \texttt{portlet\_title}: The portlet name set in the portlet Java
  class (usually from a \texttt{Keys.java} class).
\end{itemize}

Next, a condition checks if the portlet header should be displayed. If
the portlet has a portlet toolbar (Configuration, Permissions, Look and
Feel), the condition is true and the header is displayed:

\begin{verbatim}
<#if portlet_display.isPortletDecorate() && !portlet_display.isStateMax() 
&& portlet_display.getPortletConfigurationIconMenu()?? 
&& portlet_display.getPortletToolbar()??>
\end{verbatim}

You can use a similar pattern if you want to dynamically show portions
of the portlet's UI.

Next, the portlet title menus are defined. These are used in portlets
that let you add resources (Web Content Display, Media Gallery,
Documents and Media):

\begin{verbatim}
portlet_title_menus = portlet_toolbar.getPortletTitleMenus(portlet_display_root_portlet_id, renderRequest, renderResponse)
\end{verbatim}

The configuration below contains the information for the configuration
menu (Configuration, Permissions, Look and Feel):

\begin{verbatim}
portlet_configuration_icons = portlet_configuration_icon_menu.getPortletConfigurationIcons(portlet_display_root_portlet_id, renderRequest, renderResponse)
\end{verbatim}

The rest of the file contains the HTML markup for the portlet topper and
the portlet content. This section barely scratches the surface of the
\texttt{portlet.ftl} file. You must examine the \texttt{portlet.ftl}
file yourself and determine what elements and classes need updated for
your theme and site.

Now that you are more familiar with your theme's \texttt{portlet.ftl}
file, you can learn the role Portlet Decorators play in the overall look
and feel of your portlets.

\subsection{Portlet Decorators}\label{portlet-decorators}

With Portlet Decorators, you can customize the style of the application
wrapper. Themes come bundled with three default portlet decorators in
their \texttt{liferay-look-and-feel.xml}:

\begin{itemize}
\item
  \texttt{Barebone}: this decorator displays the bare application
  content, showing neither the wrapping box nor the custom application
  title.
\item
  \texttt{Borderless}: this decorator shows the title at the top, but
  does not display a wrapping box.
\item
  \texttt{decorate}: this is the default Portlet Decorator when using
  the Classic theme. It wraps the application in a white box with a
  border, and displays the title at the top.
\end{itemize}

Now you know how to make your portlets stylish! But if default
decorators are not stylish enough for you, {[}EDITOR: Our defaults are
always stylish!{]} go to
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-configurable-styles-for-portlet-wrappers}{Portlet
Decorators} to learn how make and apply your own.

\subsection{Related Topics}\label{related-topics-143}

\href{/docs/7-1/user/-/knowledge_base/u/look-and-feel-configuration}{Look
and Feel Configuration}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-configurable-styles-for-portlet-wrappers}{Creating
Configurable Styles For Portlet Wrappers}

\href{/docs/7-1/tutorials/-/knowledge_base/t/themes-and-layout-templates}{Themes
and Layout Templates}

\chapter{Creating Configurable Styles for Portlet
Wrappers}\label{creating-configurable-styles-for-portlet-wrappers}

Portlet Decorators customize the style of an application's wrapper. If
you inspect the markup of your application when it's on a page you'll
observe that it is wrapped by two layers. Among other things, these
layers provide some common basic features like drag and drop and the
application border style. In order to protect these features, you can't
modify the markup of these layers directly with a theme.

With Portlet Decorators, you can add a CSS class to one of these
wrapping layers via a user's setting. By defining styles for this class
in your theme, you can change the look and feel of the application
instances where the Portlet Decorator is applied, including its wrapper.

The figure below shows the markup of the layers wrapping a Liferay DXP
application when the \emph{Decorate} Portlet Decorator is applied:

\begin{figure}
\centering
\includegraphics{./images/portlet-application-markup.png}
\caption{Portlet Decorators add the decorator's CSS class to the
application's wrapper}
\end{figure}

Once your Portlet Decorator is complete, apply it to your applications
through the
\href{/docs/7-1/user/-/knowledge_base/u/look-and-feel-configuration}{Look
and Feel Configuration menu}.

\begin{figure}
\centering
\includegraphics{./images/app-decor-look-and-feel.png}
\caption{Portlet Decorators can be applied through the Look and Feel
Configuration menu}
\end{figure}

The tutorials in this section detail how to customize Portlet Decorators
and apply them to your applications.

\section{Adding Portlet Decorators to a
Theme}\label{adding-portlet-decorators-to-a-theme}

Portlet Decorators are associated with a particular theme. If your theme
does not define any portlet decorators, none are available. It is
recommended that you provide a few decorators for your portlets to cover
the basic use cases.

For example, the Liferay Portal CE 7.1
\href{https://github.com/liferay/liferay-portal/tree/7.1.x/modules/apps/frontend-theme/frontend-theme-classic}{Classic
theme} includes three Portlet Decorators:

\begin{itemize}
\item
  Decorate: this is the default Application Decorator when using the
  Classic theme. It wraps the application in a white box with a border,
  and displays the title at the top. theme.

  \begin{figure}
  \centering
  \includegraphics{./images/application-decorator-decorate.png}
  \caption{The Classic theme's Decorate Application Decorator wraps the
  portlet in a white box.}
  \end{figure}
\item
  Borderless: this decorator shows the title at the top, but does not
  display a wrapping box.

  \begin{figure}
  \centering
  \includegraphics{./images/application-decorator-borderless.png}
  \caption{The Classic theme's Borderless Application Decorator displays
  the application's custom title.}
  \end{figure}
\item
  Barebone: this decorator displays the bare application content,
  showing neither the wrapping box nor the custom application title.

  \begin{figure}
  \centering
  \includegraphics{./images/application-decorator-barebone.png}
  \caption{The Classic theme's Barebone Application Decorator displays
  only the application's content.}
  \end{figure}
\end{itemize}

\noindent\hrulefill

\textbf{Note:} Upgrading to Liferay DXP assigns the \emph{borderless}
decorator automatically to those portlets that had the \emph{Show
Borders} option set to false in previous versions of Liferay.

\noindent\hrulefill

This tutorial demonstrates how to

\begin{itemize}
\item
  Add Portlet Decorators to your theme
\item
  Affect theme markup with Portlet Decorators
\end{itemize}

\subsection{Adding Portlet Decorators to a
Theme}\label{adding-portlet-decorators-to-a-theme-1}

Adding Portlet Decorators to your theme is similar to adding Color
Schemes. Follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Configure your theme's \texttt{liferay-look-and-feel.xml}
\item
  Define the Application Decorator CSS styles
\item
  Optional: Add conditions to your theme's markup
\end{enumerate}

\subsubsection{Configuring
liferay-look-and-feel.xml}\label{configuring-liferay-look-and-feel.xml}

The first thing you must do is declare the Portlet Decorators in your
theme's \texttt{liferay-look-and-feel.xml}.

The
\href{https://docs.liferay.com/dxp/portal/7.1-latest/definitions/liferay-look-and-feel_7_0_0.dtd.html\#portlet-decorator}{Document
Type Definition for the liferay-look-and-feel.xml} contains the
information and rules to add Portlet Decorators (in the code referred as
portlet-decorators) to your theme.

Here is how the classic theme defines Portlet Decorators in its
\texttt{liferay-look-and-feel.xml}:

\begin{verbatim}
<?xml version="1.0"?>
<!DOCTYPE look-and-feel PUBLIC "-//Liferay//DTD Look and Feel 7.0.0//EN" "http://www.liferay.com/dtd/liferay-look-and-feel_7_0_0.dtd">

<look-and-feel>
    <compatibility>
        <version>7.1.0+</version>
    </compatibility>
    ...
        <theme id="classic" name="Classic">
        ...
        <portlet-decorator id="barebone" name="Barebone">
            <portlet-decorator-css-class>portlet-barebone</portlet-decorator-css-class>
        </portlet-decorator>
        <portlet-decorator id="borderless" name="Borderless">
            <portlet-decorator-css-class>portlet-borderless</portlet-decorator-css-class>
        </portlet-decorator>
        <portlet-decorator id="decorate" name="Decorate">
            <default-portlet-decorator>true</default-portlet-decorator>
            <portlet-decorator-css-class>portlet-decorate</portlet-decorator-css-class>
        </portlet-decorator>
        </theme>
</look-and-feel>
\end{verbatim}

The \texttt{portlet-decorator} element contains all the information
about the Application Decorator:

\begin{itemize}
\tightlist
\item
  \texttt{id}: this required attribute contains a unique string that
  identifies this specific Application Decorator. This is the value that
  is stored when applying an Application Decorator, and it can be used
  to refer to this decorator in your theme templates.
\item
  \texttt{name}: this required attribute is a user friendly identifier
  for the Application Decorator to be displayed in the Look and Feel UI.
\item
  \texttt{portlet-decorator-css-class}: this required element contains
  the name of the CSS class that is added to the application wrapping
  layer when this Application Decorator is applied.
\item
  \texttt{default-portlet-decorator}: use this optional element to
  identify the default Application Decorator for your theme.
\end{itemize}

You can define as many Portlet Decorators as you want, but it's
recommended to include at least one for the \emph{decorate},
\emph{borderless} and \emph{barebone} use cases.

\subsubsection{Define the Styles for Your Application Decorator CSS
Class}\label{define-the-styles-for-your-application-decorator-css-class}

Once you've declared your Portlet Decorators, it's time to define their
effect in the application look and feel. While the previous step was
straightforward, this one asks for some creativity.

As an example, look at the \texttt{\_portlet\_decorator.scss} of the
Classic theme:

\begin{verbatim}
.portlet-decorate .portlet-content {
    background: #FFF;
    border: 1px solid #DEEEEE;
}

.portlet-barebone .portlet-content {
    padding: 0;
}
\end{verbatim}

Once your CSS styles are written, import the CSS file into your
\texttt{\_custom.scss}:

\begin{verbatim}
@import "portlet_decorator"
\end{verbatim}

That's all that's required to add Portlet Decorators to your theme. If
you want to modify your application's markup with your Portlet
Decorators, read the next section.

\subsubsection{Changing Your Application Markup with Portlet
Decorators}\label{changing-your-application-markup-with-portlet-decorators}

So far you've seen how to use Portlet Decorators to change the look and
feel of an application with styles.

It's possible to go a step further and alter the markup of your
application based on the Application Decorator applied. For this, you
must edit the \texttt{portlet.ftl} template for your theme, retrieve the
\texttt{portletDecoratorId} of the current Application Decorator from
the \texttt{portletDisplay} object, and make some decisions based on it.

For example, this is how the Classic theme shows the application title
when the \emph{barebone} Application Decorator is not applied:

\begin{verbatim}
<#if !stringUtil.equals(portlet_display.getPortletDecoratorId(), "barebone")>
    <h2 class="portlet-title-text">${portlet_title}</h2>
</#if>
\end{verbatim}

Now you know how to add Portlet Decorators to your theme. Let your
creativity be your guide.

\subsection{Related Topics}\label{related-topics-144}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-reusable-pieces-of-code-for-your-themes}{Themelets}

\href{/docs/7-1/tutorials/-/knowledge_base/t/making-applications-configurable}{Making
Applications Configurable}

\section{Applying Portlet Decorators to Embedded
Portlets}\label{applying-portlet-decorators-to-embedded-portlets}

Once you have installed a theme that contains Portlet Decorators, site
administrators can apply them to a portlet instance by selecting the
Application Decorator in the Look and Feel Configuration dialog. If your
theme contains embedded portlets, it's also possible to apply an
Application Decorator other than the default one by setting its
preferences.

This tutorial demonstrates how to apply Portlet Decorators to Embedded
Portlets in your theme.

\subsection{Setting Application Decorator
Preferences}\label{setting-application-decorator-preferences}

To define a default Application Decorator for your theme's embedded
portlets, you must set a default decorator in the portlet preferences.

For example, the
\href{https://github.com/liferay/liferay-portal/blob/7.1.x/modules/apps/frontend-theme/frontend-theme-classic/src/templates/portal_normal.ftl}{Classic
theme} declares an Application Decorator with Id \texttt{barebone} and
applies it to the embedded Search portlet in its
\texttt{portal\_normal.ftl}:

\begin{verbatim}
<div class="navbar navbar-top navigation-bar-secondary">
  <div class="container user-personal-bar">
    <#assign preferences = 
    freeMarkerPortletPreferences.getPreferences(
      "portletSetupPortletDecoratorId", "barebone"
    ) />

    <#if show_header_search>
      <div class="ml-auto mr-4 navbar-form" role="search">
        <@liferay.search default_preferences="${preferences}" />
      </div>
    </#if>

    <@liferay.user_personal_bar />
  </div>
</div>
\end{verbatim}

To set the default decorator for your embedded portlets, follow these
steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Set the value for the \texttt{portletSetupPortletDecoratorId} to the
  Id of the Application Decorator you want to use. The example below
  assigns the \texttt{barebone} decorator to the \texttt{preferences}
  variable:

\begin{verbatim}
<#assign preferences = freeMarkerPortletPreferences.getPreferences(
  "portletSetupPortletDecoratorId", "barebone"
) />
\end{verbatim}
\item
  Next, set the \texttt{default\_preferences} attribute of the portlet's
  tag to the variable you just defined (\texttt{preferences} in the last
  step):

\begin{verbatim}
<@liferay.search default_preferences= "${preferences}" />
\end{verbatim}
\end{enumerate}

Your embedded portlets now have a custom default Application Decorator!

\subsection{Related Topics}\label{related-topics-145}

\href{/docs/7-1/tutorials/-/knowledge_base/t/embedding-portlets-in-themes}{Embedding
Portlets in Themes}

\href{/docs/7-1/tutorials/-/knowledge_base/t/theming-portlets}{Theming
Portlets}

\section{Embedding Portlets in
Themes}\label{embedding-portlets-in-themes}

You may occasionally want to embed a portlet in a theme, making the
portlet visible on all pages where the theme is used. Since there are
numerous drawbacks to hard-coding a specific portlet into place, the
\emph{Portlet Providers} framework offers an alternative that displays
the appropriate portlet based on a given entity type and action.

In this tutorial, you'll learn how to declare an entity type and action
in a custom theme, and you'll create a module that finds the correct
portlet to use based on those given parameters. You'll first learn how
to embed portlets into a theme.

\subsection{Adding a Portlet to a Custom
Theme}\label{adding-a-portlet-to-a-custom-theme}

The first thing you should do is open the template file for which you
want to declare an embedded portlet. For example, the
\texttt{portal\_normal.ftl} template file is a popular place to declare
embedded portlets. To avoid problems, it's usually best to embed
portlets with an entity type and action, but you may encounter
circumstances where you'll want to hard code it by portlet name. Both
methods are covered here.

\subsubsection{\texorpdfstring{Embedding a Portlet by Entity Type and
Action\href{id=embedding-a-portlet-by-class-name}{}}{Embedding a Portlet by Entity Type and Action}}\label{embedding-a-portlet-by-entity-type-and-action}

Start by inserting the following declaration where you want the portlet
embedded:

\begin{verbatim}
<@liferay_portlet["runtime"]
    portletProviderAction=ACTION
    portletProviderClassName="CLASS_NAME"
/>
\end{verbatim}

This declaration expects two parameters: the type of action and the
class name of the entity type the portlet should handle. Here's an
example of an embedded portlet declaration that uses the class name:

\begin{verbatim}
<@liferay_portlet["runtime"]
    portletProviderAction=portletProviderAction.VIEW
    portletProviderClassName="com.liferay.portal.kernel.servlet.taglib.ui.LanguageEntry"
/>
\end{verbatim}

This declares that the theme is requesting to view language entries.
Liferay DXP determines which deployed portlet to use in this case by
providing the portlet with the highest service ranking.

\noindent\hrulefill

\textbf{Note:} In some cases, a default portlet is already provided to
fulfill certain requests. You can override the default portlet with your
custom portlet by specifying a higher service rank. To do this, set the
following property in your class' \texttt{@Component} declaration:

\begin{verbatim}
 property= {"service.ranking:Integer=20"}
\end{verbatim}

Make sure you set the service ranking higher than the default portlet
being used.

\noindent\hrulefill

There are five different kinds of actions supported by the Portlet
Providers framework: \texttt{ADD}, \texttt{BROWSE}, \texttt{EDIT},
\texttt{PREVIEW}, and \texttt{VIEW}. Specify the entity type and action
in your theme's runtime declaration.

Great! Your theme declaration is complete. However, the Portal is not
yet configured to handle this request. You must create a module that can
find the portlet that fits the theme's request.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/starting-module-development\#creating-a-module}{Create
  an OSGi module}.
\item
  Create a unique package name in the module's \texttt{src} directory,
  and create a new Java class in that package. To follow naming
  conventions, name the class based on the entity type and action type,
  followed by \emph{PortletProvider} (e.g.,
  \texttt{SiteNavigationLanguageEntryViewPortletProvider}). The class
  should extend the
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/BasePortletProvider.html}{\texttt{BasePortletProvider}}
  class and implement the appropriate portlet provider interface based
  on the action you chose in your theme (e.g.,
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/ViewPortletProvider.html}{\texttt{ViewPortletProvider}},
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/BrowsePortletProvider.html}{\texttt{BrowsePortletProvider}},
  etc.).
\item
  Directly above the class's declaration, insert the following
  annotation:

\begin{verbatim}
@Component(
    immediate = true,
    property = {"model.class.name=CLASS_NAME"},
    service = INTERFACE.class
)
\end{verbatim}

  The \texttt{property} element should match the entity type you
  specified in your theme declaration (e.g.,
  \texttt{com.liferay.portal.kernel.servlet.taglib.ui.LanguageEntry}).
  Also, your \texttt{service} element should match the interface you're
  implementing (e.g., \texttt{ViewPortletProvider.class}). You can view
  an example of a similar \texttt{@Component} annotation in the
  \href{https://github.com/liferay/liferay-portal/blob/7.1.x/modules/apps/roles/roles-selector-web/src/main/java/com/liferay/roles/selector/web/internal/portlet/RolesSelectorEditPortletProvider.java}{RolesSelectorEditPortletProvider}
  class.
\item
  Specify the methods you want to implement. Make sure to retrieve the
  portlet ID and page ID that should be provided when this service is
  called by your theme.

  A common use case is to implement the \texttt{getPortletId()} and
  \texttt{getPlid(ThemeDisplay)} methods. You can view the
  \href{https://github.com/liferay/liferay-portal/blob/7.1.x/modules/apps/site-navigation/site-navigation-language-web/src/main/java/com/liferay/site/navigation/language/web/internal/portlet/SiteNavigationLanguageViewPortletProvider.java}{SiteNavigationLanguageViewPortletProvider}
  for an example of how these methods can be implemented to provide a
  portlet for embedding in a theme. This example module returns the
  portlet ID of the Language portlet specified in
  \href{https://github.com/liferay/liferay-portal/blob/7.1.x/modules/apps/site-navigation/site-navigation-language-api/src/main/java/com/liferay/site/navigation/language/constants/SiteNavigationLanguagePortletKeys.java}{SiteNavigationLanguagePortletKeys}.
  It also returns the PLID, which is the ID that uniquely identifies a
  page used by your theme. By retrieving these, your theme will know
  which portlet to use, and which page to use it on.
\end{enumerate}

The only thing left to do is generate the module's JAR file and copy it
to your Portal's \texttt{osgi/modules} directory. Once the module is
installed and activated in your Portal's service registry, your embedded
portlet is available for use wherever your theme is used.

You successfully requested a portlet based on the entity and action
types required, and created and deployed a module that retrieves the
portlet and embeds it in your theme.

\subsubsection{Embedding a Portlet by Portlet
Name}\label{embedding-a-portlet-by-portlet-name}

If you'd like to embed a specific portlet in the theme, you can hard
code it by providing its instance ID and name:

\begin{verbatim}
<@liferay_portlet["runtime"]
    instanceId="INSTANCE_ID"
    portletName="PORTLET_NAME"
/>
\end{verbatim}

\noindent\hrulefill

\textbf{Note:} If your portlet is instanceable, an instance ID must be
provided; otherwise, you can remove this line. To set your portlet to
non-instanceable, set the property
\texttt{com.liferay.portlet.instanceable} in the component annotation of
your portlet to \texttt{false}.

\noindent\hrulefill

The portlet name must be the same as \texttt{javax.portlet.name}'s
value.

Here's an example of an embedded portlet declaration that uses the
portlet name to embed a web content portlet:

\begin{verbatim}
<@liferay_portlet["runtime"]
    portletName="com_liferay_journal_content_web_portlet_JournalContentPortlet"
/>
\end{verbatim}

You can also set default preferences for an application. This process is
covered next.

\subsubsection{Setting Default Preferences for an Embedded
Portlet}\label{setting-default-preferences-for-an-embedded-portlet}

Follow these steps to set default portlet preferences for an embedded
portlet:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Retrieve portlet preferences using the
  \texttt{freeMarkerPortletPreferences} object. The example below
  retrieves the \texttt{barebone}
  \href{/docs/7-1/tutorials/-/knowledge_base/t/creating-configurable-styles-for-portlet-wrappers}{portlet
  decorator}:

\begin{verbatim}
<#assign preferences = freeMarkerPortletPreferences.getPreferences(
  "portletSetupPortletDecoratorId", "barebone"
) />
\end{verbatim}
\item
  Set the \texttt{defaultPreferences} attribute of the embedded portlet
  to the \texttt{freeMarkerPortletPreferences} object you just
  configured:

\begin{verbatim}
<@liferay_portlet["runtime"]
    defaultPreferences="${preferences}"
    portletName="com_liferay_login_web_portlet_LoginPortlet"
/>
\end{verbatim}
\end{enumerate}

Now you know how to set default preferences for embedded portlets! Next
you can see the additional attributes you can use for your embedded
portlets.

\subsubsection{Additional Attributes for
Portlets}\label{additional-attributes-for-portlets}

Below are some additional attributes you can define for embedded
portlets:

\textbf{defaultPreferences}: A string of Portlet Preferences for the
application. This includes look and feel configurations.

\textbf{instanceId}: The instance ID for the app, if the application is
instanceable.

\textbf{persistSettings}: Whether to have an application use its default
settings, which will persist across layouts. The default value is
\emph{true}.

\textbf{settingsScope}: Specifies which settings to use for the
application. The default value is \texttt{portletInstance}, but it can
be set to \texttt{group} or \texttt{company}.

Now you know how to embed a portlet in your theme by class name and by
portlet name and how to configure your embedded portlet!

\subsection{Related Topics}\label{related-topics-146}

\href{/docs/7-1/tutorials/-/knowledge_base/t/embedding-portlets-in-themes}{Embedding
Portlets in Themes}

\href{/docs/7-1/tutorials/-/knowledge_base/t/portlets}{Portlets}

\href{/docs/7-1/tutorials/-/knowledge_base/t/service-builder}{Service
Builder}

\chapter{Clay CSS and Themes}\label{clay-css-and-themes}

\href{https://lexicondesign.io/}{Lexicon} is a design language that
provides a common framework for building consistent UIs.
\href{https://clayui.com/}{Clay}, the web implementation of Lexicon, is
an extension of Bootstrap's open source CSS Framework. Bootstrap is by
far the most popular CSS framework on the web. Built with Sass, Clay CSS
fills the front-end gaps between Bootstrap and the specific needs of
Liferay DXP.

These tutorials look briefly at Clay CSS and show you how to use it in
your themes.

\section{Importing Clay CSS into a
Theme}\label{importing-clay-css-into-a-theme}

Clay CSS fills the gaps between Bootstrap and the specific needs of
Liferay DXP. Bootstrap features have been extended to cover more use
cases. Here are some of the new components added by Clay CSS:

\begin{itemize}
\tightlist
\item
  Aspect Ratio
\item
  Cards
\item
  Dropdown Wide and Dropdown Full
\item
  Figures
\item
  Nameplates
\item
  Sidebar / Sidenav
\item
  Stickers
\item
  SVG Icons
\item
  Timelines
\item
  Toggles
\end{itemize}

Several reusable CSS patterns have also been added to help accomplish
time consuming tasks such as these:

\begin{itemize}
\tightlist
\item
  truncating text
\item
  content filling the remaining container width
\item
  truncating text inside table cells
\item
  table cells filling remaining container width and table cells only
  being as wide as their content
\item
  open and close icons inside collapsible panels
\item
  nested vertical navigations
\item
  slide out panels
\item
  notification icons/messages
\item
  vertical alignment of content
\end{itemize}

Next you can learn more about Clay's structure.

\subsection{Clay CSS Structure}\label{clay-css-structure}

\href{https://claycss.com/}{Clay CSS} is bundled with two sub-themes:
\href{https://github.com/liferay/liferay-portal/tree/7.1.x/modules/apps/frontend-theme/frontend-theme-styled/src/main/resources/META-INF/resources/_styled/css/clay}{Clay
Base} and
\href{https://github.com/liferay/liferay-portal/tree/7.1.x/modules/apps/frontend-theme/frontend-theme-styled/src/main/resources/META-INF/resources/_styled/css/clay/atlas}{Atlas}.
Clay Base is Liferay DXP's Bootstrap API extension. It adds all the
features and components you need and inherits Bootstrap's styles. As a
result, Clay Base is fully compatible with
\href{/docs/7-1/tutorials/-/knowledge_base/t/integrating-third-party-themes-with-clay}{third
party themes} that leverage Bootstrap's Sass variable API.

Atlas is Liferay DXP's custom Bootstrap theme that is used in the
Classic Theme. Its purpose is to overwrite and manipulate Bootstrap and
Clay Base to create its classic look and feel. Atlas is equivalent to
installing a Bootstrap third party theme.

\noindent\hrulefill

\textbf{Note:} It is not recommended to integrate third party themes
with Atlas, as it adds variables and styles that are outside the scope
of Bootstrap's API.

\noindent\hrulefill

You can learn how to customize the Atlas theme next.

\subsection{Customizing Atlas in Liferay
DXP}\label{customizing-atlas-in-liferay-dxp}

If you want to include all the Classic Theme's files, you can skip these
steps and move on to the next section.

Follow these steps to customize the Atlas theme:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In your theme's \texttt{/src/css} directory (for legacy ant themes,
  place in \texttt{/\_diff/css}) add a file named \texttt{clay.scss}
  with the code below and save:

\begin{verbatim}
@import "clay/atlas";
\end{verbatim}
\item
  Add a file named \texttt{\_imports.scss} with the code below and save:

\begin{verbatim}
@import "bourbon";
@import "mixins";
@import "clay/atlas-variables";
\end{verbatim}
\item
  Add a file named \texttt{font\_awesome.scss} and add the font-awesome
  path and import:

\begin{verbatim}
// Icon paths

$FontAwesomePath: "font-awesome/font";

@import "font-awesome/scss/font-awesome";
\end{verbatim}
\item
  Add a file named \texttt{\_clay\_variables.scss}. All your Atlas,
  Bootstrap, and Clay Base variable modifications must be placed in this
  file.
\item
  Add a file named \texttt{\_custom.scss} with the code below and save:

\begin{verbatim}
/* Use these inject tags to dynamically create imports for 
themelet styles. You can place them where ever you like in this file. */

/* inject:imports */
/* endinject */

/* This file allows you to override default styles in one central 
location for easier upgrade and maintenance. */
\end{verbatim}
\end{enumerate}

Place your custom CSS in this file. Next you can learn how to extend
Atlas with the Classic theme.

\subsubsection{Extending Atlas with the Classic
Theme}\label{extending-atlas-with-the-classic-theme}

To extend the Atlas theme with the Classic theme, copy all the files
located in these directories into your theme:

\begin{verbatim}
frontend-theme-classic/src/css
frontend-theme-classic/src/images
frontend-theme-classic/src/js
frontend-theme-classic/src/templates
\end{verbatim}

You can also automatically
\href{/docs/7-1/tutorials/-/knowledge_base/t/copying-an-existing-themes-files}{copy
these files into your theme} using the \texttt{gulp\ kickstart} command
and following the prompts.

Next you can learn how to customize the Clay Base.

\subsection{Customizing Clay Base}\label{customizing-clay-base}

You can customize Clay Base with just a few imports.

In your custom theme's \texttt{/src/css} folder (legacy ant themes:
\texttt{/\_diff/css}) add a file named \texttt{font\_awesome.scss} with
the code below and save:

\begin{verbatim}
// Icon paths

    $FontAwesomePath: "font-awesome/font";
    
    @import "font-awesome/scss/font-awesome";
\end{verbatim}

Then in that same folder, add a file named
\texttt{\_clay\_variables.scss}. All your Atlas, Bootstrap, and Clay
Base variable modifications must be placed in this file.

As mentioned earlier, any custom CSS should be placed in
\texttt{\_custom.scss}.

Now you know how to use Clay CSS in your theme!

\subsection{Related Topics}\label{related-topics-147}

\href{/docs/7-1/tutorials/-/knowledge_base/t/applying-clay-styles-to-your-app}{Applying
Clay Styles to Your App}

\href{/docs/7-1/tutorials/-/knowledge_base/t/integrating-third-party-themes-with-clay}{Integrating
Third Party Themes with Clay}

\section{Integrating Third Party Themes with
Clay}\label{integrating-third-party-themes-with-clay}

\href{https://github.com/liferay/liferay-portal/tree/7.1.x/modules/apps/frontend-theme/frontend-theme-styled/src/main/resources/META-INF/resources/_styled/css/clay}{Clay
Base} provides all the features and components your theme needs and
inherits Bootstrap's styles. As a result, Clay Base is fully compatible
with third party themes that leverage Bootstrap's Sass variable API.

The
\href{https://github.com/liferay/liferay-portal/tree/7.1.x/modules/apps/frontend-theme/frontend-theme-styled}{Styled
Theme} uses Clay Base to provide its styles and components. Therefore,
as a best practice, you should use the Styled base theme to integrate
third party themes.

\noindent\hrulefill

\textbf{Note:} You can purchase third party themes from the
\href{https://web.liferay.com/marketplace}{Liferay Marketplace}. Third
party themes must be built with Sass to be compatible. \textbf{Make
sure} Sass files are included before making any theme purchase.

\noindent\hrulefill

Follow these steps to integrate a third party theme with Clay Base:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a new theme with the Styled Theme as its base. This is the
  default base theme for newly created themes, so no further action is
  required. This provides the Clay Base files you need.
\item
  In the theme's \texttt{/src/css} folder (legacy ant themes:
  \texttt{/\_diff/css}) add a file named \texttt{font\_awesome.scss}
  with the code below and save:

\begin{verbatim}
// Icon paths

$FontAwesomePath: "font-awesome/font";

@import "font-awesome/scss/font-awesome";
\end{verbatim}
\item
  In that same folder, add a file named \texttt{\_clay\_variables.scss}.
  All your Atlas, Bootstrap, and Clay Base variable modifications must
  be placed in this file.
\item
  Create a folder inside \texttt{/src/css} (for legacy ant themes,
  \texttt{/\_diff/css}) that contains your third party theme
  (e.g.~\texttt{/src/css/awesome-theme} or
  \texttt{/\_diff/css/awesome-theme})
\item
  Copy the CSS contents of the theme to the folder you just created.
\item
  In \texttt{\_clay\_variables.scss}, import the file containing the
  theme variables. For example,
  \texttt{@import\ "awesome-theme/variables.scss";}
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** You may omit the leading underscore when importing Sass files.
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{6}
\item
  In \texttt{\_custom.scss}, import the file containing the CSS. For
  example, \texttt{@import\ "awesome-theme/main.scss";}
\item
  Deploy your theme with \texttt{gulp\ deploy} (for legacy ant themes,
  use \texttt{ant\ deploy})
\end{enumerate}

Now you know how to integrate third party themes with Clay Base!

\subsection{Related Topics}\label{related-topics-148}

\href{/docs/7-1/tutorials/-/knowledge_base/t/applying-clay-styles-to-your-app}{Applying
Clay Styles to Your App}

\href{/docs/7-1/tutorials/-/knowledge_base/t/importing-clay-css-into-a-theme}{Importing
Clay CSS into a Theme}

\chapter{Liferay JavaScript APIs}\label{liferay-javascript-apis}

The \texttt{Liferay} JavaScript object exposes methods, objects, and
properties that you can use to access Liferay DXP-specific information.
This section contains a comprehensive list of some of the most useful
utilities you can find inside the \texttt{Liferay} object.

\section{Accessing ThemeDisplay
Information}\label{accessing-themedisplay-information}

The \texttt{Liferay} global JavaScript Object exposes useful methods,
objects, and properties, each containing a wealth of information, one of
which is \texttt{ThemeDisplay}. If you have experience with Java
development in Liferay DXP, you may be familiar with ThemeDisplay. The
JavaScript object exposes the same information as the ThemeDisplay Java
Class. It gives you access to valuable information that you can use in
your applications, such as the Portal instance, the current user, the
user's language, whether the user is signed in or being impersonated,
the file path to the theme's resources, and much more.

The \texttt{Liferay} global object is automatically available in Liferay
DXP at runtime. To access the \texttt{ThemeDisplay} object, use the
following dot notation in your app:

\begin{verbatim}
    `Liferay.ThemeDisplay.method-name`
\end{verbatim}

This tutorial describes some of the most commonly used
\texttt{ThemeDisplay} methods for retrieving IDs, file paths, and login
information. An exhaustive list of all of the available methods is
displayed in the table at the end of this tutorial.

\subsection{Retrieving IDs}\label{retrieving-ids}

The methods below retrieve various Portal elements related to the
current user:

\textbf{getCompanyId:} Returns the
\href{/participate/liferaypedia/-/wiki/Main/Company+ID}{company ID}.

\textbf{getLanguageId:} Returns the user's language ID.

\textbf{getScopeGroupId:} Returns the
\href{/participate/liferaypedia/-/wiki/Main/Group+ID}{group ID} of the
current site.

\textbf{getUserId:} Returns the
\href{/participate/liferaypedia/-/wiki/Main/User+ID}{user's ID}.

\textbf{getUserName:} Returns the user's name.

Next you can learn how to access file paths for various deployed
entities.

\subsection{Retrieving File Paths}\label{retrieving-file-paths}

The methods below retrieve file paths for various theme resources:

\textbf{getPathImage:} Returns the relative path of the portlet's image
directory.

\textbf{getPathJavaScript:} Returns the relative path of the directory
containing the portlet's JavaScript source files.

\textbf{getPathMain:} Returns the path of the portal instance's main
directory.

\textbf{getPathThemeImages:} Returns the path of the current theme's
image directory.

\textbf{getPathThemeRoot:} Returns the relative path of the current
theme's root directory.

Next you can learn how to retrieve information for the current user.

\subsection{Retrieving Login
Information}\label{retrieving-login-information}

The methods below return a boolean value indicating whether the current
user is signed in or being impersonated:

\textbf{isImpersonated:} Returns \texttt{true} if the current user is
being impersonated. Authorized administrative users can
\href{/docs/6-2/user/-/knowledge_base/u/the-users-section-of-the-control-panel\#user-management}{impersonate}
act as another user to test that user's account.

\textbf{isSignedIn:} Returns \texttt{true} if the user is logged in to
the portal.

The example configuration below alerts users with a standard message if
they are a guest or a personal greeting if they are signed in. This is a
basic example, and perhaps a bit invasive, but it illustrates how you
can create unique experiences for each user with the
\texttt{ThemeDisplay} APIs:

\begin{verbatim}
if(Liferay.ThemeDisplay.isSignedIn()){
    alert('Hello ' + Liferay.ThemeDisplay.getUserName() + '. Welcome Back.')
}
else {
    alert('Hello Guest.')
}
\end{verbatim}

\subsection{Liferay ThemeDisplay
Methods}\label{liferay-themedisplay-methods}

A complete list of the available \texttt{Liferay.ThemeDisplay} methods
is shown in the table below:

\noindent\hrulefill

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.3333}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Method
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Type
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Description
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
getLayoutId & number & \\
getLayoutRelativeURL & string & Returns the relative URL for the page \\
getLayoutURL & string & \\
getParentLayoutId & number & \\
isControlPanel & boolean & \\
isPrivateLayout & boolean & \\
isVirtualLayout & boolean & \\
getBCP47LanguageId & number & \\
getCDNBaseURL & string & Returns the content delivery network (CDN) base
URL, or the current portal URL if the CDN base URL is null \\
getCDNDynamicResourcesHost & string & Returns the content delivery
network (CDN) dynamic resources host, or the current portal URL if the
CDN dynamic resources host is null \\
getCDNHost & string & \\
getCompanyGroupId & number & \\
getCompanyId & number & Returns the portal instance ID \\
getDefaultLanguageId & number & \\
getDoAsUserIdEncoded & string & \\
getLanguageId & number & Returns the user's language ID \\
getParentGroupId & number & \\
getPathContext & string & \\
getPathImage & string & Returns the relative path of the portlet's image
directory \\
getPathJavaScript & string & Returns the relative path of the directory
containing the portlet's JavaScript source files \\
getPathMain & string & Returns the path of the portal instance's main
directory \\
getPathThemeImages & string & Returns the path of the current theme's
image directory \\
getPathThemeRoot & string & Returns the relative path of the current
theme's root directory \\
getPlid & string & Returns the primary key of the page \\
getPortalURL & string & Returns the portal instance's base URL \\
getScopeGroupId & number & Returns the ID of the scoped or sub-scoped
active group (e.g.~site) \\
getScopeGroupIdOrLiveGroupId & number & \\
getSessionId & number & Returns the session ID, or a blank string if the
session ID is not available to the application \\
getSiteGroupId & number & \\
getURLControlPanel & string & \\
getURLHome & string & \\
getUserId & number & Returns the ID of the user for which the current
request is being handled \\
getUserName & string & Returns the user's name \\
isAddSessionIdToURL & boolean & \\
isFreeformLayout & boolean & \\
isImpersonated & boolean & Returns \texttt{true} if the current user is
being impersonated. Authorized administrative users can
\href{/docs/7-1/user/-/knowledge_base/u/adding-editing-and-deleting-users\#editing-users}{impersonate}
act as another user to test that user's account \\
isSignedIn & boolean & Returns \texttt{true} if the user is logged in to
the portal \\
isStateExclusive & boolean & \\
isStateMaximized & boolean & \\
isStatePopUp & boolean & \\
\end{longtable}

\noindent\hrulefill

\subsection{Related Topics}\label{related-topics-149}

\href{/docs/7-1/tutorials/-/knowledge_base/t/javascript-utilities}{Liferay
DXP JavaScript Utilities}

\section{Working with URLs in
JavaScript}\label{working-with-urls-in-javascript}

The \texttt{Liferay} global JavaScript Object exposes methods, objects,
and properties that access the portal context. Four of these are helpful
when working with URLS: \texttt{authToken}, \texttt{currentURL},
\texttt{currentURLEncoded}, and \texttt{PortletURL}. If you have
experience with Java development in Liferay DXP, you may have worked
with some of these before. The \texttt{Liferay} global object is
automatically available at runtime, so no additional dependencies are
required.

This tutorial covers how to use the \texttt{Liferay} global JavaScript
object to manipulate URLs. A complete list of the available methods and
properties appears in the tables at the end of this tutorial.

\subsection{Liferay PortletURL}\label{liferay-portleturl}

The \texttt{Liferay.PortletURL} object provides methods for creating
portlet API URLs (\texttt{actionURL}, \texttt{renderURL}, and
\texttt{resourceURL}), through JavaScript. Below is an example
configuration:

\begin{verbatim}
var portletURL = Liferay.PortletURL.createURL(themeDisplay.getURLControlPanel());

portletURL.setDoAsGroupId('true');
portletURL.setLifecycle(Liferay.PortletURL.ACTION_PHASE);
portletURL.setParameter('cmd', 'add_temp');
portletURL.setParameter('javax.portlet.action', '/document_library/upload_file_entry');
portletURL.setParameter('p_auth', Liferay.authToken);
portletURL.setPortletId(Liferay.PortletKeys.DOCUMENT_LIBRARY);
\end{verbatim}

See the \hyperref[portlet-url-methods-and-properties]{Portlet URL
Methods and Properties} section for more information about the methods
and properties used in the example above.

\subsection{Liferay AuthToken}\label{liferay-authtoken}

The \texttt{Liferay.authToken} property holds the current authentication
token value as a String. The \texttt{authToken} is used to validate
permissions when you make calls to services. To use the
\texttt{authToken} in a URL, pass \texttt{Liferay.authToken} as the
URL's \texttt{p\_auth} parameter, as shown in the example below:

\begin{verbatim}
portletURL.setParameter('p_auth', Liferay.authToken);
\end{verbatim}

\subsection{Liferay CurrentURL}\label{liferay-currenturl}

The \texttt{Liferay.currentURL} property holds the path of the current
URL from the server root.

For example, if checked from \texttt{my.domain.com/es/web/guest/home},
the value is \texttt{/es/web/guest/home}, as shown below:

\begin{verbatim}
// Inside my.domain.com/es/web/guest/home
console.log(Liferay.currentURL); // "/es/web/guest/home"
\end{verbatim}

\subsection{Liferay CurrentURLEncoded}\label{liferay-currenturlencoded}

The \texttt{Liferay.currentURLEncoded} property holds the path of the
current URL, encoded in ASCII for safe transmission over the Internet,
from the server root.

For example, if checked from \texttt{my.domain.com/es/web/guest/home},
the value is \texttt{\%2Fes\%2Fweb\%2Fguest\%2Fhome}, as shown below:

\begin{verbatim}
// Inside my.domain.com/es/web/guest/home
console.log(Liferay.currentURLEncoded); // "%2Fes%2Fweb%2Fguest%2Fhome"
\end{verbatim}

\subsection{Portlet URL Methods and
Properties}\label{portlet-url-methods-and-properties}

\texttt{Liferay.PortletURL} Methods:

\noindent\hrulefill

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.3333}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Method
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Parameters
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Returns
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{createURL} & \texttt{basePortletURL}, \texttt{params} & new
\texttt{PortletURL(null,\ params,\ basePortletURL);} \\
\texttt{createActionURL} & & new
\texttt{PortletURL(PortletURL.ACTION\_PHASE}); \\
\texttt{createRenderURL} & & new
\texttt{PortletURL(PortletURL.RENDER\_PHASE}); \\
\texttt{createResourceURL} & & new
\texttt{PortletURL(PortletURL.RESOURCE\_PHASE}); \\
\end{longtable}

\noindent\hrulefill

\texttt{Liferay.PortletURL} Properties:

\noindent\hrulefill

\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Property & Value \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{ACTION\_PHASE} & ``1'' \\
\texttt{RENDER\_PHASE} & ``0'' \\
\texttt{RESOURCE\_PHASE} & ``2'' \\
\end{longtable}

\noindent\hrulefill

Once the portlet URL is created, you have access to several methods that
you can use to manipulate the URL further:

\noindent\hrulefill

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.2500}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.2500}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.2500}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.2500}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Method
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Description
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Parameters
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Returns
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{setDoAsGroupId} & Sets the ID of the site, organization, or user
group for the URL & \texttt{doAsGroupId} & The updated Portlet URL
Object \\
\texttt{setDoAsUserId} & Sets the ID of the user to impersonate &
\texttt{doAsUserId} & The updated Portlet URL Object \\
\texttt{setEscapeXML} & Sets whether the URL should be XML escaped &
\texttt{true} or \texttt{false} & The updated Portlet URL Object \\
\texttt{setLifecycle} & Sets the portlet lifecycle of this URL's target
portlet & \texttt{lifecycle} & The updated Portlet URL Object \\
\texttt{setName} & sets the portlet URL's \texttt{javax.portlet.action}
name & \texttt{name} & The updated Portlet URL Object \\
\texttt{setParameter} & Creates an individual parameter or replaces an
existing reserved parameter & key,value & The updated Portlet URL
Object \\
\texttt{setParameters} & Creates multiple parameters and/or replaces
existing reserved parameters & \{key:value,\ldots\} & The updated
Portlet URL Object \\
\texttt{setPlid} & Sets the portlet layout ID & \texttt{plid} & The
updated Portlet URL Object \\
\texttt{setPortletId} & Sets the ID of the target portlet &
\texttt{portletId} & The updated Portlet URL Object \\
\texttt{setPortletMode} & Sets the portlet mode, if the URL triggers a
request & \texttt{portletMode} & The updated Portlet URL Object \\
\texttt{setResourceId} & Sets the ID of the URL's target resource &
\texttt{ResourceId} & The updated Portlet URL Object \\
\texttt{setSecure} & Sets whether to make the URL secure (HTTPS). &
\texttt{true} or \texttt{false} & The updated Portlet URL Object \\
\texttt{setWindowState} & Sets the portlet's window state, if the URL
triggers a request & \texttt{windowState} & The updated Portlet URL
Object \\
\texttt{toString} & Returns the URL as a String & & The portlet URL as a
String \\
\texttt{\_isReservedParam} & Returns whether the parameter is reserved &
\texttt{paramName} & \texttt{true} if the parameter is reserved \\
\end{longtable}

\noindent\hrulefill

Now you know how to manipulate URLs using methods within the
\texttt{Liferay} global JavaScript object.

\subsection{Related Topics}\label{related-topics-150}

\href{/docs/7-1/tutorials/-/knowledge_base/t/javascript-utilities}{Liferay
DXP JavaScript Utilities}

\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-themedisplay}{Liferay
Theme Display}

\section{Liferay DXP JavaScript
Utilities}\label{liferay-dxp-javascript-utilities}

This tutorial explains some of the utility methods and objects inside
the \texttt{Liferay} global JavaScript object.

\subsection{Liferay Browser}\label{liferay-browser}

The \texttt{Liferay.Browser} object contains methods that expose the
current user agent characteristics without the need of accessing and
parsing the global \texttt{window.navigator} object.

The available methods for the \texttt{Liferay.Browser} object are listed
in the table below:

\noindent\hrulefill

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.3333}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Method
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Return Type
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Description
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
acceptsGzip & boolean & Returns whether the browser accepts gzip file
compression \\
getMajorVersion & number & Returns the major version of the browser \\
getRevision & number & Returns the revision version of the browser \\
getVersion & number & Returns the major.minor version of the browser \\
isAir & boolean & Returns whether the browser is Adobe AIR \\
isChrome & boolean & Returns whether the browser is Chrome \\
isFirefox & boolean & Returns whether the browser is Firefox \\
isGecko & boolean & Returns whether the browser is Gecko \\
isIe & boolean & Returns whether the browser is Internet Explorer \\
isIphone & boolean & Returns whether the browser is on an Iphone \\
isLinux & boolean & Returns whether the browser is being viewed on
Linux \\
isMac & boolean & Returns whether the browser is being viewed on Mac \\
isMobile & boolean & Returns whether the browser is being viewed on a
mobile device \\
isMozilla & boolean & Returns whether the browser is Mozilla \\
isOpera & boolean & Returns whether the browser is Opera \\
isRtf & boolean & Returns whether the browser supports RTF \\
isSafari & boolean & Returns whether the browser is Safari \\
isSun & boolean & Returns whether the browser is being viewed on Sun
OS \\
isWebKit & boolean & Returns whether the browser is WebKit \\
isWindows & boolean & Returns whether the browser is being viewed on
Windows \\
\end{longtable}

\noindent\hrulefill

\subsection{Related Topics}\label{related-topics-151}

\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-themedisplay}{Accessing
ThemeDisplay Information}

\section{Invoking Liferay Services}\label{invoking-liferay-services}

Liferay DXP provides many web services out-of-the-box. To see a
comprehensive list of the available web services, navigate to
\texttt{http://localhost:8080/api/jsonws} (assuming your localhost is
running on port 8080). If you've deployed your own Service
Builder-generated JSON web services,
\href{/docs/7-1/tutorials/-/knowledge_base/t/registering-json-web-services\#mapping-and-naming-conventions}{follow
these guidelines} for invoking them. These services are useful for
creating single page applications and can even be used to create custom
front-ends in Liferay DXP.

This tutorial explains how to invoke these web services using
JavaScript.

\subsection{Invoking Web Services via
JavaScript}\label{invoking-web-services-via-javascript}

7.0 contains a global JavaScript object called \texttt{Liferay} that has
many useful utilities. One method is \texttt{Liferay.Service}, which
invokes JSON web services.

The \texttt{Liferay.Service} method takes four possible arguments:

\textbf{service \{string\textbar object\}:} Specify the service name or
an object with the keys as the service to call, and the value as the
service configuration object. (Required)

\textbf{data \{object\textbar node\textbar string\}:} Specify the data
to send to the service. If the object passed is the ID of a form or a
form element, the form fields will be serialized and used as the data.

\textbf{successCallback \{function\}:} A function to execute when the
server returns a response. It receives a JSON object as its first
parameter.

\textbf{exceptionCallback \{function\}:} A function to execute when the
response from the server contains a service exception. It receives an
exception message as its first parameter.

One of the benefits of using the \texttt{Liferay.Service} method versus
using a standard AJAX request is that it handles the authentication for
you.

Below is an example configuration of the \texttt{Liferay.Service}
method:

\begin{verbatim}
Liferay.Service(
        '/user/get-user-by-email-address',
        {
                companyId: Liferay.ThemeDisplay.getCompanyId(),
                emailAddress: 'test@example.com'
        },
        function(obj) {
                console.log(obj);
        }
);
\end{verbatim}

The example above retrieves information about a user by passing its
\texttt{companyId} and \texttt{emailAddress}. The response data
resembles the following JSON object:

\begin{verbatim}
{
        "agreedToTermsOfUse": true,
        "comments": "",
        "companyId": "20116",
        "contactId": "20157",
        "createDate": 1471990639779,
        "defaultUser": false,
        "emailAddress": "test@example.com",
        "emailAddressVerified": true,
        "facebookId": "0",
        "failedLoginAttempts": 0,
        "firstName": "Test",
        "googleUserId": "",
        "graceLoginCount": 0,
        "greeting": "Welcome Test Test!",
        "jobTitle": "",
        "languageId": "en_US",
        "lastFailedLoginDate": null,
        "lastLoginDate": 1471996720765,
        "lastLoginIP": "127.0.0.1",
        "lastName": "Test",
        "ldapServerId": "-1",
        "lockout": false,
        "lockoutDate": null,
        "loginDate": 1472077523149,
        "loginIP": "127.0.0.1",
        "middleName": "",
        "modifiedDate": 1472077523149,
        "mvccVersion": "7",
        "openId": "",
        "portraitId": "0",
        "reminderQueryAnswer": "test",
        "reminderQueryQuestion": "what-is-your-father's-middle-name",
        "screenName": "test",
        "status": 0,
        "timeZoneId": "UTC",
        "userId": "20156",
        "uuid": "c641a7c9-5acb-aa68-b3ea-5575e1845d2f"
}
\end{verbatim}

Now that you know how to send an individual request, you're ready to run
batch requests.

\subsection{Batching Requests}\label{batching-requests}

Another way to invoke the \texttt{Liferay.Service} method is by passing
an object with the keys of the service to call and the value of the
service configuration object.

Below is an example configuration for a batch request:

\begin{verbatim}
Liferay.Service(
        {
                '/user/get-user-by-email-address': {
                        companyId: Liferay.ThemeDisplay.getCompanyId(),
                        emailAddress: 'test@example.com'
                }
        },
        function(obj) {
                console.log(obj);
        }
);
\end{verbatim}

You can invoke multiple services with the same request by passing in an
array of service objects. Here's an example:

\begin{verbatim}
Liferay.Service(
        [
                {
                        '/user/get-user-by-email-address': {
                                companyId: Liferay.ThemeDisplay.getCompanyId(),
                                emailAddress: 'test@example.com'
                        }
                },
                {
                        '/role/get-user-roles': {
                                userId: Liferay.ThemeDisplay.getUserId()
                        }
                }
        ],
        function(obj) {
                // obj is now an array of response objects
                // obj[0] == /user/get-user-by-email-address data
                // obj[1] == /role/get-user-roles data

                console.log(obj);
        }
);
\end{verbatim}

Next you can learn how to nest your requests.

\subsection{Nesting Requests}\label{nesting-requests}

Nested service calls bind information from related objects together in a
JSON object. You can call other services in the same HTTP request and
conveniently nest returned objects.

You can use variables to reference objects returned from service calls.
Variable names must start with a dollar sign (\texttt{\$}).

The example in this section retrieves user data with
\texttt{/user/get-user-by-id} and uses the \texttt{contactId} returned
from that service to then invoke \texttt{/contact/get-contact} in the
same request.

\noindent\hrulefill

\textbf{Note:} You must flag parameters that take values from existing
variables. To flag a parameter, insert the \texttt{@} prefix before the
parameter name.

\noindent\hrulefill

Below is an example configuration that demonstrates these concepts:

\begin{verbatim}
Liferay.Service(
        {
                "$user = /user/get-user-by-id": {
                        "userId": Liferay.ThemeDisplay.getUserId(),
                        "$contact = /contact/get-contact": {
                                "@contactId": "$user.contactId"
                        }
                }
        },
        function(obj) {
                console.log(obj);
        }
);
\end{verbatim}

Here is what the response data would look like for the request above:

\begin{verbatim}
{
        "agreedToTermsOfUse": true,
        "comments": "",
        "companyId": "20116",
        "contactId": "20157",
        "createDate": 1471990639779,
        "defaultUser": false,
        "emailAddress": "test@example.com",
        "emailAddressVerified": true,
        "facebookId": "0",
        "failedLoginAttempts": 0,
        "firstName": "Test",
        "googleUserId": "",
        "graceLoginCount": 0,
        "greeting": "Welcome Test Test!",
        "jobTitle": "",
        "languageId": "en_US",
        "lastFailedLoginDate": null,
        "lastLoginDate": 1472231639378,
        "lastLoginIP": "127.0.0.1",
        [...]
        "screenName": "test",
        "status": 0,
        "timeZoneId": "UTC",
        "userId": "20156",
        "uuid": "c641a7c9-5acb-aa68-b3ea-5575e1845d2f",
        "contact": {
                "accountId": "20118",
                "birthday": 0,
                [...]
                "createDate": 1471990639779,
                "emailAddress": "test@example.com",
                "employeeNumber": "",
                "employeeStatusId": "",
                "facebookSn": "",
                "firstName": "Test",
                "lastName": "Test",
                "male": true,
                "middleName": "",
                "modifiedDate": 1471990639779,
                [...]
                "userName": ""
        }
}
\end{verbatim}

Now that you know how to process requests, you can learn how to filter
the results.

\subsection{Filtering Results}\label{filtering-results-1}

If you don't want all the properties returned by a service, you can
define a whitelist of properties. This returns only the specific
properties you request in the object.

Below is an example of whitelisting properties:

\begin{verbatim}
Liferay.Service(
        {
                '$user[emailAddress,firstName] = /user/get-user-by-id': {
                        userId: Liferay.ThemeDisplay.getUserId()
                }
        },
        function(obj) {
                console.log(obj);
        }
);
\end{verbatim}

To specify whitelist properties, place the properties in square brackets
(e.g., \texttt{{[}whiteList{]}}) immediately following the name of your
variable. The example above requests only the \texttt{emailAddress} and
\texttt{firstName} of the user.

Below is the filtered response:

\begin{verbatim}
{
        "firstName": "Test",
        "emailAddress": "test@example.com"
}
\end{verbatim}

Next you can learn how to populate the inner parameters of the request.

\subsection{Inner Parameters}\label{inner-parameters-1}

When you pass in an object parameter, you'll often need to populate its
inner parameters (i.e., fields).

Consider a default parameter \texttt{serviceContext} of type
\texttt{ServiceContext}. To make an appropriate call to JSON web
services you might need to set \texttt{serviceContext} fields such as
\texttt{scopeGroupId}, as shown below:

\begin{verbatim}
Liferay.Service(
        '/example/some-web-service',
        {
                serviceContext: {
                        scopeGroupId: 123
                }
        },
        function(obj) {
                console.log(obj);
        }
);
\end{verbatim}

Now you know how to invoke Liferay services!

\subsection{Related Topics}\label{related-topics-152}

\href{/docs/7-1/tutorials/-/knowledge_base/t/javascript-utilities}{Liferay
DXP JavaScript Utilities}

\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-themedisplay}{Accessing
ThemeDisplay Information}

\chapter{JavaScript Module Loaders}\label{javascript-module-loaders}

A JavaScript module encapsulates code into a useful unit that exports
its capability/value. This makes it easier to see the broader scope,
easier to find what you're looking for, and keeps related code close
together. A normal web page usually loads JavaScript files via HTML
\texttt{script} tags. That's fine for small websites, but when
developing large scale web applications, a more robust organization and
loader is needed. A module loader lets an application load dependencies
easily by specifying a string that identifies the JavaScript module's
name.

These tutorials show you how to load JavaScript modules in Portal.

\section{Loading AMD Modules in
Liferay}\label{loading-amd-modules-in-liferay}

Modularized JavaScript code is a specification for the JavaScript
language called Asynchronous Module Definition, or AMD. The
\href{https://github.com/liferay/liferay-amd-loader\#amd-module-loader}{Liferay
AMD Module Loader} is the native loader that you can use to load your
AMD modules. This tutorial covers how to use the Liferay AMD Module
Loader.

\noindent\hrulefill

\textbf{Note:} While you can manually configure the AMD Loader, we
recommend that you use the
\href{/docs/7-1/tutorials/-/knowledge_base/t/using-npm-in-your-portlets}{liferay-npm-bundler}
instead.

\noindent\hrulefill

\subsection{Configuring Your AMD Module for the
Loader}\label{configuring-your-amd-module-for-the-loader}

Follow these steps to prepare your module:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Wrap your AMD module code with the \texttt{Liferay.Loader.define()}
  method, such as the one shown below:

\begin{verbatim}
Liferay.Loader.define('my-dialog', ['my-node', 'my-plugin-base'], 
function(myNode, myPluginBase) {
   return {
       log: function(text) {
           console.log('module my-dialog: ' + text);
       }
   };
});
\end{verbatim}
\item
  You can modify the configuration to load the module when another
  module is triggered or when a condition is met. The configuration
  below specifies that this module should be loaded if the developer
  requests the \texttt{my-test} module:

\begin{verbatim}
Liferay.Loader.define('my-dialog', ['my-node', 'my-plugin-base'], 
function(myNode, myPluginBase) {
   return {
       log: function(text) {
           console.log('module my-dialog: ' + text);
       }
   };
}, {
   condition: {
       trigger: 'my-test',
       test: function() {
           var el = document.createElement('input');

           return ('placeholder' in el);
       }
   },
   path: 'my-dialog.js'
});
\end{verbatim}

  The Liferay AMD Loader uses the definition, along with the listed
  dependencies, as well as any other configurations specified, to create
  a \texttt{config.json} file. This configuration object tells the
  loader which modules are available, where they are located, and what
  dependencies they require. Below is an example of a generated
  \texttt{config.json} file:

\begin{verbatim}
{
    "frontend-js-web@1.0.0/html/js/parser": {
        "dependencies": []
    },
    "frontend-js-web@1.0.0/html/js/list-display": {
        "dependencies": ["exports"]
    },
    "frontend-js-web@1.0.0/html/js/autocomplete": {
        "dependencies": ["exports", "./parser", "./list-display"]
    }
}
\end{verbatim}
\item
  Load your module in your scripts. Pass the module name to the
  \texttt{Liferay.Loader.require} method. The example below loads a
  module called \texttt{my-dialog}:

\begin{verbatim}
Liferay.Loader.require('my-dialog', function(myDialog) {
    // your code here
}, function(error) {
    console.error(error);
});
\end{verbatim}
\end{enumerate}

\noindent\hrulefill

\textbf{Note:} By default, the AMD Loader times out in seven seconds.
Since Liferay DXP Fix Pack 3 and Liferay Portal 7.1 CE GA 2, you can
configure this value through System Settings. Open the Control Panel and
navigate to \emph{Configuration} → \emph{System Settings} →
\emph{PLATFORM} → \emph{Infrastructure}, and select \emph{JavaScript
Loader}. Set the \emph{Module Definition Timeout} configuration to the
time you want and click \emph{Save}.

\noindent\hrulefill

\subsection{Related Topics}\label{related-topics-153}

\href{/docs/7-1/tutorials/-/knowledge_base/t/loading-modules-with-aui-script}{Loading
Modules with AUI Script}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-npm-in-your-portlets}{Using
npm in Your Portlets}

\section{Using External JavaScript
Libraries}\label{using-external-javascript-libraries}

You can use external JavaScript libraries in your portlets (i.e.,
anything but Metal.js, jQuery, or Lodash, which are included by
default). There are a few methods you can use to make external libraries
available. The method you should choose depends on the external
libraries you plan to use and how you plan to use them.

This tutorial covers how to adapt external libraries for the JavaScript
Loaders.

\subsection{Configuring Libraries to Support
UMD}\label{configuring-libraries-to-support-umd}

If you're the owner of the library, you should make sure that it
supports \href{https://github.com/umdjs/umd}{UMD} (Universal Module
Definition). You can configure your code to support UMD with the
template shown below:

\begin{verbatim}
// Assuming your "module" will be exported as "mylibrary"
(function (root, factory) {
    if (typeof Liferay.Loader.define === 'function' && Liferay.Loader.define.amd) {
        // AMD. Register as a "named" module.
        Liferay.Loader.define('mylibrary', [], factory);
    } else if (typeof module === 'object' && module.exports) {
        // Node. Does not work with strict CommonJS, but
        // only CommonJS-like environments that support module.exports,
        // like Node.
        module.exports = factory();
    } else {
        // Browser globals (root is window)
        root.mylibrary = factory();
  }
}(this, function () {

    // Your library code goes here
    return {};
}));
\end{verbatim}

Next you can learn how to use libraries that you host.

\subsection{Using Libraries That You
Host}\label{using-libraries-that-you-host}

If you're hosting the library (and not loading it from a CDN), you must
hide the Liferay AMD Loader to use your Library. Follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open the Control Panel, navigate to \emph{Configuration} →
  \emph{System Settings}.
\item
  Click \emph{JavaScript Loader} under \emph{Platform} →
  \emph{Infrastructure}.
\item
  Uncheck the \texttt{expose\ global} option.
\end{enumerate}

\noindent\hrulefill

\textbf{Note:} Once this option is unchecked, you can no longer use the
\texttt{Liferay.Loader.define} or \texttt{Liferay.Loader.require}
functions in your app. Also, if you're using third party libraries that
are AMD compatible, they could stop working after unchecking this option
because they usually use global functions like \texttt{require()} or
\texttt{define()}.

\noindent\hrulefill

Now you know how to adapt external libraries for Liferay's JavaScript
Loaders.

\subsection{Related Topics}\label{related-topics-154}

\href{/docs/7-1/tutorials/-/knowledge_base/t/loading-amd-modules-in-liferay}{Liferay
AMD Module Loader}

\href{/docs/7-1/tutorials/-/knowledge_base/t/preparing-your-javascript-files-for-esplus}{Using
ES2015+ Modules in Your Portlet}

\section{Loading Modules with AUI
Script}\label{loading-modules-with-aui-script}

The \texttt{aui:script} tag is a JSP tag that loads JavaScript in script
tags on the page, while ensuring that certain resources are loaded
before executing.

\noindent\hrulefill

\textbf{Note:} AUI is deprecated and no longer in active development in
7.0, but all the tags will remain fully functional in Liferay DXP 7.1.
Eventually, these tags will be replaced with
\href{https://claycss.com/}{Clay} tag counterparts.

\noindent\hrulefill

\subsection{Using aui:script}\label{using-auiscript}

The \texttt{aui:script} tag supports the following options:

\begin{itemize}
\tightlist
\item
  \texttt{require}: Requires an AMD module to load with the
  \href{https://github.com/liferay/liferay-amd-loader\#amd-module-loader}{Liferay
  AMD Module Loader}.
\item
  \texttt{use}: Uses an AlloyUI/YUI module that is loaded via the YUI
  loader.
\item
  \texttt{position}: The position the script tag is put on the page.
  Possible options are \texttt{inline} or \texttt{auto}.
\item
  \texttt{sandbox}: Whether to wrap the script tag in an anonymous
  function. If set to \texttt{true}, in addition to the wrapping,
  \texttt{\$} and \texttt{\_} are defined for jQuery and underscore.
\end{itemize}

Next you can learn how to load ES2015 and
\href{https://metaljs.com/}{Metal.js} modules.

\subsection{Loading ES2015 and Metal.js
Modules}\label{loading-es2015-and-metal.js-modules}

You can use \texttt{aui:script} to load your ES2015 and Metal.js modules
like this:

\begin{verbatim}
<aui:script require="metal-clipboard/src/Clipboard">
    new metalClipboardSrcClipboard.default();
</aui:script>
\end{verbatim}

alternatively, you can specify a variable for your module by adding
\texttt{as\ variableName} after the module name, as shown in the example
below:

\begin{verbatim}
<aui:script require="metal-clipboard/src/Clipboard as myModule">
    new myModule.default();
</aui:script>
\end{verbatim}

This resolves the dependencies of the registered \texttt{Clipboard.js}
and loads them in order until all of them are satisfied and the
requested module can be safely executed.

In the browser, the \texttt{aui:script} translates to the full HTML
shown below:

\begin{verbatim}
<script type="text/javascript">
    Liferay.Loader.require("metal-clipboard/src/Clipboard", 
    function(metalClipboardSrcClipboard) {
        (function() {
            new metalClipboardSrcClipboard.default();
        })()
    }, function(error) {
        console.error(error)
    });
</script>
\end{verbatim}

Next you can learn how to load AlloyUI modules.

\subsection{Loading AlloyUI Modules}\label{loading-alloyui-modules}

You can use the \texttt{use} attribute to load AlloyUI/YUI modules:

\begin{verbatim}
<aui:script use="aui-base">
    A.one('#someNodeId').on(
        'click',
        function(event) {
            alert('Thank you for clicking.')
        }
    );
</aui:script>
\end{verbatim}

This loads the \texttt{aui-base} AlloyUI component and makes it
available to the code inside the \texttt{aui:script}.

In the browser, the \texttt{aui:script} translates to the full HTML
shown below:

\begin{verbatim}
<script type="text/javascript">
    AUI().use("aui-base",
        function(A){
            A.one('#someNodeId').on(
                'click',
                function(event) {
                    alert('Thank you for clicking.')
                }
            );
        }
    );
</script>
\end{verbatim}

Next you can learn how to load AlloyUI modules together with ES2015 and
Metal.js modules.

\subsection{Loading AlloyUI Modules and ES2015 and Metal.js Modules
Together}\label{loading-alloyui-modules-and-es2015-and-metal.js-modules-together}

You may want to load an AUI module along with an ES2015 module or
Metal.js module in an \texttt{aui:script}. The \texttt{aui:script} tag
doesn't support both the \texttt{require} and \texttt{use} attributes in
the same configuration. Not to worry though. You can use the
\texttt{aui:script}'s \texttt{require} attribute to load the ES2015 and
Metal.js modules, while loading the AUI module(s) with the
\texttt{AUI().use()} function within the script. Below is an example
configuration:

\begin{verbatim}
<aui:script require="path-to/metal/module">
 AUI().use(
    'liferay-aui-module', 
    function(A) {
        let var = pathToMetalModule.default;
    }
);
</aui:script>
\end{verbatim}

Now you know how to load modules with the \texttt{aui:script} tag!

\subsection{Related Topics}\label{related-topics-155}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-external-javascript-libraries}{Using
External JavaScript Libraries}

\href{/docs/7-1/tutorials/-/knowledge_base/t/loading-amd-modules-in-liferay}{Loading
AMD Modules}

\chapter{Using Front-End Frameworks in Your
portlets}\label{using-front-end-frameworks-in-your-portlets}

You can use the most popular Front-End frameworks in your portlets with
just a few minor updates to the standard portlet configuration. To help
kick-start your portlet project, you can choose from several
\href{/docs/7-1/reference/-/knowledge_base/r/project-templates}{Blade
portlet project templates}. The following templates are covered in this
section:

\begin{itemize}
\tightlist
\item
  Angular
\item
  React
\item
  Vue
\end{itemize}

Alternatively, you can
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-and-bundling-javascript-portlets-with-javascript-tooling}{use
Liferay DXP's Liferay JS Generator} to build JavaScript-based portlets.
The tutorials in this section show how to use front-end frameworks in
your portlets.

\noindent\hrulefill

\textbf{Note:} JavaScript Server-Side-Rendering is not supported
out-of-the-box. To use JS frameworks for site rendering, you
\textbf{must} set up your server-side (or search-crawler) rendering
generation to support them.

\section{Using React in Your
Portlets}\label{using-react-in-your-portlets}

You can use the
\href{/docs/7-1/reference/-/knowledge_base/r/npm-react-portlet-template}{npm
React portlet template} to automate much of the required configuration
for you or create the module manually. For convenience, all manual steps
are listed below. This tutorial shows how to use React in your portlets,
whether you're migrating an existing React project or building a fresh
project. See the
\href{/docs/7-1/reference/-/knowledge_base/r/npm-react-portlet-template}{npm
React portlet template} reference docs for more information on the
portlet's anatomy or the
\href{/docs/7-1/reference/-/knowledge_base/r/react-npm-portlet}{react
npm portlet sample} for a React portlet example that you can test and
deploy right now. Get started by creating your OSGi module and
configuring its metadata.

\subsection{Configuring Metadata}\label{configuring-metadata}

Follow these steps to create the module and configure its metadata for
React:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/starting-module-development\#creating-a-module}{Create
  an OSGi module}. For example, use the
  \href{/docs/7-1/reference/-/knowledge_base/r/npm-react-portlet-template}{npm
  React portlet template}.
\item
  Specify the \texttt{Web-ContextPath} BND Header in your project's
  \texttt{bnd.bnd} file. Below is the default configuration for the npm
  React portlet template:

\begin{verbatim}
Web-ContextPath: /my-npm-react-portlet
\end{verbatim}
\item
  Create a
  \href{/docs/7-1/reference/-/knowledge_base/r/configuring-liferay-npm-bundler}{\texttt{.babelrc}
  file} and add the following presets to it:

\begin{verbatim}
{
    "presets": ["env", "react"]
}
\end{verbatim}
\item
  Optionally add a
  \href{/docs/7-1/reference/-/knowledge_base/r/configuring-liferay-npm-bundler}{\texttt{.npmbundlerrc}
  file} to your project's root folder. This file is not required. You
  can, however, configure this file to customize the
  \texttt{liferay-npm-bundler} to suit your needs, such as to ignore
  files.
\item
  Include the following dependency in your \texttt{build.gradle} file:

\begin{verbatim}
compileOnly group: "com.liferay", 
name: "com.liferay.frontend.js.loader.modules.extender.api", 
version: "2.0.2"
\end{verbatim}
\item
  Create a \texttt{package.json} in your project if it doesn't already
  exist with the configuration shown below. Update the \texttt{"main"}
  JS path to point to your app's main JS file. Note that the
  \texttt{liferay-npm-bundler} is added last to the build script. List
  any additional build processes before this that your project requires:

\begin{verbatim}
{
    "dependencies": {
        "react": "15.6.2",
        "react-dom": "15.6.2"
    },
  "description": "React Portlet",
    "devDependencies": {
        "babel-cli": "^6.26.0",
        "babel-preset-env": "^1.7.0",
        "babel-preset-react": "6.24.1",
        "liferay-npm-bundler": "^2.0.0"
    },
    "main": "js/index.js",
    "name": "my-npm-react-portlet",
    "scripts": {
        "build": "babel --source-maps -d 
    build/resources/main/META-INF/resources 
    src/main/resources/META-INF/resources && liferay-npm-bundler"
    },
    "version": "1.0.0"
}    
\end{verbatim}
\end{enumerate}

To use ES2015+ syntax in your portlet, you must transpile it for the
browser. Babel, included in your build script, takes care of this for
you.

Next You can configure the portlet.

\subsection{Configuring the Portlet}\label{configuring-the-portlet}

Follow these steps to configure your portlet:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a Component class that implements the \texttt{Portlet.class}
  service:

\begin{verbatim}
@Component(
    immediate = true,
    property = {
        "com.liferay.portlet.display-category=category.sample",
        "com.liferay.portlet.instanceable=true",
        "javax.portlet.init-param.template-path=/",
        "javax.portlet.init-param.view-template=/view.jsp",
        "javax.portlet.name=" + MyNpmReactPortletKeys.MyNpmReact,
        "javax.portlet.resource-bundle=content.Language",
        "javax.portlet.security-role-ref=power-user,user"
    },
    service = Portlet.class
)
public class MyNpmReactPortlet extends MVCPortlet {
  ...
}
\end{verbatim}
\item
  If your React project includes CSS styling as well, add the following
  additional property to specify the location of the main CSS file:

\begin{verbatim}
"com.liferay.portlet.header-portlet-css=/css/main.css"
\end{verbatim}

  Note that this path is relative to the resources path. If using Sass,
  drop the \texttt{.scss} extension in this property and use
  \texttt{.css} instead. For example, if your main CSS file is located
  in \texttt{src/main/resources/META-INF/resources/css/app.scss}, then
  you would have the following configuration:

\begin{verbatim}
"com.liferay.portlet.header-portlet-css=/css/app.css"
\end{verbatim}
\item
  To improve code maintenance,
  \href{/docs/7-1/tutorials/-/knowledge_base/t/referencing-an-npm-modules-package}{use
  the NPMResolver APIs to alias your module's package name}. The example
  below exposes the module's name as \texttt{bootstrapRequire}:

\begin{verbatim}
@Override
public void doView(
        RenderRequest renderRequest, RenderResponse renderResponse)
    throws IOException, PortletException {

    JSPackage jsPackage = _npmResolver.getJSPackage();

    renderRequest.setAttribute(
        MyNpmReactWebKeys.BOOTSTRAP_REQUIRE,
        jsPackage.getResolvedId() + " as bootstrapRequire");

    super.doView(renderRequest, renderResponse);
}

@Reference
private NPMResolver _npmResolver;
\end{verbatim}
\item
  Inside your \texttt{init.jsp}, add the following Java scriptlet to
  access the \texttt{bootstrapRequire} variable in your portlet's
  \texttt{view.jsp}:

\begin{verbatim}
<%
String bootstrapRequire = (String)renderRequest.getAttribute(
  MyNpmReactWebKeys.BOOTSTRAP_REQUIRE
);
%>
\end{verbatim}
\end{enumerate}

Next you can learn how to render your app's component.

\subsection{Rendering Your Component}\label{rendering-your-component}

Follow these steps to render your app component:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Inside your app's main JS file (\texttt{index.js} for example), use
  the function below to render your component:

\begin{verbatim}
import React from 'react';
import ReactDOM from 'react-dom';
import AppComponent from './components/App' //parent component

export default function(elementId) {
  ReactDOM.render(<AppComponent />, document.getElementById(elementId));
}  
\end{verbatim}
\item
  Open your \texttt{view.jsp} and add an element container to house your
  component. Then add an \texttt{\textless{}aui:script\textgreater{}}
  tag and pass your aliased module name as the \texttt{require}
  attribute's value. Finally, call your module's \texttt{default}
  function that you exported in the previous step and pass the container
  element in as the element ID. Adding the
  \texttt{\textless{}portlet:namespace\ /\textgreater{}} to the
  \texttt{\textless{}div\textgreater{}}'s \texttt{id} ensures that it is
  unique to the portlet and doesn't clash with any existing elements on
  the page:

\begin{verbatim}
<%@ include file="/init.jsp" %>

<div id="<portlet:namespace />-root"></div>

<aui:script require="<%= bootstrapRequire %>">
    bootstrapRequire.default('<portlet:namespace />-root');
</aui:script>
\end{verbatim}
\end{enumerate}

Now you know how to use React in your projects!

\subsection{Related Topics}\label{related-topics-156}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-angular-js-in-your-portlets}{Using
Angular in Your Portlets}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-vue-in-your-portlets}{Using
Vue in Your Portlets}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-npm-in-your-portlets}{Using
npm in Your Portlets}

\section{Using Vue in Your Portlets}\label{using-vue-in-your-portlets}

You can create a Vue project manually or use the
\href{/docs/7-1/reference/-/knowledge_base/r/npm-vue-js-portlet-template}{npm
Vue portlet template} to automate much of the required configuration for
you. For convenience, all manual steps are listed below. This tutorial
shows how to use Vue JS in your portlets, whether you're migrating an
existing Vue project or building a fresh one. See the
\href{/docs/7-1/reference/-/knowledge_base/r/npm-vue-js-portlet-template}{npm
Vue portlet template} reference docs for more information on the
portlet's anatomy or the
\href{/docs/7-1/reference/-/knowledge_base/r/vue-js-npm-portlet}{npm Vue
portlet sample} for a Vue portlet example that you can test and deploy
right now. Get started by creating your OSGi module and configuring its
metadata.

\subsection{Configuring Metadata}\label{configuring-metadata-1}

Follow these steps to create the module and configure its metadata for
Vue:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/starting-module-development\#creating-a-module}{Create
  an OSGi module}. For example, use the
  \href{/docs/7-1/reference/-/knowledge_base/r/npm-vue-js-portlet-template}{npm
  Vue portlet template}.
\item
  Specify the \texttt{Web-ContextPath} BND Header in your project's
  \texttt{bnd.bnd} file. Below is the default configuration for the npm
  Vue portlet template:

\begin{verbatim}
Web-ContextPath: /my-npm-vue-portlet
\end{verbatim}
\item
  Create a
  \href{/docs/7-1/reference/-/knowledge_base/r/configuring-liferay-npm-bundler}{\texttt{.babelrc}
  file} and add the following presets to it:

\begin{verbatim}
{
    "presets": ["env"]
}
\end{verbatim}
\item
  Optionally add a
  \href{/docs/7-1/reference/-/knowledge_base/r/configuring-liferay-npm-bundler}{\texttt{.npmbundlerrc}
  file} to your project's root folder. This file is not required. You
  can, however, configure this file to customize the liferay-npm-bundler
  to suit your needs, such as to ignore files.
\item
  Include the following dependency to your \texttt{build.gradle} file:

\begin{verbatim}
compileOnly group: "com.liferay", 
name: "com.liferay.frontend.js.loader.modules.extender.api", 
version: "2.0.2"
\end{verbatim}
\item
  Create a \texttt{package.json} in your project if it doesn't already
  exist and add the configuration shown below to it. Update the
  \texttt{"main"} JS path to point to your app's main JS file. Note that
  the \texttt{liferay-npm-bundler} is added last to the build script.
  List any additional build processes before this that your project
  requires:

\begin{verbatim}
{
    "dependencies": {
        "vue": "2.4.4"
    },
  "description": "Vue.js Portlet",
    "devDependencies": {
        "babel-cli": "^6.26.0",
        "babel-preset-env": "^1.7.0",
        "liferay-npm-bundler": "^2.0.0"
    },
    "main": "js/index.js",
    "name": "my-npm-vuejs-portlet",
    "scripts": {
        "build": "babel --source-maps -d 
    build/resources/main/META-INF/resources 
    src/main/resources/META-INF/resources && liferay-npm-bundler"
    },
    "version": "1.0.0"
}
\end{verbatim}
\end{enumerate}

To use ES2015+ syntax in your portlet, you must transpile it for the
browser. Babel, included in your build script, takes care of this for
you.

Next You can configure the portlet.

\subsection{Configuring the Portlet}\label{configuring-the-portlet-1}

Follow these steps to configure your portlet:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a Component class that implements the \texttt{Portlet.class}
  service:

\begin{verbatim}
@Component(
    immediate = true,
    property = {
        "com.liferay.portlet.display-category=category.sample",
        "com.liferay.portlet.instanceable=true",
        "javax.portlet.init-param.template-path=/",
        "javax.portlet.init-param.view-template=/view.jsp",
        "javax.portlet.name=" + MyNpmVuejsPortletKeys.MyNpmVuejs,
        "javax.portlet.resource-bundle=content.Language",
        "javax.portlet.security-role-ref=power-user,user"
    },
    service = Portlet.class
)
public class MyNpmVuejsPortlet extends MVCPortlet {
  ...
}
\end{verbatim}
\item
  If your Vue project includes CSS styling, add the following additional
  property to specify the location of the main CSS file:

\begin{verbatim}
"com.liferay.portlet.header-portlet-css=/css/main.css"
\end{verbatim}

  Note that this path is relative to the resources path. If using Sass,
  drop the \texttt{.scss} extension in this property and use
  \texttt{.css} instead. For example, if your main CSS file is located
  in \texttt{src/main/resources/META-INF/resources/css/app.scss}, then
  you would have the following configuration:

\begin{verbatim}
"com.liferay.portlet.header-portlet-css=/css/app.css"
\end{verbatim}
\item
  To improve code maintenance,
  \href{/docs/7-1/tutorials/-/knowledge_base/t/referencing-an-npm-modules-package}{use
  the NPMResolver APIs to alias your module's package name}. The example
  below exposes the module's name as \texttt{bootstrapRequire}:

\begin{verbatim}
@Override
public void doView(
        RenderRequest renderRequest, RenderResponse renderResponse)
    throws IOException, PortletException {

    JSPackage jsPackage = _npmResolver.getJSPackage();

    renderRequest.setAttribute(
        MyNpmVuejsWebKeys.BOOTSTRAP_REQUIRE,
        jsPackage.getResolvedId() + " as bootstrapRequire");

    super.doView(renderRequest, renderResponse);
}

@Reference
private NPMResolver _npmResolver;
\end{verbatim}
\item
  Inside your \texttt{init.jsp}, add the following Java scriptlet to
  access the \texttt{bootstrapRequire} variable in your portlet's
  \texttt{view.jsp}:

\begin{verbatim}
<%
String bootstrapRequire = (String)renderRequest.getAttribute(
  MyNpmVuejsWebKeys.BOOTSTRAP_REQUIRE
);
%>
\end{verbatim}
\end{enumerate}

Next you can learn how to render your app's component.

\subsection{Rendering Your Component}\label{rendering-your-component-1}

Follow these steps to render your app component:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Inside your app's main JS file (\texttt{index.js} for example), use
  the function below to render your component:

\begin{verbatim}
import Vue from 'vue/dist/vue.common';

export default function(portletNamespace) {
    // Application 1
    new Vue({
        el: `#${portletNamespace}-root`,
        data: {
            message: 'Hello from Vue.js!',
        },
        methods: {
            reverseMessage: function() {
                this.message = this.message
                    .split('')
                    .reverse()
                    .join('');
            },
        },
    });
}
\end{verbatim}
\item
  Open your \texttt{view.jsp} and add an element container to house your
  component. Then, add an \texttt{\textless{}aui:script\textgreater{}}
  and pass your aliased module name as the \texttt{require} attribute's
  value. Finally, call your module's \texttt{default} function that you
  exported in the previous step and pass the portlet namespace. Adding
  the \texttt{\textless{}portlet:namespace\ /\textgreater{}} to the
  \texttt{\textless{}div\textgreater{}}'s \texttt{id} ensures that it is
  unique to the portlet and doesn't clash with any existing elements on
  the page:

\begin{verbatim}
<%@ include file="/init.jsp" %>

<div id="<portlet:namespace />-root"></div>

<aui:script require="<%= bootstrapRequire %>">
    bootstrapRequire.default('<portlet:namespace />');
</aui:script>
\end{verbatim}
\end{enumerate}

Now you know how to use Vue in your projects!

\subsection{Related Topics}\label{related-topics-157}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-angular-js-in-your-portlets}{Using
Angular in Your Portlets}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-react-in-your-portlets}{Using
React in Your Portlets}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-npm-in-your-portlets}{Using
npm in Your Portlets}

\section{Using Angular in Your
Portlets}\label{using-angular-in-your-portlets}

You can use the
\href{/docs/7-1/reference/-/knowledge_base/r/npm-angular-portlet-template}{npm
Angular portlet template} to automate much of the required configuration
for you, or create the module manually. For convenience, all manual
steps are listed below. This tutorial shows how to use Angular in your
portlets, whether you're migrating an existing Angular project or
building a fresh one. See the
\href{/docs/7-1/reference/-/knowledge_base/r/npm-angular-portlet-template}{npm
Angular portlet template} reference docs for more information on the
portlet's anatomy. Get started by creating your OSGi module and
configuring its metadata.

\subsection{Configuring Metadata}\label{configuring-metadata-2}

Follow these steps to create the module and configure its metadata for
Angular:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/starting-module-development\#creating-a-module}{Create
  an OSGi module}. For example, use the
  \href{/docs/7-1/reference/-/knowledge_base/r/npm-angular-portlet-template}{npm
  Angular portlet template}.
\item
  Specify the \texttt{Web-ContextPath} BND Header in your project's
  \texttt{bnd.bnd} file. Below is the default configuration for the npm
  Angular portlet template:

\begin{verbatim}
Web-ContextPath: /my-npm-angular-portlet
\end{verbatim}
\item
  Create a \texttt{.tsconfig.json} file and add the following
  configuration to it:

\begin{verbatim}
{
    "compilerOptions": {
        "emitDecoratorMetadata": true,
        "experimentalDecorators": true,
        "lib": ["es2015", "dom"],
        "moduleResolution": "node",
        "outDir": "build/resources/main/META-INF/resources/lib",
        "sourceMap": true,
        "suppressImplicitAnyIndexErrors": true,
        "target": "es5",
        "typeRoots": ["./node_modules/@types/"],

        "module": "commonjs",
        "strict": true,
        "noFallthroughCasesInSwitch": true,
        "inlineSources": true,
        "declaration": false,
        "skipLibCheck": true,
        "types": ["jasmine", "node"]
    },
    "include": ["src/main/resources/META-INF/resources/**/*.ts"]
}
\end{verbatim}
\item
  Optionally add a
  \href{/docs/7-1/reference/-/knowledge_base/r/configuring-liferay-npm-bundler}{\texttt{.npmbundlerrc}
  file} to your project's root folder. This file is not required. You
  can, however, configure this file to customize the liferay-npm-bundler
  to suit your needs, such as to ignore files.
\item
  Include the following dependency to your \texttt{build.gradle} file:

\begin{verbatim}
compileOnly group: "com.liferay", 
name: "com.liferay.frontend.js.loader.modules.extender.api", 
version: "2.0.2"
\end{verbatim}
\item
  Create a \texttt{package.json} in your project if it doesn't already
  exist and add the configuration shown below to it. Update the
  \texttt{"main"} JS path to point to your app's main JS file. Note that
  the \texttt{liferay-npm-bundler} is added last to the build script.
  List any additional build processes before this that your project
  requires, such as the \texttt{tsc} (Typescript) process shown below:

\begin{verbatim}
{
    "dependencies": {
        "@angular/animations": "^5.0.0",
        "@angular/common": "^5.0.0",
        "@angular/compiler": "^5.0.0",
        "@angular/core": "^5.0.0",
        "@angular/forms": "^5.0.0",
        "@angular/http": "^5.0.0",
        "@angular/platform-browser": "^5.0.0",
        "@angular/platform-browser-dynamic": "^5.0.0",
        "@angular/platform-server": "^5.0.0",
        "@angular/router": "^5.0.0",
        "@ngx-translate/core": "^9.1.1",
        "core-js": "^2.5.1",
        "rxjs": "^5.5.2",
        "zone.js": "0.8.12"
    },
    "description": "Angular Portlet",
    "devDependencies": {
        "@angular/cli": "^1.6.7",
        "@angular/compiler-cli": "^5.0.0",
        "@compodoc/compodoc": "1.0.0-beta.10",
        "@types/bootstrap": "^3.3.33",
        "@types/bootstrap-datepicker": "0.0.6",
        "@types/jasmine": "2.5.48",
        "@types/jquery": "^2.0.46",
        "@types/moment": "^2.13.0",
        "@types/node": "~6.0.60",
        "@types/toastr": "^2.1.34",
        "chalk": "1.1.3",
        "codelyzer": "3.1.2",
        "del": "^3.0.0",
        "gulp": "^3.9.1",
        "gulp-flatten": "^0.3.1",
        "gulp-sass": "^3.1.0",
        "inline-ng2-resources": "^1.1.0",
        "jasmine-core": "~2.6.2",
        "jasmine-spec-reporter": "~3.2.0",
        "karma": "1.7.0",
        "karma-chrome-launcher": "~2.1.1",
        "karma-cli": "~1.0.1",
        "karma-coverage-istanbul-reporter": "^1.1.0",
        "karma-jasmine": "~1.1.0",
        "karma-jasmine-html-reporter": "^0.2.2",
        "karma-junit-reporter": "1.2.0",
        "karma-remap-istanbul": "^0.2.1",
        "karma-spec-reporter": "0.0.31",
        "liferay-npm-bundler": "^2.0.0",
        "protractor": "~5.1.0",
        "rollup": "0.41.6",
        "rollup-plugin-commonjs": "^8.0.2",
        "rollup-plugin-node-resolve": "3.0.0",
        "shelljs": "0.7.7",
        "sorcery": "0.10.0",
        "ts-node": "~2.0.0",
        "tslint": "5.4.0",
        "typescript": "2.4.2",
        "webpack": "2.6.1",
        "yargs": "8.0.1"
    },
    "main": "js/angular-loader.js",
    "name": "my-npm-angular-portlet",
    "scripts": {
        "build": "tsc && babel --source-maps -d build/resources/main/META-INF/resources src/main/resources/META-INF/resources && liferay-npm-bundler"
    },
    "version": "1.0.0"
}
\end{verbatim}
\end{enumerate}

Next You can configure the portlet.

\subsection{Configuring the Portlet}\label{configuring-the-portlet-2}

Follow these steps to configure your portlet:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a Component class that implements the \texttt{Portlet.class}
  service:

\begin{verbatim}
@Component(
    immediate = true,
    property = {
        "com.liferay.portlet.display-category=category.sample",
        "com.liferay.portlet.instanceable=true",
        "javax.portlet.init-param.template-path=/",
        "javax.portlet.init-param.view-template=/view.jsp",
        "javax.portlet.name=" + MyNpmAngularPortletKeys.MyNpmAngular,
        "javax.portlet.resource-bundle=content.Language",
        "javax.portlet.security-role-ref=power-user,user"
    },
    service = Portlet.class
)
public class MyNpmAngularPortlet extends MVCPortlet {
  ...
}
\end{verbatim}
\item
  If your Angular project includes CSS styling, add the following
  additional property to specify the location of the main CSS file:

\begin{verbatim}
"com.liferay.portlet.header-portlet-css=/css/main.css"
\end{verbatim}

  Note that this path is relative to the resources path. If using Sass,
  drop the \texttt{.scss} extension in this property and use
  \texttt{.css} instead. For example, if your main CSS file is located
  in \texttt{src/main/resources/META-INF/resources/css/app.scss}, then
  you would have the following configuration:

\begin{verbatim}
"com.liferay.portlet.header-portlet-css=/css/app.css"
\end{verbatim}
\item
  To improve code maintenance,
  \href{/docs/7-1/tutorials/-/knowledge_base/t/referencing-an-npm-modules-package}{use
  the NPMResolver APIs to alias your module's package name}. The example
  below exposes the module's name as \texttt{bootstrapRequire}:

\begin{verbatim}
@Override
public void doView(
        RenderRequest renderRequest, RenderResponse renderResponse)
    throws IOException, PortletException {

    JSPackage jsPackage = _npmResolver.getJSPackage();

    renderRequest.setAttribute(
        MyNpmAngularWebKeys.BOOTSTRAP_REQUIRE,
        jsPackage.getResolvedId() + " as bootstrapRequire");

    super.doView(renderRequest, renderResponse);
}

@Reference
private NPMResolver _npmResolver;
\end{verbatim}
\item
  Inside your \texttt{init.jsp}, add the following Java scriptlet to
  access the \texttt{bootstrapRequire} variable in your portlet's
  \texttt{view.jsp}:

\begin{verbatim}
<%
String bootstrapRequire = (String)renderRequest.getAttribute(
  MyNpmAngularWebKeys.BOOTSTRAP_REQUIRE
);
%>
\end{verbatim}
\end{enumerate}

Next you can learn how to render your app's component.

\subsection{Rendering Your Component}\label{rendering-your-component-2}

Follow these steps to render your app component:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Inside your app's main TS file (\texttt{main.ts} for example), use the
  function below to render your component:

\begin{verbatim}
import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';

import { AppComponent } from './app/app.component';
import { AppModule } from './app/app.module';
import { DynamicLoader } from './app/dynamic.loader';

export default function(rootId: any) {
    platformBrowserDynamic()
        .bootstrapModule(AppModule)
        .then((injector: any) => {

            // Load the bootstrap component dynamically so that we can attach it
            // to the portlet's DOM, which is different for each portlet
            // instance and, thus, cannot be determined until the page is
            // rendered (during runtime).

            // The rootId argument is passed from view.jsp where we can obtain
            // the portlet's namespace by using JSP tags.

            const dynamicLoader = new DynamicLoader(injector);

            dynamicLoader.loadComponent(AppComponent, rootId);
        });
}
\end{verbatim}
\item
  In a separate file, such as \texttt{angular-loader.ts}, you can add
  the following configuration:

\begin{verbatim}
// Import needed polyfills before application is launched

import 'reflect-metadata';
import 'zone.js';

// Declare Liferay AMD loader

declare var Liferay: any;

// Launch application

export default function(rootId: any) {
    Liferay.Loader.require('my-npm-angular-portlet@1.0.0/js/main', 
  (main: any) => {
        main.default(rootId);
    });
}
\end{verbatim}
\item
  Open your \texttt{view.jsp} and add an element container to house your
  component. Then, add an \texttt{\textless{}aui:script\textgreater{}}
  and pass your aliased module name as the \texttt{require} attribute's
  value. Finally, call your module's \texttt{default} function that you
  exported in the previous step, and pass the container element in as
  the root ID. Adding the
  \texttt{\textless{}portlet:namespace\ /\textgreater{}} to the
  \texttt{\textless{}div\textgreater{}}'s \texttt{id} ensures that it is
  unique to the portlet and doesn't clash with any existing elements on
  the page:

\begin{verbatim}
<%@ include file="/init.jsp" %>

<div id="<portlet:namespace />-root"></div>

<aui:script require="<%= bootstrapRequire %>">
    bootstrapRequire.default('#<portlet:namespace />-root');
</aui:script>
\end{verbatim}
\end{enumerate}

Now you know how to use Angular in your projects!

\subsection{Related Topics}\label{related-topics-158}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-react-in-your-portlets}{Using
React in Your Portlets}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-vue-in-your-portlets}{Using
Vue in Your Portlets}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-npm-in-your-portlets}{Using
npm in Your Portlets}

\section{Creating and Bundling JavaScript Widgets with JavaScript
Tooling}\label{creating-and-bundling-javascript-widgets-with-javascript-tooling}

The Liferay JS Generator generates JavaScript widgets for Liferay DXP.
It is just one of Liferay JS Bundle Toolkit's
\href{https://github.com/liferay/liferay-npm-build-tools/tree/master/packages}{tools}.

\noindent\hrulefill

\textbf{Important:} To use the Liferay JS Generator, you must have the
Liferay JS Portlet Extender installed in your Liferay DXP instance. The
JS Portlet Extender is a Labs application available from Liferay
Marketplace for
\href{https://web.liferay.com/marketplace/-/mp/application/115543020}{Liferay
Digital Enterprise 7.1} and
\href{https://web.liferay.com/marketplace/-/mp/application/115542926}{Liferay
Portal CE 7.1}. Apps designated as Labs are experimental and not
supported by Liferay. They're released to accelerate the availability of
useful and cutting-edge features. This status may change without notice.
Please download and use Labs apps at your own discretion.

\noindent\hrulefill

Portlets are a Java standard, so you must have a knowledge and
understanding of how Java works to write one. This can be quite the
hurdle for front-end developers who want to use JavaScript frameworks in
their widgets. Thanks to the JS Portlet Extender and
\href{/docs/7-1/reference/-/knowledge_base/r/liferay-npm-bundler}{liferay-npm-bundler},
developers can easily create and develop JavaScript widgets in Liferay
DXP using pure JavaScript tooling.

\begin{figure}
\centering
\includegraphics{./images/extender-lifecycle.png}
\caption{The JS Portlet Extender lets you use pure JavaScript tooling to
write widgets.}
\end{figure}

\noindent\hrulefill

\textbf{Note:} JavaScript Server-Side-Rendering is not supported
out-of-the-box. To use JS frameworks for site rendering, you
\textbf{must} set up your server-side (or search-crawler) rendering
generation to support them.

\noindent\hrulefill

This section explains how to configure these options for generated JS
widgets:

\begin{itemize}
\tightlist
\item
  Installing the Liferay JS Generator and generating a bundle
\item
  Configuring system and instance settings
\item
  Localization
\item
  Setting portlet properties
\item
  Using translation features
\end{itemize}

\section{Installing the Bundle Generator and Generating a
Bundle}\label{installing-the-bundle-generator-and-generating-a-bundle}

This tutorial shows how to install the
\href{https://www.npmjs.com/package/generator-liferay-js}{Liferay JS
Generator} and how to use it to create JavaScript widgets.

\noindent\hrulefill

\textbf{Note:} The Liferay Bundle Generator is deprecated as of v2.7.1
of the \href{https://github.com/liferay/liferay-js-toolkit}{Liferay JS
Toolkit}. It has been renamed the Liferay JS Generator. If you're still
running the Liferay Bundle Generator, we recommend that you install the
Liferay JS Generator instead at your earliest convenience, as the
Liferay Bundle Generator will be removed in future versions.

\noindent\hrulefill

\noindent\hrulefill

\textbf{Important:} To use the Liferay JS Generator, you must have the
Liferay JS Portlet Extender installed in your Liferay DXP instance. The
JS Portlet Extender is a Labs application available from Liferay
Marketplace for
\href{https://web.liferay.com/marketplace/-/mp/application/115543020}{Liferay
Digital Enterprise 7.1} and
\href{https://web.liferay.com/marketplace/-/mp/application/115542926}{Liferay
Portal CE 7.1}. Apps designated as Labs are experimental and not
supported by Liferay. They're released to accelerate the availability of
useful and cutting-edge features. This status may change without notice.
Please download and use Labs apps at your own discretion.

\noindent\hrulefill

Follow these steps to create your JavaScript widget:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Install \href{http://nodejs.org/}{Node.js}. Note that Node Package
  Manager (npm) is installed with this as well. You'll use npm to
  install the remaining dependencies and generator, and
  \href{/docs/7-1/reference/-/knowledge_base/r/setting-up-your-npm-environment}{configure
  your npm environment}.
\item
  Install \href{http://yeoman.io/}{Yeoman} for the generator:

\begin{verbatim}
npm install -g yeoman
\end{verbatim}
\item
  Install the Liferay JS Generator:

\begin{verbatim}
npm install -g generator-liferay-js
\end{verbatim}
\item
  Run the generator with the command below, select the JavaScript widget
  you want to create, and answer the prompts that follow.

\begin{verbatim}
yo liferay-js
\end{verbatim}

  \begin{figure}
  \centering
  \includegraphics{./images/liferay-js-generator-prompts.png}
  \caption{The liferay-bundle generator prompts you for widget options.}
  \end{figure}
\item
  If you specified your app server information when your widget was
  generated, you can deploy your widget by running the command below.
  You can verify this by checking the value of the \texttt{liferayDir}
  entry in the widget's \texttt{.npmbuildrc}.

\begin{verbatim}
npm run deploy
\end{verbatim}
\end{enumerate}

Great! Now you know how to install and run the Liferay JS Generator.

\subsection{Related Topics}\label{related-topics-159}

\href{/docs/7-1/reference/-/knowledge_base/r/liferay-npm-bundler}{liferay-npm-bundler}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-npm-in-your-portlets}{Using
npm in Your Portlets}

\href{/docs/7-1/tutorials/-/knowledge_base/t/applying-clay-styles-to-your-app}{Applying
Clay Styles to Your App}

\section{Configuring System Settings and Instance Settings for Your
JavaScript
Widget}\label{configuring-system-settings-and-instance-settings-for-your-javascript-widget}

As of v1.1.0 of the JS Portlet Extender, you can define configuration
options for your widget. These options are passed to the widget's
JavaScript entry point as the \texttt{configuration} parameter. See the
\href{/docs/7-1/reference/-/knowledge_base/r/understanding-the-js-portlet-extender-configuration\#main-entry-point}{main
entry point's reference} for more information on the entry point. Follow
these steps to set system and/or portlet instance settings for your
widget:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Add a \texttt{/features} folder in your project's root folder if it
  doesn't already exist.
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** This location can be overridden with the
 `create-jar.features.configuration` option in your project's `.npmbundlerrc`
 file. See
 [OSGi bundle configuration options](/docs/7-1/reference/-/knowledge_base/r/configuring-liferay-npm-bundler#osgi-bundle-creation-options)
 for all the available options for the bundle.
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\item
  Create a \texttt{configuration.json} file in the \texttt{/features}
  folder and follow the pattern below. See the
  \href{/docs/7-1/reference/-/knowledge_base/r/configuring-system-settings-for-osgi-bundles-created-with-the-bundler}{Configuration
  JSON} reference for an explanation of each of the available options:

\begin{verbatim}
{
  "system": {
    "category": "{category identifier}",
    "name": "{name of configuration}",
    "fields": {
      "{field id 1}": {
        "type": "{field type}",
        "name": "{field name}",
        "description": "{field description}",
        "default": "{default value}",
        "options": {
          "{option id 1}": "{option name 1}",
          "{option id 2}": "{option name 2}",

          "{option id n}": "{option name n}"
        }
      },
      "{field id 2}": {},

      "{field id n}": {}
    }
  },
  "portletInstance": {
    "name": "{name of configuration}",
    "fields": {
      "{field id 1}": {
        "type": "{field type}",
        "name": "{field name}",
        "description": "{field description}",
        "default": "{default value}",
        "options": {
          "{option id 1}": "{option name 1}",
          "{option id 2}": "{option name 2}",

          "{option id n}": "{option name n}"
        }
      },
      "{field id 2}": {},

      "{field id n}": {}
    }
  }
}
\end{verbatim}
\item
  Access a system setting's value or a portlet instance setting's value
  with the syntax \texttt{configuration.system} or
  \texttt{configuration.portletInstance} respectively. For instance, to
  retrieve the \texttt{\{field\ id\ 1\}} system setting's value, you
  would use \texttt{configuration.system.\{field\ id\ 1\}}. Note that
  all fields are passed as strings no matter what type they declare in
  their descriptor.
\end{enumerate}

Awesome! Now you know how to configure system settings and portlet
instance settings for your widget.

\subsection{Related Topics}\label{related-topics-160}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/localizing-your-portlet}{Localizing
  Your Widget}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/using-translation-features-in-your-portlet}{Using
  Translation Features in Your JavaScript Widget}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/configuring-portlet-properties-for-your-js-portlet}{Configuring
  Portlet Properties for Your JavaScript Widget}
\end{itemize}

\section{Localizing Your Widget}\label{localizing-your-widget}

Follow the steps below to learn how to localize your widget:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  If you didn't choose to use localization when you generated the
  bundle, follow this step to enable it in your bundle now, otherwise
  you can skip this step. Create a \texttt{/features/localization}
  folder in your project and add a \texttt{Language.properties} file to
  it. Add a \texttt{create-jar.features.localization} key to your
  \texttt{.npmbuildrc} file that points to the
  \texttt{Language.properties} file. An example configuration is shown
  below:

  \{ ``create-jar'': \{ ``output-dir'': ``dist'', ``features'': \{
  ``js-extender'': true, ``web-context'': ``/my-test-js-widget'',
  ``localization'': ``features/localization/Language'', ``settings'':
  ``features/settings.json'' \} \}, \ldots{} \}
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** The default file path is shown above. You can update this value,
 if you want to place your `Language.properties` file in a different
 location.
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\item
  Configure the \texttt{Language.properties} file and provide the
  localized property files
  (e.g.~\texttt{Language\_{[}locale{]}.properties}) with the
  \href{/docs/7-1/tutorials/-/knowledge_base/t/localizing-your-application\#what-are-language-keys}{language
  keys} for each
  \href{/docs/7-1/tutorials/-/knowledge_base/t/localizing-your-application\#what-locales-are-available-by-default}{available
  translation}. The \emph{JavaScript based widget} configuration is
  shown below:

  javax.portlet.title.my\_js\_portlet\_project=My JS widget Project
  porlet-namespace=Porlet Namespace context-path=Context Path
  portlet-element-id=Portlet Element Id configuration=Configuration
  fruit=Favourite fruit fruit-help=Choose the fruit you like the most
  an-orange=An orange a-pear=A pear an-apple=An apple
\item
  Retrieve a language key's localized value in JavaScript with the
  \texttt{Liferay.Language.get(\textquotesingle{}key\textquotesingle{})}
  method.
\end{enumerate}

Great! Now you know how to localize your widget!

\subsection{Related Topics}\label{related-topics-161}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/configuring-system-settings-and-instance-settings-for-your-js-portlet}{Configuring
  System Settings and Instance Settings for Your JavaScript Widget}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/using-translation-features-in-your-portlet}{Using
  Translation Features in Your JavaScript Widget}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/configuring-portlet-properties-for-your-js-portlet}{Configuring
  Portlet Properties for Your JavaScript Widget}
\end{itemize}

\section{Configuring Portlet Properties for Your JS
Widget}\label{configuring-portlet-properties-for-your-js-widget}

Follow these steps to configure your portlet's properties:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open your generated JavaScript widget's \texttt{package.json} file.
\item
  Set the properties under the \texttt{portlet} entry. Note that these
  are the same properties you would define in the Java
  \texttt{@Component} annotation of a portlet, as defined in the
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/definitions/liferay-portlet-app_7_2_0.dtd.html}{liferay-portlet-app\_7\_2\_0.dtd}.
  An example configuration is shown below:

\begin{verbatim}
"portlet": {
    "com.liferay.portlet.display-category": "category.sample",
    "com.liferay.portlet.header-portlet-css": "/css/styles.css",
    "com.liferay.portlet.instanceable": true,
    "javax.portlet.name": "my_js_portlet_project",
    "javax.portlet.security-role-ref": "power-user,user",
    "javax.portlet.resource-bundle": "content.Language"
},
\end{verbatim}
\item
  Deploy your bundle to apply the changes.
\end{enumerate}

Great! Now you know how to configure your JavaScript portlet's
properties.

\subsection{Related Topics}\label{related-topics-162}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/configuring-system-settings-and-instance-settings-for-your-js-portlet}{Configuring
  System Settings and Instance Settings for Your JavaScript Widget}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/localizing-your-portlet}{Localizing
  Your Widget}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/using-translation-features-in-your-javascript-portlet}{Using
  Translation Features in Your JavaScript Widget}
\end{itemize}

\section{Using Translation Features in Your
Widget}\label{using-translation-features-in-your-widget}

By default, the Liferay JS Generator creates an empty configuration for
translation. The translate script instructs the user how to add new
supported locales or configure the credentials when it is run. The
translate target reads the supported locales you have defined in the
\texttt{supportedLocales} key of your \texttt{.npmbuildrc} file and
checks your \texttt{*language.properties} files to make sure they match.

\noindent\hrulefill

\textbf{Note:} To use the translation features, you must have a
Microsoft Translator key. Provide your credentials through either the
\texttt{translatorTextKey} variable in your \texttt{.npmbuildrc} file,
or provide them in the \texttt{TRANSLATOR\_TEXT\_KEY} environment
variable.

\noindent\hrulefill

Follow these steps to add a new supported locale and automatically
create a language properties file for it with translations:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add the locale to the \texttt{supportedLocales} array in your
  \texttt{.npmbuildrc} file.
\item
  Run the translate target with the command below:

\begin{verbatim}
npm run translate
\end{verbatim}
\item
  The translate target automatically creates a language properties file
  for each new \textbf{supported} locale with translations for your
  language keys. It also warns about locales that are not supported, but
  have a \texttt{*language.properties} file.
\end{enumerate}

Great! Now you know how to use the Liferay JS Generator's translation
features in your app.

\subsection{Related Topics}\label{related-topics-163}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/configuring-system-settings-and-instance-settings-for-your-js-portlet}{Configuring
  System Settings and Instance Settings for Your JavaScript Widget}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/localizing-your-portlet}{Localizing
  Your Widget}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/configuring-portlet-properties-for-your-js-portlet}{Configuring
  Portlet Properties for Your JavaScript Widget}
\end{itemize}

\chapter{Front-End Taglibs}\label{front-end-taglibs}

You have access to a powerful set of taglibs for creating commonly used
UI components in your apps, themes, and web content. The following
taglibs are covered in this section of tutorials:

\begin{itemize}
\item
  AUI: lets you create common UI components such as forms, buttons, and
  more.
\item
  Chart: visualizes data. You can create bar charts, line charts,
  scatter charts, spline charts, and much more.
\item
  Clay: lets you add
  \href{https://clayui.com/docs/components/alerts.html}{Clay
  components}, such as alerts, buttons, drop-down menus, form elements,
  and more to your apps.
\item
  Frontend: Lets you create UI components commonly used throughout
  Portal's apps, such as add menus, cards, management bars, and more.
\item
  Liferay UI: lets you create common UI components such as icons, tabs,
  and more.
\end{itemize}

\noindent\hrulefill

\textbf{Note:} Each taglib is available as a FreeMarker macro, except
for the Chart taglib. The Chart taglib is \textbf{not} available as a
FreeMarker macro. The tutorials in this section provide the proper
syntax to use for each macro. See the
\href{/docs/7-1/reference/-/knowledge_base/r/freemarker-taglib-macros}{FreeMarker
Taglib Mappings reference} for a complete list of the available
FreeMarker taglib macros.

\noindent\hrulefill

In this section of tutorials, you'll learn how to use taglibs to build
awesome user interfaces for your apps!

\chapter{Using the Liferay UI Taglib}\label{using-the-liferay-ui-taglib}

The Liferay UI tag library provides tags that implement commonly used UI
components. These tags make your markup consistent, responsive, and
accessible.

You can find a list of the available Liferay UI taglibs in the
\href{https://docs.liferay.com/portal/7.1-latest/taglibs/util-taglib/liferay-ui/tld-summary.html}{Liferay
UI taglibdocs}. Each taglib has a list of attributes that can be passed
to the tag. Some of these are required and some are optional. See the
taglibdocs to view the requirements for each tag. You'll find the full
markup generated by the tags in their JSPs in their
\href{https://github.com/liferay/liferay-portal/tree/7.1.x/portal-web/docroot/html/taglib/ui}{Liferay
Github Repo} folders.

To use the Liferay-UI taglib library in your apps, you must add the
following declaration to your JSP:

\begin{verbatim}
<%@ taglib prefix="liferay-ui" uri="http://liferay.com/tld/ui" %>
\end{verbatim}

The Liferay-UI taglib is also available via a macro for your FreeMarker
theme and web content templates. Follow this syntax:

\begin{verbatim}
<@liferay_ui["tag-name"] attribute="string value" attribute=10 />
\end{verbatim}

This section of tutorials covers how to create UI components with the
Liferay UI taglibs. Each tutorial contains code examples along with a
screenshot of the resulting UI.

\section{Liferay UI Icons}\label{liferay-ui-icons}

The Liferay UI taglibs provide several icons you can include in your
apps. To add an icon to your app, use the \texttt{liferay-ui:icon} tag
and specify the icon with either the \texttt{icon},
\texttt{iconCssClass}, or \texttt{image} attribute. An example of each
use case is shown below.

The \texttt{image} attribute specifies
\href{https://github.com/liferay/liferay-portal/tree/7.1.x/modules/apps/frontend-theme/frontend-theme-unstyled/src/main/resources/META-INF/resources/_unstyled/images}{Liferay
UI icons} to use (as defined in the Unstyled theme's
\texttt{images/common} folder). Here's an example configuration for a
JSP:

\begin{verbatim}
<div class="col-md-3">
    <liferay-ui:icon image="subscribe" />

    <span class="ml-2">Subscribe</span>
</div>
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/liferay-ui-taglib-icon-subscribe.png}
\caption{Use the image attribute to use a theme icon.}
\end{figure}

The Liferay UI taglib also exposes language flag icons. To use a
language flag icon, provide the \texttt{../language/} relative path
before the icon's name. Below is an example snippet from the Web Content
Search portlet that displays the current language's flag along with a
localized message:

\begin{verbatim}
<liferay-ui:icon
    image='<%= "../language/" + languageId %>'
    message='<%= LanguageUtil.format(
        request,
        "this-result-comes-from-the-x-version-of-this-content",
        snippetLocale.getDisplayLanguage(locale),
        false
    ) %>'
/>
\end{verbatim}

You can achieve the same result in FreeMarker with the following code
that uses the available
\href{https://github.com/liferay/liferay-portal/blob/7.1.x/modules/apps/frontend-theme/frontend-theme-unstyled/src/main/resources/META-INF/resources/_unstyled/templates/init.ftl}{\texttt{init.ftl}
variables} and
\href{/docs/7-1/tutorials/-/knowledge_base/t/using-liferays-macros-in-your-theme}{Liferay
DXP macros}:

\begin{verbatim}
<#assign flag_message>
    <@liferay.language_format 
        arguments=language 
        key="this-result-comes-from-the-x-version-of-this-content" 
    />
</#assign>

<@liferay_ui["icon"]
    image="../language/${language_id}"
    message=flag_message
/>
\end{verbatim}

The full list of available icons is shown in the figures below:

\begin{figure}
\centering
\includegraphics{./images/liferay-ui-taglib-icons.png}
\caption{The Liferay UI taglib offers multiple icons for use in your
app.}
\end{figure}

\begin{figure}
\centering
\includegraphics{./images/liferay-ui-taglib-icon-flags.png}
\caption{Liferay UI icons can be configured based on language.}
\end{figure}

The \texttt{icon} attribute specifies
\href{https://fontawesome.com/v3.2.1/icons/}{Font Awesome icons} to use:

\begin{verbatim}
<liferay-ui:icon icon="angle-down" />
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/liferay-ui-taglib-icon-angle-down.png}
\caption{You can use the icon attribute to include Font Awesome icons in
your app.}
\end{figure}

The \texttt{iconCssClass} attribute specifies a
\href{http://marcoceppi.github.io/bootstrap-glyphicons/}{glyphicon} to
use:

\begin{verbatim}
<liferay-ui:icon
    iconCssClass="icon-remove-sign"
    label="<%= true %>"
    message="unsubscribe"
    url="<%= unsubscribeURL %>"
/>
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/liferay-ui-taglib-icon-css-class.png}
\caption{You can use Font Awesome icons in your app.}
\end{figure}

The examples above use some of the icon's available attributes. See the
\href{https://docs.liferay.com/dxp/portal/7.1-latest/taglibs/util-taglib/liferay-ui/icon.html}{Icon
taglibdocs} for the full list.

\subsection{Related Topics}\label{related-topics-164}

\href{/docs/7-1/tutorials/-/knowledge_base/t/clay-icons}{Clay Icons}

\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-ui-icon-lists}{Liferay
UI Icon Lists}

\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-ui-icon-menus}{Liferay
UI Icon Menus}

\section{Liferay UI Icon Lists}\label{liferay-ui-icon-lists}

An icon list displays icons in a horizontal list, instead of in a pop-up
navigation menu like an
\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-ui-icon-menus}{icon
menu}. You can see an example of an icon list menu in a message board
thread. The thread's actions are visible at all times for
administrators:

\begin{figure}
\centering
\includegraphics{./images/liferay-ui-taglib-icon-list.png}
\caption{Icon lists display an app's actions at all times.}
\end{figure}

Create the list menu with the \texttt{liferay-ui:icon-list} tag and nest
\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-ui-icons}{icons}
for each list item, as shown below:

\begin{verbatim}
<div class="thread-actions">
    <liferay-ui:icon-list>

        <liferay-ui:icon
        iconCssClass="icon-lock"
        message="permissions"
        method="get"
        url="<%= permissionsURL %>"
        useDialog="<%= true %>"
        />

        <liferay-rss:rss
        delta="<%= rssDelta %>"
        displayStyle="<%= rssDisplayStyle %>"
        feedType="<%= rssFeedType %>"
        url="<%= MBRSSUtil.getRSSURL(plid, 0, message.getThreadId(), 0, themeDisplay) %>"
        />

        <liferay-ui:icon
        iconCssClass="icon-remove-sign"
        message="unsubscribe"
        url="<%= unsubscribeURL %>"
        />

        <liferay-ui:icon
        iconCssClass="icon-lock"
        message="lock"
        url="<%= lockThreadURL %>"
        />

        <liferay-ui:icon
        iconCssClass="icon-move"
        message="move"
        url="<%= editThreadURL %>"
        />

        <liferay-ui:icon-delete
        showIcon="<%= true %>"
        trash="<%= trashHelper.isTrashEnabled(themeDisplay.getScopeGroupId()) %>"
        url="<%= deleteURL %>"
        />
    </liferay-ui:icon-list>
</div>
\end{verbatim}

See the
\href{https://docs.liferay.com/dxp/portal/7.1-latest/taglibs/util-taglib/liferay-ui/icon-list.html}{Icon
List taglibdocs} for the full list of available attributes.

\subsection{Related Topics}\label{related-topics-165}

\href{/docs/7-1/tutorials/-/knowledge_base/t/clay-icons}{Clay Icons}

\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-ui-icon-menus}{Liferay
UI Icon Menus}

\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-ui-icons}{Liferay
UI Icons}

\section{Liferay UI Icon Menus}\label{liferay-ui-icon-menus}

You can add a pop-up navigation menu to your app with the
\texttt{liferay-ui:icon-menu} tag. Icon menus display menu options when
needed, storing them away in a collapsed menu when they're not. This
keeps the UI clean and uncluttered. Just as with an icon list, you nest
\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-ui-icons}{icons}
for each navigation item. You can see an example of a icon menu in a
site's actions menu in the My Sites portlet:

\begin{figure}
\centering
\includegraphics{./images/liferay-ui-taglib-icon-menu.png}
\caption{Setting up an icon menu is a piece of cake.}
\end{figure}

Example JSP configuration:

\begin{verbatim}
<liferay-ui:icon-menu
    direction="left-side"
    icon="<%= StringPool.BLANK %>"
    markupView="lexicon"
    message="<%= StringPool.BLANK %>"
    showWhenSingleIcon="<%= true %>"
>

                <liferay-ui:icon
                    message="go-to-public-pages"
                    target="_blank"
                    url="<%= group.getDisplayURL(themeDisplay, false) %>"
                />

                <liferay-ui:icon
                    message="leave"
                    url="<%= leaveURL %>"
                />

</liferay-ui:icon-menu>
\end{verbatim}

Note that the \texttt{url} attribute is required for icons to render
properly. See the
\href{https://docs.liferay.com/dxp/portal/7.1-latest/taglibs/util-taglib/liferay-ui/icon-menu.html}{Icon
Menu taglibdocs} for the full list of attributes.

\subsection{Related Topics}\label{related-topics-166}

\href{/docs/7-1/tutorials/-/knowledge_base/t/clay-icons}{Clay Icons}

\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-ui-icon-lists}{Liferay
UI Icon Lists}

\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-ui-icons}{Liferay
UI Icons}

\section{Liferay UI Tabs}\label{liferay-ui-tabs}

Tabs create dividers that organize content into individual sections.
Content can be embedded or included from another JSP.

To add tabs to your app, use the
\texttt{\textless{}liferay-ui:tabs\textgreater{}} tag and specify each
tab's name as a comma-separated list for the \texttt{names} attribute.
For example, three tabs named \texttt{tab1}, \texttt{tab2}, and
\texttt{tab3}, look like this in the JSP:

\begin{verbatim}
<liferay-ui:tabs names="tab1,tab2,tab3">

</liferay-ui:tabs>
\end{verbatim}

Each tab requires a corresponding section to display content. Nest
\texttt{liferay-ui:section} tags for each of the tabs. Within each
section, you can add HTML content or add content indirectly by including
content from another JSP (via the
\texttt{\textless{}\%@\ includefile="filepath"\%\textgreater{}}
directive). The example snippet below is from the Calendar portlet's
\texttt{configuration.jsp}:

\begin{verbatim}
<liferay-ui:tabs
    names='<%= "user-settings,display-settings,rss" %>'
    param="tabs2"
    refresh="<%= false %>"
    type="tabs nav-tabs-default"
>
    <liferay-ui:section>
        <%@ include file="/configuration/user_settings.jspf" %>
    </liferay-ui:section>

    <liferay-ui:section>
        <%@ include file="/configuration/display_settings.jspf" %>
    </liferay-ui:section>

    <liferay-ui:section>
        <%@ include file="/configuration/rss.jspf" %>
    </liferay-ui:section>
</liferay-ui:tabs>
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/liferay-ui-taglib-tabs.png}
\caption{Tabs are a useful way to organize configuration options into
individual sections within the same UI.}
\end{figure}

The example above uses some of the tab's available attributes. See the
\href{https://docs.liferay.com/dxp/portal/7.1-latest/taglibs/util-taglib/liferay-ui/tabs.html}{Tabs
taglibdocs} for the full list of attributes.

\subsection{Related Topics}\label{related-topics-167}

\href{/docs/7-1/tutorials/-/knowledge_base/t/clay-navigation-bars}{Clay
Navigation Bars}

\href{/docs/7-1/tutorials/-/knowledge_base/t/clay-dropdown-menus-and-action-menus}{Clay
Dropdown Menus and Action Menus}

\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-ui-icon-help}{Liferay
UI Icon Help}

\section{Liferay UI Icon Help}\label{liferay-ui-icon-help}

The icon help tag lets you communicate additional information to your
users in an unobtrusive way. It renders as an iconic question mark that
provides more information through a pop-up tooltip on mouse over. You
can see an example of this in the Control Panel:

\begin{figure}
\centering
\includegraphics{./images/liferay-ui-taglib-tooltip.png}
\caption{Here's an example of the icon help tag.}
\end{figure}

\noindent\hrulefill

\textbf{Note:} If you have installed a custom theme you may also need to
add the following imports to your \texttt{view.jsp} to make
\texttt{liferay-ui:icon-help} tag work:

\begin{verbatim}
 <%@ taglib uri="http://liferay.com/tld/theme" prefix="liferay-theme"%>
 <liferay-theme:defineObjects />
\end{verbatim}

\noindent\hrulefill

Add the \texttt{\textless{}liferay-ui:icon-help/\textgreater{}} tag next
to the UI that needs tooltip information. Define the informational text
with the required \texttt{message} attribute. Below is an example
snippet for one of the Server Administration's clean up actions:

\begin{verbatim}
<h5>
    <liferay-ui:message key="clean-up-permissions" />
    <liferay-ui:icon-help message="clean-up-permissions-help" />
</h5>
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/liferay-ui-taglib-tooltip-02.png}
\caption{help icons are used throughout the Control Panel.}
\end{figure}

Note that the message is supplied via a
\href{/docs/7-1/tutorials/-/knowledge_base/t/localizing-your-application\#where-do-i-put-language-files}{language
key}. While you can use a string for the tooltip's message for testing
purposes, a language key is considered best practice and should be used
in production.

\subsection{Related Topics}\label{related-topics-168}

\href{/docs/7-1/tutorials/-/knowledge_base/t/clay-badges}{Clay Badges}

\href{/docs/7-1/tutorials/-/knowledge_base/t/clay-stickers}{Clay
Stickers}

\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-ui-icon-menus}{Liferay
UI Icon Menus}

\chapter{Using Liferay Front-end Taglibs in Your
Portlet}\label{using-liferay-front-end-taglibs-in-your-portlet}

The Liferay Front-end tag library provides a set of tags for creating
common front-end UI components in your app.

To use the Front-end taglib in you apps, add the following declaration
to your JSP:

\begin{verbatim}
<%@ taglib prefix="liferay-frontend" uri="http://liferay.com/tld/frontend" %>
\end{verbatim}

The Liferay Front-end taglib is also available via a macro for your
FreeMarker theme templates and web content templates. Follow this
syntax:

\begin{verbatim}
<@liferay_frontend["tag-name"] attribute="string value" attribute=10 />
\end{verbatim}

The following Front-end UI components are covered in this section of
tutorials:

\begin{itemize}
\tightlist
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-frontend-add-menu}{Add
  Menu}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-frontend-cards}{Cards}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-frontend-info-bar}{Info
  Bar}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-frontend-management-bar}{Management
  Bar}
\end{itemize}

The tutorials in this section cover how to create these components with
the Front-end taglibs. Each tutorial contains a set of examples along
with a screenshot of the resulting UI.

\section{Liferay Front-end Add Menu}\label{liferay-front-end-add-menu}

The add menu tag creates an add menu button for one or multiple items.
It's used for actions that add entities (e.g.~a new blog entry), and is
part of the Management Bar. Use the
\texttt{\textless{}liferay-frontend:add-menu\textgreater{}} tag to
create the add menu and nest a
\texttt{\textless{}liferay-frontend:add-menu-item\textgreater{}} tag for
each item.

\noindent\hrulefill

\textbf{Note:} This pattern is deprecated as of 7.0. We recommend that
you use the Clay Management Toolbar's
\href{/docs/7-1/tutorials/-/knowledge_base/t/clay-management-toolbar\#creation-menu}{creation
menu pattern} instead.

\noindent\hrulefill

When the menu has one item, the button triggers the item's action as
shown in the example below for the Blogs Admin App:

\begin{verbatim}
<liferay-frontend:management-bar-buttons>
    ...
    <liferay-frontend:add-menu
      inline="<%= true %>"
    >
      <liferay-frontend:add-menu-item
        title='<%= LanguageUtil.get(request, "add-blog-entry") %>'
        url="<%= addEntryURL %>"
      />
    </liferay-frontend:add-menu>

</liferay-frontend:management-bar-buttons>
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/liferay-frontend-taglib-add-menu-one-item.png}
\caption{The add button pattern consists of an \texttt{add-menu} tag and
at least one \texttt{add-menu-item} tag.}
\end{figure}

When the menu has multiple items, they display in a pop-up menu. For
example, the Message Boards Admin application has the configuration
below:

\begin{verbatim}
<liferay-frontend:add-menu>
    ...
    <liferay-frontend:add-menu-item title='<%= LanguageUtil.get(request,
    "thread") %>' url="<%= addMessageURL.toString() %>" />
    ...
    <liferay-frontend:add-menu-item title='<%= LanguageUtil.get(request,
    (categoryId == MBCategoryConstants.DEFAULT_PARENT_CATEGORY_ID) ?
    "category[message-board]" : "subcategory[message-board]") %>'
    url="<%= addCategoryURL.toString() %>" />
    ...
</liferay-frontend:add-menu>
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/liferay-frontend-taglib-add-menu-items.png}
\caption{The add button pattern consists of an \texttt{add-menu} tag and
at least one \texttt{add-menu-item} tag.}
\end{figure}

The examples above use some of the available attributes. See the
\href{https://docs.liferay.com/dxp/apps/foundation/latest/taglibdocs/liferay-frontend/add-menu.html}{add
menu} and
\href{https://docs.liferay.com/dxp/apps/foundation/latest/taglibdocs/liferay-frontend/add-menu-item.html}{add
menu item} taglibdocs for the full list of available attributes for the
tags.

\subsection{Related Topics}\label{related-topics-169}

\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-frontend-cards}{Liferay
Frontend Cards}

\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-frontend-info-bar}{Liferay
Frontend Info Bar}

\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-frontend-management-bar}{Liferay
Frontend Management Bar}

\section{Liferay Front-end Cards}\label{liferay-front-end-cards}

If you have data you want to compare that's heavy on image usage, cards
are the component for the job. Cards visually represent data in a
minimal and compact format. Use them for images, document libraries,
user profiles, and more. There are four main types of Cards covered in
this tutorial:

\begin{itemize}
\tightlist
\item
  Horizontal Cards
\item
  Icon Cards
\item
  Vertical Cards
\item
  User Cards
\end{itemize}

Examples of each card are shown below.

\subsection{Horizontal Card}\label{horizontal-card}

Horizontal cards are used primarily to display documents, such as files
and folders. An example configuration is shown below:

\begin{verbatim}
<liferay-frontend:horizontal-card
    text="Documents"
  url="/docs/7-1/tutorials/-/knowledge_base/t/clay-icons"
>
    <liferay-frontend:horizontal-card-col>
                <liferay-frontend:horizontal-card-icon
                    icon="folder"
                />
    </liferay-frontend:horizontal-card-col>
</liferay-frontend:horizontal-card>
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/liferay-frontend-taglib-cards-horizontal.png}
\caption{Horizontal cards are perfect to display files and documents.}
\end{figure}

The
\texttt{\textless{}liferay-frontend:horizontal-card-icon\textgreater{}}
tag uses \href{/docs/7-1/tutorials/-/knowledge_base/t/clay-icons}{Clay
Icons} for its \texttt{icon} attribute.

\subsection{Icon Vertical Card}\label{icon-vertical-card}

Icon vertical cards, as the name suggests, are cards that display
information in a vertical format that emphasizes an icon. These cards
show content that doesn't have an associated image. Instead, an icon
representing the type of content is displayed. The example snippet below
displays information for a web content article:

\begin{verbatim}
<liferay-frontend:icon-vertical-card
  cssClass="article-preview-content"
  icon="web-content"
  title="<%= title %>"
>
  <liferay-frontend:vertical-card-sticker-bottom>
    <liferay-ui:user-portrait
      cssClass="sticker sticker-bottom"
      userId="<%= assetRenderer.getUserId() %>"
    />
  </liferay-frontend:vertical-card-sticker-bottom>

  <liferay-frontend:vertical-card-footer>
    <aui:workflow-status 
      markupView="lexicon" 
      showIcon="<%= false %>" 
      showLabel="<%= false %>" 
      status="<%= article.getStatus() %>" 
    />
  </liferay-frontend:vertical-card-footer>
</liferay-frontend:icon-vertical-card>
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/liferay-frontend-taglib-cards-icon-vertical.png}
\caption{Vertical icon cards are perfect to display an entity selection,
such as a web content article.}
\end{figure}

\subsection{Vertical Card}\label{vertical-card}

Vertical cards display information in a vertical card format, as opposed
to a horizontal format. If the content has an associated image (like a
blog header image) you can use a vertical card to display the image. If
there is no associated image, you can use an icon vertical card to
represent the content's type instead (e.g.~a PDF file). The example
below displays a vertical card for a web content article when an image
preview is available:

\begin{verbatim}
<liferay-frontend:vertical-card
  cssClass="article-preview-content"
  imageUrl="<%= articleImageURL %>"
  title="<%= title %>"
>
  <liferay-frontend:vertical-card-sticker-bottom>
    <liferay-ui:user-portrait
      cssClass="sticker sticker-bottom"
      userId="<%= assetRenderer.getUserId() %>"
    />
  </liferay-frontend:vertical-card-sticker-bottom>

  <liferay-frontend:vertical-card-footer>
    <aui:workflow-status 
      markupView="lexicon" 
      showIcon="<%= false %>" 
      showLabel="<%= false %>" 
      status="<%= article.getStatus() %>" 
    />
  </liferay-frontend:vertical-card-footer>
</liferay-frontend:vertical-card>
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/liferay-frontend-taglib-cards-vertical.png}
\caption{Vertical cards are perfect to display files and documents.}
\end{figure}

\subsection{HTML Vertical Card}\label{html-vertical-card}

The HTML Vertical card lets you display custom HTML in the header of the
vertical card. The example below embeds a video:

\begin{verbatim}
<liferay-util:buffer var = "customThumbnailHtml">
    <div class="embed-responsive embed-responsive-16by9">
      <iframe class="embed-responsive-item" 
    src="https://www.youtube.com/embed/8Bg9jPJpGOM?rel=0" 
    allowfullscreen></iframe>
    </div>
</liferay-util:buffer>

<div class="container">
  <div class="row">
    <div class="col-md-4">
      <liferay-frontend:html-vertical-card
        html="<%= customThumbnailHtml %>"
        title="My Video"
      >
      </liferay-frontend:html-vertical-card>
    </div>
  </div>
</div>
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/liferay-frontend-taglib-cards-html-vertical.png}
\caption{Html vertical cards let you display custom HTML in the card's
header.}
\end{figure}

\subsection{User Vertical Card}\label{user-vertical-card}

The User Vertical card displays user profile selections in the icon view
of the Management Bar. Below is an example snippet from the User Admin
portlet:

\begin{verbatim}
<liferay-frontend:user-vertical-card
  actionJsp="/membership_request_action.jsp"
  actionJspServletContext="<%= application %>"
  resultRow="<%= row %>"
  subtitle="<%= membershipRequestUser.getEmailAddress() %>"
  title="<%= HtmlUtil.escape(membershipRequestUser.getFullName()) %>"
  userId="<%= membershipRequest.getUserId() %>"
>
  <liferay-frontend:vertical-card-header>
    <liferay-ui:message 
      arguments="<%= LanguageUtil.getTimeDescription(
      request, 
      System.currentTimeMillis() - membershipRequest.getCreateDate().getTime(), 
      true) %>" 
      key="x-ago" 
      translateArguments="<%= false %>" 
    />
  </liferay-frontend:vertical-card-header>
</liferay-frontend:user-vertical-card>
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/liferay-frontend-taglib-cards-user-vertical.png}
\caption{User vertical cards are perfect to display files and
documents.}
\end{figure}

\subsection{Related Topics}\label{related-topics-170}

\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-frontend-add-menu}{Liferay
Front-end Add Menu}

\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-frontend-info-bar}{Liferay
Front-end Info Bar}

\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-frontend-management-bar}{Liferay
Front-end Management Bar}

\section{Liferay Front-end Info Bar}\label{liferay-front-end-info-bar}

An info bar provides a button that toggles the visibility of additional
sidebar information. This is perfect for providing more detailed
metadata for a search result, such as the file size, type, URL, etc.

\begin{figure}
\centering
\includegraphics{./images/liferay-frontend-taglib-info-bar-article.png}
\caption{The info bar tags create a sidebar panel toggler that reveals
additional info.}
\end{figure}

The configuration has two key parts: the info bar---and buttons---and
the sidebar panel.

Info bar:

\begin{verbatim}
<liferay-frontend:info-bar>
  <liferay-frontend:info-bar-buttons>
    <liferay-frontend:info-bar-sidenav-toggler-button
      icon="info-circle"
      label="my info"
    />
  </liferay-frontend:info-bar-buttons>
</liferay-frontend:info-bar>
\end{verbatim}

The
\texttt{\textless{}liferay-frontend:info-bar-sidenav-toggler-button\textgreater{}}
tag uses \href{/docs/7-1/tutorials/-/knowledge_base/t/clay-icons}{Clay
Icons} for the \texttt{icon} attribute.

Sidebar panel:

\begin{verbatim}
<div class="closed container-fluid-1280 sidenav-container sidenav-right" id="<portlet:namespace />infoPanelId">
    <liferay-frontend:sidebar-panel>
      <div>
      <h2>sidebar content</h2>
      <p>Here is some content</p>
      </div>
    </liferay-frontend:sidebar-panel>
</div>
\end{verbatim}

Note that the sidebar panel's wrapper
\texttt{\textless{}div\textgreater{}} has the classes \texttt{closed}
and \texttt{sidenav-right}. The info button toggles the classes
\texttt{open} and \texttt{closed}, showing and hiding the sidebar panel.
The \texttt{sidenav-right} class specifies that the panel should open on
the right.

\begin{figure}
\centering
\includegraphics{./images/liferay-frontend-taglib-info-bar.png}
\caption{The info bar tags create a sidebar panel toggler that reveals
additional info.}
\end{figure}

The examples above use some of the available attributes. See the
\href{https://docs.liferay.com/dxp/apps/foundation/latest/taglibdocs/liferay-frontend/info-bar.html}{info
bar},
\href{https://docs.liferay.com/dxp/apps/foundation/latest/taglibdocs/liferay-frontend/info-bar-buttons.html}{info
bar buttons},
\href{https://docs.liferay.com/dxp/apps/foundation/latest/taglibdocs/liferay-frontend/info-bar-sidenav-toggler-button.html}{info
bar sidenav toggler button}, and
\href{https://docs.liferay.com/dxp/apps/foundation/latest/taglibdocs/liferay-frontend/sidebar-panel.html}{sidebar
panel} taglibdocs for the full list of available attributes for the
tags.

\subsection{Related Topics}\label{related-topics-171}

\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-frontend-add-menu}{Liferay
Front-end Add Menu}

\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-frontend-cards}{Liferay
Front-end Cards}

\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-frontend-management-bar}{Liferay
Front-end Management Bar}

\chapter{Liferay Front-end Management
Bar}\label{liferay-front-end-management-bar}

The Management Bar gives administrators control over search container
results. It lets you filter, sort, and choose a display style for search
results, so you can quickly identify the document, web content, asset
entry, or whatever you're looking for in your app. The Management Bar is
fully customizable, so you can implement all the controls, or just the
ones your app requires.

\begin{figure}
\centering
\includegraphics{./images/liferay-frontend-taglib-management-bar-message-boards.png}
\caption{The Management Bar lets the user customize how the app displays
content.}
\end{figure}

\noindent\hrulefill

\textbf{Note:} The Liferay Front-end Management Bar is deprecated as of
7.0. We recommend that you use the
\href{/docs/7-1/tutorials/-/knowledge_base/t/clay-management-toolbar}{Clay
Management Toolbar} instead.

\noindent\hrulefill

The Management Bar has a few key sections. Each section is grouped and
configured using different taglibs:

The
\href{https://docs.liferay.com/dxp/apps/foundation/latest/taglibdocs/liferay-frontend/management-bar-buttons.html}{\texttt{\textless{}liferay-frontend:management-bar-buttons\textgreater{}}
tag} wraps the Management Bar's button elements:

\begin{figure}
\centering
\includegraphics{./images/liferay-frontend-taglib-management-bar-buttons.png}
\caption{The \texttt{management-bar-buttons} tag contains the Management
Bar's main buttons.}
\end{figure}

The
\href{https://docs.liferay.com/dxp/apps/foundation/latest/taglibdocs/liferay-frontend/management-bar-sidenav-toggler-button.html}{\texttt{\textless{}liferay-frontend:management-bar-sidenav-toggler-button\textgreater{}}
tag} implements slide-out navigation for the info button.

The
\href{https://docs.liferay.com/dxp/apps/foundation/latest/taglibdocs/liferay-frontend/management-bar-display-buttons.html}{\texttt{\textless{}liferay-frontend:management-bar-display-buttons\textgreater{}}
tag} renders the app's display style options.

\begin{figure}
\centering
\includegraphics{./images/liferay-frontend-taglib-management-bar-display-buttons.png}
\caption{The \texttt{management-bar-display-buttons} tag contains the
content's display options.}
\end{figure}

The
\href{https://docs.liferay.com/dxp/apps/foundation/latest/taglibdocs/liferay-frontend/management-bar-filters.html}{\texttt{\textless{}liferay-frontend:management-bar-filters\textgreater{}}
tag} wraps the app's filtering options. This filter should be included
in all control panel applications. Filtering options can include sort
criteria, sort ordering, and more.

\begin{figure}
\centering
\includegraphics{./images/liferay-frontend-taglib-management-bar-filters.png}
\caption{The \texttt{management-bar-filters} tag contains the content
filtering options.}
\end{figure}

Finally, the
\href{https://docs.liferay.com/dxp/apps/foundation/latest/taglibdocs/liferay-frontend/management-bar-action-buttons.html}{\texttt{\textless{}liferay-frontend:management-bar-action-buttons\textgreater{}}
tag} wraps the actions that you can execute over selected items. You can
select multiple items between pages. The management bar keeps track of
the number of selected items for you.

\begin{figure}
\centering
\includegraphics{./images/liferay-frontend-taglib-management-bar-action-buttons.png}
\caption{The management bar keeps track of the items selected and
displays the actions to execute on them.}
\end{figure}

For example, here's the Management Bar configuration in the Trash app:

\begin{verbatim}
<liferay-frontend:management-bar
   includeCheckBox="<%= true %>"
   searchContainerId="trash"
>
   <liferay-frontend:management-bar-buttons>
       <liferay-frontend:management-bar-sidenav-toggler-button />

       <liferay-portlet:actionURL name="changeDisplayStyle"
       varImpl="changeDisplayStyleURL">
           <portlet:param name="redirect" value="<%= currentURL %>" />
       </liferay-portlet:actionURL>

       <liferay-frontend:management-bar-display-buttons
           displayViews='<%= new String[] {"descriptive", "icon",
           "list"} %>'
           portletURL="<%= changeDisplayStyleURL %>"
           selectedDisplayStyle="<%= trashDisplayContext.getDisplayStyle()
           %>"
       />
   </liferay-frontend:management-bar-buttons>

   <liferay-frontend:management-bar-filters>
       <liferay-frontend:management-bar-navigation
           navigationKeys='<%= new String[] {"all"} %>'
           portletURL="<%= trashDisplayContext.getPortletURL() %>"
       />

       <liferay-frontend:management-bar-sort
           orderByCol="<%= trashDisplayContext.getOrderByCol() %>"
           orderByType="<%= trashDisplayContext.getOrderByType() %>"
           orderColumns='<%= new String[] {"removed-date"} %>'
           portletURL="<%= trashDisplayContext.getPortletURL() %>"
       />
   </liferay-frontend:management-bar-filters>

   <liferay-frontend:management-bar-action-buttons>
       <liferay-frontend:management-bar-sidenav-toggler-button />

       <liferay-frontend:management-bar-button href="javascript:;"
       icon="trash" id="deleteSelectedEntries" label="delete" />
   </liferay-frontend:management-bar-action-buttons>
</liferay-frontend:management-bar>
\end{verbatim}

\section{Including Actions in the Management
Bar}\label{including-actions-in-the-management-bar}

While an actions menu is typically included with each search container
result, you can also include these actions in the management bar. This
keeps everything organized within the same UI. This update adds a
checkbox next to each search container result, as well as adds one in
the management bar itself to select all results. The actions are
displayed when a checkbox is checked---individual or select all---and
hidden from view otherwise.

\begin{figure}
\centering
\includegraphics{./images/liferay-frontend-taglib-management-bar-include-checkbox.png}
\caption{You can select individual results or all results at once.}
\end{figure}

Follow these steps to include actions in your management bar:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Update the
  \texttt{\textless{}liferay-frontend:management-bar\textgreater{}} tag
  to include the checkbox and provide the search container's ID:

\begin{verbatim}
<liferay-frontend:management-bar
    includeCheckBox="<%= true %>"
    searchContainerId="mySearchContainerId"
>
\end{verbatim}
\item
  After the closing
  \texttt{\textless{}/liferay-frontend:management-bar-filters\textgreater{}}
  tag, add the
  \texttt{\textless{}liferay-frontend:management-bar-action-buttons\textgreater{}}
  tags:

\begin{verbatim}
<liferay-frontend:management-bar-action-buttons>

</liferay-frontend:management-bar-action-buttons>
\end{verbatim}
\item
  Use the available management bar button taglibs
  (e.g.~\texttt{management-bar-button}) to build the action buttons for
  your app's management bar. A code snippet from the Site admin portlet
  is shown below:

\begin{verbatim}
<liferay-frontend:management-bar-action-buttons>
    <liferay-frontend:management-bar-sidenav-toggler-button
        icon="info-circle"
        label="info"
    />

    <liferay-frontend:management-bar-button
        href="javascript:deleteEntries();"
        icon="trash"
        id="deleteSites"
        label="delete"
    />
</liferay-frontend:management-bar-action-buttons>
\end{verbatim}
\end{enumerate}

\begin{figure}
\centering
\includegraphics{./images/liferay-frontend-taglib-management-bar-actions.png}
\caption{You can have as many actions as your app requires.}
\end{figure}

\subsection{Related Topics}\label{related-topics-172}

\href{/docs/7-1/tutorials/-/knowledge_base/t/disabling-all-or-portions-of-the-management-bar}{Disabling
All or Portions of the Management Bar}

\href{/docs/7-1/tutorials/-/knowledge_base/t/clay-management-toolbar}{Clay
Management Toolbar}

\section{Disabling All or Portions of the Management
Bar}\label{disabling-all-or-portions-of-the-management-bar}

When there are no search results to display, you should disable all the
Management Bar's buttons, except the sidenav toggler button.

You can disable the Management Bar by adding the \texttt{disabled}
attribute to the \texttt{liferay-frontend:management-bar} tag:

\begin{verbatim}
<liferay-frontend:management-bar
        disabled="<%= total == 0 %>"
        includeCheckBox="<%= true %>"
        searchContainerId="<%= searchContainerId %>"
>
\end{verbatim}

You can also disable individual components by adding the
\texttt{disabled} attribute to the corresponding tag. The example below
disables the display buttons when the search container displays 0
results, since changing the display style has no effect when there
aren't any results to view:

\begin{verbatim}
<liferay-frontend:management-bar-display-buttons
        disabled="<%= total == 0 %>"
        displayViews='<%= new String[] {"descriptive", "icon", "list"} %>'
        portletURL="<%= changeDisplayStyleURL %>"
        selectedDisplayStyle="<%= displayStyle %>"
/>
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/liferay-frontend-taglib-management-bar-disabled.png}
\caption{You can disable all or portions of the Management Bar.}
\end{figure}

\subsection{Related Topics}\label{related-topics-173}

\href{/docs/7-1/tutorials/-/knowledge_base/t/including-actions-in-the-management-bar}{Including
Actions in the Management Bar}

\href{/docs/7-1/tutorials/-/knowledge_base/t/clay-management-toolbar}{Clay
Management Toolbar}

\chapter{Using the Liferay Util
Taglib}\label{using-the-liferay-util-taglib}

The Liferay Util taglib is used to pull other resources into a portlet
or theme. You can use it to specify which resources to insert at the
bottom or top of the page's HTML.

To use the Liferay-Util taglib, add the following declaration to your
JSP:

\begin{verbatim}
<%@ taglib prefix="liferay-util" uri="http://liferay.com/tld/util" %>
\end{verbatim}

The Liferay-Util taglib is also available via a macro for your
FreeMarker theme templates and web content templates. Follow this
syntax:

\begin{verbatim}
<@liferay_util["tag-name"] attribute="string value" attribute=10 />
\end{verbatim}

This section of tutorials covers the available Liferay Util tags you can
use in your app to inject content into portlets and themes.

\section{Using Liferay Util Body
Bottom}\label{using-liferay-util-body-bottom}

The body bottom tag is not a self-closing tag. It lets you add
additional HTML or scripts to the bottom of the \texttt{body} tag.
content placed between the opening and closing of this tag is passed to
the
\href{https://github.com/liferay/liferay-portal/blob/7.1.x/portal-web/docroot/html/common/themes/body_bottom.jsp\#L26-L31}{body\_bottom.jsp}
and outputs in this JSP.

This tag also has an optional \texttt{outputKey} attribute. If several
portlets on the page include the same resource with this tag, you can
specify the same \texttt{outputKey} value for each tag so the resource
is only loaded once.

The example configuration below uses the
\texttt{\textless{}liferay-util:body-bottom\textgreater{}} tag to
include JavaScript provided by the portlet's bundle:

\begin{verbatim}
<liferay-util:body-bottom outputKey="bodybottom" >
    <script 
  src="/o/my-liferay-util-portlet/js/my_custom_javascript_body_bottom.js" 
  type="text/javascript"></script>
</liferay-util:body-bottom>
\end{verbatim}

Now you know how to use the
\texttt{\textless{}liferay-util:body-bottom\textgreater{}} tag to
include additional resources in the bottom of the page's body.

\subsection{Related Topics}\label{related-topics-174}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-liferay-util-body-top}{Using
the Liferay Util HTML Body Top Tag}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-liferay-util-html-top}{Using
the Liferay Util HTML Top Tag}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-the-liferay-ui-taglib-in-your-portlets}{Using
the Liferay UI Taglib}

\section{Using Liferay Util Body Top}\label{using-liferay-util-body-top}

The body top tag is not a self-closing tag. The content placed between
the opening and closing of this tag is moved to the top of the
\texttt{body} tag. When something is passed using this taglib, the
\href{https://github.com/liferay/liferay-portal/blob/7.1.x/portal-web/docroot/html/common/themes/body_top.jsp\#L25-L31}{body\_top.jsp}
is passed markup and outputs in this JSP.

This tag also has an optional \texttt{outputKey} attribute. If several
portlets on the page include the same resource with this tag, you can
specify the same \texttt{outputKey} value for each tag so the resource
is only loaded once.

The example configuration below uses the
\texttt{\textless{}liferay-util:body-top\textgreater{}} tag to include
JavaScript provided by the portlet's bundle:

\begin{verbatim}
<liferay-util:body-top outputKey="bodytop" >
    <script 
  src="/o/my-liferay-util-portlet/js/my_custom_javascript_body_top.js" 
  type="text/javascript"></script>
</liferay-util:body-top>
\end{verbatim}

Now you know how to use the
\texttt{\textless{}liferay-util:body-top\textgreater{}} tag to include
additional resources in the top of the page's body.

\subsection{Related Topics}\label{related-topics-175}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-liferay-util-body-bottom}{Using
the Liferay Util HTML Body Bottom Tag}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-liferay-util-html-bottom}{Using
the Liferay Util HTML Bottom Tag}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-the-clay-taglib-in-your-portlets}{Using
the Clay Taglib}

\section{Using Liferay Util Buffer}\label{using-liferay-util-buffer}

The buffer tag is not a self-closing tag. The content placed between the
opening and closing of this tag is saved to a buffer and its output is
assigned to the Java variable declared with the tag's \texttt{var}
attribute. The output is returned as a String, letting you post-process
it. For example, you can use this to
\href{/docs/7-1/tutorials/-/knowledge_base/t/jsp-overrides-using-osgi-fragments\#provide-the-overridden-jsp}{override
a JSP's existing contents}.

The example below saves the link's generated markup to a buffer and then
uses the returned string as the argument for a
\texttt{liferay-ui:message} key:

\begin{verbatim}
<liferay-util:buffer
        var="linkContent"
>
        <aui:a 
            href="https://portal.liferay.dev/" 
            target="_blank">the Liferay Portal project
        </aui:a>
</liferay-util:buffer>

<liferay-ui:message 
        arguments="<%= linkContent %>" 
        key="see-x-for-more-information" 
        translateArguments="<%= false %>" 
/>
\end{verbatim}

Now you know how to use the
\texttt{\textless{}liferay-util:buffer\textgreater{}} tag to save
content to a buffer.

\begin{figure}
\centering
\includegraphics{./images/liferay-util-buffer.png}
\caption{You can use the Liferay Util Buffer tag to save pieces of
markup to reuse in your JSP.}
\end{figure}

\subsection{Related Topics}\label{related-topics-176}

\href{/docs/7-1/tutorials/-/knowledge_base/t/jsp-overrides-using-osgi-fragments\#provide-the-overridden-jsp}{JSP
Overrides Using OSGi Fragments}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-liferay-util-param}{Using
the Liferay Util Param Tag}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-liferay-frontend-taglibs-in-your-portlet}{Using
the Liferay Front-End Taglibs}

\section{Using Liferay Util Dynamic
Include}\label{using-liferay-util-dynamic-include}

The dynamic include tag lets you specify a point or points in a JSP or
theme where a developer can inject additional HTML, resources, or
functionality, using the \texttt{DynamicIncludeRegistry}. You can read
more about the OSGi Service Registry
\href{http://docs.spring.io/osgi/docs/current/reference/html/service-registry.html}{here}.
The \texttt{key} attribute identifies the extension point. See the
\href{/docs/7-1/tutorials/-/knowledge_base/t/dynamic-includes}{Dynamic
Include} tutorials section for example configurations that use dynamic
include extension points to inject additional functionality.

The example configuration below uses the
\texttt{\textless{}liferay-util:dynamic-include\textgreater{}} tag to
include an extension point before the primary code and an extension
point after the primary code:

\begin{verbatim}
<%@ taglib uri="http://liferay.com/tld/util" prefix="liferay-util" %>

<liferay-util:dynamic-include key="/path/to/jsp#pre" />

<div>
        <p>And here we have our content</p>
</div>

<liferay-util:dynamic-include key="/path/to/jsp#post" />
\end{verbatim}

Now you know how to use the
\texttt{\textless{}liferay-util:dynamic-include\textgreater{}} tag to
add extension points to your app.

\subsection{Related Topics}\label{related-topics-177}

\href{/docs/7-1/tutorials/-/knowledge_base/t/dynamic-includes}{Dynamic
Includes}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-liferay-util-body-top}{Using
the Liferay Util Body Top Tag}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-the-chart-taglib-in-your-portlets}{Using
the Chart Taglib}

\section{Using Liferay Util Get URL}\label{using-liferay-util-get-url}

The get URL tag scrapes the URL provided by the \texttt{url} attribute.
If a value is provided for the \texttt{var} attribute, the content from
the screen scrape is scoped to that variable. Otherwise, the scraped
content is displayed where the taglib is used.

A basic configuration for the
\texttt{\textless{}liferay-util:get-url\textgreater{}} tag is shown
below:

\begin{verbatim}
<liferay-util:get-url url="https://portal.liferay.dev/" />
\end{verbatim}

Here is an example that uses the \texttt{var} attribute:

\begin{verbatim}
<liferay-util:get-url url="https://portal.liferay.dev/" var="ldn" />

<div>
                <h2>We stole <a href="https://portal.liferay.dev/">Liferay Portal</a>, here it is.</h2>

                <div class="ldn">
                                <%= ldn %>
                </div>
</div>
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/liferay-util-get-url-ldn.png}
\caption{You can use the Liferay Util Get URL tag to scrape URLs.}
\end{figure}

Now you know how to use the
\texttt{\textless{}liferay-util:get-url\textgreater{}} tag to scrape
URLs.

\subsection{Related Topics}\label{related-topics-178}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-liferay-util-param}{Using
the Liferay Util Param Tag}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-liferay-util-include}{Using
the Liferay Util Include Tag}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-aui-taglibs-in-your-portlets}{Using
the AUI Taglib}

\section{Using Liferay Util HTML
Bottom}\label{using-liferay-util-html-bottom}

The HTML bottom tag is not a self-closing tag. Content placed between
the opening and closing of this tag is moved to the bottom of the
\texttt{\textless{}html\textgreater{}} tag. When something is passed
using this taglib, the
\href{https://github.com/liferay/liferay-portal/blob/master/portal-web/docroot/html/common/themes/bottom.jsp\#L53-L59}{bottom.jsp}
is passed markup and outputs in this JSP.

This tag also has an optional \texttt{outputKey} attribute. If several
portlets on the page include the same resource with this tag, you can
specify the same \texttt{outputKey} value for each tag so the resource
is only loaded once.

The example configuration below uses the
\texttt{\textless{}liferay-util:html-bottom\textgreater{}} tag to
include JavaScript (a common use case) provided by the portlet's bundle:

\begin{verbatim}
<liferay-util:html-bottom outputKey="htmlbottom">

    <script src="/o/my-liferay-util-portlet/js/my_custom_javascript.js" 
    type="text/javascript"></script>

</liferay-util:html-bottom>
\end{verbatim}

Now you know how to use the
\texttt{\textless{}liferay-util:html-bottom\textgreater{}} tag to
include additional resources in the bottom of the page's HTML tag.

\subsection{Related Topics}\label{related-topics-179}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-liferay-util-body-bottom}{Using
the Liferay Util HTML Body Bottom Tag}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-liferay-util-html-top}{Using
the Liferay Util HTML Top Tag}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-the-liferay-ui-taglib-in-your-portlets}{Using
the Liferay UI Taglib}

\section{Using Liferay Util HTML Top}\label{using-liferay-util-html-top}

The HTML top tag is not a self-closing tag. The content placed between
the opening and closing of this tag is moved to the
\texttt{\textless{}head\textgreater{}} tag. When something is passed
using this taglib, the
\href{https://github.com/liferay/liferay-portal/blob/master/portal-web/docroot/html/common/themes/top_head.jsp\#L147-L153}{top\_head.jsp}
is passed markup and outputs in this JSP.

This tag also has an optional \texttt{outputKey} attribute. If several
portlets on the page include the same resource with this tag, you can
specify the same \texttt{outputKey} value for each tag so the resource
is only loaded once.

The example configuration below uses the
\texttt{\textless{}liferay-util:html-top\textgreater{}} tag to include
additional CSS styles provided by the portlet's bundle:

\begin{verbatim}
<liferay-util:html-top outputKey="htmltop">
                <link data-senna-track="permanent" 
        href="/o/my-liferay-util-portlet/css/my-custom-styles.css" 
        rel="stylesheet" type="text/css" />
</liferay-util:html-top>
\end{verbatim}

Now you know how to use the
\texttt{\textless{}liferay-util:html-top\textgreater{}} tag to include
additional resources in the top of the page's HTML tag.

\subsection{Related Topics}\label{related-topics-180}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-liferay-util-html-bottom}{Using
the Liferay Util HTML Bottom Tag}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-liferay-util-body-top}{Using
the Liferay Util Body Top Tag}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-the-clay-taglib-in-your-portlets}{Using
the Clay Taglib}

\section{Using Liferay Util Include}\label{using-liferay-util-include}

The include tag lets you include other JSP files in your portlet's JSP,
theme, or web content. This can increase readability as well as provide
separation of concerns for JSP files.

The \texttt{page} attribute is required and specifies the path to the
JSP or JSPF to include. The \texttt{servletContext} refers to the
request context that the included JSP should use. Passing
\texttt{\textless{}\%=\ application\ \%\textgreater{}} to this attribute
lets the included JSP use the same \texttt{request} object as other
objects that might be set in the prior JSP.

Below is an example configuration for the
\texttt{\textless{}liferay-util:include\textgreater{}} tag:

\begin{verbatim}
<liferay-util:include 
  page="/relative/path/to/file.jsp" 
  servletContext="<%= application %>"
/>
\end{verbatim}

Now you know how to use the
\texttt{\textless{}liferay-util:include\textgreater{}} tag to include
other JSPs in your portlets, themes, and web content.

\subsection{Related Topics}\label{related-topics-181}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-liferay-util-param}{Using
the Liferay Util Param Tag}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-liferay-util-dynamic-include}{Using
the Liferay Util Dynamic Include Tag}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-liferay-frontend-taglibs-in-your-portlet}{Using
the Liferay Front-End Taglibs}

\section{Using Liferay Util Param}\label{using-liferay-util-param}

The param tag lets you set a parameter for an
\href{/docs/7-1/tutorials/-/knowledge_base/t/using-liferay-util-include}{included
JSP page}. This configuration requires two JSPs. JSP A, the main view of
the app, includes JSP B and sets its parameter value. This lets you
dynamically set content when you include the JSP.

For example, say you have your main functionality in
\texttt{my-app.jsp}, and you have additional functionality provided by
\texttt{more-content.jsp}. You could have the example configuration
shown below:

\texttt{more-content.jsp}:

\begin{verbatim}
<%@ page import="com.liferay.portal.kernel.util.ParamUtil" %>

<%
String answer = ParamUtil.getString(request, "answer");
%>

<div>
  <p>The answer to life, the universe and everything is <%= answer %>.</p>
</div>
\end{verbatim}

Then in \texttt{my-app.jsp}, you can include \texttt{more-content.jsp}
and set the value of the \texttt{answer} parameter:

\begin{verbatim}
<liferay-util:include page="/path/to/more-content.jsp" servletContext="<%= application %>">
  <liferay-util:param name="answer" value="42" />
</liferay-util:include>
\end{verbatim}

This results in the following output in \texttt{my-app.jsp}:

\begin{verbatim}
The answer to life, the universe and everything is 42.
\end{verbatim}

Now you know how to use the
\texttt{\textless{}liferay-util:param\textgreater{}} tag to set
parameters for included JSPs. You can use this approach to include
common reusable pieces of code in your apps.

\subsection{Related Topics}\label{related-topics-182}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-liferay-util-include}{Using
the Liferay Util Include Tag}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-liferay-util-body-top}{Using
the Liferay Util Body Top Tag}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-the-chart-taglib-in-your-portlets}{Using
the Chart Taglib}

\section{Using Liferay Util Whitespace
Remover}\label{using-liferay-util-whitespace-remover}

The whitespace remover tag removes line breaks and tabs from code blocks
included between the opening and closing of the tag. Below is an example
configuration for the
\texttt{\textless{}liferay-util:whitespace-remover\textgreater{}} tag:

with remover:

\begin{verbatim}
<liferay-util:whitespace-remover>
    <p>Here is some text with        tabs.</p>
</liferay-util:whitespace-remover>
\end{verbatim}

result:

\begin{verbatim}
Here is some text withtabs.
\end{verbatim}

Now you know how to use the
\texttt{\textless{}liferay-util:whitespace-remover\textgreater{}} tag to
ensure that your code formatting is consistent.

\subsection{Related Topics}\label{related-topics-183}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-liferay-util-param}{Using
the Liferay Util Param Tag}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-liferay-util-buffer}{Using
the Liferay Util Buffer Tag}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-aui-taglibs-in-your-portlets}{Using
the AUI Taglib}

\chapter{Using the Clay Taglib in Your
portlets}\label{using-the-clay-taglib-in-your-portlets}

The Liferay Clay tag library provides a set of tags for creating
\href{https://clayui.com/}{Clay} UI components in your app.

\noindent\hrulefill

\textbf{Note:} AUI taglibs are deprecated as of 7.0. We recommend that
you use Clay taglibs to avoid future compatibility issues.

\noindent\hrulefill

To use the Clay taglib in your apps, add the following declaration to
your JSP:

\begin{verbatim}
<%@ taglib prefix="clay" uri="http://liferay.com/tld/clay" %>
\end{verbatim}

The Liferay Clay taglib is also available via a macro for your
FreeMarker theme templates and web content templates. Follow this
syntax:

\begin{verbatim}
<@clay["tag-name"] attribute="string value" attribute=10 />
\end{verbatim}

Clay taglibs provide the following UI components for your apps:

\begin{itemize}
\tightlist
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/clay-alerts}{Alerts}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/clay-badges}{Badges}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/clay-buttons}{Buttons}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/clay-cards}{Cards}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/clay-dropdown-menus-and-action-menus}{Dropdown
  Menus and Action Menus}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/clay-form-elements}{Form
  Elements}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/clay-icons}{Icons}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/clay-labels-and-links}{Labels
  and links}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/clay-management-toolbar}{Management
  Toolbar}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/clay-navigation-bars}{Navigation
  Bars}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/clay-progress-bars}{Progress
  Bars}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/clay-stickers}{Stickers}
\end{itemize}

The tutorials in this section cover how to create these components with
the Clay taglibs. Each tutorial contains a set of clay component
examples along with a screenshot of the resulting UI.

\section{Clay Alerts}\label{clay-alerts}

Clay alerts come in two types: embedded and stripe. This tutorial covers
both types and provides several examples of each.

\subsection{Embedded Alerts}\label{embedded-alerts}

Embedded alerts are usually used inside forms. The element that contains
it determines an embedded alert's width. The close action is not
required for embedded alerts. The following embedded alerts can be
created with Clay taglibs:

Danger alert (embedded):

\begin{verbatim}
<clay:alert
    message="This is an error message."
    style="danger"
    title="Error"
/>
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/clay-taglib-alert-danger.png}
\caption{The danger alert notifies the user of an error or issue.}
\end{figure}

Success alert (embedded):

\begin{verbatim}
<clay:alert
    message="This is a success message."
    style="success"
    title="Success"
/>
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/clay-taglib-alert-success.png}
\caption{The success alert notifies the user when an action is
successful.}
\end{figure}

Info alert (embedded):

\begin{verbatim}
<clay:alert
    message="This is an info message."
    title="Info"
/>
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/clay-taglib-alert-info.png}
\caption{The info alert displays general information to the user.}
\end{figure}

Warning alert (embedded):

\begin{verbatim}
<clay:alert
    message="This is a warning message."
    style="warning"
    title="Warning"
/>
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/clay-taglib-alert-warning.png}
\caption{The warning alert displays a warning message to the user.}
\end{figure}

\subsection{Stripe Alerts}\label{stripe-alerts}

Stripe alerts are placed below the last navigation element (either the
header or the navigation bar), and they usually appear on \emph{Save}
action, communicating the status of the action once received from the
server. Unlike embedded alerts, stripe alerts require the close action.
A stripe alert is always the full width of the container and pushes all
the content below it. The following stripe alerts can be created with
Clay taglibs:

Danger alert (stripe):

\begin{verbatim}
<clay:stripe
    message="This is an error message."
    style="danger"
    title="Error"
/>
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/clay-taglib-alert-danger-stripe.png}
\caption{The danger striped alert notifies the user that an action has
failed.}
\end{figure}

Success alert (stripe):

\begin{verbatim}
<clay:stripe
    message="This is a success message."
    style="success"
    title="Success"
/>
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/clay-taglib-alert-success-stripe.png}
\caption{The success striped alert notifies the user that an action has
completed successfully.}
\end{figure}

Info alert (stripe):

\begin{verbatim}
<clay:stripe
    message="This is an info message."
    title="Info"
/>
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/clay-taglib-alert-info-stripe.png}
\caption{The info striped alert displays general information about an
action to the user.}
\end{figure}

Warning alert (stripe):

\begin{verbatim}
<clay:stripe
    message="This is a warning message."
    style="warning"
    title="Warning"
/>
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/clay-taglib-alert-warning-stripe.png}
\caption{The warning striped alert warns the user about an action.}
\end{figure}

Now you know how to alert users!

\subsection{Related Topics}\label{related-topics-184}

\href{/docs/7-1/tutorials/-/knowledge_base/t/clay-buttons}{Clay Buttons}

\href{/docs/7-1/tutorials/-/knowledge_base/t/clay-form-elements}{Clay
Form Elements}

\href{/docs/7-1/tutorials/-/knowledge_base/t/clay-labels-and-links}{Clay
Labels and Links}

\section{Clay Badges}\label{clay-badges}

Badges help highlight important information such as notifications or new
and unread messages. Badges have circular borders and are only used to
specify a number. This tutorial covers the different types of Clay
badges you can add to your app.

\subsection{Badge Types}\label{badge-types}

The following badge styles are available:

Primary badge:

\begin{verbatim}
<div class="col-md-1">
    <clay:badge label="8" />

    <div>Primary</div>
</div>
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/clay-taglib-badge-primary.png}
\caption{A primary badge is bright blue, commanding attention like the
primary button of a form.}
\end{figure}

Secondary badge:

\begin{verbatim}
<div class="col-md-1">
    <clay:badge label="87" style="secondary" />

    <div>Secondary</div>
</div>
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/clay-taglib-badge-secondary.png}
\caption{A secondary badge is light-grey and draws less focus than a
primary button.}
\end{figure}

Info badge:

\begin{verbatim}
<div class="col-md-1">
    <clay:badge label="91" style="info" />

    <div>Info</div>
</div>
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/clay-taglib-badge-info.png}
\caption{A info badge is dark blue and meant for numbers related to
general information.}
\end{figure}

Error badge:

\begin{verbatim}
<div class="col-md-1">
    <clay:badge label="130" style="danger" />

    <div>Error</div>
</div>
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/clay-taglib-badge-error.png}
\caption{An error badge displays numbers related to an error.}
\end{figure}

Success badge:

\begin{verbatim}
<div class="col-md-1">
    <clay:badge label="1111" style="success" />

    <div>Success</div>
</div>
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/clay-taglib-badge-success.png}
\caption{A success badge displays numbers related to a successful
action.}
\end{figure}

Warning badge:

\begin{verbatim}
<div class="col-md-1">
    <clay:badge label="21" style="warning" />

    <div>Warning</div>
</div>
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/clay-taglib-badge-warning.png}
\caption{A warning badge displays numbers related to warnings that
should be addressed.}
\end{figure}

Now you know how to use badges to keep track of values in your app.

\subsection{Related Topics}\label{related-topics-185}

\href{/docs/7-1/tutorials/-/knowledge_base/t/clay-labels-and-links}{Clay
Labels and Links}

\href{/docs/7-1/tutorials/-/knowledge_base/t/clay-cards}{Clay Cards}

\href{/docs/7-1/tutorials/-/knowledge_base/t/clay-stickers}{Clay
Stickers}

\section{Clay Buttons}\label{clay-buttons}

Buttons come in several types and variations. This tutorial covers the
different styles and variations of buttons you can create with the Clay
taglibs.

\subsection{Types}\label{types}

\textbf{Primary button:} Used for the most important actions. Two
primary buttons should not be together or near each other.

Primary button with label:

\begin{verbatim}
<clay:button label="Primary" />
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/clay-taglib-button-primary.png}
\caption{A primary button is bright blue, grabbing the user's
attention.}
\end{figure}

\textbf{Secondary button:} Used for secondary actions. There can be
multiple secondary buttons together or near each other.

\begin{verbatim}
<div class="col">
    <clay:button label="Secondary" style="secondary" />
</div>
<div class="col">
    <clay:button ariaLabel="Wiki" icon="wiki" style="secondary" />
</div>
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/clay-taglib-button-secondary.png}
\caption{A secondary button draws less attention than a primary button
and is meant for secondary actions.}
\end{figure}

\textbf{Borderless button:} Used in cases such as toolbars where the
secondary button would be too heavy for the design. This keeps the
design clean.

\begin{verbatim}
<div class="col">
    <clay:button label="Borderless" style="borderless" />
</div>
<div class="col">
    <clay:button ariaLabel="Page Template" icon="page-template" style="borderless" />
</div>
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/clay-taglib-button-borderless.png}
\caption{Borderless buttons remove the dark outline from the button.}
\end{figure}

\textbf{Link button:} Used for Cancel actions.

\begin{verbatim}
<div class="col">
    <clay:button label="Link" style="link" />
</div>
<div class="col">
    <clay:button ariaLabel="Add Role" icon="add-role" style="link" />
</div>
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/clay-taglib-button-link.png}
\caption{You can also turn buttons into links.}
\end{figure}

You can use labels or icons for your buttons. Below is an example of a
Primary button with an icon:

\begin{verbatim}
<clay:button ariaLabel="Workflow" icon="workflow" />
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/clay-taglib-button-primary-icon.png}
\caption{Buttons can also display icons.}
\end{figure}

You can disable a button by adding the \texttt{disabled} attribute:

\begin{verbatim}
<div class="col">
    <clay:button disabled="<%= true %>" label="Primary" />
</div>
<div class="col">
    <clay:button ariaLabel="Workflow" disabled="<%= true %>" icon="workflow" />
</div>
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/clay-taglib-button-primary-disabled.png}
\caption{Buttons can be disabled if you don't want the user to interact
with them.}
\end{figure}

\subsection{Variations}\label{variations}

Button with icon and text:

\begin{verbatim}
<clay:button icon="share" label="Share" />
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/clay-taglib-button-icon-text.png}
\caption{Buttons can display both icons and text.}
\end{figure}

Button with monospaced text:

\begin{verbatim}
<clay:button icon="indent-less" monospaced="<%= true %>" style="secondary" />
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/clay-taglib-button-monospaced.png}
\caption{Buttons can display monospaced text.}
\end{figure}

Block level button:

\begin{verbatim}
<clay:button block="<%= true %>" label="Button" />
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/clay-taglib-button-block-level.png}
\caption{Block level buttons span the entire width of the container.}
\end{figure}

Plus button:

\begin{verbatim}
<clay:button icon="plus" monospaced="<%= true %>" style="secondary" />
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/clay-taglib-button-plus.png}
\caption{: A plus button is used for add actions in an app.}
\end{figure}

Action button:

\begin{verbatim}
<clay:button icon="ellipsis-v" monospaced="<%= true %>" style="borderless" />
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/clay-taglib-button-action.png}
\caption{: An action button is used to display actions menus.}
\end{figure}

\subsection{Related Topics}\label{related-topics-186}

\href{/docs/7-1/tutorials/-/knowledge_base/t/clay-alerts}{Clay Alerts}

\href{/docs/7-1/tutorials/-/knowledge_base/t/clay-buttons}{Clay Buttons}

\href{/docs/7-1/tutorials/-/knowledge_base/t/clay-labels-and-links}{Clay
Labels and Links}

\section{Clay Cards}\label{clay-cards}

Cards visually represent data. Use them for images, document libraries,
user profiles and more. There are four main types of Cards:

\begin{itemize}
\tightlist
\item
  Image Cards
\item
  File Cards
\item
  User Cards
\item
  Horizontal Cards
\end{itemize}

Each of these types is covered in this tutorial.

\subsection{Image Cards}\label{image-cards}

Image Cards are used for image/document galleries.

Image Card:

\begin{verbatim}
<clay:image-card
    actionItems="<%= cardsDisplayContext.getDefaultActionItems() %>"
    href="#1"
    imageAlt="thumbnail"
    imageSrc="https://images.unsplash.com/photo-1506976773555-b3da30a63b57"
    subtitle="Author Action"
    title="Madrid"
/>
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/clay-taglib-image-card.png}
\caption{Image Cards display images and documents.}
\end{figure}

Image Card with icon:

\begin{verbatim}
<clay:image-card
    actionItems="<%= cardsDisplayContext.getDefaultActionItems() %>"
    icon="camera"
    subtitle="Author Action"
    title="<%= SVG_FILE_TITLE %>"
/>
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/clay-taglib-image-card-icon.png}
\caption{Image Cards can also display icons instead of images.}
\end{figure}

Image Card empty:

\begin{verbatim}
<clay:image-card 
  actionItems="<%= cardsDisplayContext.getDefaultActionItems() %>"
    subtitle="Author Action"
    title="<%= SVG_FILE_TITLE %>"
/>
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/clay-taglib-image-card-empty.png}
\caption{Cards can also display nothing.}
\end{figure}

Cards can also contain file types. Specify the file type with the
\texttt{filetype} attribute:

\begin{verbatim}
<clay:image-card
    actionItems="<%= cardsDisplayContext.getDefaultActionItems() %>"
    fileType="JPG"
    fileTypeStyle="danger"
    href="#1"
    imageAlt="thumbnail"
    imageSrc="https://images.unsplash.com/photo-1499310226026-b9d598980b90"
    subtitle="Author Action"
    title="California"
/>
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/clay-taglib-image-card-file-type.png}
\caption{Cards can also contain file types.}
\end{figure}

Include the \texttt{labels} attribute to add a label to a Card:

\begin{verbatim}
<clay:image-card
    actionItems="<%= cardsDisplayContext.getDefaultActionItems() %>"
    fileType="JPG"
    fileTypeStyle="danger"
    href="#1"
    imageAlt="thumbnail"
    imageSrc="https://images.unsplash.com/photo-1503703294279-c83bdf7b4bf4"
    labels="<%= cardsDisplayContext.getLabels() %>"
    subtitle="Author Action"
    title="Beetle"
/>
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/clay-taglib-image-card-icon-label.png}
\caption{You can include labels in Cards.}
\end{figure}

Include the \texttt{selectable} attribute to make cards selectable
(include a checkbox):

\begin{verbatim}
<clay:image-card
    actionItems="<%= cardsDisplayContext.getDefaultActionItems() %>"
    fileType="JPG"
    fileTypeStyle="danger"
    href="#1"
    imageAlt="thumbnail"
    imageSrc="https://images.unsplash.com/photo-1506020647804-b04ee956dc04"
    labels="<%= cardsDisplayContext.getLabels() %>"
    selectable="<%= true %>"
    selected="<%= true %>"
    subtitle="Author Action"
    title="Beetle"
/>
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/clay-taglib-image-card-icon-selectable.png}
\caption{Cards can be selectable.}
\end{figure}

\subsection{File Cards}\label{file-cards}

File Cards display an icon of the file's type. They represent file types
other than image files (i.e.~PDF, MP3, DOC, etc.).

\begin{verbatim}
<clay:file-card
    actionItems="<%= cardsDisplayContext.getDefaultActionItems() %>"
    fileType="MP3"
    fileTypeStyle="warning"
    labels="<%= cardsDisplayContext.getLabels() %>"
    labelStylesMap="<%= cardsDisplayContext.getLabelStylesMap() %>"
    selectable="<%= true %>"
    selected="<%= true %>"
    subtitle="Jimi Hendrix"
    title="<%= MP3_FILE_TITLE %>"
/>
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/clay-taglib-file-card.png}
\caption{File Cards display file type icons.}
\end{figure}

You can optionally use the \texttt{labelStylesMap} attribute to pass a
\texttt{HashMap} of multiple labels, as shown above.

The example below specifies a list \texttt{icon} instead of the default
file icon:

\begin{verbatim}
<clay:file-card
    actionItems="<%= cardsDisplayContext.getDefaultActionItems() %>"
    fileType="DOC"
    fileTypeStyle="info"
    icon="list"
    labels="<%= cardsDisplayContext.getLabels() %>"
    selectable="<%= true %>"
    selected="<%= true %>"
    subtitle="Paco de Lucia"
    title="<%= DOC_FILE_TITLE %>"
/>
\end{verbatim}

\noindent\hrulefill

\textbf{Note:} The full list of available Liferay icons can be found on
the
\href{https://claycss.com/docs/components/icons-lexicon.html\#clay-lexicon-icons}{Clay
CSS website}.

\noindent\hrulefill

\subsection{User Cards}\label{user-cards}

User Cards display user profile images or the initials of the user's
name or name+surname.

User Card with initials:

\begin{verbatim}
    <clay:user-card
        actionItems="<%= cardsDisplayContext.getDefaultActionItems() %>"
        initials="HS"
        name="User Name"
        subtitle="Latest Action"
        userColor="danger"
    />
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/clay-taglib-user-card-initial.png}
\caption{User Cards can display a user's initials.}
\end{figure}

User Card with profile image:

\begin{verbatim}
    <clay:user-card
        actionItems="<%= cardsDisplayContext.getDefaultActionItems() %>"
        disabled="<%= true %>"
        imageAlt="thumbnail"
        imageSrc="https://images.unsplash.com/photo-1502290822284-9538ef1f1291"
        name="User name"
        selectable="<%= true %>"
        selected="<%= true %>"
        subtitle="Latest Action"
    />
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/clay-taglib-user-card-profile-image.png}
\caption{A User Card can also display a profile image.}
\end{figure}

\subsection{Horizontal Cards}\label{horizontal-cards}

Horizontal Cards represent folders and can have the same amount of
information as other Cards. The key difference is that horizontal Cards
let you remove the image portion of the Card, since only the folder icon
is required.

\begin{verbatim}
<clay:horizontal-card
    actionItems="<%= cardsDisplayContext.getDefaultActionItems() %>"
    selectable="<%= true %>"
    selected="<%= true %>"
    title="ReallySuperInsanelyJustIncrediblyLongAndTotallyNotPossibleWordButWeAreReallyTryingToCoverAllOurBasesHereJustInCaseSomeoneIsNutsAsPerUsual"
/>
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/clay-taglib-horizontal-card.png}
\caption{: Horizontal Cards are good for displaying folders.}
\end{figure}

Now you know how to use Cards in your UI to display information in your
apps.

\subsection{Related Topics}\label{related-topics-187}

\href{/docs/7-1/tutorials/-/knowledge_base/t/clay-badges}{Clay Badges}

\href{/docs/7-1/tutorials/-/knowledge_base/t/clay-labels-and-links}{Clay
Labels and Links}

\href{/docs/7-1/tutorials/-/knowledge_base/t/clay-stickers}{Clay
Stickers}

\section{Clay Dropdown Menus and Action
Menus}\label{clay-dropdown-menus-and-action-menus}

You can add dropdown menus to your app via the
\texttt{clay:dropdown-menu} and \texttt{clay:actions-menu} taglibs. The
Clay taglibs provide several menu variations for you to choose. Both
taglibs with several examples are shown below.

\subsection{Dropdown Menus}\label{dropdown-menus}

Basic dropdown menu:

\begin{verbatim}
<clay:dropdown-menu
    items="<%= dropdownsDisplayContext.getDefaultDropdownItems() %>"
    label="Default"
/>
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/clay-taglib-dropdown-basic.png}
\caption{Clay taglibs provide everything you need to add dropdown menus
to your app.}
\end{figure}

The dropdown menu's items are defined in its Java
class--\texttt{dropdownDisplayContext} in this case. Menu items are
\texttt{NavigationItem} objects. You can disable menu items with the
\texttt{setDisabled(true)} method and make a menu item active with the
\texttt{setActive(true)} method. The \texttt{href} attribute is set with
the \texttt{setHref()} method, and labels are defined with the
\texttt{setLabel()} method. Here's an example implementation of the
\texttt{dropdownDisplayContext} class:

\begin{verbatim}
    if (_defaultDropdownItems != null) {
      return _defaultDropdownItems;
    }

    _defaultDropdownItems = new ArrayList<>();

    for (int i = 0; i < 4; i++) {
      NavigationItem navigationItem = new NavigationItem();

      if (i == 1) {
        navigationItem.setDisabled(true);
      }
      else if (i == 2) {
        navigationItem.setActive(true);
      }

      navigationItem.setHref("#" + i);
      navigationItem.setLabel("Option " + i);

      _defaultDropdownItems.add(navigationItem);
    }

    return _defaultDropdownItems;
    }
\end{verbatim}

You can organize menu items into groups by setting the
\texttt{NavigationItem}'s type to \texttt{TYPE\_GROUP} and nesting the
items in separate \texttt{ArrayList}s. You can add a horizontal
separator to separate the groups visually with the
\texttt{setSeparator(true)} method. Below is a code snippet from the
\texttt{dropdownsDisplayContext} class:

\begin{verbatim}
group1NavigationItem.setSeparator(true);
group1NavigationItem.setType(NavigationItem.TYPE_GROUP);
\end{verbatim}

Corresponding taglib:

\begin{verbatim}
<clay:dropdown-menu
    items="<%= dropdownsDisplayContext.getGroupDropdownItems() %>"
    label="Dividers"
/>
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/clay-taglib-dropdown-group.png}
\caption{You can organize dropdown menu items into groups.}
\end{figure}

You can also add inputs to dropdown menus. To add an input to a dropdown
menu, set the input's type with the \texttt{setType()} method
(e.g.~\texttt{NavigationItem.TYPE\_CHECKBOX}), its name with the
\texttt{setInputName()} method, and its value with the
\texttt{setInputValue()} method. Here's an example implementation:

\begin{verbatim}
navigationItem.setInputName("checkbox" + i);
navigationItem.setInputValue("checkboxValue" + i);
navigationItem.setLabel("Group 1 - Option " + i);
navigationItem.setType(NavigationItem.TYPE_CHECKBOX);
\end{verbatim}

Corresponding taglib:

\begin{verbatim}
<clay:dropdown-menu
    buttonLabel="Done"
    items="<%= dropdownsDisplayContext.getInputDropdownItems() %>"
    label="Inputs"
    searchable="<%= true %>"
/>
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/clay-taglib-dropdown-input.png}
\caption{Inputs can be included in dropdown menus.}
\end{figure}

Menu items can also contain icons. To add an icon to a menu item, use
the \texttt{setIcon()} method. Below is an example:

\begin{verbatim}
navigationItem.setIcon("check-circle-full")
\end{verbatim}

Corresponding taglib:

\begin{verbatim}
<clay:dropdown-menu
    items="<%= dropdownsDisplayContext.getIconDropdownItems() %>"
    itemsIconAlignment="left"
    label="Icons"
/>
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/clay-taglib-dropdown-icons.png}
\caption{Icons can be included in dropdown menus.}
\end{figure}

\subsection{Actions Menus}\label{actions-menus}

Basic actions menu:

\begin{verbatim}
<clay:dropdown-actions
    items="<%= dropdownsDisplayContext.getDefaultDropdownItems() %>"
/>
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/clay-taglib-dropdown-actions.png}
\caption{You can also create Actions menus with Clay taglibs.}
\end{figure}

An actions menu can also display help text to the user:

\begin{verbatim}
<clay:dropdown-actions
    buttonLabel="More"
    buttonStyle="secondary"
    caption="Showing 4 of 32 Options"
    helpText="You can customize this menu or see all you have by pressing \"more\"."
    items="<%= dropdownsDisplayContext.getDefaultDropdownItems() %>"
/>
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/clay-taglib-dropdown-actions-help.png}
\caption{You can provide help text in Actions menus.}
\end{figure}

Clay taglibs make it easy to add dropdown menus and action menus to your
apps.

\subsection{Related Topics}\label{related-topics-188}

\href{/docs/7-1/tutorials/-/knowledge_base/t/clay-form-elements}{Clay
Form Elements}

\href{/docs/7-1/tutorials/-/knowledge_base/t/clay-navigation-bars}{Clay
Navigation Bars}

\href{/docs/7-1/tutorials/-/knowledge_base/t/clay-progress-bars}{Clay
Progress Bars}

\section{Clay Form Elements}\label{clay-form-elements}

The Liferay Clay tag library provides several tags for creating form
elements. An example of each tag is shown below.

\subsection{Checkbox}\label{checkbox}

Checkboxes give the user a true or false input.

\begin{verbatim}
    <clay:checkbox 
            checked="<%= true %>" 
            hideLabel="<%= true %>" 
            label="My Input" 
            name="name" 
    />
\end{verbatim}

Attributes:

\textbf{checked:} Whether the checkbox is checked

\textbf{disabled:} Whether the checkbox is enabled

\textbf{hideLabel:} Whether to display the checkbox label

\textbf{indeterminate:} Checkbox variable for multiple selection

\textbf{label:} The checkbox's label

\textbf{name:} The checkbox's name

\begin{figure}
\centering
\includegraphics{./images/clay-taglib-form-checkbox.png}
\caption{Clay taglibs provide checkboxes.}
\end{figure}

\subsection{Radio}\label{radio}

A radio button lets the user select one choice from a set of options in
a form.

\begin{verbatim}
<clay:radio 
            checked="<%= true %>" 
            hideLabel="<%= true %>" 
            label="My Input" 
            name="name" 
    />
\end{verbatim}

Attributes:

\textbf{checked:} Whether the radio button is checked

\textbf{hideLabel:} Whether to display the radio button label

\textbf{disabled:} Whether the radio button is enabled

\textbf{label:} The radio button's label

\textbf{name:} The radio button's name

\begin{figure}
\centering
\includegraphics{./images/clay-taglib-form-radio-button.png}
\caption{Clay taglibs provide radio buttons.}
\end{figure}

\subsection{Selector}\label{selector}

A selector gives the user a select box with a set of options to choose
from.

The Java scriplet below creates eight dummy options for the selector:

\begin{verbatim}
<%
List<Map<String, Object>> options = new ArrayList<>();

for (int i = 0; i < 8; i++) {
    Map<String, Object> option = new HashMap<>();

    option.put("label", "Sample " + i);
    option.put("value", i);

    options.add(option);
}
%>

<clay:select 
            label="Regular Select Element" 
            name="name" 
            options="<%= options %>" 
    />
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/clay-taglib-form-selector.png}
\caption{Clay taglibs provide select boxes.}
\end{figure}

If you want let users select multiple options at once, set the
\texttt{multiple} attribute to \texttt{true}:

\begin{verbatim}
<clay:select 
            label="Multiple Select Element" 
            multiple="<%= true %>" 
            name="name" 
            options="<%= options %>" 
    />
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/clay-taglib-form-selector-multiple.png}
\caption{You can let users select multiple options from the select
menu.}
\end{figure}

Attributes:

\textbf{disabled:} Whether the selector is enabled \textbf{label:} The
selector's label \textbf{multiple:} Whether multiple options can be
selected \textbf{name:} The selector's name

Now you know how to use Clay taglibs to add common form elements to your
app!

\subsection{Related Topics}\label{related-topics-189}

\href{/docs/7-1/tutorials/-/knowledge_base/t/clay-buttons}{Clay Buttons}

\href{/docs/7-1/tutorials/-/knowledge_base/t/clay-icons}{Clay Icons}

\href{/docs/7-1/tutorials/-/knowledge_base/t/clay-labels-and-links}{Clay
Labels and Links}

\section{Clay Icons}\label{clay-icons}

The Liferay Clay taglibs provide several icons that you can use in your
apps. Use the \texttt{clay:icon} tag and specify the icon with the
\texttt{symbol} attribute:

\begin{verbatim}
<clay:icon symbol="folder" />
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/clay-taglib-icon-folder.png}
\caption{You can include icons in your app with the Clay taglib.}
\end{figure}

The full list of icons is shown below:

\begin{figure}
\centering
\includegraphics{./images/clay-taglib-icon-library.png}
\caption{The Clay taglib gives you access to several Liferay DXP icons.}
\end{figure}

The Liferay Clay taglibs also provide a set of language flag icons that
you can use in your app. The full list of language flags is shown below:

\begin{figure}
\centering
\includegraphics{./images/clay-taglib-icon-language-flags.png}
\caption{You can include language flags in your apps.}
\end{figure}

\subsection{Related Topics}\label{related-topics-190}

\href{/docs/7-1/tutorials/-/knowledge_base/t/clay-badges}{Clay Badges}

\href{/docs/7-1/tutorials/-/knowledge_base/t/clay-stickers}{Clay
Stickers}

\href{https://v2.clayui.com/docs/components/icons.html}{Clay Icon
Component}

\section{Clay Labels and Links}\label{clay-labels-and-links}

Liferay Clay taglibs provide tags for creating labels and links in your
app. This tutorial shows how to add both of these UI elements to your
apps.

\subsection{Labels}\label{labels}

The Liferay Clay taglibs provide a few different labels for your app.
Use the \texttt{clay:label} tag to add a label to your app. You can
create color-coded labels, removable labels, and labels that contain
links. The sections below demonstrate all of these options.

\subsubsection{Color-coded Labels}\label{color-coded-labels}

The Liferay Clay labels come in four different colors: dark-blue for
info, light-gray for status, orange for pending, red for rejected, and
green for approved.

Info labels are dark-blue, and since they stand out a bit more than
status labels, they are best for conveying general information. To use
an info label, set the \texttt{style} attribute to \texttt{info}:

\begin{verbatim}
<clay:label label="Label text" style="info" />
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/clay-taglib-label-info.png}
\caption{Info labels convey general information.}
\end{figure}

Status labels are light-gray, and due to their neutral color, they are
best for conveying basic information. Status labels are the default
label and therefore require no \texttt{style} attribute:

\begin{verbatim}
    <clay:label label="Status" />
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/clay-taglib-label-status.png}
\caption{Status labels are the least flashy and best for displaying
basic information.}
\end{figure}

Warning labels are orange, and due to their color, they are best for
conveying a warning message. To use a warning label, set the
\texttt{style} attribute to \texttt{warning}:

\begin{verbatim}
    <clay:label label="Pending" style="warning" />
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/clay-taglib-label-warning.png}
\caption{Warning labels notify the user of issues, but nothing app
breaking.}
\end{figure}

Danger labels are red and indicate that something is wrong or has
failed. To use a danger label, set the \texttt{style} attribute to
\texttt{danger}:

\begin{verbatim}
    <clay:label label="Rejected" style="danger" />
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/clay-taglib-label-danger.png}
\caption{Danger labels convey a sense of urgency that must be
addressed.}
\end{figure}

Success labels are green and indicate that something has completed
successfully. To use a success label, set the \texttt{style} attribute
to \texttt{success}:

\begin{verbatim}
<clay:label label="Approved" style="success" />
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/clay-taglib-label-success.png}
\caption{Success labels indicate a successful action.}
\end{figure}

Labels can also be bigger. Set the \texttt{size} attribute to
\texttt{lg} to display large labels:

\begin{verbatim}
<clay:label label="Approved" size="lg" style="success" />
\end{verbatim}

\subsubsection{Removable Labels}\label{removable-labels}

If you want to let a user close a label (e.g.~a temporary notification),
you can make the label removable by setting the \texttt{closeable}
attribute to \texttt{true}.

\begin{verbatim}
    <clay:label closeable="<%= true %>" label="Normal Label" />
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/clay-taglib-label-removable.png}
\caption{Labels can be removable.}
\end{figure}

\subsubsection{Labels with Links}\label{labels-with-links}

You can make a label a link by adding the \texttt{href} attribute to it
just as you would an anchor tag:

\begin{verbatim}
<clay:label href="#" label="Label Text" />
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/clay-taglib-label-link.png}
\caption{Labels can also be links.}
\end{figure}

\subsection{Links}\label{links}

You can add traditional hyperlinks to your app with the
\texttt{\textless{}clay:link\textgreater{}} tag:

\begin{verbatim}
<clay:link href="#" label="link text" />
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/clay-taglib-link.png}
\caption{Clay taglibs also provide link elements.}
\end{figure}

Now you know how to add links and labels to your apps!

\subsection{Related Topics}\label{related-topics-191}

\href{/docs/7-1/tutorials/-/knowledge_base/t/clay-badges}{Clay Badges}

\href{/docs/7-1/tutorials/-/knowledge_base/t/clay-cards}{Clay Cards}

\href{/docs/7-1/tutorials/-/knowledge_base/t/clay-form-elements}{Clay
Form Elements}

\section{Clay Management Toolbar}\label{clay-management-toolbar}

The Management Toolbar gives administrators control over search
container results in their apps. It lets you filter, sort, and choose a
view type for search results, so you can quickly identify the document,
web content, asset entry, or whatever you're looking for. The Management
Toolbar is fully customizable, so you can implement all the controls or
just the ones your app requires.

\begin{figure}
\centering
\includegraphics{./images/clay-taglib-management-toolbar.png}
\caption{The Management ToolBar lets the user customize how the app
displays content.}
\end{figure}

To create a management toolbar, use the \texttt{clay:management-toolbar}
taglib. The toolbar contains a few key sections. Each section is grouped
and configured using different attributes. These attributes are
described in more detail below.

\subsection{Using a Display Context to Configure the Management
Toolbar}\label{using-a-display-context-to-configure-the-management-toolbar}

If you're using a Display Context---a separate class to configure your
display options for your management toolbar---to define all or some of
the configuration options for the toolbar, you can specify the Display
Context with the \texttt{displayContext} attribute. An example is shown
below:

\begin{verbatim}
<clay:management-toolbar 
    displayContext="<%= viewUADEntitiesManagementToolbarDisplayContext %>" 
/>
\end{verbatim}

You can see an example use case of a Display Context in the
\href{/docs/7-1/tutorials/-/knowledge_base/t/filtering-and-sorting-items-with-the-management-toolbar}{Filtering
and Sorting Items with the Management Toolbar tutorial}. A Display
Context is not required for a management toolbar's configuration. You
can provide as much or as little of the configuration options for your
management toolbar through the Display Context as you like.

\subsection{Checkbox and Actions}\label{checkbox-and-actions}

The \texttt{actionItems}, \texttt{searchContainerId},
\texttt{selectable}, and \texttt{totalItems} attributes let you include
a checkbox in the toolbar to select all search container results and run
bulk actions on them. Actions and total items display when an individual
result is checked, or when the master checkbox is checked in the
toolbar.

\texttt{actionItems}: The list of dropdown items to display when a
result is checked or the master checkbox in the Management Toolbar is
checked. You can select multiple results between pages. The Management
Toolbar keeps track of the number of selected results for you.

\texttt{searchContainerId}: The ID of the search container connected to
the Management Toolbar

\texttt{selectable}: Whether to include a checkbox in the Management
Toolbar

\texttt{totalItems}: The total number of items across pagination. This
number displays when one or multiple items are selected.

An example configuration is shown below:

\begin{verbatim}
actionItems="<%=
    new JSPDropdownItemList(pageContext) {
        {
          add(
            dropdownItem -> {
              dropdownItem.setHref("#edit");
              dropdownItem.setLabel("Edit");
            });
  
          add(
            dropdownItem -> {
              dropdownItem.setHref("#download");
              dropdownItem.setIcon("download");
              dropdownItem.setLabel("Download");
              dropdownItem.setQuickAction(true);
            });
  
          add(
            dropdownItem -> {
              dropdownItem.setHref("#delete");
              dropdownItem.setLabel("Delete");
              dropdownItem.setIcon("trash");
              dropdownItem.setQuickAction(true);
            });
        }
    }
%>"
\end{verbatim}

Action items are listed in the Actions menu, along with the number of
items selected across pagination.

\begin{figure}
\centering
\includegraphics{./images/clay-taglib-management-toolbar-actions.png}
\caption{Actions are also listed in the Management Toolbar's dropdown
menu when an item, multiple items, or the master checkbox is checked.}
\end{figure}

If an action has an icon specified, such as the Delete and Download
actions in the example above, the icon is displayed next to the action
menu as well.

\begin{figure}
\centering
\includegraphics{./images/clay-taglib-management-toolbar-selectable.png}
\caption{The Management Toolbar keeps track of the results selected and
displays the actions to execute on them.}
\end{figure}

\subsection{Filtering and Sorting Search
Results}\label{filtering-and-sorting-search-results}

The \texttt{filterItems}, \texttt{sortingOrder}, and \texttt{sortingURL}
attributes let you filter and sort search container results. Filtering
and sorting are grouped together in one convenient dropdown menu.

\texttt{filterItems}: Sets the search container's filtering options.
This filter should be included in all control panel applications.
Filtering options can include sort criteria, sort ordering, and more.

\texttt{sortingOrder}: The current sorting order: ascending or
descending.

\texttt{sortingURL}: The URL to change the sorting order

The example below adds two filter options and two sorting options:

\begin{verbatim}
filterItems="<%=
    new DropdownItemList(_request) {
        {
            addGroup(
                dropdownGroupItem -> {
                    dropdownGroupItem.setDropdownItemList(
                        new DropdownItemList(_request) {
                            {
                                add(
                                    dropdownItem -> {
                                        dropdownItem.setHref("#1");
                                        dropdownItem.setLabel("Filter 1");
                                    });

                                add(
                                    dropdownItem -> {
                                        dropdownItem.setHref("#2");
                                        dropdownItem.setLabel("Filter 2");
                                    });
                            }
                        }
                    );
                    dropdownGroupItem.setLabel("Filter By");
                });
                
            addGroup(
                dropdownGroupItem -> {
                    dropdownGroupItem.setDropdownItemList(
                        new DropdownItemList(_request) {
                            {
                                add(
                                    dropdownItem -> {
                                        dropdownItem.setHref("#3");
                                        dropdownItem.setLabel("Order 1");
                                    });

                                add(
                                    dropdownItem -> {
                                        dropdownItem.setHref("#4");
                                        dropdownItem.setLabel("Order 2");
                                    });
                            }
                        }
                    );
                    dropdownGroupItem.setLabel("Order By");
                });
        }
    }
%>"
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/clay-taglib-management-toolbar-filter-and-sort.png}
\caption{You can also sort and filter search container results.}
\end{figure}

\subsection{Search Form}\label{search-form}

The \texttt{clearResultsURL}, \texttt{searchActionURL},
\texttt{searchFormName}, \texttt{searchInputName}, and
\texttt{searchValue} attributes let you configure the search form. The
main portion of the Management Toolbar is reserved for the search form.

\texttt{clearResultsURL}: The URL to reset the search

\texttt{searchActionURL}: The action URL to send the search form

\texttt{searchFormName}: The search form's name

\texttt{searchInputName}: The search input's name

\texttt{searchValue}: The search input's value

An example configuration is shown below:

\begin{verbatim}
<clay:management-toolbar
    clearResultsURL="<%= searchURL %>"
    disabled="<%= isDisabled %>"
    namespace="<%= renderResponse.getNamespace() %>"
    searchActionURL="<%= searchURL %>"
    searchFormName="fm"
    searchInputName="<%= DisplayTerms.KEYWORDS %>"
    searchValue="<%= ParamUtil.getString(request, searchInputName) %>"
    selectable="<%= false %>"
    totalItems="<%= totalItems %>"
/>
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/clay-taglib-management-toolbar-search-form.png}
\caption{The search form comprises most of the Management Toolbar,
letting users search through the search container results.}
\end{figure}

\subsection{Info Panel}\label{info-panel}

The \texttt{infoPanelId} and \texttt{showInfoButton} attributes let you
add a retractable sidebar panel that displays additional information
related to a search container result.

\texttt{infoPanelId}: The ID of the info panel to toggle

\texttt{showInfoButton}: Whether to show the info button

In the example configuration below, the \texttt{showInfoButton}
attribute is provided in the Display Context---specified with the
\texttt{displayContext} attribute---and the \texttt{infoPanelId} is
explicitly set in the JSP:

\begin{verbatim}
<clay:management-toolbar
    displayContext="<%= journalDisplayContext %>"
    infoPanelId="infoPanelId"
    namespace="<%= renderResponse.getNamespace() %>"
    searchContainerId="<=% searchContainerId %>"
/>
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/clay-taglib-management-toolbar-info-panel.png}
\caption{The info panel keeps your UI clutter-free.}
\end{figure}

\subsection{View Types}\label{view-types}

The \texttt{viewTypes} attribute specifies the display options for the
search container results. There are three display options to choose
from:

\textbf{Cards:} Displays search result columns on a horizontal or
vertical card.

\begin{figure}
\centering
\includegraphics{./images/clay-taglib-management-toolbar-view-type-card.png}
\caption{The Management Toolbar's icon display view gives a quick
summary of the content's description and status.}
\end{figure}

\textbf{List:} Displays a detailed description along with summarized
details for the search result columns.

\begin{figure}
\centering
\includegraphics{./images/clay-taglib-management-toolbar-view-type-list.png}
\caption{The Management Toolbar's List view type gives the content's
full description.}
\end{figure}

\textbf{Table:} The default view. Lists the search result columns from
left to right.

\begin{figure}
\centering
\includegraphics{./images/clay-taglib-management-toolbar-view-type-table.png}
\caption{The Management Toolbar's Table view type list the content's
information in individual columns.}
\end{figure}

An example configuration is shown below:

\begin{verbatim}
viewTypes="<%=
    new JSPViewTypeItemList(pageContext, baseURL, selectedType) {
        {
            addCardViewTypeItem(
                viewTypeItem -> {
                    viewTypeItem.setActive(true);
                    viewTypeItem.setLabel("Card");
                });

            addListViewTypeItem(
                viewTypeItem -> {
                    viewTypeItem.setLabel("List");
                });

            addTableViewTypeItem(
                viewTypeItem -> {
                    viewTypeItem.setLabel("Table");
                });
        }
    }
%>"
\end{verbatim}

While the example above shows how to configure the view types in the
JSP, you must also
\href{/docs/7-1/tutorials/-/knowledge_base/t/implementing-the-view-types}{specify
when to use each view type}.

\begin{figure}
\centering
\includegraphics{./images/clay-taglib-management-toolbar-view-types.png}
\caption{: The Management Toolbar offers three view type options.}
\end{figure}

\subsection{Creation Menu}\label{creation-menu}

The \texttt{creationMenu} attribute creates an add menu button for one
or multiple items. It's used for creating new entities (e.g.~a new blog
entry).

Use the \texttt{addPrimaryDropdownItem()} method to add the top level
items to the dropdown menu, or use the
\texttt{addFavoriteDropdownItem()} method to add secondary items to the
dropdown menu.

The example configuration below adds two primary creation menu items and
two secondary creation menu items:

\begin{verbatim}
creationMenu="<%= 
    new JSPCreationMenu(pageContext) {
            {
                addPrimaryDropdownItem(
                    dropdownItem -> {
                        dropdownItem.setHref("#1");
                        dropdownItem.setLabel("Sample 1");
                    });
  
                addPrimaryDropdownItem(
                    dropdownItem -> {
                        dropdownItem.setHref("#2");
                        dropdownItem.setLabel("Sample 2");
                    });
  
                addFavoriteDropdownItem(
                    dropdownItem -> {
                        dropdownItem.setHref("#3");
                        dropdownItem.setLabel("Favorite 1");
                    });
  
                addFavoriteDropdownItem(
                    dropdownItem -> {
                        dropdownItem.setHref("#4");
                        dropdownItem.setLabel("Other item");
                    });
            }
    };
%>"
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/clay-taglib-management-toolbar-creation-menu.png}
\caption{: The Management Toolbar lets you optionally add a Creation
Menu for creating new entities.}
\end{figure}

\subsection{Related Topics}\label{related-topics-192}

\href{/docs/7-1/tutorials/-/knowledge_base/t/clay-dropdown-menus-and-action-menus}{Clay
Dropdown Menus and Action Menus}

\href{/docs/7-1/tutorials/-/knowledge_base/t/clay-icons}{Clay Icons}

\href{/docs/7-1/tutorials/-/knowledge_base/t/clay-navigation-bars}{Clay
Navigation Bars}

\section{Clay Navigation Bars}\label{clay-navigation-bars}

Similar to dropdown menus, navigation bars display a list of navigation
items. The key difference is navigation bars are displayed in a
horizontal bar with all navigation items visible at all times. The
navigation bar also indicates the active navigation item with an
underline. Navigation bars come in two styles: white background with
dark-grey text (default) and dark-grey background with white text
(inverted).

Default navigation bar:

\begin{verbatim}
<clay:navigation-bar 
    navigationItems="<%= navigationBarsDisplayContext.getNavigationItems() %>" 
/>
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/clay-taglib-nav-bars.png}
\caption{You can include navigation bars in your apps.}
\end{figure}

Inverted navigation bar (set \texttt{inverted} attribute to
\texttt{true}):

\begin{verbatim}
<clay:navigation-bar 
    inverted="<%= true %>" 
    navigationItems="<%= navigationBarsDisplayContext.getNavigationItems() %>" 
/>
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/clay-taglib-nav-bars-inverted.png}
\caption{Navigation bars can be inverted if you prefer.}
\end{figure}

\subsection{Related Topics}\label{related-topics-193}

\href{/docs/7-1/tutorials/-/knowledge_base/t/clay-dropdown-menus-and-action-menus}{Clay
Dropdown Menus and Action Menus}

\href{/docs/7-1/tutorials/-/knowledge_base/t/clay-form-elements}{Clay
Form Elements}

\href{/docs/7-1/tutorials/-/knowledge_base/t/clay-progress-bars}{Clay
Progress Bars}

\section{Clay Progress Bars}\label{clay-progress-bars}

You can add progress bars to your app with the \texttt{clay:progressbar}
tag. These indicate the completion percentage of a task and come in
three status styles: \texttt{default} (blue), \texttt{warning} (red),
and \texttt{complete} (green with checkmark). You can provide a minimum
value (\texttt{minValue}) and a maximum value (\texttt{maxValue}).

Default progress bar:

\begin{verbatim}
<clay:progressbar 
    maxValue="<%= 100 %>" 
    minValue="<%= 0 %>" 
    value="<%= 30 %>" 
/>
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/clay-taglib-progress-bar.png}
\caption{You can include progress bars in your apps.}
\end{figure}

Warning progress bar:

\begin{verbatim}
<clay:progressbar 
    maxValue="<%= 100 %>" 
    minValue="<%= 0 %>" 
    status="warning" 
    value="<%= 70 %>" 
/>
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/clay-taglib-progress-bar-warning.png}
\caption{warning progress bars indicate that the progress has not
completed due to an error.}
\end{figure}

Complete progress bar:

\begin{verbatim}
<clay:progressbar 
    status="complete" 
/>
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/clay-taglib-progress-bar-complete.png}
\caption{The complete progress bar indicates the progress is complete.}
\end{figure}

Clay taglibs make it easy to track progress in your apps.

\subsection{Related Topics}\label{related-topics-194}

\href{/docs/7-1/tutorials/-/knowledge_base/t/clay-dropdown-menus-and-action-menus}{Clay
Dropdown Menus and Action Menus}

\href{/docs/7-1/tutorials/-/knowledge_base/t/clay-icons}{Clay Icons}

\href{/docs/7-1/tutorials/-/knowledge_base/t/clay-navigation-bars}{Clay
Navigation Bars}

\section{Clay Stickers}\label{clay-stickers}

Whereas badges display numbers and labels display short information,
stickers are small visual indicators of the content (usually the content
type). They can include a small label or a Liferay icon, and they come
in two shapes: circle and square.

Square sticker with label:

\begin{verbatim}
<clay:sticker label="JPG" />
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/clay-taglib-sticker-square-label.png}
\caption{You can include stickers in your apps.}
\end{figure}

Square sticker with icon:

\begin{verbatim}
<clay:sticker icon="picture" />
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/clay-taglib-sticker-square-icon.png}
\caption{Stickers can include icons.}
\end{figure}

Circle sticker:

\begin{verbatim}
<clay:sticker label="JPG" shape="circle" />
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/clay-taglib-sticker-round.png}
\caption{You can also have circle stickers.}
\end{figure}

Stickers can be positioned in any corner of a div. Indicate their
position with the \texttt{position} attribute: \texttt{top-left},
\texttt{bottom-left}, \texttt{top-right}, or \texttt{bottom-right}:

\begin{verbatim}
<div class="aspect-ratio">

    <img class="aspect-ratio-item-fluid" src="https://claycss.com](./images/thumbnail_hot_air_ballon.jpg" />

    <clay:sticker label="PDF" position="top-left" style="danger" />
</div>
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/clay-taglib-sticker-position.png}
\caption{You can specify the position of the sticker within a
container.}
\end{figure}

Now you know how to use Clay stickers in your app!

\subsection{Related Topics}\label{related-topics-195}

\href{/docs/7-1/tutorials/-/knowledge_base/t/clay-badges}{Clay Badges}

\href{/docs/7-1/tutorials/-/knowledge_base/t/clay-cards}{Clay Cards}

\href{/docs/7-1/tutorials/-/knowledge_base/t/clay-icons}{Clay Icons}

\chapter{Using the Chart Taglib in Your
Portlets}\label{using-the-chart-taglib-in-your-portlets}

Lines, splines, bars, pies and more, the Chart tag Library provides
everything you need to model data. Each taglib gives you access to the
corresponding
\href{https://github.com/liferay/clay/tree/2.x-stable/packages/clay-charts/src}{Clay
component}. These components contain the default configuration for the
UI.

To use the Chart taglib in your apps, add the following declaration to
your JSP:

\begin{verbatim}
<%@ taglib prefix="chart" uri="http://liferay.com/tld/chart" %>
\end{verbatim}

This section of tutorials covers the types of charts you can create with
the Chart taglibs. Each tutorial contains a set of chart examples along
with sample Java data and a figure displaying the rendered results.

\begin{figure}
\centering
\includegraphics{./images/chart-taglib-sample-portlet.png}
\caption{You can create many different types of charts with the chart
taglibs.}
\end{figure}

\section{Bar Charts}\label{bar-charts}

Bar charts contain multiple sets of data. A bar chart models the data in
bars. Each data series (created with the \texttt{addColumns()} method)
is defined with a new instance of the
\href{https://docs.liferay.com/portal/7.1-latest/apps/frontend-taglib-1.0.1/javadocs/com/liferay/frontend/taglib/chart/model/MultiValueColumn.html}{\texttt{MultiValueColumn}
object}, which takes an ID and a set of values. This tutorial shows how
to configure your portlet to use bar charts.

Follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Import the chart taglib along with the \texttt{BarChartConfig} and
  \texttt{MultiValueColumn} classes into your bundle's \texttt{init.jsp}
  file:

\begin{verbatim}
<%@ taglib prefix="chart" uri="http://liferay.com/tld/chart" %>
<%@ page import="com.liferay.frontend.taglib.chart.model.point.bar.BarChartConfig" %>
<%@ page import="com.liferay.frontend.taglib.chart.model.MultiValueColumn" %>
\end{verbatim}
\item
  Add the following Java scriptlet to the top of your \texttt{view.jsp}:

\begin{verbatim}
<%
BarChartConfig _barChartConfig = new BarChartConfig();

_barChartConfig.addColumns(
    new MultiValueColumn("data1", 100, 20, 30),
    new MultiValueColumn("data2", 20, 70, 100)
);

%>
\end{verbatim}
\item
  Add the \texttt{\textless{}chart\textgreater{}} taglib to the
  \texttt{view.jsp}, passing the \texttt{\_barChartConfig} as the
  \texttt{config} attribute's value:

\begin{verbatim}
<chart:bar
  config="<%= _barChartConfig %>"
/>
\end{verbatim}
\end{enumerate}

\begin{figure}
\centering
\includegraphics{./images/chart-taglib-bar.png}
\caption{A bar chart models the data in bars.}
\end{figure}

\subsection{Related Topics}\label{related-topics-196}

\href{/docs/7-1/tutorials/-/knowledge_base/t/line-charts}{Line Charts}

\href{/docs/7-1/tutorials/-/knowledge_base/t/donut-charts}{Donut Charts}

\href{/docs/7-1/tutorials/-/knowledge_base/t/combination-charts}{Combination
Charts}

\section{Line Charts}\label{line-charts}

Line charts contain multiple sets of data. A Line chart displays the
data linearly. Each data series (created with the \texttt{addColumns()}
method) is defined with a new instance of the
\href{https://docs.liferay.com/portal/7.1-latest/apps/frontend-taglib-1.0.1/javadocs/com/liferay/frontend/taglib/chart/model/MultiValueColumn.html}{\texttt{MultiValueColumn}
object}, which takes an ID and a set of values. This tutorial shows how
to configure your portlet to use line charts.

Follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Import the chart taglib along with the \texttt{LineChartConfig} and
  \texttt{MultiValueColumn} classes into your bundle's \texttt{init.jsp}
  file:

\begin{verbatim}
<%@ taglib prefix="chart" uri="http://liferay.com/tld/chart" %>
<%@ page import="com.liferay.frontend.taglib.chart.model.point.line.LineChartConfig" %>
<%@ page import="com.liferay.frontend.taglib.chart.model.MultiValueColumn" %>
\end{verbatim}
\item
  Add the following Java scriptlet to the top of your \texttt{view.jsp}:

\begin{verbatim}
<%
LineChartConfig _lineChartConfig = new LineChartConfig();

_lineChartConfig.addColumns(
  new MultiValueColumn("data1", 100, 20, 30),
  new MultiValueColumn("data2", 20, 70, 100)
);
%>
\end{verbatim}
\item
  Add the \texttt{\textless{}chart\textgreater{}} taglib to the
  \texttt{view.jsp}, passing the \texttt{\_lineChartConfig} as the
  \texttt{config} attribute's value:

\begin{verbatim}
<chart:line
  config="<%= _lineChartConfig %>"
/>
\end{verbatim}
\end{enumerate}

\begin{figure}
\centering
\includegraphics{./images/chart-taglib-line.png}
\caption{A Line chart displays the data linearly.}
\end{figure}

\subsection{Related Topics}\label{related-topics-197}

\href{/docs/7-1/tutorials/-/knowledge_base/t/spline-charts}{Spline
Charts}

\href{/docs/7-1/tutorials/-/knowledge_base/t/step-charts}{Step Charts}

\href{/docs/7-1/tutorials/-/knowledge_base/t/predictive-charts}{Predictive
Charts}

\section{Scatter Charts}\label{scatter-charts}

Scatter charts contain multiple sets of data. A scatter chart models the
data as individual points. Each data series (created with the
\texttt{addColumns()} method) is defined with a new instance of the
\href{https://docs.liferay.com/portal/7.1-latest/apps/frontend-taglib-1.0.1/javadocs/com/liferay/frontend/taglib/chart/model/MultiValueColumn.html}{\texttt{MultiValueColumn}
object}, which takes an ID and a set of values. This tutorial shows how
to configure your portlet to use scatter charts.

Follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Import the chart taglib along with the \texttt{ScatterChartConfig} and
  \texttt{MultiValueColumn} classes into your bundle's \texttt{init.jsp}
  file:

\begin{verbatim}
<%@ taglib prefix="chart" uri="http://liferay.com/tld/chart" %>
<%@ page import="com.liferay.frontend.taglib.chart.model.point.scatter.ScatterChartConfig" %>
<%@ page import="com.liferay.frontend.taglib.chart.model.MultiValueColumn" %>
\end{verbatim}
\item
  Add the following Java scriptlet to the top of your \texttt{view.jsp}:

\begin{verbatim}
<%
ScatterChartConfig _scatterChartConfig = new ScatterChartConfig();

_scatterChartConfig.addColumns(
  new MultiValueColumn("data1", 100, 20, 30),
  new MultiValueColumn("data2", 20, 70, 100)
);
%>
\end{verbatim}
\item
  Add the \texttt{\textless{}chart\textgreater{}} taglib to the
  \texttt{view.jsp}, passing the \texttt{\_scatterChartConfig} as the
  \texttt{config} attribute's value:

\begin{verbatim}
<chart:scatter
  config="<%= _scatterChartConfig %>"
/>
\end{verbatim}
\end{enumerate}

\begin{figure}
\centering
\includegraphics{./images/chart-taglib-scatter.png}
\caption{A scatter chart models the data as individual points.}
\end{figure}

\subsection{Related Topics}\label{related-topics-198}

\href{/docs/7-1/tutorials/-/knowledge_base/t/line-charts}{Line Charts}

\href{/docs/7-1/tutorials/-/knowledge_base/t/step-charts}{Step Charts}

\href{/docs/7-1/tutorials/-/knowledge_base/t/predictive-charts}{Predictive
Charts}

\section{Spline Charts}\label{spline-charts}

Spline charts contain multiple sets of data. A spline chart connects
points of data with a smooth curve. Each data series (created with the
\texttt{addColumns()} method) is defined with a new instance of the
\href{https://docs.liferay.com/portal/7.1-latest/apps/frontend-taglib-1.0.1/javadocs/com/liferay/frontend/taglib/chart/model/MultiValueColumn.html}{\texttt{MultiValueColumn}
object}, which takes an ID and a set of values. This tutorial shows how
to configure your portlet to use spline charts.

Follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Import the chart taglib along with the \texttt{SplineChartConfig} and
  \texttt{MultiValueColumn} classes into your bundle's \texttt{init.jsp}
  file:

\begin{verbatim}
<%@ taglib prefix="chart" uri="http://liferay.com/tld/chart" %>
<%@ page import="com.liferay.frontend.taglib.chart.model.point.spline.SplineChartConfig" %>
<%@ page import="com.liferay.frontend.taglib.chart.model.MultiValueColumn" %>
\end{verbatim}
\item
  Add the following Java scriptlet to the top of your \texttt{view.jsp}:

\begin{verbatim}
<%
SplineChartConfig _splineChartConfig = new SplineChartConfig();

_splineChartConfig.addColumns(
  new MultiValueColumn("data1", 100, 20, 30),
  new MultiValueColumn("data2", 20, 70, 100)
);
%>
\end{verbatim}
\item
  Add the \texttt{\textless{}chart\textgreater{}} taglib to the
  \texttt{view.jsp}, passing the \texttt{\_splineChartConfig} as the
  \texttt{config} attribute's value:

\begin{verbatim}
<chart:spline
  config="<%= _splineChartConfig %>"
/>
\end{verbatim}
\end{enumerate}

\begin{figure}
\centering
\includegraphics{./images/chart-taglib-spline.png}
\caption{A spline chart connects points of data with a smooth curve.}
\end{figure}

You can also use an area spline chart if you prefer. An area spline
chart highlights the area under the spline curve.

\begin{verbatim}
<chart:area-spline
  config="<%= _splineChartConfig %>"
/>
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/chart-taglib-area-spline.png}
\caption{An area spline chart highlights the area under the spline
curve.}
\end{figure}

\subsection{Related Topics}\label{related-topics-199}

\href{/docs/7-1/tutorials/-/knowledge_base/t/line-charts}{Line Charts}

\href{/docs/7-1/tutorials/-/knowledge_base/t/step-charts}{Step Charts}

\href{/docs/7-1/tutorials/-/knowledge_base/t/scatter-charts}{Scatter
Charts}

\section{Step Charts}\label{step-charts}

Step charts contain multiple sets of data. A step chart steps between
the points of data, resembling steps. Each data series (created with the
\texttt{addColumns()} method) is defined with a new instance of the
\href{https://docs.liferay.com/portal/7.1-latest/apps/frontend-taglib-1.0.1/javadocs/com/liferay/frontend/taglib/chart/model/MultiValueColumn.html}{\texttt{MultiValueColumn}
object}, which takes an ID and a set of values. This tutorial shows how
to configure your portlet to use step charts.

Follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Import the chart taglib along with the \texttt{StepChartConfig} and
  \texttt{MultiValueColumn} classes into your bundle's \texttt{init.jsp}
  file:

\begin{verbatim}
<%@ taglib prefix="chart" uri="http://liferay.com/tld/chart" %>
<%@ page import="com.liferay.frontend.taglib.chart.model.point.step.StepChartConfig" %>
<%@ page import="com.liferay.frontend.taglib.chart.model.MultiValueColumn" %>
\end{verbatim}
\item
  Add the following Java scriptlet to the top of your \texttt{view.jsp}:

\begin{verbatim}
<%
StepChartConfig _stepChartConfig = new StepChartConfig();

_stepChartConfig.addColumns(
  new MultiValueColumn("data1", 100, 20, 30),
  new MultiValueColumn("data2", 20, 70, 100)
);
%>
\end{verbatim}
\item
  Add the \texttt{\textless{}chart\textgreater{}} taglib to the
  \texttt{view.jsp}, passing the \texttt{\_stepChartConfig} as the
  \texttt{config} attribute's value:

\begin{verbatim}
<chart:step
  config="<%= _stepChartConfig %>"
/>
\end{verbatim}
\end{enumerate}

\begin{figure}
\centering
\includegraphics{./images/chart-taglib-step.png}
\caption{A step chart steps between the points of data, resembling
steps.}
\end{figure}

You can also use an area step chart if you prefer. An area step chart
highlights the area covered by a step graph.

\begin{verbatim}
<chart:area-step
  config="<%= _stepChartConfig %>"
/>
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/chart-taglib-area-step.png}
\caption{An area step chart highlights the area covered by a step
graph.}
\end{figure}

\subsection{Related Topics}\label{related-topics-200}

\href{/docs/7-1/tutorials/-/knowledge_base/t/line-charts}{Line Charts}

\href{/docs/7-1/tutorials/-/knowledge_base/t/spline-charts}{Spline
Charts}

\href{/docs/7-1/tutorials/-/knowledge_base/t/scatter-charts}{Scatter
Charts}

\section{Combination Charts}\label{combination-charts}

Combination charts have minor differences from other charts. In a
combination chart, you must define the representation type of each data
set: \texttt{AREA}, \texttt{AREA\_SPLINE}, \texttt{AREA\_STEP},
\texttt{BAR}, \texttt{BUBBLE}, \texttt{DONUT}, \texttt{GAUGE},
\texttt{LINE}, \texttt{PIE}, \texttt{SCATTER}, \texttt{SPLINE}, or
\texttt{STEP}. Each data set in a combination chart is an instance of
the
\href{https://docs.liferay.com/portal/7.1-latest/apps/frontend-taglib-1.0.1/javadocs/com/liferay/frontend/taglib/chart/model/TypedMultiValueColumn.html}{\texttt{TypedMultiValueColumn}
object}. Each object receives an ID, the representation type, and values
for the data. This tutorial shows how to configure your portlet to use
combination charts.

Follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Import the chart taglib along with the
  \texttt{CombinationChartConfig}, \texttt{MultiValueColumn}, and
  \texttt{MultiValueColumn.Type} classes into your bundle's
  \texttt{init.jsp} file:

\begin{verbatim}
<%@ taglib prefix="chart" uri="http://liferay.com/tld/chart" %>
<%@ page import="com.liferay.frontend.taglib.chart.model.combination.CombinationChartConfig" %>
<%@ page import="com.liferay.frontend.taglib.chart.model.MultiValueColumn" %>
<%@ page import="com.liferay.frontend.taglib.chart.model.TypedMultiValueColumn.Type" %>
\end{verbatim}
\item
  Add the following Java scriptlet to the top of your \texttt{view.jsp}:

\begin{verbatim}
<%
CombinationChartConfig _combinationChartConfig =
new CombinationChartConfig();

_combinationChartConfig.addColumns(
  new TypedMultiValueColumn(
    "data1", Type.BAR, 30, 20, 50, 40, 60, 50),
  new TypedMultiValueColumn(
    "data2", Type.BAR, 200, 130, 90, 240, 130, 220),
  new TypedMultiValueColumn(
    "data3", Type.SPLINE, 300, 200, 160, 400, 250, 250),
  new TypedMultiValueColumn(
    "data4", Type.LINE, 200, 130, 90, 240, 130, 220),
  new TypedMultiValueColumn(
    "data5", Type.BAR, 130, 120, 150, 140, 160, 150),
  new TypedMultiValueColumn(
    "data6", Type.AREA, 90, 70, 20, 50, 60, 120)
  );

_combinationChartConfig.addGroup("data1", "data2");
%>
\end{verbatim}
\item
  Add the \texttt{\textless{}chart\textgreater{}} taglib to the
  \texttt{view.jsp}, passing the \texttt{\_combinationChartConfig} as
  the \texttt{config} attribute's value:

\begin{verbatim}
<chart:combination
  config="<%= _combinationChartConfig %>"
/>
\end{verbatim}
\end{enumerate}

\begin{figure}
\centering
\includegraphics{./images/chart-taglib-combination.png}
\caption{A combination chart displays a variety of data set types.}
\end{figure}

\subsection{Related Topics}\label{related-topics-201}

\href{/docs/7-1/tutorials/-/knowledge_base/t/bar-charts}{Bar Charts}

\href{/docs/7-1/tutorials/-/knowledge_base/t/line-charts}{Line Charts}

\href{/docs/7-1/tutorials/-/knowledge_base/t/geomap-charts}{Geomap
Charts}

\section{Donut Charts}\label{donut-charts}

Donut charts are percentage-based. A donut chart is similar to a pie
chart, but it has a hole in the center. Each data set must be defined as
a new instance of the
\href{https://docs.liferay.com/portal/7.1-latest/apps/frontend-taglib-1.0.1/javadocs/com/liferay/frontend/taglib/chart/model/SingleValueColumn.html}{\texttt{SingleValueColumn}
object}. This tutorial shows how to configure your portlet to use donut
charts.

Follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Import the chart taglib along with the \texttt{DonutChartConfig} and
  \texttt{SingleValueColumn} classes into your bundle's
  \texttt{init.jsp} file:

\begin{verbatim}
<%@ taglib prefix="chart" uri="http://liferay.com/tld/chart" %>
<%@ page import="com.liferay.frontend.taglib.chart.model.percentage.donut.DonutChartConfig" %>
<%@ page import="com.liferay.frontend.taglib.chart.model.SingleValueColumn" %>
\end{verbatim}
\item
  Add the following Java scriptlet to the top of your \texttt{view.jsp}:

\begin{verbatim}
<%
DonutChartConfig _donutChartConfig = new DonutChartConfig();

_donutChartConfig.addColumns(
  new SingleValueColumn("data1", 30),
  new SingleValueColumn("data2", 70)
);
%>
\end{verbatim}
\item
  Add the \texttt{\textless{}chart\textgreater{}} taglib to the
  \texttt{view.jsp}, passing the \texttt{\_donutChartConfig} as the
  \texttt{config} attribute's value:

\begin{verbatim}
<chart:donut
  config="<%= _donutChartConfig %>"
/>
\end{verbatim}
\end{enumerate}

\begin{figure}
\centering
\includegraphics{./images/chart-taglib-donut.png}
\caption{A donut chart is similar to a pie chart, but it has a hole in
the center.}
\end{figure}

\subsection{Related Topics}\label{related-topics-202}

\href{/docs/7-1/tutorials/-/knowledge_base/t/pie-charts}{Pie Charts}

\href{/docs/7-1/tutorials/-/knowledge_base/t/gauge-charts}{Gauge Charts}

\href{/docs/7-1/tutorials/-/knowledge_base/t/bar-charts}{Bar Charts}

\section{Gauge Charts}\label{gauge-charts}

Gauge charts are percentage-based. A gauge chart shows where
percentage-based data falls over a given range. Each data set must be
defined as a new instance of the
\href{https://docs.liferay.com/portal/7.1-latest/apps/frontend-taglib-1.0.1/javadocs/com/liferay/frontend/taglib/chart/model/SingleValueColumn.html}{\texttt{SingleValueColumn}
object}. This tutorial shows how to configure your portlet to use gauge
charts.

Follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Import the chart taglib along with the \texttt{GaugeChartConfig} and
  \texttt{SingleValueColumn} classes into your bundle's
  \texttt{init.jsp} file:

\begin{verbatim}
<%@ taglib prefix="chart" uri="http://liferay.com/tld/chart" %>
<%@ page import="com.liferay.frontend.taglib.chart.model.gauge.GaugeChartConfig" %>
<%@ page import="com.liferay.frontend.taglib.chart.model.SingleValueColumn" %>
\end{verbatim}
\item
  Add the following Java scriptlet to the top of your \texttt{view.jsp}:

\begin{verbatim}
<%
GaugeChartConfig _gaugeChartConfig = new GaugeChartConfig();

_gaugeChartConfig.addColumn(
  new SingleValueColumn("data1", 85.4)
);
%>
\end{verbatim}
\item
  Add the \texttt{\textless{}chart\textgreater{}} taglib to the
  \texttt{view.jsp}, passing the \texttt{\_gaugeChartConfig} as the
  \texttt{config} attribute's value:

\begin{verbatim}
<chart:gauge
  config="<%= _gaugeChartConfig %>"
/>
\end{verbatim}
\end{enumerate}

\begin{figure}
\centering
\includegraphics{./images/chart-taglib-gauge.png}
\caption{A gauge chart shows where percentage-based data falls over a
given range.}
\end{figure}

\subsection{Related Topics}\label{related-topics-203}

\href{/docs/7-1/tutorials/-/knowledge_base/t/pie-charts}{Pie Charts}

\href{/docs/7-1/tutorials/-/knowledge_base/t/donut-charts}{Donut Charts}

\href{/docs/7-1/tutorials/-/knowledge_base/t/bar-charts}{Bar Charts}

\section{Pie Charts}\label{pie-charts}

Pie charts are percentage-based. A pie chart models percentage-based
data as individual slices of pie. Each data set must be defined as a new
instance of the
\href{https://docs.liferay.com/portal/7.1-latest/apps/frontend-taglib-1.0.1/javadocs/com/liferay/frontend/taglib/chart/model/SingleValueColumn.html}{\texttt{SingleValueColumn}
object}. This tutorial shows how to configure your portlet to use pie
charts.

Follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Import the chart taglib along with the \texttt{PieChartConfig} and
  \texttt{SingleValueColumn} classes into your bundle's
  \texttt{init.jsp} file:

\begin{verbatim}
<%@ taglib prefix="chart" uri="http://liferay.com/tld/chart" %>
<%@ page import="com.liferay.frontend.taglib.chart.model.percentage.pie.PieChartConfig" %>
<%@ page import="com.liferay.frontend.taglib.chart.model.SingleValueColumn" %>
\end{verbatim}
\item
  Add the following Java scriptlet to the top of your \texttt{view.jsp}:

\begin{verbatim}
<%
PieChartConfig _pieChartConfig = new PieChartConfig();

_pieChartConfig.addColumn(
  new SingleValueColumn("data1", 85.4)
);
%>
\end{verbatim}
\item
  Add the \texttt{\textless{}chart\textgreater{}} taglib to the
  \texttt{view.jsp}, passing the \texttt{\_pieChartConfig} as the
  \texttt{config} attribute's value:

\begin{verbatim}
<chart:pie
  config="<%= _pieChartConfig %>"
/>
\end{verbatim}
\end{enumerate}

\begin{figure}
\centering
\includegraphics{./images/chart-taglib-pie.png}
\caption{A pie chart models percentage-based data as individual slices
of pie.}
\end{figure}

\subsection{Related Topics}\label{related-topics-204}

\href{/docs/7-1/tutorials/-/knowledge_base/t/donut-charts}{Donut Charts}

\href{/docs/7-1/tutorials/-/knowledge_base/t/gauge-charts}{Gauge Charts}

\href{/docs/7-1/tutorials/-/knowledge_base/t/spline-charts}{Spline
Charts}

\section{Geomap Charts}\label{geomap-charts}

A Geomap Chart lets you visualize data based on geography, given a
specified color range---a lighter color representing a lower rank and a
darker a higher rank usually. The default configuration comes from the
Clay charts
\href{https://github.com/liferay/clay/blob/2.x-stable/packages/clay-charts/src/Geomap.js\#L90-L104}{geomap
component}: which ranges from light-blue (\#b1d4ff) to dark-blue
(\#0065e4) and ranks the geography based on the location's
\texttt{pop\_est} value (specified in the geomap's JSON file).

\begin{figure}
\centering
\includegraphics{./images/chart-taglib-geomap-default.png}
\caption{A Geomap chart displays a heatmap representing the data.}
\end{figure}

This tutorial shows how to configure your portlet to use geomap charts.
Follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Import the chart taglib along with the \texttt{GeomapConfig},
  \texttt{GeomapColor}, and \texttt{GeomapColorRange} classes into your
  bundle's \texttt{init.jsp} file:

\begin{verbatim}
<%@ taglib prefix="chart" uri="http://liferay.com/tld/chart" %>
<%@ page import="com.liferay.frontend.taglib.chart.model.geomap.GeomapConfig" %>
<%@ page import="com.liferay.frontend.taglib.chart.model.geomap.GeomapColor" %>
<%@ page import="com.liferay.frontend.taglib.chart.model.geomap.GeomapColorRange" %>
\end{verbatim}
\item
  Add the following Java scriptlet to the top of your \texttt{view.jsp}.
  The colors---a color for minimum and a color for maximum---are
  completely configurable, as shown in the second example configuration
  below: \texttt{\_geomapConfig2}. Create a new
  \texttt{GeomapColorRange} and set the minimum and maximum color values
  with the \texttt{setMax()} and \texttt{setMin()} methods. Specify the
  highlight color---the color displayed when you mouse over an
  area---with the \texttt{setSelected()} method. use the
  \texttt{geomapColor.setValue()} method to specify the JSON property to
  determine the geomap's ranking. Specify the JSON filepath with the
  \texttt{setDataHREF()} method. The example below displays a geomap
  based on the length of each location's name:

\begin{verbatim}
<%
GeomapConfig _geomapConfig1 = new GeomapConfig();
GeomapConfig _geomapConfig2 = new GeomapConfig();

GeomapColor geomapColor = new GeomapColor();
GeomapColorRange geomapColorRange = new GeomapColorRange();

geomapColorRange.setMax("#b2150a");
geomapColorRange.setMin("#ee3e32");

geomapColor.setGeomapColorRange(geomapColorRange);

geomapColor.setSelected("#a9615c");

geomapColor.setValue("name_len");

_geomapConfig2.setColor(geomapColor);

StringBuilder sb = new StringBuilder();

sb.append(_portletRequest.getScheme());
sb.append(StringPool.COLON);
sb.append(StringPool.SLASH);
sb.append(StringPool.SLASH);
sb.append(_portletRequest.getServerName());
sb.append(StringPool.COLON);
sb.append(_portletRequest.getServerPort());
sb.append(_portletRequest.getContextPath());
sb.append(StringPool.SLASH);
sb.append("geomap.geo.json");

_geomapConfig1.setDataHREF(sb.toString());
_geomapConfig2.setDataHREF(sb.toString());
%>
\end{verbatim}
\item
  Add the \texttt{\textless{}chart\textgreater{}} taglib to the
  \texttt{view.jsp} along with any styling information for the geomap,
  such as the size and margins as shown below:

\begin{verbatim}
<style type="text/css">
    .geomap {
        margin: 10px 0 10px 0;
    }
    .geomap svg {
        width: 100%;
        height: 500px !important;
    }
</style>

<chart:geomap
    config="<%= _geomapConfig1 %>"
    id="geomap-default-colors"
/>

<chart:geomap
    config="<%= _geomapConfig2 %>"
    id="geomap-custom-colors"
/>
\end{verbatim}
\end{enumerate}

\begin{figure}
\centering
\includegraphics{./images/chart-taglib-geomap-custom.png}
\caption{Geomap charts can be customized to fit the look and feel you
desire.}
\end{figure}

\subsection{Related Topics}\label{related-topics-205}

\href{/docs/7-1/tutorials/-/knowledge_base/t/bar-charts}{Bar Charts}

\href{/docs/7-1/tutorials/-/knowledge_base/t/pie-charts}{Pie Charts}

\href{/docs/7-1/tutorials/-/knowledge_base/t/combination-charts}{Combination
Charts}

\section{Predictive Charts}\label{predictive-charts}

Predictive charts let you visualize current data along with
predicted/forecasted data within a given value range.

\begin{figure}
\centering
\includegraphics{./images/chart-taglib-predictive-value-range.png}
\caption{Predicted/forecasted data is surrounded by a highlighted area
of possible values.}
\end{figure}

This tutorial shows how to configure your portlet to use predictive
charts. Follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Import the chart taglib along with the \texttt{PredictiveChartConfig}
  and \texttt{MixedDataColumn} classes into your bundle's
  \texttt{init.jsp} file:

\begin{verbatim}
<%@ taglib prefix="chart" uri="http://liferay.com/tld/chart" %>
<%@ page import="com.liferay.frontend.taglib.chart.model.predictive.PredictiveChartConfig" %>
<%@ page import="com.liferay.frontend.taglib.chart.model.MixedDataColumn" %>
\end{verbatim}
\item
  Add the following Java scriptlet to the top of your \texttt{view.jsp}.
  Add a
  \href{https://docs.liferay.com/portal/7.1-latest/apps/frontend-taglib-1.0.1/javadocs/com/liferay/frontend/taglib/chart/model/MixedDataColumn.html}{\texttt{MixedDataColumn}
  object} ---a column that supports both single number values and arrays
  of three numbers---for each data series. Single number values define
  existing data. Arrays of numbers are used as the prediction/forecast
  data and contain three numbers: a minimum value, an estimated value,
  and a maximum value. The estimated value is rendered solid and
  surrounded by a highlighted area with borders specified by the minimum
  and maximum values. This lets you visualize your estimated values,
  while also giving you an idea of the possible value ranges. Use the
  \texttt{addDataColumn()} method to add each data series:

\begin{verbatim}
<%
private PredictiveChartConfig _predictiveChartConfig = new
PredictiveChartConfig();

MixedDataColumn mixedDataColumn1 = new MixedDataColumn(
  "data1", 130, 340, 200, 500, 80, 240, 40,
  new Number[] {370, 400, 450}, new Number[] {210, 240, 270},
  new Number[] {150, 180, 210}, new Number[] {60, 90, 120},
  new Number[] {310, 340, 370}
);

_predictiveChartConfig.addDataColumn(mixedDataColumn1);

MixedDataColumn mixedDataColumn2 = new MixedDataColumn(
  "data2", 210, 160, 50, 125, 230, 110, 90,
  Arrays.asList(170, 200, 230), Arrays.asList(10, 40, 70),
  Arrays.asList(350, 380, 410), Arrays.asList(260, 290, 320),
  Arrays.asList(30, 70, 150)
);

_predictiveChartConfig.addDataColumn(mixedDataColumn2);

_predictiveChartConfig.setAxisXTickFormat("%b");

_predictiveChartConfig.setPredictionDate("2018-07-01");

List<String> timeseries = new ArrayList<>();

timeseries.add("2018-01-01");
timeseries.add("2018-02-01");
timeseries.add("2018-03-01");
timeseries.add("2018-04-01");
timeseries.add("2018-05-01");
timeseries.add("2018-06-01");
timeseries.add("2018-07-01");
timeseries.add("2018-08-01");
timeseries.add("2018-09-01");
timeseries.add("2018-10-01");
timeseries.add("2018-11-01");
timeseries.add("2018-12-01");

_predictiveChartConfig.setTimeseries(timeseries);
%>
\end{verbatim}

  Predictive charts have the following properties:

  \textbf{axisXTickFormat:} An optional string which specfies the time
  formatting on the X axis. For more information on which formats can be
  specified please refer to
  \href{https://github.com/d3/d3-time-format/blob/master/README.md\#locale_format}{d3's
  time format README}. This value is set using the
  \texttt{setAxisXTickFormat()} method.

  \textbf{Prediction Date:} A date as a string that represents the point
  in the timeline from when the forecast/prediction is shown. This value
  is parsed as a Date object in JavaScript and set using the
  \texttt{setPredictionDate()} method.

  \textbf{Time Series:} A timeline for the data which is displayed on
  the X axis of the chart. This value is set as an array of dates
  (\texttt{2018-01-01} for example).
\item
  Add the \texttt{\textless{}chart\textgreater{}} taglib to the
  \texttt{view.jsp}, passing the \texttt{\_predictiveChartConfig} as the
  \texttt{config} attribute's value:

\begin{verbatim}
<chart:predictive
  config="<%= _predictiveChartConfig %>"
/>
\end{verbatim}
\end{enumerate}

The area contained within the light-blue rectangle is the point from
which the predicted/forecasted values are shown:

\begin{figure}
\centering
\includegraphics{./images/chart-taglib-predictive.png}
\caption{A predictive chart lets you visualize estimated future data
alongside existing data.}
\end{figure}

\subsection{Related Topics}\label{related-topics-206}

\href{/docs/7-1/tutorials/-/knowledge_base/t/line-charts}{Line Charts}

\href{/docs/7-1/tutorials/-/knowledge_base/t/combination-charts}{Combination
Charts}

\href{/docs/7-1/tutorials/-/knowledge_base/t/geomap-charts}{Geomap
Charts}

\section{Refreshing Charts to Reflect Real Time
Data}\label{refreshing-charts-to-reflect-real-time-data}

The polling interval property is an optional property for all charts. It
specifies the time in milliseconds for the chart's data to refresh. You
can use this for charts that receive any kind of real time data, such as
a JSON file that changes periodically. This ensures that the chart is up
to date, reflecting the most recent data. This tutorial shows how to
configure your portlet's chart to reflect real time data.

Use the \texttt{setPollingInterval()} method for your chart's
configuration object to specify the refresh rate. An example
\texttt{view.jsp} configuration is shown below:

\begin{verbatim}
<%
LineChartConfig _pollingIntervalLineChartConfig = new LineChartConfig();

_pollingIntervalLineChartConfig.put("data", "/foo.json");

_pollingIntervalLineChartConfig.setPollingInterval(2000);

%>

<chart:line
    componentId="polling-interval-line-chart"
    config="<%= _pollingIntervalLineChartConfig %>"
/>
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/chart-polling-interval.gif}
\caption{The polling interval property lets you refresh charts at a
given interval to reflect real time data.}
\end{figure}

\subsection{Related Topics}\label{related-topics-207}

\href{/docs/7-1/tutorials/-/knowledge_base/t/bar-charts}{Bar Charts}

\href{/docs/7-1/tutorials/-/knowledge_base/t/scatter-charts}{Scatter
Charts}

\href{/docs/7-1/tutorials/-/knowledge_base/t/donut-charts}{Donut Charts}

\chapter{Using AUI Taglibs}\label{using-aui-taglibs}

The AUI tag library provides tags that implement commonly used UI
components. These tags make your markup consistent, responsive, and
accessible.

You can find a list of the available
\texttt{\textless{}aui\textgreater{}} taglibs in the
\href{https://docs.liferay.com/portal/7.1-latest/taglibs/util-taglib/aui/tld-summary.html}{AUI
taglibdocs}. Each taglib has a list of attributes that can be passed to
the tag. Some of these are required, and some are optional. See the
taglibdocs to view the requirements for each tag. You'll find the full
markup generated by the tags in their JSPs in their
\href{https://github.com/liferay/liferay-portal/tree/7.1.x/portal-web/docroot/html/taglib/aui}{Liferay
Github Repo} folders.

To use the AUI taglib library in your apps, you must add the following
declaration to your JSP:

\begin{verbatim}
<%@ taglib prefix="aui" uri="http://liferay.com/tld/aui" %>
\end{verbatim}

The AUI taglib is also available via a macro for your FreeMarker theme
templates and web content templates. Follow this syntax:

\begin{verbatim}
<@liferay_aui["tag-name"] attribute="string value" attribute=10 />
\end{verbatim}

This section of tutorials covers how to create UI components with the
AUI taglibs. Each tutorial contains code examples along with a
screenshot of the resulting UI.

\section{Building Forms with AUI
Tags}\label{building-forms-with-aui-tags}

The
\href{https://docs.liferay.com/portal/7.1-latest/taglibs/util-taglib/aui/tld-summary.html}{AUI
tag library} provides all the components you need to build forms for
your applications. AUI tags provide many benefits to standard form
elements, such as custom namespacing, localization, and even validation.
They provide multiple attributes that let you create the experience you
want for your users.

This tutorial shows you how to build forms using AUI tags. Follow these
steps to build a form:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add the \texttt{aui} taglib declaration to your portlet's
  \texttt{view.jsp} if you haven't already:

\begin{verbatim}
<%@ taglib prefix="aui" uri="http://liferay.com/tld/aui" %>
\end{verbatim}
\item
  Build your form using the tags shown below. Each tag links to the
  corresponding taglibdoc that list the available attributes:

  \begin{itemize}
  \tightlist
  \item
    \href{https://docs.liferay.com/ce/portal/7.1-latest/taglibs/util-taglib/aui/input.html}{\texttt{\textless{}aui:input\textgreater{}}}
  \item
    \href{https://docs.liferay.com/ce/portal/7.1-latest/taglibs/util-taglib/aui/button.html}{\texttt{\textless{}aui:button\textgreater{}}}
  \item
    \href{https://docs.liferay.com/ce/portal/7.1-latest/taglibs/util-taglib/aui/button-row.html}{\texttt{\textless{}aui:button-row\textgreater{}}}
  \item
    \href{https://docs.liferay.com/ce/portal/7.1-latest/taglibs/util-taglib/aui/container.html}{\texttt{\textless{}aui:container\textgreater{}}}
  \item
    \href{https://docs.liferay.com/ce/portal/7.1-latest/taglibs/util-taglib/aui/col.html}{\texttt{\textless{}aui:col\textgreater{}}}
  \item
    \href{https://docs.liferay.com/ce/portal/7.1-latest/taglibs/util-taglib/aui/row.html}{\texttt{\textless{}aui:row\textgreater{}}}
  \item
    \href{https://docs.liferay.com/ce/portal/7.1-latest/taglibs/util-taglib/aui/field-wrapper.html}{\texttt{\textless{}aui:field-wrapper\textgreater{}}}
  \item
    \href{https://docs.liferay.com/ce/portal/7.1-latest/taglibs/util-taglib/aui/fieldset.html}{\texttt{\textless{}aui:fieldset\textgreater{}}}
  \item
    \href{https://docs.liferay.com/ce/portal/7.1-latest/taglibs/util-taglib/aui/fieldset-group.html}{\texttt{\textless{}aui:fieldset-group\textgreater{}}}
  \item
    \href{https://docs.liferay.com/ce/portal/7.1-latest/taglibs/util-taglib/aui/form.html}{\texttt{\textless{}aui:form\textgreater{}}}
  \item
    \href{https://docs.liferay.com/ce/portal/7.1-latest/taglibs/util-taglib/aui/select.html}{\texttt{\textless{}aui:select\textgreater{}}}
  \item
    \href{https://docs.liferay.com/ce/portal/7.1-latest/taglibs/util-taglib/aui/option.html}{\texttt{\textless{}aui:option\textgreater{}}}
  \end{itemize}

  An example form is shown below:

\begin{verbatim}
<aui:form name="fm">
    <aui:fieldset-group markupView="lexicon">
        <aui:fieldset label="Personal Information">
            <aui:row>
                <aui:col width="50">
                    <aui:input label="First Name" name="firstName" type="text" />
                </aui:col>
                <aui:col width="50">
                    <aui:input label="Last Name" name="lastName" type="text" />
                </aui:col>
            </aui:row>
            <aui:row>
                <aui:col width="50">
                    <aui:input label="Username" name="username" type="text" />
                </aui:col>
                <aui:col width="50">
                    <aui:input label="Email" name="email" type="email" />
                </aui:col>
            </aui:row>
        </aui:fieldset>
    </aui:fieldset-group>
    <aui:fieldset-group markupView="lexicon">
        <aui:fieldset label="Miscellaneous">
            <aui:input label="Hobbies" name="hobbies" type="textarea" />
            <aui:input label="Receive email updates" name="emailUpdates" type="checkbox" />
        </aui:fieldset>
    </aui:fieldset-group>
    <aui:button-row>
        <aui:button name="submitButton" type="submit" value="Submit" />
    </aui:button-row>
</aui:form>
\end{verbatim}

  \begin{figure}
  \centering
  \includegraphics{./images/aui-taglib-basic-form.png}
  \caption{The AUI tags provide everything you need to build forms for
  your applications.}
  \end{figure}
\item
  Optionally add validation to your form fields. Nest a
  \texttt{\textless{}aui:validator\textgreater{}} tag inside each form
  field that you want to validate. Specify the validation rule with the
  \texttt{\textless{}aui:validator\textgreater{}} tag's \texttt{name}
  attribute (The available validation rules are shown in the table
  below). You can override a field's default validation error message
  with the \texttt{errorMessage} attribute. An example configuration is
  shown below:

\begin{verbatim}
<aui:form name="myForm">
    <aui:input name="password" id="password" label="Password" 
    required="true" />
    <aui:input name="confirmPassword" id="password" 
    label="Confirm Password" required="true">
        <aui:validator name="equalTo" 
        errorMessage="The passwords much match. Please try again." >
        '#<portlet:namespace>password'
        </aui:validator>
    </aui:input>
</aui:form>
\end{verbatim}

  \begin{figure}
  \centering
  \includegraphics{./images/aui-taglib-form-validation.png}
  \caption{The AUI tags also provide validation for form fields.}
  \end{figure}

  The full list of available validation rules is shown in the table
  below:
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 Rule | Description | Default Error Message |
 --- | --- | --- |
 `acceptFiles` | Specifies that the field can only contain the file types given. Each file extension must be separated by a comma. For example </br> `<aui:validator name="acceptFiles">'jpg,png,tif,gif'</aui:validator>` | 'Please enter a file with a valid extension ([supported extensions]).' |
 `alpha` | Permits alphabetic characters | 'Please enter only alpha characters.' |
 `alphanum` | Permits alphanumeric characters | 'Please enter only alphanumeric characters.' |
 `date` | Permits dates | 'Please enter a valid date.' |
 `digits` | Permits digits | 'Please enter only digits.' |
 `email` | Permits an email address | 'Please enter a valid email address.' |
 `equalTo` | Permits contents equal to another field with the specified field ID. For example, </br> `<aui:validator name="equalTo">'#<portlet:namespace/>password'</aui:validator>` | 'Please enter the same value again.' |
 `max` | Permits an integer value less than the specified value. For example, a max value of 20 is specified with </br> `<aui:validator name="max">20</aui:validator>` | 'Please enter a value less than or equal to [max value].' |
 `maxLength` | Permits a maximum field length of the specified size (follows the same syntax as `max`) | 'Please enter no more than [max] characters.' |
 `min` | Permits an integer value greater than the specified minimum value (follows the same syntax as `max`) | 'Please enter a value greater than or equal to [min value].' |
 `minLength` | Permits a field length longer than the specified size (follows the same syntax as `max`). | 'Please enter at least [min] characters.' |
 `number` | Permits numerical values | 'Please enter a valid number.' |
 `range` | Permits a number between the specified range. For example, a range between 1.23 and 10 is specified here </br> `<aui:validator name="range">[1.23,10]</aui:validator>` | 'Please enter a value between [0] and [1].' |
 `rangeLength` | Permits a field length between the specified range (follows the same syntax as `range`)  | 'Please enter a value between [0] and [1] characters long.' |
 `required` | Prevents a blank field  | 'This field is required.' |
 `url` | Permits a URL value | 'Please enter a valid URL.' |
\end{verbatim}

\noindent\hrulefill

Now you know how to build user-friendly forms for your applications.

\subsection{Related Topics}\label{related-topics-208}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-the-chart-taglib-in-your-portlets}{Using
the Chart Taglib in Your Portlets}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-liferay-frontend-taglibs-in-your-portlet}{Using
Liferay Front-end Taglibs in Your Portlet}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-the-clay-taglib-in-your-portlets}{Using
the Clay Taglib in Your portlets}

\chapter{Mobile}\label{mobile}

Liferay provides two ways to create native Android and iOS apps that
work with your Liferay instances: Liferay Screens and the Liferay Mobile
SDK. Liferay Screens does this via ready-to-use components called
\emph{Screenlets}. Since Screenlets already contain the code required to
call your Liferay instance--and a complete UI--all you need to do is
insert and configure them in your Android or iOS app. Screens provides
Screenlets for common tasks such as logging in, viewing web content,
adding DDL records, and more. You can also customize each Screenlet to
fit your specific needs, or write your own Screenlet. Behind the scenes,
Screenlets use the Liferay Mobile SDK to call Liferay's remote services.

The Liferay Mobile SDK is a lower-level tool that lets you manually
invoke Liferay's remote services. You'll need to use the Mobile SDK to
write your own Screenlets, or call Liferay's remote services independent
of Screens. In most cases, you'll find that using Screens saves you time
and effort. For example, although you can use the Mobile SDK to
implement login in your app, Screens already provides this via Login
Screenlet. There are certain cases, however, where using the Mobile SDK
makes sense. For example, if you need to call one or more Liferay remote
services but your app's UI doesn't need to reflect this, then it doesn't
make sense to use Screenlets for this purpose. Each Screenlet must
contain a UI.

Regardless of your specific needs, Liferay has you covered with Liferay
Screens and the Liferay Mobile SDK. This section of tutorials contains
the following sections that show you how to use both:

\begin{itemize}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/android-apps-with-liferay-screens}{Android
  Apps with Liferay Screens}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/ios-apps-with-liferay-screens}{iOS
  Apps with Liferay Screens}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/using-xamarin-with-liferay-screens}{Using
  Xamarin with Liferay Screens}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/mobile-sdk}{Liferay
  Mobile SDK}
\end{itemize}

Venture forth to become a mobile guru!

\chapter{Android Apps with Liferay
Screens}\label{android-apps-with-liferay-screens}

Liferay Screens speeds up and simplifies developing native mobile apps
that use Liferay. Its power lies in its \emph{Screenlets}. A Screenlet
is a visual component that you insert into your native app to leverage
Liferay Portal's content and
\href{/docs/7-1/tutorials/-/knowledge_base/t/web-services}{services}. On
Android, Screenlets are available to log in to your portal, create
accounts, submit forms, display content, and more. You can use any
number of Screenlets in your app; they're independent, so you can use
them in modular fashion. Screenlets on Android also deliver UI
flexibility with pluggable \emph{Views} that implement elegant user
interfaces. Liferay's reference documentation for
\href{/docs/7-1/reference/-/knowledge_base/r/screenlets-in-liferay-screens-for-android}{Android}
Screenlets describes each Screenlet's features and Views.

You might be thinking, ``These Screenlets sound like the greatest thing
since taco Tuesdays, but what if they don't fit in with my app's UI?
What if they don't behave exactly how I want them to? What if there's no
Screenlet for what I want to do?'' Fret not! You can customize
Screenlets to fit your needs by changing or extending their UI and
behavior. You can even write your own Screenlets! What's more, Screens
seamlessly integrates with your existing Android projects.

\begin{figure}
\centering
\includegraphics{./images/screens-android-intro.png}
\caption{Here's an app that uses a Liferay Screens Sign Up Screenlet.}
\end{figure}

Screenlets leverage the
\href{https://www.liferay.com/community/liferay-projects/liferay-mobile-sdk/overview}{Liferay
Mobile SDK} to make server calls. The Mobile SDK is a low-level layer on
top of the Liferay JSON API. To write your own Screenlets, you must
familiarize yourself with Liferay's
\href{/docs/7-1/tutorials/-/knowledge_base/t/web-services}{remote
services}. If no existing Screenlet meets your needs, consider
customizing an existing Screenlet, creating a Screenlet, or directly
using the Mobile SDK. Creating a Screenlet involves writing Mobile SDK
calls and constructing the Screenlet; if you don't plan to reuse or
distribute the implementation then you may want to forgo writing a
Screenlet and, instead, work with the
\href{/docs/7-1/tutorials/-/knowledge_base/t/mobile-sdk}{Mobile SDK}. A
benefit of integrating an existing Screenlet into your app, however, is
that the Mobile SDK's details are abstracted from you.

These tutorials show you how to use, customize, create, and distribute
Screenlets for Android. They show you how to create Views too. There's
even a tutorial that explains the nitty-gritty details of the Liferay
Screens architecture. No matter how deep you want to go, you'll use
Screenlets in no time. Start by preparing your
\href{/docs/7-1/tutorials/-/knowledge_base/t/preparing-android-projects-for-liferay-screens}{Android
project} to use Liferay Screens.

\section{Preparing Android Projects for Liferay
Screens}\label{preparing-android-projects-for-liferay-screens}

To use Liferay Screens, you must install it in your Android project and
then configure it to communicate with your Liferay DXP instance. Note
that Screens is released as an
\href{http://tools.android.com/tech-docs/new-build-system/aar-format}{AAR}
file hosted in jCenter.

There are three different ways to install Screens. This tutorial shows
you each:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  With Gradle: Gradle is the build system Android Studio uses to build
  Android projects. We therefore recommend that you use it to install
  Screens.
\item
  With Maven
\item
  Manually
\end{enumerate}

\noindent\hrulefill

\textbf{Note:} After installation, you must configure Liferay Screens to
communicate with your Liferay DXP instance. The last section in this
tutorial shows you how to do this.

\noindent\hrulefill

\subsection{Requirements}\label{requirements}

Liferay Screens for Android includes the Component Library (the
Screenlets) and a sample project. It requires the following software:

\begin{itemize}
\tightlist
\item
  Android Studio 3.0 or above.
\item
  Android SDK 4.1 (API Level 16) or above.
\item
  \href{http://www.liferay.com/downloads/liferay-portal/available-releases}{Liferay
  Portal 6.2 CE/EE, Liferay CE Portal 7.0/7.1, or Liferay DXP}
\item
  Liferay Screens Compatibility Plugin
  (\href{http://www.liferay.com/marketplace/-/mp/application/54365664}{CE}
  or
  \href{http://www.liferay.com/marketplace/-/mp/application/54369726}{DXP/EE},
  depending on your portal edition). This app is preinstalled in Liferay
  CE Portal 7.0/7.1 CE and Liferay DXP.
\item
  Liferay Screens source code.
\end{itemize}

Liferay Screens for Android uses
\href{https://github.com/greenrobot/EventBus}{EventBus} internally.

\subsection{Securing JSON Web
Services}\label{securing-json-web-services}

Each Screenlet in Liferay Screens calls one or more of Liferay DXP's
JSON web services, which are enabled by default. The Screenlet
\href{/docs/7-1/reference/-/knowledge_base/r/screenlets-in-liferay-screens-for-android}{reference
documentation} lists the web services that each Screenlet calls. To use
a Screenlet, its web services must be enabled in the portal. It's
possible, however, to disable the web services needed by Screenlets
you're not using. For instructions on this, see the tutorial
\href{/docs/7-1/tutorials/-/knowledge_base/t/configuring-json-web-services}{Configuring
JSON Web Services}. You can also use
\href{/docs/7-1/tutorials/-/knowledge_base/t/service-access-policies}{Service
Access Policies} for more fine-grained control over accessible services.

\subsection{Using Gradle to Install Liferay
Screens}\label{using-gradle-to-install-liferay-screens}

To use Gradle to install Liferay Screens in your Android Studio project,
you must edit your app's \texttt{build.gradle} file. Note that your
project has two \texttt{build.gradle} files: one for the project and
another for the app module. You can find them under Gradle Scripts in
your Android Studio project. This screenshot highlights the app module's
\texttt{build.gradle} file:

\begin{figure}
\centering
\includegraphics{./images/screens-android-gradle-app-module.png}
\caption{The app module's \texttt{build.gradle} file.}
\end{figure}

In the app module's \texttt{build.gradle} file, add the following line
of code inside the \texttt{dependencies} element:

\begin{verbatim}
implementation 'com.liferay.mobile:liferay-screens:+'
\end{verbatim}

Note that the \texttt{+} symbol tells Gradle to install the newest
version of Screens. If your app relies on a specific version of Screens,
you can replace the \texttt{+} symbol with that version.

If you're not sure where to add the above lines, see the below
screenshot.

Once you edit \texttt{build.gradle}, a message appears at the top of the
file that asks you to \emph{sync} your app with its Gradle files.
Syncing the Gradle files incorporates the changes you make to them.
Syncing also downloads and installs any new dependencies, like the
Liferay Screens dependency that you just added. Sync the Gradle files
now by clicking the \emph{Sync Now} link in the message. The following
screenshot shows the top of an edited \texttt{build.gradle} file with
the Sync Now link highlighted by a red box:

\begin{figure}
\centering
\includegraphics{./images/screens-android-gradle-sync.png}
\caption{After editing the app module's \texttt{build.gradle} file,
click \emph{Sync Now} to incorporate the changes in your app.}
\end{figure}

In the case of conflict with the \texttt{appcompat-v7} or other support
libraries (\texttt{com.android.support:appcompat-v7},
\texttt{com.android.support:support-v4}), you have several options:

\begin{itemize}
\item
  Explicitly add the versions of the conflicting libraries you want to
  use. For example:

\begin{verbatim}
implementation 'com.android.support:design:27.0.2'
implementation 'com.android.support:support-media-compat:27.0.2'
implementation 'com.android.support:exifinterface:27.0.2'
\end{verbatim}
\item
  Remove the \texttt{com.android.support:appcompat-v7} dependency from
  your project and use the one embedded in Liferay Screens.
\item
  Exclude the problematic library from Liferay Screens. For example:

\begin{verbatim}
implementation ('com.liferay.mobile:liferay-screens:+') {
    exclude group: 'com.android.support:', module: 'design'
}
\end{verbatim}
\item
  Ignore the inspection, adding a comment like this:

\begin{verbatim}
//noinspection GradleCompatible
\end{verbatim}
\item
  Ignore the warning--Liferay Screens will work without problems.
\end{itemize}

Although we strongly recommend that you use Gradle to install Screens,
the following section shows you how to install Screens with Maven.

\subsection{Using Maven to Install Liferay
Screens}\label{using-maven-to-install-liferay-screens}

Note that we strongly recommend that you use Gradle to install Screens.
It's possible though to use Maven to install Screens. Follow these steps
to configure Liferay Screens in a Maven project:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add the following dependency to your \texttt{pom.xml}:

\begin{verbatim}
 <dependency>
     <groupId>com.liferay.mobile</groupId>
     <artifactId>liferay-screens</artifactId>
     <version>LATEST</version>
 </dependency>
\end{verbatim}
\item
  Force a Maven update to download all the dependencies.
\end{enumerate}

If Maven doesn't automatically locate the artifact, you must add jCenter
as a new repository in your maven settings (e.g.,
\texttt{.m2/settings.xml} file):

\begin{verbatim}
<profiles>
    <profile>
        <repositories>
            <repository>
                <id>bintray-liferay-liferay-mobile</id>
                <name>bintray</name>
                <url>http://dl.bintray.com/liferay/liferay-mobile</url>
            </repository>
        </repositories>
        <pluginRepositories>
            <pluginRepository>
                <id>bintray-liferay-liferay-mobile</id>
                <name>bintray-plugins</name>
                <url>http://dl.bintray.com/liferay/liferay-mobile</url>
            </pluginRepository>
        </pluginRepositories>
        <id>bintray</id>
    </profile>
</profiles>
<activeProfiles>
    <activeProfile>bintray</activeProfile>
</activeProfiles>
\end{verbatim}

Nice work!

\subsection{Manual Configuration in
Gradle}\label{manual-configuration-in-gradle}

Although we strongly recommend that you use Gradle to install Screens
automatically, it's possible to use Gradle to install Screens manually.
Follow these steps to use Gradle to install Screens and its dependencies
manually in your Android project:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \href{https://github.com/liferay/liferay-screens/releases}{Download}
  the latest version of Liferay Screens for Android.
\item
  Copy the contents of \texttt{Android/library} into a folder outside
  your project.
\item
  In your project, configure a \texttt{settings.gradle} file with the
  paths to the library folders:

\begin{verbatim}
 include ':core'
 project(':core').projectDir = new File(settingsDir, '../../library/core')
 project(':core').name = 'liferay-screens'
\end{verbatim}
\item
  Include the required dependencies in your \texttt{build.gradle} file:

\begin{verbatim}
 implementation project(':liferay-screens')
\end{verbatim}
\end{enumerate}

You can also configure the \texttt{.aar} binary files (in
\texttt{Android/dist}) as local \texttt{.aar} file dependencies. You can
download all necessary files from
\href{https://bintray.com/liferay/liferay-mobile/liferay-screens/view}{jCenter}.

To check your configuration, you can compile and execute a blank
activity and import a Liferay Screens class (like Login Screenlet).

Next, you'll set up communication with Liferay DXP.

\subsection{Configuring Communication with Liferay
DXP}\label{configuring-communication-with-liferay-dxp}

Before using Liferay Screens, you must configure it to communicate with
your Liferay DXP instance. To do this, you must provide Screens the
following information:

\begin{itemize}
\item
  Your Liferay DXP instance's ID
\item
  The ID of the site your app needs to communicate with
\item
  Your Liferay DXP instance's version
\item
  Any other information required by specific Screenlets
\end{itemize}

Fortunately, this is straightforward. In your Android project's
\texttt{res/values} folder, create a new file called
\texttt{server\_context.xml}. Add the following code to the new file:

\begin{verbatim}
<?xml version="1.0" encoding="utf-8"?>
<resources>

    <!-- Change these values for your Liferay DXP installation -->

    <string name="liferay_server">http://10.0.2.2:8080</string>

    <string name="liferay_company_id">10155</string>
    <string name="liferay_group_id">10182</string>
    
    <integer name="liferay_portal_version">71</integer>

</resources>
\end{verbatim}

As the above comment indicates, make sure to change these values to
match your Liferay DXP instance. The server address
\texttt{http://10.0.2.2:8080} is suitable for testing with Android
Studio's emulator, because it corresponds to \texttt{localhost:8080}
through the emulator. If you're using the Genymotion emulator, you
should, however, use address \texttt{192.168.56.1} instead of
\texttt{localhost}.

The \texttt{liferay\_company\_id} value is your Liferay DXP instance's
ID. You can find it in your Liferay DXP instance at \emph{Control Panel}
→ \emph{Configuration} → \emph{Virtual Instances}. The instance's ID is
in the \emph{Instance ID} column. Copy and paste this value into the
\texttt{liferay\_company\_id} value in \texttt{server\_context.xml}.

The \texttt{liferay\_group\_id} value is the ID of the site your app
needs to communicate with. To find this value, first go to the site in
your Liferay DXP instance that you want your app to communicate with. In
the \emph{Site Administration} menu, select \emph{Configuration} →
\emph{Site Settings}. The site ID is listed at the top of the
\emph{General} tab. Copy and paste this value into the
\texttt{liferay\_group\_id} value in \texttt{server\_context.xml}.

The \texttt{liferay\_portal\_version} value \texttt{71} tells Screens
that it's communicating with a Liferay CE Portal 7.1 or Liferay DXP 7.1
instance. Here are the supported \texttt{liferay\_portal\_version}
values and the portal versions they correspond to:

\begin{itemize}
\tightlist
\item
  \texttt{71}: Liferay CE Portal 7.1 or Liferay DXP 7.1
\item
  \texttt{70}: Liferay CE Portal 7.0 or Liferay DXP 7.0
\item
  \texttt{62}: Liferay Portal 6.2 CE/EE
\end{itemize}

You can also configure Screenlet properties in your
\texttt{server\_context.xml} file. The example properties listed below,
\texttt{liferay\_recordset\_id} and \texttt{liferay\_recordset\_fields},
enable DDL Form Screenlet and DDL List Screenlet to interact with a
Liferay DXP instance's DDLs. You can see an additional example
\texttt{server\_context.xml} file
\href{https://github.com/liferay/liferay-screens/blob/master/android/samples/bankofwesteros/src/main/res/values/server_context.xml}{here}.

\begin{verbatim}
<!-- Change these values for your Liferay DXP installation -->

<string name="liferay_recordset_id">20935</string>
<string name="liferay_recordset_fields">Title</string>
\end{verbatim}

Super! Your Android project's ready for Liferay Screens.

\subsection{Example Apps}\label{example-apps}

As you use Screens to develop your apps, you may want to refer to some
example apps that also use it. There are two demo applications
available:

\begin{itemize}
\tightlist
\item
  \href{https://github.com/liferay/liferay-screens/tree/master/android/samples/test-app}{test-app}:
  A showcase app containing all the currently available Screenlets.
\item
  \href{https://github.com/liferay/liferay-screens/tree/master/android/samples/bankofwesteros}{Westeros
  Bank}: An example app that uses Screenlets to manage technical issues
  for the \emph{Westeros Bank}. It's also available in
  \href{https://play.google.com/store/apps/details?id=com.liferay.mobile.screens.bankofwesteros}{Google
  Play}.
\end{itemize}

Great! Now you're ready to put Screens to use. The following tutorials
show you how to do this.

\subsection{Related Topics}\label{related-topics-209}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-screenlets-in-android-apps}{Using
Screenlets in Android Apps}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-views-in-android-screenlets}{Using
Views in Android Screenlets}

\href{/docs/7-1/tutorials/-/knowledge_base/t/preparing-ios-projects-for-liferay-screens}{Preparing
iOS Projects for Liferay Screens}

\section{Using Screenlets in Android
Apps}\label{using-screenlets-in-android-apps}

You can start using Screenlets once you've
\href{/docs/7-1/tutorials/-/knowledge_base/t/preparing-android-projects-for-liferay-screens}{prepared}
your project to use Liferay Screens. There are plenty of Liferay
Screenlets available and they're described in the Screenlet
\href{/docs/7-1/reference/-/knowledge_base/r/screenlets-in-liferay-screens-for-android}{reference
documentation}. It is very straightforward to use Screenlets. This
tutorial shows you how to insert Screenlets into your android app and
configure them. You'll be a Screenlet master in no time!

First, in Android Studio's visual layout editor or your favorite editor,
open your app's layout XML file and insert the Screenlet in your
activity or fragment layout. The following screenshot, for example,
shows the Login Screenlet inserted in an activity's
\texttt{FrameLayout}.

\begin{figure}
\centering
\includegraphics{./images/screens-android-insert-screenlet.png}
\caption{Here's the Login Screenlet in an activity's layout in Android
Studio.}
\end{figure}

Next, set the Screenlet's attributes. If it's a Liferay Screenlet, refer
to the Screenlet
\href{/docs/7-1/reference/-/knowledge_base/r/screenlets-in-liferay-screens-for-android}{reference
documentation} to learn the Screenlet's required and supported
attributes. This screenshot shows the attributes of the Login Screenlet
being set:

\begin{figure}
\centering
\includegraphics{./images/screens-android-screenlet-attributes.png}
\caption{You can set a Screenlet's attributes via the app's layout XML
file.}
\end{figure}

To configure your app to listen for events the Screenlet triggers,
implement the Screenlet's listener interface in your activity or
fragment class. Refer to the Screenlet's documentation to learn its
listener interface. Then register your activity or fragment as the
Screenlet's listener. The activity class, for example, in the screenshot
below, declares that it implements the Login Screenlet's
\texttt{LoginListener} interface, and it registers itself to listen for
the Screenlet's events.

\begin{figure}
\centering
\includegraphics{./images/screens-android-screenlet-listener.png}
\caption{Implement the Screenlet's listener in your activity or fragment
class.}
\end{figure}

Make sure to implement all methods required by the Screenlet's listener
interface. For Liferay's Screenlets, the listener methods are listed in
each Screenlet's
\href{/docs/7-1/reference/-/knowledge_base/r/screenlets-in-liferay-screens-for-android}{reference
documentation}. That's all there is to it! Awesome! Now you know how to
use Screenlets in your Android apps.

\textbf{Related Topics}

\href{/docs/7-1/tutorials/-/knowledge_base/t/preparing-android-projects-for-liferay-screens}{Preparing
Android Projects for Liferay Screens}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-views-in-android-screenlets}{Using
Views in Android Screenlets}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-android-screenlets}{Creating
Android Screenlets}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-screenlets-in-ios-apps}{Using
Screenlets in iOS apps}

\section{Using Views in Android
Screenlets}\label{using-views-in-android-screenlets}

You can use a Liferay Screens \emph{View} to set a Screenlet's look and
feel independent of the Screenlet's core functionality. Liferay's
Screenlets come with several Views, and more are being developed by
Liferay and the community.
\href{/docs/7-1/reference/-/knowledge_base/r/screenlets-in-liferay-screens-for-android}{The
Screenlet reference documentation} lists the Views available for each
Screenlet included with Screens. This tutorial shows you how to use
Views in Android Screenlets. It's straightforward; you'll master using
Views in no time!

\subsection{Views and View Sets}\label{views-and-view-sets}

Before using Views, you should know what components make them up. Note
that what follows is a simple description, sufficient for learning how
to use different Views. For a detailed description of the View layer in
Liferay Screens, see the tutorial
\href{/docs/7-1/tutorials/-/knowledge_base/t/architecture-of-liferay-screens-for-android}{Architecture
of Liferay Screens for Android}.

A View consists of the following items:

\textbf{Screenlet class:} A Java class that coordinates and implements
the Screenlet's functionality. The Screenlet class contains attributes
for configuring the Screenlet's behavior, a reference to the Screenlet's
View class, methods for invoking server operations, and more.

\textbf{View class:} A Java class that implements a View's behavior.
This class usually listens for the UI components' events.

\textbf{Layout:} An XML file that defines a View's UI components. The
View class is usually this file's root element. To use a View, you must
specify its layout in the Screenlet XML (you'll see an example of this
shortly).

Note that because it contains a Screenlet class and a specific set of UI
components, a View can only be used with one particular Screenlet. For
example, the Default View for Login Screenlet can only be used with
Login Screenlet. Multiple Views for several Screenlets can be combined
into a \emph{View Set}. A View Set typically implements a similar look
and feel for several Screenlets. This lets an app use a View Set to
present a cohesive look and feel. For example,
\href{https://github.com/liferay/liferay-screens/tree/master/android/samples/bankofwesteros}{the
Bank of Westeros sample app} uses the
\href{https://github.com/liferay/liferay-screens/tree/master/android/viewsets/westeros/src/main}{Westeros
View Set's} Views with several Screenlets to present the red and white
motif you can see
\href{https://play.google.com/store/apps/details?id=com.liferay.mobile.screens.bankofwesteros}{here
on Google Play}. Liferay Screens for Android comes with the Default View
Set, but Liferay makes additional View Sets (e.g., Material, Lexicon,
and Westeros) available in jCenter. Anyone can create View Sets and
publish them in public repositories like Maven Central and jCenter.

To install View Sets besides Default, add them as dependencies in your
project. The \texttt{build.gradle} file code snippet here specifies the
Material, Lexicon, and Westeros View Sets as dependencies:

\begin{verbatim}
dependencies {
    ...
    implementation 'com.liferay.mobile:liferay-material-viewset:+'
    implementation 'com.liferay.mobile:liferay-lexicon-viewset:+'   
    implementation 'com.liferay.mobile:liferay-westeros-viewset:+'
    ...
}
\end{verbatim}

Here are the View Sets that Liferay currently provides for Screens:

\textbf{Default:} Comes standard with a Screenlet. It's used by a
Screenlet if no layout ID is specified or if no View is found with the
layout ID. The Default Views can be used as parent Views for your custom
Views. Refer to the
\href{/docs/7-1/tutorials/-/knowledge_base/t/architecture-of-liferay-screens-for-android}{architecture
tutorial} for more details.

\textbf{Material:} Demonstrates Views built from scratch. It follows
Google's
\href{https://developer.android.com/design/material/index.html}{Material
Design} guidelines. Refer to the
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-android-views}{View
creation tutorial} for instructions on creating your own Views.

\textbf{Lexicon:} Demonstrates Views built from scratch. It follows
Liferay's \href{https://lexicondesign.io/}{Lexicon Design} guidelines.

\textbf{Westeros:} Customizes the behavior and appearance of the
\href{https://github.com/liferay/liferay-screens/tree/master/android/samples/bankofwesteros}{Westeros
Bank} demo app.

Now that you know about Views and View Sets, you're ready to put them to
use!

\subsection{Using Views}\label{using-views}

To use a View in a Screenlet, specify the View's layout as the
\texttt{liferay:layoutId} attribute's value when inserting the Screenlet
XML in an activity or fragment layout. For example, to use Login
Screenlet with its Material View, insert the Screenlet's XML with
\texttt{liferay:layoutId} set to \texttt{@layout/login\_material}:

\begin{verbatim}
<com.liferay.mobile.screens.auth.login.LoginScreenlet
    android:id="@+id/login_screenlet"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    liferay:layoutId="@layout/login_material"
    />
\end{verbatim}

The following links list the View layouts available in each View Set:

\begin{itemize}
\tightlist
\item
  \href{https://github.com/liferay/liferay-screens/tree/master/android/library/src/main/res/layout}{Default}
\item
  \href{https://github.com/liferay/liferay-screens/tree/master/android/viewsets/material/src/main/res/layout}{Material}
\item
  \href{https://github.com/liferay/liferay-screens/tree/master/android/viewsets/lexicon/src/main/res/layout}{Lexicon}
\item
  \href{https://github.com/liferay/liferay-screens/tree/master/android/viewsets/westeros/src/main/res/layout}{Westeros}
\end{itemize}

If the View you want to use is part of a View Set, your app or
activity's theme must also inherit the theme that defines that View
Set's styles. For example, the following code in an app's
\texttt{res/values/styles.xml} tells \texttt{AppTheme.NoActionBar} to
use the Material View Set as its parent theme:

\begin{verbatim}
<resources>

    <style name="AppTheme.NoActionBar" parent="material_theme">
        <item name="colorPrimary">@color/colorPrimary</item>
        <item name="colorPrimaryDark">@color/colorPrimaryDark</item>
        <item name="colorAccent">@color/colorAccent</item>

        <item name="windowActionBar">false</item>
        <item name="windowNoTitle">true</item>
    </style>
    ...
</resources>
\end{verbatim}

To use the Default, Lexicon, or Westeros View Set, inherit
\texttt{default\_theme}, \texttt{lexicon\_theme} or
\texttt{westeros\_theme}, respectively.

That's it! Great! Now you know how to use Views to spruce up your
Android Screenlets. This opens up a world of possibilities, like
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-android-views}{writing
your own Views}.

\subsection{Related Topics}\label{related-topics-210}

\href{/docs/7-1/tutorials/-/knowledge_base/t/preparing-android-projects-for-liferay-screens}{Preparing
Android Projects for Liferay Screens}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-screenlets-in-android-apps}{Using
Screenlets in Android Apps}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-android-views}{Creating
Android Views}

\href{/docs/7-1/tutorials/-/knowledge_base/t/architecture-of-liferay-screens-for-android}{Architecture
of Liferay Screens for Android}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-themes-in-ios-screenlets}{Using
Themes in iOS Screenlets}

\section{Using Offline Mode in
Android}\label{using-offline-mode-in-android}

Offline mode in Liferay Screens lets your apps function when
connectivity is unavailable or intermittent. Even though the steady
march of technology makes connections more stable and prevalent, there
are still plenty of places the Internet has trouble reaching. Areas with
complex terrain, including cities with large buildings, often lack
stable connections. Remote areas typically don't have connections at
all. Using Screens's offline mode in your apps gives your users
flexibility in these situations.

This tutorial shows you how to use offline mode in Screenlets. For an
explanation of how offline mode works, see the tutorial
\href{/docs/7-1/tutorials/-/knowledge_base/t/architecture-of-offline-mode-in-liferay-screens}{Architecture
of Offline Mode in Liferay Screens}. Offline mode's architecture is the
same on iOS and Android, although its use on these platforms differs.

\subsection{Configuring Screenlets for Offline
Mode}\label{configuring-screenlets-for-offline-mode}

If you want to enable offline mode in any of your screenlets, you must
configure the \texttt{offlinePolicy} attribute when inserting the
Screenlet's XML in a layout. This attribute can take four possible
values:

\begin{itemize}
\tightlist
\item
  \texttt{REMOTE\_ONLY}
\item
  \texttt{CACHE\_ONLY}
\item
  \texttt{REMOTE\_FIRST}
\item
  \texttt{CACHE\_FIRST}
\end{itemize}

For a description of these values, see the section
\href{/docs/7-1/tutorials/-/knowledge_base/t/architecture-of-offline-mode-in-liferay-screens\#using-policies-with-offline-mode}{Using
Policies with Offline Mode} in the offline mode architecture tutorial.
Note that each Screenlet behaves a bit differently with offline mode.
For specific details, see the
\href{/docs/7-1/reference/-/knowledge_base/r/screenlets-in-liferay-screens-for-android}{Screenlet
reference documentation}.

\subsection{Handling Synchronization}\label{handling-synchronization}

Under some scenarios, values stored in the local cache need to be
synchronized with the portal. To do this, you need to use the
\texttt{CacheSyncService} class. This class sends information from the
local cache to the portal. To register \texttt{CacheSyncService} with
your app, you must add the following code to your
\texttt{AndroidManifest.xml} file:

\begin{verbatim}
<receiver android:name=".CacheReceiver">
    <intent-filter>
        <action android:name="com.liferay.mobile.screens.auth.login.success"/>
        <action android:name="com.liferay.mobile.screens.cache.resync"/>
        <action android:name="android.net.conn.CONNECTIVITY_CHANGE"/>
    </intent-filter>
</receiver>

<service
    android:name=".CacheSyncService"
    android:exported="false"/>
\end{verbatim}

This code registers the \texttt{CacheReceiver} and
\texttt{CacheSyncService} components. The \texttt{CacheReceiver} is
invoked in the following scenarios:

\begin{itemize}
\tightlist
\item
  When a connectivity change occurs (for example, when the network
  connection is restored).
\item
  When Login Screenlet successfully completes the login.
\item
  When a specific \texttt{resync} intent is broadcasted. In this case,
  use
  \texttt{context.sendBroadcast(new\ Intent("com.liferay.mobile.screens.cache.resync"));}.
\end{itemize}

The \texttt{CacheSyncService} performs the synchronization process when
invoked from the above receiver. This is currently an unassisted
process. Future versions will include some kind of control mechanism.

\subsection{Related Topics}\label{related-topics-211}

\href{/docs/7-1/tutorials/-/knowledge_base/t/architecture-of-offline-mode-in-liferay-screens}{Architecture
of Offline Mode in Liferay Screens}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-screenlets-in-android-apps}{Using
Screenlets in Android Apps}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-offline-mode-in-ios}{Using
Offline Mode in iOS}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-screenlets-in-ios-apps}{Using
Screenlets in iOS Apps}

\chapter{Architecture of Liferay Screens for
Android}\label{architecture-of-liferay-screens-for-android}

Liferay Screens applies architectural ideas from
\href{http://en.wikipedia.org/wiki/Model-view-presenter}{Model View
Presenter},
\href{http://en.wikipedia.org/wiki/Model_View_ViewModel}{Model View
ViewModel}, and \href{http://www.objc.io/issue-13/viper.html}{VIPER}.
Screens isn't considered a canonical implementation of these
architectures, because it isn't an app, but it borrows from them to
separate presentation layers from business-logic. This tutorial explains
Screen's high-level architecture, its components' low-level
architecture, and the Android Screenlet lifecycle. Now go ahead and get
started examining Screens's building blocks!

\section{High-Level Architecture}\label{high-level-architecture}

Liferay Screens for Android is composed of a Core, a Screenlet layer, a
View layer, Interactors, and Server Connectors. Interactors are
technically part of the core, but are worth covering separately. They
facilitate interaction with both local and remote data sources, as well
as communication between the Screenlet layer and the
\href{/docs/7-1/tutorials/-/knowledge_base/t/mobile-sdk}{Liferay Mobile
SDK}.

\begin{figure}
\centering
\includegraphics{./images/screens-android-architecture-01.png}
\caption{Here are the high-level components of Liferay Screens for
Android. The dashed arrow connectors represent a ``uses'' relationship,
in which a component uses the component its pointing to.}
\end{figure}

Each component is described below.

\textbf{Core:} includes all the base classes for developing other
Screens components. It's a micro-framework that lets developers write
their own Screenlets, Views, and Interactors.

\textbf{Screenlets:} Java view classes for inserting into any activity
or fragment view hierarchy. They render a selected layout in the runtime
and in Android Studio's visual editor and react to UI events, sending
any necessary server requests. You can set a Screenlet's properties from
its layout XML file and Java classes. The Screenlets bundled with
Liferay Screens are known collectively as the
\href{/docs/7-1/reference/-/knowledge_base/r/screenlets-in-liferay-screens-for-android}{Screenlet
Library}.

\textbf{Server Connectors:} a collection of classes that interact with
different Liferay DXP versions. These classes abstract away the
complexity of communicating with different versions. This allows the
developer to call API methods and the correct Interactor without
worrying about the specific Liferay DXP version.

\textbf{Interactors:} implement specific use cases for communicating
with servers. They can use local and remote data sources. Most
Interactors use the
\href{/docs/7-1/tutorials/-/knowledge_base/t/mobile-sdk}{Liferay Mobile
SDK} to exchange data with a Liferay instance. If a user action or use
case needs to execute more than one query on a local or remote store,
the sequence is done in the corresponding Interactor. If a Screenlet
supports more than one user action or use case, an Interactor must be
created for each. Interactors are typically bound to one specific
Liferay version, and instantiated by a Server Connector. Interactors run
in a background thread and can therefore perform intensive operations
without blocking the UI thread.

\textbf{Views:} a set of layouts and accompanying custom view classes
that present Screenlets to the user.

Next, the core layer is described in detail.

\subsection{Related Topics}\label{related-topics-212}

\href{/docs/7-1/tutorials/-/knowledge_base/t/core-layer}{Core Layer}

\href{/docs/7-1/tutorials/-/knowledge_base/t/screenlet-layer}{Screenlet
Layer}

\href{/docs/7-1/tutorials/-/knowledge_base/t/view-layer}{View Layer}

\href{/docs/7-1/tutorials/-/knowledge_base/t/screenlet-lifecycle}{Screenlet
Lifecycle}

\section{Core Layer}\label{core-layer}

The core layer is the micro-framework that lets developers write
Screenlets in a structured and isolated way. All Screenlets share a
common structure based on the core classes, but each Screenlet can have
a unique purpose and communication API.

\begin{figure}
\centering
\includegraphics{./images/screens-android-architecture-02.png}
\caption{Here's the core layer of Liferay Screens for Android.}
\end{figure}

Here are the core's main components:

\href{https://github.com/liferay/liferay-screens/blob/master/android/library/core/src/main/java/com/liferay/mobile/screens/base/interactor/Interactor.java}{\textbf{Interactor:}}
the base class for all Liferay Portal interactions and use cases that a
Screenlet supports. Interactors call services through the Liferay Mobile
SDK and receive responses asynchronously through the
\href{https://github.com/greenrobot/EventBus}{EventBus}, eventually
changing a View's state. Their actions can vary in complexity, from
performing simple algorithms to requesting data asynchronously from a
server or database. A Screenlet can have multiple Interactors, each
dedicated to supporting a specific operation.

\href{https://github.com/liferay/liferay-screens/blob/master/android/library/core/src/main/java/com/liferay/mobile/screens/base/BaseScreenlet.java}{\textbf{BaseScreenlet:}}
the base class for all Screenlet classes. It receives user events from a
Screenlet's View, instantiates and calls the Interactors, and then
updates the View with operation results. Classes that extend it can
override its
\href{http://www.oodesign.com/template-method-pattern.html}{template
methods}:

\begin{itemize}
\tightlist
\item
  \emph{createScreenletView:} typically inflates the Screenlet's View
  and gets the attribute values from the XML definition.
\item
  \emph{createInteractor:} instantiates an Interactor for the specified
  action. If a Screenlet only supports one Interactor type then that
  type of Interactor is always instantiated.
\item
  \emph{onUserAction:} runs the Interactor associated with the specified
  action.
\end{itemize}

\textbf{Screenlet View:} implements the Screenlet's UI. It's
instantiated by the Screenlet's \texttt{createScreenletView} method. It
renders a specific UI using standard layout files and updates the UI
with data changes. When developing your own Views that extend a parent
View, you can read the parent Screenlet's properties or call its methods
from this class.

\href{https://github.com/greenrobot/EventBus}{\textbf{EventBus:}}
notifies the Interactor when asynchronous operations complete. It
decouples the \texttt{AsyncTask} class instance from the activity life
cycle, to avoid problems typically associated with \texttt{AsyncTask}
instances.

\href{https://www.liferay.com/community/liferay-projects/liferay-mobile-sdk/overview}{\textbf{Liferay
Mobile SDK:}} calls a Liferay instance's remote services in a type-safe
and transparent way.

\href{https://github.com/liferay/liferay-screens/blob/master/android/library/core/src/main/java/com/liferay/mobile/screens/context/SessionContext.java}{\textbf{SessionContext:}}
a singleton class that holds the logged in user's session. Apps can use
an implicit login, invisible to the user, or a login that relies on
explicit user input to create the session. User logins can be
implemented with the
\href{/docs/7-1/reference/-/knowledge_base/r/loginscreenlet-for-android}{Login
Screenlet}. This is explained in detail
\href{/docs/7-1/tutorials/-/knowledge_base/t/accessing-the-liferay-session-in-android}{here}.

\href{https://github.com/liferay/liferay-screens/blob/master/android/library/core/src/main/java/com/liferay/mobile/screens/context/LiferayServerContext.java}{\textbf{LiferayServerContext:}}
a singleton object that holds server configuration parameters. It's
loaded from the \texttt{server\_context.xml} file, or from any other XML
file that overrides the keys defined in the
\texttt{server\_context.xml}.

\href{https://github.com/liferay/liferay-screens/blob/develop/android/library/core/src/main/res/values/server_context.xml}{\textbf{server\_context.xml:}}
specifies the default server, \texttt{companyId} (Liferay instance ID)
and \texttt{groupId} (site ID). You can also configure other Screens
parameters in this file, such as the current Liferay version (with the
attribute \texttt{liferay\_portal\_version}) or an alternative
\texttt{ServiceVersionFactory} to access custom backends.

\href{https://github.com/liferay/liferay-screens/blob/master/android/library/core/src/main/java/com/liferay/mobile/screens/context/LiferayScreensContext.java}{\textbf{LiferayScreensContext:}}
a singleton object that holds a reference to the application context.
It's used internally where necessary.

\href{https://github.com/liferay/liferay-screens/blob/develop/android/library/core/src/main/java/com/liferay/mobile/screens/util/ServiceVersionFactory.java}{\textbf{ServiceVersionFactory:}}
an interface that defines all the server operations supported in Liferay
Screens. This is created and accessed through a
\href{https://github.com/liferay/liferay-screens/blob/develop/android/library/core/src/main/java/com/liferay/mobile/screens/util/ServiceProvider.java}{\texttt{ServiceProvider}}
that creates the Server Connectors needed to interact with a specific
Liferay version. The \texttt{ServiceVersionFactory} is an implementation
of an
\href{https://en.wikipedia.org/wiki/Abstract_factory_pattern}{Abstract
Factory pattern}.

Now that you know what makes up the core layer, you're ready to learn
the Screenlet layer's details.

\subsection{Related Topics}\label{related-topics-213}

\href{/docs/7-1/tutorials/-/knowledge_base/t/high-level-architecture}{High-Level
Architecture}

\href{/docs/7-1/tutorials/-/knowledge_base/t/screenlet-layer}{Screenlet
Layer}

\href{/docs/7-1/tutorials/-/knowledge_base/t/view-layer}{View Layer}

\href{/docs/7-1/tutorials/-/knowledge_base/t/screenlet-lifecycle}{Screenlet
Lifecycle}

\section{Screenlet Layer}\label{screenlet-layer}

The Screenlet layer contains the Screenlets available in Liferay Screens
for Android. The following diagram uses Screenlet classes prefixed with
\emph{MyScreenlet} to show the Screenlet layer's relationship with the
core, View, and Interactor components.

\begin{figure}
\centering
\includegraphics{./images/screens-android-architecture-03.png}
\caption{This diagram illustrates the Android Screenlet layer's
relationship to other Screens components.}
\end{figure}

Screenlets are comprised of several Java classes and an XML descriptor
file:

\textbf{MyScreenletViewModel:} an interface that defines the attributes
shown in the UI. It typically accounts for all the input and output
values presented to the user. For instance,
\href{https://github.com/liferay/liferay-screens/blob/master/android/library/core/src/main/java/com/liferay/mobile/screens/auth/login/view/LoginViewModel.java}{\texttt{LoginViewModel}}
includes attributes like the user name and password. The Screenlet can
read the attribute values, invoke Interactor operations, and change
these values based on operation results.

\textbf{MyScreenlet:} a class that represents the Screenlet component
the app developer interacts with. It includes the following things:

\begin{itemize}
\tightlist
\item
  Attribute fields for configuring the Screenlet's behavior. They are
  read in the Screenlet's \texttt{createScreenletView} method and their
  default values can optionally be set there too.
\item
  A reference to the Screenlet's View, specified by the
  \texttt{liferay:layoutId} attribute's value. Note: a View must
  implement the Screenlet's \texttt{ViewModel} interface.
\item
  Any number of methods for invoking Interactor operations. You can
  optionally make them public for app developers to call. They can also
  handle UI events received in the view class through a regular listener
  (such as Android's \texttt{OnClickListener}) or events forwarded to
  the Screenlet via the \texttt{performUserAction} method.
\item
  An optional (but recommended) listener object for the Screenlet to
  call on a particular event.
\end{itemize}

\textbf{MyScreenletInteractor:} implements an end-to-end use case that
communicates with a server or consumes a Liferay service. It might
perform several intermediate steps. For example, it might send a request
to a server, compute a local value based on the response, and then send
this value to a different server. On completing an interaction, the
Interactor must notify its listeners, one of which is typically the
Screenlet class instance. The number of Interactors a Screenlet requires
depends on the number of server use cases it supports. For example, the
\href{https://github.com/liferay/liferay-screens/blob/master/android/library/core/src/main/java/com/liferay/mobile/screens/auth/login/LoginScreenlet.java}{Login
Screenlet} class only supports one use case (log in the user), so it has
only one Interactor. The
\href{https://github.com/liferay/liferay-screens/blob/master/android/library/core/src/main/java/com/liferay/mobile/screens/ddl/form/DDLFormScreenlet.java}{DDL
Forms Screenlet} class, however, supports several use cases (load the
form, load a record, submit the form, etc.), so it uses a different
Interactor class for each use case.

\textbf{MyScreenletConnector62} and \textbf{MyScreenletConnector70}: the
classes that create the Interactors required to communicate with a
specific Liferay version. The \texttt{ServiceProvider} creates a
singleton \texttt{ServiceVersionFactory} that returns the right
Connector.

\textbf{MyScreenletDefaultView:} a class that renders the Screenlet's UI
with the default layout. The class in Figure 3, for example, belongs to
the Default View set. The View object and the layout file communicate
using standard mechanisms, like a \texttt{findViewById} method or a
listener object. User actions are received by a specified listener (for
example, \texttt{OnClickListener}) and then passed to the Screenlet
object via the \texttt{performUserAction} method.

\textbf{myscreenlet\_default.xml:} an XML file that specifies how to
render the Screenlet's View. Here's a skeleton of a Screenlet's layout
XML file:

\begin{verbatim}
<?xml version="1.0" encoding="utf-8"?>
<com.your.package.MyScreenletView 
    xmlns:android="http://schemas.android.com/apk/res/android">

    <!-- Put your regular components here: EditText, Button, etc. -->

</com.your.package.MyScreenletView>
\end{verbatim}

Refer to the tutorial
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-android-screenlets}{Creating
Android Screenlets} for more Screenlet details. Next, the View layer's
details are described.

\subsection{Related Topics}\label{related-topics-214}

\href{/docs/7-1/tutorials/-/knowledge_base/t/high-level-architecture}{High-Level
Architecture}

\href{/docs/7-1/tutorials/-/knowledge_base/t/core-layer}{Core Layer}

\href{/docs/7-1/tutorials/-/knowledge_base/t/view-layer}{View Layer}

\href{/docs/7-1/tutorials/-/knowledge_base/t/screenlet-lifecycle}{Screenlet
Lifecycle}

\section{View Layer}\label{view-layer}

The View layer lets developers set a Screenlet's look and feel. Each
Screenlet's \texttt{liferay:layoutId} attribute specifies its View. A
View consists of a Screenlet class, view class, and layout XML file. The
layout XML file specifies the UI components, while the Screenlet class
and view class control the View's behavior. By inheriting one or more of
these View layer components from another View, the different View
\emph{types} allow varying levels of control over a Screenlet's UI
design and behavior.

There are several different View types:

\textbf{Themed:} presents the same structure as the current View, but
alters the theme colors and tints of the View's resources. All existing
Views can be themed with different styles. The View's colors reflect the
current value of the Android
\href{https://www.google.com/design/spec/style/color.html\#color-color-palette}{color
palette}. If you want to use one View Set with another View Set's
colors, you can use those colors in your app's theme
(e.g.~\texttt{colorPrimary\_default}, \texttt{colorPrimary\_material},
\texttt{colorPrimary\_westeros}).

\textbf{Child:} presents the same behavior and UI components as its
parent, but can change the UI components' appearance and position. A
Child View specifies visual changes in its own layout XML file; it
inherits the parent's view class and Screenlet class. It can't add or
remove any UI components. The parent must be a Full View. Creating a
Child View is ideal when you only need to make visual changes to an
existing View. For example, you might create a Child View for Login
Screenlet's Default View to set new positions and sizes for the standard
text boxes.

\textbf{Extended:} inherits the parent View's behavior and appearance,
but lets you change and add to both. You can do so by creating a custom
view class and a new layout XML file. An Extended View inherits all the
parent View's other classes, including its Screenlet, listeners, and
Interactors; if you need to customize any of them, you must create a
Full View to do so. An Extended View's parent must be a Full View.
Creating an Extended View is ideal for adding, removing, or changing an
existing View's UI components. For example, you can extend the Login
Screenlet's Default View to present different UI components for the user
name and password fields.

\textbf{Full:} provides a complete standalone View. It doesn't inherit
another View's UI components or behavior. When creating a Full View, you
must therefore create its Screenlet class, view class, and layout XML
file. You should create a Full View when you don't need to inherit
another View or when you need to alter the core behavior of a Screenlet
by customizing its listeners or calling custom Interactors. For example,
you could implement a Full View with a new Interactor for calling a
different Liferay Portal instance. Default Views are Full Views.

\begin{figure}
\centering
\includegraphics{./images/screens-android-architecture-04.png}
\caption{This diagram illustrates the View layer of Liferay Screens for
Android.}
\end{figure}

Liferay Screens Views are organized into \emph{View sets} that contain
Views for several Screenlets. Liferay's available View sets are listed
here:

\begin{itemize}
\item
  \href{https://github.com/liferay/liferay-screens/tree/master/android/library/core/src/main/java/com/liferay/mobile/screens/viewsets/defaultviews}{\emph{Default:}}
  a mandatory View Set supplied by Liferay. It's used by a Screenlet if
  no layout ID is specified or if no View is found with the layout ID.
  The Default View Set uses a neutral, flat white and blue design with
  standard UI components. In the
  \href{https://github.com/liferay/liferay-screens/tree/master/android/library/core/src/main/java/com/liferay/mobile/screens/auth/login}{Login
  Screenlet}, for example, the Default View uses standard text boxes for
  the user name and password, but the text boxes are styled with the
  Default View's flat white and blue design. You can customize this View
  Set's properties, such as its components' colors, positions, and
  sizes. See the Default View Set's
  \href{https://github.com/liferay/liferay-screens/blob/master/android/library/core/src/main/res/values/styles.xml}{\texttt{styles.xml}}
  file for specific values. Since the Default View Set contains Full
  Views, you can use them to create your own custom Child and Extended
  Views.
\item
  \href{https://github.com/liferay/liferay-screens/tree/master/android/viewsets/material}{\emph{Material:}}
  the View Set containing Views that conform to Android's
  \href{https://developer.android.com/design/material/index.html}{Material
  design guidelines}.
\item
  \href{https://github.com/liferay/liferay-screens/tree/master/android/viewsets/westeros}{\emph{Westeros:}}
  the View Set containing Views for the
  \href{https://github.com/liferay/liferay-screens/tree/master/android/samples/bankofwesteros}{Bank
  of Westeros} sample app.
\end{itemize}

For information on creating or customizing Views, see the tutorial
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-android-views}{Creating
Android Views}.

Great! Now you know how Liferay Screens for Android is composed.
However, there's something you should know before moving on: how
Screenlets interact with the Android life cycle.

\subsection{Related Topics}\label{related-topics-215}

\href{/docs/7-1/tutorials/-/knowledge_base/t/high-level-architecture}{High-Level
Architecture}

\href{/docs/7-1/tutorials/-/knowledge_base/t/core-layer}{Core Layer}

\href{/docs/7-1/tutorials/-/knowledge_base/t/screenlet-layer}{Screenlet
Layer}

\href{/docs/7-1/tutorials/-/knowledge_base/t/screenlet-lifecycle}{Screenlet
Lifecycle}

\section{Screenlet Lifecycle}\label{screenlet-lifecycle}

Liferay Screens automatically saves and restores Screenlets' states
using the Android SDK methods \texttt{onSaveInstanceState} and
\texttt{onRestoreInstanceState}. Each Screenlet uses a uniquely
generated identifier (\texttt{screenletId}) to assign action results to
action sources.

The Screenlets' states are restored after the \texttt{onCreate} and
\texttt{onStart} methods, as specified by the
\href{http://developer.android.com/training/basics/activity-lifecycle/recreating.html}{standard
Android lifecycle}. It's a best practice to execute Screenlet methods
inside the activity's \texttt{onResume} method; this helps assure that
actions and tasks find their destinations.

\subsection{Related Topics}\label{related-topics-216}

\href{/docs/7-1/tutorials/-/knowledge_base/t/high-level-architecture}{High-Level
Architecture}

\href{/docs/7-1/tutorials/-/knowledge_base/t/core-layer}{Core Layer}

\href{/docs/7-1/tutorials/-/knowledge_base/t/screenlet-layer}{Screenlet
Layer}

\href{/docs/7-1/tutorials/-/knowledge_base/t/view-layer}{View Layer}

\section{Architecture of Offline Mode in Liferay
Screens}\label{architecture-of-offline-mode-in-liferay-screens}

Mobile users may encounter difficulty getting or maintaining a network
connection at certain locations or times of day. Using offline mode with
Screenlets ensures that your app still functions in these situations.
You should note, however, that some difficulties may arise when using an
app offline. For example, allowing users to edit data in an app when
they're offline may cause synchronization conflicts with the portal when
they reconnect. By detailing how offline mode is implemented in Liferay
Screens, this tutorial helps you be aware of such difficulties and know
how to handle them.

\subsection{Understanding Offline Mode's
Basics}\label{understanding-offline-modes-basics}

Screenlets in Liferay Screens support the following phases:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Get information from the portal.
\item
  Show information to the user.
\item
  Collect the user's input (if necessary).
\item
  Send input to the portal (if necessary).
\end{enumerate}

The following diagram summarizes these phases:

\begin{figure}
\centering
\includegraphics{./images/screens-offline-01.png}
\caption{A Screenlet's basic phases when requesting and submitting data
to the portal.}
\end{figure}

Note that not all Screenlets need to execute each phase. For example,
the Web Content Display Screenlet only needs to retrieve and display
portal content. Conversely, Login Screenlet and Sign Up Screenlet only
need to handle user input. Only the most complex Screenlets, like the
DDL Form Screenlet and the User Portrait Screenlet, need to do both.

So what does all this have to do with offline mode? Liferay Screens's
offline infrastructure is a small layer of code that intercepts
information going to and coming from the portal. It stores this
information in a local data store for use when there's no Internet
connection. The following diagram illustrates this, with \emph{Local
cache} representing the local data store:

\begin{figure}
\centering
\includegraphics{./images/screens-offline-02.png}
\caption{This is the same diagram as before, with the addition of the
local cache for offline mode.}
\end{figure}

With offline mode enabled, any Screenlet can persist information
exchanged with the portal. You can also configure exactly how offline
mode works with the Screenlet you're using. You do this through
\emph{policies}.

\subsection{Using Policies with Offline
Mode}\label{using-policies-with-offline-mode}

Policies configure how a Screenlet behaves with offline mode when it
sends or receives data. The Screenlet adheres to the policy even if the
data operation fails. Screenlets support the following policies:

\textbf{remote-only:} The Screenlet only uses network connections to
load data. Screenlets functioned this way prior to the introduction of
offline mode. Use this policy when you want the Screenlet always to use
remote content. Your app won't work, however, if a network connection is
unavailable. Also, apps using this policy tend to be slower due to
network lag. Note that if the request succeeds, the Screenlet stores the
data in the local cache for later use.

\textbf{cache-only:} The Screenlet only uses local storage to load data
(it doesn't use the network connection). Use this policy when you want
the Screenlet to always use offline content. Note that in the app's
local cache, some portal data may not exist or may be outdated.

\textbf{remote-first:} The Screenlet first tries to use the network
connection to load data. If this fails, it then tries to load data from
local storage. Use this policy when you want the Screenlet to use the
latest portal data when there's a connection, but also want to support a
fallback mechanism when the connection is gone. Note that the Screenlet
may use outdated information when there's no connection. In many cases,
however, this is better than showing your users no information at all.

\textbf{cache-first:} The Screenlet first tries to load data from local
storage. If this fails, it then tries to use the network connection. Use
this policy when you want the Screenlet to optimize performance and
network efficiency. You can update data in a background process, or let
the user update on-demand (via an option, for example). Note that while
the information retrieved from local storage may be outdated, loading
times and bandwidth consumption are typically lower.

These policies behave a bit differently depending on the data's
direction. In other words, when a Screenlet set to a specific policy
retrieves information from the portal, it may behave differently than
when it submits information to the portal. As an example, consider the
possible scenarios for User Portrait Screenlet:

\begin{itemize}
\tightlist
\item
  When loading the portrait:

  \begin{itemize}
  \item
    \textbf{remote-only:} The Screenlet always attempts to load the
    portrait from the portal. If the request fails, the operation also
    fails.
  \item
    \textbf{cache-only}: The Screenlet always attempts to load the
    portrait from the local cache. The operation fails if the portrait
    doesn't exist there.
  \item
    \textbf{remote-first:} The Screenlet first attempts to load the
    portrait from the portal. If the request succeeds, the Screenlet
    stores the portrait locally for later use. If the request fails, the
    Screenlet tries to load the portrait from the local cache. If the
    local cache doesn't contain the portrait, the Screenlet can't load
    it, and calls the standard error handling code (call the delegate,
    use the default placeholder, etc\ldots).
  \item
    \textbf{cache-first:} The Screenlet first attempts to load the
    portrait from the local cache. If the portrait doesn't exist there,
    it's then requested from the server.
  \end{itemize}
\item
  When submitting the portrait:

  \begin{itemize}
  \item
    \textbf{remote-only:} The Screenlet first sends the new portrait to
    the portal. If the submission succeeds, the Screenlet also stores
    the portrait in the local cache. If the submission fails, the
    operation also fails.
  \item
    \textbf{cache-only}: The Screenlet only stores the portrait locally.
    The portrait may be loaded from the cache later, or synchronized
    with the portal.
  \item
    \textbf{remote-first:} The Screenlet first tries to send the new
    portrait to the portal. If this fails due to lack of network
    connectivity, the Screenlet stores the portrait in the local cache
    for later synchronization with the portal.
  \item
    \textbf{cache-first:} The screenlet first stores the new portrait
    locally, then sends it to the portal. If the submission fails, the
    Screenlet still stores the portrait locally, but the send operation
    fails.
  \end{itemize}
\end{itemize}

\subsection{Understanding
Synchronization}\label{understanding-synchronization}

Synchronization can be a tricky problem to solve. What initially seems
straightforward quickly evolves into scenarios where you're not sure
which version of the data to use. Having offline users complicates
things further. The following diagram illustrates how the Screenlet
retrieves and stores portal data.

\begin{figure}
\centering
\includegraphics{./images/screens-offline-03.png}
\caption{The Screenlet requests the resource from the portal and stores
it in the app's local cache.}
\end{figure}

When a user edits the data in the app, the Screenlet needs to send the
new data to the portal. But what happens if the user is offline? In this
case, the new data can't reach the portal and the local and portal data
are out-of-sync. In this scenario, the app has the new data while the
portal has the old data. The app's data in this synchronization state is
called the \emph{dirty version}. Put away your soap and washcloth. We
don't recommend giving your mobile device a bath. In this context, dirty
means that the data should be synchronized with the portal as soon as
possible. When the Screenlet synchronizes the dirty version, it removes
the dirty flag from the local data.

\begin{figure}
\centering
\includegraphics{./images/screens-offline-04.png}
\caption{The updated data is said to be dirty when the Screenlet can't
send it to the portal.}
\end{figure}

\begin{figure}
\centering
\includegraphics{./images/screens-offline-05.png}
\caption{The dirty flag is removed once synchronization completes.}
\end{figure}

There are other complicated synchronization states. For example, portal
data may change while out-of-sync with a Screenlet's local data. To
avoid data loss, the local data can't overwrite the portal data, and
vice versa. In this situation, the synchronization process produces a
conflict when it runs. The following diagram illustrates this.

\begin{figure}
\centering
\includegraphics{./images/screens-offline-06.png}
\caption{Users have changed the data independently in the app and in the
portal, causing a synchronization conflict.}
\end{figure}

The developer needs to resolve the conflict by choosing the local data
or portal data. Synchronization conflicts have four possible
resolutions:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{Keep the local version:} The Screenlet overwrites the portal
  data with the local data. This results in the local cache and the
  portal having the same version of the data (Version 2 in the above
  diagram).
\item
  \textbf{Keep remote version:} The Screenlet overwrites the local data
  with the portal data. This results in the local cache and the portal
  having the same version of the data (Version 3 in the above diagram).
\item
  \textbf{Discard:} The Screenlet removes the local data, and the portal
  data isn't overwritten.
\item
  \textbf{Ignore:} The Screenlet doesn't change any data. The next
  synchronization event reproduces the conflict.
\end{enumerate}

Great! Now that you know how offline mode works, you're ready to put it
to use.

\subsection{Related Topics}\label{related-topics-217}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-offline-mode-in-android}{Using
Offline Mode in Android}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-offline-mode-in-ios}{Using
Offline Mode in iOS}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-screenlets-in-android-apps}{Using
Screenlets in Android Apps}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-screenlets-in-ios-apps}{Using
Screenlets in iOS Apps}

\chapter{Creating Android Screenlets}\label{creating-android-screenlets}

\href{/docs/7-1/reference/-/knowledge_base/r/screenlets-in-liferay-screens-for-android}{The
Screenlets} that come with Liferay Screens cover common use cases for
mobile apps that use Liferay. They authenticate users, interact with
Dynamic Data Lists, view assets, and more. However, what if there's no
Screenlet for \emph{your} specific use case? No sweat! You can create
your own. Extensibility is a key strength of Liferay Screens.

This tutorial explains how to create your own Screenlets. As an example,
it references code from the sample
\href{https://github.com/liferay/liferay-screens/tree/master/android/samples/addbookmarkscreenlet}{Add
Bookmark Screenlet}, that saves bookmarks to Liferay's Bookmarks
portlet.

In general, you use the following steps to create Screenlets:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \hyperref[determining-your-screenlets-location]{Determine your
  Screenlet's location}. Where you create your Screenlet depends on how
  you'll use it.
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/creating-the-ui}{Create
  the Screenlet's UI (its View)}. Although this tutorial presents all
  the information you need to create a View for your Screenlet, you may
  first want to learn how to
  \href{/docs/7-1/tutorials/-/knowledge_base/t/creating-android-views}{create
  a View}. For more information on Views in general, see
  \href{/docs/7-1/tutorials/-/knowledge_base/t/using-views-in-android-screenlets}{the
  tutorial on using Views with Screenlets}.
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/creating-the-interactor}{Create
  the Screenlet's Interactor}. Interactors are Screenlet components that
  make server calls.
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/defining-the-attributes}{Define
  the Screenlet's attributes}. These are the XML attributes the app
  developer can set when inserting the Screenlet's XML. These attributes
  control aspects of the Screenlet's behavior. You'll add functionality
  to these attributes in the Screenlet class.
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/creating-the-screenlet-class}{Create
  the Screenlet class}. The Screenlet class is the Screenlet's central
  component. It controls the Screenlet's behavior and is the component
  the app developer interacts with when inserting a Screenlet.
\end{enumerate}

To understand the components that make up a Screenlet, you should first
learn the
\href{/docs/7-1/tutorials/-/knowledge_base/t/architecture-of-liferay-screens-for-android}{architecture
of Liferay Screens for Android}.

Without further ado, let the Screenlet creation begin!

\section{Determining Your Screenlet's
Location}\label{determining-your-screenlets-location}

Where you should create your Screenlet depends on how you plan to use
it. If you don't plan to reuse your Screenlet in another app or don't
want to redistribute it, create it in a new package inside your Android
app project. This lets you reference and access Liferay Screens's core,
in addition to all the View Sets you may have imported.

If you want to reuse your Screenlet in another app, create it in a new
Android application module. The tutorial
\href{/docs/7-1/tutorials/-/knowledge_base/t/packaging-your-screenlets}{Packaging
Android Screenlets} explains how to do this. When your Screenlet's
project is in place, you can start by creating the Screenlet's UI.

\section{Creating the UI}\label{creating-the-ui}

In Liferay Screens for Android, Screenlet UIs are called Views. Every
Screenlet must have at least one View. A View consists of the following
components:

\begin{itemize}
\item
  \textbf{The View Model interface:} Defines the methods the View needs
  to update the UI.
\item
  \textbf{A layout XML file:} Defines the UI components that the View
  presents to the end user.
\item
  \textbf{A View class:} Renders the UI, handles user interactions, and
  communicates with the Screenlet class. The View class implements the
  View Model interface.
\item
  \textbf{The Screenlet class:} Although technically part of a View, the
  Screenlet class depends on all the other Screenlet components. You
  therefore won't create the Screenlet class until the end of this
  tutorial.
\end{itemize}

\subsection{Creating the Screenlet's View Model and
Layout}\label{creating-the-screenlets-view-model-and-layout}

The first items to create for a Screenlet's View are its View Model
interface and layout. The following steps explain how:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  To define the methods that every Screenlet's View class must
  implement, Screens provides the
  \href{https://github.com/liferay/liferay-screens/blob/master/android/library/src/main/java/com/liferay/mobile/screens/base/view/BaseViewModel.java}{\texttt{BaseViewModel}
  interface}. Your View Model interface should extend
  \texttt{BaseViewModel} to define any additional methods needed by your
  Screenlet. This includes any getters and setters for the attributes
  you want to use.

  For example, Add Bookmark Screenlet needs attributes for each
  bookmark's URL and title. Its View Model interface,
  \texttt{AddBookmarkViewModel}, therefore, defines getters and setters
  for these attributes:

\begin{verbatim}
public interface AddBookmarkViewModel extends BaseViewModel {
    String getURL();

    void setURL(String value);

    String getTitle();

    void setTitle(String value);
}
\end{verbatim}
\item
  Define your Screenlet's UI by writing a standard Android layout XML
  file. The layout's root element should be the fully qualified class
  name of your Screenlet's View class. You'll create that class in the
  next step, but determine its name now and name the layout's root
  element after it. Finally, add any UI elements your View needs.

  For example, Add Bookmark Screenlet's layout needs two text fields:
  one for entering a bookmark's URL and one for entering its title. The
  layout also needs a button for saving the bookmark. The Screenlet
  defines this UI in its
  \href{https://github.com/liferay/liferay-screens/blob/master/android/samples/addbookmarkscreenlet/src/main/res/layout/bookmark_default.xml}{\texttt{bookmark\_default.xml}
  layout file}:

\begin{verbatim}
<?xml version="1.0" encoding="utf-8"?>
<com.your.package.AddBookmarkView 
    xmlns:android="http://schemas.android.com/apk/res/android"
    style="@style/default_screenlet">

    <EditText
        android:id="@+id/url"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_marginBottom="15dp"
        android:hint="URL Address"
        android:inputType="textUri"/>

    <EditText
        android:id="@+id/title"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_marginBottom="15dp"
        android:hint="Title"/>

    <Button
        android:id="@+id/add_button"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Add Bookmark"/>

</com.your.package.AddBookmarkView>
\end{verbatim}
\end{enumerate}

\begin{figure}
\centering
\includegraphics{./images/screens-android-add-bookmark-view.png}
\caption{Add Bookmark Screenlet's layout contains two text fields and a
button.}
\end{figure}

Next, you'll create your Screenlet's View class.

\subsection{Creating the Screenlet's View
Class}\label{creating-the-screenlets-view-class}

Your Screenlet needs a View class to support the layout you just
created. This class must extend an Android layout class
(e.g.~\texttt{LinearLayout}, \texttt{ListView}), implement your View
Model interface, and implement a separate listener interface to handle
user actions. Follow these steps to create this View class:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a View class that extends the Android layout class appropriate
  for your Screenlet's UI. For example, Add Bookmark Screenlet renders
  its UI components in a single column, so
  \href{https://github.com/liferay/liferay-screens/blob/master/android/samples/addbookmarkscreenlet/src/main/java/com/liferay/mobile/screens/bookmark/view/AddBookmarkView.java}{its
  View class (\texttt{AddBookmarkView})} extends
  \href{https://developer.android.com/reference/android/widget/LinearLayout.html}{Android's
  \texttt{LinearLayout}}. Your View class's constructors should call the
  parent layout class's constructors. For example,
  \href{https://github.com/liferay/liferay-screens/blob/master/android/samples/addbookmarkscreenlet/src/main/java/com/liferay/mobile/screens/bookmark/view/AddBookmarkView.java\#L20-L30}{\texttt{AddBookmarkView}'s
  constructors} call those of \texttt{LinearLayout}:

\begin{verbatim}
public AddBookmarkView(Context context) {
    super(context);
}

public AddBookmarkView(Context context, AttributeSet attributes) {
    super(context, attributes);
}

public AddBookmarkView(Context context, AttributeSet attributes, int defaultStyle) {
    super(context, attributes, defaultStyle);
}
\end{verbatim}
\item
  Add instance variables for your View Model's attributes and
  \texttt{BaseScreenlet}. For example, Add Bookmark Screenlet needs
  instance variables for a bookmark's URL and title. Because all
  Screenlet classes extend the
  \href{https://github.com/liferay/liferay-screens/blob/master/android/library/src/main/java/com/liferay/mobile/screens/base/BaseScreenlet.java}{\texttt{BaseScreenlet}
  class}, a \texttt{BaseScreenlet} variable in your View class ensures
  that your View always has a reference to the Screenlet. For example,
  here are \texttt{AddBookmarkView}'s instance variables:

\begin{verbatim}
private EditText urlText;
private EditText titleText;
private BaseScreenlet screenlet;
\end{verbatim}
\item
  Implement your View Model interface. Implement your View Model's
  getter and setter methods to get and set the inner value of each
  component, respectively. For example, here's
  \texttt{AddBookmarkView}'s implementation of
  \texttt{AddBookmarkViewModel}:

\begin{verbatim}
public String getURL() {
    return urlText.getText().toString();
}

public void setURL(String value) {
    urlText.setText(value);
}

public String getTitle() {
    return titleText.getText().toString();
}

public void setTitle(String value) {
    titleText.setText(value);
}
\end{verbatim}
\item
  Implement a listener interface to handle user actions in the
  Screenlet. For example, Add Bookmark Screenlet must detect when the
  user presses the save button. The \texttt{AddBookmarkView} class
  enables this by implementing
  \href{https://developer.android.com/reference/android/view/View.OnClickListener.html}{Android's
  \texttt{View.OnClickListener} interface}, which defines a single
  method: \texttt{onClick}. The Screenlet's \texttt{onClick}
  implementation gets a reference to the Screenlet and calls its
  \texttt{performUserAction()} method (you'll create
  \texttt{performUserAction()} in the Screenlet class shortly):

\begin{verbatim}
public void onClick(View v) {
    AddBookmarkScreenlet screenlet = (AddBookmarkScreenlet) getParent();

    screenlet.performUserAction();
}
\end{verbatim}

  You can set the listener to the appropriate UI element by implementing
  an \texttt{onFinishInflate()} method. This method should also retrieve
  and assign any other UI elements from your layout. For example, the
  \texttt{onFinishInflate()} implementation in \texttt{AddBookmarkView}
  retrieves the URL and title attributes from the layout, and sets them
  to the \texttt{urlText} and \texttt{titleText} variables,
  respectively. This method then retrieves the button from the layout
  and sets this View class as the button's click listener:

\begin{verbatim}
protected void onFinishInflate() {
    super.onFinishInflate();

    urlText = (EditText) findViewById(R.id.url);
    titleText = (EditText) findViewById(R.id.title_bookmark);

    Button addButton = (Button) findViewById(R.id.add_button);
    addButton.setOnClickListener(this);
}
\end{verbatim}
\item
  Implement
  \href{https://github.com/liferay/liferay-screens/blob/master/android/library/src/main/java/com/liferay/mobile/screens/base/view/BaseViewModel.java}{the
  \texttt{BaseViewModel} interface}'s methods:
  \texttt{showStartOperation}, \texttt{showFinishOperation},
  \texttt{showFailedOperation}, \texttt{getScreenlet}, and
  \texttt{setScreenlet}. In the \texttt{show*Operation} methods, you can
  log what happens in your Screenlet when the server operation starts,
  finishes successfully, or fails, respectively. In the
  \texttt{getScreenlet} and \texttt{setScreenlet} methods, you must get
  and set the \texttt{BaseScreenlet} variable, respectively. This
  ensures that the View always has a Screenlet reference. For example,
  Add Bookmark Screenlet implements these methods as follows:

\begin{verbatim}
@Override
public void showStartOperation(String actionName) {

}

@Override
public void showFinishOperation(String actionName) {
    LiferayLogger.i("Add bookmark successful");
}

@Override
public void showFailedOperation(String actionName, Exception e) {
    LiferayLogger.e("Could not add bookmark", e);
}

@Override
public BaseScreenlet getScreenlet() {
    return screenlet;
}

@Override
public void setScreenlet(BaseScreenlet screenlet) {
    this.screenlet = screenlet;
}
\end{verbatim}

  Note that although you must implement the
  \texttt{show{[}something{]}Operation} methods, you can leave their
  implementations empty if you don't need to take any specific action.
\end{enumerate}

\href{https://github.com/liferay/liferay-screens/blob/master/android/samples/addbookmarkscreenlet/src/main/java/com/liferay/mobile/screens/bookmark/view/AddBookmarkView.java}{Click
here} to see the complete example \texttt{AddBookmarkView} class.

Great! Your View class is finished. Now you're ready to create your
Screenlet's Interactor class.

\subsection{Related Topics}\label{related-topics-218}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-the-interactor}{Creating
the Interactor}

\href{/docs/7-1/tutorials/-/knowledge_base/t/defining-the-attributes}{Defining
the Attributes}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-the-screenlet-class}{Creating
the Screenlet Class}

\href{/docs/7-1/tutorials/-/knowledge_base/t/packaging-your-screenlets}{Packaging
Your Screenlets}

\section{Creating the Interactor}\label{creating-the-interactor}

A Screenlet's Interactor makes the service call to retrieve the data you
need from a Liferay instance. An Interactor is made up of several
components:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  The event class. This class lets you handle communication between the
  Screenlet's components via event objects that contain the server
  call's results. Screens uses the
  \href{https://greenrobot.github.io/EventBus/}{EventBus} library for
  this. Screens supplies the
  \href{https://github.com/liferay/liferay-screens/blob/master/android/library/src/main/java/com/liferay/mobile/screens/base/interactor/event/BasicEvent.java}{\texttt{BasicEvent}
  class} and
  \href{https://github.com/liferay/liferay-screens/blob/master/android/library/src/main/java/com/liferay/mobile/screens/base/list/interactor/BaseListEvent.java}{\texttt{BaseListEvent}
  class} for communicating \texttt{JSONObject} and \texttt{JSONArray}
  results within Screenlets, respectively. You can create your own event
  classes by extending \texttt{BasicEvent}. You should create your own
  event classes when you must communicate objects other than
  \texttt{JSONObject} or \texttt{JSONArray}. The example Add Bookmark
  Screenlet only needs to communicate \texttt{JSONObject} instances, so
  it uses \texttt{BasicEvent}.
\item
  The listener interface. This defines the methods the app developer
  needs to respond to the Screenlet's behavior. For example,
  \href{/docs/7-1/reference/-/knowledge_base/r/loginscreenlet-for-android\#listener}{Login
  Screenlet's listener} defines the \texttt{onLoginSuccess} and
  \texttt{onLoginFailure} methods. Screens calls these methods when
  login succeeds or fails, respectively. By implementing these methods
  in the activity or fragment class that contains the Screenlet, the app
  developer can respond to login success and failure. Similarly, the
  \href{https://github.com/liferay/liferay-screens/blob/master/android/samples/addbookmarkscreenlet/src/main/java/com/liferay/mobile/screens/bookmark/interactor/AddBookmarkListener.java}{example
  Add Bookmark Screenlet's listener interface} defines two methods: one
  for responding to the Screenlet's failure to add a bookmark and one
  for responding to its success to add a bookmark:

\begin{verbatim}
 public interface AddBookmarkListener {

     void onAddBookmarkFailure(Exception exception);

     void onAddBookmarkSuccess();
 }
\end{verbatim}
\item
  The Interactor class. This class must extend
  \href{https://github.com/liferay/liferay-screens/blob/master/android/library/src/main/java/com/liferay/mobile/screens/base/interactor/BaseRemoteInteractor.java}{Screens's
  \texttt{BaseRemoteInteractor}} with your listener and event as type
  arguments. The listener lets the Interactor class send the server
  call's results to any classes that implement the listener. In the
  implementation of the method that makes the server call, the
  \texttt{execute} method, you must
  \href{/docs/7-1/tutorials/-/knowledge_base/t/invoking-services-asynchronously-from-your-android-app}{use
  the Mobile SDK to make an asynchronous service call}. This means you
  must get a session and then make the server call. You make the server
  call by creating an instance of the Mobile SDK service (e.g.,
  \texttt{BookmarksEntryService}) that can call the Liferay service you
  need and then making the call. The Interactor class must also process
  the event object that contains the call's results and then notify the
  listener of those results. You do this by implementing the
  \texttt{onSuccess} and \texttt{onFailure} methods to invoke the
  corresponding \texttt{getListener()} methods.

  For example, the
  \href{https://github.com/liferay/liferay-screens/blob/master/android/samples/addbookmarkscreenlet/src/main/java/com/liferay/mobile/screens/bookmark/interactor/AddBookmarkInteractor.java}{\texttt{AddBookmarkInteractor}
  class} is Add Bookmark Screenlet's Interactor class. This class
  implements the \texttt{execute} method, which adds a bookmark to a
  folder in a Liferay instance's Bookmarks portlet. This method first
  validates the bookmark's URL and folder. It then calls the
  \texttt{getJSONObject} method to add the bookmark, and concludes by
  returning a new \texttt{BasicEvent} object created from the
  \texttt{JSONObject}. The \texttt{if} statement in the
  \texttt{getJSONObject} method checks the Liferay version so it can
  create the appropriate \texttt{BookmarksEntryService} instance needed
  to make the server call. Regardless of the Liferay version, the
  \texttt{getSession()} method retrieves the existing session created by
  Login Screenlet upon successful login. The session's \texttt{addEntry}
  method makes the server call. The Screenlet calls the
  \texttt{onSuccess} or \texttt{onFailure} method to notify the listener
  of the server call's success or failure, respectively. In either case,
  the \texttt{BasicEvent} object contains the server call's results.
  Since this Screenlet doesn't retrieve anything from the server,
  however, there's no need to process the \texttt{BasicEvent} object in
  the \texttt{onSuccess} method; calling the listener's
  \texttt{onAddBookmarkSuccess} method is sufficient. Here's the
  complete code for \texttt{AddBookmarkInteractor}:

\begin{verbatim}
 public class AddBookmarkInteractor extends BaseRemoteInteractor<AddBookmarkListener, BasicEvent> {

     @Override
     public BasicEvent execute(Object[] args) throws Exception {
         String url = (String) args[0];
         String title = (String) args[1];
         long folderId = (long) args[2];

         validate(url, folderId);

         JSONObject jsonObject = getJSONObject(url, title, folderId);
         return new BasicEvent(jsonObject);
     }

     @Override
     public void onSuccess(BasicEvent event) throws Exception {
         getListener().onAddBookmarkSuccess();
     }

     @Override
     public void onFailure(BasicEvent event) {
         getListener().onAddBookmarkFailure(event.getException());
     }

     private void validate(String url, long folderId) {
         if (url == null || url.isEmpty() || !URLUtil.isValidUrl(url)) {
             throw new IllegalArgumentException("Invalid url");
         } else if (folderId == 0) {
             throw new IllegalArgumentException("folderId not set");
         }
     }

     @NonNull
     private JSONObject getJSONObject(String url, String title, long folderId) throws Exception {
         if (LiferayServerContext.isLiferay7()) {
             return new BookmarksEntryService(getSession()).addEntry(LiferayServerContext.getGroupId(), 
                 folderId, title, url, "", null);
         } else {
             return new com.liferay.mobile.android.v62.bookmarksentry.BookmarksEntryService(
                 getSession()).addEntry(LiferayServerContext.getGroupId(), folderId, title, url, "", null);
         }
     }
 }
\end{verbatim}
\end{enumerate}

Sweetness! Your Screenlet's Interactor is done. Next, you'll create the
Screenlet class.

\subsection{Related Topics}\label{related-topics-219}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-the-ui}{Creating
the UI}

\href{/docs/7-1/tutorials/-/knowledge_base/t/defining-the-attributes}{Defining
the Attributes}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-the-screenlet-class}{Creating
the Screenlet Class}

\href{/docs/7-1/tutorials/-/knowledge_base/t/packaging-your-screenlets}{Packaging
Your Screenlets}

\section{Defining the Attributes}\label{defining-the-attributes}

Before creating the Screenlet class, you should define its attributes.
These are the attributes the app developer can set when inserting the
Screenlet's XML in an activity or fragment layout. For example, to use
\href{/docs/7-1/reference/-/knowledge_base/r/loginscreenlet-for-android}{Login
Screenlet}, the app developer could insert the following Login Screenlet
XML in an activity or fragment layout:

\begin{verbatim}
<com.liferay.mobile.screens.auth.login.LoginScreenlet
    android:id="@+id/login_screenlet"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    app:basicAuthMethod="email"
    app:layoutId="@layout/login_default"
    />
\end{verbatim}

The app developer can set the \texttt{liferay} attributes
\texttt{basicAuthMethod} and \texttt{layoutId} to set Login Screenlet's
authentication method and View, respectively. The Screenlet class reads
these settings to enable the appropriate functionality.

When creating a Screenlet, you can define the attributes you want to
make available to app developers. You do this in an XML file inside your
Android project's \texttt{res/values} directory. For example, Add
Bookmark Screenlet's attributes are defined in the
\href{https://github.com/liferay/liferay-screens/blob/master/android/samples/addbookmarkscreenlet/src/main/res/values/bookmark_attrs.xml}{Screenlet's
\texttt{bookmark\_attrs.xml} file}:

\begin{verbatim}
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <declare-styleable name="AddBookmarkScreenlet">
        <attr name="layoutId"/>
        <attr name="folderId"/>
        <attr name="defaultTitle" format="string"/>
    </declare-styleable>
</resources>
\end{verbatim}

This defines the attributes \texttt{layoutId}, \texttt{folderId}, and
\texttt{defaultTitle}. Add Bookmark Screenlet's Screenlet class adds
functionality to these attributes. Here's a brief description of what
each does:

\begin{itemize}
\item
  \texttt{layoutId}: Sets the View that displays the Screenlet. This
  functions the same as the \texttt{layoutId} attribute in
  \href{/docs/7-1/reference/-/knowledge_base/r/screenlets-in-liferay-screens-for-android}{Liferay's
  existing Screenlets}.
\item
  \texttt{folderId}: Sets the folder ID in the Bookmarks portlet where
  the Screenlet adds bookmarks.
\item
  \texttt{defaultTitle}: Sets each Bookmark's default title.
\end{itemize}

Now that you've defined your Screenlet's attributes, you're ready to
create the Screenlet class.

\subsection{Related Topics}\label{related-topics-220}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-the-ui}{Creating
the UI}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-the-interactor}{Creating
the Interactor}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-the-screenlet-class}{Creating
the Screenlet Class}

\href{/docs/7-1/tutorials/-/knowledge_base/t/packaging-your-screenlets}{Packaging
Your Screenlets}

\section{Creating the Screenlet
Class}\label{creating-the-screenlet-class}

The Screenlet class is the central hub of a Screenlet. It contains
attributes for configuring the Screenlet's behavior, a reference to the
Screenlet's View, methods for invoking Interactor operations, and more.
When using a Screenlet, app developers primarily interact with its
Screenlet class. In other words, if a Screenlet were to become
self-aware, it would happen in its Screenlet class (though we're
reasonably confident this won't happen).

To make all this possible, your Screenlet class must implement the
Interactor's listener interface and extend
\href{https://github.com/liferay/liferay-screens/blob/master/android/library/src/main/java/com/liferay/mobile/screens/base/BaseScreenlet.java}{Screens's
\texttt{BaseScreenlet} class} with the View Model interface and
Interactor class as type arguments. Your Screenlet class should also
contain instance variables and accompanying getters and setters for the
listener and any other attributes that the app developer needs to
access. For constructors, you can call
\href{https://github.com/liferay/liferay-screens/blob/master/android/library/src/main/java/com/liferay/mobile/screens/base/BaseScreenlet.java\#L45-L61}{\texttt{BaseScreenlet}'s
constructors}.

For example,
\href{https://github.com/liferay/liferay-screens/blob/master/android/samples/addbookmarkscreenlet/src/main/java/com/liferay/mobile/screens/bookmark/AddBookmarkScreenlet.java}{Add
Bookmark Screenlet's Screenlet class} extends
\texttt{BaseScreenlet\textless{}AddBookmarkViewModel,\ AddBookmarkInteractor\textgreater{}}
and implements \texttt{AddBookmarkListener}. It also contains instance
variables for \texttt{AddBookmarkListener} and the bookmark's folder ID,
and getters and setters for these variables. Also note the constructors
call \texttt{BaseScreenlet}'s constructors:

\begin{verbatim}
public class AddBookmarkScreenlet extends 
    BaseScreenlet<AddBookmarkViewModel, AddBookmarkInteractor>
    implements AddBookmarkListener {

    private long folderId;
    private AddBookmarkListener listener;

    public AddBookmarkScreenlet(Context context) {
        super(context);
    }

    public AddBookmarkScreenlet(Context context, AttributeSet attributes) {
        super(context, attributes);
    }

    public AddBookmarkScreenlet(Context context, AttributeSet attributes, int defaultStyle) {
        super(context, attributes, defaultStyle);
    }

    public long getFolderId() {
        return folderId;
    }

    public void setFolderId(long folderId) {
        this.folderId = folderId;
    }

    public AddBookmarkListener getListener() {
        return listener;
    }

    public void setListener(AddBookmarkListener listener) {
        this.listener = listener;
    }

    ...
\end{verbatim}

Next, implement the Screenlet's listener methods. This lets the
Screenlet class receive the server call's results and thus act as the
listener. These methods should communicate the server call's results to
the View (via the View Model) and any other listener instances (via the
Screenlet class's listener instance). For example, here are Add Bookmark
Screenlet's listener method implementations:

\begin{verbatim}
public void onAddBookmarkSuccess() {
    getViewModel().showFinishOperation(null);

    if (listener != null) {
        listener.onAddBookmarkSuccess();
    }
}

public void onAddBookmarkFailure(Exception e) {
    getViewModel().showFailedOperation(null, e);

    if (listener != null) {
        listener.onAddBookmarkFailure(e);
    }
}
\end{verbatim}

These methods are called when the server call succeeds or fails,
respectively. They first use \texttt{getViewModel()} to get a View Model
instance and then call the \texttt{BaseViewModel} methods
\texttt{showFinishOperation} and \texttt{showFailedOperation} to send
the server call's results to the View. The \texttt{showFinishOperation}
call sends \texttt{null} because a successful server call to add a
bookmark doesn't return any objects. If a successful server call in your
Screenlet returns any objects you need to display, then you should send
them in this \texttt{showFinishOperation} call. The
\texttt{showFailedOperation} call sends the \texttt{Exception} that
results from a failed server call to the View. This lets you display an
informative error to the user. The \texttt{onAddBookmarkSuccess} and
\texttt{onAddBookmarkFailure} implementations then call the listener
instance's method of the same name. This sends the server call's results
to any other classes that implement the listener interface, such as the
activity or fragment that uses the Screenlet.

Next, you must implement \texttt{BaseScreenlet}'s abstract methods:

\begin{itemize}
\item
  \texttt{createScreenletView}: Reads the app developer's Screenlet
  attribute settings, and inflates the View. You'll use an
  \href{https://developer.android.com/reference/android/content/res/TypedArray.html}{Android
  \texttt{TypedArray}} to retrieve the attribute settings. You should
  set the attribute values to the appropriate variables, and set any
  default values you need to display via a View Model reference.

  For example, Add Bookmark Screenlet's \texttt{createScreenletView}
  method gets the app developer's attribute settings via a
  \texttt{TypedArray}. This includes the \texttt{layoutId},
  \texttt{defaultTitle}, and \texttt{folderId} attributes. The
  \texttt{layoutId} is used to inflate a View reference (\texttt{view}),
  which is then cast to a View Model instance (\texttt{viewModel}). The
  View Model instance's \texttt{setTitle} method is then called with
  \texttt{defaultTitle} to set the bookmark's default title. The method
  concludes by returning the View reference.

\begin{verbatim}
  @Override
  protected View createScreenletView(Context context, AttributeSet attributes) {
      TypedArray typedArray = context.getTheme()
          .obtainStyledAttributes(attributes, R.styleable.AddBookmarkScreenlet, 0, 0);

      int layoutId = typedArray.getResourceId(R.styleable.AddBookmarkScreenlet_layoutId, 0);

      View view = LayoutInflater.from(context).inflate(layoutId, null);

      String defaultTitle = typedArray.getString(R.styleable.AddBookmarkScreenlet_defaultTitle);

      folderId = castToLong(typedArray.getString(R.styleable.AddBookmarkScreenlet_folderId));

      typedArray.recycle();

      AddBookmarkViewModel viewModel = (AddBookmarkViewModel) view;
      viewModel.setTitle(defaultTitle);

      return view;
  }
\end{verbatim}
\item
  \texttt{createInteractor}: Instantiates the Screenlet's Interactor.
  For example, Add Bookmark Screenlet's \texttt{createInteractor} method
  calls the \texttt{AddBookmarkInteractor} constructor to create a new
  instance of this Interactor:

\begin{verbatim}
  @Override
  protected AddBookmarkInteractor createInteractor(String actionName) {
      return new AddBookmarkInteractor(getScreenletId());
  }
\end{verbatim}
\item
  \texttt{onUserAction}: Retrieves any data the user has entered in the
  View, and starts the Screenlet's server operation via an Interactor
  instance. If your Screenlet doesn't take user input, this method only
  needs to do the latter.

  The example Add Bookmark Screenlet takes user input (the bookmark's
  URL and title), so its \texttt{onUserAction} method must retrieve this
  data. This method does so via a View Model instance it retrieves with
  the \texttt{getViewModel()} method. The \texttt{onUserAction} method
  starts the server operation by calling the Interactor's \texttt{start}
  method with the user input. Note that the Interactor inherits the
  \texttt{start} method from the
  \href{https://github.com/liferay/liferay-screens/blob/master/android/library/src/main/java/com/liferay/mobile/screens/base/interactor/BaseInteractor.java}{\texttt{BaseInteractor}
  class}. Invoking the \texttt{start} method causes the Interactor's
  \texttt{execute} method to run in a background thread:

\begin{verbatim}
  @Override
  protected void onUserAction(String userActionName, AddBookmarkInteractor interactor, Object... args) {
      AddBookmarkViewModel viewModel = getViewModel();
      String url = viewModel.getURL();
      String title = viewModel.getTitle();

      interactor.start(url, title, folderId);
  }
\end{verbatim}
\end{itemize}

Nice! Your Screenlet is finished! You can now use it
\href{/docs/7-1/tutorials/-/knowledge_base/t/using-screenlets-in-android-apps}{the
same way you would any other}. If you created your Screenlet in its own
project, you can also
\href{/docs/7-1/tutorials/-/knowledge_base/t/packaging-your-screenlets}{package
and distribute} it via the Screens project, JCenter, or Maven Central.

To finish the Add Bookmark Screenlet example, the following section
shows you how to use this Screenlet. It also shows how you can set
default attribute values in an app's \texttt{server\_context.xml} file.
Although you may not need to do this when using your Screenlets, it
might come in handy on your way to becoming a master of Screenlets.

\subsection{Related Topics}\label{related-topics-221}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-the-ui}{Creating
the UI}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-the-interactor}{Creating
the Interactor}

\href{/docs/7-1/tutorials/-/knowledge_base/t/defining-the-attributes}{Defining
the Attributes}

\href{/docs/7-1/tutorials/-/knowledge_base/t/packaging-your-screenlets}{Packaging
Your Screenlets}

\section{Using Your Screenlet}\label{using-your-screenlet}

To use any Screenlet, you must follow these
\href{/docs/7-1/tutorials/-/knowledge_base/t/using-screenlets-in-android-apps}{general
steps}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Insert the Screenlet's XML in the activity or fragment layout you want
  the Screenlet to appear in. You can fine-tune the Screenlet's behavior
  by setting the Screenlet XML's attributes.
\item
  Implement the Screenlet's listener in the activity or fragment class.
\end{enumerate}

As an example of this, the Liferay Screens
\href{https://github.com/liferay/liferay-screens/tree/master/android/samples/test-app}{Test
App} uses Add Bookmark Screenlet. You can find the following Add
Bookmark Screenlet XML in the
\href{https://github.com/liferay/liferay-screens/blob/master/android/samples/test-app/src/main/res/layout/add_bookmark.xml}{Test
App's \texttt{add\_bookmark.xml} layout}:

\begin{verbatim}
<com.liferay.mobile.screens.bookmark.AddBookmarkScreenlet
    android:id="@+id/bookmark_screenlet"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    app:folderId="@string/bookmark_folder"
    app:layoutId="@layout/bookmark_default" />
\end{verbatim}

Note that the layout specified by \texttt{app:layoutId}
(\texttt{bookmark\_default}) matches the layout file of the Screenlet's
View (\texttt{bookmark\_default.xml}). This is how you specify the View
that displays your Screenlet. For example, if Add Bookmark Screenlet had
another View defined in a layout file named
\texttt{bookmark\_awesome.xml}, you could use that layout by specifying
\texttt{@layout/bookmark\_awesome} as the \texttt{app:layoutId}
attribute's value.

Also note that the \texttt{app:folderId} attribute specifies
\texttt{@string/bookmark\_folder} as the bookmark folder's ID. This is
an alternative way of specifying an attribute's value. Instead of
specifying the value directly, the Test App specifies the value in its
\href{https://github.com/liferay/liferay-screens/blob/master/android/samples/test-app/src/main/res/values/server_context.xml\#L23-L24}{\texttt{server\_context.xml}
file}:

\begin{verbatim}
...
<string name="bookmark_folder">20622</string>
...
\end{verbatim}

This \texttt{name} attribute's value, \texttt{bookmark\_folder} is then
used in the Screenlet XML to set the \texttt{app:folderId} attribute to
\texttt{20622}.

\subsection{Related Topics}\label{related-topics-222}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-screenlets-in-android-apps}{Using
Screenlets in Android Apps}

\section{Packaging Your Screenlets}\label{packaging-your-screenlets}

To reuse your Screenlet in another app or distribute it, you can package
it in a module (Android library). You can optionally share it with other
developers via jCenter or Maven Central. Developers can then use your
Screenlet by adding its module as a project dependency in their apps.
This tutorial explains how to package and distribute Screenlets by
following these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Create a new Android module.
\item
  Configure dependencies between each module.
\item
  Distribute the module by uploading it to jCenter or Maven Central.
\end{enumerate}

Now get ready to package and distribute Screenlets like a pro!

\subsection{Create a New Android
Module}\label{create-a-new-android-module}

Android Studio's \emph{Create New Module} wizard can automatically
create a module and add it to your \texttt{settings.gradle} file. Go to
\emph{File} → \emph{New Module\ldots{}}, select \emph{Android Library}
in the More Modules section, and click \emph{Next}. Then name your
module and click \emph{Next}. The wizard's final step lets you add a new
activity. Since your module doesn't need one, select \emph{Blank
Activity} and click \emph{Finish}. Android Studio creates a new
\texttt{build.gradle} file with an Android Library configuration and
adds the new module to your \texttt{settings.gradle} file.

If you prefer to create a new module manually, examine the
\texttt{build.gradle} file from the
\href{https://github.com/liferay/liferay-screens/blob/master/android/viewsets/material/build.gradle}{Material
View set} or
\href{https://github.com/liferay/liferay-screens/blob/master/android/viewsets/westeros/build.gradle}{Westeros
app} as an example. After creating the module, import it into your
project by specifying its location in
\href{https://github.com/liferay/liferay-screens/blob/master/android/samples/test-app/settings.gradle}{\texttt{settings.gradle}}.
Here's an example configuration:

\begin{verbatim}
// Change YOUR_MODULE_NAME and RELATIVE_ROUTE_TO_YOUR_MODULE to match your module

include ':YOUR_MODULE_NAME'
project(':YOUR_MODULE_NAME').projectDir = new File(settingsDir, 'RELATIVE_ROUTE_TO_YOUR_MODULE')
\end{verbatim}

Now that you have a module, you're ready to configure its dependencies.

\subsection{Configure Dependencies Between Each
Module}\label{configure-dependencies-between-each-module}

Next, you must configure your app to use the module. To do so, add a
project implementation statement to your \texttt{build.gradle} file's
dependencies:

\begin{verbatim}
// Change YOUR_MODULE_NAME to match your module's name

dependencies {
    ...
    implementation project (':YOUR_MODULE_NAME')
    ...
}
\end{verbatim}

Your module must also specify dependencies for overriding existing
Screenlets and creating new ones. This usually requires adding Liferay
Screens and the View Sets your Screenlet currently uses to your
\texttt{build.gradle} file's dependencies. To add Liferay Screens as a
dependency, add to your \texttt{build.gradle} file's dependencies the
following project implementation statement:

\begin{verbatim}
implementation 'com.liferay.mobile:liferay-screens:+'
\end{verbatim}

Awesome! Now you're ready to share your Screenlet with the world!

\subsection{Upload the Module to jCenter or Maven
Central}\label{upload-the-module-to-jcenter-or-maven-central}

To make your module available to anyone, you can upload your module to
jCenter or Maven Central. Before doing so, you must configure your
\texttt{build.gradle} file appropriately for those repositories. Use the
material or Westeros View Set's
\href{https://github.com/liferay/liferay-screens/blob/master/android/viewsets/westeros/build.gradle}{\texttt{build.gradle}}
file as an example. After entering your bintray api key, execute
\texttt{gradlew\ bintrayupload} to upload your project to jCenter.
Developers can then use your Screenlet as any other Android dependency
by specifying its repository, artifact, group ID, and version in their
Gradle files. Congratulations on publishing your Screenlet!

\subsection{Related Topics}\label{related-topics-223}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-android-screenlets}{Creating
Android Screenlets}

\href{/docs/7-1/tutorials/-/knowledge_base/t/preparing-android-projects-for-liferay-screens}{Preparing
Android Projects for Liferay Screens}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-screenlets-in-android-apps}{Using
Screenlets in Android Apps}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-android-views}{Creating
Android Views}

\chapter{Creating Android List
Screenlets}\label{creating-android-list-screenlets}

It's very common for mobile apps to display lists. Liferay Screens lets
you display asset lists and DDL lists in your Android app by using
\href{/docs/7-1/reference/-/knowledge_base/r/assetlistscreenlet-for-android}{Asset
List Screenlet} and
\href{/docs/7-1/reference/-/knowledge_base/r/ddllistscreenlet-for-android}{DDL
List Screenlet}, respectively. Screens also includes list Screenlets for
displaying lists of other Liferay entities like web content articles,
images, and more.
\href{/docs/7-1/reference/-/knowledge_base/r/screenlets-in-liferay-screens-for-android}{The
Screenlet reference documentation} lists all the Screenlets included
with Liferay Screens. If there's not a list Screenlet for the entity you
want to display in a list, you must create your own. A list Screenlet
can display any entity from a Liferay instance. For example, you can
create a list Screenlet that displays standard Liferay entities like
\texttt{User}, or custom entities from custom Liferay apps.

This tutorial uses code from the sample Bookmark List Screenlet to show
you how to create your own list Screenlet. This Screenlet displays a
list of bookmarks from Liferay's Bookmarks portlet. You can find this
Screenlet's complete code
\href{https://github.com/liferay/liferay-screens/tree/master/android/samples/listbookmarkscreenlet}{here
in GitHub}.

Note that because this tutorial focuses on creating a list Screenlet, it
doesn't explain general Screenlet concepts and components. Before
beginning, you should therefore read the following tutorials:

\begin{itemize}
\tightlist
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/architecture-of-liferay-screens-for-android}{Screens
  architecture tutorial}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/creating-android-screenlets}{Basic
  Screenlet creation tutorial}
\end{itemize}

You'll create the list Screenlet by following these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/creating-the-model-class}{Creating
  the Model Class}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/creating-the-view}{Creating
  the View}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/creating-the-interactor-0}{Creating
  the Interactor}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/creating-the-screenlet-class-0}{Creating
  the Screenlet Class}
\end{enumerate}

First though, you should understand how pagination works with list
Screenlets.

\section{Pagination}\label{pagination-2}

To ensure that users can scroll smoothly through large lists of items,
list Screenlets support fluent pagination. Support for this is built
into the list Screenlet framework. You'll see this as you construct your
list Screenlet.

Now you're ready to begin!

\section{Creating the Model Class}\label{creating-the-model-class}

Entities come back from Liferay in JSON. To work with these results
efficiently in your app, you must convert them to model objects that
represent the entity in Liferay. Although Screens's
\href{https://github.com/liferay/liferay-screens/blob/master/android/library/src/main/java/com/liferay/mobile/screens/base/list/interactor/BaseListInteractor.java}{\texttt{BaseListInteractor}}
transforms the JSON entities into \texttt{Map} objects for you, you
still must convert these into proper entity objects for use in your app.
You'll do this via a model class.

For example, Bookmark List Screenlet's model class (\texttt{Bookmark})
creates \texttt{Bookmark} objects that contain a bookmark's URL and
other data. To ensure quick access to the URL, the constructor that
takes a \texttt{Map\textless{}String,\ Object\textgreater{}} extracts it
from the \texttt{Map} and sets it to the \texttt{url} variable. To allow
access to any other data, the same constructor sets the entire
\texttt{Map} to the \texttt{values} variable. Besides the getters and
setter, the rest of this class implements
\href{https://developer.android.com/reference/android/os/Parcelable.html}{Android's
\texttt{Parcelable} interface}:

\begin{verbatim}
import android.os.Parcel;
import android.os.Parcelable;

import java.util.Map;

public class Bookmark implements Parcelable {

    private String url;
    private Map values;

    public static final Creator<Bookmark> CREATOR = new Creator<Bookmark>() {
        @Override
        public Bookmark createFromParcel(Parcel in) {
            return new Bookmark(in);
        }

        @Override
        public Bookmark[] newArray(int size) {
            return new Bookmark[size];
        }
    };

    public Bookmark() {
        super();
    }

    protected Bookmark(Parcel in) {
        url = in.readString();
    }

    public Bookmark(Map<String, Object> stringObjectMap) {
        url = (String) stringObjectMap.get("url");
        values = stringObjectMap;
    }

    @Override
    public void writeToParcel(Parcel dest, int flags) {
        dest.writeString(url);
    }

    @Override
    public int describeContents() {
        return 0;
    }

    public String getUrl() {
        return url;
    }

    public Map getValues() {
        return values;
    }

    public void setValues(Map values) {
        this.values = values;
    }

}
\end{verbatim}

Now that you have your model class, you can create your Screenlet's
View.

\subsection{Related Topics}\label{related-topics-224}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-the-view}{Creating
the View}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-the-interactor-0}{Creating
the Interactor}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-the-screenlet-class-0}{Creating
the Screenlet Class}

\section{Creating the View}\label{creating-the-view}

Recall from
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-the-ui}{the basic
Screenlet creation tutorial} that a View defines a Screenlet's UI. To
accommodate its list, a list Screenlet's View is constructed a bit
differently than that of a non-list Screenlet. To create a List
Screenlet's View, you'll create the following components:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Row Layout: the layout for each list row.
\item
  Adapter Class: an
  \href{http://developer.android.com/guide/topics/ui/declaring-layout.html\#AdapterViews}{Android
  adapter class} that populates each list row with data.
\item
  View Class: the class that controls the View. This class serves the
  same purpose in list Screenlets as it does in non-list Screenlets.
\item
  Main Layout: the layout for the list as a whole. Note this is
  different from the row layout, which defines the UI for individual
  rows.
\end{enumerate}

First, you'll create the row layout.

\subsection{Creating the Row Layout}\label{creating-the-row-layout}

Before constructing the rest of the View, you should first define the
layout to use for each row in the list. For example, Bookmark List
Screenlet needs to display a bookmark in each row. Its row layout
(\texttt{res/layout/bookmark\_row.xml}) is therefore a
\texttt{LinearLayout} containing a single \texttt{TextView} that
displays the bookmark's URL:

\begin{verbatim}
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="vertical">

    <TextView
        android:id="@+id/bookmark_url"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"/>

</LinearLayout>
\end{verbatim}

As you can see, this example is very simple. Row layouts, however, can
be as simple or complex as you need them to be to display your content.

Next, you'll create the adapter class.

\subsection{Creating the Adapter
Class}\label{creating-the-adapter-class}

\href{https://developer.android.com/guide/topics/ui/declaring-layout.html\#AdapterViews}{Android
adapters} fill a layout with content. In the example Bookmark List
Screenlet, the layout is the row layout (\texttt{bookmark\_row.xml}) and
the content is each list item (a URL). To make list scrolling smooth,
the adapter class should use an
\href{https://developer.android.com/training/improving-layouts/smooth-scrolling.html\#ViewHolder}{Android
view holder}. To make this easier, you can extend the list Screenlet
framework's
\href{https://github.com/liferay/liferay-screens/blob/master/android/library/src/main/java/com/liferay/mobile/screens/base/list/BaseListAdapter.java}{\texttt{BaseListAdapter}
class} with your model class and view holder as type arguments. By
extending \texttt{BaseListAdapter}, your adapter needs only two methods:

\begin{itemize}
\tightlist
\item
  \texttt{createViewHolder}: instantiates the view holder
\item
  \texttt{fillHolder}: fills in the view holder for each row
\end{itemize}

Your view holder should also contain variables for any data each row
needs to display. The view holder must assign these variables to the
corresponding row layout elements, and set the appropriate data to them.

For example, Bookmark List Screenlet's adapter class
(\texttt{BookmarkAdapter}) extends \texttt{BaseListAdapter} with
\texttt{Bookmark} and \texttt{BookmarkAdapter.BookmarkViewHolder} as
type arguments. This class's view holder is an inner class that extends
\texttt{BaseListAdapter}'s view holder. Since Bookmark List Screenlet
only needs to display a URL in each row, the view holder only needs one
variable: \texttt{url}. The view holder's constructor assigns the
\texttt{TextView} from \texttt{bookmark\_row.xml} to this variable. The
\texttt{bind} method then sets the bookmark's URL as the
\texttt{TextView}'s text. The other methods in \texttt{BookmarkAdapter}
leverage the view holder. The \texttt{createViewHolder} method
instantiates \texttt{BookmarkViewHolder}. The \texttt{fillHolder} method
calls the view holder's \texttt{bind} method to set the bookmark's URL
as the \texttt{url} variable's text:

\begin{verbatim}
public class BookmarkAdapter extends BaseListAdapter<Bookmark, BookmarkAdapter.BookmarkViewHolder> {

    public BookmarkAdapter(int layoutId, int progressLayoutId, BaseListAdapterListener listener) {
        super(layoutId, progressLayoutId, listener);
    }

    @NonNull
    @Override
    public BookmarkViewHolder createViewHolder(View view, BaseListAdapterListener listener) {
        return new BookmarkAdapter.BookmarkViewHolder(view, listener);
    }

    @Override
    protected void fillHolder(Bookmark entry, BookmarkViewHolder holder) {
        holder.bind(entry);
    }

    public class BookmarkViewHolder extends BaseListAdapter.ViewHolder {

        private final TextView url;

        public BookmarkViewHolder(View view, BaseListAdapterListener listener) {
            super(view, listener);

            url = (TextView) view.findViewById(R.id.bookmark_url);
        }

        public void bind(Bookmark entry) {
            url.setText(entry.getUrl());
        }
    }
}
\end{verbatim}

Great! Your adapter class is finished. Next, you'll create the View
class.

\subsection{Creating the View Class}\label{creating-the-view-class}

Now that your adapter exists, you can create your list Screenlet's View
class. Recall from
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-the-ui}{the basic
Screenlet creation tutorial} that the View class is the central hub of
any Screenlet's UI. It renders the UI, handles user interactions, and
communicates with the Screenlet class. The list Screenlet framework
provides most of this functionality for you via
\href{https://github.com/liferay/liferay-screens/blob/master/android/library/src/main/java/com/liferay/mobile/screens/base/list/BaseListScreenletView.java}{the
\texttt{BaseListScreenletView} class}. Your View class must extend this
class to provide your row layout ID and an instance of your adapter.
You'll do this by overriding \texttt{BaseListScreenletView}'s
\texttt{getItemLayoutId} and \texttt{createListAdapter} methods. Note
that in many cases this is the only custom functionality your View class
needs. If it needs more, you can provide it by creating new methods or
overriding other \texttt{BaseListScreenletView} methods.

Create your View class by extending \texttt{BaseListScreenletView} with
your model class, view holder, and adapter as type arguments. This is
required for your View class to represent your model objects in a view
holder, inside an adapter. For example, Bookmark List Screenlet's View
class (\texttt{BookmarkListView}) must represent \texttt{Bookmark}
instances in a \texttt{BookmarkViewHolder} inside a
\texttt{BookmarkAdapter}. The \texttt{BookmarkListView} class must
therefore extend \texttt{BaseListScreenletView} parameterized with
\texttt{Bookmark}, \texttt{BookmarkAdapter.BookmarkViewHolder}, and
\texttt{BookmarkAdapter}. Besides overriding \texttt{createListAdapter}
to return a \texttt{BookmarkAdapter} instance, the only other
functionality that this View class needs to support is to get the layout
for each row in the list. The overridden \texttt{getItemLayoutId} method
does this by returning the row layout \texttt{bookmark\_row}:

\begin{verbatim}
import android.content.Context;
import android.util.AttributeSet;

import com.liferay.mobile.screens.base.list.BaseListScreenletView;

public class BookmarkListView
    extends BaseListScreenletView<Bookmark, BookmarkAdapter.BookmarkViewHolder, BookmarkAdapter> {

    public BookmarkListView(Context context) {
        super(context);
    }

    public BookmarkListView(Context context, AttributeSet attributes) {
        super(context, attributes);
    }

    public BookmarkListView(Context context, AttributeSet attributes, int defaultStyle) {
        super(context, attributes, defaultStyle);
    }

    @Override
    protected BookmarkAdapter createListAdapter(int itemLayoutId, int itemProgressLayoutId) {
        return new BookmarkAdapter(itemLayoutId, itemProgressLayoutId, this);
    }

    @Override
    protected int getItemLayoutId() {
        return R.layout.bookmark_row;
    }
}
\end{verbatim}

Next, you'll create your View's main layout.

\subsection{Creating the View's Main
Layout}\label{creating-the-views-main-layout}

Although you already created a layout for your list rows, you must still
create a layout to define the list as a whole. This layout must contain:

\begin{itemize}
\tightlist
\item
  The View class's fully qualified name as the layout's first element.
\item
  An
  \href{http://developer.android.com/training/material/lists-cards.html\#RecyclerView}{Android
  \texttt{RecyclerView}} to let your app efficiently scroll through a
  potentially large list of items.
\item
  An
  \href{https://developer.android.com/reference/android/widget/ProgressBar.html}{Android
  \texttt{ProgressBar}} to indicate progress when loading the list.
\end{itemize}

Apart from the View class and styling, this layout's code is the same
for all list Screenlets. For example, here's Bookmark List Screenlet's
layout \texttt{res/layout/list\_bookmarks.xml}:

\begin{verbatim}
<com.liferay.mobile.screens.listbookmark.BookmarkListView
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:id="@+id/liferay_list_screenlet"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <ProgressBar
        android:id="@+id/liferay_progress"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="center"
        android:visibility="gone"/>

    <android.support.v7.widget.RecyclerView
        android:id="@+id/liferay_recycler_list"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:visibility="gone"/>
</com.liferay.mobile.screens.listbookmark.BookmarkListView>
\end{verbatim}

\noindent\hrulefill

\textbf{Warning:} The \texttt{android:id} values in your View's layout
XML must \textbf{exactly} match the ones shown here. These values are
hardcoded into the Screens framework and changing them will cause your
app to crash.

\noindent\hrulefill

Great job! Your View is finished. Next, you'll create your Screenlet's
Interactor.

\subsection{Related Topics}\label{related-topics-225}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-the-model-class}{Creating
the Model Class}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-the-interactor-0}{Creating
the Interactor}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-the-screenlet-class-0}{Creating
the Screenlet Class}

\section{Creating the Interactor}\label{creating-the-interactor-1}

Recall from
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-the-interactor}{the
basic Screenlet creation tutorial} that Interactors retrieve and process
a server call's results. Also recall that the following components make
up an Interactor:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Event
\item
  Listener
\item
  Interactor Class
\end{enumerate}

These components perform the same basic functions in list Screenlets as
they do in non-list Screenlets. Creating them, however, is a bit
different. Each of the following sections show you how to create one of
these components. First, you'll create the event.

\subsection{Creating the Event}\label{creating-the-event}

Screens uses the \href{http://greenrobot.org/eventbus/}{EventBus}
library to handle communication within Screenlets. Screenlet components
therefore communicate with each other by using event classes that
contain the server call's results. Your list Screenlet's event class
must extend
\href{https://github.com/liferay/liferay-screens/blob/master/android/library/src/main/java/com/liferay/mobile/screens/base/list/interactor/ListEvent.java}{the
\texttt{ListEvent} class} parameterized with your model class. Your
event class should also contain a private instance variable for the
model class, a constructor that sets this variable, and a no-argument
constructor that calls the superclass constructor. For example, Bookmark
List Screenlet's event class (\texttt{BookmarkEvent}) communicates
\texttt{Bookmark} objects. It therefore extends \texttt{ListEvent} with
\texttt{Bookmark} as a type argument, and defines a private
\texttt{Bookmark} variable that its
\texttt{BookmarkEvent(Bookmark\ bookmark)} constructor sets:

\begin{verbatim}
public class BookmarkEvent extends ListEvent<Bookmark> {

      private Bookmark bookmark;

      public BookmarkEvent() {
            super();
      }

      public BookmarkEvent(Bookmark bookmark) {
          this.bookmark = bookmark;
      }
    ...
\end{verbatim}

You must also implement \texttt{ListEvent}'s abstract methods in your
event class. Note that these methods support
\href{/docs/7-1/tutorials/-/knowledge_base/t/using-offline-mode-in-android}{offline
mode}. Although these methods are briefly described here, supporting
offline mode in your Screenlets is addressed in detail in a separate
tutorial.

\begin{itemize}
\item
  \texttt{getListKey}: returns the ID for the cache. This ID is
  typically the data each list row displays. For example, the
  \texttt{getListKey} method in \texttt{BookmarkEvent} returns the
  bookmark's URL:

\begin{verbatim}
  @Override
  public String getListKey() {
      return bookmark.getUrl();
  }
\end{verbatim}
\item
  \texttt{getModel}: unwraps the model entity to the cache by returning
  the model class instance. For example, the \texttt{getModel} method in
  \texttt{BookmarkEvent} method returns the bookmark:

\begin{verbatim}
  @Override
  public Bookmark getModel() {
      return bookmark;
  }
\end{verbatim}
\end{itemize}

Next, you'll create your Screenlet's listener.

\subsection{Creating the Listener}\label{creating-the-listener}

Recall that listeners let the app developer respond to events that occur
in Screenlets. For example, an app developer using Login Screenlet in an
activity must implement \texttt{LoginListener} in that activity to
respond to login success or failure. When creating a list Screenlet,
however, you don't have to create a separate listener. Developers can
use your list Screenlet in an activity or fragment by implementing
\href{https://github.com/liferay/liferay-screens/blob/master/android/library/src/main/java/com/liferay/mobile/screens/base/list/BaseListListener.java}{the
\texttt{BaseListListener} interface} parameterized with your model
class. For example, to use Bookmark List Screenlet in an activity, an
app developer's activity declaration could look like this:

\begin{verbatim}
public class BookmarkListActivity extends AppCompatActivity 
    implements BaseListListener<Bookmark> {...
\end{verbatim}

The \texttt{BaseListListener} interface defines the following methods
that the app developer can implement in their activity or fragment:

\begin{itemize}
\item
  \texttt{void\ onListPageFailed(int\ startRow,\ Exception\ e)}:
  Responds to the Screenlet's failure to retrieve entities from the
  server.
\item
  \texttt{void\ onListPageReceived(int\ startRow,\ int\ endRow,\ List\textless{}E\textgreater{}\ entries,\ int\ rowCount)}:
  Responds to the Screenlet's success in retrieving entities from the
  server.
\item
  \texttt{void\ onListItemSelected(E\ element,\ View\ view)}: Responds
  to a user selection in the list.
\end{itemize}

If these methods meet your list Screenlet's needs, then you can move on
to the next section in this tutorial. If you want to let app developers
respond to more actions, however, you must create your own listener that
extends \texttt{BaseListListener} parameterized with your model class.
For example, Bookmark List Screenlet contains such a listener:
\texttt{BookmarkListListener}. This listener defines a single method
that notifies the app developer when the Interactor is called:

\begin{verbatim}
public interface BookmarkListListener extends BaseListListener<Bookmark> {
    void interactorCalled();
}
\end{verbatim}

Next, you'll create the Interactor class.

\subsection{Creating the Interactor
Class}\label{creating-the-interactor-class}

Recall that as an Interactor's central component, the Interactor class
makes the service call to retrieve entities from Liferay DXP, and
processes the results of that call. The list Screenlet framework's
\href{https://github.com/liferay/liferay-screens/blob/master/android/library/src/main/java/com/liferay/mobile/screens/base/list/interactor/BaseListInteractor.java}{\texttt{BaseListInteractor}
class} provides most of the functionality that Interactor classes in
list Screenlets require. You must, however, extend
\texttt{BaseListInteractor} to make your service calls and handle their
results via your model and event classes. Your Interactor class must
therefore extend \texttt{BaseListInteractor}, parameterized with
\texttt{BaseListInteractorListener\textless{}YourModelClass\textgreater{}}
and your event class. For example, Bookmark List Screenlet's Interactor
class, \texttt{BookmarkListInteractor}, extends
\texttt{BaseListInteractor} parameterized with
\texttt{BaseListInteractorListener\textless{}Bookmark\textgreater{}} and
\texttt{BookmarkEvent}:

\begin{verbatim}
public class BookmarkListInteractor extends 
    BaseListInteractor<BaseListInteractorListener<Bookmark>, BookmarkEvent> {...
\end{verbatim}

Your Interactor must also override the methods needed to make the server
call and process the results:

\begin{itemize}
\item
  \texttt{getPageRowsRequest}: Retrieves the specified page of entities.
  In the example \texttt{BookmarkListInteractor}, this method first uses
  the \texttt{args} parameter to retrieve the ID of the folder to
  retrieve bookmarks from. It then sets the comparator (more on this
  shortly) if the app developer sets one when inserting the Screenlet
  XML in a fragment or activity. The \texttt{getPageRowsRequest} method
  finishes by calling \texttt{BookmarksEntryService}'s
  \texttt{getEntries} method to retrieve a page of bookmarks. Note that
  the service call, like the service call in the
  \href{/docs/7-1/tutorials/-/knowledge_base/t/creating-the-interactor}{basic
  Screenlet creation tutorial}, uses
  \texttt{LiferayServerContext.isLiferay7()} to check the portal version
  to make sure the correct service instance is used. This isn't required
  if you only plan to use your Screenlet with one portal version. Also
  note that the \texttt{groupId} variable used to make the service calls
  isn't set anywhere in \texttt{getPageRowsRequest} or
  \texttt{BookmarkListInteractor}. Interactors that extend
  \texttt{BaseListInteractor}, like \texttt{BookmarkListInteractor},
  inherit this variable via the Screens framework. You'll set it when
  you create the Screenlet class. Here's
  \texttt{BookmarkListInteractor}'s complete \texttt{getPageRowsRequest}
  method:

\begin{verbatim}
  @Override
  protected JSONArray getPageRowsRequest(Query query, Object... args) throws Exception {
      long folderId = (long) args[0];

      if (args[1] != null) {
          query.setComparator((String) args[1]);
      }

      if (LiferayServerContext.isLiferay7()) {
          return new BookmarksEntryService(getSession()).getEntries(groupId, folderId, 
              query.getStartRow(), query.getEndRow(), query.getComparatorJSONWrapper());
      } else {
          return new com.liferay.mobile.android.v62.bookmarksentry.BookmarksEntryService(
              getSession()).getEntries(groupId, folderId, query.getStartRow(), 
              query.getEndRow(), query.getComparatorJSONWrapper());
      }
  }
\end{verbatim}

  You might now be asking yourself what a comparator is. A comparator is
  a class in the Liferay DXP instance that sorts a portlet's entities.
  For example, the Bookmarks portlet contains several comparators that
  can sort entities by different criteria.
  \href{https://github.com/liferay/liferay-portal/tree/master/modules/apps/collaboration/bookmarks/bookmarks-api/src/main/java/com/liferay/bookmarks/util/comparator}{Click
  here} to see these comparators. Although it's not required, you can
  develop your list Screenlet to use a comparator to sort its entities.
  Since Bookmark List Screenlet supports comparators, you'll see more of
  this as you progress through this tutorial.
\item
  \texttt{getPageRowCountRequest}: Retrieves the number of entities, to
  enable pagination. In the example \texttt{BookmarkListInteractor},
  this method first uses the \texttt{args} parameter to get the ID of
  the folder in which to count bookmarks. It then calls
  \texttt{BookmarksEntryService}'s \texttt{getEntriesCount} method to
  retrieve the number of bookmarks:

\begin{verbatim}
  @Override
  protected Integer getPageRowCountRequest(Object... args) throws Exception {
      long folderId = (long) args[0];

      if (LiferayServerContext.isLiferay7()) {
          return new BookmarksEntryService(getSession()).getEntriesCount(groupId, folderId);
      } else {
          return new com.liferay.mobile.android.v62.bookmarksentry.BookmarksEntryService(
              getSession()).getEntriesCount(groupId, folderId);
      }
  }
\end{verbatim}
\item
  \texttt{createEntity}: Returns an instance of your event that contains
  the server call's results. This method receives the results as
  \texttt{Map\textless{}String,\ Object\textgreater{}}, which it uses to
  instantiate your model class. It then uses this model instance to
  create the event object. In the example
  \texttt{BookmarkListInteractor}, this method passes the
  \texttt{Map\textless{}String,\ Object\textgreater{}} to the
  \texttt{Bookmark} constructor. It then uses the resulting
  \texttt{Bookmark} to create and return a \texttt{BookmarkEvent}:

\begin{verbatim}
  @Override
  protected BookmarkEvent createEntity(Map<String, Object> stringObjectMap) {
      Bookmark bookmark = new Bookmark(stringObjectMap);
      return new BookmarkEvent(bookmark);
  }
\end{verbatim}
\item
  \texttt{getIdFromArgs}: a boilerplate method that returns the value of
  the first object argument as a string. This serves as a cache key for
  \href{/docs/7-1/tutorials/-/knowledge_base/t/using-offline-mode-in-android}{offline
  mode}:

\begin{verbatim}
  @Override
  protected String getIdFromArgs(Object... args) {
      return String.valueOf(args[0]);
  }
\end{verbatim}

  You must implement this method even if you don't intend to support
  offline mode in your Screenlet. Having this method in your Interactor
  class makes it simpler to add offline mode functionality later.
  Supporting offline mode in your Screenlets is addressed in detail in a
  separate tutorial.
\end{itemize}

To see the complete \texttt{BookmarkListInteractor} class,
\href{https://github.com/liferay/liferay-screens/blob/master/android/samples/listbookmarkscreenlet/src/main/java/com/liferay/mobile/screens/listbookmark/BookmarkListInteractor.java}{click
here}.

Next, you'll create the Screenlet class.

\subsection{Related Topics}\label{related-topics-226}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-the-model-class}{Creating
the Model Class}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-the-view}{Creating
the View}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-the-screenlet-class-0}{Creating
the Screenlet Class}

\section{Creating the Screenlet
Class}\label{creating-the-screenlet-class-1}

Recall from
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-the-screenlet-class}{the
basic Screenlet creation tutorial} that the Screenlet class serves as
your Screenlet's focal point. It governs the Screenlet's behavior and is
the primary component the app developer interacts with. As with non-list
Screenlets, you should first define any XML attributes that you want to
make available to the app developer. For example, Bookmark List
Screenlet defines the following attributes:

\begin{itemize}
\tightlist
\item
  \texttt{groupId}: the ID of the site containing the Bookmarks portlet
\item
  \texttt{folderId}: the ID of the Bookmarks portlet folder to retrieve
  bookmarks from
\item
  \texttt{comparator}: the name of the comparator to use to sort the
  bookmarks
\end{itemize}

The Screenlet defines these attributes in its
\texttt{res/values/bookmark\_attrs.xml} file:

\begin{verbatim}
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <declare-styleable name="BookmarkListScreenlet">
        <attr name="groupId"/>
        <attr name="folderId"/>
        <attr format="string" name="comparator"/>
    </declare-styleable>
</resources>
\end{verbatim}

Now you're ready to create your Screenlet class. Because
\href{https://github.com/liferay/liferay-screens/blob/master/android/library/src/main/java/com/liferay/mobile/screens/base/list/BaseListScreenlet.java}{the
\texttt{BaseListScreenlet} class} provides the basic functionality for
all Screenlet classes in list Screenlets, including methods for
pagination and other default behavior, your Screenlet class must extend
\texttt{BaseListScreenlet} with your model class and Interactor as type
arguments.

For example, Bookmark List Screenlet's Screenlet
class--\texttt{BookmarkListScreenlet}--extends
\texttt{BaseListScreenlet} parameterized with \texttt{Bookmark} and
\texttt{BookmarkListInteractor}:

\begin{verbatim}
public class BookmarkListScreenlet 
    extends BaseListScreenlet<Bookmark, BookmarkListInteractor> {...
\end{verbatim}

You must also create instance variables for the XML attributes that you
want to pass to your Interactor. For example, recall that the request
methods in \texttt{BookmarkListInteractor} receive two \texttt{Object}
arguments: the folder ID and the comparator. The
\texttt{BookmarkListScreenlet} class must therefore contain variables
for these parameters so it can pass them to the Interactor:

\begin{verbatim}
private long folderId;
private String comparator;
\end{verbatim}

For constructors, leverage the superclass constructors. For example,
here are \texttt{BookmarkListScreenlet}'s constructors:

\begin{verbatim}
public BookmarkListScreenlet(Context context) {
    super(context);
}

public BookmarkListScreenlet(Context context, AttributeSet attrs) {
    super(context, attrs);
}

public BookmarkListScreenlet(Context context, AttributeSet attrs, int defStyleAttr) {
    super(context, attrs, defStyleAttr);
}

public BookmarkListScreenlet(Context context, AttributeSet attrs, int defStyleAttr, 
    int defStyleRes) {
        super(context, attrs, defStyleAttr, defStyleRes);
}
\end{verbatim}

Now you must implement the \texttt{error} method. This is a boilerplate
method that uses a listener in the Screenlet framework to propagate any
exception, and the user action that produced it, that occurs during the
service call. This method does this by checking for a listener and then
calling its \texttt{error} method with the \texttt{Exception} and
\texttt{userAction}:

\begin{verbatim}
@Override
public void error(Exception e, String userAction) {
    if (getListener() != null) {
        getListener().error(e, userAction);
    }
}
\end{verbatim}

Next, override the \texttt{createScreenletView} method to read the
values of the XML attributes you defined earlier and create the
Screenlet's View. Recall from
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-the-screenlet-class}{the
basic Screenlet creation tutorial} that this method assigns the
attribute values to their corresponding instance variables. For example,
the \texttt{createScreenletView} method in
\texttt{BookmarkListScreenlet} assigns the \texttt{folderId} and
\texttt{comparator} attribute values to variables of the same name. This
method also sets the local variable \texttt{groupId}. Recall that the
Screens framework propagates this variable to your Interactor. Finish
the \texttt{createScreenletView} method by calling the superclass's
\texttt{createScreenletView} method. This instantiates the View for you:

\begin{verbatim}
@Override
protected View createScreenletView(Context context, AttributeSet attributes) {
    TypedArray typedArray = context.getTheme().obtainStyledAttributes(attributes, 
        R.styleable.BookmarkListScreenlet, 0, 0);
    groupId = typedArray.getInt(R.styleable.BookmarkListScreenlet_groupId, 
        (int) LiferayServerContext.getGroupId());
    folderId = typedArray.getInt(R.styleable.BookmarkListScreenlet_folderId, 0);
    comparator = typedArray.getString(R.styleable.BookmarkListScreenlet_comparator);
    typedArray.recycle();

    return super.createScreenletView(context, attributes);
}
\end{verbatim}

Next, override the \texttt{loadRows} method to start your Interactor and
thereby retrieve the list rows from the server. This method takes an
instance of your Interactor as an argument, which you use to call the
Interactor's \texttt{start} method. Note that the Interactor inherits
\texttt{start} from \texttt{BaseListInteractor}. You can also use the
\texttt{loadRows} method to execute any other code that you want to run
when the Interactor starts. For example, the \texttt{loadRows} method in
\texttt{BookmarkListScreenlet} first retrieves a listener instance so it
can call the listener's \texttt{interactorCalled} method. It then starts
the server operation to retrieve the list rows by calling the
Interactor's \texttt{start} method with \texttt{folderId} and
\texttt{comparator}:

\begin{verbatim}
@Override
protected void loadRows(BookmarkListInteractor interactor) {

    ((BookmarkListListener) getListener()).interactorCalled();

    interactor.start(folderId, comparator);
}
\end{verbatim}

Note that if your Interactor doesn't require arguments, then you can
pass the \texttt{start} method \texttt{0} or \texttt{null}. Calling
\texttt{start} with no arguments, however, causes the server call to
fail.

Lastly, override the \texttt{createInteractor} method to instantiate
your Interactor. Since that's all this method needs to do, call your
Interactor's constructor and return the new instance. For example,
\texttt{BookmarkListScreenlet}'s \texttt{createInteractor} method
returns a new \texttt{BookmarkListInteractor}:

\begin{verbatim}
@Override
protected BookmarkListInteractor createInteractor(String actionName) {
    return new BookmarkListInteractor();
}
\end{verbatim}

You're done! Your Screenlet is a ready-to-use component that you can use
in your app. You can even
\href{/docs/7-1/tutorials/-/knowledge_base/t/packaging-your-screenlets}{package
your Screenlet} and contribute it to the Screens project, or distribute
it in Maven Central or jCenter.

\subsection{Related Topics}\label{related-topics-227}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-the-model-class}{Creating
the Model Class}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-the-view}{Creating
the View}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-the-interactor-0}{Creating
the Interactor}

\section{Using the List Screenlet}\label{using-the-list-screenlet}

You can now use your new list Screenlet
\href{/docs/7-1/tutorials/-/knowledge_base/t/using-screenlets-in-android-apps}{the
same way you use any other Screenlet}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Insert the Screenlet's XML in the layout of the activity or fragment
  you want to use the Screenlet in. For example, here's Bookmark List
  Screenlet's XML:

\begin{verbatim}
 <com.liferay.mobile.screens.listbookmark.BookmarkListScreenlet
     android:id="@+id/bookmarklist_screenlet"
     android:layout_width="match_parent"
     android:layout_height="match_parent"
     app:comparator="FULLY_QUALIFIED_COMPARATOR_CLASS"
     app:folderId="YOUR_FOLDER_ID"
     app:groupId="YOUR_GROUP_ID"
     app:layoutId="@layout/list_bookmarks"/>
\end{verbatim}

  Note that to set a comparator, you must use its fully qualified class
  name. For example, to use
  \href{https://github.com/liferay/liferay-portal/blob/7.0.6-ga7/modules/apps/collaboration/bookmarks/bookmarks-api/src/main/java/com/liferay/bookmarks/util/comparator/EntryURLComparator.java}{the
  Bookmarks portlet's \texttt{EntryURLComparator}}, set
  \texttt{app:comparator} in the Screenlet XML as follows:

\begin{verbatim}
 app:comparator="com.liferay.bookmarks.util.comparator.EntryURLComparator"
\end{verbatim}
\item
  Implement the Screenlet's listener in the activity or fragment class.
  If your list Screenlet doesn't have a custom listener, then you can do
  this by implementing \texttt{BaseListListener} parameterized with your
  model class. For example:

\begin{verbatim}
 public class YourListActivity extends AppCompatActivity 
     implements BaseListListener<YourModelClass> {...
\end{verbatim}

  If you created a custom listener for your list Screenlet, however,
  then your activity or fragment must implement it instead. For example,
  recall that the example Bookmark List Screenlet's listener is
  \texttt{BookmarkListListener}. To use this Screenlet, you must
  therefore implement this listener in the class of the activity or
  fragment that you want to use the Screenlet in. For example:

\begin{verbatim}
 public class ListBookmarksActivity extends AppCompatActivity 
     implements BookmarkListListener {...
\end{verbatim}

  See the full example of this
  \href{https://github.com/liferay/liferay-screens/blob/master/android/samples/test-app/src/main/java/com/liferay/mobile/screens/testapp/ListBookmarksActivity.java}{here
  in GitHub}.
\end{enumerate}

Well done! Now you know how to create list Screenlets.

\subsection{Related Topics}\label{related-topics-228}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-screenlets-in-android-apps}{Using
Screenlets in Android Apps}

\chapter{Creating Android Views}\label{creating-android-views}

By creating your own Views, you can customize your mobile app's layout,
style, and functionality. You can create them from scratch or use an
existing View as a foundation. Views include a View class for
implementing Screenlet behavior, a Screenlet class for notifying
listeners and invoking Interactors, and an XML file for specifying the
UI. The four Liferay Screens View types support different levels of
customization and parent View inheritance. Here's what each View type
offers:

\textbf{Themed View:} presents the same structure as the current View,
but alters the theme colors and tints of the View's resources. All
existing Views can be themed with different styles. The View's colors
reflect the current value of the Android
\href{https://www.google.com/design/spec/style/color.html\#color-color-palette}{color
palette}. If you want to use one View Set with another View Set's
colors, you can use those colors in your app's theme
(e.g.~\texttt{colorPrimary\_default}, \texttt{colorPrimary\_material},
\texttt{colorPrimary\_westeros}).

\textbf{Child View:} presents the same UI components as its parent View,
but lets you change their appearance and position.

\textbf{Extended View:} inherits its parent View's functionality and
appearance, but lets you add to and modify both.

\textbf{Full View:} provides a complete standalone View for a Screenlet.
A full View is ideal for implementing completely different functionality
and appearance from a Screenlet's current theme.

This tutorial explains how to create all four types of Views. To
understand View concepts and components, you might want to examine the
\href{/docs/7-1/tutorials/-/knowledge_base/t/architecture-of-liferay-screens-for-android}{architecture}
of Liferay Screens for Android. And the tutorial
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-android-screenlets}{Creating
Android Screenlets} can help you create or extend any Screenlet classes
your View requires. Now get ready to create some great Views!

\section{Determining Your View's
Location}\label{determining-your-views-location}

First, decide whether you'll reuse your view or if it's just for your
current app. If you don't plan to reuse it in another app or don't want
to redistribute it, create it in your app project.

If you want to reuse your View in another app, create it in a new
Android application module; the tutorial
\href{/docs/7-1/tutorials/-/knowledge_base/t/packaging-your-screenlets}{Packaging
Android Screenlets} explains how. When your View's project is in place,
you can start creating it.

First, you'll learn how to create a Themed View.

\section{Themed Views}\label{themed-views}

Screens provides several existing View Sets that you can reuse and
customize in your app to create a Themed View. If you use or override
the Android color palette's values (for example, \texttt{primaryColor},
\texttt{secondaryColor}, etc\ldots), you'll reuse the View Set's general
structure, but be able to use the new colors (also with tinted
resources). Note that you must create Themed Views inside your app. This
is because Themed Views depend on the app or activity theme.

Each View Set has its own Android theme. These are listed here:

\begin{itemize}
\tightlist
\item
  \textbf{Default View Set:} \texttt{default\_theme}
\item
  \textbf{Lexicon View Set:} \texttt{lexicon\_theme}
\item
  \textbf{Material View Set:} \texttt{material\_theme}
\item
  \textbf{Westeros View Set:} \texttt{westeros\_theme}
\end{itemize}

You can easily style all your Screenlets by setting your app or activity
theme to inherit a View Set's Android theme. For example, you can use
the following code to reuse the styles (and layouts) from
\texttt{material\_theme} in your own theme:

\begin{verbatim}
<style name="AppTheme.NoActionBar" parent="material_theme">
    <item name="colorPrimary">#B91D6D</item>
    <item name="colorPrimaryDark">#670E3B</item>
    <item name="colorAccent">#BBBBBB</item>
</style>

<application android:theme="@style/AppTheme.NoActionBar"
    ...
>
\end{verbatim}

Note that this code overrides the \texttt{AppTheme.NoActionBar} theme's
colors with your own color settings for \texttt{colorPrimary},
\texttt{colorPrimaryDark}, and \texttt{colorAccent}. Screenlets will
also use these new colors, and tint images and other resources
accordingly. Liferay Screens uses the default Android color palette
names from the Support Library.

You can also override only the parent View Set's theme colors. This way
you can set a default color palette and override only the View Set
colors you want. The color names for each View Set are the default
Android names, followed by an underscore and the View Set's lowercase
name (\texttt{\_default}, \texttt{\_material}, and \texttt{\_westeros}).
For example, the following code overrides \texttt{colorPrimary},
\texttt{colorPrimaryDark}, and \texttt{colorAccent} for only the
\texttt{material\_theme}:

\begin{verbatim}
<resources>
    <color name="colorPrimary_material">#B91D6D</color>
    <color name="colorPrimaryDark_material">#670E3B</color>
    <color name="colorAccent_material">#BBBBBB</color>
</resources>
\end{verbatim}

Liferay Screens also lets you use one View Set's layout with a
Screenlet, and use another View Set's general style and colors. To do
this, pass a \texttt{layoutId} attribute to a Screenlet that is already
styled with another View Set's theme. The Screenlet uses the layout
structure specified in \texttt{layoutId}, but inherits the general style
and colors from the View Set's theme. For example, this code tells Login
Screenlet to use the Default View Set's layout structure, but use the
styles and colors defined earlier in \texttt{AppTheme.NoActionBar}:

\begin{verbatim}
<com.liferay.mobile.screens.auth.login.LoginScreenlet
    android:id="@+id/login_screenlet"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    app:basicAuthMethod="email"
    app:layoutId="@layout/login_default"
    app:credentialsStorage="shared_preferences" />

<application android:theme="@style/AppTheme.NoActionBar"
    ...
>
\end{verbatim}

\subsection{Related Topics}\label{related-topics-229}

\href{/docs/7-1/tutorials/-/knowledge_base/t/child-views}{Child Views}

\href{/docs/7-1/tutorials/-/knowledge_base/t/extended-views}{Extended
Views}

\href{/docs/7-1/tutorials/-/knowledge_base/t/full-views}{Full Views}

\href{/docs/7-1/tutorials/-/knowledge_base/t/packaging-your-views}{Packaging
Your Views}

\section{Child Views}\label{child-views}

A Child View presents the same behavior and UI components as its parent,
but can change the UI components' appearance and position. It can't add
or remove any UI components. A Child View specifies visual changes in
its own layout XML file; it inherits the parent's View class and
Screenlet class. The parent must be a Full View.

The Child View discussed here presents the same UI components as the
\href{https://github.com/liferay/liferay-screens/tree/master/android/library/core/src/main/java/com/liferay/mobile/screens/auth/login}{Login
Screenlet's} Default View, but uses a more compact layout.

You can follow these steps to create a Child View:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a new layout XML file named after the View's Screenlet and its
  intended use case. A good way to start building your UI is to
  duplicate the parent's layout XML file and use it as a template.
  However you start building your UI, name the root element after the
  parent View's fully-qualified class name and specify the parent's UI
  components with the same IDs.

  In the example here, the Child View's layout file
  \texttt{login\_compact.xml} resembles its parent's layout file
  \href{https://github.com/liferay/liferay-screens/blob/master/android/library/core/src/main/res/layout/login_default.xml}{\texttt{login\_default.xml}}--
  the layout of the Login Screenlet's Default View. The child View's
  name \emph{compact} describes its use case: display the Screenlet's
  components in a more compact layout. The IDs of its \texttt{EditText}
  and \texttt{Button} components match those of the parent View. Its
  root element uses the parent View class's fully-qualified name:

\begin{verbatim}
<?xml version="1.0" encoding="utf-8"?>
<com.liferay.mobile.screens.viewsets.defaultviews.auth.login.LoginView
    xmlns:android="http://schemas.android.com/apk/res/android"
    style="@style/default_screenlet">

    <EditText
        android:id="@+id/liferay_login"
        style="@style/default_edit_text"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_marginBottom="15dp"
        android:drawableLeft="@drawable/default_mail_icon"
        android:hint="@string/email_address"
        android:inputType="text" />

    <EditText
        android:id="@+id/liferay_password"
        style="@style/default_edit_text"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_marginBottom="15dp"
        android:drawableLeft="@drawable/default_lock_icon"
        android:hint="@string/password"
        android:inputType="textPassword" />

    <Button
        android:id="@+id/liferay_login_button"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        style="@style/default_button"
        android:text="@string/sign_in" />

</com.liferay.mobile.screens.viewsets.defaultviews.auth.login.LoginView>
\end{verbatim}

  You can browse other layouts for Screens's Default Views on
  \href{https://github.com/liferay/liferay-screens/tree/master/android/library/core/src/main/res/layout}{GitHub}.
\item
  Insert your View's Screenlet in any of your activities or fragments,
  using your new layout's name as the \texttt{liferay:layoutId}
  attribute's value. For example, to use the new \texttt{login\_compact}
  layout, insert \texttt{LoginScreenlet} in an activity or fragment and
  set \texttt{liferay:layoutId="@layout/login\_compact"}.
\end{enumerate}

Another good Child View layout file to examine is
\href{https://github.com/liferay/liferay-screens/blob/master/android/viewsets/material/src/main/res/layout/sign_up_material.xml}{\texttt{sign\_up\_material.xml}}.
It presents the same UI components and functionality as the Sign Up
Screenlet's Default View, but using
\href{http://www.google.com/design/spec/material-design/introduction.html}{Android's
Material design}.

\subsection{Related Topics}\label{related-topics-230}

\href{/docs/7-1/tutorials/-/knowledge_base/t/themed-views}{Themed Views}

\href{/docs/7-1/tutorials/-/knowledge_base/t/extended-views}{Extended
Views}

\href{/docs/7-1/tutorials/-/knowledge_base/t/full-views}{Full Views}

\href{/docs/7-1/tutorials/-/knowledge_base/t/packaging-your-views}{Packaging
Your Views}

\section{Extended Views}\label{extended-views}

An Extended View inherits the parent View's behavior and appearance, but
lets you change and add to both. You can do so by writing a custom View
class and a new layout XML file. An Extended View inherits all of the
parent View's other classes, including its Screenlet, listeners, and
Interactors. An Extended View's parent must be a Full View.

The example Extended View discussed here presents the same UI components
as the Login Screenlet's Default View, but adds functionality: computing
password strength. Of course, you're not restricted to password strength
computations; you can implement anything you want.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a new layout XML file named after the View's Screenlet and its
  intended use case. A good way to start building your UI is to
  duplicate the parent's layout XML file and use it as a template. The
  new layout file for the Login Screenlet's Extended View is called
  \texttt{login\_password.xml}, because it's based on the Login
  Screenlet's Default View layout file
  \href{https://github.com/liferay/liferay-screens/blob/master/android/library/core/src/main/res/layout/login_default.xml}{\texttt{login\_default.xml}}
  and it adds a password strength computation.
\item
  Create a new custom View class that extends the parent View class.
  Name it after the Screenlet and the functionality you'll add or
  override. The example View class \texttt{LoginCheckPasswordView}
  extends the Default View's
  \href{https://github.com/liferay/liferay-screens/blob/master/android/library/core/src/main/java/com/liferay/mobile/screens/viewsets/defaultviews/auth/login/LoginView.java}{\texttt{LoginView}}
  class, overriding the \texttt{onClick} method to compute password
  strength:

\begin{verbatim}
public class LoginCheckPasswordView extends LoginView {

    // parent's constructors go here...

    @Override
    public void onClick(View view) {
        // compute password strength

        if (passwordIsStrong) {
            super.onClick(view);
        }
        else {
            // Present user message
        }
    }

}
\end{verbatim}
\item
  Rename the layout XML file's root element after your custom View's
  fully-qualified class name. For example, the root element in
  \texttt{login\_password.xml} is
  \texttt{com.your.package.LoginCheckPasswordView}:

\begin{verbatim}
<com.your.package.LoginCheckPasswordView
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="vertical">
    ...
\end{verbatim}
\item
  Insert your View's Screenlet in any of your activities or fragments,
  using your new layout's name as the \texttt{liferay:layoutId}
  attribute's value. For example, to use the new
  \texttt{login\_password} layout, insert \texttt{LoginScreenlet} in an
  activity or fragment, and set
  \texttt{liferay:layoutId="@layout/login\_password"}.
\end{enumerate}

The
\href{https://github.com/liferay/liferay-screens/tree/master/android/samples/bankofwesteros}{Bank
of Westeros} sample app's
\href{https://github.com/liferay/liferay-screens/tree/master/android/viewsets/westeros}{Westeros
View Set} has a couple of Extended Views that you can examine. It has an
Extended View that adds a new button to show the password in the clear
for the Login Screenlet. The View uses custom layout file
\href{https://github.com/liferay/liferay-screens/blob/master/android/viewsets/westeros/src/main/res/layout/login_westeros.xml}{\texttt{login\_westeros.xml}}
and custom View class
\href{https://github.com/liferay/liferay-screens/blob/master/android/viewsets/westeros/src/main/java/com/liferay/mobile/screens/viewsets/westeros/auth/login/LoginView.java}{\texttt{LoginView}}.
The Westeros View Set also contains an Extended View for the User
Portrait Screenlet; it changes the border color and width of the user's
portrait picture and it uses the custom layout file
\href{https://github.com/liferay/liferay-screens/blob/master/android/viewsets/westeros/src/main/res/layout/userportrait_westeros.xml}{\texttt{userportrait\_westeros.xml}}
and the custom View class
\href{https://github.com/liferay/liferay-screens/blob/master/android/viewsets/westeros/src/main/java/com/liferay/mobile/screens/viewsets/westeros/userportrait/UserPortraitView.java}{\texttt{UserPortraitView}}.

\subsection{Related Topics}\label{related-topics-231}

\href{/docs/7-1/tutorials/-/knowledge_base/t/themed-views}{Themed Views}

\href{/docs/7-1/tutorials/-/knowledge_base/t/child-views}{Child Views}

\href{/docs/7-1/tutorials/-/knowledge_base/t/full-views}{Full Views}

\href{/docs/7-1/tutorials/-/knowledge_base/t/packaging-your-views}{Packaging
Your Views}

\section{Full Views}\label{full-views}

A Full View has a unique Screenlet class, a View class, and layout XML
file. It's standalone and doesn't inherit from any View. You should
create a Full View if there's no other View that you can extend to meet
your needs or if your Screenlet's behavior can only be augmented by
customizing its listeners or calling custom Interactors. To create a
Full View, you must create its Screenlet class, View class, and layout
XML file. The example Full View here for the Login Screenlet presents a
single \texttt{EditText} component for the user name. For the password,
it uses
\href{http://developer.android.com/reference/android/provider/Settings.Secure.html\#ANDROID_ID}{\texttt{Secure.ANDROID\_ID}}.
The
\href{https://github.com/liferay/liferay-screens/tree/master/android/samples/test-app}{Screens
Test App} uses
\href{https://github.com/liferay/liferay-screens/tree/master/android/samples/test-app/src/main/java/com/liferay/mobile/screens/testapp/fullview}{this
Full View}.

You can follow these steps to create a Full View:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a new layout XML file and build your UI in it. A good way to
  start building your UI is to duplicate another View's layout XML file
  and use it as a template. Name your layout XML file after the View's
  Screenlet and intended use case. Name its root element after the
  fully-qualified class name of your custom View (you'll create this
  next).

  The Test App's Full View layout XML file for the Login Screenlet is
  called
  \href{https://github.com/liferay/liferay-screens/blob/master/android/samples/test-app/src/main/res/layout/login_full.xml}{\texttt{login\_full.xml}}.
  It specifies \texttt{EditText} and \texttt{Button} elements copied
  from the LongScreenlet's Default View file
  \href{https://github.com/liferay/liferay-screens/blob/master/android/library/core/src/main/res/layout/login_default.xml}{\texttt{login\_default.xml}}.

\begin{verbatim}
<?xml version="1.0" encoding="utf-8"?>
<com.your.package.LoginFullView
        xmlns:android="http://schemas.android.com/apk/res/android"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="vertical">

<EditText
        android:id="@+id/liferay_login"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_marginBottom="20dp"
        android:hint="Email Address"
        android:inputType="textEmailAddress"/>

<Button
        android:id="@+id/liferay_login_button"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Sign In"/>

</com.your.package.LoginFullView>
\end{verbatim}
\item
  Create a new custom View class named after the layout's root element.
  The tutorial on creating Android Screenlets explains how to
  \href{/docs/7-1/tutorials/-/knowledge_base/t/creating-the-ui\#creating-the-screenlets-view-class}{create
  a View class}. Note that you don't have to extend a View class to
  implement a View Model interface, but you might want to for
  convenience. The custom View class
  \href{https://github.com/liferay/liferay-screens/blob/master/android/samples/test-app/src/main/java/com/liferay/mobile/screens/testapp/fullview/LoginFullView.java}{\texttt{LoginFullView}},
  for example, implements the
  \href{https://github.com/liferay/liferay-screens/blob/master/android/library/core/src/main/java/com/liferay/mobile/screens/auth/login/view/LoginViewModel.java}{\texttt{LoginViewModel}}
  interface by extending the Default
  \href{https://github.com/liferay/liferay-screens/blob/master/android/library/core/src/main/java/com/liferay/mobile/screens/viewsets/defaultviews/auth/login/LoginView.java}{\texttt{LoginView}}
  class. To return the \texttt{ANDROID\_ID}, the \texttt{LoginFullView}
  custom View class overrides the \texttt{getPassword()} method.
\item
  Create a new Screenlet class that inherits the base Screenlet class.
  This new class is where you can add custom behavior to the listeners
  or call custom Interactors. The Screenlet class
  \href{https://github.com/liferay/liferay-screens/blob/master/android/samples/test-app/src/main/java/com/liferay/mobile/screens/testapp/fullview/LoginFullScreenlet.java}{\texttt{LoginFullScreenlet}},
  for example, extends
  \href{https://github.com/liferay/liferay-screens/blob/master/android/library/core/src/main/java/com/liferay/mobile/screens/auth/login/LoginScreenlet.java}{\texttt{LoginScreenlet}}
  and overrides the \texttt{onUserAction} method to log Interactor
  calls.
\item
  Insert your View's Screenlet in any of your activities or fragments,
  using your new layout's name as the \texttt{liferay:layoutId}
  attribute's value. For example, to use the new
  \texttt{login\_password} layout, insert \texttt{LoginScreenlet} in an
  activity or fragment, and set
  \texttt{liferay:layoutId="@layout/login\_password"}.
\end{enumerate}

The
\href{https://github.com/liferay/liferay-screens/tree/master/android/viewsets/westeros/src/main/java/com/liferay/mobile/screens/viewsets/westeros/auth/signup}{Westeros
View Set's full view for the Sign Up Screenlet} uses a
\href{https://github.com/liferay/liferay-screens/blob/master/android/viewsets/westeros/src/main/java/com/liferay/mobile/screens/viewsets/westeros/auth/signup/SignUpScreenlet.java}{custom
Screenlet class} to add a
\href{https://github.com/liferay/liferay-screens/blob/master/android/viewsets/westeros/src/main/java/com/liferay/mobile/screens/viewsets/westeros/auth/signup/SignUpListener.java}{new
listener}. The custom Screenlet class also adds a new user action that
calls the base Interactor \texttt{SignUpInteractor}.

\subsection{Related Topics}\label{related-topics-232}

\href{/docs/7-1/tutorials/-/knowledge_base/t/themed-views}{Themed Views}

\href{/docs/7-1/tutorials/-/knowledge_base/t/child-views}{Child Views}

\href{/docs/7-1/tutorials/-/knowledge_base/t/extended-views}{Extended
Views}

\href{/docs/7-1/tutorials/-/knowledge_base/t/packaging-your-views}{Packaging
Your Views}

\section{Packaging Your Views}\label{packaging-your-views}

If you want to distribute or reuse Views, you should package them in a
module that is then added as an app's project dependency. To do this,
use the
\href{https://github.com/liferay/liferay-screens/tree/master/android/viewsets/material}{material}
sub-project as a template for your new
\href{https://github.com/liferay/liferay-screens/blob/master/android/viewsets/material/build.gradle}{\texttt{build.gradle}}
file.

To use a packaged View, you must import its module into your project by
specifying its location in your
\href{https://github.com/liferay/liferay-screens/blob/master/android/samples/bankofwesteros/settings.gradle}{\texttt{settings.gradle}}
file. The Bank of Westeros and test-app projects use custom Views
\texttt{westeros} and \texttt{material}, respectively. These projects
exemplify using independent Views in a project.

If you want to redistribute your View and let others use it, you can
upload it to jCenter or Maven Central. In the example
\href{https://github.com/liferay/liferay-screens/blob/master/android/samples/bankofwesteros/build.gradle}{\texttt{build.gradle}}
file, after entering your bintray api key you can execute
\texttt{gradlew\ bintrayupload} to upload your project to jCenter. When
finished, anyone can use the View as they would any Android dependency
by adding the repository, artifact, group ID, and version to their
Gradle file.

\subsection{Related Topics}\label{related-topics-233}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-android-views}{Creating
Android Views}

\chapter{Supporting Offline Mode}\label{supporting-offline-mode}

Offline mode lets Screenlets function without a network connection. For
offline mode to work with your Screenlet, you must manually add support
for it. Fortunately, Liferay Screens 2.0 introduced a simpler way of
implementing offline mode support in Android Screenlets:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Create an event class (or update it if your Screenlet already has
  one).
\item
  Update your Screenlet's classes to leverage the offline mode cache.
\end{enumerate}

How you implement these steps depends on how your Screenlet communicates
with the server:

\begin{itemize}
\tightlist
\item
  \textbf{Write Screenlets:} Write data to a server. The Add Bookmark
  Screenlet created in the
  \href{/docs/7-1/tutorials/-/knowledge_base/t/creating-android-screenlets}{basic
  Screenlet creation tutorial} is a good example of a simple write
  Screenlet. It asks the user to enter a URL and a title, which it then
  sends to the Bookmarks portlet in Liferay DXP to create a bookmark.
\item
  \textbf{Read Screenlets:} Read data from a server. The Web Content
  Display Screenlet included with Liferay Screens is a good example of a
  read Screenlet. It retrieves web content from Liferay DXP for display
  in an Android app.
  \href{/docs/7-1/reference/-/knowledge_base/r/webcontentdisplayscreenlet-for-android}{Click
  here} to see Web Content Display Screenlet's documentation.
\end{itemize}

Offline mode implementation differs only slightly between write and read
Screenlets. The tutorials in this section use a write Screenlet (Add
Bookmark Screenlet) to show you how to support offline mode, and point
out any differences needed for a read Screenlet.

Before getting started, be sure to read
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-android-screenlets}{the
basic Screenlet creation tutorial} to familiarize yourself with Add
Bookmark Screenlet's code.

\section{Create or Update the Event
Class}\label{create-or-update-the-event-class}

Recall from the basic Screenlet creation tutorial that an event class is
required to handle communication between Screenlet components. Also
recall that many Screenlets can use the event class included with
Screens, \texttt{BasicEvent}, as their event class. For offline mode to
work, however, you must create an event class that extends
\texttt{CacheEvent}
(\href{https://github.com/liferay/liferay-screens/blob/master/android/library/src/main/java/com/liferay/mobile/screens/base/interactor/event/CacheEvent.java}{click
here} to see \texttt{CacheEvent}). Your event class has one primary
responsibility: store and provide access to the arguments passed to the
Interactor. To accomplish this, your event class should do these things:

\begin{itemize}
\tightlist
\item
  Extend \texttt{CacheEvent}. For the arguments, define variables and
  public getter methods.
\item
  Define a no-argument constructor that only calls the corresponding
  superclass constructor.
\item
  Define a constructor that sets the Interactor's arguments.
\end{itemize}

In the case of Add Bookmark Screenlet, the arguments are the bookmark's
URL, folder ID, and title. For example, here's the full code for this
Screenlet's event class, \texttt{BookmarkEvent}:

\begin{verbatim}
public class BookmarkEvent extends CacheEvent {

    private String url; 
    private String title; 
    private long folderId; 

    public BookmarkEvent() { 
        super(); 
    }

    public BookmarkEvent(String url, String title, long folderId) {

        this.url = url; 
        this.title = title; 
        this.folderId = folderId; 
    }

    public String getURL() { 
        return url; 
    }

    public String getTitle() { 
        return title; 
    }

    public long getFolderId() { 
        return folderId; 
    } 
}
\end{verbatim}

Next, you'll update the listener.

\subsection{Related Topics}\label{related-topics-234}

\href{/docs/7-1/tutorials/-/knowledge_base/t/update-the-listener}{Update
the Listener}

\href{/docs/7-1/tutorials/-/knowledge_base/t/update-the-interactor-class}{Update
the Interactor Class}

\href{/docs/7-1/tutorials/-/knowledge_base/t/update-the-screenlet-class}{Update
the Screenlet Class}

\href{/docs/7-1/tutorials/-/knowledge_base/t/sync-the-cache-with-the-server}{Sync
the Cache with the Server}

\section{Update the Listener}\label{update-the-listener}

Recall from the basic Screenlet creation tutorial that the listener
interface defines a success method and a failure method. This lets
implementing classes respond to the server call's success or failure.
Listeners that support offline mode offer the same functionality,
although differently. Offline mode listeners must extend
\texttt{BaseCacheListener}, which defines only this \texttt{error}
method:

\begin{verbatim}
void error(Exception e, String userAction);
\end{verbatim}

By extending \texttt{BaseCacheListener}, your listener no longer needs
an explicit failure method because it inherits the \texttt{error} method
instead. This \texttt{error} method also includes an argument for the
user action that triggered the exception.

You can therefore update your listener to support offline mode by
extending \texttt{BaseCacheListener} and deleting the failure method.
For example, here's Add Bookmark Screenlet's listener,
\texttt{AddBookmarkListener}, after being updated to support offline
mode:

\begin{verbatim}
public interface AddBookmarkListener extends BaseCacheListener {

    onAddBookmarkSuccess(); 
}
\end{verbatim}

Note that you must also remove any failure method implementations (such
as in an activity or fragment that implements the listener), and replace
any failure method calls with \texttt{error} method calls. You'll do the
latter next when updating the Interactor class.

\subsection{Related Topics}\label{related-topics-235}

\href{/docs/7-1/tutorials/-/knowledge_base/t/create-or-update-the-event-class}{Create
or Update the Event Class}

\href{/docs/7-1/tutorials/-/knowledge_base/t/update-the-interactor-class}{Update
the Interactor Class}

\href{/docs/7-1/tutorials/-/knowledge_base/t/update-the-screenlet-class}{Update
the Screenlet Class}

\href{/docs/7-1/tutorials/-/knowledge_base/t/sync-the-cache-with-the-server}{Sync
the Cache with the Server}

\section{Update the Interactor Class}\label{update-the-interactor-class}

Recall from the basic Screenlet creation tutorial that Interactor
classes extend \texttt{BaseRemoteInteractor} with the listener and event
as type arguments. To support offline mode, your Interactor class must
instead extend one of the following classes. Which one depends on
whether your Interactor writes data to or reads data from a server:

\begin{itemize}
\tightlist
\item
  \texttt{BaseCacheWriteInteractor}: writes data to a server. Extend
  this class if your Screenlet is a write Screenlet.
  \href{https://github.com/liferay/liferay-screens/blob/master/android/library/src/main/java/com/liferay/mobile/screens/base/interactor/BaseCacheWriteInteractor.java}{Click
  here} to see this class.
\item
  \texttt{BaseCacheReadInteractor}: reads data from a server. Extend
  this class if your Screenlet is a read Screenlet.
  \href{https://github.com/liferay/liferay-screens/blob/master/android/library/src/main/java/com/liferay/mobile/screens/base/interactor/BaseCacheReadInteractor.java}{Click
  here} to see this class.
\end{itemize}

In either case, the type arguments are the same: the listener and the
event. Note, however, that the event must extend \texttt{CacheEvent} as
described above. For example, since Add Bookmark Screenlet is a write
Screenlet, to support offline mode its Interactor class must extend
\texttt{BaseCacheWriteInteractor} with \texttt{AddBookmarkListener} and
\texttt{AddBookmarkEvent} as type arguments:

\begin{verbatim}
public class AddBookmarkInteractor extends
    BaseCacheWriteInteractor<AddBookmarkListener, BookmarkEvent> {...
\end{verbatim}

If your Screenlet is a write Screenlet, you must change the Interactor's
\texttt{execute} method to take the event instead of var args (in read
Screenlets, this method can still take var args). You can then retrieve
the data you need from the event. For example, to support offline mode,
the \texttt{execute} method in \texttt{AddBookmarkInteractor} takes
\texttt{BookmarkEvent} as an argument. The bookmark's URL, title, and
folder ID are then retrieved from the event for use in the
\texttt{getJSONObject} method that makes the server call. The
\texttt{execute} method finishes by setting the resulting
\texttt{JSONObject} to the event, and then returning the event:

\begin{verbatim}
@Override 
public BookmarkEvent execute(BookmarkEvent bookmarkEvent) throws Exception {

    validate(bookmarkEvent.getUrl(), bookmarkEvent.getFolderId());

    JSONObject jsonObject = getJSONObject(bookmarkEvent.getUrl(), bookmarkEvent.getTitle(), 
        bookmarkEvent.getFolderId());
    bookmarkEvent.setJSONObject(jsonObject); 
    return bookmarkEvent; 
}
\end{verbatim}

If your Screenlet is a read Screenlet, then you must also implement the
\texttt{getIdFromArgs} method of \texttt{BaseCacheReadInteractor}. This
method takes the var args passed to the Interactor so you can return the
argument that identifies your entity. Note that because this method
requires you to return a \texttt{String}, you'll often use
\texttt{String.valueOf} to return non-string arguments as a string. For
example, the \texttt{getIdFromArgs} implementation in Comment Display
Screenlet's \texttt{CommentLoadInteractor} retrieves the comment ID (a
\texttt{long}) from the first argument and then returns it as a
\texttt{String}:

\begin{verbatim}
 @Override 
 protected String getIdFromArgs(Object... args) { 
     long commentId = (long) args[0]; 
     return String.valueOf(commentId); 
 }
\end{verbatim}

You should also change the \texttt{onSuccess} method to take an instance
of your event class instead of \texttt{BasicEvent}. This is the only
change you need to make to this method. For example, the
\texttt{onSuccess} method in \texttt{AddBookmarkInteractor} supports
offline mode by taking a \texttt{BookmarkEvent} instead of a
\texttt{BasicEvent}:

\begin{verbatim}
@Override 
public void onSuccess(BookmarkEvent event) {
    getListener().onAddBookmarkSuccess(); 
}
\end{verbatim}

Now make the same change to the \texttt{onFailure} method, but replace
the listener's failure method call with a call to the \texttt{error}
method inherited from \texttt{BaseCacheListener} (see the listener
section above for an explanation of this method). For the \texttt{error}
method's arguments, you can retrieve the exception from the event and
define a string to use as the user action. For example, to support
offline mode the \texttt{onFailure} method in
\texttt{AddBookmarkInteractor} takes a \texttt{BookmarkEvent} instead of
a \texttt{BasicEvent}. Also, the method's \texttt{error} call defines
the ``ADD\_BOOKMARK'' string to indicate that the error occurred while
trying to add a bookmark to the server:

\begin{verbatim}
@Override public void onFailure(BookmarkEvent event) {
    getListener().error(event.getException(), "ADD_BOOKMARK"); 
}
\end{verbatim}

\subsection{Related Topics}\label{related-topics-236}

\href{/docs/7-1/tutorials/-/knowledge_base/t/create-or-update-the-event-class}{Create
or Update the Event Class}

\href{/docs/7-1/tutorials/-/knowledge_base/t/update-the-listener}{Update
the Listener}

\href{/docs/7-1/tutorials/-/knowledge_base/t/update-the-screenlet-class}{Update
the Screenlet Class}

\href{/docs/7-1/tutorials/-/knowledge_base/t/sync-the-cache-with-the-server}{Sync
the Cache with the Server}

\section{Update the Screenlet Class}\label{update-the-screenlet-class}

Updating the Screenlet class for offline mode is straightforward. In the
Screenlet class's \texttt{onUserAction} method, you'll change the call
to the Interactor's \texttt{start} method so that it takes only an event
as an argument. Before doing this, however, you should create an event
instance and set its cache key. A cache key is a value that identifies
an entity in the local cache. This lets you retrieve the entity from the
cache for later synchronization with the server.

In Add Bookmark Screenlet, for example, a bookmark's URL makes a good
cache key. To support offline mode, the \texttt{onUserAction} method in
\texttt{AddBookmarkScreenlet} creates a new \texttt{BookmarkEvent}
instance with a bookmark's data and then uses the \texttt{setCacheKey}
method to set the bookmark's URL as the event's cache key. The
Interactor's start method takes this event as its argument:

\begin{verbatim}
BookmarkEvent event = new BookmarkEvent(url, title, folderId);
event.setCacheKey(url); 
interactor.start(event);
\end{verbatim}

Note that you don't have to set a cache key to use offline mode.
Instead, you can pass the event to the \texttt{start} method without
calling \texttt{setCacheKey}. However, this means that you'll only be
able to access the most recent entity in the cache.

That's it! Your write Screenlet now supports offline mode. There's one
more detail to keep in mind, however, when using the Screenlet: syncing
the cache with the server. You'll learn about this next.

\subsection{Related Topics}\label{related-topics-237}

\href{/docs/7-1/tutorials/-/knowledge_base/t/create-or-update-the-event-class}{Create
or Update the Event Class}

\href{/docs/7-1/tutorials/-/knowledge_base/t/update-the-listener}{Update
the Listener}

\href{/docs/7-1/tutorials/-/knowledge_base/t/update-the-interactor-class}{Update
the Interactor Class}

\href{/docs/7-1/tutorials/-/knowledge_base/t/sync-the-cache-with-the-server}{Sync
the Cache with the Server}

\section{Sync the Cache with the
Server}\label{sync-the-cache-with-the-server}

When using a write Screenlet that supports offline mode, new data
written to the cache must also be synced with the server. The write
Screenlets included with Liferay Screens do this for you. However, you
must do this manually when using a custom write Screenlet. You should do
this in the activity or fragment that uses the Screenlet--exactly where
in this activity or fragment is up to you though.

\noindent\hrulefill

\textbf{Note:} You don't have to do this when adding offline mode
support to read Screenlets.

\noindent\hrulefill

To sync a write Screenlet's data with the server manually, follow these
steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Retrieve the event that needs to be synced with the server. To do
  this, you must first get the cache key associated with the event. Then
  use the key as an argument to the \texttt{Cache.getObject} method.
\item
  Call the Interactor with the event. This syncs the data with the
  server.
\end{enumerate}

For example, the following code uses the \texttt{Cache.findKeys} method
to retrieve all \texttt{BookmarkEvent} keys in the cache. The loop that
follows then retrieves the event that corresponds to each key, and syncs
it to the server by calling the Interactor:

\begin{verbatim}
String[] keys = Cache.findKeys(BookmarkEvent.class, groupId, userId, locale, 0, 
    Integer.MAX_VALUE); 
for (String key : keys) {

    BookmarkEvent event = Cache.getObject(BookmarkEvent.class, groupId, userId, key); 
    new AddBookmarkInteractor().execute(event); 
}
\end{verbatim}

Note that if you opted not to set a cache key in your Screenlet class,
you can pass \texttt{null} in place of a key.

Also note that you can use Android's \texttt{SharedPreferences} APIs as
an alternative way to store and retrieve cache keys. For example, the
following code stores cache keys in shared preferences:

\begin{verbatim}
SharedPreferences sharedPreferences = getSharedPreferences("MY_PREFERENCES", Context.MODE_PRIVATE); 
HashSet<String> values = new HashSet<>();
sharedPreferences.edit().putStringSet("keysToSync", values).apply();
\end{verbatim}

You can then retrieve the keys as you would retrieve any other key-value
set from shared preferences:

\begin{verbatim}
SharedPreferences sharedPreferences = getSharedPreferences("MY_PREFERENCES", Context.MODE_PRIVATE); 
HashSet<String> keysToSync = sharedPreferences.getStringSet("keysToSync", new HashSet<>());
\end{verbatim}

\subsection{Related Topics}\label{related-topics-238}

\href{/docs/7-1/tutorials/-/knowledge_base/t/create-or-update-the-event-class}{Create
or Update the Event Class}

\href{/docs/7-1/tutorials/-/knowledge_base/t/update-the-listener}{Update
the Listener}

\href{/docs/7-1/tutorials/-/knowledge_base/t/update-the-interactor-class}{Update
the Interactor Class}

\href{/docs/7-1/tutorials/-/knowledge_base/t/update-the-screenlet-class}{Update
the Screenlet Class}

\section{Supporting Offline Mode in List
Screenlets}\label{supporting-offline-mode-in-list-screenlets}

A list Screenlet is a special type of read Screenlet that displays
entities in a list. Recall from the
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-android-list-screenlets}{list
Screenlet creation tutorial} that list Screenlets have a model class
that encapsulates entities retrieved from the server. To support offline
mode, a list Screenlet's event class must extend \texttt{ListEvent} with
the model class as a type argument. This event class also needs three
things:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  A default constructor
\item
  A \texttt{getListKey} method that returns a unique ID to store the
  entity with
\item
  A \texttt{getModel} method that returns the model instance
\end{enumerate}

The list Screenlet creation tutorial contains example model and event
classes that support offline mode for Bookmark List Screenlet. Click the
following links to see the sections in the tutorial that show you how to
create these classes:

\begin{itemize}
\tightlist
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/creating-the-model-class}{Creating
  the Model Class}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/creating-the-interactor-0\#creating-the-screenlets-event}{Creating
  the Event}
\end{itemize}

\subsection{Related Topics}\label{related-topics-239}

\href{/docs/7-1/tutorials/-/knowledge_base/t/supporting-offline-mode}{Supporting
Offline Mode}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-android-list-screenlets}{Creating
Android List Screenlets}

\section{Using Liferay Push in Android
Apps}\label{using-liferay-push-in-android-apps}

Liferay Screens supports push notifications in Android apps. To use
them, you must configure some APIs and modify your app to consume and/or
produce push notifications. This tutorial shows how to do all these
things.

\subsection{Configuring to Use Liferay Push
Notifications}\label{configuring-to-use-liferay-push-notifications}

Your first step is to create and configure a Google project to use
Google Cloud Messaging
(\href{https://developers.google.com/cloud-messaging/}{GCM}). You also
need to configure the Liferay Push app to use the project's GCM API.

Follow these steps to create and configure a Google project to support
cloud messaging:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  On the
  \href{https://developers.google.com/cloud-messaging/android/start/}{Google
  Cloud Messaging page}, create a configuration file by clicking
  \emph{Get a Configuration File}. On the screen that appears, set your
  \emph{App name} and \emph{Android package name}, and then click
  \emph{Continue To Choose and Configure Services}. On the next screen,
  click \emph{Enable Google Cloud Messaging}.
\item
  Copy and save the \emph{Server API Key} and \emph{Sender ID} values
  you're presented with. You'll need to use these values later as the
  push notifications API keys for Liferay Push.

  \begin{figure}
  \centering
  \includegraphics{./images/screens-android-push-project-and-server-key.png}
  \caption{You need the Server API Key and Sender ID to enable Liferay
  Push.}
  \end{figure}
\end{enumerate}

Now that you've set up your Google project, you can configure the
Liferay Push app to use the project's GCM API. Install the Liferay Push
app from the \href{http://www.liferay.com/marketplace}{Liferay
Marketplace}. In your Liferay DXP instance's Control Panel, navigate to
\emph{Configuration} → \emph{System Settings}, select the \emph{Other}
tab, then select \emph{Android Push Notifications Sender}. Set the push
notifications \emph{API Key} to the value of the Server API Key you
generated in your Google project. You can also set the number of retries
in the event that sending a notification fails.

\begin{figure}
\centering
\includegraphics{./images/push-android-settings.png}
\caption{Set the API key and number of retries in your Liferay DXP
instance.}
\end{figure}

Great! Your Liferay DXP instance is now ready to send push notifications
to your Android apps!

\subsection{Receiving and Sending Push
Notifications}\label{receiving-and-sending-push-notifications}

\href{https://github.com/liferay-mobile/liferay-push-android}{The
Liferay Push Client for Android} streamlines registering a device with
the portal for receiving and sending push notifications. Although the
information below contains the main steps needed to use the client, the
\href{https://github.com/liferay-mobile/liferay-push-android/blob/master/README.md}{readme}
explains them in detail.

In your Android application's Gradle build file,
\href{/docs/7-1/tutorials/-/knowledge_base/t/configuring-dependencies}{add
a new dependency} on the Liferay Push Client for Android:

\begin{verbatim}
dependencies {

    ...

    implementation 'com.liferay.mobile:liferay-push:1.2.1'
}
\end{verbatim}

Make sure your app's \texttt{liferay-plugin-package.properties} file
specifies the Push Notifications portlet as a required deployment
context:

\begin{verbatim}
required-deployment-contexts=\
    push-notifications-portlet\
    ...
\end{verbatim}

Next, you'll learn how to register listeners for push notifications.

\subsubsection{Receiving Push
Notifications}\label{receiving-push-notifications}

First, register your device in GCM with the \texttt{SENDER\_ID} you
generated previously:

\begin{verbatim}
Session session = new SessionImpl(YOUR_SERVER, new BasicAuthentication(YOUR_USER, YOUR_PASSWORD));

Push.with(session).register(this, YOUR_SENDER_ID);
\end{verbatim}

If you're using Liferay Screens to maintain a session, you can retrieve
it and use it instead of creating a new one:

\begin{verbatim}
Push.with(SessionContext.createSessionFromCurrentSession()).register(this, YOUR_SENDER_ID);
\end{verbatim}

If you use these example lines of code, make sure to replace
\texttt{YOUR\_SERVER}, \texttt{YOUR\_USER}, \texttt{YOUR\_PASSWORD}, and
\texttt{YOUR\_SENDER\_ID} with your own values.

That's it! You can attach a listener to store the registration ID or to
process the notification sent to the activity (using
\texttt{onPushNotification()}). You can also register a receiver and
service to process the notification. You can refer to the
\href{https://github.com/liferay/liferay-screens/tree/master/android/samples/pushnotifications}{Push
Notifications project} as an example push notifications implementation.

Next, you'll learn how to send push notifications.

\subsubsection{Sending Push
Notifications}\label{sending-push-notifications}

Using the Liferay Push app, sending notifications to your app's users is
straightforward. You can specify the user IDs along with the message
content:

\begin{verbatim}
PushNotificationsDeviceLocalServiceUtil.sendPushNotification(userIds, content);
\end{verbatim}

This \href{https://github.com/nhpatt/push-with-ddl-hook}{example hook
plugin} sends a push notification each time a user creates a new DDL
record or updates an existing one.

In your app's \texttt{portal.properties} file, you can add a listener
for a class by creating a
\href{https://docs.liferay.com/portal/6.2/propertiesdoc/portal.properties.html\#Value\%20Object}{\emph{value.object.listener}}
property, set to a comma separated list of intended listener classes.
Here's an example listener setting for \texttt{DDLRecord} objects:

\begin{verbatim}
value.object.listener.com.liferay.portlet.dynamicdatalists.model.DDLRecord=com.liferay.push.hooks.DDLRecordModelListener
\end{verbatim}

Great! Now you know how to configure your Android apps to receive push
notifications from Liferay DXP.

In this tutorial, you've configured your portal to accommodate push
notifications, registered notification listeners, and implemented
sending push notifications. Way to go!

\subsection{Related Topics}\label{related-topics-240}

\href{/docs/7-1/tutorials/-/knowledge_base/t/preparing-android-projects-for-liferay-screens}{Preparing
Android Projects for Liferay Screens}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-screenlets-in-android-apps}{Using
Screenlets in Android Apps}

\section{Accessing the Liferay Session in
Android}\label{accessing-the-liferay-session-in-android}

A session is a conversation state between the client and server. It
typically consists of multiple requests and responses between the two.
To facilitate this communication, the session must have the server IP
address, and a user's login credentials. Liferay Screens uses a Liferay
Session to access and query the JSON web services provided by Liferay
Portal. When you log in using a Liferay Session, the portal returns the
user's information (name, email, user ID, etc\ldots). Screens stores
this information and the active Liferay Session in Screens's
\texttt{SessionContext} class.

The \texttt{SessionContext} class is very powerful and lets you use
Screens in many different scenarios. For example, you can use
\texttt{SessionContext} to request information with the JSON WS API
provided by Liferay. You can also use \texttt{SessionContext} to create
anonymous sessions, or to log in a user without showing a Login
Screenlet.

This tutorial explains some common \texttt{SessionContext} use cases,
and and also describes the class's most important methods.

\subsection{Creating a Session from an Existing
Session}\label{creating-a-session-from-an-existing-session}

When working with Liferay Screens, you may wish to call the remote JSON
web services provided by the Liferay Mobile SDK. Every operation with
the Liferay Mobile SDK needs a Liferay Session to provide the server
address, user credentials, and any other required parameters. Since the
Login Screenlet creates a session when a user successfully logs in, you
can retrieve this session with the \texttt{SessionContext} method
\texttt{createSessionFromCurrentSession()}. You can then use that
session to make the Mobile SDK service call. The following example shows
this for calling the Mobile SDK's \texttt{BookmarksEntryService}:

\begin{verbatim}
Session sessionFromCurrentSession = SessionContext.createSessionFromCurrentSession();
sessionFromCurrentSession.setCallback(callback);

new BookmarksEntryService(sessionFromCurrentSession).methodCall()
\end{verbatim}

If you need to check first to see if a user has logged in, you can use
\texttt{SessionContext.isLoggedIn()}.

Great! Now you know how to retrieve an existing session in your app. But
what if you're not using the Login Screenlet? There won't be an existing
session to retrieve. No sweat! You can still use \texttt{SessionContext}
to create one manually. The next section shows you how to do this.

\subsection{Creating a Session
Manually}\label{creating-a-session-manually}

If you don't use the Login Screenlet, then \texttt{SessionContext}
doesn't have a session for you to retrieve. In this case, you must
create one manually. You can do this with the \texttt{SessionContext}
method \texttt{createBasicSession}. The method takes a username and
password as parameters, and creates a session with those credentials. If
you also need to access a user's information, you must manually call the
\texttt{User} JSON web service, or call
\texttt{SessionContext.setLoggedUser()}. The following code creates a
session with \texttt{createBasicSession} and then uses
\texttt{setLoggedUser} to set the user in \texttt{SessionContext}:

\begin{verbatim}
LiferayScreensContext.init(this);

Session session = SessionContext.createBasicSession(USERNAME, PASSWORD);
SessionContext.setLoggedUser(USER);
\end{verbatim}

Note that you can achieve the same thing by calling the interactor
directly:

\begin{verbatim}
LoginBasicInteractor loginBasicInteractor = new LoginBasicInteractor(0);
loginBasicInteractor.onScreenletAttached(this);
loginBasicInteractor.setLogin(USERNAME);
loginBasicInteractor.setPassword(PASSWORD);
loginBasicInteractor.login();
\end{verbatim}

Super! Now you know how to create a session manually. The next section
shows you how to implement auto-login, and save or restore a session.

\subsection{Implementing Auto-login and Saving or Restoring a
Session}\label{implementing-auto-login-and-saving-or-restoring-a-session}

Although the Login Screenlet is awesome, your users may not want to
enter their credentials every time they open your app. It's very common
for apps to only require a single login. To implement this in your app,
see \href{https://www.youtube.com/watch?v=kEZEahTzuck}{this video}.

In short, you need to pass a storage type to the Login Screenlet, and
then use \texttt{SessionContext.isLoggedIn()} to check for a session. If
a session doesn't exist, load the stored session from
\texttt{CredentialsStorage} with
\texttt{loadStoredCredentials(StorageType\ storageType)}. The following
code shows a typical implementation of this:

\begin{verbatim}
LiferayScreensContext.init(this); // If you haven't called a Screenlet yet
SessionContext.loadStoredCredentials(SHARED_PREFERENCES);

if (SessionContext.isLoggedIn()) {
    // logged in
    // consider doing a relogin here (see next section)
} else {
    // send user to login form
}
\end{verbatim}

Awesome! Now you know how to implement auto-login in your Liferay
Screens apps. For more information on available \texttt{SessionContext}
methods, see the \hyperref[methods]{Methods section} at the end of this
tutorial. Next, you'll learn how to implement relogin for cases where a
user's credentials change on the server while they're logged in.

\subsection{Implementing Relogin}\label{implementing-relogin}

A session, whether created via Login Screenlet or auto-login, contains
basic user data that verifies the user in the Liferay instance. If that
data changes in the server, then your session is outdated, which may
cause your app to behave inconsistently. Also, if a user is deleted,
deactivated, or otherwise changes their credentials in the server, the
auto-login feature won't deny access because it doesn't perform server
transactions: it only retrieves an existing session from local storage.
This isn't an optimal situation!

For such scenarios, you can use the relogin feature. This feature is
implemented in a simple method that determines if the current session is
still valid. If the session is still valid, the user's data is updated
with the most recent data from the server. If the session isn't valid,
the user is logged out and must then log in again to create a new
session.

To use this feature, call the \texttt{SessionContext} method
\texttt{relogin}, with an object that implements the
\texttt{LoginListener} interface as an argument:

\begin{verbatim}
SessionContext.relogin(listener);
\end{verbatim}

This method handles success or failure via the listener's
\texttt{onLoginSuccess} and \texttt{onLoginFailure} methods,
respectively. Note that this operation is done asynchronously in a
background thread, so the listener is called in that thread. If you also
want to perform any UI operations, you must do so in your UI thread. For
example:

\begin{verbatim}
@Override
public void onLoginSuccess(final User user) {
    runOnUiThread(new Runnable() {
        @Override
        public void run() {
            // do any UI operation here
        }
    });
}
\end{verbatim}

Great! Now you know how to implement relogin in your app. You've also
seen how handy \texttt{SessionContext} can be. It can do even more! The
next section lists some additional \texttt{SessionContext} methods, and
some more detail on the ones used in this tutorial.

\subsection{Methods}\label{methods}

\noindent\hrulefill

Method \textbar{} Return Type \textbar{} Explanation \textbar{}
\texttt{logout()} \textbar{} \texttt{void} \textbar{} Clears the stored
user attributes and session. \textbar{} \texttt{relogin(LoginListener)}
\textbar{} \texttt{void} \textbar{} Refreshes user data from the server.
This recreates the \texttt{currentUser} object if successful, or calls
\texttt{logout()} on failure. When the server data is received, the
listener method \texttt{onLoginSuccess} is called with received user's
attributes. If an error occurs, the listener method
\texttt{onLoginFailure} is called. \textbar{} \texttt{isLoggedIn()}
\textbar{} \texttt{boolean} \textbar{} Returns \texttt{true} if there is
a stored Liferay Session in \texttt{SessionContext}. \textbar{}
\texttt{createBasicSession(String\ username,\ String\ password)}
\textbar{} \texttt{Session} \textbar{} Creates a Liferay Session using
the default server and the supplied username and password. \textbar{}
\texttt{createSessionFromCurrentSession()} \textbar{} \texttt{Session}
\textbar{} Creates a Liferay Session based on the stored credentials and
server. \textbar{} \texttt{getCurrentUser()} \textbar{} \texttt{User}
\textbar{} Returns a \texttt{User} object containing the server
attributes of the logged-in user. This includes the user's email, user
ID, name, and portrait ID. \textbar{}
\texttt{storeCredentials(StorageType\ storageType)} \textbar{}
\texttt{void} \textbar{} Stores the current session in the
\texttt{StorageType} supplied as a parameter. \textbar{}
\texttt{removeStoredCredentials(StorageType\ storageType)} \textbar{}
\texttt{void} \textbar{} Clears the \texttt{StorageType} of any user
information and session. \textbar{}
\texttt{loadStoredCredentials(StorageType\ storageType)} \textbar{}
\texttt{void} \textbar{} Loads the session and user information from the
\texttt{StorageType} parameter, and uses it as the current session and
user. \textbar{}

\noindent\hrulefill

For more information, see the
\href{https://github.com/liferay/liferay-screens/blob/master/android/library/core/src/main/java/com/liferay/mobile/screens/context/SessionContext.java}{\texttt{SessionContext}
source code in GitHub}.

\subsection{Related Topics}\label{related-topics-241}

\href{/docs/7-1/reference/-/knowledge_base/r/loginscreenlet-for-android}{Login
Screenlet for Android}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-screenlets-in-android-apps}{Using
Screenlets in Android Apps}

\section{Adding Custom Interactors to Android
Screenlets}\label{adding-custom-interactors-to-android-screenlets}

Interactors are Screenlet components that implement server communication
for a specific use case. For example, the Login Screenlet's interactor
calls the Liferay Mobile SDK service that authenticates a user to the
portal. Similarly, the Interactor for
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-android-screenlets}{the
Add Bookmark Screenlet} calls the Liferay Mobile SDK service that adds a
bookmark to the Bookmarks portlet.

That's all fine and well, but what if you want to customize a
Screenlet's server call? What if you want to use a different back-end
with a Screenlet? No problem! You can implement a custom interactor for
the Screenlet. You can plug in a different interactor that makes its
server call by using custom logic or network code. To do this, you must
implement the current interactor's interface and then pass it to the
Screenlet you want to override. You should do this inside your app's
code, either in an inner class or a separate class.

In this tutorial, you'll see an example interactor that overrides the
Login Screenlet to always log in the same user, without a password. You
can find the complete code in the
\href{https://github.com/liferay/liferay-screens/blob/master/android/samples/test-app/src/main/java/com/liferay/mobile/screens/testapp/CustomInteractorActivity.java}{test-app
on GitHub.}. Note that this example implements the custom interactor in
an inner class of an activity.

\subsection{Implementing a Custom
Interactor}\label{implementing-a-custom-interactor}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Implement your custom interactor. You must inherit the original
  interactor's interface, as shown here:

\begin{verbatim}
 private class CustomLoginInteractor extends LoginBasicInteractor {

     public CustomLoginInteractor(int targetScreenletId) {
         super(targetScreenletId);
     }

     @Override
     public void login() throws Exception {
         //custom implementation
     }
 }
\end{verbatim}
\item
  Call the interactor's listener. In your custom logic, you must call
  the interactor's listener. In this example, you must call
  \texttt{onLoginFailure} and \texttt{onLoginSuccess}, depending on your
  custom logic's result:

\begin{verbatim}
 if (SUCCESS) {
     getListener().onLoginSuccess(fakeUser);
 }
 else {
     getListener().onLoginFailure(new AuthenticationException("bad login"));
 }
\end{verbatim}
\item
  Return your interactor in the custom listener. You must use
  \texttt{setCustomInteractorListener} to set a specific listener that
  expects an Interactor created with \texttt{actionName} (a string):

\begin{verbatim}
 _screenlet.setCustomInteractorListener(this);

 @Override
 public LoginInteractor createInteractor(String actionName) {
     return new CustomLoginInteractor(_loginScreenlet.getScreenletId());
 }
\end{verbatim}
\end{enumerate}

Great! Now you know how to implement custom interactors for Android
Screenlets. The next example builds on this by showing you how to access
non-Liferay backends with a custom interactor.

\subsection{Using Custom Interactors to Access Other
Backends}\label{using-custom-interactors-to-access-other-backends}

Custom interactors are also capable of communicating with non-Liferay
backends. The following example illustrates this by creating a custom
interactor for the
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-android-screenlets}{Add
Bookmark Screenlet} that can store bookmarks at
\href{https://delicious.com}{Delicious}. You can find this example's
complete code
\href{https://gist.github.com/nhpatt/7cbeb0df6f39ec8a9176}{at this
gist}.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a new custom interactor. This interactor inherits
  \texttt{BaseRemoteInteractor}, the base class of all interactors, with
  \texttt{AddBookmarkListener} as a type parameter. It also implements
  the \texttt{AddBookmarkInteractor} class. The base code for this new
  interactor is shown here:

\begin{verbatim}
 public class AddDeliciousInteractorImpl extends BaseRemoteInteractor<AddBookmarkListener>
     implements AddBookmarkInteractor {

     public AddDeliciousInteractorImpl(int targetScreenletId) {
         super(targetScreenletId);
     }

     public void addBookmark(final String url, final String title, long folderId) throws Exception {
         ...
     }
 }
\end{verbatim}
\item
  Implement your custom logic. In this example, you must implement the
  code for accessing Delicious and inserting a new bookmark with the
  Delicious API. You can use the
  \href{http://square.github.io/okhttp/}{OkHttp library} to pass the API
  your bookmark's URL and description. The following code shows this:

\begin{verbatim}
 new Thread(new Runnable() {
     @Override
     public void run() {
         try {

             Headers headers = Headers.of("Authorization", "Bearer _OAUTH_TOKEN_");

             OkHttpClient client = new OkHttpClient();

             Request add = new Request.Builder()
                 .url("https://api.del.icio.us/api/v1/posts/add?url=" + url + "&description=" + title)
                 .headers(headers)
                 .build();

             com.squareup.okhttp.Response response = client.newCall(get).execute();

             String text = response.body().string();

             ...

         }
         catch (IOException e) {
             LiferayLogger.e("Error sending", e);
             ...
         }
     }
 }).start();
\end{verbatim}
\item
  Notify your app of the results. You should use the
  \texttt{EventBusUtil} class to post an event for this. Use the event
  to let other classes listen for the event. The following code uses
  \texttt{EventBusUtil.post(text)} to post the event, and the
  \texttt{onEvent} method to notify the listener:

\begin{verbatim}
 EventBusUtil.post(text);

 ...

 public void onEvent(String text) {
     getListener().onAddBookmarkSuccess();
 }
\end{verbatim}

  Note that the code in
  \href{https://gist.github.com/nhpatt/7cbeb0df6f39ec8a9176}{the gist}
  uses the custom \texttt{BookmarkAdded} class to model the operation's
  results.
\item
  In the activity or fragment you're using the Screenlet in, implement
  \texttt{CustomInteractorListener}. You must also reference your new
  custom interactor and connect it to the Screenlet:

\begin{verbatim}
 _screenlet.setCustomInteractorListener(this);

 @Override
 public Interactor createInteractor(String actionName) {
     return new AddDeliciousInteractorImpl(_screenlet.getScreenletId());
 }
\end{verbatim}
\end{enumerate}

Awesome! Now you know how to create a custom interactor that can
communicate with a non-Liferay backend. This opens up even more
possibilities for your apps.

\subsection{Related Topics}\label{related-topics-242}

\href{/docs/7-1/tutorials/-/knowledge_base/t/architecture-of-liferay-screens-for-android}{Architecture
of Liferay Screens for Android}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-android-screenlets}{Creating
Android Screenlets}

\section{Rendering Web Content in Your Android
App}\label{rendering-web-content-in-your-android-app}

Liferay DXP represents
\href{/docs/7-1/user/-/knowledge_base/u/creating-web-content}{web
content} articles as \texttt{JournalArticle} entities. Liferay Screens
provides several ways to render these entities in your apps.

The simplest way to display a \texttt{JournalArticle}'s HTML in your app
is to use
\href{/docs/7-1/reference/-/knowledge_base/r/webcontentdisplayscreenlet-for-android}{Web
Content Display Screenlet}. This Screenlet is very powerful and supports
several complex use cases to fit your needs. You can also use
\href{/docs/7-1/reference/-/knowledge_base/r/web-content-list-screenlet-for-android}{Web
Content List Screenlet} to display lists of web content articles. This
tutorial shows you how to use both Screenlets to display web content in
your apps.

\subsection{Retrieving Basic Web
Content}\label{retrieving-basic-web-content}

Web Content Display Screenlet's simplest use case is to render a
\texttt{JournalArticle}'s HTML in an
\href{http://developer.android.com/guide/webapps/webview.html}{Android
\texttt{WebView}}. Simply provide the \texttt{JournalArticle}'s
\texttt{articleId} in the Screenlet XML, and the Screenlet takes care of
the rest (including decorating itself with the CSS needed to render it
in a small display). The following Screenlet XML shows this:

\begin{verbatim}
<com.liferay.mobile.screens.webcontent.display.WebContentDisplayScreenlet
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    app:articleId="YOUR_ARTICLE_ID" />
\end{verbatim}

To render the content \emph{exactly} as it appears on your mobile site,
however, you must provide the CSS inline or use a template. The HTML
returned isn't aware of a Liferay instance's global CSS.

You can also use a listener to modify the HTML, as explained in the
\href{/docs/7-1/reference/-/knowledge_base/r/webcontentdisplayscreenlet-for-android}{Screenlet
reference documentation}.

In the default security policy, an Android \texttt{WebView} doesn't
execute a page's JavaScript. You can enable such JavaScript execution by
setting the \texttt{javascriptEnabled} property via XML:

\begin{verbatim}
<com.liferay.mobile.screens.webcontent.display.WebContentDisplayScreenlet
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    app:articleId="YOUR_ARTICLE_ID"
    app:javascriptEnabled="true" />
\end{verbatim}

Alternatively, you can set this property in your app's fragment or
activity class that contains the Screenlet:

\begin{verbatim}
...
screenlet.setJavascriptEnabled(true);
...
\end{verbatim}

You can also use the \texttt{isJavascriptEnabled()} method to check this
property's setting.

As you can see, this is all straightforward. What could go wrong? Famous
last words. A common mistake is to use the default \texttt{groupId}
instead of the one for the site that contains your
\texttt{JournalArticle} entities.

If you need to use a default \texttt{groupId} in the rest of your app,
but render another site's HTML, you can set the Web Content Display
Screenlet's \texttt{groupId} with the \texttt{app:groupId} attribute.
You can alternatively use the \texttt{setGroupId} method in the activity
or fragment code that uses the Screenlet.

\subsection{Using Templates}\label{using-templates}

Web Content Display Screenlet can also use
\href{/docs/7-1/user/-/knowledge_base/u/designing-web-content-with-templates}{templates}
to render \texttt{JournalArticle} entities. For example, your Liferay
instance may have a custom template specifically designed to display
content on mobile devices.

To use a template, specify its ID in the Screenlet XML's
\texttt{templateId} property:

\begin{verbatim}
<com.liferay.mobile.screens.webcontent.display.WebContentDisplayScreenlet
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    app:articleId="YOUR_ARTICLE_ID"
    app:templateId="YOUR_TEMPLATE_ID" />
\end{verbatim}

\subsection{Using Structures}\label{using-structures}

Since mobile devices have limited screen space, you must often display
only the most important parts of a web content article. If your web
content is
\href{/docs/7-1/user/-/knowledge_base/u/designing-web-content-with-templates}{structured},
you can do this by using Web Content Display Screenlet to display only
specific fields from a \texttt{JournalArticle}'s structure. The simplest
way to do this is to specify the structure's ID and a comma-delimited
list of fields in the Screenlet XML's \texttt{structureId} and
\texttt{labelFields} attributes, respectively. The following example
illustrates this:

\begin{verbatim}
<com.liferay.mobile.screens.webcontent.display.WebContentDisplayScreenlet
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    liferay:articleId="YOUR_ARTICLE_ID"
    liferay:labelFields="YOUR_LABELS"
    liferay:layoutId="@layout/webcontentdisplay_structured_default"
    liferay:structureId="YOUR_STRUCTURE_ID" />
\end{verbatim}

You can also use your own layout to render the structure fields exactly
how you want. To do this, your layout should inherit from
\texttt{WebContentStructuredDisplayView} and read the information parsed
and stored in the \texttt{webContent} entity. By displaying two
structure fields with such a custom layout, the
\href{https://github.com/liferay/liferay-screens/tree/master/android/samples/test-app}{test
app} contains a complete example of this:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  The
  \href{https://github.com/liferay/liferay-screens/blob/master/android/samples/test-app/src/main/res/layout/webcontentdisplaystructured_example.xml}{layout
  file \texttt{webcontentdisplaystructured\_example.xml}} defines the
  custom layout:

\begin{verbatim}
 <com.liferay.mobile.screens.testapp.webviewstructured.WebContentDisplayView 
     xmlns:android="http://schemas.android.com/apk/res/android"
     android:layout_width="match_parent"
     android:layout_height="match_parent">

     <TextView
         android:id="@+id/web_content_first_field"
         android:layout_width="match_parent"
         android:layout_height="wrap_content"
         android:background="@android:color/holo_red_light" />

     <TextView
         android:id="@+id/web_content_second_field"
         android:layout_width="match_parent"
         android:layout_height="wrap_content"
         android:background="@android:color/holo_green_light" />

 </com.liferay.mobile.screens.testapp.webviewstructured.WebContentDisplayView>
\end{verbatim}
\item
  The
  \href{https://github.com/liferay/liferay-screens/blob/master/android/samples/test-app/src/main/java/com/liferay/mobile/screens/testapp/webviewstructured/WebContentDisplayView.java}{\texttt{WebContentDisplayView}
  class} sets the custom layout's functionality:

\begin{verbatim}
 public class WebContentDisplayView extends WebContentStructuredDisplayView {

     ...

     @Override
     public void showFinishOperation(WebContent webContent) {
         super.showFinishOperation(webContent);

         DDMStructure ddmStructure = webContent.getDDMStructure();

         TextView firstField = (TextView) findViewById(R.id.first_field);
         firstField.setText(String.valueOf(ddmStructure.getField(0).getCurrentValue()));

         TextView secondField = (TextView) findViewById(R.id.second_field);
         secondField.setText(String.valueOf(ddmStructure.getField(1).getCurrentValue()));
     }
 }
\end{verbatim}
\item
  The
  \href{https://github.com/liferay/liferay-screens/blob/master/android/samples/test-app/src/main/res/layout/web_content_display_structured.xml}{Screenlet
  XML's} \texttt{layoutId} attribute specifies the custom layout to use:

\begin{verbatim}
 <com.liferay.mobile.screens.webcontent.display.WebContentDisplayScreenlet
     android:layout_width="match_parent"
     android:layout_height="wrap_content"
     liferay:articleId="@string/liferay_article_structured_article_id"
     liferay:labelFields="@string/liferay_article_structured_label_fields_first_field"
     liferay:layoutId="@layout/webcontentdisplaystructured_example"
     liferay:offlinePolicy="REMOTE_FIRST"
     liferay:structureId="@string/liferay_article_structured_structure_id" />
\end{verbatim}
\end{enumerate}

Great! Now you know how to use structured web content with Web Content
Display Screenlet. Next, you'll learn how to display a list of web
content articles in your app.

\subsection{Displaying a List of Web Content
Articles}\label{displaying-a-list-of-web-content-articles}

The preceding examples show you how to use Web Content Display Screenlet
to display a single web content article's contents in your app. But what
if you want to display a list of articles instead? No problem! You can
use Web Content List Screenlet for this. Web Content List Screenlet can
retrieve the contents of a web content folder and display only the
labels you want. The Screenlet is also aware of
\href{/docs/7-1/user/-/knowledge_base/u/designing-web-content-with-templates}{structured}
content, so you can render each row with certain structure fields. You
can also do this via a custom layout.

To use a web content folder with Web Content List Screenlet, specify the
folder's ID in the Screenlet XML's \texttt{folderId} attribute. To
render a specific structure field for each article in the list, specify
that field in the Screenlet XML's \texttt{labelFields} attribute. For
example:

\begin{verbatim}
<com.liferay.mobile.screens.webcontent.list.WebContentListScreenlet
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    app:folderId="YOUR_FOLDER_ID"
    app:labelFields="Text" />
\end{verbatim}

You can also see an example of this in the test app's
\href{https://github.com/liferay/liferay-screens/blob/master/android/samples/test-app/src/main/res/layout/web_content_display_list.xml}{\texttt{web\_content\_display\_list.xml}
layout file}.

Also note that several methods in
\href{https://github.com/liferay/liferay-screens/blob/master/android/library/src/main/java/com/liferay/mobile/screens/webcontent/WebContent.java}{Screens's
\texttt{WebContent} class} help you render content from different
locales. For example, \texttt{getLocalized(name)} receives a field's
name and returns the value in the mobile device's current locale. Such
methods help you render a custom view without worrying about the
underlying structure, XML parsing, or HTTP calls.

\subsection{Displaying a List of
Assets}\label{displaying-a-list-of-assets}

To render a list of different assets in your app, including web content
articles, you can use Asset List Screenlet. Asset List Screenlet can
display a list of any assets from a Liferay instance. Like Web Content
List Screenlet, you can also access a web content article's structure
fields, or use a custom layout to render each asset type. For more
information, see the
\href{/docs/7-1/reference/-/knowledge_base/r/assetlistscreenlet-for-android}{reference
documentation for Asset List Screenlet}.

\subsection{Related Topics}\label{related-topics-243}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-screenlets-in-android-apps}{Using
Screenlets in Android Apps}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-views-in-android-screenlets}{Using
Views in Android Screenlets}

\href{/docs/7-1/reference/-/knowledge_base/r/webcontentdisplayscreenlet-for-android}{Web
Content Display Screenlet for Android}

\href{/docs/7-1/reference/-/knowledge_base/r/web-content-list-screenlet-for-android}{Web
Content List Screenlet for Android}

\href{/docs/7-1/reference/-/knowledge_base/r/assetlistscreenlet-for-android}{Asset
List Screenlet for Android}

\section{Rendering Web Pages in Your Android
App}\label{rendering-web-pages-in-your-android-app}

The
\href{/docs/7-1/tutorials/-/knowledge_base/t/rendering-web-content-in-your-android-app}{Rendering
Web Content} tutorial shows you how to display
\href{/docs/7-1/user/-/knowledge_base/u/introduction-web-content}{web
content} from a Liferay DXP site in your Android app. Displaying content
is great, but what if you want to display an entire page? No problem!
\href{/docs/7-1/reference/-/knowledge_base/r/web-screenlet-for-android}{Web
Screenlet} lets you display any web page. You can even customize the
page by injecting local or remote JavaScript and CSS files. When
combined with Liferay DXP's server-side customization features (e.g.,
\href{/docs/7-1/user/-/knowledge_base/u/styling-apps-and-assets}{Application
Display Templates}), Web Screenlet gives you almost limitless
possibilities for displaying web pages in your Android apps.

In this tutorial, you'll learn how to use Web Screenlet to display web
pages in your Android app.

\subsection{Inserting Web Screenlet in Your
App}\label{inserting-web-screenlet-in-your-app}

Inserting Web Screenlet in your app is the same as
\href{/docs/7-1/tutorials/-/knowledge_base/t/using-screenlets-in-android-apps}{inserting
any Screenlet in your app}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Insert the Screenlet's XML in the layout of the activity or fragment
  you want to use the Screenlet in. Also be sure to set any attributes
  that you need. For a list of Web Screenlet's available attributes, see
  \href{/docs/7-1/reference/-/knowledge_base/r/web-screenlet-for-android\#attributes}{the
  Attributes section} of the Web Screenlet reference doc.

  For example, here's Web Screenlet's XML with the Screenlet's
  \texttt{layoutId} and \texttt{autoLoad} attributes set to
  \texttt{web\_default} and \texttt{false}, respectively:

\begin{verbatim}
<com.liferay.mobile.screens.web.WebScreenlet
    android:id="@+id/web_screenlet"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    app:layoutId="@layout/web_default"
    app:autoLoad="false"
    /> 
\end{verbatim}

  Note that \texttt{web\_default} specifies the Screenlet's Default
  View, which is part of the Default View Set.
\item
  To use a View that is part of a View Set, like the Default View, the
  app or activity theme must inherit the theme that sets the View Set's
  styles. For the Default View Set, this is \texttt{default\_theme}. For
  example, to set the app's theme to inherit \texttt{default\_theme},
  open \texttt{res/values/styles.xml} and set the base app theme's
  parent to \texttt{default\_theme}. In this example, the base app theme
  is \texttt{AppTheme}:

\begin{verbatim}
<style name="AppTheme" parent="default_theme">
    ...
\end{verbatim}
\end{enumerate}

Next, you'll implement Web Screenlet's listener.

\subsection{Implementing Web Screenlet's
Listener}\label{implementing-web-screenlets-listener}

To use any Screenlet in an activity or fragment, you must also implement
the Screenlet's listener in that activity or fragment's class. Web
Screenlet's listener is \texttt{WebListener}. Follow these steps to
implement \texttt{WebListener}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Change the class declaration to implement \texttt{WebListener}, and
  import \texttt{com.liferay.mobile.screens.web.WebListener}:

\begin{verbatim}
...
import com.liferay.mobile.screens.web.WebListener;
...

public class YourActivity extends AppCompatActivity implements WebListener {...
\end{verbatim}
\item
  Implement \texttt{WebListener}'s \texttt{onPageLoaded} method. This
  method is called when the Screenlet loads the page successfully. How
  you implement it depends on what (if anything) you want to happen upon
  page load. For example, this \texttt{onPageLoaded} implementation
  displays a toast message indicating success:

\begin{verbatim}
@Override
public void onPageLoaded(String url) {
    Toast.makeText(this, "Page load successful!", Toast.LENGTH_SHORT).show();
}
\end{verbatim}
\item
  Implement \texttt{WebListener}'s \texttt{onScriptMessageHandler}
  method. This method is called when
  \href{https://developer.android.com/reference/android/webkit/WebView.html}{the
  Screenlet's \texttt{WebView}} sends a message. The \texttt{namespace}
  argument is the source namespace key, and the \texttt{body} argument
  is the source namespace body. For example, this
  \texttt{onScriptMessageHandler} implementation parses data from the
  source namespace body if it matches a specific namespace, and then
  starts a new activity with that data via an intent:

\begin{verbatim}
@Override
public void onScriptMessageHandler(String namespace, String body) {
    if ("gallery".equals(namespace)) {
        String[] allImgSrc = body.split(",");
        int imgSrcPosition = Integer.parseInt(allImgSrc[allImgSrc.length - 1]);

        Intent intent = new Intent(getApplicationContext(), DetailMediaGalleryActivity.class);
        intent.putExtra("allImgSrc", allImgSrc);
        intent.putExtra("imgSrcPosition", imgSrcPosition);
        startActivity(intent);
    }
}
\end{verbatim}
\item
  Implement the \texttt{error} method. This method is called when an
  error occurs in the process. The \texttt{e} argument contains the
  exception, and the \texttt{userAction} argument distinguishes the
  specific action in which the error occurred. In most cases, you'll use
  these arguments to log or display the error. For example, this
  \texttt{error} implementation displays a toast message with the
  exception's message:

\begin{verbatim}
@Override
public void error(Exception e, String userAction) {
    Toast.makeText(this, "Bad things happened: " + e.getMessage(), Toast.LENGTH_LONG).show();
}
\end{verbatim}
\item
  Get a \texttt{WebScreenlet} reference and set the activity or fragment
  class as its listener. To do so, import
  \texttt{com.liferay.mobile.screens.web.WebScreenlet} and add the
  following code to the end of the \texttt{onCreate} method:

\begin{verbatim}
WebScreenlet screenlet = (WebScreenlet) findViewById(R.id.web_screenlet);
screenlet.setListener(this);
\end{verbatim}

  Note that the \texttt{findViewById} references the \texttt{android:id}
  value set in the Screenlet's XML.
\end{enumerate}

Next, you'll use the same \texttt{WebScreenlet} reference to set the
Screenlet's parameters.

\subsection{Setting Web Screenlet's
Parameters}\label{setting-web-screenlets-parameters}

Web Screenlet has \texttt{WebScreenletConfiguration} and
\texttt{WebScreenletConfiguration.Builder} objects that supply the
parameters the Screenlet needs to work. These parameters include the URL
of the page to load and the location of any JavaScript or CSS files that
customize the page. You'll set most of these parameters via
\texttt{WebScreenletConfiguration.Builder}'s methods.

\noindent\hrulefill

\textbf{Note:} For a full list of
\texttt{WebScreenletConfiguration.Builder}'s methods, and a description
of each, see the table in
\href{/docs/7-1/reference/-/knowledge_base/r/web-screenlet-for-android\#configuration}{the
Configuration section} of Web Screenlet's reference doc.

\noindent\hrulefill

To set Web Screenlet's parameters, follow these steps in the method that
initializes the activity or fragment containing the Screenlet (e.g.,
\texttt{onCreate} in activities, \texttt{onCreateView} in fragments).
You can, however, do this in other methods as needed.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Use
  \texttt{WebScreenletConfiguration.Builder(\textless{}url\textgreater{})},
  where \texttt{\textless{}url\textgreater{}} is the web page's URL
  string, to create a \texttt{WebScreenletConfiguration.Builder} object.
  If the page requires Liferay DXP authentication, then the user must be
  logged in via
  \href{/docs/7-1/reference/-/knowledge_base/r/loginscreenlet-for-android}{Login
  Screenlet} or a \texttt{SessionContext} method, and you must provide a
  relative URL to the \texttt{WebScreenletConfiguration.Builder}
  constructor. For example, if such a page's full URL is
  \texttt{http://your.liferay.instance/web/guest/blog}, then the
  constructor's argument is \texttt{/web/guest/blog}. For any other page
  that doesn't require Liferay DXP authentication, you must supply the
  full URL to the constructor.
\item
  Call the \texttt{WebScreenletConfiguration.Builder} methods to set the
  parameters that you need.
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** If the URL you supplied to the `WebScreenletConfiguration.Builder`
 constructor is to a page that doesn't require Liferay DXP authentication, then
 you must call the `WebScreenletConfiguration.Builder` method
 `setWebType(WebScreenletConfiguration.WebType.OTHER)`. The default `WebType`
 is `LIFERAY_AUTHENTICATED`, which is required to load Liferay DXP pages that
 require authentication. If you need to set `LIFERAY_AUTHENTICATED` manually,
 call `setWebType(WebScreenletConfiguration.WebType.LIFERAY_AUTHENTICATED)`.
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\item
  Call the \texttt{WebScreenletConfiguration.Builder} instance's
  \texttt{load()} method, which returns a
  \texttt{WebScreenletConfiguration} object.
\item
  Use Web Screenlet's \texttt{setWebScreenletConfiguration} method to
  set the \texttt{WebScreenletConfiguration} object to the Web Screenlet
  instance.
\item
  Call the Web Screenlet instance's \texttt{load()} method.
\end{enumerate}

Here's an example snippet of these steps in the \texttt{onCreate()}
method of an activity in which the Web Screenlet instance is
\texttt{screenlet}, and the \texttt{WebScreenletConfiguration} object is
\texttt{webScreenletConfiguration}:

\begin{verbatim}
WebScreenletConfiguration webScreenletConfiguration =
            new WebScreenletConfiguration.Builder("/web/westeros-hybrid/companynews")
                .addRawCss(R.raw.portlet, "portlet.css")
                .addLocalCss("gallery.css")
                .addLocalJs("gallery.js")
                .load();

        screenlet.setWebScreenletConfiguration(webScreenletConfiguration);
        screenlet.load();
\end{verbatim}

There are a few things to note about this example:

\begin{itemize}
\item
  The relative URL \texttt{/web/westeros-hybrid/companynews} supplied to
  the \texttt{WebScreenletConfiguration.Builder} constructor, and the
  lack of a \texttt{setWebType(WebScreenletConfiguration.WebType.OTHER)}
  call, indicates that this Web Screenlet instance loads a Liferay DXP
  page that requires authentication.
\item
  The \texttt{addRawCss} method adds the CSS file \texttt{portlet.css}
  from the app's \texttt{res/raw} folder. Any files that you add via the
  methods \texttt{addRawCss} or \texttt{addRawJs} must be located in
  \texttt{res/raw} (create this folder if it doesn't exist). Also note
  that you must reference these files with \texttt{R.raw.yourfilename}.
  For instance, the \texttt{portlet.css} file in this is example is
  referenced with \texttt{R.raw.portlet}.
\item
  The \texttt{addLocalCss} and \texttt{addLocalJs} methods add the local
  files \texttt{gallery.css} and \texttt{gallery.js}, respectively. Any
  files that you add via these methods must be in the first level of
  your app's \texttt{assets} folder. This folder must exist at the same
  level as your app's \texttt{res} folder. Create the \texttt{assets}
  folder in that location if it doesn't exist.
\end{itemize}

Great! Now you know how to use Web Screenlet in your Android apps.

\subsection{Related Topics}\label{related-topics-244}

\href{/docs/7-1/reference/-/knowledge_base/r/web-screenlet-for-android}{Web
Screenlet for Android}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-web-screenlet-with-cordova-in-your-android-app}{Using
Web Screenlet with Cordova in Your Android App}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-screenlets-in-android-apps}{Using
Screenlets in Android Apps}

\href{/docs/7-1/tutorials/-/knowledge_base/t/rendering-web-content-in-your-android-app}{Rendering
Web Content in Your Android App}

\section{Using Web Screenlet with Cordova in Your Android
App}\label{using-web-screenlet-with-cordova-in-your-android-app}

By using \href{https://cordova.apache.org/plugins/}{Cordova plugins} in
\href{/docs/7-1/tutorials/-/knowledge_base/t/rendering-web-pages-in-your-android-app}{Web
Screenlet}, you can extend the functionality of the web page that the
Screenlet renders. This lets you tailor that page to your app's needs.

You'll get started by installing and configuring Cordova. There are two
ways to do this: automatically, or manually. The automatic method is
covered first.

\subsection{Installing and Configuring Cordova
Automatically}\label{installing-and-configuring-cordova-automatically}

Follow these steps to automatically create an empty Android project
configured to use Cordova. Note that you must have
\href{https://git-scm.com/}{git}, \href{https://nodejs.org/en/}{Node.js,
and npm} installed.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Install \texttt{screens-cli}:

\begin{verbatim}
npm install -g screens-cli
\end{verbatim}
\item
  Create the file \texttt{.plugins.screens} in the folder you want to
  create your project in. In this file, add all the Cordova plugins you
  want to use in your app. For example, you can add plugins from Cordova
  or GitHub:

\begin{verbatim}
https://github.com/apache/cordova-plugin-wkwebview-engine.git
cordova-plugin-call-number
cordova-plugin-camera
\end{verbatim}
\item
  In the folder containing your \texttt{.plugins.screens} file, run
  \texttt{screens-cli} to create your project:

\begin{verbatim}
screens-cli android <project-name>
\end{verbatim}

  This creates your project in the folder
  \texttt{platforms/android/\textless{}project-name\textgreater{}}. You
  can open it with Android Studio.
\end{enumerate}

\subsection{Installing and Configuring Cordova
Manually}\label{installing-and-configuring-cordova-manually}

To install and configure Cordova manually, follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Follow \href{https://cordova.apache.org/\#getstarted}{the Cordova
  getting started guide} to install Cordova, create a Cordova project,
  and add the Android platform to your Cordova project.
\item
  Install any Cordova plugins you want to use in your app. For example,
  this command adds
  \href{https://www.npmjs.com/package/cordova-plugin-call-number}{the
  Cordova plugin \texttt{cordova-plugin-call-number}}:

\begin{verbatim}
cordova plugin add cordova-plugin-call-number
\end{verbatim}

  You can use \texttt{cordova\ plugin} to view the currently installed
  plugins.
\item
  Copy the following files and folders from your Cordova project to your
  Android project's root folder:

  \begin{itemize}
  \tightlist
  \item
    \texttt{/platforms/android/res/xml/config.xml}
  \item
    \texttt{/platforms/android/assets/www}
  \end{itemize}

  You should also review other files like \texttt{AndroidManifest.xml},
  resource files, and so on. Some plugins add permissions or styles in
  such files that you may need to copy for those plugins to work
  correctly in your Android app.
\end{enumerate}

\subsection{Using Cordova in Web
Screenlet}\label{using-cordova-in-web-screenlet}

Now that you've installed and configured Cordova in your Android
project, you're ready to use it with Web Screenlet. Follow these steps
to do so:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/rendering-web-pages-in-your-android-app}{Insert
  and configure Web Screenlet in your app}.
\item
  When you set Web Screenlet's parameters via the
  \texttt{WebScreenletConfiguration.Builder} object, you must enable
  Cordova by calling the \texttt{enableCordova} method with a
  \texttt{CordovaLifeCycleObserver} argument.
  \texttt{CordovaLifeCycleObserver} informs Cordova about the activity
  lifecycle. You can create an instance of this observer by using its
  no-argument constructor.

  For example, this code creates a \texttt{CordovaLifeCycleObserver}
  object that it then uses with \texttt{enableCordova} when setting Web
  Screenlet's parameters:

\begin{verbatim}
CordovaLifeCycleObserver observer = new CordovaLifeCycleObserver();

WebScreenletConfiguration configuration =
        new WebScreenletConfiguration
                .Builder("/")
                .addLocalJs("call.js")
                .enableCordova(observer)
                .load();

webScreenlet.setWebScreenletConfiguration(configuration);
webScreenlet.load();
\end{verbatim}
\item
  Override the following \texttt{Activity} methods to call their
  corresponding observer methods:

\begin{verbatim}
@Override
protected void onStart() {
    super.onStart();
    observer.onStart();
}

@Override
protected void onStop() {
    super.onStop();

    observer.onStop();
}

@Override
public void onPause() {
    super.onPause();

    observer.onPause();
}

@Override
public void onResume() {
    super.onResume();

    observer.onResume();
}

@Override
public void onDestroy() {
    super.onDestroy();

    observer.onDestroy();
}

@Override
public void onSaveInstanceState(Bundle outState) {
    super.onSaveInstanceState(outState);

    observer.onSaveInstanceState(outState);
}

@Override
protected void onActivityResult(int requestCode, int resultCode, Intent data) {
    super.onActivityResult(requestCode, resultCode, data);

    observer.onActivityResult(requestCode, resultCode, data);
}

@Override
public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, 
    @NonNull int[] grantResults) {
        super.onRequestPermissionsResult(requestCode, permissions, grantResults);

        observer.onRequestPermissionsResult(requestCode, permissions, grantResults);
}

@Override
public void onConfigurationChanged(Configuration newConfig) {
    super.onConfigurationChanged(newConfig);

    observer.onConfigurationChanged(newConfig);
}
\end{verbatim}
\end{enumerate}

That's it! Note, however, that you may also need to invoke Cordova from
a JavaScript file, depending on what you're doing. For example, to use
\href{https://www.npmjs.com/package/cordova-plugin-call-number}{the
Cordova plugin \texttt{cordova-plugin-call-number}} to call a number,
you must add a JavaScript file with the following code:

\begin{verbatim}
function callNumber() {
    //This line triggers the Cordova plugin and makes a call
    window.plugins.CallNumber.callNumber(null, function(){ alert("Calling failed.") }, "900000000", true);
}

setTimeout(callNumber, 3000);
\end{verbatim}

If you run the app containing this code and wait three seconds, the
plugin activates and calls the number in the JavaScript file.

Great! Now you know how to use Web Screenlet with Cordova.

\subsection{Related Topics}\label{related-topics-245}

\href{/docs/7-1/tutorials/-/knowledge_base/t/rendering-web-pages-in-your-android-app}{Rendering
Web Pages in Your Android App}

\href{/docs/7-1/reference/-/knowledge_base/r/web-screenlet-for-android}{Web
Screenlet for Android}

\section{Using OAuth 2 in Liferay Screens for
Android}\label{using-oauth-2-in-liferay-screens-for-android}

You can use \href{https://oauth.net/2/}{OAuth 2} to authenticate using
\href{/docs/7-1/reference/-/knowledge_base/r/loginscreenlet-for-android}{Login
Screenlet} with the following
\href{https://oauth.net/2/grant-types/}{OAuth 2 grant types}:

\begin{itemize}
\item
  \href{https://oauth.net/2/grant-types/authorization-code/}{\textbf{Authorization
  Code (PKCE for native apps):}} Redirects users to a page in their
  mobile browser where they enter their credentials. Following login,
  the browser redirects users back to the mobile app. User credentials
  can't be compromised via the app because it never accesses them---it
  uses a revocable token. This is also useful if users don't want to
  enter their credentials in the app. For example, users may not want to
  enter their Twitter credentials directly in a 3rd-party Twitter app,
  preferring instead to authenticate via Twitter's official site. Note
  that the site you redirect to for authentication must have OAuth 2
  implemented.
\item
  \href{https://oauth.net/2/grant-types/password/}{\textbf{Resource
  Owner Password:}} Users authenticate by entering their credentials
  directly in the app.
\item
  \href{https://oauth.net/2/grant-types/client-credentials/}{\textbf{Client
  Credentials:}} Authenticates without requiring user interaction. This
  is useful when the app needs to access its own resources, not those of
  a specific user.
\end{itemize}

This tutorial shows you how to use these grant types with Login
Screenlet. Note that before getting started, you may want to see
\href{/docs/7-1/deploy/-/knowledge_base/d/oauth-2-0}{Liferay DXP's OAuth
2.0 documentation} for instructions on registering an OAuth 2.0
application in the portal.

\subsection{Authorization Code (PKCE)}\label{authorization-code-pkce}

Follow these steps to use the Authorization Code grant type with Login
Screenlet:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Configure the URL where the mobile browser redirects after the user
  authenticates. To do this, follow the first two steps in the
  \href{/docs/7-1/tutorials/-/knowledge_base/t/using-oauth-2-in-the-android-mobile-sdk\#authorization-code-pkce}{Mobile
  SDK's Authorization Code instructions}. Note that you must configure
  this URL in both the portal and your Android app.
\item
  Set Login Screenlet's \texttt{loginMode} attribute to
  \texttt{oauth2Redirect}. There are two ways to do this:

  \begin{itemize}
  \item
    In code, as the Login Screenlet instance's
    \texttt{authenticationType} variable. You must set this variable via
    Login Screenlet's \texttt{setAuthenticationType} method, using the
    \texttt{AuthenticationType} enum constant \texttt{OAUTH2REDIRECT}:

\begin{verbatim}
loginScreenlet.setAuthenticationType(AuthenticationType.OAUTH2REDIRECT); 
\end{verbatim}
  \item
    When inserting Login Screenlet's XML, set the \texttt{loginMode}
    attribute to \texttt{oauth2Redirect}.
  \end{itemize}
\item
  In Login Screenlet's XML, set Login Screenlet's
  \texttt{oauth2ClientId} attribute to the ID of the portal's OAuth 2
  application that you want to use. To find this value, navigate to that
  application in the portal's OAuth 2 Admin portlet.
\item
  In Login Screenlet's XML, set Login Screenlet's
  \texttt{oauth2Redirect} attribute to the URL you configured in step 1.

  Here's an example of Login Screenlet's XML with the attributes from
  the preceding steps:

\begin{verbatim}
<com.liferay.mobile.screens.auth.login.LoginScreenlet
    android:id="@+id/login_screenlet"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    app:loginMode="oauth2Redirect"
    app:oauth2Redirect="my-app://my-app"
    app:oauth2ClientId="54321"
    app:credentialsStorage="shared_preferences"
/>
\end{verbatim}
\item
  In your activity that uses Login Screenlet, you must override the
  \texttt{onActivityResult} method to implement the redirect you
  configured in the first step. You do this by calling Login Screenlet's
  \texttt{resumeOAuth2RedirectFlow} method:

\begin{verbatim}
@Override
protected void onActivityResult(int requestCode, int resultCode, Intent intent) {
    super.onActivityResult(requestCode, resultCode, intent);

    if (requestCode == OAuth2SignIn.REDIRECT_REQUEST_CODE) {
        loginScreenlet.resumeOAuth2RedirectFlow(intent);
    }
}
\end{verbatim}
\end{enumerate}

\subsection{Resource Owner Password}\label{resource-owner-password}

Follow these steps to use the Resource Owner Password grant type with
Login Screenlet:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Set Login Screenlet's \texttt{loginMode} attribute to
  \texttt{oauth2UsernameAndPassword}. There are two ways to do this:

  \begin{itemize}
  \item
    In code, as the Login Screenlet instance's
    \texttt{authenticationType} variable. You must set this variable via
    Login Screenlet's \texttt{setAuthenticationType} method, using the
    \texttt{AuthenticationType} enum constant
    \texttt{OAUTH2USERNAMEANDPASSWORD}:

\begin{verbatim}
loginScreenlet.setAuthenticationType(AuthenticationType.OAUTH2USERNAMEANDPASSWORD);
\end{verbatim}
  \item
    When inserting Login Screenlet's XML, set the \texttt{loginMode}
    attribute to \texttt{oauth2UsernameAndPassword}.
  \end{itemize}
\item
  In Login Screenlet's XML, set Login Screenlet's
  \texttt{oauth2ClientId} attribute to the ID of the OAuth 2 application
  that you want to use. To find this value, navigate to that application
  in the OAuth 2 Admin portlet.
\item
  In Login Screenlet's XML, set Login Screenlet's
  \texttt{oauth2ClientSecret} attribute to the same OAuth 2
  application's client secret.

  Here's an example of Login Screenlet's XML with the attributes from
  the preceding steps:

\begin{verbatim}
<com.liferay.mobile.screens.auth.login.LoginScreenlet
    android:id="@+id/login_screenlet"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    app:loginMode="oauth2UsernameAndPassword"
    app:oauth2ClientId="54321"
    app:oauth2ClientSecret="12345"
    app:basicAuthMethod="email"
    app:credentialsStorage="shared_preferences"
/>
\end{verbatim}
\end{enumerate}

\subsection{Client Credentials}\label{client-credentials}

The OAuth 2 Client Credentials grant type authenticates without
requiring user interaction. This is useful when the app needs to access
its own resources, not those of a specific user.

\noindent\hrulefill

\textbf{Warning:} The Client Credentials grant type poses a security
risk to the portal. To authenticate without user credentials, the mobile
app must contain the OAuth 2 application's client ID and client secret.
Anyone who can access those values via the mobile app can also
authenticate without user credentials.

\noindent\hrulefill

Follow these steps to use the Client Credentials grant type in your
Android app:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Follow the
  \href{/docs/7-1/tutorials/-/knowledge_base/t/using-oauth-2-in-the-android-mobile-sdk\#client-credentials}{Android
  Mobile SDK instructions} for using the Client Credentials grant type.
\item
  The session object contains a valid authentication object. Pass the
  session as an argument to the \texttt{SessionContext} method
  \texttt{createOAuth2Session}:

\begin{verbatim}
SessionContext.createOAuth2Session(session);
\end{verbatim}

  This initializes the Screens \texttt{SessionContext} object,
  authenticating any Screenlets that you use in the Android app.
\end{enumerate}

\subsection{Related Topics}\label{related-topics-246}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-oauth-2-in-the-android-mobile-sdk}{Using
OAuth 2 in the Android Mobile SDK}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-screenlets-in-android-apps}{Using
Screenlets in Android Apps}

\href{/docs/7-1/deploy/-/knowledge_base/d/oauth-2-0}{OAuth 2.0}

\section{Android Best Practices}\label{android-best-practices}

When developing Android projects with Liferay Screens, there are a few
best practices that you should follow to ensure your code is as clean
and bug-free as possible. This tutorial lists these.

\subsection{Update Your Tools}\label{update-your-tools}

You should first make sure that you have the latest tools installed. You
should use the latest Android API level with the latest version of
Android Studio. Although Screens \emph{may} work with Eclipse ADT or
manual Gradle builds, Android Studio is the preferred IDE.

\subsection{Naming Conventions}\label{naming-conventions}

Using the naming conventions described here leads to consistency and a
better understanding of the Screens library. This makes working with
your Screenlets much simpler.

Also note that Liferay Screens follows
\href{https://github.com/square/java-code-styles}{Square's Java
conventions} for Android, with tabs as separator. The configuration for
IDEA, findbugs, PMD, and checkstyle is available in the project's source
code.

\subsubsection{Screenlet Folder}\label{screenlet-folder}

Your Screenlet folder's name should indicate your Screenlet's
functionality. For example,
\href{https://github.com/liferay/liferay-screens/tree/master/android/library/src/main/java/com/liferay/mobile/screens/auth/login}{Login
Screenlet's folder is named \texttt{login}}.

If you have multiple Screenlets that operate on the same entity, you can
place them inside a folder named for that entity. For example,
\href{/docs/7-1/reference/-/knowledge_base/r/asset-display-screenlet-for-android}{Asset
Display Screenlet} and
\href{/docs/7-1/reference/-/knowledge_base/r/assetlistscreenlet-for-android}{Asset
List Screenlet} both work with Liferay assets. They're therefore in the
Screens library's
\href{https://github.com/liferay/liferay-screens/tree/master/android/library/src/main/java/com/liferay/mobile/screens/asset}{\texttt{asset}
folder}.

\subsubsection{Screenlets}\label{screenlets}

Naming Screenlets properly is very important; they're the main focus of
Liferay Screens. You should name your Screenlet with its principal
action first, followed by \emph{Screenlet}. Its Screenlet class should
also follow this pattern. For example,
\href{/docs/7-1/reference/-/knowledge_base/r/loginscreenlet-for-android}{Login
Screenlet's} principal action is to log users into a Liferay DXP
installation. This Screenlet's Screenlet class is therefore
\texttt{LoginScreenlet}.

\subsubsection{View Models}\label{view-models}

Name your View models the same way you name Screenlets, but substitute
\texttt{ViewModel} for \texttt{Screenlet}. Also, place your View Models
in a \texttt{view} folder in your Screenlet's root folder. For example,
Login Screenlet's View Model is named \texttt{LoginViewModel} and is in
the
\href{https://github.com/liferay/liferay-screens/tree/master/android/library/src/main/java/com/liferay/mobile/screens/auth/login/view}{\texttt{login/view}
folder}.

\subsubsection{Interactors}\label{interactors}

Place your Screenlet's Interactors in a folder named \texttt{interactor}
in your Screenlet's root folder. Name each Interactor first with the
object it operates on, followed by its action and the suffix
\emph{Interactor}. If you wish, you can also put each Interactor in its
own folder named after its action. For example,
\href{/docs/7-1/reference/-/knowledge_base/r/rating-screenlet-for-android}{Rating
Screenlet} has three Interactors. Each is in its own folder inside
\href{https://github.com/liferay/liferay-screens/tree/master/android/library/src/main/java/com/liferay/mobile/screens/rating/interactor}{the
\texttt{interactor} folder}:

\begin{itemize}
\tightlist
\item
  \texttt{delete/RatingDeleteInteractor}: Deletes an asset's ratings
\item
  \texttt{load/RatingLoadInteractor}: Loads an asset's ratings
\item
  \texttt{update/RatingUpdateInteractor}: Updates an asset's ratings
\end{itemize}

\subsubsection{Views}\label{views-1}

Place Views in a \texttt{view} folder in the Screenlet's root folder. If
you're creating a View Set, however, you can place its Views in a
separate \texttt{viewsets} folder outside your Screenlets' root folders.
This is what the Screens Library does for
\href{https://github.com/liferay/liferay-screens/tree/master/android/viewsets}{its
Material and Westeros View Sets}. The \texttt{material} and
\texttt{westeros} folders contain those View Sets, respectively. Also
note that in each View, each Screenlet's View class is in its own
folder. For example, the View class for
\href{/docs/7-1/reference/-/knowledge_base/r/forgotpasswordscreenlet-for-android}{Forgot
Password Screenlet's} Material View is in
\href{https://github.com/liferay/liferay-screens/tree/master/android/viewsets/material/src/main/java/com/liferay/mobile/screens/viewsets/material/auth/forgotpassword}{the
folder
\texttt{viewsets/material/src/main/java/com/liferay/mobile/screens/viewsets/material/auth/forgotpassword}}.
Note that the \texttt{auth} folder in this path is the Screenlet's
module. Creating your Screenlets and Views in modules isn't required.
Also note that the
\href{https://github.com/liferay/liferay-screens/blob/master/android/viewsets/material/src/main/res/layout/forgotpassword_material.xml}{View's
layout file \texttt{forgotpassword\_material.xml}} is in
\texttt{viewsets/material/src/main/res/layout}.

Name a View's layout XML and View class after your Screenlet,
substituting \emph{View} for \emph{Screenlet} where necessary. The
layout's filename should also be suffixed with \texttt{\_yourViewName}.
For example, the XIB file and View class for Forgot Password Screenlet's
Material View are \texttt{forgotpassword\_material.xml} and
\texttt{ForgotPasswordView.java}, respectively.

\subsection{Avoid Hard Coded Elements}\label{avoid-hard-coded-elements}

Using constants instead of hard-coded elements is a simple way to avoid
bugs. Constants reduce the likelihood that you'll make a typo when
referring to common elements. They also gather these elements in a
single location. For example,
\href{https://github.com/liferay/liferay-screens/blob/master/android/library/src/main/java/com/liferay/mobile/screens/ddl/form/DDLFormScreenlet.java}{DDL
Form Screenlet's Screenlet class} defines the following constants for
the user action names:

\begin{verbatim}
public static final String LOAD_FORM_ACTION = "loadForm";
public static final String LOAD_RECORD_ACTION = "loadRecord";
public static final String ADD_RECORD_ACTION = "addRecord";
public static final String UPDATE_RECORD_ACTION = "updateRecord";
public static final String UPLOAD_DOCUMENT_ACTION = "uploadDocument";
\end{verbatim}

\subsection{Avoid State in
Interactors}\label{avoid-state-in-interactors}

Liferay Screens uses \href{http://greenrobot.org/eventbus/}{EventBus} to
ensure that the network or background operation isn't lost when the
device changes orientation. For this to work, however, you must ensure
that your Interactor's request is stateless.

If an Interactor needs some piece of information, you should pass it to
the Interactor via the \texttt{start} call and then attach it to the
event. You can see an example of this in the sample Add Bookmark
Screenlet from
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-android-screenlets}{the
Screenlet creation tutorial}. The \texttt{onUserAction} method in the
Screenlet class (\texttt{AddBookmarkScreenlet}) passes a Bookmark's URL
and title from the View Model to the Interactor via the Interactor's
\texttt{start} method:

\begin{verbatim}
@Override
protected void onUserAction(String userActionName, AddBookmarkInteractor interactor, 
    Object... args) {
        AddBookmarkViewModel viewModel = getViewModel();
        String url = viewModel.getURL();
        String title = viewModel.getTitle();

        interactor.start(url, title, folderId);
}
\end{verbatim}

The \texttt{start} method calls the Interactor's \texttt{execute} method
in a background thread. The \texttt{execute} method in Add Bookmark
Screenlet's Interactor (\texttt{AddBookmarkInteractor}) creates a
\texttt{BasicEvent} object that contains the \texttt{start} method's
arguments:

\begin{verbatim}
@Override
public BasicEvent execute(Object[] args) throws Exception {
    String url = (String) args[0];
    String title = (String) args[1];
    long folderId = (long) args[2];

    validate(url, folderId);

    JSONObject jsonObject = getJSONObject(url, title, folderId);
    return new BasicEvent(jsonObject);
}
\end{verbatim}

\subsection{Stay in Your Layer}\label{stay-in-your-layer}

When accessing variables that belong to other Screenlet components, you
should avoid those outside your current Screenlet layer. This achieves
better decoupling between the layers, which tends to reduce bugs and
simplify maintenance. For an explanation of the layers in Liferay
Screens, see
\href{/docs/7-1/tutorials/-/knowledge_base/t/architecture-of-liferay-screens-for-android}{the
architecture tutorial}. For example, don't directly access View
variables from an Interactor. Instead, pass data from a View Model to
the Interactor via the Interactor's \texttt{start} method. The example
\texttt{onUserAction} method in the previous section illustrates this.

\subsection{Related Topics}\label{related-topics-247}

\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-screens-for-android-troubleshooting-and-faqs}{Liferay
Screens for Android Troubleshooting and FAQs}

\href{/docs/7-1/tutorials/-/knowledge_base/t/architecture-of-liferay-screens-for-android}{Architecture
of Liferay Screens for Android}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-android-screenlets}{Creating
Android Screenlets}

\section{Liferay Screens for Android Troubleshooting and
FAQs}\label{liferay-screens-for-android-troubleshooting-and-faqs}

Even though Liferay developed Screens for Android with great care, you
may still run into some common issues. Here are solutions and tips for
solving these issues. You'll also find answers to common questions about
Screens for Android.

\subsection{General Troubleshooting}\label{general-troubleshooting}

Before delving into specific issues, you should first make sure that you
have the latest tools installed and know where to get additional help if
you need it. You should use the latest Android API level, with the
latest version of Android Studio. Although Screens \emph{can} work with
Eclipse ADT or manual Gradle builds, Android Studio is the preferred
IDE.

If you're having trouble using Liferay Screens, it may help to
investigate the sample apps developed by Liferay. Both serve as good
examples of how to use Screenlets and Views:

\begin{itemize}
\tightlist
\item
  \href{https://github.com/liferay/liferay-screens/tree/master/android/samples/bankofwesteros}{Westeros
  Bank}
\item
  \href{https://github.com/liferay/liferay-screens/tree/master/android/samples/test-app}{Test
  App}
\end{itemize}

If you get stuck at any point, you can post your question on our
\href{https://www.liferay.com/community/forums/-/message_boards/category/42706063}{forum}.
We're happy to assist you! If you found a bug or want to suggest an
improvement, file a ticket in our
\href{https://issues.liferay.com/browse/LMW/}{Jira}. Note that you must
\href{https://issues.liferay.com/login.jsp?os_destination=\%2Fbrowse\%2F}{log
in} first to be able to see the project.

\subsection{Common Issues}\label{common-issues}

This section contains information on common issues that can occur when
using Liferay Screens.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Could not find \texttt{com.liferay.mobile:liferay-screens}

  This error occurs when Gradle isn't able to find Liferay Screens or
  the repository. First, check that the Screens version number you're
  trying to use exists in jCenter. You can use this
  \href{https://bintray.com/liferay/liferay-mobile/liferay-screens/view}{link}
  to see all uploaded versions.

  It's also possible that you're using an old Gradle plugin that doesn't
  use jCenter as the default repository. Screens uses version 1.2.3 and
  later. You can add jCenter as a new repository by placing this code in
  your project's \texttt{build.gradle} file:

\begin{verbatim}
repositories {
    jcenter()
}
\end{verbatim}
\item
  Failed to resolve: \texttt{com.android.support:appcompat-v7}

  Liferay Screens uses the appcompat library from Google, as do all new
  Android projects created with the latest Android Studio. The appcompat
  library uses a custom repository maintained by Google, so it must be
  updated manually using the Android SDK Manager.

  In the Android SDK Manager (located at \emph{Tools} → \emph{Android} →
  \emph{SDK Manager} in Android Studio), you must install at least
  version 14 of the Android Support Repository (in the \emph{Extras}
  menu), and version 22.1.1 of the Android Support Library.
\item
  Duplicate files copied in \texttt{APK\ META-INF}\ldots{}

  This is a common Android error when using libraries. It occurs because
  Gradle can't merge duplicated files such as license or notice files.
  To prevent this error, add the following code to your
  \texttt{build.gradle} file:

\begin{verbatim}
android {
    ...
    packagingOptions {
        exclude 'META-INF/LICENSE'
        exclude 'META-INF/NOTICE'
    }
    ...
}
\end{verbatim}

  This error may not happen right away, but may only appear later on in
  the development process. For this reason, it's recommended that you
  put the above code in your \texttt{build.gradle} file after creating
  your project.
\item
  Connect failed: ECONNREFUSED (Connection refused), or
  \texttt{org.apache.http.conn.HttpHostConnectException}

  This error occurs when Liferay Screens and the underlying Liferay
  Mobile SDK can't connect to the Liferay Portal instance. If you get
  this error, you should first check the IP address of the server to
  make sure it's available. If you've
  \href{/docs/7-1/tutorials/-/knowledge_base/t/preparing-android-projects-for-liferay-screens\#configuring-communication-with-liferay}{overridden
  the default IP address in \texttt{server\_context.xml}}, you should
  check to make sure that you've set it to the correct IP. Also, if
  you're using the Genymotion emulator, you must use
  \texttt{192.168.56.1} instead of localhost for your app to communicate
  with a local Liferay instance.
\item
  \texttt{java.io.IOException}: open failed: EACCES (Permission denied)

  Some Screenlets use temporary files to store information, such as when
  the User Portrait Screenlet uploads a new portrait, or the DDL Form
  Screenlet uploads new files to the portal. Your app needs to have the
  necessary permissions to use a specific Screenlet's functionality. In
  this case, add the following line to your
  \texttt{AndroidManifest.xml}:

\begin{verbatim}
<uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
\end{verbatim}

  If you're using the device's camera, you also need to add the
  following permission:

\begin{verbatim}
<uses-permission android:name="android.permission.CAMERA"/>
\end{verbatim}
\item
  No JSON web service action with path \ldots{}

  This error most commonly occurs if you haven't installed the
  \href{https://github.com/liferay/liferay-screens/tree/master/portal}{Liferay
  Screens Compatibility Plugin}. This plugin adds new API calls to
  Liferay Portal.
\end{enumerate}

\subsection{FAQs}\label{faqs}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Do I have to use Android Studio?

  No, Liferay Screens also works with Eclipse ADT. You can also compile
  your project manually with Gradle or another build system. Just make
  sure you use the compiled \texttt{aar} in your project's \texttt{lib}
  folder.

  We \emph{strongly} recommend, however, that you use Android Studio.
  Android Studio is the official IDE for developing Android apps, and
  Eclipse ADT is no longer supported. Using Eclipse ADT or compiling
  manually may cause unexpected issues that are difficult to overcome.
\item
  How does Screens handle orientation changes?

  Liferay Screens uses an event bus,
  \href{http://greenrobot.github.io/EventBus/}{the \texttt{EventBus}
  library}, to notify activities when the interactor has finished its
  work.
\item
  How can I use a Liferay feature not available in Screens?

  There are several ways you can use Liferay features not currently
  available in Screens. The
  \href{https://github.com/liferay/liferay-mobile-sdk}{Liferay Mobile
  SDK} gives you access to all of Liferay's remote APIs. You can also
  create a custom Screenlet to support any features not included in
  Screens by default.
\item
  How do I create a new Screenlet?

  Screenlet creation is explained in detail
  \href{/docs/7-1/tutorials/-/knowledge_base/t/creating-android-screenlets}{here}.
\item
  How can I customize a Screenlet?

  You can customize Screenlets by creating new Views. Fortunately, there
  are
  \href{/docs/7-1/tutorials/-/knowledge_base/t/creating-android-views}{tutorials}
  for this!
\item
  Does Screens have offline support?

  Yes, since Liferay Screens 1.3!
\end{enumerate}

\subsection{Related Topics}\label{related-topics-248}

\href{/docs/7-1/tutorials/-/knowledge_base/t/preparing-android-projects-for-liferay-screens}{Preparing
Android Projects for Liferay Screens}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-android-screenlets}{Creating
Android Screenlets}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-android-views}{Creating
Android Views}

\href{/docs/7-1/tutorials/-/knowledge_base/t/mobile-sdk}{Mobile SDK}

\chapter{iOS Apps with Liferay
Screens}\label{ios-apps-with-liferay-screens}

Liferay Screens speeds up and simplifies developing native mobile apps
that use Liferay. Its power lies in its \emph{Screenlets}. A Screenlet
is a visual component that you insert into your native app to leverage
Liferay DXP's content and
\href{/docs/7-1/tutorials/-/knowledge_base/t/web-services}{services}. On
iOS, Screenlets are available to log in to your portal, create accounts,
submit forms, display content, and more. You can use any number of
Screenlets in your app; they're independent, so you can use them in
modular fashion. Screenlets on iOS also deliver UI flexibility with
pluggable \emph{Themes} that implement elegant user interfaces. The
\href{/docs/7-1/reference/-/knowledge_base/r/screenlets-in-liferay-screens-for-ios}{reference
documentation} for iOS Screenlets describes each Screenlet's features
and Themes.

You might be thinking, ``These Screenlets sound like the greatest thing
since taco Tuesdays, but what if they don't fit in with my app's UI?
What if they don't behave exactly how I want them to? What if there's no
Screenlet for what I want to do?'' Fret not! You can customize
Screenlets to fit your needs by changing or extending their UI and
behavior. You can even write your own Screenlets! What's more, Screens
seamlessly integrates with your existing iOS projects.

\begin{figure}
\centering
\includegraphics{./images/screens-ios-intro.png}
\caption{The Liferay Screens Sign Up Screenlet lets users create an
account in the portal.}
\end{figure}

Screenlets leverage the
\href{https://www.liferay.com/community/liferay-projects/liferay-mobile-sdk/overview}{Liferay
Mobile SDK} to make server calls. The Mobile SDK is a low-level layer on
top of the Liferay JSON API. To write your own Screenlets, you must
familiarize yourself with Liferay DXP's
\href{/docs/7-1/tutorials/-/knowledge_base/t/web-services}{web
services}. If no existing Screenlet meets your needs, consider
customizing an existing Screenlet, creating a Screenlet, or directly
using the Mobile SDK. Creating a Screenlet involves writing Mobile SDK
calls and constructing the Screenlet; if you don't plan to reuse or
distribute the implementation then you may want to forgo writing a
Screenlet and instead work with the
\href{/docs/7-1/tutorials/-/knowledge_base/t/mobile-sdk}{Mobile SDK}. A
benefit of integrating an existing Screenlet into your app, however, is
that the Mobile SDK's details are abstracted from you.

These tutorials show you how to use, customize, create, and distribute
iOS Screenlets and their Themes. There's even a tutorial that explains
the Liferay Screens architecture.

To get started,
\href{/docs/7-1/tutorials/-/knowledge_base/t/preparing-ios-projects-for-liferay-screens}{prepare
your iOS project} to use Liferay Screens.

\section{Preparing iOS Projects for Liferay
Screens}\label{preparing-ios-projects-for-liferay-screens}

To develop iOS apps with Liferay Screens, you must first install and
configure Screens in your iOS project. Screens is released as a standard
\href{https://cocoapods.org}{CocoaPods} dependency. You must therefore
install Screens via CocoaPods. After completing the installation, you
must configure your iOS project to communicate with your Liferay DXP
instance. This tutorial walks you through these processes. You'll be up
and running in no time!

First, you'll review the requirements for Liferay Screens.

\subsection{Requirements}\label{requirements-1}

Liferay Screens for iOS includes the Component Library (the Screenlets)
and some sample projects written in Swift. Screens is developed using
Swift and development techniques that leverage functional Swift code and
the
\href{http://en.wikipedia.org/wiki/Model\%E2\%80\%93view\%E2\%80\%93presenter}{Model
View Presenter} architecture. You can use Swift or Objective-C with
Screens, and you can run Screens apps on iOS 9 and above.

Liferay Screens for iOS requires the following software:

\begin{itemize}
\tightlist
\item
  Xcode 9.3 or newer
\item
  iOS 11 SDK
\item
  \href{http://cocoapods.org}{CocoaPods} 1 or newer
\item
  \href{http://www.liferay.com/downloads/liferay-portal/available-releases}{Liferay
  Portal 6.2 CE/EE, Liferay CE Portal 7.0/7.1, or Liferay DXP}
\item
  Liferay Screens Compatibility Plugin
  (\href{http://www.liferay.com/marketplace/-/mp/application/54365664}{CE}
  or
  \href{http://www.liferay.com/marketplace/-/mp/application/54369726}{DXP/EE},
  depending on your portal edition). This app is preinstalled in Liferay
  CE Portal 7.0/7.1 CE and Liferay DXP.
\end{itemize}

\subsection{Securing JSON Web
Services}\label{securing-json-web-services-1}

Each Screenlet in Liferay Screens calls one or more of Liferay DXP's
JSON web services, which are enabled by default. The Screenlet
\href{/docs/7-1/reference/-/knowledge_base/r/screenlets-in-liferay-screens-for-ios}{reference
documentation} lists the web services that each Screenlet calls. To use
a Screenlet, its web services must be enabled in the portal. It's
possible, however, to disable the web services needed by Screenlets
you're not using. For instructions on this, see the tutorial
\href{/docs/7-1/tutorials/-/knowledge_base/t/configuring-json-web-services}{Configuring
JSON Web Services}. You can also use
\href{/docs/7-1/tutorials/-/knowledge_base/t/service-access-policies}{Service
Access Policies} for more fine-grained control over accessible services.

\subsection{Configuring Your Project with
CocoaPods}\label{configuring-your-project-with-cocoapods}

To use CocoaPods to prepare your iOS 9.0 (or above) project for Liferay
Screens, follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In your project's root folder, add the following code to the file
  named \texttt{Podfile}, or create this file if it doesn't exist. Be
  sure to replace \texttt{Your\ Target} with your target's name:

\begin{verbatim}
source 'https://github.com/CocoaPods/Specs.git'

platform :ios, '9.0'
use_frameworks!

target "Your Target" do
    pod 'LiferayScreens'
end

# the rest of your podfile
\end{verbatim}

  Note that Liferay Screens and some of its dependencies aren't
  compatible with Swift 3.2 or Swift 4.0. If your iOS project is
  compiled in Swift 3.2 or Swift 4.0, then your \texttt{Podfile} must
  specify Screens and those dependencies for compilation in Swift 4.2.
  The \texttt{post\_install} code in the following \texttt{Podfile} does
  this. You must therefore use this \texttt{Podfile} if you want to use
  Screens in a Swift 3.2 or Swift 4.0 app:

\begin{verbatim}
source 'https://github.com/CocoaPods/Specs.git'

platform :ios, '9.0'
use_frameworks!

target "Your Target" do
    pod 'LiferayScreens'
end

post_install do |installer|
  incompatiblePods = [
    'Cosmos',
    'CryptoSwift',
    'KeychainAccess',
    'Liferay-iOS-SDK',
    'Liferay-OAuth',
    'LiferayScreens',
    'Kingfisher'
  ]

  installer.pods_project.targets.each do |target|
    if incompatiblePods.include? target.name
      target.build_configurations.each do |config|
        config.build_settings['SWIFT_VERSION'] = '4.2'
      end
    end
    target.build_configurations.each do |config|
        config.build_settings['CONFIGURATION_BUILD_DIR'] = '$PODS_CONFIGURATION_BUILD_DIR'
    end
  end
end

# the rest of your podfile 
\end{verbatim}
\item
  On the terminal, navigate to your project's root folder and run this
  command:

\begin{verbatim}
pod repo update
\end{verbatim}

  This ensures you have the latest version of the CocoaPods repository
  on your machine. Note that this command can take a while to run.
\item
  Still in your project's root folder in the terminal, run this command:

\begin{verbatim}
pod install
\end{verbatim}

  Once this completes, quit Xcode and reopen your project by using the
  \texttt{*.xcworkspace} file in your project's root folder. From now
  on, you must use this file to open your project.
\end{enumerate}

Great! To configure your project's communication with Liferay DXP, you
can skip the next section and follow the instructions in the final
section.

\subsection{Configuring Communication with Liferay
DXP}\label{configuring-communication-with-liferay-dxp-1}

Configuring communication between Screenlets and Liferay DXP is easy.
Liferay Screens uses a property list (\texttt{.plist}) file to access
your Liferay DXP instance. It must include the server's URL, the
portal's company ID, and the site's group ID. Create a
\texttt{liferay-server-context.plist} file and specify values required
for communicating with your Liferay DXP instance. As an example, refer
to
\href{https://github.com/liferay/liferay-screens/blob/master/ios/Framework/Core/Resources/liferay-server-context-sample.plist}{\texttt{liferay-server-context-sample.plist}}.

\begin{figure}
\centering
\includegraphics{./images/screens-ios-liferay-context.png}
\caption{Here's a property list file, called
\texttt{liferay-context.plist}.}
\end{figure}

The values you need to specify in your
\texttt{liferay-server-context.plist} are:

\begin{itemize}
\tightlist
\item
  \texttt{server}: Your Liferay DXP instance's URL.
\item
  \texttt{version}: Your Liferay DXP instance's version. Supported
  values are \texttt{71} for Liferay CE Portal 7.1 or Liferay DXP 7.1,
  \texttt{70} for Liferay CE Portal 7.0 or Liferay DXP 7.0, and
  \texttt{62} for Liferay Portal 6.2 CE/EE.
\item
  \texttt{companyId}: Your Liferay DXP instance's identifier. You can
  find this value in the \emph{Instance ID} column of \emph{Control
  Panel} → \emph{Portal Instances}.
\item
  \texttt{groupId}: The ID of the default site you want Screens to
  communicate with. You can find this value in the Site ID field of the
  site's \emph{Site Administration} → \emph{Configuration} → \emph{Site
  Settings} menu.
\item
  \texttt{connectorFactoryClassName}: Your Connector's factory class
  name. This is optional. If you don't include it, the \texttt{version}
  value is used to determine which factory is the most suitable for that
  version of Liferay DXP.
\end{itemize}

Great! Your iOS project is ready for Liferay Screens.

\subsection{Related Topics}\label{related-topics-249}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-screenlets-in-ios-apps}{Using
Screenlets in iOS Apps}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-themes-in-ios-screenlets}{Using
Themes in iOS Screenlets}

\href{/docs/7-1/tutorials/-/knowledge_base/t/preparing-android-projects-for-liferay-screens}{Preparing
Android Projects for Liferay Screens}

\section{Using Screenlets in iOS
Apps}\label{using-screenlets-in-ios-apps}

Once you've
\href{/docs/7-1/tutorials/-/knowledge_base/t/preparing-ios-projects-for-liferay-screens}{prepared}
your iOS project to use Liferay Screens, you can use Screenlets in your
app. There are plenty of Liferay Screenlets available, and they're
described in the Screenlet
\href{/docs/7-1/reference/-/knowledge_base/r/screenlets-in-liferay-screens-for-ios}{reference
documentation}. This tutorial shows you how to insert and configure
Screenlets in iOS apps written in Swift and Objective-C. It also
explains how to localize them. You'll be a Screenlet master in no time!

\subsection{Inserting and Configuring Screenlets in iOS
Apps}\label{inserting-and-configuring-screenlets-in-ios-apps}

The first step to using Screenlets in your iOS project is to add a new
UIView to your project. In Interface Builder, insert a new UIView into
your Storyboard or XIB file. Figure 1 shows this.

\begin{figure}
\centering
\includegraphics{./images/screens-ios-add-uiwindow.png}
\caption{Add a new UIView to your project.}
\end{figure}

Next, enter the Screenlet's name as the Custom Class. For example, if
you're using the Login Screenlet, then enter Login Screenlet as the
class.

\begin{figure}
\centering
\includegraphics{./images/screens-ios-custom-class.png}
\caption{Change the Custom Class to match the Screenlet.}
\end{figure}

Now you need to conform the Screenlet's delegate protocol in your
\texttt{ViewController} class. For example, the Login Screenlet's
delegate class is \texttt{LoginScreenletDelegate}. This is shown in the
code that follows. Note that you need to implement the functionality of
\texttt{onLoginResponse} and \texttt{onLoginError}. This is indicated by
the comments in the code here:

\begin{verbatim}
class ViewController: UIViewController, LoginScreenletDelegate {

    ...

   func screenlet(screenlet: BaseScreenlet,
           onLoginResponseUserAttributes attributes: [String:AnyObject]) {
       // handle succeeded login using passed user attributes
    }

    func screenlet(screenlet: BaseScreenlet,
            onLoginError error: NSError) {
        // handle failed login using passed error
    }

    ...
\end{verbatim}

If you're using CocoaPods, you need to import Liferay Screens in your
View Controller:

\begin{verbatim}
import LiferayScreens
\end{verbatim}

Now that the Screenlet's delegate protocol conforms in your
\texttt{ViewController} class, go back to Interface Builder and connect
the Screenlet's delegate to your View Controller. If the Screenlet
you're using has more outlets, you can assign them as well.

Note that currently Xcode has some
\href{http://stackoverflow.com/questions/26180268/interface-builder-iboutlet-and-protocols-for-delegate-and-datasource-in-swift/26180481\#26180481}{issues}
connecting outlets to Swift source code. To get around this, you can
change the delegate data type or assign the outlets in your code. In
your View Controller, follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Declare an outlet to hold a reference to the Screenlet. You can
  connect it in Interface Builder without any issues.

  \begin{figure}
  \centering
  \includegraphics{./images/screens-ios-xcode-add-screenlet-delegate.png}
  \caption{Connect the outlet with the Screenlet reference.}
  \end{figure}
\item
  Assign the Screenlet's delegate the \texttt{viewDidLoad} method. This
  is the connection typically done in Interface Builder.
\end{enumerate}

These steps are shown in the following code for Login Screenlet's View
Controller.

\begin{verbatim}
class ViewController: UIViewController, LoginScreenletDelegate {

    @IBOutlet var screenlet: LoginScreenlet?

    override func viewDidLoad() {
        super.viewDidLoad()
        self.screenlet?.delegate = self
    }

    ...
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/screens-ios-xcode-delegate.png}
\caption{Connect the Screenlet's delegate in Interface Builder.}
\end{figure}

Awesome! Now you know how to use Screenlets in your apps. If you need to
use Screenlets from Objective-C code, follow the instructions in the
next section.

\subsection{Using Screenlets from
Objective-C}\label{using-screenlets-from-objective-c}

If you want to invoke Screenlet classes from Objective-C code, there is
an additional header file that you must import. You can import the
header file \texttt{LiferayScreens-Swift.h} in all your Objective-C
files or configure a precompiler header file.

The first option involves adding the following import line all of your
Objective-C files:

\begin{verbatim}
#import "LiferayScreens-Swift.h"
\end{verbatim}

Alternatively, you can configure a precompiler header file by following
these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a precompiler header file (e.g., \texttt{PrefixHeader.pch}) and
  add it to your project.
\item
  Import \texttt{LiferayScreens-Swift.h} in the precompiler header file
  you just created.
\item
  Edit the following build settings of your target. Remember to replace
  \texttt{path/to/your/file/} with the path to your
  \texttt{PrefixHeader.pch} file:

  \begin{itemize}
  \tightlist
  \item
    Precompile Prefix Header: \texttt{Yes}
  \item
    Prefix Header: \texttt{path/to/your/file/PrefixHeader.pch}
  \end{itemize}

  \begin{figure}
  \centering
  \includegraphics{./images/screens-ios-xcode-prefix.png}
  \caption{The \texttt{PrefixHeader.pch} configuration in Xcode
  settings.}
  \end{figure}
\end{enumerate}

You can use the precompiler header file
\href{https://github.com/liferay/liferay-screens/blob/master/ios/Samples/Showcase-objc/LiferayScreens-Showcase-Objc/PrefixHeader.pch}{\texttt{PrefixHeader.pch}}
as a template.

Super! Now you know how to use Screenlets from Objective-C code in your
apps.

\subsection{Localizing Screenlets}\label{localizing-screenlets}

Follow Apple's
\href{https://developer.apple.com/library/ios/documentation/MacOSX/Conceptual/BPInternational/Introduction/Introduction.html}{standard
mechanism} to implement localization in your Screenlet. Note: even
though a Screenlet may support several languages, you must also support
those languages in your app. In other words, a Screenlet's support for a
language is only valid if your app supports that language. To support a
language, make sure to add it as a localization in your project's
settings.

\begin{figure}
\centering
\includegraphics{./images/screens-ios-xcode-localizations.png}
\caption{The Xcode localizations in the project's settings.}
\end{figure}

Way to go! You now know how to use Screenlets in your iOS apps.

\subsection{Related Topics}\label{related-topics-250}

\href{/docs/7-1/tutorials/-/knowledge_base/t/preparing-ios-projects-for-liferay-screens}{Preparing
iOS Projects for Liferay Screens}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-themes-in-ios-screenlets}{Using
Themes in iOS Screenlets}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-ios-screenlets}{Creating
iOS Screenlets}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-screenlets-in-android-apps}{Using
Screenlets in Android apps}

\section{Using Themes in iOS
Screenlets}\label{using-themes-in-ios-screenlets}

Using a Liferay Screens \emph{Theme}, you can set your Screenlet's UI
components, style, and behavior. They let you focus on a Screenlet's UI
and UX, without having to worry about its core functionality. Liferay's
Screenlets come with several Themes, and more are being developed by
Liferay and the community. A Liferay Screenlet's Themes are specified in
its
\href{/docs/7-1/reference/-/knowledge_base/r/screenlets-in-liferay-screens-for-ios}{reference
documentation}. This tutorial shows you how to use Themes in your iOS
Screenlets.

To install a Theme in your iOS app's Screenlet, you have two options,
depending on how the Theme has been published:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  If the Theme has been packaged as a CocoaPods pod dependency, you can
  install it by adding a line to your Podfile:

\begin{verbatim}
pod 'LiferayScreensThemeName'
\end{verbatim}

  Make sure to replace \texttt{LiferayScreensThemeName} with the Theme's
  CocoaPods project name.
\item
  If the Theme isn't available through CocoaPods, you can drag and drop
  the Theme's folder into your project. Liferay Screens detects the new
  classes and then applies the new design in the runtime and in
  Interface Builder.
\end{enumerate}

\begin{figure}
\centering
\includegraphics{./images/screens-ios-xcode-install-theme.png}
\caption{To install a Theme into an Xcode project, drag and drop the
Theme's folder into it.}
\end{figure}

To use the installed Theme, specify its name in the \emph{Theme Name}
property field of the \emph{Base Screenlet} in Interface Builder. The
names of each Screenlet's Themes are listed in the \emph{Themes} section
of the Screenlet's
\href{/docs/7-1/reference/-/knowledge_base/r/screenlets-in-liferay-screens-for-ios}{reference
documentation}. If you leave the Theme name property blank or enter a
name for a Theme that can't be found, the Screenlet's Default Theme is
used.

\begin{figure}
\centering
\includegraphics{./images/screens-ios-themes-property.png}
\caption{In Interface Builder, you specify a Screenlet's Theme by
entering its name in the \emph{Theme Name} field; this sets the
Screenlet's \texttt{themeName} property.}
\end{figure}

The initial release of Liferay Screens for iOS includes the following
Themes for its Screenlets:

\begin{itemize}
\tightlist
\item
  \emph{Default}: Comes standard with a Screenlet. It's used by a
  Screenlet if no Theme name is specified or the named Theme can't be
  found. The Default Theme can be used as the parent Theme for your
  custom Themes. Refer to the
  \href{/docs/7-1/tutorials/-/knowledge_base/t/architecture-of-liferay-screens-for-ios}{architecture
  tutorial} for more details.
\item
  \emph{Flat7}: Demonstrates a Theme made from scratch. Refer to the
  \href{/docs/7-1/tutorials/-/knowledge_base/t/creating-ios-themes}{Theme
  creation tutorial} for instructions on creating your own Theme.
\item
  \emph{Westeros}: Customizes the behavior and appearance of the
  \href{https://github.com/liferay/liferay-screens/tree/master/ios/Samples/WesterosBank}{Westeros
  Bank} demo app.
\end{itemize}

That's all there is to it! Great! Now you know how to use Themes to
dress up Screenlets in your iOS app. This opens up a world of
possibilities--like
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-ios-themes}{writing
your own Themes}.

\textbf{Related Topics}

\href{/docs/7-1/tutorials/-/knowledge_base/t/preparing-ios-projects-for-liferay-screens}{Preparing
iOS Projects for Liferay Screens}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-ios-themes}{Creating
iOS Themes}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-screenlets-in-ios-apps}{Using
Screenlets in iOS Apps}

\href{/docs/7-1/tutorials/-/knowledge_base/t/architecture-of-liferay-screens-for-ios}{Architecture
of Liferay Screens for iOS}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-views-in-android-screenlets}{Using
Views in Android Screenlets}

\section{Using Offline Mode in iOS}\label{using-offline-mode-in-ios}

Offline mode in Liferay Screens lets your apps function when
connectivity is unavailable or intermittent. Even though the steady
march of technology makes connections more stable and prevalent, there
are still plenty of places the Internet has trouble reaching. Areas with
complex terrain, including cities with large buildings, often lack
stable connections. Remote areas typically don't have connections at
all. Using Screens's offline mode in your apps gives your users
flexibility in these situations.

This tutorial shows you how to use offline mode in Screenlets. For an
explanation of how offline mode works, see the tutorial
\href{/docs/7-1/tutorials/-/knowledge_base/t/architecture-of-offline-mode-in-liferay-screens}{Architecture
of Offline Mode in Liferay Screens}. Offline mode's architecture is the
same on iOS and Android, although its use on these platforms differs.

\subsection{Configuring Screenlets for Offline
Mode}\label{configuring-screenlets-for-offline-mode-1}

If you want to enable the offline mode in any of your screenlets, you
must configure the attribute \texttt{offlinePolicy}. This attribute can
take four possible values. For a description of these values, see the
section
\href{/docs/7-1/tutorials/-/knowledge_base/t/architecture-of-offline-mode-in-liferay-screens\#using-policies-with-offline-mode}{Using
Policies with Offline Mode} in the offline mode architecture tutorial.
Note that each Screenlet behaves a bit differently with offline mode.
For specific details, see the
\href{/docs/7-1/reference/-/knowledge_base/r/screenlets-in-liferay-screens-for-ios}{Screenlet
reference documentation}.

\subsection{Handling Synchronization}\label{handling-synchronization-1}

Under some scenarios, values stored in the local cache need to be
synchronized with the portal. For that purpose you must use the
\texttt{SyncManager} class. This class is responsible for sending the
information stored in the local cache that hasn't been sent to the
portal yet.

Use the following steps to start a synchronization process:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create an instance of the \texttt{SyncManager} class. You must pass a
  \texttt{CacheManager} object in the constructor. You can get the
  current cache manager using
  \texttt{SessionContext.currentCacheManager}.
\item
  Set the delegate property. This delegate object receives the events
  produced in the synchronization process. For more details on the
  delegate's methods, see
  \href{/docs/7-1/reference/-/knowledge_base/r/syncmanagerdelegate}{the
  API reference documentation for the \texttt{SyncManagerDelegate}
  class}.
\item
  Make sure you keep a strong reference to the \texttt{SyncManager}
  object while the process is running.
\end{enumerate}

\subsection{Related Topics}\label{related-topics-251}

\href{/docs/7-1/tutorials/-/knowledge_base/t/architecture-of-offline-mode-in-liferay-screens}{Architecture
of Offline Mode in Liferay Screens}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-screenlets-in-ios-apps}{Using
Screenlets in iOS Apps}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-offline-mode-in-android}{Using
Offline Mode in Android}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-screenlets-in-android-apps}{Using
Screenlets in Android Apps}

\chapter{Architecture of Liferay Screens for
iOS}\label{architecture-of-liferay-screens-for-ios}

Liferay Screens separates its presentation and business-logic code using
ideas from
\href{http://en.wikipedia.org/wiki/Model-view-presenter}{Model View
Presenter},
\href{http://en.wikipedia.org/wiki/Model_View_ViewModel}{Model View
ViewModel}, and \href{http://www.objc.io/issue-13/viper.html}{VIPER}.
However, Screens isn't a canonical implementation of these architectures
because they're designed for apps. Screens isn't an app; it's a suite of
visual components intended for use \emph{in} apps.

The tutorials in this section explain the architecture of Liferay
Screens for iOS. First is an overview of the high level components that
make up the system. This includes the Core, Screenlets, and Themes.
These components are then described in detail in the tutorials that
follow. After you get done examining these building blocks, you'll be
ready to create some amazing Screenlets and Themes!

\section{High Level Architecture of Liferay Screens for
iOS}\label{high-level-architecture-of-liferay-screens-for-ios}

Liferay Screens for iOS is composed of a Core, a Screenlet layer, a View
layer, and Server Connectors. Server Connectors are technically part of
the Core, but are worth describing separately. They facilitate
interaction with local and remote data sources and communication between
the Screenlet layer and the
\href{/docs/7-1/tutorials/-/knowledge_base/t/mobile-sdk}{Liferay Mobile
SDK}.

\begin{figure}
\centering
\includegraphics{./images/screens-ios-architecture-01.png}
\caption{The high level components of Liferay Screens for iOS.}
\end{figure}

Each component is described here:

\begin{itemize}
\item
  \textbf{Core:} A micro-framework that lets developers write their own
  Screenlets, views, and Server Connector classes. The Core includes all
  the base classes for developing Screens components.
\item
  \textbf{Screenlets:} Swift classes to insert in any \texttt{UIView}.
  Screenlets render a selected Theme in the runtime and in Interface
  Builder. They also react to UI events to start server requests (via
  Server Connectors), and define a set of \texttt{@IBInspectable}
  properties that can be configured from Interface Builder. The
  Screenlets bundled with Liferay Screens are known as the
  \href{/docs/7-1/reference/-/knowledge_base/r/screenlets-in-liferay-screens-for-ios}{Screenlet
  library}.
\item
  \textbf{Interactors:} Implementations of specific use cases for
  communicating with servers or any other data store. They can use local
  and remote data sources by using Server Connectors or custom classes.
  If a user action or use case needs to execute more than one query on a
  local or remote store, the sequence is done in the corresponding
  Interactor. If a Screenlet supports more than one user action or use
  case, an Interactor must be created for each.
\item
  \textbf{Connectors} (or Server Connectors): A collection of classes
  that can interact with local and remote data sources and Liferay
  instances. Liferay's own set of Connectors, Liferay Connectors, use
  the
  \href{/docs/7-1/tutorials/-/knowledge_base/t/invoking-liferay-services-in-your-ios-app}{Liferay
  Mobile SDK}. All Server Connectors can run concurrently since they use
  the
  \href{https://developer.apple.com/library/mac/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationObjects/OperationObjects.html\#//apple_ref/doc/uid/TP40008091-CH101-SW1}{\texttt{NSOperation}
  framework}. It's straightforward to define priorities and dependencies
  between Connectors, so you can build your own graph of Connectors
  (operations) that can the framework can resolve. Connectors are always
  created using a
  \href{https://en.wikipedia.org/wiki/Abstract_factory_pattern}{factory
  class} so they can be injected by the app developer.
\item
  \textbf{Themes:} A set of XIB files and accompanying \texttt{UIView}
  classes that present Screenlets to the user.
\end{itemize}

\section{Core Layer of Liferay Screens for
iOS}\label{core-layer-of-liferay-screens-for-ios}

The Core is the micro-framework that lets developers write Screenlets in
a structured and isolated way. All Screenlets share a common structure
based on the Core classes, but each Screenlet can have a unique purpose
and communication API.

\begin{figure}
\centering
\includegraphics{./images/screens-ios-architecture-02.png}
\caption{Here's the core layer of Liferay Screens for iOS.}
\end{figure}

From right to left, these are the main components:

\begin{itemize}
\item
  \href{https://github.com/liferay/liferay-screens/blob/master/ios/Framework/Core/Base/BaseScreenletView.swift}{\textbf{BaseScreenletView}}:
  The base class for all Screenlet View classes. Its child classes
  belong to the Theme layer. View classes use standard XIB files to
  render a UI and then update it when the data changes. The
  \texttt{BaseScreenletView} class contains template methods that child
  classes may overwrite. When developing your own Theme from a parent
  Theme, you can read the Screenlet's properties or call its methods
  from this class. Any user action in the UI is received in this class,
  and then redirected to the Screenlet class.
\item
  \href{https://github.com/liferay/liferay-screens/blob/master/ios/Framework/Core/Base/BaseScreenlet.swift}{\textbf{BaseScreenlet}}:
  The base class for all Screenlet classes. Screenlet classes receive UI
  events through the \texttt{ScreenletView} class, then instantiate
  Interactors to process and respond to that UI event. When the
  Interactor's result is received, the \texttt{ScreenletView} (the UI)
  is updated accordingly. The \texttt{BaseScreenlet} class contains a
  set of
  \href{http://www.oodesign.com/template-method-pattern.html}{template
  methods} that child classes may overwrite.
\item
  \href{https://github.com/liferay/liferay-screens/blob/master/ios/Framework/Core/Base/Interactor.swift}{\textbf{Interactor}}:
  The base class for all Interactors that a Screenlet supports. The
  Interactor class implements a specific use case supported by the
  Screenlet. If the Screenlet supports several use cases, it needs
  different Interactors. If the Interactor needs to retrieve remote
  data, it uses a Server Connector to do so. When the Server Connector
  returns the operation's result, the Interactor returns that result to
  the Screenlet. The Screenlet then changes the \texttt{ScreenletView}
  (the UI) status.
\item
  \href{https://github.com/liferay/liferay-screens/blob/master/ios/Framework/Core/Base/BaseConnectors/ServerConnector.swift}{\textbf{ServerConnector}}:
  The base class for all Liferay Connectors that a Screenlet supports.
  Connectors retrieve data asynchronously from local or remote data
  sources. The Interactor classes instantiate and start these Connector
  classes.
\item
  \href{https://github.com/liferay/liferay-screens/blob/master/ios/Framework/Core/Context/SessionContext.swift}{\textbf{SessionContext}}:
  An object (typically a singleton) that holds the logged in user's
  session. Apps can use an implicit login, invisible to the user, or a
  login that relies on explicit user input to create the session. User
  logins can be implemented with
  \href{/docs/7-1/reference/-/knowledge_base/r/loginscreenlet-for-ios}{Login
  Screenlet}. For more information, see the
  \href{/docs/7-1/tutorials/-/knowledge_base/t/accessing-the-liferay-session-in-ios}{tutorial
  on accessing the session in iOS}.
\item
  \href{https://github.com/liferay/liferay-screens/blob/master/ios/Framework/Core/Context/LiferayServerContext.swift}{\textbf{LiferayServerContext}}:
  A singleton object that holds server configuration parameters. It's
  loaded from the \texttt{liferay-server-context.plist} file. Most
  Screenlets use these parameters as default values.
\end{itemize}

\section{Screenlet Layer of Liferay Screens for
iOS}\label{screenlet-layer-of-liferay-screens-for-ios}

The Screenlet layer contains the available Screenlets in Liferay Screens
for iOS. The following diagram shows the Screenlet layer in relation to
the Core, Interactor, Theme, and Connector layers. The Screenlet classes
in the diagram are explained in this section.

\begin{figure}
\centering
\includegraphics{./images/screens-ios-architecture-03.png}
\caption{This diagram illustrates the iOS Screenlet Layer's relationship
to other Screens components.}
\end{figure}

Screenlets are comprised of several Swift classes and an XIB file:

\begin{itemize}
\item
  \textbf{MyScreenletViewModel:} A protocol that defines the attributes
  shown in the UI. It typically accounts for all the input and output
  values presented to the user. For example,
  \href{https://github.com/liferay/liferay-screens/blob/master/ios/Framework/Core/Auth/LoginScreenlet/LoginViewModel.swift}{\texttt{LoginViewModel}}
  includes attributes like the user name and password. A Connector can
  be configured by reading and validating these values. Also, the
  Screenlet can change these values based on any default values and
  operation results.
\item
  \textbf{MyScreenlet:} a class that represents the Screenlet component
  the app developer interacts with. It includes the following things:

  \begin{itemize}
  \tightlist
  \item
    Inspectable parameters for configuring the Screenlet's behavior. The
    initial state can be set in the Screenlet's data.
  \item
    A reference to the Screenlet's View, based on the selected Theme. To
    meet the Screenlet's requirements, all Themes must implement the
    \texttt{ViewModel} protocol.
  \item
    Any number of methods for invoking Connectors. You can optionally
    make them public for app developers to call.\\
  \item
    An optional (but recommended)
    \href{https://developer.apple.com/library/ios/documentation/general/conceptual/DevPedia-CocoaCore/Delegation.html}{delegate
    object} the Screenlet can call on for particular events.
  \end{itemize}
\item
  \textbf{MyUserCaseInteractor:} Each Interactor runs the operations
  that implement the use case. These can be local operations, remote
  operations, or a combination thereof. Operations can be executed
  sequentially or in parallel. The final results are stored in a
  \texttt{result} object that can be read by the Screenlet when
  notified. The number of Interactor classes a Screenlet requires
  depends on the number of use cases it supports.
\item
  \textbf{MyOperationConnector:} This is related to the Interactor, but
  has one or more Connectors. If the Server Connector is a back-end
  call, then there's typically only a single request. Each Server
  Connector is responsible for retrieving a set of related values. The
  results are stored in a \texttt{result} object that can be read by the
  Interactor when notified. The number of Server Connector classes an
  Interactor requires depends on the number of endpoints you need to
  query, or even the number of different servers you need to support.
  Connectors are always created using a
  \href{https://en.wikipedia.org/wiki/Abstract_factory_pattern}{factory
  class}. You can therefore take advantage of
  \href{https://en.wikipedia.org/wiki/Inversion_of_control}{Inversion of
  Control}. This way, you can implement your own factory class to use to
  create your own Connector objects. To tell Screens to use your factory
  class, specify it in the \texttt{liferay-server-context.plist} file as
  described
  \href{/docs/7-1/tutorials/-/knowledge_base/t/preparing-ios-projects-for-liferay-screens\#configuring-communication-with-liferay}{in
  the tutorial on preparing your iOS project for Screens}.
\item
  \textbf{MyScreenletView\_themeX:} A class that belongs to one specific
  Theme. In the diagram, this Theme is \emph{ThemeX}. The class renders
  the Screenlet's UI by using its related XIB file. The View object and
  XIB file communicate using standard mechanisms like \texttt{@IBOutlet}
  and \texttt{@IBAction}. When a user action occurs in the XIB file,
  it's received by \texttt{BaseScreenletView} and then passed to the
  Screenlet class via the \texttt{performAction} method. To identify
  different events, the component's \texttt{restorationIdentifier}
  property is passed to the \texttt{performAction} method.
\item
  \textbf{MyScreenletView\_themeX.xib:} An XIB file that specifies how
  to render the Screenlet's View. Its name is very important. By
  convention, a Screenlet with a view class named
  \emph{FooScreenletView} and a Theme named \emph{BarTheme} must have an
  XIB file named \texttt{FooScreenletView\_barTheme.xib}.
\end{itemize}

For more details, refer to the tutorials on
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-ios-screenlets}{creating
iOS Screenlets}.

\section{Theme Layer of Liferay Screens for
iOS}\label{theme-layer-of-liferay-screens-for-ios}

The Theme Layer lets developers set a Screenlet's look and feel. The
Screenlet property \texttt{themeName} determines the Theme to load. This
can be set by the Screenlet's \emph{Theme Name} field in Interface
Builder. A Theme consists of a view class for Screenlet behavior and an
XIB file for the UI. By inheriting one or more of these components from
another Theme, the different Theme \emph{types} allow varying levels of
control over a Screenlet's UI design and behavior.

\begin{figure}
\centering
\includegraphics{./images/screens-ios-architecture-04.png}
\caption{The Theme Layer of Liferay Screens for iOS.}
\end{figure}

There are several Theme types:

\begin{itemize}
\item
  \textbf{Default Theme:} The standard Theme provided by Liferay. It can
  be used as a template to create other Themes, or as the parent Theme
  of other Themes. Each Theme for each Screenlet requires a View class.
  A Default Theme's View class is named
  \texttt{MyScreenletView\_default}, where \texttt{MyScreenlet} is the
  Screenlet's name. This class is similar to the standard
  \texttt{ViewController} in iOS; it receives and handles UI events by
  using the standard \texttt{@IBAction} and \texttt{@IBOutlet}. The View
  class usually uses an XIB file to build the UI components. This XIB
  file is bound to the class.
\item
  \textbf{Child Theme:} Presents the same UI components as the parent
  Theme, but can change the UI components' appearance and position. A
  Child Theme specifies visual changes in its own XIB file; it can't add
  or remove any UI components. In the diagram, the Child Theme inherits
  from the Default Theme. Creating a Child Theme is ideal when you only
  need to make visual changes to an existing Theme. For example, you can
  create a Child Theme that sets new positions and sizes for the
  standard text boxes in Login Screenlet's Default Theme, but without
  adding or overwriting existing code.
\item
  \textbf{Full:} Provides a complete standalone theme. It has no parent
  Theme and implements unique behavior and appearance for a Screenlet.
  Its View class must extend Screens's \texttt{BaseScreenletView} class
  and conform to the Screenlet's view model protocol. It must also
  specify a new UI in an XIB file. Refer to the
  \href{https://github.com/liferay/liferay-screens/tree/master/ios/Framework/Themes/Default}{Default
  Theme} for an example of a Full Theme.
\item
  \textbf{Extended:} Inherits the parent Theme's behavior and
  appearance, but lets you change and add code to both. You can do so by
  creating a new XIB file and a custom View class that extends the
  parent Theme's View class. In the diagram, the Extended Theme inherits
  the Full Theme and extends its Screenlet's View class. Refer to the
  \href{https://github.com/liferay/liferay-screens/tree/master/ios/Framework/Themes/Flat7}{Flat7
  Theme} for an example of an Extended Theme.
\end{itemize}

Themes in Liferay Screens are organized into sets that contain Themes
for several Screenlets. Liferay's available Theme sets are listed here:

\begin{itemize}
\item
  \href{https://github.com/liferay/liferay-screens/tree/master/ios/Framework/Themes/Default}{\textbf{Default:}}
  A mandatory Theme set supplied by Liferay. It's used if the
  Screenlet's \texttt{themeName} isn't specified or is invalid. The
  Default Theme uses a neutral, flat white and blue design with standard
  UI components. For example, the
  \href{https://github.com/liferay/liferay-screens/tree/master/ios/Framework/Core/Auth/LoginScreenlet}{Login
  Screenlet} uses standard text boxes for the user name and password
  fields, but uses the Default Theme's flat white and blue design.
\item
  \href{https://github.com/liferay/liferay-screens/tree/master/ios/Framework/Themes/Flat7}{\textbf{Flat7:}}
  A collection of Themes that use a flat black and green design, and UI
  components with rounded edges. They're Extended Themes.
\item
  \href{https://github.com/liferay/liferay-screens/tree/master/ios/Samples/WesterosBank/Theme}{\textbf{Westeros:}}
  The Theme for the
  \href{https://github.com/liferay/liferay-screens/tree/master/ios/Samples/WesterosBank/App}{Bank
  of Westeros} sample app.
\end{itemize}

For more details on Theme creation, see the tutorial series
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-ios-themes}{Creating
iOS Themes}.

\chapter{Creating iOS Screenlets}\label{creating-ios-screenlets}

\href{/docs/7-1/reference/-/knowledge_base/r/screenlets-in-liferay-screens-for-ios}{The
built-in Screenlets} cover common use cases for mobile apps that use
Liferay. They authenticate users, interact with Dynamic Data Lists,
display assets, and more. What if, however, there's no Screenlet for
\emph{your} use case? No problem! You can create your own. Extensibility
is a key strength of Liferay Screens.

This tutorial series explains how to create your own Screenlets. As an
example, it references code from the sample
\href{https://github.com/liferay/liferay-screens/tree/master/ios/Samples/Bookmark}{Add
Bookmark Screenlet}, that saves bookmarks to Liferay's Bookmarks
portlet.

In general, you use the following steps to create Screenlets:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{Plan Your Screenlet:} Your Screenlet's features and use cases
  determine where you'll create it and the portal services you'll call.
\item
  \textbf{Create Your Screenlet's UI (its Theme):} Although these
  tutorials present all the information you need to create a Theme for
  your Screenlet, you may first want to learn the steps for
  \href{/docs/7-1/tutorials/-/knowledge_base/t/creating-ios-themes}{creating
  a Theme}. For more information on Themes in general, see
  \href{/docs/7-1/tutorials/-/knowledge_base/t/using-themes-in-ios-screenlets}{the
  tutorial on using Themes}.
\item
  \textbf{Create the Screenlet's Interactor:} Interactors are Screenlet
  components that make server calls.
\item
  \textbf{Create the Screenlet class:} The Screenlet class is the
  Screenlet's central component. It controls the Screenlet's behavior
  and is the component the app developer interacts with when using a
  Screenlet.
\end{enumerate}

The tutorials that follow walk you through these steps. Before getting
started, make sure that you're familiar with the
\href{/docs/7-1/tutorials/-/knowledge_base/t/architecture-of-liferay-screens-for-ios}{architecture
of Liferay Screens}.

\section{Planning Your iOS Screenlet}\label{planning-your-ios-screenlet}

Before creating your Screenlet, you must determine what it needs to do
and how you want developers to use it. This determines where you'll
create your Screenlet and its functionality.

Where you should create your Screenlet depends on how you plan to use
it. If you want to reuse or redistribute it, you should create it in an
empty Cocoa Touch Framework project in Xcode. You can then use CocoaPods
to publish it. The tutorial
\href{/docs/7-1/tutorials/-/knowledge_base/t/packaging-ios-themes}{Packaging
iOS Themes} explains how to publish an iOS Screenlet. Even though that
tutorial refers to Themes, the steps for preparing Screenlets for
publication are the same. If you don't plan to reuse or redistribute
your Screenlet, create it in your app's Xcode project.

You must also determine your Screenlet's functionality and what data
your Screenlet requires. This determines the actions your Screenlet must
support and the Liferay remote services it must call. For example, Add
Bookmark Screenlet only needs to respond to one action: adding a
bookmark to Liferay's Bookmarks portlet. To add a bookmark, this
Screenlet must call the Liferay instance's \texttt{add-entry} service
for \texttt{BookmarksEntry}. If you're running a Liferay instance
locally on port 8080,
\href{http://localhost:8080/api/jsonws?contextName=bookmarks&signature=\%2Fbookmarks.bookmarksentry\%2Fadd-entry-6-groupId-folderId-name-url-description-serviceContext}{click
here} to see this service. To add a bookmark, this service requires the
following parameters:

\begin{itemize}
\item
  \texttt{groupId}: The site ID in the Liferay instance that contains
  the Bookmarks portlet.
\item
  \texttt{folderId}: The folder ID in the Bookmarks portlet that
  receives the new bookmark.
\item
  \texttt{name}: The new bookmark's title.
\item
  \texttt{url}: The new bookmark's URL.
\item
  \texttt{description}: The new bookmark's description.
\item
  \texttt{serviceContext}: A Liferay
  \href{/docs/7-1/tutorials/-/knowledge_base/t/understanding-servicecontext}{\texttt{ServiceContext}}
  object.
\end{itemize}

Add Bookmark Screenlet must therefore account for each of these
parameters. When saving a bookmark, the Screenlet asks the user to enter
the bookmark's URL and name. The user isn't required, however, to enter
any other parameters. This is because the app developer sets the
\texttt{groupId} and \texttt{folderId} via the app's code. Also, the
Screenlet's code automatically populates the \texttt{description} and
\texttt{serviceContext}.

\section{Creating the iOS Screenlet's
UI}\label{creating-the-ios-screenlets-ui}

In Liferay Screens for iOS, a Screenlet's UI is called a Theme. Every
Screenlet must have at least one Theme. A Theme has the following
components:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  An XIB file: defines the UI components that the Theme presents to the
  end user.
\item
  A View class: renders the UI, handles user interactions, and
  communicates with the Screenlet class.
\end{enumerate}

First, create a new XIB file and use Interface Builder to construct your
Screenlet's UI. In many cases, the Screenlet's actions must be triggered
from the Theme. To achieve this, make sure to use a
\texttt{restorationIdentifier} property to assign a unique ID to each UI
component that triggers an action. The user triggers the action by
interacting with the UI component. If the action only changes the UI's
state (that is, changes the UI component's properties), then you can
associate that component's event to an \texttt{IBAction} method as
usual. Actions using \texttt{restorationIdentifier} are intended for use
by actions that need an Interactor, such as actions that make server
requests or retrieve data from a database.

For example, Add Bookmark Screenlet's UI needs text boxes for entering a
bookmark's URL and title. This UI also needs a button to support the
Screenlet's action: sending the bookmark to a Liferay instance. The
\href{https://github.com/liferay/liferay-screens/tree/master/ios/Samples/Bookmark/AddBookmarkScreenlet/Basic/Themes/AddBookmarkView_default.xib}{XIB
file \texttt{AddBookmarkView\_default.xib}} defines this UI. Because the
button triggers the Screenlet's action, it contains
\texttt{restorationIdentifier="add-bookmark"}.

\begin{figure}
\centering
\includegraphics{./images/screens-ios-xcode-add-bookmark.png}
\caption{Here's the sample Add Bookmark Screenlet's XIB file rendered in
Interface Builder.}
\end{figure}

\noindent\hrulefill

\textbf{Note:} The Screenlet in this tutorial doesn't support multiple
Themes. If you want your Screenlet to support multiple Themes, your View
class must also conform a \emph{View Model} protocol that you create.
For instructions on this, see the tutorial
\href{/docs/7-1/tutorials/-/knowledge_base/t/supporting-multiple-themes-in-your-ios-screenlet}{Supporting
Multiple Themes in Your Screenlet}.

\noindent\hrulefill

Now you must create your Screenlet's View class. This class controls the
UI you just defined. In the
\href{https://github.com/liferay/liferay-screens/blob/master/ios/Framework/Core/Base/BaseScreenletView.swift}{\texttt{BaseScreenletView}
class}, Screens provides the default functionality required by all View
classes. Your View class must therefore extend
\texttt{BaseScreenletView} to provide the functionality unique to your
Screenlet. To support your UI, use standard \texttt{@IBOutlet}s and
\texttt{@IBAction}s to connect all your XIB's UI components and events
to your View class. You should also implement getters and setters to get
values from and set values to the UI components. Your View class should
also implement any required animations or front-end logic.

For example,
\href{https://github.com/liferay/liferay-screens/tree/master/ios/Samples/Bookmark/AddBookmarkScreenlet/Basic/Themes/AddBookmarkView_default.swift}{\texttt{AddBookmarkView\_default}}
is Add Bookmark Screenlet's View class. This class extends
\texttt{BaseScreenletView} and contains \texttt{@IBOutlet} references to
the XIB's text fields. The getters for these references let the Theme
retrieve the data the user enters into the corresponding text field:

\begin{verbatim}
import UIKit
import LiferayScreens

class AddBookmarkView_default: BaseScreenletView {

   @IBOutlet weak var URLTextField: UITextField?
   @IBOutlet weak var titleTextField: UITextField?

   var URL: String? {
       return URLTextField?.text
   }

   var title: String? {
       return titleTextField?.text
   }
}
\end{verbatim}

In Interface Builder, you must now specify your View class as your XIB
file's custom class. In Add Bookmark Screenlet, for example,
\texttt{AddBookmarkView\_default} is set as the
\texttt{AddBookmarkView\_default.xib} file's custom class in Interface
Builder.

If you're using CocoaPods, make sure to explicitly set a valid module
for the custom class--the grayed-out \emph{Current} default value only
suggests a module.

\begin{figure}
\centering
\includegraphics{./images/screens-ios-theme-custom-module-wrong.png}
\caption{In this XIB file, the custom class's module is NOT specified.}
\end{figure}

\begin{figure}
\centering
\includegraphics{./images/screens-ios-theme-custom-module-right.png}
\caption{The XIB file is bound to the custom class name, with the
specified module.}
\end{figure}

\section{Creating the iOS Screenlet's
Interactor}\label{creating-the-ios-screenlets-interactor}

Create an Interactor class for each of your Screenlet's actions. In the
\href{https://github.com/liferay/liferay-screens/blob/master/ios/Framework/Core/Base/Interactor.swift}{\texttt{Interactor}
class}, Screens provides the default functionality required by all
Interactor classes. Your Interactor class must therefore extend
\texttt{Interactor} to provide the functionality unique to your
Screenlet.

\noindent\hrulefill

\textbf{Note:} You may wish to make your server call in a Connector
instead of an Interactor. Doing so provides an additional abstraction
layer for your server call, leaving your Interactor to instantiate your
Connector and receive its results. For instructions on this, see the
tutorial
\href{/docs/7-1/tutorials/-/knowledge_base/t/create-and-use-a-connector-with-your-screenlet}{Create
and Use a Connector with Your Screenlet}.

\noindent\hrulefill

Interactors work synchronously, but you can use callbacks (delegates) or
Connectors to run their operations in the background. For example, the
Liferay Mobile SDK provides the
\href{https://github.com/liferay/liferay-mobile-sdk/blob/master/ios/Source/Core/LRCallback.h}{\texttt{LRCallback}
protocol} for this purpose. This is described in
\href{/docs/7-1/tutorials/-/knowledge_base/t/invoking-services-asynchronously-from-your-ios-app}{the
Mobile SDK tutorial on invoking Liferay services asynchronously}.
Screens bridges this protocol to make it available in Swift. Your
Interactor class can conform this protocol to make its server calls
asynchronously. To implement an Interactor class:

\begin{itemize}
\tightlist
\item
  Your initializer must receive all required properties and a reference
  to the Screenlet.
\item
  Override \texttt{Interactor}'s \texttt{start} method to perform the
  server operations your Screenlet requires (e.g., invoke a Liferay
  operation via a Liferay Mobile SDK service).
\item
  Save the server response to an accessible property, if necessary. For
  example, if the server call returns objects from a Liferay instance,
  you should store these objects in an accessible property. This way
  your Screenlet can display those results to the user.
\item
  You must invoke the methods \texttt{callOnSuccess} and
  \texttt{callOnFailure} to execute the closures \texttt{onSuccess} and
  \texttt{onFailure}, respectively.
\end{itemize}

For example, the sample Add Bookmark Screenlet's Interactor class
\href{https://github.com/liferay/liferay-screens/tree/master/ios/Samples/Bookmark/AddBookmarkScreenlet/Basic/Interactor/AddBookmarkInteractor.swift}{\texttt{AddBookmarkInteractor}}
makes the server call that adds a bookmark to a Liferay instance. This
class extends the \texttt{Interactor} class and conforms the
\texttt{LRCallback} protocol. The latter ensures that the Interactor's
server call runs asynchronously:

\begin{verbatim}
public class AddBookmarkInteractor: Interactor, LRCallback {...
\end{verbatim}

To save the server call's results, \texttt{AddBookmarkInteractor}
defines the public variable \texttt{resultBookmarkInfo}. This class also
defines public constants for the bookmark's folder ID, title, and URL.
The initializer sets these variables and calls \texttt{Interactor}'s
constructor with a reference to the base Screenlet class
(\texttt{BaseScreenlet}):

\begin{verbatim}
public var resultBookmarkInfo: [String:AnyObject]?
public let folderId: Int64
public let title: String
public let url: String

public init(screenlet: BaseScreenlet, folderId: Int64, title: String, url: String) {
    self.folderId = folderId
    self.title = title
    self.url = url
    super.init(screenlet: screenlet)
}
\end{verbatim}

The \texttt{AddBookmarkInteractor} class's \texttt{start} method makes
the server call. To do so, it must first get a \texttt{Session}. Since
Login Screenlet creates a session automatically upon successful login,
the \texttt{start} method retrieves this session with
\texttt{SessionContext.createSessionFromCurrentSession()}. To make the
server call asynchronously, the \texttt{start} method must set a
callback to this session. Because \texttt{AddBookmarkInteractor}
conforms the \texttt{LRCallback} protocol, setting \texttt{self} as the
session's callback accomplishes this. The \texttt{start} method must
then create a \texttt{LRBookmarksEntryService\_v7} instance and call
this instance's \texttt{addEntryWithGroupId} method. The latter method
calls a Liferay instance's \texttt{add-entry} service for
\texttt{BookmarksEntry}. The \texttt{start} method therefore provides
the \texttt{groupId}, \texttt{folderId}, \texttt{name}, \texttt{url},
\texttt{description}, and \texttt{serviceContext} arguments to
\texttt{addEntryWithGroupId}. Note that this example provides a
hard-coded string for the \texttt{description}. Also, the
\texttt{serviceContext} is \texttt{nil} because the Mobile SDK handles
the \texttt{ServiceContext} object for you:

\begin{verbatim}
override public func start() -> Bool {
    let session = SessionContext.createSessionFromCurrentSession()
    session?.callback = self

    let service = LRBookmarksEntryService_v7(session: session)

    do {
        try service.addEntryWithGroupId(LiferayServerContext.groupId,
                        folderId: folderId,
                        name: title,
                        url: url,
                        description: "Added from Liferay Screens",
                        serviceContext: nil)

        return true
    }
    catch {
        return false
    }
}
\end{verbatim}

Finally, the \texttt{AddBookmarkInteractor} class must conform the
\texttt{LRCallback} protocol by implementing the \texttt{onFailure} and
\texttt{onSuccess} methods. The \texttt{onFailure} method communicates
the \texttt{NSError} object that results from a failed server call. It
does this by calling the base \texttt{Interactor} class's
\texttt{callOnFailure} method with the error. When the server call
succeeds, the \texttt{onSuccess} method sets the server call's results
(the \texttt{result} argument) to the \texttt{resultBookmarkInfo}
variable. The \texttt{onSuccess} method finishes by calling the base
\texttt{Interactor} class's \texttt{callOnSuccess} method to communicate
the success status throughout the Screenlet:

\begin{verbatim}
public func onFailure(error: NSError!) {
    self.callOnFailure(error)
}

public func onSuccess(result: AnyObject!) {
    //Save result bookmark info
    resultBookmarkInfo = (result as! [String:AnyObject])

    self.callOnSuccess()
}
\end{verbatim}

\section{Creating the iOS Screenlet's
Class}\label{creating-the-ios-screenlets-class}

The Screenlet class is the central hub of a Screenlet. It contains the
Screenlet's properties, a reference to the Screenlet's View class,
methods for invoking Interactor operations, and more. When using a
Screenlet, app developers primarily interact with its Screenlet class.
In other words, if a Screenlet were to become self-aware, it would
happen in its Screenlet class (though we're reasonably confident this
won't happen).

\href{https://github.com/liferay/liferay-screens/blob/master/ios/Framework/Core/Base/BaseScreenlet.swift}{Screens's
\texttt{BaseScreenlet} class} is a base Screenlet class implementation.
Since \texttt{BaseScreenlet} provides most of a Screenlet class's
required functionality, your Screenlet class should extend
\texttt{BaseScreenlet}. This lets you focus on your Screenlet's unique
functionality. Your Screenlet class must also include any
\texttt{@IBInspectable} properties your Screenlet requires and a
reference to your Screenlet's View class. To perform your Screenlet's
action, your Screenlet class must override \texttt{BaseScreenlet}'s
\texttt{createInteractor} method. This method should create an instance
of your Interactor and then set the Interactor's \texttt{onSuccess} and
\texttt{onFailure} closures to define what happens when the server call
succeeds or fails, respectively.

For example, the
\href{https://github.com/liferay/liferay-screens/blob/master/ios/Samples/Bookmark/AddBookmarkScreenlet/Basic/AddBookmarkScreenlet.swift}{\texttt{AddBookmarkScreenlet}
class} is the Screenlet class in Add Bookmark Screenlet. This class
extends \texttt{BaseScreenlet} and contains an \texttt{@IBInspectable}
variable for the bookmark folder's ID (\texttt{folderId}). The
\texttt{AddBookmarkScreenlet} class's \texttt{createInteractor} method
first gets a reference to the View class
(\texttt{AddBookmarkView\_default}). It then creates an
\texttt{AddBookmarkInteractor} instance with this Screenlet class
(\texttt{self}), the \texttt{folderId}, the bookmark's title, and the
bookmark's URL. Note that the View class reference contains the bookmark
title and URL that the user entered into the UI. The
\texttt{createInteractor} method then sets the Interactor's
\texttt{onSuccess} closure to print a success message when the server
call succeeds. Likewise, the Interactor's \texttt{onFailure} closure is
set to print an error message when the server call fails. Note that
you're not restricted to only printing messages here: you should set
these closures to do whatever is best for your Screenlet. The
\texttt{createInteractor} method finishes by returning the Interactor
instance. Here's the complete \texttt{AddBookmarkScreenlet} class:

\begin{verbatim}
import UIKit
import LiferayScreens


public class AddBookmarkScreenlet: BaseScreenlet {

    //MARK: Inspectables

    @IBInspectable var folderId: Int64 = 0

    //MARK: BaseScreenlet

    override public func createInteractor(name name: String?, sender: AnyObject?) -> Interactor? {

        let view = self.screenletView as! AddBookmarkView_default

        let interactor = AddBookmarkInteractor(screenlet: self,
                                           folderId: folderId,
                                           title: view.title!,
                                           url: view.URL!)

        //Called when the Interactor's server call finishes succesfully
        interactor.onSuccess = {
            let bookmarkName = interactor.resultBookmarkInfo!["name"] as! String
            print("Bookmark \"\(bookmarkName)\" saved!")
        }

        //Called when the Interactor's server call fails
        interactor.onFailure = { _ in
            print("An error occurred saving the bookmark")
        }

        return interactor
    }

}
\end{verbatim}

For reference, the sample Add Bookmark Screenlet's final code is
\href{https://github.com/liferay/liferay-screens/tree/master/ios/Samples/Bookmark/AddBookmarkScreenlet/Basic/AddBookmarkScreenlet.swift}{here
on GitHub}.

\chapter{Creating iOS List
Screenlets}\label{creating-ios-list-screenlets}

It's very common for mobile apps to display lists. Liferay Screens lets
you display asset lists and DDL lists in your iOS app by using
\href{/docs/7-1/reference/-/knowledge_base/r/assetlistscreenlet-for-ios}{Asset
List Screenlet} and
\href{/docs/7-1/reference/-/knowledge_base/r/ddllistscreenlet-for-ios}{DDL
List Screenlet}, respectively. Screens also includes list Screenlets for
displaying lists of other Liferay entities like web content articles,
images, and more.
\href{/docs/7-1/reference/-/knowledge_base/r/screenlets-in-liferay-screens-for-ios}{The
Screenlet reference documentation} lists all the Screenlets included
with Liferay Screens. If there's not a list Screenlet for the entity you
want to display in a list, you must create your own list Screenlet. A
list Screenlet can display any entity from a Liferay instance. For
example, you can create a list Screenlet that displays standard Liferay
entities like \texttt{User}, or custom entities from custom Liferay
apps.

The tutorials in this section use code from the sample Bookmark List
Screenlet to show you how to create your own list Screenlet. This
Screenlet displays a list of bookmarks from Liferay's Bookmarks portlet.
You can find this Screenlet's complete code
\href{https://github.com/liferay/liferay-screens/tree/master/ios/Samples/Bookmark/BookmarkListScreenlet}{here
in GitHub}.

Note that because this tutorial focuses on creating a list Screenlet, it
doesn't explain general Screenlet concepts and components. Before
beginning, you should therefore read the following:

\begin{itemize}
\tightlist
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/creating-ios-screenlets}{Creating
  iOS Screenlets}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/supporting-multiple-themes-in-your-ios-screenlet}{Supporting
  Multiple Themes in Your Screenlet}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/create-and-use-a-connector-with-your-screenlet}{Create
  and Use a Connector with Your Screenlet}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/add-a-screenlet-delegate}{Add
  a Screenlet Delegate}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/creating-and-using-your-screenlets-model-class}{Creating
  and Using Your Screenlet's Model Class}
\end{itemize}

You'll create a list Screenlet by following these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Creating the Model class
\item
  Creating the Theme
\item
  Creating the Connector
\item
  Creating the Interactor
\item
  Creating the Delegate
\item
  Creating the Screenlet class
\end{enumerate}

First though, you should understand how pagination works with list
Screenlets.

\section{Pagination}\label{pagination-3}

To ensure that users can scroll smoothly through large lists of items,
list Screenlets support
\href{http://www.iosnomad.com/blog/2014/4/21/fluent-pagination}{fluent
pagination}. Support for this is built into the list Screenlet
framework. You'll see this as you construct your list Screenlet.

\section{Creating the Model Class}\label{creating-the-model-class-1}

Recall that a model class transforms each
\texttt{{[}String:AnyObject{]}} entity Screens receives into a model
object that represents the corresponding Liferay entity. For
instructions on creating your model class, see the tutorial
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-and-using-your-screenlets-model-class}{Creating
and Using Your Screenlet's Model Class}. The example model class in that
tutorial is identical to Bookmark List Screenlet's.

Next, you'll create your list Screenlet's theme.

\section{Creating the iOS List Screenlet's
Theme}\label{creating-the-ios-list-screenlets-theme}

Recall that each Screenlet needs a Theme to serve as its UI. A Theme
needs an XIB file to define the UI's components and layout. Since a list
Screenlet displays a list of entities, its XIB file must contain a Table
View. Use these steps to create your Theme's XIB file:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In Xcode, create a new XIB file and name it according to
  \href{/docs/7-1/tutorials/-/knowledge_base/t/ios-best-practices\#naming-conventions}{these
  naming conventions}. For example, the XIB for Bookmark List
  Screenlet's Default Theme is \texttt{BookmarkListView\_default.xib}.
\item
  In Interface Builder, drag and drop a View from the Object Library to
  the canvas. Then add a Table View to the View.
\item
  Resize the Table View to take up the entire View, and set the
  constraints the Table View needs to maintain this size dynamically.
  This ensures that the list fills the Screenlet's UI regardless of the
  iOS device's size or orientation.
\end{enumerate}

For example,
\href{https://github.com/liferay/liferay-screens/blob/master/ios/Samples/Bookmark/BookmarkListScreenlet/Themes/Default/BookmarkListView_default.xib}{Bookmark
List Screenlet's XIB file} uses a \texttt{UITableView} inside a parent
View to show the list of bookmarks.

Now you'll create your Theme's View class. Every Theme needs a View
class that controls its behavior. Since the XIB file uses a
\texttt{UITableView} to show a list of guestbooks, your View class must
extend
\href{https://github.com/liferay/liferay-screens/blob/master/ios/Framework/Core/Base/BaseListScreenlet/TableView/BaseListTableView.swift}{the
\texttt{BaseListTableView} class}. Liferay Screens provides this class
to serve as the base class for list Screenlets' View classes. Since
\texttt{BaseListTableView} provides most of the required functionality,
extending it lets you focus on the parts of your View class that are
unique to your Screenlet. You must also configure the XIB file to use
your View class.

Follow these steps to create your Screenlet's View class and configure
the XIB file to use it:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create your Theme's View class, and name it according to
  \href{/docs/7-1/tutorials/-/knowledge_base/t/ios-best-practices\#naming-conventions}{these
  naming conventions}. Since the XIB uses \texttt{UITableView}, your
  View class must extend \texttt{BaseListTableView}. For example, this
  is Bookmark List Screenlet's View class declaration:

\begin{verbatim}
public class BookmarkListView_default: BaseListTableView {...
\end{verbatim}
\item
  Now you must override the View class methods that fill the table
  cells' contents. There are two methods for this, depending on the cell
  type:

  \begin{itemize}
  \item
    \textbf{Normal cells:} the cells that show the entities. These cells
    typically use \texttt{UILabel}, \texttt{UIImage}, or another UI
    component to show the entity. Override the \texttt{doFillLoadedCell}
    method to fill these cells. For example, Bookmark List Screenlet's
    View class overrides \texttt{doFillLoadedCell} to set each cell's
    \texttt{textLabel} to a bookmark's name:

\begin{verbatim}
  override public func doFillLoadedCell(row row: Int, cell: UITableViewCell, 
      object: AnyObject) {

          let bookmark = object as! Bookmark

          cell.textLabel?.text = bookmark.name
  }
\end{verbatim}
  \item
    \textbf{Progress cell:} the cell at the bottom of the list that
    indicates the list is loading the next page of items. Override the
    \texttt{doFillInProgressCell} method to fill this cell. For example,
    Bookmark List Screenlet's View class overrides this method to set
    the cell's \texttt{textLabel} to the string \texttt{"Loading..."}:

\begin{verbatim}
  override public func doFillInProgressCell(row row: Int, cell: UITableViewCell) {
      cell.textLabel?.text = "Loading..."
  }
\end{verbatim}
  \end{itemize}
\item
  Return to the Theme's XIB in Interface Builder, and set the View class
  as the the parent View's custom class. For example, if you were doing
  this for Bookmark List Screenlet you'd select the Table View's parent
  View, click the Identity inspector, and enter
  \texttt{BookmarkListView\_default} as the custom class.
\item
  With the Theme's XIB still open in Interface Builder, set the parent
  View's \texttt{tableView} outlet to the Table View. To do this, select
  the parent View and click the Connections inspector. In the Outlets
  section, drag and drop from the \texttt{tableView}'s circle icon (it
  turns into a plus icon on mouseover) to the Table View in the XIB. The
  new outlet then appears in the Connections inspector.
\end{enumerate}

That's it! Now that your Theme is finished, you can create the
Connector.

\section{Creating the iOS List Screenlet's
Connector}\label{creating-the-ios-list-screenlets-connector}

Recall that Connectors make a server call. To support pagination, a List
Screenlet's Connector class must extend the
\href{https://github.com/liferay/liferay-screens/blob/master/ios/Framework/Core/Base/BaseListScreenlet/PaginationLiferayConnector.swift}{\texttt{PaginationLiferayConnector}
class}. The Connector class must also contain any properties it needs to
make the server call, and an initializer that sets them. To support
pagination, the initializer must also contain the following arguments,
which you'll pass to the superclass initializer:

\begin{itemize}
\tightlist
\item
  \texttt{startRow}: The number representing the page's first row.
\item
  \texttt{endRow}: The number representing the page's last row.
\item
  \texttt{computeRowCount}: Whether to call the Connector's
  \texttt{doAddRowCountServiceCall} method (you'll learn about this
  method shortly).
\end{itemize}

For example, Bookmark List Screenlet must retrieve bookmarks from a
Bookmarks portlet folder in a specific site. The Screenlet's Connector
class must therefore have properties for the \texttt{groupId} (site ID)
and \texttt{folderId} (Bookmarks folder ID), and an initializer that
sets them. The initializer also calls the superclass initializer with
the \texttt{startRow}, \texttt{endRow}, and \texttt{computeRowCount}
arguments:

\begin{verbatim}
import UIKit
import LiferayScreens

public class BookmarkListPageLiferayConnector: PaginationLiferayConnector {

    public let groupId: Int64
    public let folderId: Int64

    //MARK: Initializer

    public init(startRow: Int, endRow: Int, computeRowCount: Bool, groupId: Int64, 
        folderId: Int64) {
        
            self.groupId = groupId
            self.folderId = folderId

            super.init(startRow: startRow, endRow: endRow, computeRowCount: computeRowCount)
    }
    ...
\end{verbatim}

Next, if you want to validate any of your Screenlet's properties,
override the \texttt{validateData} method as described in
\href{/docs/7-1/tutorials/-/knowledge_base/t/create-and-use-a-connector-with-your-screenlet}{the
tutorial on creating Connectors}. Note that Bookmark List Screenlet only
needs to validate the \texttt{folderId}:

\begin{verbatim}
override public func validateData() -> ValidationError? {
    let error = super.validateData()

    if error == nil {
        if folderId <= 0 {
            return ValidationError("Undefined folderId")
        }
    }

    return error
}
\end{verbatim}

Lastly, you must override the following two methods in the Connector
class:

\begin{itemize}
\item
  \texttt{doAddPageRowsServiceCall}: calls the Liferay Mobile SDK
  service method that retrieves a page of entities. The
  \texttt{doAddPageRowsServiceCall} method's \texttt{startRow} and
  \texttt{endRow} arguments specify the page's first and last entities,
  respectively. Make the service call as you would in any Screenlet. For
  example, the \texttt{doAddPageRowsServiceCall} method in
  \texttt{BookmarkListPageLiferayConnector} calls the service's
  \texttt{getEntriesWithGroupId} method to retrieve a page of bookmarks
  from the folder specified by \texttt{folderId}:

\begin{verbatim}
  public override func doAddPageRowsServiceCall(session session: LRBatchSession, 
      startRow: Int, endRow: Int, obc: LRJSONObjectWrapper?) {
          let service = LRBookmarksEntryService_v7(session: session)

      do {
          try service.getEntriesWithGroupId(groupId,
                                            folderId: folderId,
                                            start: Int32(startRow),
                                            end: Int32(endRow))
      }
      catch  {
          // ignore error: the service method returns nil because
          // the request is sent later, in batch
      }
  }
\end{verbatim}

  Note that you don't need to do anything in the \texttt{catch}
  statement because the request is sent later, in batch. The
  \texttt{session} type \texttt{LRBatchSession} handles this for you.
  You'll receive the request's results elsewhere, once the request
  completes.
\item
  \texttt{doAddRowCountServiceCall}: calls the Liferay Mobile SDK
  service method that retrieves the total number of entities. This
  supports pagination. Make the service call as you would in any
  Screenlet. For example, the \texttt{doAddRowCountServiceCall} in
  \texttt{BookmarkListPageLiferayConnector} calls the service's
  \texttt{getEntriesCountWithGroupId} method to retrieve the total
  number of bookmarks in the folder specified by \texttt{folderId}:

\begin{verbatim}
  override public func doAddRowCountServiceCall(session session: LRBatchSession) {
      let service = LRBookmarksEntryService_v7(session: session)

      do {
          try service.getEntriesCountWithGroupId(groupId, folderId: folderId)
      }
      catch  {
          // ignore error: the service method returns nil because
          // the request is sent later, in batch
      }
  }
\end{verbatim}
\end{itemize}

Now that you have your Connector class, you're ready to create the
Interactor.

\section{Creating the iOS List Screenlet's
Interactor}\label{creating-the-ios-list-screenlets-interactor}

Recall that Interactors implement your Screenlet's actions. In list
Screenlets, loading entities is usually the only action a user can take.
The Interactor class of a list Screenlet that implements fluent
pagination must extend the
\href{https://github.com/liferay/liferay-screens/blob/master/ios/Framework/Core/Base/BaseListScreenlet/BaseListPageLoadInteractor.swift}{\texttt{BaseListPageLoadInteractor}
class}. Your Interactor class must also contain any properties the
Screenlet needs, and an initializer that sets them. This initializer
also needs arguments for the following properties, which it passes to
the superclass initializer:

\begin{itemize}
\tightlist
\item
  \texttt{screenlet}: A \texttt{BaseListScreenlet} reference. This
  ensures the Interactor always has a Screenlet reference.
\item
  \texttt{page}: The page number to retrieve.
\item
  \texttt{computeRowCount}: Whether to call the Connector's
  \texttt{doAddRowCountServiceCall} method.
\end{itemize}

For example, Bookmark List Screenlet's Interactor class contains the
same \texttt{groupId} and \texttt{folderId} properties as the Connector,
and an initializer that sets them. This initializer also passes the
\texttt{screenlet}, \texttt{page}, and \texttt{computeRowCount}
arguments to the superclass initializer:

\begin{verbatim}
public class BookmarkListPageLoadInteractor : BaseListPageLoadInteractor {

    private let groupId: Int64
    private let folderId: Int64

    init(screenlet: BaseListScreenlet,
        page: Int,
        computeRowCount: Bool,
        groupId: Int64,
        folderId: Int64) {

            self.groupId = (groupId != 0) ? groupId : LiferayServerContext.groupId
            self.folderId = folderId

            super.init(screenlet: screenlet, page: page, computeRowCount: computeRowCount)
    }
    ...
\end{verbatim}

The Interactor class must also initiate the server request by
instantiating the Connector, and convert the results into model objects.
Override the \texttt{createListPageConnector} method to create and
return an instance of your Connector. This method must first get a
reference to the Screenlet via the \texttt{screenlet} property. When
calling the Connector's initializer, use
\texttt{screenlet.firstRowForPage} to convert the page number
(\texttt{page}) to the page's start and end indices. You must also pass
the initializer any other properties it needs, like \texttt{groupId}.
For example, \texttt{BookmarkListPageLoadInteractor}'s
\texttt{createListPageConnector} method does this to create a
\texttt{BookmarkListPageLiferayConnector} instance:

\begin{verbatim}
public override func createListPageConnector() -> PaginationLiferayConnector {
    let screenlet = self.screenlet as! BaseListScreenlet

    return BookmarkListPageLiferayConnector(
        startRow: screenlet.firstRowForPage(self.page),
        endRow: screenlet.firstRowForPage(self.page + 1),
        computeRowCount: self.computeRowCount,
        groupId: groupId,
        folderId: folderId)
}
\end{verbatim}

Next, override the \texttt{convertResult} method to convert each
\texttt{{[}String:AnyObject{]}} result into a model object. The
Screenlet calls this method once for each entity retrieved from the
server. For example, \texttt{BookmarkListPageLoadInteractor}'s
\texttt{convertResult} method converts the
\texttt{{[}String:AnyObject{]}} result into a \texttt{Bookmark} object:

\begin{verbatim}
override public func convertResult(_ serverResult: [String:AnyObject]) -> AnyObject {
    return Bookmark(attributes: serverResult)
}
\end{verbatim}

You may also want to support
\href{/docs/7-1/tutorials/-/knowledge_base/t/architecture-of-offline-mode-in-liferay-screens}{offline
mode} in your Interactor. To do so, the Interactor must override the
\texttt{cacheKey} method to return a cache key unique to your Screenlet.
For example, \texttt{BookmarkListPageLoadInteractor}'s \texttt{cacheKey}
method returns a cache key that includes the Screenlet's
\texttt{groupId} and \texttt{folderId} settings:

\begin{verbatim}
override public func cacheKey(_ op: PaginationLiferayConnector) -> String {
    return "\(groupId)-\(folderId)"
}
\end{verbatim}

Great! Next, you'll create your Screenlet's delegate.

\section{Creating the iOS List Screenlet's
Delegate}\label{creating-the-ios-list-screenlets-delegate}

Recall that a delegate is required if you want other classes to respond
to your Screenlet's actions. Create your delegate by following the first
step in
\href{/docs/7-1/tutorials/-/knowledge_base/t/add-a-screenlet-delegate}{the
tutorial on adding a Screenlet delegate}. A list Screenlet's delegate
must also define a method for responding to a list item selection. For
example, Bookmark List Screenlet's delegate needs the following methods:

\begin{itemize}
\tightlist
\item
  \texttt{screenlet(\_:onBookmarkListResponse:)}: Returns the
  \texttt{Bookmark} results when the server call succeeds.
\item
  \texttt{screenlet(\_:onBookmarkListError:)}: Returns the
  \texttt{NSError} object when the server call fails.
\item
  \texttt{screenlet(\_:onBookmarkSelected:)}: Returns the
  \texttt{Bookmark} when a user selects it in the list.
\end{itemize}

The \texttt{BookmarkListScreenletDelegate} protocol defines these
methods:

\begin{verbatim}
@objc public protocol BookmarkListScreenletDelegate : BaseScreenletDelegate {

    optional func screenlet(screenlet: BookmarkListScreenlet,
                            onBookmarkListResponse bookmarks: [Bookmark])

    optional func screenlet(screenlet: BookmarkListScreenlet,
                            onBookmarkListError error: NSError)

    optional func screenlet(screenlet: BookmarkListScreenlet,
                            onBookmarkSelected bookmark: Bookmark)

}
\end{verbatim}

Nice work! Next, you'll create the Screenlet class.

\section{Creating the iOS List Screenlet's
Class}\label{creating-the-ios-list-screenlets-class}

Now that your list Screenlet's other components exist, you can create
the Screenlet class. A list Screenlet's Screenlet class must extend the
\href{https://github.com/liferay/liferay-screens/blob/master/ios/Framework/Core/Base/BaseListScreenlet/BaseListScreenlet.swift}{\texttt{BaseListScreenlet}
class} and define the configurable properties the Screenlet needs. You
should define these as \texttt{IBInspectable} properties. If you want to
support offline mode, you should also add an \texttt{offlinePolicy}
property.

For example,
\href{https://github.com/liferay/liferay-screens/blob/master/ios/Samples/Bookmark/BookmarkListScreenlet/BookmarkListScreenlet.swift}{Bookmark
List Screenlet's Screenlet class} contains the \texttt{IBInspectable}
properties \texttt{groupId}, \texttt{folderId}, and
\texttt{offlinePolicy}:

\begin{verbatim}
public class BookmarkListScreenlet: BaseListScreenlet {

    @IBInspectable public var groupId: Int64 = 0
    @IBInspectable public var folderId: Int64 = 0
    @IBInspectable public var offlinePolicy: String? = CacheStrategyType.RemoteFirst.rawValue

    ...
\end{verbatim}

Next, override the \texttt{createPageLoadInteractor} method to create
and return the Interactor. If your Screenlet supports offline mode, you
should also use \texttt{offlinePolicy} to pass a
\texttt{CacheStrategyType} object to the Interactor. For example, the
\texttt{createPageLoadInteractor} method in
\texttt{BookmarkListScreenlet} creates and returns a
\texttt{BookmarkListPageLoadInteractor} instance. This method also sets
the Interactor's \texttt{cacheStrategy} property to a
\texttt{CacheStrategyType} object created with \texttt{offlinePolicy}:

\begin{verbatim}
override public func createPageLoadInteractor(
    page page: Int, 
    computeRowCount: Bool) -> BaseListPageLoadInteractor {

    let interactor = BookmarkListPageLoadInteractor(screenlet: self,
                                                    page: page,
                                                    computeRowCount: computeRowCount,
                                                    groupId: self.groupId,
                                                    folderId: self.folderId)

    interactor.cacheStrategy = CacheStrategyType(rawValue: self.offlinePolicy ?? "") ?? .RemoteFirst

    return interactor
}
\end{verbatim}

Now get a reference to your delegate. The \texttt{BaseScreenlet} class,
which \texttt{BaseListScreenlet} extends, already defines the
\texttt{delegate} property for the delegate object. Every list Screenlet
therefore has this property, and any app developer using the Screenlet
can access it. To avoid casting this property to your delegate every
time you use it, add a computed property to your Screenlet class that
does so. For example, the following \texttt{bookmarkListDelegate}
property in \texttt{BookmarkListScreenlet} casts the \texttt{delegate}
property to \texttt{BookmarkListScreenletDelegate}:

\begin{verbatim}
public var bookmarkListDelegate: BookmarkListScreenletDelegate? {
    return delegate as? BookmarkListScreenletDelegate
}
\end{verbatim}

Next, override the \texttt{BaseListScreenlet} methods that handle the
Screenlet's events. Because these events correspond to the events your
delegate methods handle, you'll call your delegate methods in these
\texttt{BaseListScreenlet} methods:

\begin{itemize}
\item
  \texttt{onLoadPageResult}: Called when the Screenlet loads a page
  successfully. Override this method to call your delegate's
  \texttt{screenlet(\_:onBookmarkListResponse:)} method. For example,
  here's \texttt{BookmarkListScreenlet}'s \texttt{onLoadPageResult}
  method:

\begin{verbatim}
  override public func onLoadPageResult(page page: Int, rows: [AnyObject], rowCount: Int) {
      super.onLoadPageResult(page: page, rows: rows, rowCount: rowCount)

      bookmarkListDelegate?.screenlet?(screenlet: self, onBookmarkListResponse: rows as! [Bookmark])
  }
\end{verbatim}
\item
  \texttt{onLoadPageError}: Called when the Screenlet fails to load a
  page. Override this method to call your delegate's
  \texttt{screenlet(\_:onBookmarkListError:)} method. For example,
  here's \texttt{BookmarkListScreenlet}'s \texttt{onLoadPageError}
  method:

\begin{verbatim}
  override public func onLoadPageError(page page: Int, error: NSError) {
      super.onLoadPageError(page: page, error: error)

      bookmarkListDelegate?.screenlet?(screenlet: self, onBookmarkListError: error)
  }
\end{verbatim}
\item
  \texttt{onSelectedRow}: Called when an item is selected in the list.
  Override this method to call your delegate's
  \texttt{screenlet(\_:onBookmarkSelected:)} method. For example, here's
  \texttt{BookmarkListScreenlet}'s \texttt{onSelectedRow} method:

\begin{verbatim}
  override public func onSelectedRow(_ row: AnyObject) {
      bookmarkListDelegate?.screenlet?(screenlet: self, onBookmarkSelected: row as! Bookmark)
  }
\end{verbatim}
\end{itemize}

\chapter{Creating iOS Themes}\label{creating-ios-themes}

By creating your own Themes, you can customize your mobile app's design
and functionality. You can create them from scratch or use an existing
Theme as a foundation. Themes include a View class for implementing
Screenlet behavior and an XIB file for specifying the UI. The three
Liferay Screens Theme types support different levels of customization
and parent Theme inheritance. Here's what each Theme type offers:

\begin{itemize}
\item
  \textbf{Child Theme:} Presents the same UI components as its parent
  Theme, but lets you change their appearance and position.
\item
  \textbf{Extended Theme:} Inherits its parent Theme's functionality and
  appearance, but lets you add to and modify both.
\item
  \textbf{Full Theme:} Provides a complete standalone View for a
  Screenlet. A full Theme is ideal for implementing functionality and
  appearance completely different from a Screenlet's current Theme.
\end{itemize}

The tutorials in this section explain how to create all three Theme
types. To understand Theme concepts and components, you might want to
examine the
\href{/docs/7-1/tutorials/-/knowledge_base/t/architecture-of-liferay-screens-for-ios}{architecture}
of Liferay Screens for iOS. The tutorials on
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-ios-screenlets}{creating
iOS Screenlets} can help you create any Screenlet classes your Theme
requires.

\section{Determining Your Theme's
Location}\label{determining-your-themes-location}

After determining the type of Theme to create, you need to decide where
to create it. If you want to reuse or redistribute it, you should create
it in an empty Cocoa Touch Framework project in Xcode. The
\href{/docs/7-1/tutorials/-/knowledge_base/t/packaging-ios-themes}{packaging}
tutorial explains how to package and publish with CocoaPods. If you're
not planning to reuse or redistribute your Theme, you can create it
directly inside your app project.

\section{Creating an iOS Child Theme}\label{creating-an-ios-child-theme}

In a Child Theme, you leverage a parent Theme's behavior and UI
components, but you can modify the appearance and position of the UI
components. Note that you can't add or remove any components and the
parent Theme must be a Full Theme. The Child Theme presents visual
changes with its own XIB file and inherits the parent's View class.

For example, the Child Theme in Figure 1 presents the same UI components
as the
\href{https://github.com/liferay/liferay-screens/tree/master/ios/Framework/Core/Auth/LoginScreenlet}{Login
Screenlet's} Default Theme, but enlarges them for viewing on devices
with larger screens.

\begin{figure}
\centering
\includegraphics{./images/screens-ios-xcode-child-theme.png}
\caption{The UI components are enlarged in the example Child Theme's XIB
file.}
\end{figure}

You can follow these steps to create a Child Theme:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  In Xcode, create a new XIB file that's named after the Screenlet's
  View class and your Theme. By convention, an XIB file for a Screenlet
  with a View class named \emph{FooScreenletView} and a Theme named
  \emph{BarTheme} must be named \texttt{FooScreenletView\_barTheme.xib}.
  You can use content from the parent Theme's XIB file as a foundation
  for your new XIB file. In your new XIB, you can change the UI
  components' visual properties (e.g., their position and size). You
  mustn't change, however, the XIB file's custom class, outlet
  connection, or \texttt{restorationIdentifier}--these must match those
  of the parent's XIB file.
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** The XIB file name serves as the Theme's Xcode name. For example,
 the Theme in Figure 1 inherits from the Login Screenlet's Default Theme,
 which uses the View class `LoginView_default`. The new child Theme is named
 *Large* because it's purpose is to enlarge the Screenlet's UI components. In
 Xcode, it's assigned the Theme Name *large*. The XIB file is named
 `LoginView_large.xib`, after the Login Screenlet's View class and the
 Theme's Xcode name.
\end{verbatim}

\noindent\hrulefill

You can optionally
\href{/docs/7-1/tutorials/-/knowledge_base/t/packaging-ios-themes}{package}
your Theme and/or start
\href{/docs/7-1/tutorials/-/knowledge_base/t/using-themes-in-ios-screenlets}{using
it}.

\section{Creating an iOS Extended
Theme}\label{creating-an-ios-extended-theme}

An Extended Theme inherits another Theme's UI components and behavior,
but lets you add to or alter it by extending the parent Theme's View
class and creating a new XIB file. An Extended Theme's parent must be a
Full Theme. The
\href{https://github.com/liferay/liferay-screens/tree/master/ios/Framework/Themes/Flat7}{Flat7
Theme} is an Extended Theme.

These steps explain how to create an Extended Theme:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In Xcode, create a new XIB file named after the Screenlet's View class
  and your Theme. By convention, an XIB file for a Screenlet with a View
  class named \emph{FooScreenletView} and a Theme named \emph{BarTheme}
  must be named \texttt{FooScreenletView\_barTheme.xib}. You can use the
  XIB file of your parent Theme as a template. Build your UI changes in
  your new XIB file with Interface Builder.

  \begin{figure}
  \centering
  \includegraphics{./images/screens-ios-xcode-ext-theme.png}
  \caption{This example Extended Theme's XIB file extends the Login
  Portlet's UI and behavior with a switch that lets the user show or
  hide the password field value.}
  \end{figure}
\item
  Create a new View class that extends the parent Theme's View class.
  You should name this class after the XIB file you just created. You
  can add or override functionality of the parent Theme's View class.
\item
  Set your new View class as the custom class for your Theme's XIB file.
  If you added \texttt{@IBOutlet} or \texttt{@IBAction} actions, bind
  them to your class.
\end{enumerate}

Well done! You can optionally
\href{/docs/7-1/tutorials/-/knowledge_base/t/packaging-ios-themes}{package}
your Theme and/or start
\href{/docs/7-1/tutorials/-/knowledge_base/t/using-themes-in-ios-screenlets}{using
it}.

\section{Creating an iOS Full Theme}\label{creating-an-ios-full-theme}

A Full Theme implements unique behavior and appearance for a Screenlet,
without using a parent Theme. Its View class must inherit Screens's
\href{https://github.com/liferay/liferay-screens/blob/master/ios/Framework/Core/Base/BaseScreenletView.swift}{\texttt{BaseScreenletView}}
and conform to the Screenlet's View Model protocol. It must also specify
a new UI in an XIB file. As you create a Full Theme, you can refer to
the tutorial
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-ios-screenlets}{Creating
iOS Screenlets} to learn how to create these classes.

Follow these steps to create a Full Theme:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a new XIB file and use Interface Builder to build your UI. By
  convention, an XIB file for a Screenlet with a View class named
  \emph{FooScreenletView} and a Theme named \emph{BarTheme} must be
  named \texttt{FooScreenletView\_barTheme.xib}. You can use the XIB
  file from the Screenlet's default Theme as a template.

  \begin{figure}
  \centering
  \includegraphics{./images/screens-ios-xcode-full-theme.png}
  \caption{This Full Theme for the Login Screenlet, includes a text
  field for entering the user name, uses the UDID for the password, and
  adds a \emph{Sign In} button with the same
  \texttt{restorationIdentifier} as the Default Theme.}
  \end{figure}
\item
  Create a new View class for your Theme named after the XIB file you
  just created. As a template, you can use the View class of your
  Screenlet's Default Theme. Your new View class must inherit
  \href{https://github.com/liferay/liferay-screens/blob/master/ios/Framework/Core/Base/BaseScreenletView.swift}{\texttt{BaseScreenletView}}
  and conform to the Screenlet's \texttt{*ScreenletViewModel} protocol,
  implementing the corresponding getters and setters. It should also add
  all the \texttt{@IBOutlet} properties or \texttt{@IBAction} methods
  you need to bind your UI components.
\item
  Set your Theme's new View class as your XIB file's custom class and
  bind any \texttt{@IBOutlet} and \texttt{@IBAction} actions to your
  class.
\end{enumerate}

Now that your theme is finished, you can optionally
\href{/docs/7-1/tutorials/-/knowledge_base/t/packaging-ios-themes}{package}
and/or start
\href{/docs/7-1/tutorials/-/knowledge_base/t/using-themes-in-ios-screenlets}{using
it}. Note that a Full Theme can serve as a parent to a Child and
Extended Theme.

\section{Packaging iOS Themes}\label{packaging-ios-themes}

Once you've
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-ios-themes}{created
a Theme}, you can package it for
\href{/docs/7-1/tutorials/-/knowledge_base/t/using-themes-in-ios-screenlets}{installation
and use} with its Screenlet. Your Theme is a code library that you can
package using CocoaPods.

Follow the steps here to package your Theme for use with CocoaPods. Note
that it's important that you use the same names and identifiers
described in these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create an empty \emph{Cocoa Touch Framework} Xcode project.

  \begin{figure}
  \centering
  \includegraphics{./images/screens-ios-cocoa-touch-framework.png}
  \caption{Choose \emph{Cocoa Touch Framework} when creating a project
  for your Theme.}
  \end{figure}
\item
  Name your project \texttt{LiferayScreensThemeName}, replacing
  \texttt{Name} with your Theme's name. You can specify any name, but
  it's a best practice to use your Theme's Xcode name, capitalizing its
  first letter. The entire name becomes the Theme's CocoaPods name.
\item
  Configure Liferay Screens for CocoaPods, using the steps described in
  \href{/docs/7-1/tutorials/-/knowledge_base/t/preparing-ios-projects-for-liferay-screens}{Preparing
  iOS Projects for Liferay Screens}.
\item
  Prepare your Theme's classes and resources by making sure your classes
  compile successfully in Xcode and by explicitly specifying a valid
  module for the custom class--the grayed-out \emph{Current} default
  value only suggests a module.

  \begin{figure}
  \centering
  \includegraphics{./images/screens-ios-theme-custom-module-wrong.png}
  \caption{This XIB file's custom class's module is NOT specified.}
  \end{figure}

  In the following screenshot, the setting for the custom class is
  correct:

  \begin{figure}
  \centering
  \includegraphics{./images/screens-ios-theme-custom-module-right.png}
  \caption{The XIB file is bound to the custom class name, with the
  specified module.}
  \end{figure}
\item
  In your project's root folder, add a file named
  \texttt{LiferayScreensTheme-Name.podspec} (change \texttt{Name} to
  your Theme's CocoaPods name--the value you used to replace
  \texttt{Name} in step 2). Note: you must start your the
  \texttt{.podspec} file's name and the project's name with
  \texttt{LiferayScreens}.

  Add the following content to the file:

\begin{verbatim}
Pod::Spec.new do |s|
    s.name = 'LiferayScreensThemeName'
    s.version = '1.0'
    s.summary = 'Your theme description'
    s.source = {
        :git => 'https://your_repository_url.git',
        :tag => 'v1.0'
    }

    s.platform = :ios, '8.0'
    s.requires_arc = true

    s.source_files = 'Your/Relative/Folder/**/*.{h,m,swift}'
    s.resources = 'Your/Relative/Folder/**/*.{xib,png,plist,lproj}'

    s.dependency 'LiferayScreens'
end
\end{verbatim}

  Make the following substitutions in the \texttt{.podspec} file:

  \begin{itemize}
  \tightlist
  \item
    Replace \texttt{Name} in \texttt{LiferayScreensThemeName}, with your
    Theme's CocoaPods name--the value you used to replace \texttt{Name}
    in step 2.
  \item
    Replace \texttt{your\_repository\_url} with your repository's URL.
  \item
    Replace \texttt{Your/Relative/Folder/} with the path to your source
    and resource files.
  \end{itemize}
\item
  Commit your changes and push your project's branch to your Git
  repository.
\end{enumerate}

Your Theme is now available for other developers to pull from your Git
repository. You can, alternatively, publish your Theme as a public Pod.
For instructions, see the chapter \emph{Deploying a library} in the
\href{https://guides.cocoapods.org/making/getting-setup-with-trunk.html\#deploying-a-library}{official
CocoaPods guide}.

Developers can now use your Theme by adding the following line to their
app's \texttt{Podfile}; they must, of course, change \texttt{Name} to
the Theme's CocoaPods name and \texttt{your\_repository\_url} to your
repository's URL:

\begin{verbatim}
pod 'LiferayScreensThemeName', :git => 'https://your_repository_url.git'
\end{verbatim}

Nice work! Now you know how to package and distribute Screenlet Themes
with CocoaPods.

\textbf{Related Topics}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-themes-in-ios-screenlets}{Using
Themes in iOS Screenlets}

\href{/docs/7-1/tutorials/-/knowledge_base/t/architecture-of-liferay-screens-for-ios}{Architecture
of Liferay Screens for iOS}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-ios-themes}{Creating
iOS Themes}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-ios-screenlets}{Creating
iOS Screenlets}

\href{/docs/7-1/tutorials/-/knowledge_base/t/preparing-android-projects-for-liferay-screens}{Preparing
Android Projects for Liferay Screens}

\section{Supporting Multiple Themes in Your iOS
Screenlet}\label{supporting-multiple-themes-in-your-ios-screenlet}

Themes let you present the same Screenlet with a different look and
feel. For example, if you have multiple apps that use the same
Screenlet, you can use different Themes to match the Screenlet's
appearance to each app's style. Each Screenlet that comes with Liferay
Screens supports the use of multiple Themes. For your custom Screenlet
to support different Themes, however, it must contain a \emph{View
Model} protocol. A View Model abstracts the Theme used to display the
Screenlet, thus letting developers use other Themes. For example, note
that the Screenlet class's \texttt{createInteractor} method in
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-ios-screenlets}{the
Screenlet creation tutorials} accesses the View class
(\texttt{AddBookmarkView\_default}) directly when getting a reference to
the View class:

\begin{verbatim}
let view = self.screenletView as! AddBookmarkView_default
\end{verbatim}

This is all fine and well, except it hard codes the Theme defined by
\texttt{AddBookmarkView\_default}! To use a different Theme, you'd have
to rewrite this line of code to use that Theme's View class. This isn't
very flexible! Instead of making your Screenlet take expensive yoga
classes, you can abstract the Theme's View class via a View Model
protocol.

This tutorial shows you how to add a View Model to your Screenlet. The
Add Bookmark Screenlet created in
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-ios-screenlets}{the
Screenlet creation tutorials} is used as an example. Note that you can
also add a View Model while creating your Screenlet.

\subsection{Creating and Using a View
Model}\label{creating-and-using-a-view-model}

Follow these steps to add and use a View Model in your Screenlet:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a View Model protocol that defines your Screenlet's attributes.
  These attributes are the View class properties your Screenlet class
  uses. For example, the
  \href{https://github.com/liferay/liferay-screens/blob/develop/ios/Samples/Bookmark/AddBookmarkScreenlet/Basic/AddBookmarkScreenlet.swift}{Screenlet
  class in Add Bookmark Screenlet} uses the View class properties
  \texttt{title} and \texttt{URL}. Add Bookmark Screenlet's View Model
  protocol (\texttt{AddBookmarkViewModel}) must therefore define
  variables for these properties:

\begin{verbatim}
 import UIKit

 @objc protocol AddBookmarkViewModel {

     var URL: String? {get}

     var title: String? {get}

 }
\end{verbatim}
\item
  Conform your View class to your Screenlet's View Model protocol. Make
  sure to get/set all the protocol's properties. For example, here's Add
  Bookmark Screenlet's View Class (\texttt{AddBookmarkView\_default})
  conformed to \texttt{AddBookmarkViewModel}:

\begin{verbatim}
 import UIKit
 import LiferayScreens

 class AddBookmarkView_default: BaseScreenletView, AddBookmarkViewModel {

     @IBOutlet weak var URLTextField: UITextField?
     @IBOutlet weak var titleTextField: UITextField?

     var URL: String? {
         return URLTextField?.text
     }

     var title: String? {
         return titleTextField?.text
     }

 }
\end{verbatim}
\item
  Create and use a View Model reference in your Screenlet class. By
  retrieving data from this reference instead of a direct View class
  reference, you can use your Screenlet with other Themes. For example,
  here's the \texttt{AddBookmarkScreenlet} class with a
  \texttt{viewModel} property instead of a direct reference to
  \texttt{AddBookmarkView\_default}. This class's
  \texttt{createInteractor} method then uses this property to get the
  \texttt{title} and \texttt{URL} properties in the
  \texttt{AddBookmarkInteractor} constructor:

\begin{verbatim}
 ...
 //View Model reference
 var viewModel: AddBookmarkViewModel {
     return self.screenletView as! AddBookmarkViewModel
 }

 override public func createInteractor(name name: String?, sender: AnyObject?) -> Interactor? {

     let interactor = AddBookmarkInteractor(screenlet: self,
                                            folderId: folderId,
                                            title: viewModel.title!,
                                            url: viewModel.URL!)

     // Called when the Interactor finishes succesfully
     interactor.onSuccess = {
         let bookmarkName = interactor.resultBookmarkInfo!["name"] as! String
         print("Bookmark \"\(bookmarkName)\" saved!")
     }

     // Called when the Interactor finishes with an error
     interactor.onFailure = { _ in
         print("An error occurred saving the bookmark")
     }

     return interactor
 }
 ...
\end{verbatim}
\end{enumerate}

That's it! Now your Screenlet is ready to use other Themes that you
create for it. See the tutorials on
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-ios-themes}{creating
iOS Themes} for instructions on creating a Theme.

\subsection{Related Topics}\label{related-topics-252}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-ios-themes}{Creating
iOS Themes}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-ios-screenlets}{Creating
iOS Screenlets}

\href{/docs/7-1/tutorials/-/knowledge_base/t/architecture-of-liferay-screens-for-ios}{Architecture
of Liferay Screens for iOS}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-ios-list-screenlets}{Creating
iOS List Screenlets}

\section{Adding Screenlet Actions}\label{adding-screenlet-actions}

With multiple Interactors, it's possible for a Screenlet to have
multiple actions. You must create an Interactor class for each action.
For example, if your Screenlet needs to make two server calls, then you
need two Interactors: one for each call. Your Screenlet class's
\texttt{createInteractor} method must return an instance of each
Interactor. Also, recall that each action name is given by the
\texttt{restorationIdentifier} of the UI components that trigger them.
You should set this \texttt{restorationIdentifier} to a constant in your
Screenlet.

This tutorial walks you through the steps necessary to add an action to
your Screenlet, and trigger an action programmatically. As an example,
this tutorial uses the
\href{https://github.com/liferay/liferay-screens/tree/master/ios/Samples/Bookmark/AddBookmarkScreenlet/Advanced}{advanced
version of the sample Add Bookmark Screenlet}. This Screenlet is similar
to the sample Add Bookmark Screenlet created in
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-ios-screenlets}{the
Screenlet creation tutorials}. The advanced Add Bookmark Screenlet,
however, contains two actions:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add Bookmark: Adds a bookmark to the Bookmarks portlet in a Liferay
  DXP installation. This is the Screenlet's main action, created in
  \href{/docs/7-1/tutorials/-/knowledge_base/t/creating-ios-screenlets}{the
  Screenlet creation tutorials}.
\item
  Get Title: Retrieves the title from a bookmark URL entered by the
  user. This tutorial shows you how to implement this action.
\end{enumerate}

Note that this tutorial doesn't explain Screenlet creation in general.
Before proceeding, make sure you've read
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-ios-screenlets}{the
Screenlet creation tutorials}. And without any further ado, it's time to
implement your Screenlet's action!

\subsection{Implementing Your Action}\label{implementing-your-action}

Use the following steps to add an action to your your Screenlet:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a constant in your Screenlet class for each of your Screenlet's
  actions. For example, here are the constants in Add Bookmark
  Screenlet's Screenlet class (\texttt{AddBookmarkScreenlet}):

\begin{verbatim}
 static let AddBookmarkAction = "add-bookmark"
 static let GetTitleAction = "get-title"
\end{verbatim}
\item
  In your Theme's XIB file, add any new UI components that you need to
  perform the action. For example, Add Boookmark Screenlet's XIB file
  needs a new button for getting the URL's title:

  \begin{figure}
  \centering
  \includegraphics{./images/screens-ios-xcode-add-bookmark-advanced.png}
  \caption{The sample Add Bookmark Screenlet's XIB file contains a new
  button next to the \emph{Title} field for retrieving the URL's title.}
  \end{figure}
\item
  Wire the UI components in your XIB file to your View class. In your
  View class, you must also register the events you want to react to
  (e.g., button clicks). The
  \href{https://github.com/liferay/liferay-screens/blob/master/ios/Framework/Core/Base/BaseScreenletView.swift}{\texttt{BaseScreenletView}
  class} contains a set of \texttt{userAction} methods that you can call
  in your View class to perform actions programmatically. For example,
  it's possible to trigger Add Bookmark Screenlet's
  \texttt{GetTitleAction} automatically whenever the user leaves the
  \texttt{URLTextField}. Since \texttt{BaseScreenletView} is the
  delegate for all \texttt{UITextField} objects by default, this is done
  in the View class (\texttt{AddBookmarkView\_default}) by implementing
  the
  \href{https://developer.apple.com/reference/uikit/uitextfielddelegate/1619591-textfielddidendediting}{\texttt{textFieldDidEndEditing}
  method} to call the \texttt{userAction} method with the action name:

\begin{verbatim}
 func textFieldDidEndEditing(textField: UITextField) {
     if textField == URLTextField {
         userAction(name: AddBookmarkScreenlet.GetTitleAction)
     }
 }
\end{verbatim}
\item
  Update your View class or View Model protocol to account for the new
  action. For example, Add Bookmark Screenlet contains a View Model
  (\texttt{AddBookmarkViewModel}) so it can
  \href{/docs/7-1/tutorials/-/knowledge_base/t/supporting-multiple-themes-in-your-ios-screenlet}{support
  multiple Themes}. This View Model must allow the new action to set its
  \texttt{title} variable:

\begin{verbatim}
 import UIKit

 @objc protocol AddBookmarkViewModel {
     var URL: String? {get}
     var title: String? {set get}
 }
\end{verbatim}
\item
  If your Screenlet uses a View Model, conform your View class to the
  updated View Model. For example, the \texttt{title} variable in Add
  Bookmark Screenlet's View class (\texttt{AddBookmarkView\_default})
  must implement the setter from the previous step:

\begin{verbatim}
 var title: String? {
     get {
         return titleTextField?.text
     }
     set {
         self.titleTextField?.text = newValue
     }
 }
\end{verbatim}
\item
  Create a new Interactor class for the new action. To do this, use the
  same steps detailed in the
  \href{/docs/7-1/tutorials/-/knowledge_base/t/creating-the-ios-screenlets-interactor}{Screenlet
  creation tutorial}. For example, here's the Interactor class for Add
  Bookmark Screenlet's Get Title action:

\begin{verbatim}
 import UIKit
 import LiferayScreens


 public class GetWebTitleInteractor: Interactor {

     public var resultTitle: String?

     var url: String

     //MARK: Initializer

     public init(screenlet: BaseScreenlet, url: String) {
         self.url = url
         super.init(screenlet: screenlet)
     }

     override public func start() -> Bool {
         if let URL = NSURL(string: url) {

             // Use the NSURLSession class to retrieve the HTML
             NSURLSession.sharedSession().dataTaskWithURL(URL) {
                     (data, response, error) in

                 if let errorValue = error {
                     self.callOnFailure(errorValue)
                 }
                 else {
                     if let data = data, html = NSString(data: data, encoding: NSUTF8StringEncoding) {
                         self.resultTitle = self.parseTitle(html)
                     }

                     self.callOnSuccess()
                 }
             }.resume()

             return true
         }

         return false
     }

     // Parse the title from a webpage HTML
     private func parseTitle(html: NSString) -> String {
         let range1 = html.rangeOfString("<title>")
         let range2 = html.rangeOfString("</title>")

         let start = range1.location + range1.length

         return html.substringWithRange(NSMakeRange(start, range2.location - start))
     }

 }
\end{verbatim}
\item
  Update your Screenlet class's \texttt{createInteractor} method so it
  returns the correct Interactor for each action. For example, the
  \texttt{createInteractor} method in Add Bookmark Screenlet's Screenlet
  class (\texttt{AddBookmarkScreenlet}) contains a \texttt{switch}
  statement that returns an \texttt{AddBookmarkInteractor} or
  \texttt{GetWebTitleInteractor} instance when the Add Bookmark or Get
  Title action is called, respectively. Note that the
  \texttt{createAddBookmarkInteractor()} and
  \texttt{createGetTitleInteractor()} methods create these instances.
  Although you don't have to create your Interactor instances in
  separate methods, doing so leads to cleaner code:

\begin{verbatim}
 ... 
 override public func createInteractor(name name: String, sender: AnyObject?) 
     -> Interactor? {
         switch name {
         case AddBookmarkScreenlet.AddBookmarkAction:
             return createAddBookmarkInteractor()
         case AddBookmarkScreenlet.GetTitleAction:
             return createGetTitleInteractor()
         default:
             return nil
         }
     }

 private func createAddBookmarkInteractor() -> Interactor {
     let interactor = AddBookmarkInteractor(screenlet: self,
                                            folderId: folderId,
                                            title: viewModel.title!,
                                            url: viewModel.URL!)

     // Called when the Interactor finishes succesfully
     interactor.onSuccess = {
         let bookmarkName = interactor.resultBookmarkInfo!["name"] as! String
         print("Bookmark \"\(bookmarkName)\" saved!")
     }

     // Called when the Interactor finishes with an error
     interactor.onFailure = { _ in
         print("An error occurred saving the bookmark")
     }

     return interactor
 }

 private func createGetTitleInteractor() -> Interactor {
     let interactor = GetWebTitleInteractor(screenlet: self, url: viewModel.URL!)

     // Called when the Interactor finishes succesfully
     interactor.onSuccess = {
         let title = interactor.resultTitle
         self.viewModel.title = title
     }

     // Called when the Interactor finishes with an error
     interactor.onFailure = { _ in
         print("An error occurred retrieving the title")
     }

     return interactor
 }
 ...
\end{verbatim}
\end{enumerate}

Great! Now you know how to support multiple actions in your Screenlets.
The next section shows you how to trigger your actions programmatically.

\subsection{Related Topics}\label{related-topics-253}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-ios-screenlets}{Creating
iOS Screenlets}

\href{/docs/7-1/tutorials/-/knowledge_base/t/create-and-use-a-connector-with-your-screenlet}{Create
and Use a Connector with Your Screenlet}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-ios-list-screenlets}{Creating
iOS List Screenlets}

\href{/docs/7-1/tutorials/-/knowledge_base/t/architecture-of-liferay-screens-for-ios}{Architecture
of Liferay Screens for iOS}

\section{Create and Use a Connector with Your
Screenlet}\label{create-and-use-a-connector-with-your-screenlet}

In Liferay Screens, a Connector is a class that interacts asynchronously
with local and remote data sources and Liferay instances. Recall that
callbacks also make asynchronous service calls. So why bother with a
Connector? Connectors provide a layer of abstraction by making your
service call outside your Interactor. For example,
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-the-ios-screenlets-interactor}{the
Interactor in the Screenlet creation tutorial} makes the server call and
and processes its results via \texttt{LRCallback}. This Screenlet could
instead make its server call in a separate Connector class, leaving the
Interactor to instantiate the Connector and receive its results.
Connectors also let you validate your Screenlet's data. For more
information on Connectors, see the
\href{/docs/7-1/tutorials/-/knowledge_base/t/architecture-of-liferay-screens-for-ios}{tutorial
on the architecture of Liferay Screens for iOS}.

This tutorial walks you through the steps required to create and use a
Connector with your Screenlets, using the
\href{https://github.com/liferay/liferay-screens/tree/master/ios/Samples/Bookmark/AddBookmarkScreenlet/Advanced}{advanced
version of the sample Add Bookmark Screenlet} as an example. This
Screenlet contains two actions:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add Bookmark: Adds a bookmark to the Bookmarks portlet in a Liferay
  DXP installation. This tutorial shows you how to create and use a
  Connector for this action.
\item
  Get Title: Retrieves the title from a bookmark URL entered by the
  user. This tutorial shows you how to use a pre-existing Connector with
  this action.
\end{enumerate}

Before proceeding, make sure you've read
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-ios-screenlets}{the
Screenlet creation tutorial}. First, you'll learn how to create your
Connector.

\subsection{Creating Connectors}\label{creating-connectors}

When you create your Connector class, be sure to follow the
\href{/docs/7-1/tutorials/-/knowledge_base/t/ios-best-practices\#naming-conventions}{naming
convention} specified in the best practices tutorial.

Use the following steps to implement your Connector class:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create your Connector class by extending the
  \href{https://github.com/liferay/liferay-screens/blob/master/ios/Framework/Core/Base/BaseConnectors/ServerConnector.swift}{\texttt{ServerConnector}
  class}. For example, here's the class declaration for Add Bookmark
  Screenlet's Connector class, \texttt{AddBookmarkLiferayConnector}:

\begin{verbatim}
public class AddBookmarkLiferayConnector: ServerConnector {
    ...
}
\end{verbatim}
\item
  Add the properties needed to call the Mobile SDK service, then create
  an initializer that sets those properties. For example,
  \texttt{AddBookmarkLiferayConnector} needs properties for the
  bookmark's folder ID, title, and URL. It also needs an initializer to
  set those properties:

\begin{verbatim}
public let folderId: Int64
public let title: String
public let url: String

public init(folderId: Int64, title: String, url: String) {
    self.folderId = folderId
    self.title = title
    self.url = url
    super.init()
}
\end{verbatim}
\item
  If you want to validate any of your Screenlet's properties, override
  the \texttt{validateData} method to implement validation for those
  properties. You can use the
  \href{https://github.com/liferay/liferay-screens/blob/develop/ios/Framework/Core/Extensions/NSError\%2BScreens.swift}{\texttt{ValidationError}
  class} to encapsulate the errors. For example, the following
  \texttt{validateData} implementation in
  \texttt{AddBookmarkLiferayConnector} ensures that \texttt{folderId} is
  greater than \texttt{0}, and \texttt{title} and \texttt{url} contain
  values. This method also uses \texttt{ValidationError} to represent
  the error:

\begin{verbatim}
override public func validateData() -> ValidationError? {
    let error = super.validateData()

    if error == nil {

        if folderId <= 0 {
            return ValidationError("Undefined folderId")
        }

        if title.isEmpty {
            return ValidationError("Title cannot be empty")
        }

        if url.isEmpty {
            return ValidationError("URL cannot be empty")
        }
    }

    return error
}
\end{verbatim}
\item
  Override the \texttt{doRun} method to call the Mobile SDK service you
  need to call. This method should retrieve the result from the service
  and store it in a public property. Also be sure to handle errors and
  empty results. For example, the following code defines the
  \texttt{resultBookmarkInfo} property for storing the service's results
  retrieved in the \texttt{doRun} method. Note that this method's
  service call is identical to the one in the
  \texttt{AddBookmarkInteractor} class's \texttt{start} method in the
  \href{/docs/7-1/tutorials/-/knowledge_base/t/creating-ios-screenlets}{Screenlet
  creation tutorial}. The \texttt{doRun} method, however, takes the
  additional step of saving the result to the
  \texttt{resultBookmarkInfo} property. Also note that this
  \texttt{doRun} method handles errors as \texttt{NSError} objects:

\begin{verbatim}
public var resultBookmarkInfo: [String:AnyObject]?

override public func doRun(session session: LRSession) {

    let service = LRBookmarksEntryService_v7(session: session)

    do {
        let result = try service.addEntryWithGroupId(LiferayServerContext.groupId,
                                                     folderId: folderId,
                                                     name: title,
                                                     url: url,
                                                     description: "Added from Liferay Screens",
                                                     serviceContext: nil)

        if let result = result as? [String: AnyObject] {
            resultBookmarkInfo = result
            lastError = nil
        }
        else {
            lastError = NSError.errorWithCause(.InvalidServerResponse)
            resultBookmarkInfo = nil
        }
    }
    catch let error as NSError {
        lastError = error
        resultBookmarkInfo = nil
    }

}
\end{verbatim}
\end{enumerate}

Well done! Now you know how to create a Connector class. To see the
finished example \texttt{AddBookmarkLiferayConnector} class,
\href{https://github.com/liferay/liferay-screens/blob/master/ios/Samples/Bookmark/AddBookmarkScreenlet/Advanced/Connector/AddBookmarkLiferayConnector.swift}{click
here}.

\subsection{Using Connectors}\label{using-connectors}

To use a Connector, your Interactor class must extend the
\href{https://github.com/liferay/liferay-screens/blob/master/ios/Framework/Core/Base/BaseConnectors/ServerConnectorInteractor.swift}{\texttt{ServerConnectorInteractor}
class} or one of its following subclasses:

\begin{itemize}
\item
  \href{https://github.com/liferay/liferay-screens/blob/master/ios/Framework/Core/Base/BaseConnectors/ServerReadConnectorInteractor.swift}{\texttt{ServerReadConnectorInteractor}:}
  Your Interactor class should extend this class when implementing an
  action that retrieves information from a server or data source.
\item
  \href{https://github.com/liferay/liferay-screens/blob/master/ios/Framework/Core/Base/BaseConnectors/ServerWriteConnectorInteractor.swift}{\texttt{ServerWriteConnectorInteractor}:}
  Your Interactor class should extend this class when implementing an
  action that writes information to a server or data source.
\end{itemize}

When extending \texttt{ServerConnectorInteractor} or one of its
subclasses, your Interactor class only needs to override the
\texttt{createConnector} and \texttt{completedConnector} methods. These
methods create a Connector instance and recover the Connector's result,
respectively.

Follow these steps to use a Connector in your Interactor:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Set your Interactor class's superclass to
  \texttt{ServerConnectorInteractor} or one of its subclasses. You
  should also remove any code that conforms a callback protocol, if it
  exists. For example, Add Bookmark Screenlet's Interactor class
  (\texttt{AddBookmarkInteractor}) extends
  \texttt{ServerWriteConnectorInteractor} because it writes data to a
  Liferay DXP installation. At this point, your Interactor should
  contain only the properties and initializer that it requires:

\begin{verbatim}
 public class AddBookmarkInteractor: ServerWriteConnectorInteractor {

     public let folderId: Int64
     public let title: String
     public let url: String

     public var resultBookmark: Bookmark?

     //MARK: Initializer

     public init(screenlet: BaseScreenlet, folderId: Int64, title: String, url: String) {
         self.folderId = folderId
         self.title = title
         self.url = url
         super.init(screenlet: screenlet)
     }
 }
\end{verbatim}
\item
  Override the \texttt{createConnector} method to return an instance of
  your Connector. For example, the \texttt{createConnector} method in
  \texttt{AddBookmarkInteractor} returns an
  \texttt{AddBookmarkLiferayConnector} instance created with the
  \texttt{folderId}, \texttt{title}, and \texttt{url} properties:

\begin{verbatim}
 public override func createConnector() -> ServerConnector? {
     return AddBookmarkLiferayConnector(folderId: folderId, title: title, url: url)
 }
\end{verbatim}
\item
  Override the \texttt{completedConnector} method to get the result from
  the Connector and store it in the appropriate property. For example,
  the \texttt{completedConnector} method in
  \texttt{AddBookmarkInteractor} first casts its
  \texttt{ServerConnector} argument to
  \texttt{AddBookmarkLiferayConnector}. It then gets the Connector's
  \texttt{resultBookmarkInfo} property and sets it to the Interactor's
  \texttt{resultBookmark} property:

\begin{verbatim}
 override public func completedConnector(c: ServerConnector) {
     if let addCon = (c as? AddBookmarkLiferayConnector),
         bookmarkInfo = addCon.resultBookmarkInfo {
         self.resultBookmark = bookmarkInfo
     }
 }
\end{verbatim}
\end{enumerate}

That's it! To see the complete example \texttt{AddBookmarkInteractor},
\href{https://github.com/liferay/liferay-screens/blob/master/ios/Samples/Bookmark/AddBookmarkScreenlet/Advanced/Interactor/AddBookmarkInteractor.swift}{click
here}.

If your Screenlet uses multiple Interactors, follow the same steps to
use Connectors. Also, Screens provides
\href{https://github.com/liferay/liferay-screens/blob/master/ios/Framework/Core/Base/BaseConnectors/HttpConnector.swift}{the
ready-to-use \texttt{HttpConnector}} for interacting with non-Liferay
URL's. To use this Connector, set your Interactor to use
\texttt{HttpConnector}. For example, the Add Bookmark Screenlet action
that retrieves a URL's title doesn't interact with a Liferay DXP
installation; it retrieves the title directly from the URL. Because this
action's Interactor class (\texttt{GetWebTitleInteractor}) retrieves
data, it extends \texttt{ServerReadConnectorInteractor}. It also
overrides the \texttt{createConnector} and \texttt{completedConnector}
methods to use \texttt{HttpConnector}. Here's the complete
\texttt{GetWebTitleInteractor}:

\begin{verbatim}
import UIKit
import LiferayScreens

public class GetWebTitleInteractor: ServerReadConnectorInteractor {

    public let url: String?

    // title from the webpage
    public var resultTitle: String?

    //MARK: Initializer

    public init(screenlet: BaseScreenlet, url: String) {
        self.url = url
        super.init(screenlet: screenlet)
    }

    //MARK: ServerConnectorInteractor

    public override func createConnector() -> ServerConnector? {
        if let url = url, URL = NSURL(string: url) {
            return HttpConnector(url: URL)
        }

        return nil
    }

    override public func completedConnector(c: ServerConnector) {
        if let httpCon = (c as? HttpConnector), data = httpCon.resultData,
            html = NSString(data: data, encoding: NSUTF8StringEncoding) {
            self.resultTitle = parseTitle(html)
        }
    }

    //MARK: Private methods

    // Parse the title from the webpage's HTML
    private func parseTitle(html: NSString) -> String {
        let range1 = html.rangeOfString("<title>")
        let range2 = html.rangeOfString("</title>")

        let start = range1.location + range1.length

        return html.substringWithRange(NSMakeRange(start, range2.location - start))
    }

}
\end{verbatim}

Awesome! Now you know how to create and use Connectors in your
Screenlets.

\subsection{Related Topics}\label{related-topics-254}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-ios-screenlets}{Creating
iOS Screenlets}

\href{/docs/7-1/tutorials/-/knowledge_base/t/adding-screenlet-actions}{Adding
Screenlet Actions}

\href{/docs/7-1/tutorials/-/knowledge_base/t/architecture-of-liferay-screens-for-ios}{Architecture
of Liferay Screens for iOS}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-ios-list-screenlets}{Creating
iOS List Screenlets}

\section{Add a Screenlet Delegate}\label{add-a-screenlet-delegate}

Screenlet delegates let other classes respond to your Screenlet's
actions. For example,
\href{/docs/7-1/reference/-/knowledge_base/r/loginscreenlet-for-ios\#delegate}{Login
Screenlet's delegate} lets the app developer implement methods that
respond to login success or failure. Note that the
\href{/docs/7-1/reference/-/knowledge_base/r/screenlets-in-liferay-screens-for-ios}{reference
documentation} for each Screenlet that comes with Liferay Screens lists
the Screenlet's delegate methods.

You can also create a delegate for your own Screenlet. This tutorial
walks you through the steps required to do this, using code from
\href{https://github.com/liferay/liferay-screens/tree/master/ios/Samples/Bookmark/AddBookmarkScreenlet/Advanced}{the
advanced version of the sample Add Bookmark Screenlet} as an example.
All the example code in this tutorial resides in
\href{https://github.com/liferay/liferay-screens/blob/master/ios/Samples/Bookmark/AddBookmarkScreenlet/Advanced/AddBookmarkScreenlet.swift}{this
Screenlet's Screenlet class}. Also note that this sample Screenlet has
two actions: adding a bookmark to a Liferay instance's Bookmarks
portlet, and retrieving a bookmark's title from its URL. This tutorial
only details creating a delegate for adding a bookmark.

Follow these steps to add a delegate to your Screenlet:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Define a delegate protocol that extends the
  \href{https://github.com/liferay/liferay-screens/blob/master/ios/Framework/Core/Base/BaseScreenlet.swift}{\texttt{BaseScreenletDelegate}
  class}. In this protocol, define success and failure methods so the
  conforming class can respond to the server call's success and failure,
  respectively. As parameters, these methods should take a Screenlet
  instance and the success or failure object. For example, Add Bookmark
  Screenlet's delegate protocol (\texttt{AddBookmarkScreenletDelegate})
  defines the following success and failure methods:

\begin{verbatim}
 @objc public protocol AddBookmarkScreenletDelegate: BaseScreenletDelegate {

     optional func screenlet(screenlet: AddBookmarkScreenlet,
                         onBookmarkAdded bookmark: [String: AnyObject])

     optional func screenlet(screenlet: AddBookmarkScreenlet,
                         onAddBookmarkError error: NSError)

 }
\end{verbatim}

  Both take an \texttt{AddBookmarkScreenlet} instance as their first
  argument. For their second argument, the success method contains the
  bookmark added to the server, and the failure method contains the
  \texttt{NSError} object. Note that in this example, the methods are
  optional. This means that the delegate class doesn't have to implement
  them.
\item
  In your Screenlet class, add a property for your delegate. This
  property should return \texttt{BaseScreenlet}'s \texttt{delegate}
  property as an instance of your delegate. For example, the
  \texttt{addBookmarkDelegate} property in \texttt{AddBookmarkScreenlet}
  returns the \texttt{self.delegate} property as
  \texttt{AddBookmarkScreenletDelegate}:

\begin{verbatim}
 var addBookmarkDelegate: AddBookmarkScreenletDelegate? {
     return self.delegate as? AddBookmarkScreenletDelegate
 }
\end{verbatim}
\item
  Also in your Screenlet class, invoke the appropriate delegate methods
  in your Interactor's closures. For example, the
  \texttt{interactor.onSuccess} closure in \texttt{AddBookmarkScreenlet}
  calls the delegate method that responds when the Screenlet
  successfully adds a bookmark. The \texttt{interactor.onFailure}
  closure calls the delegate method that responds when the Screenlet
  fails to add a bookmark. Note that in this example, these closures are
  in the Screenlet class's Interactor method that adds a bookmark
  (\texttt{createAddBookmarkInteractor}). Be sure to call your delegate
  methods wherever the appropriate Interactor's closures are in your
  Screenlet class:

\begin{verbatim}
 private func createAddBookmarkInteractor() -> Interactor {
     let interactor = AddBookmarkInteractor(screenlet: self,
                                        folderId: folderId,
                                        title: viewModel.title!,
                                        url: viewModel.URL!)

     // Called when the Interactor finishes successfully
     interactor.onSuccess = {
         if let bookmark = interactor.resultBookmark {
             self.addBookmarkDelegate?.screenlet?(self, onBookmarkAdded: bookmark)
         }
     }

     // Called when the Interactor finishes with an error
     interactor.onFailure = { error in
         self.addBookmarkDelegate?.screenlet?(self, onAddBookmarkError: error)
     }

     return interactor
 }
\end{verbatim}
\end{enumerate}

Great! Now you know how to add a delegate to your Screenlets.

\textbf{Related Topics}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-ios-screenlets}{Creating
iOS Screenlets}

\href{/docs/7-1/tutorials/-/knowledge_base/t/adding-screenlet-actions}{Adding
Screenlet Actions}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-ios-list-screenlets}{Creating
iOS List Screenlets}

\href{/docs/7-1/tutorials/-/knowledge_base/t/architecture-of-liferay-screens-for-ios}{Architecture
of Liferay Screens for iOS}

\section{Using and Creating Progress
Presenters}\label{using-and-creating-progress-presenters}

Many apps display a progress indicator while performing an operation.
For example, you've likely seen the spinners in iOS apps that let you
know the app is performing some kind of work. For more information, see
\href{https://developer.apple.com/ios/human-interface-guidelines/ui-controls/progress-indicators/}{the
iOS Human Interface Guidelines article on Progress Indicators}.

You can display these in Screenlets by using classes that conform the
\href{https://github.com/liferay/liferay-screens/blob/master/ios/Framework/Core/Base/ProgressPresenter.swift}{\texttt{ProgressPresenter}
protocol}. Liferay Screens includes two such classes:

\begin{itemize}
\item
  \href{https://github.com/liferay/liferay-screens/blob/master/ios/Framework/Core/Base/MBProgressHUDPresenter.swift}{\texttt{MBProgressHUDPresenter}}:
  Shows a message with a spinner in the middle of the screen. Liferay
  Screens shows this presenter by default.
\item
  \href{https://github.com/liferay/liferay-screens/blob/master/ios/Framework/Core/Base/NetworkActivityIndicatorPresenter.swift}{\texttt{NetworkActivityIndicatorPresenter}}:
  Shows the progress using the iOS network activity indicator. This
  presenter doesn't support messages.
\end{itemize}

This tutorial shows you how to use and create progress presenters, using
code from the
\href{https://github.com/liferay/liferay-screens/tree/master/ios/Samples/Bookmark/AddBookmarkScreenlet/Advanced}{advanced
version of the sample Add Bookmark Screenlet} as an example. First,
you'll learn how to use progress presenters.

\subsection{Using Progress Presenters}\label{using-progress-presenters}

\href{https://github.com/liferay/liferay-screens/blob/master/ios/Framework/Core/Base/BaseScreenletView.swift}{The
\texttt{BaseScreenletView} class} contains the default progress
presenter functionality. To show a presenter other than the default
\texttt{MBProgressHUDPresenter}, your View class must therefore override
certain \texttt{BaseScreenletView} functionality. Follow these steps to
do this:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In your View class, override the \texttt{BaseScreenletView} method
  \texttt{createProgressPresenter} to return an instance of the desired
  presenter. For example, to use
  \texttt{NetworkActivityIndicatorPresenter} in the sample Add Bookmark
  Screenlet, you must override the \texttt{createProgressPresenter}
  method in \texttt{AddBookmarkView\_default} to return a
  \texttt{NetworkActivityIndicatorPresenter} instance:

\begin{verbatim}
 override func createProgressPresenter() -> ProgressPresenter {
     return NetworkActivityIndicatorPresenter()
 }
\end{verbatim}
\item
  In your View class, override the \texttt{BaseScreenletView} property
  \texttt{progressMessages} to return the messages you want to use in
  the presenter. If the presenter doesn't display messages, then return
  an empty string. The \texttt{progressMessages} property should return
  the messages as \texttt{{[}String\ :\ ProgressMessages{]}}, where
  \texttt{String} is the Screenlet's action name.
  \href{https://github.com/liferay/liferay-screens/blob/master/ios/Framework/Core/Base/ProgressPresenter.swift}{\texttt{ProgressMessages}
  is a type alias} representing a dictionary where the progress type is
  the key, and the actual message is the value. The three possible
  progress types correspond to the Screenlet action's status:
  \texttt{Working}, \texttt{Failure}, or \texttt{Success}. The
  \texttt{progressMessages} property therefore lets the presenter
  display the appropriate message for the Screenlet action's current
  status.

  For example, the following code overrides the
  \texttt{progressMessages} property in Add Bookmark Screenlet's View
  class (\texttt{AddBookmarkView\_default}). For each Screenlet action
  (\texttt{AddBookmarkAction} and \texttt{GetTitleAction}), a message
  (\texttt{NoProgressMessage}) is assigned to the Screenlet operation's
  \texttt{Working} status. Since \texttt{NoProgressMessage} is an alias
  for an empty string, this tells the presenter to display no message
  when the Screenlet attempts to add a bookmark or get a title. Note,
  however, that the presenter still displays its progress indicator:

\begin{verbatim}
 override var progressMessages: [String : ProgressMessages] {
     return [
         AddBookmarkScreenlet.AddBookmarkAction : [.Working: NoProgressMessage],
         AddBookmarkScreenlet.GetTitleAction : [.Working: NoProgressMessage],
     ]
 }
\end{verbatim}

  To display a message, replace \texttt{NoProgressMessage} with your
  message. For example, the following code defines separate messages for
  \texttt{Working}, \texttt{Success}, and \texttt{Failure}:

\begin{verbatim}
 override var progressMessages: [String : ProgressMessages] {
     return [
         AddBookmarkScreenlet.AddBookmarkAction : [
             .Working: "Saving bookmark...",
             .Success: "Bookmark saved!",
             .Failure: "An error occurred saving the bookmark"
         ],
         AddBookmarkScreenlet.GetTitleAction : [
             .Working: "Getting site title...",
             .Failure: "An error occurred retrieving the title"
         ],
     ]
 }
\end{verbatim}
\end{enumerate}

Great! Now you know how to use progress presenters. Next, you'll learn
how to create your own.

\subsection{Creating Progress
Presenters}\label{creating-progress-presenters}

Creating your own progress presenter isn't as complicated as you might
think. Recall that a presenter in Liferay Screens is a class that
conforms the
\href{https://github.com/liferay/liferay-screens/blob/master/ios/Framework/Core/Base/ProgressPresenter.swift}{\texttt{ProgressPresenter}
protocol}. You can create your presenter by conforming this protocol
from scratch, or by extending one of Screens's existing presenters that
already conform this protocol (\texttt{MBProgressHUDPresenter} or
\texttt{NetworkActivityIndicatorPresenter}). In most cases, extending
\texttt{MBProgressHUDPresenter} is sufficient.

For example,
\href{https://github.com/liferay/liferay-screens/blob/master/ios/Samples/Bookmark/AddBookmarkScreenlet/Advanced/ProgressPresenter/AddBookmarkProgressPresenter.swift}{Add
Bookmark Screenlet's \texttt{AddBookmarkProgressPresenter}} extends
\texttt{MBProgressHUDPresenter} to display a different progress
indicator for the Screenlet's get title action. Use the following steps
to create a progress presenter that extends from an existing presenter.
As an example, these steps extend \texttt{MBProgressHUDPresenter} to add
a progress indicator for the get title button:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In your View's XIB file, add the activity indicator you want to use.
  For example, the XIB file in Add Bookmark Screenlet contains an iOS
  \texttt{UIActivityIndicatorView} over the get title button:

  \begin{figure}
  \centering
  \includegraphics{./images/screens-ios-xcode-add-bookmark-advanced-progress.png}
  \caption{The updated Add Bookmark Screenlet's XIB file contains a new
  activity indicator over the get title button.}
  \end{figure}
\item
  In your View class, create an outlet for the XIB's new activity
  indicator. For example, Add Bookmark Screenlet's View class
  (\texttt{AddBookmarkView\_default}) contains an \texttt{@IBOutlet} for
  the \texttt{UIActivityIndicatorView} from the XIB:

\begin{verbatim}
 @IBOutlet weak var activityIndicatorView: UIActivityIndicatorView?
\end{verbatim}
\end{enumerate}

Now you must create your presenter class. You'll do this here by
extending an existing presenter class. Use the following steps to do
this:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Extend the existing presenter class you want to base your presenter
  on. Your presenter class must contain properties for your presenter's
  activity indicator and any other UI components. It must also contain
  an initializer that sets these properties. For example,
  \texttt{AddBookmarkProgressPresenter} extends
  \texttt{MBProgressHUDPresenter} and contains properties for the get
  title button and \texttt{UIActivityIndicatorView}. Its initializer
  sets these properties:

\begin{verbatim}
 public class AddBookmarkProgressPresenter: MBProgressHUDPresenter {

     let button: UIButton?

     let activityIndicator: UIActivityIndicatorView?

     public init(button: UIButton?, activityIndicator: UIActivityIndicatorView?) {
         self.button = button
         self.activityIndicator = activityIndicator
         super.init()
     }
     ...
\end{verbatim}
\item
  Implement your presenter's behavior by overriding the appropriate
  methods from the presenter class that you're extending. For example,
  \texttt{AddBookmarkProgressPresenter} overrides
  \texttt{MBProgressHUDPresenter}'s \texttt{showHUDInView} and
  \texttt{hideHUDFromView} methods. The overridden
  \texttt{showHUDInView} method hides the button and starts animating
  the activity indicator. The overridden \texttt{hideHUDFromView} method
  stops this animation and restores the button:

\begin{verbatim}
 public override func showHUDInView(view: UIView, message: String?, 
     forInteractor interactor: Interactor) {
         guard interactor is GetWebTitleInteractor else {
             return super.showHUDInView(view, message: message, 
                 forInteractor: interactor)
         }

         button?.hidden = true
         activityIndicator?.startAnimating()
 }

 public override func hideHUDFromView(view: UIView?, message: String?, 
     forInteractor interactor: Interactor, withError error: NSError?) {
         guard interactor is GetWebTitleInteractor else {
             return super.hideHUDFromView(view, message: message, 
                 forInteractor: interactor, withError: error)
         }

         activityIndicator?.stopAnimating()
         button?.hidden = false
     }

 }
\end{verbatim}
\end{enumerate}

Great, that's it! Now you can use your presenter the same way you would
any other.

\subsection{Related Topics}\label{related-topics-255}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-ios-screenlets}{Creating
iOS Screenlets}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-ios-list-screenlets}{Creating
iOS List Screenlets}

\href{/docs/7-1/tutorials/-/knowledge_base/t/architecture-of-liferay-screens-for-ios}{Architecture
of Liferay Screens for iOS}

\section{Creating and Using Your Screenlet's Model
Class}\label{creating-and-using-your-screenlets-model-class}

Liferay Screens typically receives entities from a Liferay instance as
\texttt{{[}String:AnyObject{]}}, where \texttt{String} is the entity's
attribute and \texttt{AnyObject} is the attribute's value. Although you
can use these dictionary objects throughout your Screenlet, it's often
easier to create a \emph{model class} that converts each into an object
that represents the corresponding Liferay entity. This is especially
convenient for complex entities composed of many attribute-value pairs.
Note that Liferay Screens already provides
\href{https://github.com/liferay/liferay-screens/tree/master/ios/Framework/Core/Models}{several
model classes} for you.

At this point, you might be saying, ``Ugh! I have complex entities and
Screens doesn't provide a model class for them! I'm just going to give
up and watch football.'' Fret not! Although we'd never come between you
and football, creating and using your own model class is
straightforward.

Using the
\href{https://github.com/liferay/liferay-screens/tree/master/ios/Samples/Bookmark/AddBookmarkScreenlet/Advanced}{advanced
version of the sample Add Bookmark Screenlet} as an example, this
tutorial shows you how to create and use a model class in your
Screenlet. First, you'll create your model class.

\subsection{Creating Your Model Class}\label{creating-your-model-class}

Your model class must contain all the code necessary to transform each
\texttt{{[}String:AnyObject{]}} that comes back from the server into a
model object that represents the corresponding Liferay entity. This
includes a constant for holding each \texttt{{[}String:AnyObject{]}},
and initializer that sets this constant, and a public property for each
attribute value.

For example, the sample Add Bookmark Screenlet adds a bookmark to a
Liferay instance's Bookmarks portlet. Since the Mobile SDK service
method that adds the bookmark also returns it as
\texttt{{[}String:AnyObject{]}}, the Screenlet can convert it into an
object that represents bookmarks. It does so with its
\href{https://github.com/liferay/liferay-screens/blob/master/ios/Samples/Bookmark/AddBookmarkScreenlet/Advanced/Model/Bookmark.swift}{\texttt{Bookmark}
model class}. This class extends \texttt{NSObject} and sets the
\texttt{{[}String:AnyObject{]}} to the \texttt{attributes} constant via
the initializer. This class also defines computed properties that return
the attribute values for each bookmark's name and URL:

\begin{verbatim}
@objc public class Bookmark : NSObject {

    public let attributes: [String:AnyObject]

    public var name: String {
        return attributes["name"] as! String
    }

    override public var description: String {
        return attributes["description"] as! String
    }

    public var url: String {
        return attributes["url"] as! String
    }

    public init(attributes: [String:AnyObject]) {
        self.attributes = attributes
    }

}
\end{verbatim}

Next, you'll put your model class to work.

\subsection{Using Your Model Class}\label{using-your-model-class}

Now that your model class exists, you can use model objects anywhere
your Screenlet handles results. Exactly where depends on what Screenlet
components your Screenlet uses. For example, Add Bookmark Screenlet's
Connector, Interactor, delegate, and Screenlet class all handle the
Screenlet's results. The steps here therefore show you how to use model
objects in each of these components. Note, however, that your Screenlet
may lack a Connector or delegate: these components are optional.
Variations on these steps are therefore noted where applicable.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create model objects where the \texttt{{[}String:\ AnyObject{]}}
  results originate. For example, the \texttt{{[}String:\ AnyObject{]}}
  results in Add Bookmark Screenlet originate in the Connector.
  Therefore, this is where the Screenlet creates \texttt{Bookmark}
  objects. The following code in the Screenlet's Connector
  (\texttt{AddBookmarkLiferayConnector}) does this. The \texttt{if}
  statement following the service call casts the results to
  \texttt{{[}String:\ AnyObject{]}}, calls the \texttt{Bookmark}
  initializer with those results, and stores the resulting
  \texttt{Bookmark} object to the public \texttt{resultBookmarkInfo}
  variable. Note that this is only the code that makes the service call
  and creates the \texttt{Bookmark} object.
  \href{https://github.com/liferay/liferay-screens/blob/master/ios/Samples/Bookmark/AddBookmarkScreenlet/Advanced/Connector/AddBookmarkLiferayConnector.swift}{Click
  here to see the complete \texttt{AddBookmarkLiferayConnector} class}:

\begin{verbatim}
 ...
 // Public property for the results
 public var resultBookmarkInfo: Bookmark?

 ...

 override public func doRun(session session: LRSession) {
     let service = LRBookmarksEntryService_v7(session: session)

     do {
         let result = try service.addEntryWithGroupId(LiferayServerContext.groupId,
                                                      folderId: folderId,
                                                      name: title,
                                                      url: url,
                                                      description: "Added from Liferay Screens",
                                                      serviceContext: nil)

         // Creates Bookmark objects from the service call's results
         if let result = result as? [String: AnyObject] {
             resultBookmarkInfo = Bookmark(attributes: result)
             lastError = nil
         }
         ...
     }
     ...
 }
\end{verbatim}

  If your Screenlet doesn't have Connector, then your Interactor's
  \texttt{start} method makes your server call and handles its results.
  Otherwise, the process for creating a \texttt{Bookmark} object from
  \texttt{{[}String:\ AnyObject{]}} is the same.
\item
  Handle your model objects in your Screenlet's Interactor. The
  Interactor processes your Screenlet's results, so it must also handle
  your model objects. If your Screenlet doesn't use a Connector, then
  you already did this in your Interactor's \texttt{start} method as
  mentioned at the end of the previous step. If your Screenlet uses a
  Connector, however, then this happens in your Interactor's
  \texttt{completedConnector} method. For example, the
  \texttt{completedConnector} method in Add Bookmark Screenlet's
  Interactor (\texttt{AddBookmarkInteractor}) retrieves the
  \texttt{Bookmark} via the Connector's \texttt{resultBookmarkInfo}
  variable. This method then assigns the \texttt{Bookmark} to the
  Interactor's public \texttt{resultBookmark} variable. Note that this
  is only the code that handles \texttt{Bookmark} objects.
  \href{https://github.com/liferay/liferay-screens/blob/master/ios/Samples/Bookmark/AddBookmarkScreenlet/Advanced/Interactor/AddBookmarkInteractor.swift}{Click
  here to see the complete \texttt{AddBookmarkInteractor} class}:

\begin{verbatim}
 ...
 // Public property for the results
 public var resultBookmark: Bookmark?

 ...

 // The completedConnector method gets the results from the Connector
 override public func completedConnector(c: ServerConnector) { 
     if let addCon = (c as? AddBookmarkLiferayConnector), 
         bookmark = addCon.resultBookmarkInfo { 
             self.resultBookmark = bookmark 
         }
 }
\end{verbatim}
\item
  If your Screenlet uses a delegate, your delegate protocol must account
  for your model objects. Skip this step if you don't have a delegate.
  For example, Add Bookmark Screenlet's delegate
  (\texttt{AddBookmarkScreenletDelegate}) must communicate
  \texttt{Bookmark} objects. The delegate's first method does this via
  its second argument:

\begin{verbatim}
 @objc public protocol AddBookmarkScreenletDelegate: BaseScreenletDelegate {

     optional func screenlet(screenlet: AddBookmarkScreenlet,
                     onBookmarkAdded bookmark: Bookmark)

     optional func screenlet(screenlet: AddBookmarkScreenlet,
                     onAddBookmarkError error: NSError)

 }
\end{verbatim}
\item
  Get the model object from the Interactor in your Screenlet class's
  \texttt{interactor.onSuccess} closure. You can then use the model
  object however you wish. For example, the
  \texttt{interactor.onSuccess} closure in Add Bookmark Screenlet's
  Screenlet class (\texttt{AddBookmarkScreenlet}) retrieves the
  \texttt{Bookmark} from the Interactor's \texttt{resultBookmark}
  property. It then handles the \texttt{Bookmark} via the delegate. Note
  that in this example, the closure is in the Screenlet class's
  Interactor method that adds a bookmark
  (\texttt{createAddBookmarkInteractor}). Be sure to get your model
  object wherever the \texttt{interactor.onSuccess} closure is in your
  Screenlet class.
  \href{https://github.com/liferay/liferay-screens/blob/master/ios/Samples/Bookmark/AddBookmarkScreenlet/Advanced/AddBookmarkScreenlet.swift}{Click
  here to see the complete \texttt{AddBookmarkScreenlet}}:

\begin{verbatim}
 ...
 private func createAddBookmarkInteractor() -> Interactor {
     let interactor = AddBookmarkInteractor(screenlet: self,
                                        folderId: folderId,
                                        title: viewModel.title!,
                                        url: viewModel.URL!)

     // Called when the Interactor finishes successfully
     interactor.onSuccess = {
         if let bookmark = interactor.resultBookmark {
             self.addBookmarkDelegate?.screenlet?(self, onBookmarkAdded: bookmark)
         }
     }

     // Called when the Interactor finishes with an error
     interactor.onFailure = { error in
         self.addBookmarkDelegate?.screenlet?(self, onAddBookmarkError: error)
     }

     return interactor
 }
 ...
\end{verbatim}
\end{enumerate}

Awesome! Now you know how to create and use a model class in your
Screenlet.

\subsection{Related Topics}\label{related-topics-256}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-ios-screenlets}{Creating
iOS Screenlets}

\href{/docs/7-1/tutorials/-/knowledge_base/t/adding-screenlet-actions}{Adding
Screenlet Actions}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-ios-list-screenlets}{Creating
iOS List Screenlets}

\href{/docs/7-1/tutorials/-/knowledge_base/t/architecture-of-liferay-screens-for-ios}{Architecture
of Liferay Screens for iOS}

\section{Using Custom Cells with List
Screenlets}\label{using-custom-cells-with-list-screenlets}

In most list Screenlets, including those that come with Liferay Screens,
the Default Theme uses the default cells in
\href{https://developer.apple.com/reference/uikit/uitableview}{iOS's
\texttt{UITableView}} to show the list.
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-the-ios-list-screenlets-theme}{The
Theme creation steps} in the list Screenlet creation tutorial also
instruct you to use these cells. You can, however, use custom cells to
tailor the list to your needs. To do this, you must
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-an-ios-extended-theme}{create
an extended Theme} from a Theme that uses \texttt{UITableView}'s default
cells. This usually means extending a list Screenlet's Default theme.
This tutorial shows you how to create such an extended Theme that
contains a custom cell for your list Screenlet. As an example, this
tutorial uses code from the sample Bookmark List Screenlet's Custom
Theme. You can refer to this Theme's finished code
\href{https://github.com/liferay/liferay-screens/tree/master/ios/Samples/Bookmark/BookmarkListScreenlet/Themes/TableView}{here
in GitHub} at any time.

Note that besides creating your custom cell, this tutorial follows the
same basic steps as the
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-an-ios-extended-theme}{Theme
creation tutorial for creating an extended Theme}. For example, you must
still determine where to create your Theme, and create your Theme's XIB
and View class.

First, you'll create your Theme's custom cell.

\subsection{Creating Your Custom Cell}\label{creating-your-custom-cell}

Once you
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-ios-themes\#determining-your-themes-location}{decide
where to create your Theme}, you can get started. First, create your
custom cell's XIB file and its companion class. Name them according to
\href{/docs/7-1/tutorials/-/knowledge_base/t/ios-best-practices\#naming-conventions}{the
naming conventions in the best practices tutorial}. After defining your
cell's UI in the XIB, create as many outlets and actions as you need in
its companion class. Also be sure to assign this class as the XIB's
custom class in Interface Builder. Note that if you want to use
different layouts for different rows, you must create an XIB file and
companion class for each.

For example, the following screenshot shows the XIB file
\texttt{BookmarkCell\_default-custom.xib} for Bookmark List Screenlet's
custom cell. This cell must show a bookmark's name and URL, so it
contains two labels.

\begin{figure}
\centering
\includegraphics{./images/screens-ios-xcode-custom-cell.png}
\caption{The XIB file for Bookmark List Screenlet's custom cell.}
\end{figure}

This XIB's custom class, \texttt{BookmarkCell\_default\_custom},
contains an outlet for each label. The \texttt{bookmark} variable also
contains a \texttt{didSet} observer that sets the bookmark's name and
URL to the respective label:

\begin{verbatim}
import UIKit

class BookmarkCell_default_custom: UITableViewCell {

    @IBOutlet weak var nameLabel: UILabel?
    @IBOutlet weak var urlLabel: UILabel?

    var bookmark: Bookmark? {
        didSet {
            nameLabel?.text = bookmark?.name
            urlLabel?.text = bookmark?.url
        }
    }

}
\end{verbatim}

Great! Now you have your custom cell. Next, you'll create the rest of
your Theme.

\subsection{Creating Your Theme's XIB and View
Class}\label{creating-your-themes-xib-and-view-class}

Now you're ready to create your Theme's XIB file and View class. Create
your XIB by copying the parent Theme's XIB and making any changes you
need. You may not need to make any changes besides the file name and
custom class name. For example, the custom cell is the only difference
between Bookmark List Screenlet's Custom and Default Themes. These
Themes' XIB files (\texttt{BookmarkListView\_default-custom.xib} and
\texttt{BookmarkListView\_default.xib}) are therefore identical besides
their name and custom class; the size and position of their UI
components are the same.

Now create your View class by extending the parent Theme's View class.
You should also add a string constant to serve as the cell ID. In a
moment, you'll use this constant to register your custom cell. For
example, the View class in Bookmark List Screenlet's Custom Theme
(\texttt{BookmarkListView\_default\_custom}) extends the Default Theme's
View class (\texttt{BookmarkListView\_default}) and defines the string
constant \texttt{BookmarkCellId}:

\begin{verbatim}
public class BookmarkListView_default_custom: BookmarkListView_default {

    let BookmarkCellId = "bookmarkCell"
    …
\end{verbatim}

Next, override the \texttt{doRegisterCellNibs} method to register your
custom cell. In this method, create a \texttt{UINib} instance for your
cell and then register it with the \texttt{UITableView} instance
(\texttt{tableView}) inherited from
\href{https://github.com/liferay/liferay-screens/blob/master/ios/Framework/Core/Base/BaseListScreenlet/TableView/BaseListTableView.swift}{the
\texttt{BaseListTableView} class}. When registering the nib file, you
must use the string constant you created earlier as the
\texttt{forCellReuseIdentifier}. For example, here's the
\texttt{doRegisterCellNibs} method in
\texttt{BookmarkListView\_default-custom}:

\begin{verbatim}
  public override func doRegisterCellNibs() {
      let nib = UINib(nibName: "BookmarkCell_default-custom", bundle: NSBundle.mainBundle())

      tableView?.registerNib(nib, forCellReuseIdentifier: BookmarkCellId)
}
\end{verbatim}

Also in your View class, override the \texttt{doGetCellId} method to
return the cell ID for each row. All you need to do in this method is
return the string constant you created earlier. For example, the
\texttt{doGetCellId} method in \texttt{BookmarkListView\_default-custom}
returns the \texttt{BookmarkCellId} constant:

\begin{verbatim}
override public func doGetCellId(row row: Int, object: AnyObject?) -> String {
    return BookmarkCellId
}
\end{verbatim}

Now override the \texttt{doFillLoadedCell} method to fill the cell with
data. Note that this method isn't called for in-progress cells; it's
only called for cells that display data. Also note that this method's
\texttt{object} argument contains the data as \texttt{AnyObject}. You
must cast this to your desired type and then set it to the appropriate
cell variable. For example, the \texttt{doFillLoadedCell} method in
\texttt{BookmarkListView\_default-custom} casts the \texttt{object}
argument to \texttt{Bookmark} and then sets it to the cell's
\texttt{bookmark} variable:

\begin{verbatim}
override public func doFillLoadedCell(row row: Int, cell: UITableViewCell, object:AnyObject) {
    if let bookmarkCell = cell as? BookmarkCell_default_custom, bookmark = object as? Bookmark {
        bookmarkCell.bookmark = bookmark
    }
}
\end{verbatim}

The typical iOS
\href{https://developer.apple.com/library/ios/documentation/UIKit/Reference/UITableViewDelegate_Protocol/}{\texttt{UITableViewDelegate}
protocol} and
\href{https://developer.apple.com/library/ios/documentation/UIKit/Reference/UITableViewDataSource_Protocol/}{\texttt{UITableViewDataSource}
protocol} methods are also available in your View class. You can
override any of them if you need to (check first to make sure they're
not already overridden). For example,
\texttt{BookmarkListView\_default-custom} implements the following
method to use a different cell height for each row:

\begin{verbatim}
public func tableView(tableView: UITableView, heightForRowAtIndexPath indexPath: NSIndexPath) -> CGFloat {
    return 80
}
\end{verbatim}

When you finish, set your View class as your XIB file's custom class.

Awesome! You're done! Now you know how to implement your own custom
cells for use in list Screenlets.

\subsection{Related Topics}\label{related-topics-257}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-ios-list-screenlets}{Creating
iOS List Screenlets}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-ios-themes}{Creating
iOS Themes}

\href{/docs/7-1/tutorials/-/knowledge_base/t/sorting-your-list-screenlet}{Sorting
Your List Screenlet}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-complex-lists-in-your-list-screenlet}{Creating
Complex Lists in Your List Screenlet}

\href{/docs/7-1/tutorials/-/knowledge_base/t/ios-best-practices}{iOS
Best Practices}

\section{Sorting Your List Screenlet}\label{sorting-your-list-screenlet}

To sort your list Screenlet, you must point it to a \emph{comparator
class} in your portal. A comparator class implements the logic that
sorts your entities. You can create your own comparator class or use
those that already exist in your portal. Once your list is sorted, you
can split it into sections. This tutorial shows you how to sort your
list Screenlet with a comparator and create sections for your sorted
list.

\noindent\hrulefill

\textbf{Note:} To create a new comparator, you must create a class that
extends the portal's
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/util/OrderByComparator.html}{\texttt{OrderByComparator}
class} with your entity as a type argument. Then you must override the
methods that implement the sort. For example, the portal's
\href{https://github.com/liferay/liferay-portal/blob/7.0.x/modules/apps/collaboration/bookmarks/bookmarks-api/src/main/java/com/liferay/bookmarks/util/comparator/EntryURLComparator.java}{\texttt{EntryURLComparator}
class} sorts bookmarks in Liferay's Bookmarks portlet by URL.

\noindent\hrulefill

First, you'll learn how to use a comparator to sort your list Screenlet.

\subsection{Using a Comparator}\label{using-a-comparator}

To use a comparator, you must set the list Screenlet's
\texttt{obcClassName} property to the comparator's fully qualified class
name. Do this in Interface Builder when inserting the Screenlet in an
app, just as you would set any other Screenlet property. For example, to
set the sample Bookmark List Screenlet to sort its list of bookmarks by
URL, you must set \emph{Obc Class Name} to
\emph{com.liferay.bookmarks.util.comparator.EntryURLComparator} in
Interface Builder:

\begin{figure}
\centering
\includegraphics{./images/screens-ios-obc-ib.png}
\caption{To use a comparator, set the \emph{Obc Class Name} property in
Interface Builder to the comparator's fully qualified class name.}
\end{figure}

That's it! Note that although all list Screenlets inherit the
\texttt{obcClassName} property from
\href{https://github.com/liferay/liferay-screens/blob/develop/ios/Framework/Core/Base/BaseListScreenlet/BaseListScreenlet.swift}{the
\texttt{BaseListScreenlet} class}, the list Screenlet must also make its
service call with this property. See the
\href{/docs/7-1/reference/-/knowledge_base/r/screenlets-in-liferay-screens-for-ios}{Screenlet
reference documentation} to see which list Screenlets included with
Liferay Screens support the \texttt{obcClassName} property. Also,
Liferay DXP's comparator classes can change between versions. If you're
using one of these comparators, make sure you specify the one that
matches your Liferay DXP version.

\subsection{Create Sections for Your
List}\label{create-sections-for-your-list}

Dividing lists into sections that contain like elements is common in iOS
apps. To do this in list Screenlets, first use a comparator to sort the
list by the criteria you'll use to create the sections. Then override
the
\href{https://github.com/liferay/liferay-screens/blob/master/ios/Samples/Bookmark/BookmarkListScreenlet/Interactor/BookmarkListPageLoadInteractor.swift}{\texttt{BookmarkListPageLoadInteractor}
class's} \texttt{sectionForRowObject} method in your list Screenlet's
Interactor. This method is called for each item in the list and should
return the information necessary to place the item in a section. For
example,
\href{https://github.com/liferay/liferay-screens/blob/master/ios/Samples/Bookmark/BookmarkListScreenlet/Interactor/BookmarkListPageLoadInteractor.swift}{the
sample Bookmark List Screenlet's Interactor} overrides the
\texttt{sectionForRowObject} method to group results by hostname:

\begin{verbatim}
public override func sectionForRowObject(object: AnyObject) -> String? {
    guard let bookmark = object as? Bookmark else {
        return nil
    }

    let host = NSURL(string: bookmark.url)?.host?.lowercaseString

    return host?.stringByReplacingOccurrencesOfString("www.", withString: "")
}
\end{verbatim}

Note that this only produces predictable results when Bookmark List
Screenlet is sorted by \texttt{EntryURLComparator} as detailed in the
preceding section.

And that's all there is to it! Now you know how to sort and section your
list Screenlet's list.

\subsection{Related Topics}\label{related-topics-258}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-ios-list-screenlets}{Creating
iOS List Screenlets}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-custom-cells-with-list-screenlets}{Using
Custom Cells with List Screenlets}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-complex-lists-in-your-list-screenlet}{Creating
Complex Lists in Your List Screenlet}

\href{/docs/7-1/tutorials/-/knowledge_base/t/ios-best-practices}{iOS
Best Practices}

\section{Creating Complex Lists in Your List
Screenlet}\label{creating-complex-lists-in-your-list-screenlet}

Most list Screenlets' Themes use
\href{https://developer.apple.com/library/ios/documentation/UIKit/Reference/UITableView_Class/}{iOS's
\texttt{UITableView}} to display simple lists. Although
\texttt{UITableView} is great for this, it's not so great for complex
lists like grids or stacks. To create complex lists, you should use
\href{https://developer.apple.com/reference/uikit/uicollectionview}{iOS's
\texttt{UICollectionView}} in your list Screenlet's Theme.

This tutorial shows you how to create such a Theme, using
\href{https://github.com/liferay/liferay-screens/tree/master/ios/Samples/Bookmark/BookmarkListScreenlet/Themes/CollectionView}{the
sample Bookmark List Screenlet's Collection Theme} as an example. First,
you'll create the list's cell.

\subsection{Creating the Cell}\label{creating-the-cell}

You'll create your list's cell with
\href{/docs/7-1/tutorials/-/knowledge_base/t/using-custom-cells-with-list-screenlets}{the
same sequence of steps} used to create any list Screenlet's cell. Note,
however, that how you perform these steps is a bit different:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Define your cell's UI in a new XIB file. Because this cell is part of
  a Theme that uses \texttt{UICollectionView}, you can shape it however
  you want. For example, here's the
  \texttt{BookmarkCell\_default-collection.xib} file for the cell in
  Bookmark List Screenlet's Collection Theme. It's a simple square that
  displays the bookmark's URL and the URL's first letter.

  \begin{figure}
  \centering
  \includegraphics{./images/screens-ios-collectionview-cell.png}
  \caption{The XIB file for the cell in Bookmark List Screenlet's custom
  View.}
  \end{figure}
\item
  Create your XIB file's class by extending
  \texttt{UICollectionViewCell}. Create as many outlets and actions as
  you need for your UI components and write the logic required for your
  cell's UI to function. For example,
  \texttt{BookmarkCell\_default\_collection} is the XIB file's class in
  Bookmark List Screenlet's Custom Theme. This class extends
  \texttt{UICollectionViewCell} and contains outlets for the URL
  (\texttt{urlLabel}) and the URL's first letter (\texttt{centerLabel}).
  The \texttt{bookmark} variable's \texttt{didSet} observer sets the
  bookmark's name and URL to the respective label. Also note that the
  overridden \texttt{prepareForReuse} method resets the labels for
  reuse:

\begin{verbatim}
import UIKit
import LiferayScreens

public class BookmarkCell_default_collection: UICollectionViewCell {

    //MARK: Outlets

    @IBOutlet weak var centerLabel: UILabel?
    @IBOutlet weak var urlLabel: UILabel?

    //MARK: Public properties

    public var bookmark: Bookmark? {
        didSet {
            if let bookmark = bookmark, url = NSURL(string: bookmark.url),
                firstLetter = url.host?.remove("www.").characters.first {

                    self.centerLabel?.text = String(firstLetter).uppercaseString
                    self.urlLabel?.text = bookmark.url.remove("http://").remove("https://").remove("www.")
            }
        }
    }

    //MARK: UICollectionViewCell

    override public func prepareForReuse() {
        super.prepareForReuse()

        centerLabel?.text = "..."
        urlLabel?.text = "..."
    }
}
\end{verbatim}
\end{enumerate}

Now that your cell exists, you can create the rest of your Theme.

\subsection{Creating the Theme's XIB and View
Class}\label{creating-the-themes-xib-and-view-class}

You'll create the rest of your Theme with
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-the-ios-list-screenlets-theme}{the
same sequence of steps} used to create any list Screenlet's Theme. Like
creating the cell, how you perform these steps is a bit different
because your Theme uses \texttt{UICollectionView} instead of
\texttt{UITableView}.

First, define your Theme's UI in a new XIB file. Add a
\texttt{UICollectionView} instead of a \texttt{UITableView} to this
file. For example, the
\href{https://github.com/liferay/liferay-screens/blob/master/ios/Samples/Bookmark/BookmarkListScreenlet/Themes/CollectionView/BookmarkListView_default-collection.xib}{\texttt{BookmarkListView\_default-collection.xib}
file} for Bookmark List Screenlet's Custom Theme contains a collection
view.

Next, create the View class. Instead of extending
\texttt{BaseListTableView}, this class must extend Screens's
\href{https://github.com/liferay/liferay-screens/blob/master/ios/Framework/Core/Base/BaseListScreenlet/CollectionView/BaseListCollectionView.swift}{\texttt{BaseListCollectionView}
class}. The \texttt{BaseListCollectionView} class implements most of the
code necessary to use \texttt{UICollectionView} in your Screenlet. By
extending it, you can focus on the code unique to your Screenlet. Your
View class should also contain a string constant to serve as the cell
ID. You'll use this constant when you register your cell. For example,
the View class in Bookmark List Screenlet's Collection Theme
(\texttt{BookmarkListView\_default\_collection}) extends
\texttt{BaseListCollectionView} and defines the string constant
\texttt{BookmarkCellId}:

\begin{verbatim}
public class BookmarkListView_default_collection : BaseListCollectionView {

    let BookmarkCellId = "bookmarkCell"
    …
\end{verbatim}

In Interface Builder, set this new class as the XIB's Custom Class.

Next, override the \texttt{doRegisterCellNibs} method to register the
cell you created in the previous section. In this method, create a
\texttt{UINib} instance for your cell and then register it with the
\texttt{UICollectionView} instance (\texttt{collectionView}) inherited
from \texttt{BaseListCollectionView}. When registering the nib file, you
must use the string constant you created earlier as the
\texttt{forCellReuseIdentifier}. For example, here's the
\texttt{doRegisterCellNibs} method in
\texttt{BookmarkListView\_default\_collection}:

\begin{verbatim}
public override func doRegisterCellNibs() {
    let cellNib = UINib(nibName: "BookmarkCell_default-collection", bundle: nil)
    collectionView?.registerNib(cellNib, forCellWithReuseIdentifier: BookmarkCellId)
}
\end{verbatim}

Also in your View class, override the \texttt{doGetCellId} method to
return the ID you registered the cell with. For example, the
\texttt{doGetCellId} method in
\texttt{BookmarkListView\_default\_collection} returns the string
constant \texttt{BookmarkCellId}:

\begin{verbatim}
public override func doGetCellId(indexPath indexPath: NSIndexPath, object: AnyObject?) -> String {
    return BookmarkCellId
}
\end{verbatim}

Next, override the \texttt{doFillLoadedCell} method to fill the cell
with data. This method's \texttt{object} argument contains the data as
\texttt{AnyObject}. You must cast this to your desired type and then set
it to the appropriate cell variable. For example, the
\texttt{doFillLoadedCell} method in
\texttt{BookmarkListView\_default\_collection} casts the \texttt{object}
argument to \texttt{Bookmark} and then sets it to the cell's
\texttt{bookmark} variable:

\begin{verbatim}
public override func doFillLoadedCell(
        indexPath indexPath: NSIndexPath,
        cell: UICollectionViewCell,
        object: AnyObject) {

    if let cell = cell as? BookmarkCell_default_collection, bookmark = object as? Bookmark {
        cell.bookmark = bookmark
    }
}
\end{verbatim}

Next, you'll create the layout.

\subsection{Creating the Layout}\label{creating-the-layout}

The layout object is a key part of \texttt{UICollectionView}. This
object controls the position of the UI elements, their size, and more.
To customize the layout object, override the \texttt{doCreateLayout}
method in your View class. For example, the \texttt{doCreateLayout}
method in Bookmark List Screenlet's View class
(\texttt{BookmarkListView\_default\_collection}) returns a
\texttt{UICollectionViewFlowLayout} for the layout object. This is a
basic layout that gives you a simple way to customize things like item
size, spacing between items, scroll direction, and more:

\begin{verbatim}
public override func doCreateLayout() -> UICollectionViewLayout {
    let layout = UICollectionViewFlowLayout()
    layout.itemSize = CGSize(width: 110, height: 110)
    layout.minimumLineSpacing = 10
    layout.minimumInteritemSpacing = 10

    return layout
}
\end{verbatim}

Great! You're done! You can now use your new Theme
\href{/docs/7-1/tutorials/-/knowledge_base/t/using-themes-in-ios-screenlets}{the
same way you would any other}.

If you want to package your Theme to contribute it to the Liferay
Screens project or distribute it with CocoaPods, see
\href{/docs/7-1/tutorials/-/knowledge_base/t/packaging-ios-themes}{the
tutorial on packaging Themes}.

\subsection{Related Topics}\label{related-topics-259}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-ios-list-screenlets}{Creating
iOS List Screenlets}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-ios-themes}{Creating
iOS Themes}

\href{/docs/7-1/tutorials/-/knowledge_base/t/sorting-your-list-screenlet}{Sorting
Your List Screenlet}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-custom-cells-with-list-screenlets}{Using
Custom Cells with List Screenlets}

\href{/docs/7-1/tutorials/-/knowledge_base/t/ios-best-practices}{iOS
Best Practices}

\section{Accessing the Liferay Session in
iOS}\label{accessing-the-liferay-session-in-ios}

A session is a conversation state between the client and server. It
typically consists of multiple requests and responses between the two.
To facilitate this communication, the session must have the server IP
address, and a user's login credentials. Liferay Screens uses a Liferay
Session to access and query the JSON web services provided by Liferay
Portal. When you log in using a Liferay Session, the portal returns the
user's information (name, email, user ID, etc\ldots). Screens stores
this information and the active Liferay Session in Screens's
\texttt{SessionContext} class.

The \texttt{SessionContext} class is very powerful and lets you use
Screens in many different scenarios. For example, you can use
\texttt{SessionContext} to request information with the JSON WS API
provided by Liferay, or with the Liferay Mobile SDK. You can also use
\texttt{SessionContext} to create anonymous sessions, or log in a user
without showing Login Screenlet.

This tutorial explains some common \texttt{SessionContext} use cases,
and also describes the class's most important methods.

\subsection{Getting the Current
session}\label{getting-the-current-session}

The current session is established after the user successfully logs in
with Login Screenlet. Use \texttt{SessionContext.currentContext} to
retrieve the session. Note this will return \texttt{nil} if the user
didn't sign in with Login Screenlet. You can also use the
\texttt{SessionContext} property \texttt{isLoggedIn} to determine if a
session exists. This returns \texttt{false} if there's no current
session.

\subsection{Creating a Liferay
Session}\label{creating-a-liferay-session}

When working with Liferay Screens, you may wish to call the remote JSON
web services provided by the Liferay Mobile SDK. Every operation with
the Liferay Mobile SDK needs a Liferay Session to provide the server
address, user credentials, and any other required parameters. Login
Screenlet creates a session when a user successfully logs in. You can
retrieve this session with the \texttt{SessionContext} method
\texttt{createRequestSession()}. Typically, you call this method through
the \texttt{currentContext} object. For example:

\begin{verbatim}
SessionContext.currentContext?.createRequestSession()
\end{verbatim}

You can then use the session to make the Mobile SDK service call. If you
need to check first to see if a user has logged in, you can use the
\texttt{SessionContext} property \texttt{isLoggedIn}.

Great! Now you know how to retrieve an existing session in your app. But
what if you're not using Login Screenlet? There won't be an existing
session to retrieve. No sweat! You can still use \texttt{SessionContext}
to create one manually. The next section shows you how to do this.

\subsection{Creating a Session
Manually}\label{creating-a-session-manually-1}

If you don't use Login Screenlet, then \texttt{SessionContext} doesn't
have a session for you to retrieve. In this case, you must create one
manually. You can do this with the \texttt{SessionContext} method
\texttt{loginWithBasic}. The method takes a username, password, and user
attributes as parameters, and creates a session with those credentials.
The following code uses \texttt{loginWithBasic} to create a session:

\begin{verbatim}
Session session = SessionContext.loginWithBasic(username: USERNAME, password: PASSWORD, userAttributes: [:]);
\end{verbatim}

For the \texttt{userAttributes} parameter, you must provide some
attributes associated with the logged in user, such as their
\texttt{userId}. For a complete list of attributes, see the
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/model/User.html}{user
model interface}.

Super! Now you know how to create a session manually. The next section
shows you how to implement auto-login, and save or restore a session.

\subsection{Implementing Auto-login and Saving or Restoring a
Session}\label{implementing-auto-login-and-saving-or-restoring-a-session-1}

Although Login Screenlet is awesome, your users may not want to enter
their credentials every time they open your app. It's very common for
apps to only require a single login. To implement this in your app, see
\href{https://www.youtube.com/watch?v=kEZEahTzuck}{this video}.

In short, you need to set \texttt{saveCredentials} to \texttt{true} in
Login Screenlet. The next login then uses the saved credentials. To make
sure this also works when the app restarts, you must retrieve the stored
credentials by using the \texttt{SessionContext} method
\texttt{loadStoredCredentials}. The following Swift code shows a typical
implementation of this:

\begin{verbatim}
if SessionContext.loadStoredCredentials() {
    // user auto-logged in
    // consider doing a relogin here (see next section)
}
else {
    // send user to login screen with the login screenlet
}
\end{verbatim}

Awesome! Now you know how to implement auto-login in your Liferay
Screens apps. For more information on available \texttt{SessionContext}
methods, see the \hyperref[methods]{Methods section} at the end of this
tutorial. Next, you'll learn how to implement relogin for cases where a
user's credentials change on the server while they're logged in.

\subsection{Implementing Relogin}\label{implementing-relogin-1}

A session, whether created via Login Screenlet or auto-login, contains
basic user data that verifies the user in the Liferay instance. If that
data changes in the server, then your session is outdated, which may
cause your app to behave inconsistently. Also, if a user is deleted,
deactivated, or otherwise changes their credentials in the server, the
auto-login feature won't deny access because it doesn't perform server
transactions: it only retrieves an existing session from local storage.
This isn't an optimal situation!

For such scenarios, you can use the relogin feature. This feature is
implemented in a method that determines if the current session is still
valid. If the session is still valid, the user's data is updated with
the most recent data from the server. If the session isn't valid, the
user is logged out and must then log in again to create a new session.

To this feature, call the \texttt{SessionContext.currentContext} method
\texttt{relogin}:

\begin{verbatim}
SessionContext.currentContext?.relogin(closure)
\end{verbatim}

Note that this operation is done asynchronously in a background thread.
The \texttt{closure} argument is a function that eventually receives the
new user attributes. In case of error, the closure is called with
\texttt{nil} attributes and the user is logged out of the session. The
typical Swift code for a full relogin is as follows. Note a trailing
closure is used:

\begin{verbatim}
SessionContext.currentContext?.relogin { userAttributes in
    if userAttributes == nil {
        // couldn't retrieve the user attributes: user invalidated or password changed?
    }
    else {
        // full re-login made. Everything is updated
    }
}
\end{verbatim}

Great! Now you know how to implement relogin in your app. You've also
seen how handy \texttt{SessionContext} can be. It can do even more! The
next section lists some additional \texttt{SessionContext} methods, and
some more detail on the ones used in this tutorial.

\subsection{Methods}\label{methods-1}

\noindent\hrulefill

Method \textbar{} Return Type \textbar{} Explanation \textbar{}
\texttt{logout()} \textbar{} \texttt{void} \textbar{} Clears the stored
user attributes and session. \textbar{} \texttt{relogin(closure)}
\textbar{} \texttt{void} \textbar{} Refreshes user data from the server.
This recreates \texttt{currentContext} if successful, or calls
\texttt{logout()} on failure. When the server data is received, the
closure is called with received user's attributes. If an error occurs,
the closure is called with \texttt{nil}. \textbar{}
\texttt{loginWithBasic(username,\ password,\ userAttributes)} \textbar{}
\texttt{LRSession} \textbar{} Creates a Liferay Session using the
default server, and the supplied username, password, and user
information. \textbar{}
\texttt{loginWithOAuth2(authentication,\ userAttributes)} \textbar{}
\texttt{LRSession} \textbar{} Creates a Liferay Session using the
default server and the supplied OAuth 2 tokens. This is intended to be
used together with
\href{/docs/7-1/tutorials/-/knowledge_base/t/using-oauth-2-in-liferay-screens-for-ios}{OAuth
2 for Liferay Screens}. \textbar{} \texttt{createRequestSession()}
\textbar{} \texttt{LRSession} \textbar{} Creates a Liferay Session based
on the current session's server and user credentials. This Liferay
Session is intended to be used for only a single request (don't reuse
it). \textbar{}
\texttt{createEphemeralBasicSession(username,\ password)} \textbar{}
\texttt{LRSession} \textbar{} Creates a Liferay Session based on the
provided username and password. Note that this session isn't stored
anywhere. This is the method used to create a session for anonymous
access. Anonymous access is used by the Sign Up and Forgot Password
Screenlets. \textbar{} \texttt{userAttribute(key:\ String)} \textbar{}
\texttt{AnyObject} \textbar{} Returns a \texttt{User} object with the
server attributes of the logged-in user. This includes the user's email,
user ID, name, and portrait ID. \textbar{} \texttt{storeCredentials()}
\textbar{} \texttt{Bool} \textbar{} Stores the current session.
\textbar{} \texttt{removeStoredCredentials()} \textbar{} \texttt{Bool}
\textbar{} Clears the session and user information from storage.
\textbar{} \texttt{loadStoredCredentials()} \textbar{} \texttt{Bool}
\textbar{} Loads the session and user information from storage. They're
then used, respectively, as the current session and user. \textbar{}

\noindent\hrulefill

\subsection{Properties}\label{properties}

\noindent\hrulefill

Property \textbar{} Type \textbar{} Explanation \textbar{}
\texttt{currentContext} \textbar{} \texttt{SessionContext} \textbar{}
The current session established through Login Screenlet, or the
\texttt{loginWithBasic} or \texttt{loginWithOAuth2} methods. \textbar{}
\texttt{isLoggedIn} \textbar{} \texttt{Bool} \textbar{} Returns
\texttt{true} if \texttt{SessionContext} contains a Liferay Session.
\textbar{} \texttt{basicAuthUsername} \textbar{} \texttt{String}
\textbar{} The username used to establish the current session (if
any).\textbar{} \texttt{basicAuthPassword} \textbar{} \texttt{String}
\textbar{} The password used to establish the current session (if
any).\textbar{} \texttt{userId} \textbar{} \texttt{Number} \textbar{}
The user identifier used to establish the current session (if any).
\textbar{}

\noindent\hrulefill

For more information, see the
\href{https://github.com/liferay/liferay-screens/blob/master/ios/Framework/Core/Context/SessionContext.swift}{\texttt{SessionContext}
source code in GitHub}.

\subsection{Related Topics}\label{related-topics-260}

\href{/docs/7-1/reference/-/knowledge_base/r/loginscreenlet-for-ios}{Login
Screenlet for iOS}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-screenlets-in-ios-apps}{Using
Screenlets in iOS Apps}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-oauth-2-in-liferay-screens-for-ios}{Using
OAuth 2 in Liferay Screens for iOS}

\section{Adding Custom Interactors to iOS
Screenlets}\label{adding-custom-interactors-to-ios-screenlets}

Interactors are Screenlet components that implement server communication
for a specific use case. For example, the Login Screenlet's Interactor
calls the Liferay Mobile SDK service that authenticates a user to the
portal. Similarly, the Interactor for
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-ios-screenlets}{the
Add Bookmark Screenlet} calls the Liferay Mobile SDK service that adds a
bookmark to the Bookmarks portlet.

That's all fine and well, but what if you want to customize a
Screenlet's server call? What if you want to use a different back-end
with a Screenlet? No problem! You can implement a custom Interactor for
the Screenlet. You can plug in a different Interactor that makes its
server call by using custom logic or network code. To do this, you must
implement the current Interactor's interface and then pass it to the
Screenlet you want to override. You should do this inside your app's
code.

In this tutorial, you'll see an example Interactor that overrides the
Login Screenlet to always log in the same user, without a password.

\subsection{Implementing a Custom
Interactor}\label{implementing-a-custom-interactor-1}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Implement your custom Interactor. You must inherit
  \texttt{ServerConnectorInteractor}, as shown here:

\begin{verbatim}
 class LoginCustomInteractor: ServerConnectorInteractor {

     override func createConnector() -> ServerConnector? {

         ...

         return connector
     }

 }
\end{verbatim}
\item
  Implement the optional protocol that receives a
  \texttt{customInteractorForAction}, and return your own Interactor:

\begin{verbatim}
 func screenlet(screenlet: BaseScreenlet, 
         customInteractorForAction: String, 
         withSender: AnyObject?) -> Interactor? {

     return LoginCustomInteractor()
 }
\end{verbatim}
\end{enumerate}

Great! Now you know how to implement custom Interactors for iOS
Screenlets.

\subsection{Related Topics}\label{related-topics-261}

\href{/docs/7-1/tutorials/-/knowledge_base/t/architecture-of-liferay-screens-for-ios}{Architecture
of Liferay Screens for iOS}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-ios-screenlets}{Creating
iOS Screenlets}

\section{Rendering Web Content in Your iOS
App}\label{rendering-web-content-in-your-ios-app}

Liferay Screens provides several ways to render
\href{/docs/7-1/user/-/knowledge_base/u/creating-web-content}{web
content} in your app. For historical reasons, web content articles are
\texttt{JournalArticle} entities in Liferay. Using Web Content Display
Screenlet is a simple and powerful way to display HTML from a
\texttt{JournalArticle} in your app. To fit your needs, this Screenlet
supports several use cases. This tutorial describes them.

\subsection{Retrieving Basic Web
Content}\label{retrieving-basic-web-content-1}

The simplest use case for Web Content Display Screenlet is to retrieve a
web content article's HTML and render it in a
\href{https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIWebView_Class/}{\texttt{UIWebView}}.
To do this, provide the web content article's ID via the \emph{Article
Id} attribute in Interface Builder. The Screenlet takes care of the
rest. This includes rendering the content to fit mobile devices,
performing any required caching, and more.

To render the content \emph{exactly} as it appears on your mobile site,
however, you must provide the CSS inline or use a template. The HTML
returned isn't aware of a Liferay instance's global CSS.

You can also modify the rendered HTML with a delegate, as explained in
the
\href{/docs/7-1/reference/-/knowledge_base/r/webcontentdisplayscreenlet-for-ios}{Web
Content Display Screenlet reference documentation}.

As you can see, this is all fairly straightforward. What could go wrong?
Famous last words. A common mistake is to use the default site ID
(\texttt{groupId}) instead of the one for the site that contains your
web content articles. To continue using a default \texttt{groupId} in
your app, but use a different one for Web Content Display Screenlet,
assign the Screenlet's \emph{Group Id} property in Interface Builder.

\subsection{Using Templates}\label{using-templates-1}

Web Content Display Screenlet can also use
\href{/docs/7-1/user/-/knowledge_base/u/designing-web-content-with-templates}{templates}
to render web content articles. For example, your Liferay instance may
have a custom template specifically designed to display content on
mobile devices. To use a template, set the template's ID as the
Screenlet's \texttt{templateId} property (\emph{Template Id} in
Interface Builder).

Recall that structured web content in Liferay can have many templates.
You can create your own template if there's not one suitable for
displaying web content in your app.

\subsection{Rendering Structured Web
Content}\label{rendering-structured-web-content}

To render
\href{/docs/7-1/user/-/knowledge_base/u/creating-structured-web-content}{structured
web content} in Web Content Display Screenlet, you must create a custom
theme capable of doing so. Also, you must create a custom theme for each
structure you want to display in your app. In this case, you may find it
convenient to create each theme inside a single parent theme and use
compound naming to indicate this relationship. For example, if you have
structures in your Liferay instance called \emph{book}, \emph{employee},
and \emph{meeting}, you must create a custom theme for each. If you
create these themes as children of another custom theme called
\emph{mytheme}, you could name them \emph{mytheme.book},
\emph{mytheme.employee}, and \emph{mytheme.meeting}.

Regardless of where you create your themes or what you name them, use
the following steps to create them:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/creating-ios-themes}{Create
  a theme} to render your web content. If you've already created your
  own theme, you can skip this step.
\item
  In your theme, create a new class called
  \texttt{WebContentDisplayView\_themeName}, extending from
  \texttt{BaseScreenletView}. This class will hold the outlets and
  actions associated with the web content's UI.
\item
  Create the UI in the \texttt{WebContentDisplayView\_themeName.xib}
  file. This file should have a \texttt{UIView} that contains the
  components you need to render the web content's structure fields. For
  example, if your structured web content contains \texttt{latitude} and
  \texttt{longitude} fields, you can use a \texttt{MKMapView} component
  to render the map point.
\item
  Once your components are ready, change the root view's class to
  \texttt{WebContentDisplayView\_themeName} (the class you created in
  the first step), and create the outlets and actions you need to manage
  your UI components.
\item
  Conform the \texttt{WebContentDisplayViewModel} protocol in the
  \texttt{WebContentDisplayView\_themeName} class. This protocol
  requires you to add the \texttt{htmlContent} and
  \texttt{recordContent} properties. The \texttt{htmlContent} property
  is intended for HTML web content; this isn't your theme's use case.
  Your theme must display structured web content; use the
  \texttt{recordContent} property for this content. In this property,
  set the structure field's value as the corresponding outlet's value.
  For example:

\begin{verbatim}
 public var htmlContent: String? {
     get {
         return nil
     }
     set {
         // not used for structured Web Contents
     }
 }

 public var recordContent: DDLRecord? {
     didSet {
         // set the outlets with record's values
         set.myOutlet.myProperty = recordContent?["my_field_name"]?.currentValueAsLabel
     }
 }
\end{verbatim}
\end{enumerate}

Next, you'll learn how to display a list of web content articles in your
app.

\subsection{Displaying a List of Web Content
Articles}\label{displaying-a-list-of-web-content-articles-1}

The preceding examples show you how to use Web Content Display Screenlet
to display a single web content article's contents in your app. But what
if you want to display a list of articles instead? No problem! You can
do this by using
\href{/docs/7-1/reference/-/knowledge_base/r/web-content-list-screenlet-for-ios}{Web
Content List Screenlet}, or
\href{/docs/7-1/reference/-/knowledge_base/r/assetlistscreenlet-for-ios}{Asset
List Screenlet}.

First, you'll learn how to use Web Content List Screenlet.

\subsubsection{Using Web Content List
Screenlet}\label{using-web-content-list-screenlet}

Web Content List Screenlet lets you retrieve and display a list of web
content articles from a web content folder. Follow these steps to use
the Screenlet:

\begin{itemize}
\item
  Insert Web Content List Screenlet in your View Controller.
\item
  Configure the \emph{Group Id} and \emph{Folder Id} properties in
  Interface Builder. The folder ID is the ID of the web content folder
  you want to display articles from. To use the root folder, use
  \texttt{0} for the Folder Id.
\item
  To receive events related to the list, conform
  \texttt{WebContentListScreenletDelegate}. The events contain the
  \texttt{WebContent} objects.
\end{itemize}

For more information on the Screenlet and its supported functionality,
see the
\href{/docs/7-1/reference/-/knowledge_base/r/web-content-list-screenlet-for-ios}{Web
Content List Screenlet reference documentation}.

\subsubsection{Using Asset List
Screenlet}\label{using-asset-list-screenlet}

Asset List Screenlet is similar to Web Content Display Screenlet in that
it can display a list of items from a Liferay instance. Asset List
Screenlet, however, displays a list of assets. Since web content is an
asset, you can use Asset List Screenlet to show a list of web content
articles. Consider the following when doing this:

\begin{itemize}
\item
  In the delegate, \texttt{screenlet:onAssetListResponse} gets an array
  of \texttt{Asset} objects that represent \texttt{WebContent} objects.
  Since \texttt{WebContent} is a child of \texttt{Asset}, you can cast
  the \texttt{Asset} objects to \texttt{WebContent}. Each
  \texttt{WebContent} object has the \texttt{html}, \texttt{structure},
  or \texttt{structuredRecord} properties.
\item
  To render Asset List Screenlet with \texttt{WebContent} objects, you
  must create your own theme. Create a class in your theme that extends
  \texttt{AssetListView\_default}, and override the
  \texttt{doFillLoadedCell} method. In this method, cast the
  \texttt{object} parameter as \texttt{WebContent} and then retrieve
  field values from the web content's \texttt{structuredRecord}
  property. If you want custom cells, you can also override the
  \texttt{doRegisterCellNibs} and \texttt{doCreateCell} methods. See the
  \href{/docs/7-1/reference/-/knowledge_base/r/assetlistscreenlet-for-ios}{Asset
  List Screenlet reference documentation} for more details on
  customizing your asset list.
\end{itemize}

\subsection{Related Topics}\label{related-topics-262}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-screenlets-in-ios-apps}{Using
Screenlets in iOS Apps}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-themes-in-ios-screenlets}{Using
Themes in iOS Screenlets}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-ios-themes}{Creating
iOS Themes}

\href{/docs/7-1/reference/-/knowledge_base/r/webcontentdisplayscreenlet-for-ios}{Web
Content Display Screenlet for iOS}

\href{/docs/7-1/reference/-/knowledge_base/r/web-content-list-screenlet-for-ios}{Web
Content List Screenlet for iOS}

\href{/docs/7-1/reference/-/knowledge_base/r/assetlistscreenlet-for-ios}{Asset
List Screenlet for iOS}

\section{Rendering Web Pages in Your iOS
App}\label{rendering-web-pages-in-your-ios-app}

\href{/docs/7-1/tutorials/-/knowledge_base/t/rendering-web-content-in-your-ios-app}{The
Rendering Web Content} tutorial shows you how to display
\href{/docs/7-1/user/-/knowledge_base/u/introduction-web-content}{web
content} from a Liferay DXP site in your iOS app. Displaying content is
great, but what if you want to display an entire page? No problem!
\href{/docs/7-1/reference/-/knowledge_base/r/web-screenlet-for-ios}{Web
Screenlet} lets you display any web page. You can even customize the
page by injecting local or remote JavaScript and CSS files. When
combined with Liferay DXP's server-side customization features (e.g.,
\href{/docs/7-1/user/-/knowledge_base/u/styling-apps-and-assets}{Application
Display Templates}), Web Screenlet gives you almost limitless
possibilities for displaying web pages in your iOS apps.

In this tutorial, you'll learn how to use Web Screenlet to display web
pages in your iOS app.

\subsection{Inserting Web Screenlet in Your
App}\label{inserting-web-screenlet-in-your-app-1}

Inserting Web Screenlet in your app is the same as
\href{/docs/7-1/tutorials/-/knowledge_base/t/using-screenlets-in-ios-apps}{inserting
any Screenlet in your app}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In Interface Builder, insert a new view (\texttt{UIView}) in a new
  view controller. This new view should be nested under the view
  controller's existing view.
\item
  With the new view selected, open the Identity inspector and set the
  view's Custom Class to \texttt{WebScreenlet}.
\item
  Set any constraints that you want for the Screenlet in the scene.
\end{enumerate}

The exact steps for configuring Web Screenlet are unique to Web
Screenlet. First, you'll conform your view controller to Web Screenlet's
delegate protocol.

\subsection{Conforming to Web Screenlet's Delegate
Protocol}\label{conforming-to-web-screenlets-delegate-protocol}

To use any Screenlet, you must conform the class of the view controller
that contains it to the Screenlet's delegate protocol. Web Screenlet's
delegate protocol is \texttt{WebScreenletDelegate}. Follow these steps
to conform your view controller to \texttt{WebScreenletDelegate}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Import \texttt{LiferayScreens} and set your view controller to adopt
  the \texttt{WebScreenletDelegate} protocol:

\begin{verbatim}
import UIKit
import LiferayScreens

class ViewController: UIViewController, WebScreenletDelegate {...
\end{verbatim}
\item
  Implement the \texttt{WebScreenletDelegate} method
  \texttt{onWebLoad(\_:url:)}. This method is called when the Screenlet
  loads the page successfully. How you implement it depends on what (if
  anything) you want to happen upon page load. Its arguments are the
  \texttt{WebScreenlet} instance and the page URL. This example prints a
  message to the console indicating that the page was loaded:

\begin{verbatim}
func onWebLoad(_ screenlet: WebScreenlet, url: String) {
    // Called when the page is loaded
    print("\(url) was just loaded")
}
\end{verbatim}
\item
  Implement the \texttt{WebScreenletDelegate} method
  \texttt{screenlet(\_:onError:)}. This method is called when an error
  occurs loading the page, and therefore includes the \texttt{NSError}
  object. This lets you log or print the error. For example, this
  implementation prints a message containing the error's description:

\begin{verbatim}
func screenlet(_ screenlet: WebScreenlet, onError error: NSError) {
    print("Failed to load the page: \(error.localizedDescription)")
}
\end{verbatim}
\item
  Implement the \texttt{WebScreenletDelegate} method
  \texttt{screenlet(\_:onScriptMessageNamespace:onScriptMessage:)}. This
  method is called when
  \href{https://developer.apple.com/documentation/webkit/wkwebview}{the
  Screenlet's \texttt{WKWebView}} sends a message. This method's
  arguments include the message's namespace and the message. How you
  implement this method depends on what you want to happen when the
  message is sent. For example, you could perform a segue and include
  the message as the segue's \texttt{sender}:

\begin{verbatim}
func screenlet(_ screenlet: WebScreenlet,
    onScriptMessageNamespace namespace: String,
    onScriptMessage message: String) {

    performSegue(withIdentifier: "detail", sender: message)
}
\end{verbatim}
\item
  Get a reference to the Web Screenlet on your storyboard by using
  Interface Builder to create an outlet to it in your view controller.
  It's a best practice to name a Screenlet outlet after the Screenlet it
  references, or simply \texttt{screenlet}. Here's an example Web
  Screenlet outlet:

\begin{verbatim}
@IBOutlet weak var webScreenlet: WebScreenlet?
\end{verbatim}
\item
  In the view controller's \texttt{viewDidLoad()} method, use the Web
  Screenlet reference you just created to set the view controller as the
  Screenlet's delegate. To do this, add the following line of code just
  below the \texttt{super.viewDidLoad()} call:

\begin{verbatim}
self.webScreenlet?.delegate = self
\end{verbatim}
\end{enumerate}

Next, you'll use the same Web Screenlet reference to set the Screenlet's
parameters.

\subsection{Setting Web Screenlet's
Parameters}\label{setting-web-screenlets-parameters-1}

Web Screenlet has \texttt{WebScreenletConfiguration} and
\texttt{WebScreenletConfigurationBuilder} objects that supply the
parameters the Screenlet needs to work. These parameters include the URL
of the page to load and the location of any JavaScript or CSS files that
customize the page. You'll set most of these parameters via
\texttt{WebScreenletConfigurationBuilder}'s methods.

\noindent\hrulefill

\textbf{Note:} For a full list of
\texttt{WebScreenletConfigurationBuilder}'s methods, and a description
of each, see the table in
\href{/docs/7-1/reference/-/knowledge_base/r/web-screenlet-for-ios\#configuration}{the
Configuration section} of Web Screenlet's reference doc.

\noindent\hrulefill

To set Web Screenlet's parameters, follow these steps in the
\texttt{viewDidLoad()} method of a view controller that uses Web
Screenlet:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Use
  \texttt{WebScreenletConfigurationBuilder(\textless{}url\textgreater{})},
  where \texttt{\textless{}url\textgreater{}} is the web page's URL
  string, to create a \texttt{WebScreenletConfigurationBuilder} object.
  If the page requires Liferay DXP authentication, then the user must be
  logged in via
  \href{/docs/7-1/reference/-/knowledge_base/r/loginscreenlet-for-ios}{Login
  Screenlet} or a \texttt{SessionContext} method, and you must provide a
  relative URL to the \texttt{WebScreenletConfigurationBuilder}
  constructor. For example, if such a page's full URL is
  \texttt{http://your.liferay.instance/web/guest/blog}, then the
  constructor's argument is \texttt{/web/guest/blog}. For any other page
  that doesn't require Liferay DXP authentication, you must supply the
  full URL to the constructor.
\item
  Call the \texttt{WebScreenletConfigurationBuilder} methods to set the
  parameters that you need.
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** If the URL you supplied to the `WebScreenletConfigurationBuilder`
 constructor is to a page that doesn't require Liferay DXP authentication, then
 you must call the `WebScreenletConfigurationBuilder` method
 `set(webType: .other)`. The default `WebType` is `.liferayAuthenticated`,
 which is required to load Liferay DXP pages that require authentication. If
 you need to set `.liferayAuthenticated` manually, call
 `set(webType: .liferayAuthenticated)`.
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\item
  Call the \texttt{WebScreenletConfigurationBuilder} instance's
  \texttt{load()} method, which returns a
  \texttt{WebScreenletConfiguration} object.
\item
  Set the \texttt{WebScreenletConfiguration} object to the Web Screenlet
  instance's \texttt{configuration} property.
\item
  Call the Web Screenlet instance's \texttt{load()} method.
\end{enumerate}

Here's an example snippet of these steps in the \texttt{viewDidLoad()}
method of a view controller in which the Web Screenlet instance is
\texttt{webScreenlet}, and the \texttt{WebScreenletConfiguration} object
is \texttt{webScreenletConfiguration}:

\begin{verbatim}
override func viewDidLoad() {
    super.viewDidLoad()

    self.webScreenlet?.delegate = self

    let webScreenletConfiguration = 
        WebScreenletConfigurationBuilder(url: "/web/westeros-hybrid/companynews")
            .addCss(localFile: "blogs")
            .addJs(localFile: "blogs")
            .load()
    webScreenlet.configuration = webScreenletConfiguration
    webScreenlet.load()
}
\end{verbatim}

The relative URL \texttt{/web/westeros-hybrid/companynews} supplied to
the \texttt{WebScreenletConfigurationBuilder} constructor, and the lack
of a \texttt{set(webType:\ .other)} call, indicates that this Web
Screenlet instance loads a Liferay DXP page that requires
authentication. The \texttt{addCss} and \texttt{addJs} calls add local
CSS and JavaScript files, respectively. Both files are named
\texttt{blogs}.

Great! Now you know how to use Web Screenlet in your iOS apps.

\subsection{Related Topics}\label{related-topics-263}

\href{/docs/7-1/reference/-/knowledge_base/r/web-screenlet-for-ios}{Web
Screenlet for iOS}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-web-screenlet-with-cordova-in-your-ios-app}{Using
Web Screenlet with Cordova in Your iOS App}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-screenlets-in-ios-apps}{Using
Screenlets in iOS Apps}

\href{/docs/7-1/tutorials/-/knowledge_base/t/rendering-web-content-in-your-ios-app}{Rendering
Web Content in Your iOS App}

\section{Using Web Screenlet with Cordova in Your iOS
App}\label{using-web-screenlet-with-cordova-in-your-ios-app}

By using \href{https://cordova.apache.org/plugins/}{Cordova plugins} in
\href{/docs/7-1/tutorials/-/knowledge_base/t/rendering-web-pages-in-your-ios-app}{Web
Screenlet}, you can extend the functionality of the web page that the
Screenlet renders. This lets you tailor that page to your app's needs.
You'll get started by installing Cordova.

\subsection{Installing and Configuring Cordova
Automatically}\label{installing-and-configuring-cordova-automatically-1}

Follow these steps to automatically create an empty Android project
configured to use Cordova. Note that you must have
\href{https://git-scm.com/}{git}, \href{https://nodejs.org/en/}{Node.js
and npm}, and \href{https://cocoapods.org/}{CocoaPods} installed.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Install \texttt{screens-cli}:

\begin{verbatim}
npm install -g screens-cli
\end{verbatim}
\item
  Create the file \texttt{.plugins.screens} in the folder you want to
  create your project in. In this file, add all the Cordova plugins you
  want to use in your app. For example, you can add plugins from Cordova
  or GitHub:

\begin{verbatim}
https://github.com/apache/cordova-plugin-wkwebview-engine.git
cordova-plugin-call-number
cordova-plugin-camera
\end{verbatim}

  Note that the \texttt{WKWebView} Engine plugin is mandatory in iOS.
\item
  In the folder containing your \texttt{.plugins.screens} file, run
  \texttt{screens-cli} to create your project:

\begin{verbatim}
screens-cli ios <project-name>
\end{verbatim}

  This creates your project in the folder
  \texttt{platforms/ios/\textless{}project-name\textgreater{}}.
\item
  Run the following in
  \texttt{platforms/ios/\textless{}project-name\textgreater{}}:

\begin{verbatim}
pod install
\end{verbatim}
\item
  Open the \texttt{\textless{}project-name\textgreater{}.xcworkspace}
  file with Xcode.
\end{enumerate}

\subsection{Installing and Configuring Cordova
Manually}\label{installing-and-configuring-cordova-manually-1}

Follow these steps to install and configure Cordova:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Follow \href{https://cordova.apache.org/\#getstarted}{the Cordova
  getting started guide} to install Cordova, create a Cordova project,
  and add the iOS platform to your Cordova project.
\item
  Install the
  \href{https://www.npmjs.com/package/cordova-plugin-ionic-wkwebview-engine}{Cordova
  \texttt{WKWebView} engine}:

\begin{verbatim}
cordova plugin add cordova-plugin-wkwebview-engine
\end{verbatim}
\item
  Install any other Cordova plugins you want to use in your app. You can
  use \texttt{cordova\ plugin} to view the currently installed plugins.
\item
  Copy the following files and folders from your Cordova project to your
  iOS project's root folder:

  \begin{itemize}
  \tightlist
  \item
    \texttt{platforms/ios/\textless{}your-cordova-project\textgreater{}/config.xml}
  \item
    \texttt{platforms/ios/\textless{}your-cordova-project\textgreater{}/Plugins}
  \item
    \texttt{platforms/ios/www}
  \end{itemize}
\item
  In the \texttt{config.xml} file you just copied to your iOS project's
  root folder, add
  \texttt{\textless{}allow-navigationhref="*"\ /\textgreater{}} below
  \texttt{\textless{}access\ origin="*"\ /\textgreater{}}.
\end{enumerate}

\subsection{Using Cordova in Web
Screenlet}\label{using-cordova-in-web-screenlet-1}

Now that you've installed and configured Cordova in your iOS project,
you're ready to use it with Web Screenlet. Follow these steps to do so:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/rendering-web-pages-in-your-ios-app}{Insert
  and configure Web Screenlet in your app}.
\item
  When you set Web Screenlet's parameters via the
  \texttt{WebScreenletConfigurationBuilder} object, call the
  \texttt{enableCordova()} method. For example, this code adds a local
  JavaScript file via \texttt{addJs} and then calls
  \texttt{enableCordova()} before loading the configuration and the
  Screenlet:

\begin{verbatim}
let configuration = WebScreenletConfigurationBuilder(url: "url")
    .addJs(localFile: "call")
    .enableCordova()
    .load()

webScreenlet?.configuration = configuration
webScreenlet?.load();
\end{verbatim}
\end{enumerate}

That's it! Note, however, that you may also need to invoke Cordova from
a JavaScript file, depending on what you're doing. For example, to use
\href{https://www.npmjs.com/package/cordova-plugin-call-number}{the
Cordova plugin \texttt{cordova-plugin-call-number}} to call a number,
then you must add a JavaScript file with the following code:

\begin{verbatim}
function callNumber() {
    //This line triggers the Cordova plugin and makes a call
    window.plugins.CallNumber.callNumber(null, function(){ alert("Calling failed.") }, "900000000", true);
}

setTimeout(callNumber, 3000);
\end{verbatim}

If you run the app containing this code and wait three seconds, the
plugin activates and calls the number in the JavaScript file.

Great! Now you know how to use Web Screenlet with Cordova.

\subsection{Related Topics}\label{related-topics-264}

\href{/docs/7-1/tutorials/-/knowledge_base/t/rendering-web-pages-in-your-ios-app}{Rendering
Web Pages in Your iOS App}

\href{/docs/7-1/reference/-/knowledge_base/r/web-screenlet-for-ios}{Web
Screenlet for iOS}

\section{Using OAuth 2 in Liferay Screens for
iOS}\label{using-oauth-2-in-liferay-screens-for-ios}

You can use \href{https://oauth.net/2/}{OAuth 2} to authenticate using
\href{/docs/7-1/reference/-/knowledge_base/r/loginscreenlet-for-ios}{Login
Screenlet} with the following
\href{https://oauth.net/2/grant-types/}{OAuth 2 grant types}:

\begin{itemize}
\item
  \href{https://oauth.net/2/grant-types/authorization-code/}{\textbf{Authorization
  Code (PKCE for native apps):}} Redirects users to a page in their
  mobile browser where they enter their credentials. Following login,
  the browser redirects users back to the mobile app. User credentials
  can't be compromised via the app because it never accesses them---it
  uses a token that can be revoked. This is also useful if users don't
  want to enter their credentials in the app. For example, users may not
  want to enter their Twitter credentials directly in a 3rd-party
  Twitter app, preferring instead to authenticate via Twitter's official
  site. Note that the site you redirect to for authentication must have
  OAuth 2 implemented.
\item
  \href{https://oauth.net/2/grant-types/password/}{\textbf{Resource
  Owner Password:}} Users authenticate by entering their credentials
  directly in the app.
\item
  \href{https://oauth.net/2/grant-types/client-credentials/}{\textbf{Client
  Credentials:}} Authenticates without requiring user interaction. This
  is useful when the app needs to access its own resources, not those of
  a specific user.
\end{itemize}

This tutorial shows you how to use these grant types with Login
Screenlet. Note that before getting started, you may want to see
\href{/docs/7-1/deploy/-/knowledge_base/d/oauth-2-0}{Liferay DXP's OAuth
2.0 documentation} for instructions on registering an OAuth 2.0
application in the portal.

\subsection{Authorization Code (PKCE)}\label{authorization-code-pkce-1}

Follow these steps to use the Authorization Code grant type with Login
Screenlet:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Configure the URL where the mobile browser redirects after the user
  authenticates. To do this, follow the first two steps in the
  \href{/docs/7-1/tutorials/-/knowledge_base/t/using-oauth-2-in-the-ios-mobile-sdk\#authorization-code-pkce}{Mobile
  SDK's Authorization Code instructions}. Note that you must configure
  this URL in both the portal and your iOS app.
\item
  Set Login Screenlet's \texttt{loginMode} attribute to
  \texttt{oauth2Redirect}. There are two ways to do this:

  \begin{itemize}
  \item
    In code, as the Login Screenlet instance's \texttt{authType} or
    \texttt{loginMode} property:

\begin{verbatim}
loginScreenlet.authType = .oauth2Redirect
// or
loginScreenlet.loginMode = "oauth2redirect"
\end{verbatim}

    Note that \texttt{oauth2redirect} must be a string when set to
    \texttt{loginMode}.
  \item
    In Interface Builder, as the value of the \emph{Login Mode}
    attribute. Do this the same way you set other Screenlet attributes
    (via the Attributes inspector, with the Screenlet selected in the
    storyboard). Be sure to enter \texttt{oauth2redirect} with no period
    preceding it.
  \end{itemize}
\item
  Set Login Screenlet's \texttt{oauth2clientId} attribute to the ID of
  the portal's OAuth 2 application that you want to use. To find this
  value, navigate to that application in the portal's OAuth 2 Admin
  portlet.
\item
  Set Login Screenlet's \texttt{oauth2redirectUrl} attribute to the URL
  you configured in step 1.
\item
  In your \texttt{AppDelegate}'s \texttt{application(\_:open:options:)}
  method, call the \texttt{SessionContext} method
  \texttt{oauth2ResumeAuthorization} with the URL. This notifies Liferay
  Screens when the redirect has been performed. For more information on
  the \texttt{application(\_:open:options:)} method, see the section
  \emph{Handle Incoming URLs} in
  \href{https://developer.apple.com/documentation/uikit/core_app/communicating_with_other_apps_using_custom_urls}{Apple's
  documentation on using custom URLs}:

\begin{verbatim}
func application(_ app: UIApplication, open url: URL, 
    options: [UIApplicationOpenURLOptionsKey : Any] = [:]) -> Bool {
        return SessionContext.oauth2ResumeAuthorization(url: url)
}
\end{verbatim}
\end{enumerate}

Note that you can cancel the authorization at any time by calling
\texttt{SessionContext.oauth2Cancel()}.

\subsection{Resource Owner Password}\label{resource-owner-password-1}

Follow these steps to use the Resource Owner Password grant type with
Login Screenlet:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Set Login Screenlet's \texttt{loginMode} attribute to
  \texttt{oauth2UsernameAndPassword}. There are two ways to do this:

  \begin{itemize}
  \item
    In code, as the Login Screenlet instance's \texttt{authType} or
    \texttt{loginMode} property:

\begin{verbatim}
loginScreenlet.authType = .oauth2UsernameAndPassword
// or
loginScreenlet.loginMode = "oauth2UsernameAndPassword"
\end{verbatim}

    Note that \texttt{oauth2UsernameAndPassword} must be a string when
    setting \texttt{loginMode}.
  \item
    In Interface Builder, as the value of the \emph{Login Mode}
    attribute. Do this the same way you set other Screenlet attributes
    (via the Attributes inspector, with the Screenlet selected in the
    storyboard). Be sure to enter \texttt{oauth2UsernameAndPassword}
    with no period preceding it.
  \end{itemize}
\item
  Set Login Screenlet's \texttt{oauth2clientId} attribute to the ID of
  the OAuth 2 application that you want to use. To find this value,
  navigate to that application in the OAuth 2 Admin portlet.
\item
  Set Login Screenlet's \texttt{oauth2clientSecret} attribute to the
  same OAuth 2 application's client secret.
\end{enumerate}

\subsection{Client Credentials}\label{client-credentials-1}

The OAuth 2 Client Credentials grant type authenticates without
requiring user interaction. This is useful when the app needs to access
its own resources, not those of a specific user.

\noindent\hrulefill

\textbf{Warning:} The Client Credentials grant type poses a security
risk to the portal. To authenticate without user credentials, the mobile
app must contain the OAuth 2 application's client ID and client secret.
Anyone who can access those values via the mobile app can also
authenticate without user credentials.

\noindent\hrulefill

Follow these steps to use the Client Credentials grant type in your
Screens app:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Follow the
  \href{/docs/7-1/tutorials/-/knowledge_base/t/using-oauth-2-in-the-ios-mobile-sdk\#client-credentials}{iOS
  Mobile SDK instructions} for using the Client Credentials grant type.
\item
  The session object's \texttt{authentication} property contains a valid
  authentication object. Cast it to \texttt{LROAuth2Authentication} then
  pass it to the \texttt{authentication} argument of the
  \texttt{SessionContext} method \texttt{loginWithOAuth2}:

\begin{verbatim}
let auth = session.authentication as! LROAuth2Authentication

SessionContext.loginWithOAuth2(authentication: auth, userAttributes: [:])
\end{verbatim}

  This initializes the Screens \texttt{SessionContext} object,
  authenticating any Screenlets that you use in the iOS app.
\end{enumerate}

\subsection{Related Topics}\label{related-topics-265}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-oauth-2-in-the-ios-mobile-sdk}{Using
OAuth 2 in the iOS Mobile SDK}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-screenlets-in-ios-apps}{Using
Screenlets in iOS Apps}

\href{/docs/7-1/deploy/-/knowledge_base/d/oauth-2-0}{OAuth 2.0}

\section{iOS Best Practices}\label{ios-best-practices}

When developing iOS projects with Liferay Screens, there are a few best
practices that you should follow to ensure your code is as clean and
bug-free as possible. This tutorial lists these. Note that this tutorial
doesn't cover Swift coding conventions for contributing to the Liferay
Screens project on GitHub.
\href{https://github.com/liferay/liferay-screens/blob/master/ios/swift-style-guide.md}{Click
here} to see these.

\subsection{Naming Conventions}\label{naming-conventions-1}

Using the naming conventions described here leads to consistency and a
better understanding of the Screens library. This makes working with
your Screenlets much simpler.

\subsubsection{Screenlet Folder}\label{screenlet-folder-1}

Your Screenlet folder's name should indicate your Screenlet's
functionality. For example,
\href{https://github.com/liferay/liferay-screens/tree/master/ios/Framework/Core/Auth/LoginScreenlet}{Login
Screenlet's folder is named \texttt{LoginScreenlet}}.

If you have multiple Screenlets that operate on the same entity, you can
place them inside a folder named for that entity. For example,
\href{/docs/7-1/reference/-/knowledge_base/r/asset-display-screenlet-for-ios}{Asset
Display Screenlet} and
\href{/docs/7-1/reference/-/knowledge_base/r/assetlistscreenlet-for-ios}{Asset
List Screenlet} both work with Liferay assets. They're therefore in the
Screens library's
\href{https://github.com/liferay/liferay-screens/tree/master/ios/Framework/Core/Asset}{\texttt{Asset}
folder}.

\subsubsection{Screenlets}\label{screenlets-1}

Naming Screenlets properly is very important; they're the main focus of
Liferay Screens. Your Screenlet should be named with its principal
action first, followed by \emph{Screenlet}. Its Screenlet class should
also follow this pattern. For example,
\href{/docs/7-1/reference/-/knowledge_base/r/loginscreenlet-for-ios}{Login
Screenlet's} principal action is to log users into a Liferay instance.
Its Screenlet class is \texttt{LoginScreenlet}.

\subsubsection{View Models}\label{view-models-1}

You should place View Models in your Screenlet's root folder and name
them after your Screenlet. For example,
\href{/docs/7-1/reference/-/knowledge_base/r/forgotpasswordscreenlet-for-ios}{Forgot
Password Screenlet's} View Model is in the
\href{https://github.com/liferay/liferay-screens/tree/master/ios/Framework/Core/Auth/ForgotPasswordScreenlet}{\texttt{ForgotPasswordScreenlet}
folder} and is named \texttt{ForgotPasswordViewModel}.

\subsubsection{Interactors}\label{interactors-1}

You should place your Screenlet's Interactors in a folder named
\texttt{Interactors} in your Screenlet's root folder. You should name
each Interactor with its action first, followed by \emph{Interactor}.
For example,
\href{/docs/7-1/reference/-/knowledge_base/r/rating-screenlet-for-ios}{Rating
Screenlet} has three Interactors in
\href{https://github.com/liferay/liferay-screens/tree/master/ios/Framework/Core/Rating/Interactors}{its
\texttt{Interactors} folder}:

\begin{itemize}
\tightlist
\item
  \texttt{DeleteRatingInteractor}: Deletes an asset's ratings
\item
  \texttt{LoadRatingsInteractor}: Loads an asset's ratings
\item
  \texttt{UpdateRatingInteractor}: Updates an asset's ratings
\end{itemize}

\subsubsection{Connectors}\label{connectors}

Name your Connectors with the same naming conventions as Interactors,
replacing \emph{Interactor} with \emph{Connector}. If your Connector
calls a Liferay service, precede \emph{Connector} with \emph{Liferay}.
For example,
\href{https://github.com/liferay/liferay-screens/blob/master/ios/Framework/Core/Comment/Add/Connectors/CommentAddLiferayConnector.swift}{the
Connector \texttt{CommentAddLiferayConnector}} adds comments to an asset
in a Liferay instance. A Connector that retrieves a webpage's title from
any URL would be called \texttt{GetWebsiteTitleConnector}.

\subsubsection{Themes}\label{themes-2}

Place your Screenlet's Themes in a folder named \emph{Themes} in your
Screenlet's root folder. If you're creating a group of similarly styled
Themes for multiple Screenlets, however, then you can place them in a
separate \emph{Themes} folder outside of your Screenlets' root folders.
This is what the Screens Library does for
\href{https://github.com/liferay/liferay-screens/tree/master/ios/Framework/Themes}{its
Default and Flat7 Themes}. The \texttt{Default} and \texttt{Flat7}
folders each contain similarly styled Themes for several Screenlets.
Also note that each Screenlet's Theme is in its own folder. For example,
\href{/docs/7-1/reference/-/knowledge_base/r/forgotpasswordscreenlet-for-ios}{Forgot
Password Screenlet's} Default Theme is in
\href{https://github.com/liferay/liferay-screens/tree/master/ios/Framework/Themes/Default/Auth/ForgotPasswordScreenlet}{the
folder \texttt{Themes/Default/Auth/ForgotPasswordScreenlet}}. Note that
the \texttt{Auth} folder is the Screenlet's module. Creating your
Screenlets and Themes in modules isn't required.

Recall that a Theme consists of an XIB file and a View class. Name these
after your Screenlet, but with \emph{View} instead of \emph{Screenlet}.
The filenames should also be suffixed with \texttt{\_yourThemeName}. For
example, the XIB file and View class for Forgot Password Screenlet's
Default theme are \texttt{ForgotPasswordView\_default.xib} and
\texttt{ForgotPasswordView\_default.swift}, respectively.

\subsection{Avoid Hardcoded Elements}\label{avoid-hardcoded-elements}

Using constants instead of hard coded elements is a simple way to avoid
bugs. Constants reduce the likelihood that you'll make a typo when
referring to common elements. They also gather these elements in a
single location. For example, when you
\href{/docs/7-1/tutorials/-/knowledge_base/t/adding-screenlet-actions}{add
an action to your Screenlet}, each Screenlet action used as a
\texttt{restorationIdentifier} in the View class is defined as a
constant in the Screenlet class. The Screenlet class's
\texttt{createInteractor} method then uses the constants to distinguish
between the actions. If you instead typed each action manually in both
places, a typo could break your Screenlet and would be difficult to
track down. Defining the actions in one place via constants avoids this
potentially maddening complication.

Screenlet attributes, like those listed in each Screenlet's
\href{/docs/7-1/reference/-/knowledge_base/r/screenlets-in-liferay-screens-for-ios}{reference
documentation}, are another good example of this. Although you can set
these directly in Interface Builder, it's better to set them via
constants in a \texttt{plist} file. This puts all your Screenlets'
attributes in a single location that is also subject to version control.
For instructions on setting attributes in a \texttt{plist} file,
\href{/docs/7-1/tutorials/-/knowledge_base/t/preparing-ios-projects-for-liferay-screens\#configuring-communication-with-liferay}{see
the Configuring Communication with Liferay section} of the tutorial on
preparing iOS projects for Liferay Screens.

To retrieve these values in your code, you can use the following
\texttt{LiferayServerContext} methods:

\begin{itemize}
\tightlist
\item
  \texttt{propertyForKey}: Get a property as an \texttt{AnyObject}
\item
  \texttt{numberPropertyForKey}: Get a property as an \texttt{NSNumber}.
\item
  \texttt{longPropertyForKey}: Get a property as an \texttt{Int64}.
\item
  \texttt{intPropertyForKey}: Get a property as an \texttt{Int}.
\item
  \texttt{booleanPropertyForKey}: Get a property as a \texttt{Bool}.
\item
  \texttt{datePropertyForKey}: Get a property as an \texttt{NSDate}.
\item
  \texttt{stringPropertyForKey}: Get a property as a \texttt{String}.
\end{itemize}

For example, the following code retrieves the \texttt{galleryFolderId}
value and sets it to Image Gallery Screenlet's \texttt{folderId}
attribute:

\begin{verbatim}
@IBOutlet weak var imageGalleryScreenlet: ImageGalleryScreenlet? {
    didSet {
        imageGalleryScreenlet?.delegate = self
        imageGalleryScreenlet?.presentingViewController = self

        imageGalleryScreenlet?.repositoryId = LiferayServerContext.groupId
        imageGalleryScreenlet?.folderId = LiferayServerContext.longPropertyForKey("galleryFolderId")
    }
}
\end{verbatim}

\subsection{Stay in Your Layer}\label{stay-in-your-layer-1}

When accessing variables that belong to other Screenlet components, you
should avoid those outside your current Screenlet layer. This achieves
better decoupling between the layers, which tends to reduce bugs and
simplify maintenance. For an explanation of the layers in Liferay
Screens, see
\href{/docs/7-1/tutorials/-/knowledge_base/t/architecture-of-liferay-screens-for-ios}{the
architecture tutorial}. For example, you shouldn't directly access View
variables from an Interactor. This Interactor's \texttt{start} method
gets a View instance and accesses its \texttt{title} variable:

\begin{verbatim}
public class MyInteractor: Interactor {
    override func start() -> Bool {
        if let view = self.screenlet.screenletView as? MyView {
            let title = view.title
            ...
        }
    }
}
\end{verbatim}

Instead, you should pass the variable to the Interactor's initializer.
The Interactor now contains its own \texttt{title} variable, set in its
initializer:

\begin{verbatim}
public class MyInteractor: Interactor {

    public let title: String

    //MARK: Initializer

    public init(screenlet: BaseScreenlet, title: String) {
        self.title = title
        super.init(screenlet: screenlet)
    }
}
\end{verbatim}

The Screenlet class's \texttt{createInteractor} method calls this
initializer when creating an instance of the Interactor. Also note that
the Screenlet's View Model is used to retrieve the View's
\texttt{title}. As explained in the tutorial
\href{/docs/7-1/tutorials/-/knowledge_base/t/supporting-multiple-themes-in-your-ios-screenlet}{Supporting
Multiple Themes in Your iOS Screenlet}, a View Model serves as an
abstraction layer for your View, which lets you use different Themes
with a Screenlet:

\begin{verbatim}
public class MyScreenlet: BaseScreenlet {
    ...
    override public func createInteractor(name name: String, sender: AnyObject?) -> Interactor? {
        let interactor = MyInteractor(self, title: viewModel.title)
        ...
    }
    ...
}
\end{verbatim}

There are, however, a few places where you can break this rule
(otherwise it wouldn't be possible for layers to interact):

\begin{itemize}
\item
  The Screenlet class's \texttt{createInteractor} method. To get the
  user's input, this method must access the View's computed properties.
\item
  The Interactor's \texttt{onSuccess} closure in the Screenlet class.
  Here, you must retrieve the Interactor's result object.
\item
  When using a Connector, the Interactor's \texttt{completedConnector}
  method. In this method, you must retrieve the Connector's result
  object.
\item
  The Screenlet class's View Model references. This is required for the
  Screenlet to communicate with the View.
\end{itemize}

\subsection{Related Topics}\label{related-topics-266}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-ios-screenlets}{Creating
iOS Screenlets}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-ios-list-screenlets}{Creating
iOS List Screenlets}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-ios-themes}{Creating
iOS Themes}

\href{/docs/7-1/tutorials/-/knowledge_base/t/supporting-multiple-themes-in-your-ios-screenlet}{Supporting
Multiple Themes in Your iOS Screenlet}

\href{/docs/7-1/tutorials/-/knowledge_base/t/adding-screenlet-actions}{Adding
Screenlet Actions}

\href{/docs/7-1/tutorials/-/knowledge_base/t/create-and-use-a-connector-with-your-screenlet}{Create
and Use a Connector with Your Screenlet}

\href{/docs/7-1/tutorials/-/knowledge_base/t/architecture-of-liferay-screens-for-ios}{Architecture
of Liferay Screens for iOS}

\chapter{Using Xamarin with Liferay
Screens}\label{using-xamarin-with-liferay-screens}

Liferay Screens for
\href{/docs/7-1/tutorials/-/knowledge_base/t/android-apps-with-liferay-screens}{Android}
and
\href{/docs/7-1/tutorials/-/knowledge_base/t/ios-apps-with-liferay-screens}{iOS}
lets you use \emph{Screenlets} to develop native mobile apps on each
platform. Screenlets are complete visual components that you insert in
your app to leverage Liferay DXP's content and services. Since Liferay
Screens 3.0, you can use Screenlets with
\href{https://www.xamarin.com/}{Xamarin} to develop hybrid mobile apps
for Android and iOS.

The tutorials in this section show you how to develop hybrid mobile apps
using Liferay Screens and Xamarin. You'll start by preparing your
Xamarin project for Screens. You'll then learn how to use Screenlets in
Xamarin, customize their appearance, and more.

\noindent\hrulefill

\textbf{Note:} These tutorials assume that you know how to use Xamarin.
If you need assistance with Xamarin, see
\href{https://developer.xamarin.com/}{its documentation}.

\section{Preparing Xamarin Projects for Liferay
Screens}\label{preparing-xamarin-projects-for-liferay-screens}

To use Liferay Screens with Xamarin, you must install Screens in your
Xamarin project. You must then configure your project to communicate
with your Liferay DXP instance. Note that Liferay Screens for Xamarin is
released as a
\href{https://docs.microsoft.com/en-us/nuget/what-is-nuget}{NuGet}
package hosted in
\href{https://www.nuget.org/packages/LiferayScreens}{NuGet.org}.

\noindent\hrulefill

\textbf{Note:} After installation, you must configure Liferay Screens to
communicate with your Liferay DXP instance. The last section in this
tutorial shows you how to do this.

\noindent\hrulefill

\subsection{Requirements and Example
Projects}\label{requirements-and-example-projects}

Liferay Screens for Xamarin includes the bindings necessary to use all
Screenlets included with Screens. The following software is required:

\begin{itemize}
\tightlist
\item
  Visual Studio
\item
  Android SDK 4.1 (API Level 16) or above
\item
  \href{http://www.liferay.com/downloads/liferay-portal/available-releases}{Liferay
  Portal CE 7.0/7.1, or Liferay DXP}
\item
  \href{https://www.nuget.org/packages/LiferayScreens}{Liferay Screens
  NuGet package}
\end{itemize}

Also note that if you get confused or stuck while using Screens for
Xamarin, \href{https://github.com/liferay/liferay-screens}{the official
Liferay Screens repository} contains two sample Xamarin projects that
you can reference:

\begin{itemize}
\item
  \href{https://github.com/liferay/liferay-screens/tree/develop/xamarin/Samples/Showcase-Android}{\textbf{Showcase-Android:}}
  An example app for Xamarin.Android containing all the currently
  available Screenlets.
\item
  \href{https://github.com/liferay/liferay-screens/tree/develop/xamarin/Samples/Showcase-iOS}{\textbf{Showcase-iOS:}}
  An example app for Xamarin.iOS containing all the currently available
  Screenlets.
\end{itemize}

\subsection{Securing JSON Web
Services}\label{securing-json-web-services-2}

Each Screenlet in Liferay Screens calls one or more of Liferay DXP's
JSON web services, which are enabled by default. The Screenlet reference
documentation for
\href{/docs/7-1/reference/-/knowledge_base/r/screenlets-in-liferay-screens-for-android}{Android}
and
\href{/docs/7-1/reference/-/knowledge_base/r/screenlets-in-liferay-screens-for-ios}{iOS}
lists the web services that each Screenlet calls. To use a Screenlet,
its web services must be enabled in the portal. It's possible, however,
to disable the web services needed by Screenlets you're not using. For
instructions on this, see the tutorial
\href{/docs/7-1/tutorials/-/knowledge_base/t/configuring-json-web-services}{Configuring
JSON Web Services}. You can also use
\href{/docs/7-1/tutorials/-/knowledge_base/t/service-access-policies}{Service
Access Policies} for more fine-grained control over accessible services.

\subsection{Install Liferay Screens in Xamarin
Solutions}\label{install-liferay-screens-in-xamarin-solutions}

Follow these steps to install Liferay Screens in your Xamarin project:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open your project in Visual Studio.
\item
  Right click your project's \emph{Packages} folder and then select
  \emph{Add packages\ldots{}}.
\item
  Look for \emph{LiferayScreens} and install the latest version.
\item
  Accept the license agreements for any dependencies. These are
  necessary to use Liferay Screens in Xamarin.
\item
  Check your configuration one of these ways:

  \begin{itemize}
  \tightlist
  \item
    Rebuild and execute your project, and import a Liferay Screens path
    (e.g., \texttt{Com.Liferay.Mobile.Screens.Auth.Login}).
  \item
    In your project, select \emph{References} → \emph{From Packages} and
    look for the \texttt{LiferayScreens*} file. Open that file in the
    Assembly Browser. You should then see all the available Liferay
    Screens files.
  \end{itemize}
\end{enumerate}

Next, you'll set up communication with Liferay DXP.

\subsection{Configuring Communication with Liferay
DXP}\label{configuring-communication-with-liferay-dxp-2}

Before using Liferay Screens, you must configure your project to
communicate with your Liferay DXP instance. To do this, you must provide
your project with the following information:

\begin{itemize}
\tightlist
\item
  Your Liferay DXP instance's ID.
\item
  The ID of the Liferay DXP site your app needs to communicate with.
\item
  Your Liferay DXP instance's version.
\item
  Any other information required by specific Screenlets.
\end{itemize}

Fortunately, this is straightforward. Do the following in your Xamarin
projects:

\begin{itemize}
\item
  For Xamarin.Android, create a new file called
  \texttt{server\_context.xml} in the \texttt{Resources/values} folder.
  Add the following code to this file:

\begin{verbatim}
<?xml version="1.0" encoding="utf-8"?>
<resources>

    <!-- Change these values for your portal installation -->
    <string name="liferay_server">http://10.0.2.2:8080</string>

    <integer name="liferay_company_id">20116</integer>
    <integer name="liferay_group_id">20143</integer>

    <integer name="liferay_portal_version">71</integer>

</resources>
\end{verbatim}
\item
  For Xamarin.iOS, create a new file called
  \texttt{liferay-server-context.plist} in the \texttt{Resources}
  folder. Add the following code to this file:

\begin{verbatim}
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>server</key>
    <string>http://localhost:8080</string>
    <key>version</key>
    <integer>71</integer>
    <key>companyId</key>
    <real>20116</real>
    <key>groupId</key>
    <real>20143</real>
</dict>
</plist>
\end{verbatim}
\end{itemize}

Make sure to change these values to match those of your Liferay DXP
instance. The server address \texttt{http://10.0.2.2:8080} is suitable
for testing with Android Studio's emulator, because it corresponds to
\texttt{localhost:8080} through the emulator. If you're using the
Genymotion emulator, you should, however, use \texttt{192.168.56.1}
instead of \texttt{localhost}.

The \texttt{liferay\_company\_id} and \texttt{companyId} values are your
Liferay DXP instance's ID. You can find this in your Liferay DXP
instance at \emph{Control Panel} → \emph{Configuration} → \emph{Virtual
Instances}. The instance's ID is in the \emph{Instance ID} column.

The \texttt{liferay\_group\_id} and \texttt{groupId} values are the ID
of the site your app needs to communicate with. To find this value,
first go to the site in your Liferay DXP instance that you want your app
to communicate with. In the \emph{Site Administration} menu, select
\emph{Configuration} → \emph{Site Settings}. The site ID is listed at
the top of the \emph{General} tab.

The \texttt{liferay\_portal\_version} and \texttt{version} value
\texttt{71} tells Screens that it's communicating with a Liferay CE
Portal 7.1 or Liferay DXP 7.1 instance. Here are the supported values
and the portal versions they correspond to:

\begin{itemize}
\tightlist
\item
  \texttt{71}: Liferay CE Portal 7.1 or Liferay DXP 7.1
\item
  \texttt{70}: Liferay CE Portal 7.0 or Liferay DXP 7.0
\item
  \texttt{62}: Liferay Portal 6.2 CE/EE
\end{itemize}

You can also configure Screenlet properties in
\texttt{server\_context.xml} and \texttt{liferay-server-context.plist}.
The example \texttt{server\_context.xml} properties listed below,
\texttt{liferay\_recordset\_id} and \texttt{liferay\_recordset\_fields},
enable DDL Form Screenlet and DDL List Screenlet to interact with a
Liferay DXP instance's DDLs:

\begin{verbatim}
<!-- Change these values for your portal installation -->

<integer name="liferay_recordset_id">20935</integer>
<string name="liferay_recordset_fields">Title</string>
\end{verbatim}

For additional examples of these files, see the
\href{https://github.com/liferay/liferay-screens/blob/develop/xamarin/Samples/Showcase-Android/Resources/values/server_context.xml}{Showcase-Android}
and
\href{https://github.com/liferay/liferay-screens/blob/develop/xamarin/Samples/Showcase-iOS/Resources/liferay-server-context.plist}{Showcase-iOS}
sample projects.

Super! Your Xamarin projects are ready for Liferay Screens.

\subsection{Related Topics}\label{related-topics-267}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-screenlets-in-xamarin-apps}{Using
Screenlets in Xamarin Apps}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-views-in-xamarin-android}{Using
Views in Xamarin.Android}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-themes-in-xamarin-ios}{Using
Themes in Xamarin.iOS}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-xamarin-views-and-themes}{Creating
Xamarin Views and Themes}

\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-screens-for-xamarin-troubleshooting-and-faqs}{Liferay
Screens for Xamarin Troubleshooting and FAQs}

\section{Using Screenlets in Xamarin
Apps}\label{using-screenlets-in-xamarin-apps}

You can start using Screenlets once you've
\href{/docs/7-1/tutorials/-/knowledge_base/t/preparing-xamarin-projects-for-liferay-screens}{prepared}
your Xamarin project to use Liferay Screens. The Screenlet reference
documentation describes the available Screenlets:

\begin{itemize}
\tightlist
\item
  \href{/docs/7-1/reference/-/knowledge_base/r/screenlets-in-liferay-screens-for-android}{Screenlets
  in Liferay Screens for Android}
\item
  \href{/docs/7-1/reference/-/knowledge_base/r/screenlets-in-liferay-screens-for-ios}{Screenlets
  in Liferay Screens for iOS}
\end{itemize}

Using Screenlets is very straightforward. This tutorial shows you how to
insert and configure Screenlets in your Xamarin app. You'll be a
Screenlet master in no time!

\subsection{Xamarin.iOS}\label{xamarin.ios}

Follow these steps to insert Screenlets in your Xamarin.iOS app:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Insert a view (\texttt{UIView}) in your storyboard (in Visual Studio's
  iOS Designer or Xcode's Interface Builder). Note that if you're
  editing an XIB file, you must insert the view inside the XIB's parent
  view.
\item
  Set the view's class to the class of the Screenlet you want to use.
  For example, Login Screenlet's class is \texttt{LoginScreenlet}. If
  you're using Xamarin Designer for iOS in Visual Studio, you must also
  give the view a name so you can refer to it in your view controller's
  code.

  For example, the following video shows the first two steps for
  inserting Login Screenlet in a Xamarin Designer for iOS storyboard.
\item
  Configure the Screenlet's behavior in your app by implementing the
  Screenlet's delegate in your view controller. To configure your app to
  listen for events the Screenlet triggers, implement the Screenlet's
  delegate methods and register the view controller as the delegate.
  Make sure to annotate each delegate method with
  \texttt{{[}Export(...){]}}. This ensures the method can be called from
  Objective-C, which is required for it to work in Screens. You should
  also set any Screenlet attributes you need. Each Liferay Screenlet's
  \href{/docs/7-1/reference/-/knowledge_base/r/screenlets-in-liferay-screens-for-ios}{reference
  documentation} lists its available attributes and delegate methods.
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** In Liferay Screens for Xamarin, Screenlet delegates are prefixed
 with an `I`. For example, Login Screenlet's delegate in native code is
 `LoginScreenletDelegate`, while in Xamarin it's `ILoginScreenletDelegate`.
\end{verbatim}

\noindent\hrulefill

\begin{verbatim}
For example, here's a view controller that implements Login Screenlet's 
delegate, `ILoginScreenletDelegate`. Note that the `ViewDidLoad()` method 
sets the Screenlet's `ThemeName` attribute (`ThemeName` is available for all 
Screenlets via `BaseScreenlet` inheritance) and registers the view 
controller as the delegate. This view controller also implements the 
`OnLoginResponseUserAttributes` method, which is called upon successful 
login. Also note this method's `[Export(...)]` annotation: 

    public partial class ViewController : UIViewController, ILoginScreenletDelegate
    {
        protected ViewController(IntPtr handle) : base(handle) {}

        public override void ViewDidLoad()
        {
            base.ViewDidLoad();

            // Set the Screenlet's attributes
            this.loginScreenlet.ThemeName = "demo";

            // Registers this view controller as the delegate 
            this.loginScreenlet.Delegate = this;
        }

        ...

        // Delegate methods

        [Export("screenlet:onLoginResponseUserAttributes:")]
        public virtual void OnLoginResponseUserAttributes(BaseScreenlet screenlet, 
            NSDictionary<NSString, NSObject> attributes)
        {
            ...
        }
    }
\end{verbatim}

See
\href{https://github.com/liferay/liferay-screens/tree/develop/xamarin/Samples/Showcase-iOS/ViewController}{the
Showcase-iOS app} for more examples of view controllers that use
Liferay's Screenlets.

\subsection{Xamarin.Android}\label{xamarin.android}

Follow these steps to insert Screenlets in your Xamarin.Android app:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open your app's layout AXML file and insert the Screenlet's XML in
  your activity or fragment layout. For example, here's Login
  Screenlet's XML in an activity's \texttt{FrameLayout}:

\begin{verbatim}
<?xml version="1.0" encoding="utf-8"?>
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent">
    <com.liferay.mobile.screens.auth.login.LoginScreenlet
        android:id="@+id/login_screenlet"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        app:basicAuthMethod="email"/>
</FrameLayout>
\end{verbatim}
\item
  Set the Screenlet's attributes. If it's a Liferay Screenlet, refer to
  the
  \href{/docs/7-1/reference/-/knowledge_base/r/screenlets-in-liferay-screens-for-android}{Screenlet
  reference documentation} to learn the Screenlet's required and
  supported attributes. This screenshot shows Login Screenlet's
  attributes being set:

  \begin{figure}
  \centering
  \includegraphics{./images/screens-xamarin-android-screenlet-attributes.png}
  \caption{You can set a Screenlet's attributes via the app's layout
  AXML file.}
  \end{figure}
\item
  To configure your app to listen for events the Screenlet triggers,
  implement the Screenlet's listener interface in your activity or
  fragment class. Refer to the
  \href{/docs/7-1/reference/-/knowledge_base/r/screenlets-in-liferay-screens-for-android}{Screenlet's
  reference documentation} to learn its listener interface. Then
  register that activity or fragment as the Screenlet's listener.
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** In Liferay Screens for Xamarin, Screenlet listeners are prefixed
 with an `I`. For example, Login Screenlet's listener in native code is
 `LoginListener`, while in Xamarin it's `ILoginListener`.
\end{verbatim}

\noindent\hrulefill

\begin{verbatim}
For example, the following activity class implements Login Screenlet's 
`ILoginListener` interface, and registers itself as the Screenlet's 
listener via `loginScreenlet.Listener = this`. Note that the listener
methods `OnLoginSuccess` and `OnLoginFailure` are called when login succeeds 
and fails, respectively. In this case, these methods print simple toast 
messages: 

    [Activity]
    public class LoginActivity : Activity, ILoginListener
    {
        LoginScreenlet loginScreenlet;

        protected override void OnCreate(Bundle savedInstanceState)
        {
            base.OnCreate(savedInstanceState);
            SetContentView(Resource.Layout.LoginView);

            loginScreenlet = (LoginScreenlet) FindViewById(Resource.Id.login_screenlet);
            loginScreenlet.Listener = this;
        }

        // ILoginListener

        public void OnLoginSuccess(User p0)
        {
            Toast.MakeText(this, "Login success: " + p0.Id, ToastLength.Short).Show();
        }

        public void OnLoginFailure(Java.Lang.Exception p0)
        {
            Android.Util.Log.Debug("LoginScreenlet", $"Login failed: {p0.Message}");
        }

    }
\end{verbatim}

See
\href{https://github.com/liferay/liferay-screens/tree/develop/xamarin/Samples/Showcase-Android/Activities}{the
Showcase-Android app} for more examples of activities that use Liferay's
Screenlets.

\subsection{Related Topics}\label{related-topics-268}

\href{/docs/7-1/tutorials/-/knowledge_base/t/preparing-xamarin-projects-for-liferay-screens}{Preparing
Xamarin Projects for Liferay Screens}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-views-in-xamarin-android}{Using
Views in Xamarin.Android}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-themes-in-xamarin-ios}{Using
Themes in Xamarin.iOS}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-xamarin-views-and-themes}{Creating
Xamarin Views and Themes}

\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-screens-for-xamarin-troubleshooting-and-faqs}{Liferay
Screens for Xamarin Troubleshooting and FAQs}

\section{Using Views in
Xamarin.Android}\label{using-views-in-xamarin.android}

You can use a Liferay Screens \emph{View} to set a Screenlet's look and
feel independent of the Screenlet's core functionality. Liferay's
Screenlets come with several Views, and more are being developed by
Liferay and the community.
\href{/docs/7-1/reference/-/knowledge_base/r/screenlets-in-liferay-screens-for-android}{The
Screenlet reference documentation} lists the Views available for each
Screenlet included with Screens. This tutorial shows you how to use
Views in Xamarin.Android.

\subsection{Views and View Sets}\label{views-and-view-sets-1}

The concepts and components that comprise Views and View Sets in Liferay
Screens for Xamarin are the same as they are in Liferay Screens for
Android. For a brief description of these components, see
\href{/docs/7-1/tutorials/-/knowledge_base/t/using-views-in-android-screenlets\#views-and-view-sets}{the
section on Views and View Sets} in the general tutorial on using Views.
For a detailed description of the View layer in Liferay Screens, see the
tutorial
\href{/docs/7-1/tutorials/-/knowledge_base/t/architecture-of-liferay-screens-for-android}{Architecture
of Liferay Screens for Android}.

\subsection{Using Views}\label{using-views-1}

Follow these steps to use a View in Xamarin.Android:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Copy the layout of the View you want to use from the
  \href{https://github.com/liferay/liferay-screens}{Liferay Screens
  repository} to your app's \texttt{res/layout} folder. Alternatively,
  you can create a new layout. The following links list the View layouts
  available in each View Set:

  \begin{itemize}
  \tightlist
  \item
    \href{https://github.com/liferay/liferay-screens/tree/master/android/library/src/main/res/layout}{Default}
  \item
    \href{https://github.com/liferay/liferay-screens/tree/master/android/viewsets/material/src/main/res/layout}{Material}
  \item
    \href{https://github.com/liferay/liferay-screens/tree/master/android/viewsets/westeros/src/main/res/layout}{Westeros}
  \end{itemize}

  For example, this is Login Screenlet's Material View,
  \texttt{login\_material.xml}:

\begin{verbatim}
<com.liferay.mobile.screens.viewsets.material.auth.login.LoginView
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:liferay="http://schemas.android.com/apk/res-auto"
    android:paddingLeft="40dp"
    android:paddingRight="40dp"
    style="@style/default_screenlet">

<LinearLayout
    android:id="@+id/basic_authentication_login"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="vertical">

    <LinearLayout style="@style/material_row">

        <ImageView
            android:id="@+id/drawable_login"
            android:contentDescription="@string/user_login_icon"
            android:src="@drawable/material_email"
            style="@style/material_icon"/>

        <EditText
            android:id="@+id/liferay_login"
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            android:layout_marginTop="8dp"
            android:inputType="text"
            android:labelFor="@+id/liferay_login"/>

    </LinearLayout>

    <LinearLayout style="@style/material_row">

        <ImageView
            android:id="@+id/drawable_password"
            android:contentDescription="@string/password_icon"
            android:src="@drawable/material_https"
            style="@style/material_icon"/>

        <EditText
            android:id="@+id/liferay_password"
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            android:layout_marginTop="8dp"
            android:hint="@string/password"
            android:inputType="textPassword"/>

    </LinearLayout>

    <FrameLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_marginTop="32dp">

        <Button
            android:id="@+id/liferay_login_button"
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            android:layout_margin="10dp"
            android:text="@string/sign_in"/>

        <com.liferay.mobile.screens.base.ModalProgressBar
            android:id="@+id/liferay_progress"
            android:layout_width="wrap_content"
            android:layout_height="match_parent"
            android:layout_gravity="center_vertical|left"
            android:layout_margin="10dp"
            android:theme="@style/white_theme"
            android:visibility="invisible"
            liferay:actionViewId="@id/liferay_login_button"/>
    </FrameLayout>
</LinearLayout>

<Button
    android:id="@+id/oauth_authentication_login"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:text="@string/authorize_application"
    android:visibility="gone"/>

</com.liferay.mobile.screens.viewsets.material.auth.login.LoginView>
\end{verbatim}
\item
  When you insert the Screenlet's XML in the layout of the activity or
  fragment you want the Screenlet to appear in, set the
  \texttt{liferay:layoutId} attribute to the View's layout. For example,
  here's Login Screenlet's XML with \texttt{liferay:layoutId} set to
  \texttt{@layout/login\_material}, which specifies Login Screenlet's
  Material View from the previous step:

\begin{verbatim}
<com.liferay.mobile.screens.auth.login.LoginScreenlet
    android:id="@+id/login_screenlet"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    liferay:layoutId="@layout/login_material"
    />
\end{verbatim}
\item
  If the View you want to use is part of a View Set (e.g., the Material
  View is part of the Material View Set), your app or activity's theme
  must also inherit the theme that defines that View Set's styles. For
  example, the following code in an app's
  \texttt{Resources/values/Styles.xml} tells
  \texttt{AppTheme.NoActionBar} to use the Material View Set as its
  parent theme:

\begin{verbatim}
<resources>
    <style name="AppTheme.NoActionBar" parent="material_theme">
        <item name="colorPrimary">@color/colorPrimary</item>
        <item name="colorPrimaryDark">@color/colorPrimaryDark</item>
        <item name="colorAccent">@color/colorAccent</item>

        <item name="windowActionBar">false</item>
        <item name="windowNoTitle">true</item>
    </style>
    ...
</resources>
\end{verbatim}

  To use the Default or Westeros View Set, inherit
  \texttt{default\_theme} or \texttt{westeros\_theme}, respectively.
\end{enumerate}

Awesome! Now you know how to use Views to spruce up your Xamarin.Android
Screenlets.

\subsection{Related Topics}\label{related-topics-269}

\href{/docs/7-1/tutorials/-/knowledge_base/t/preparing-xamarin-projects-for-liferay-screens}{Preparing
Xamarin Projects for Liferay Screens}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-screenlets-in-xamarin-apps}{Using
Screenlets in Xamarin Apps}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-themes-in-xamarin-ios}{Using
Themes in Xamarin.iOS}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-xamarin-views-and-themes}{Creating
Xamarin Views and Themes}

\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-screens-for-xamarin-troubleshooting-and-faqs}{Liferay
Screens for Xamarin Troubleshooting and FAQs}

\section{Using Themes in Xamarin.iOS}\label{using-themes-in-xamarin.ios}

\emph{Themes} in Xamarin.iOS are analogous to \emph{Views} in
Xamarin.Android. Like Views, Themes let you set a Screenlet's look and
feel independent of the Screenlet's core functionality. Liferay's
Screenlets come with several Themes, and more are being developed by
Liferay and the community.
\href{/docs/7-1/reference/-/knowledge_base/r/screenlets-in-liferay-screens-for-ios}{The
Screenlet reference documentation} lists the Themes available for each
Screenlet included with Screens. This tutorial shows you how to use
Themes in Xamarin.iOS.

\subsection{Installing and Using
Themes}\label{installing-and-using-themes}

Follow these steps to install and use a Theme:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  If the Theme is packaged as a NuGet dependency, you can install it in
  your project via NuGet. To do so, right-click your project's
  \emph{Packages} folder and then select \emph{Add packages\ldots{}}.
  Then search for the Theme and install it. If the Theme isn't available
  in NuGet, you can drag and drop the Theme's folder directly into your
  project.
\item
  To use the installed Theme, set its name to the Screenlet instance's
  \texttt{ThemeName} property in your view controller that implements
  the Screenlet's delegate. All Screenlets inherit this property from
  \texttt{BaseScreenlet}. For example, this code sets Login Screenlet's
  \texttt{ThemeName} property to the Material Theme:

\begin{verbatim}
loginScreenlet.ThemeName = "material"
\end{verbatim}

  If you don't set this property or enter an invalid or missing Theme,
  the Screenlet uses its Default Theme. Each Screenlet's available
  Themes are listed in the \emph{Themes} section of the Screenlet's
  \href{/docs/7-1/reference/-/knowledge_base/r/screenlets-in-liferay-screens-for-ios}{reference
  documentation}.
\end{enumerate}

Great, that's it! Now you know how to use Themes to dress up Screenlets
in your Xamarin.iOS apps.

\subsection{Related Topics}\label{related-topics-270}

\href{/docs/7-1/tutorials/-/knowledge_base/t/preparing-xamarin-projects-for-liferay-screens}{Preparing
Xamarin Projects for Liferay Screens}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-screenlets-in-xamarin-apps}{Using
Screenlets in Xamarin Apps}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-views-in-xamarin-android}{Using
Views in Xamarin.Android}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-xamarin-views-and-themes}{Creating
Xamarin Views and Themes}

\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-screens-for-xamarin-troubleshooting-and-faqs}{Liferay
Screens for Xamarin Troubleshooting and FAQs}

\section{Creating Xamarin Views and
Themes}\label{creating-xamarin-views-and-themes}

Recall that Views in Xamarin.Android and Themes in Xamarin.iOS are
analogous components that let you customize a Screenlet's look and feel.
You can use the Views and Themes provided by Liferay Screens, or write
your own. Writing your own lets you tailor a Screenlet's UI to your
exact specifications. This tutorial shows you how to do this.

You can create Views and Themes from scratch, or use an existing one as
a foundation. Views and Themes include a View class for implementing the
Screenlet UI's behavior, a Screenlet class for notifying
listeners/delegates and invoking Interactors, and an AXML or XIB file
for defining the UI.

There are also different types of Views and Themes. These are discussed
in the tutorials on creating
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-android-views}{Views}
and
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-ios-themes}{Themes}
in native code. You should read those tutorials before creating Views in
Xamarin.Android or Themes in Xamarin.iOS.

First, you'll determine where to create your View or Theme.

\subsection{Determining the Location of Your View or
Theme}\label{determining-the-location-of-your-view-or-theme}

If you plan to reuse or redistribute your View or Theme, create it in a
new Xamarin project as a
\href{https://developer.xamarin.com/guides/cross-platform/application_fundamentals/nuget-multiplatform-libraries/}{multiplatform
library for code sharing}. Otherwise, create it in your app's project.

\subsection{Creating a Xamarin.Android
View}\label{creating-a-xamarin.android-view}

Creating Views for Xamarin.Android is very similar to doing so in native
code. You can create the following View types:

\begin{itemize}
\item
  \textbf{Themed View:} Creating a Themed View in Xamarin.Android is
  identical
  \href{/docs/7-1/tutorials/-/knowledge_base/t/themed-views}{to doing so
  in native code}. In Xamarin.Android, however, only the Default View
  Set is available to extend.
\item
  \textbf{Child View:} Creating a Child View in Xamarin.Android is
  identical \href{/docs/7-1/tutorials/-/knowledge_base/t/child-views}{to
  doing so in native code}.
\item
  \textbf{Extended View:} Creating an Extended View in Xamarin.Android
  differs from doing so in native code. The next section shows you how.
\end{itemize}

\subsubsection{Extended View}\label{extended-view}

To create an Extended View in Xamarin.Android, follow
\href{/docs/7-1/tutorials/-/knowledge_base/t/extended-views}{the steps
for creating an Extended View in native code}, but make sure your custom
View class in the second step is the appropriate C\# class. For example,
here's the View class from the native code tutorial, converted to C\#:

\begin{verbatim}
using System;
using Android.Content;
using Android.Util;
using Com.Liferay.Mobile.Screens.Viewsets.Defaultviews.Auth.Login;

namespace ShowcaseAndroid.CustomViews
{
    public class LoginCheckPasswordView : LoginView
    {
        public LoginCheckPasswordView(Context context) : base(context) { }

        public LoginCheckPasswordView(Context context, IAttributeSet attributes) : base(context, attributes) {}

        public LoginCheckPasswordView(Context context, IAttributeSet attributes, int defaultStyle) : base(context, attributes, defaultStyle) {}

        public override void OnClick(Android.Views.View view)
        {
            // compute password strength
            if (PasswordIsStrong) {
                base.OnClick(view);
            }
            else {
                // Present user message
            }
        }
    }
}
\end{verbatim}

Awesome! Now you know how to create Extended Views in Xamarin.Android.

\subsection{Creating a Xamarin.iOS
Theme}\label{creating-a-xamarin.ios-theme}

Creating Themes for Xamarin.iOS is very similar
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-ios-themes}{to
doing so in native code}. You can create the following Theme types in
Xamarin.iOS:

\begin{itemize}
\tightlist
\item
  \textbf{Child Theme:} presents the same UI components as its parent
  Theme, but lets you change their appearance and position.
\item
  \textbf{Extended Theme:} inherits its parent Theme's functionality and
  appearance, but lets you add to and modify both.
\end{itemize}

First, you'll learn how to create a Child Theme in Xamarin.iOS.

\subsubsection{Child Theme}\label{child-theme}

Child Themes leverage a parent Theme's behavior and UI components,
letting you modify the appearance and position of those components. Note
that you can't add or remove components, and the parent Theme must be a
Full Theme. The Child Theme presents visual changes with its own XIB
file and inherits the parent's View class.

Follow these steps to create a Child Theme in Xamarin.iOS:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In Visual Studio, create a new XIB file named after the Screenlet's
  View class and your Theme. By convention, an XIB file for a Screenlet
  with a View class named \texttt{LoginView} and a Theme named
  \texttt{demo} should be named \texttt{LoginView\_demo}. You can use
  content from the parent Theme's XIB file as a foundation for your new
  XIB file. In your new XIB, you can change the UI components' visual
  properties (e.g., their position and size). You mustn't change,
  however, the XIB file's custom class, outlet connection, or
  \texttt{restorationIdentifier}. These must match those of the parent
  XIB file.
\item
  In the View Controller, set the Screenlet's \texttt{ThemeName}
  property to the Theme's name. For example, this sets Login Screenlet's
  \texttt{ThemeName} property to the \texttt{demo} Theme from the first
  step:

\begin{verbatim}
this.loginScreenlet.ThemeName = "demo";
\end{verbatim}

  This causes Liferay Screens to look for the file
  \texttt{LoginView\_demo} in all apps' bundles. If that file doesn't
  exist, Screens uses the Default Theme instead
  (\texttt{LoginView\_default}).
\end{enumerate}

You can see an example of \texttt{LoginView\_demo} in
\href{https://github.com/liferay/liferay-screens/tree/develop/xamarin/Samples/Showcase-iOS/CustomViews}{the
Showcase-iOS demo app}. Fantastic! Next, you'll learn how to create an
Extended Theme.

\subsubsection{Extended Theme}\label{extended-theme}

An Extended Theme inherits another Theme's UI components and behavior,
but lets you add to or alter both. For example, you can extend the
parent Theme's View class to change the parent Theme's behavior. You can
also create a new XIB file that contains new or modified UI components.
An Extended Theme's parent must be
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-an-ios-full-theme}{a
Full Theme}.

Follow these steps to create an Extended Theme:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In Visual Studio, create a new XIB file named after the Screenlet's
  View class and your Theme. By convention, an XIB file for a Screenlet
  with a View class named \texttt{LoginView} and a Theme named
  \texttt{demo} should be named \texttt{LoginView\_demo}. You can use
  the parent Theme's XIB file as a template. Make your Theme's UI
  changes by editing your XIB file in Visual Studio's iOS Designer or
  Xcode's Interface Builder.
\item
  Create a new View class that extends the parent Theme's View class.
  You should name this class after the XIB file you just created. You
  can add to or override functionality of the parent Theme's View class.
  Here's an example that extends the View class of Login Screenlet's
  default Theme (\texttt{LoginView\_default}). Note that it changes the
  login button's background color and disables the progress presenter:

\begin{verbatim}
using LiferayScreens;
using System;

namespace ShowcaseiOS
{
    public partial class LoginView_demo : LoginView_default
    {
        public LoginView_demo (IntPtr handle) : base (handle) { }

        public override void OnCreated()
        {
            // You can change the login button color from code
            this.LoginButton.BackgroundColor = UIKit.UIColor.DarkGray;
        }

        // If you don't want a progress presenter, create an empty one
        public override IProgressPresenter CreateProgressPresenter()
        {
            return new NoneProgressPresenter();
        }
    }
}
\end{verbatim}
\item
  Set your new View class as the custom class for your Theme's XIB file:

  \begin{figure}
  \centering
  \includegraphics{./images/screens-ios-extended-theme.png}
  \caption{Set new View class in XIB Theme file.}
  \end{figure}
\end{enumerate}

Well done! Now you know how to create an Extended Theme.

\subsection{Related Topics}\label{related-topics-271}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-android-views}{Creating
Android Views (native code)}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-ios-themes}{Creating
iOS Themes (native code)}

\href{/docs/7-1/tutorials/-/knowledge_base/t/preparing-xamarin-projects-for-liferay-screens}{Preparing
Xamarin Projects for Liferay Screens}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-screenlets-in-xamarin-apps}{Using
Screenlets in Xamarin Apps}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-views-in-xamarin-android}{Using
Views in Xamarin.Android}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-themes-in-xamarin-ios}{Using
Themes in Xamarin.iOS}

\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-screens-for-xamarin-troubleshooting-and-faqs}{Liferay
Screens for Xamarin Troubleshooting and FAQs}

\section{Liferay Screens for Xamarin Troubleshooting and
FAQs}\label{liferay-screens-for-xamarin-troubleshooting-and-faqs}

Even though Liferay developed Liferay Screens for Xamarin with great
care, you may still run into some common issues. This tutorial lists
tips and solutions for these issues, as well as answers to common
questions about Screens for Xamarin.

\subsection{General Troubleshooting}\label{general-troubleshooting-1}

Before exploring specific issues, you should first make sure that you've
installed the correct versions of Visual Studio and the Mono .NET
framework. Each Screenlet's reference documentation (available for
\href{/docs/7-1/reference/-/knowledge_base/r/screenlets-in-liferay-screens-for-android}{Android}
and
\href{/docs/7-1/reference/-/knowledge_base/r/screenlets-in-liferay-screens-for-ios}{iOS})
lists these versions.

It may also help to investigate the sample Xamarin.Android and
Xamarin.iOS apps developed by Liferay. Both are good examples of how to
use Screenlets, Views (Android), and Themes (iOS):

\begin{itemize}
\tightlist
\item
  \href{https://github.com/liferay/liferay-screens/tree/develop/xamarin/Samples/Showcase-Android}{Showcase-Android}
\item
  \href{https://github.com/liferay/liferay-screens/tree/develop/xamarin/Samples/Showcase-Android}{Showcase-iOS}
\end{itemize}

If you get stuck at any point, you can post your question on our
\href{https://www.liferay.com/community/forums/-/message_boards/category/42706063}{forum}.
We're happy to assist you!

\subsection{Common Issues}\label{common-issues-1}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Build issues:

  Running \emph{Clean} in Visual Studio may not be enough. Close Visual
  Studio, remove all the \texttt{bin} and \texttt{obj} folders that
  weren't removed by the clean, then rebuild your project.
\item
  \texttt{NSUnknownKeyException} error in Xamarin.iOS:

  This error occurs when Liferay Screens for iOS has a wrong module name
  in an XIB file. You must solve this in Xcode, removing the module name
  in the XIB file's \emph{Custom Class} assignment in Interface Builder.
\item
  \texttt{The\ selector\ is\ already\ registered} error in Xamarin.iOS:

  This error occurs because one or more methods share the same name. To
  fix this, the binding file must be updated. Please file a ticket in
  our \href{https://issues.liferay.com/browse/LMW/}{Jira} or post the
  issue on our
  \href{https://www.liferay.com/community/forums/-/message_boards/category/42706063}{forum}.
\item
  Xamarin.iOS crashes unexpectedly without any error messages in the
  console:

  Check the log file. On Mac OS, do this via the Console. On Windows,
  use the Event Viewer. In the app, you must click \emph{User Reports}
  and then look for your app's name. Note that there may be more than
  one log file.
\item
  The app doesn't call delegate methods in Xamarin.iOS:

  When you implement the delegate methods in your view controller, make
  sure to annotate them with \texttt{{[}Export(...){]}}. You must also
  set the view controller to the Screenlet instance's \texttt{Delegate}
  property. Here's an example of such a view controller that implements
  Login Screenlet's delegate, \texttt{ILoginScreenletDelegate}:

\begin{verbatim}
public partial class ViewController : UIViewController, ILoginScreenletDelegate
{
    protected ViewController(IntPtr handle) : base(handle) {}

    public override void ViewDidLoad()
    {
        base.ViewDidLoad();

        this.loginScreenlet.Delegate = this;
    }

    [Export("screenlet:onLoginResponseUserAttributes:")]
    public virtual void OnLoginResponseUserAttributes(BaseScreenlet screenlet, 
        NSDictionary<NSString, NSObject> attributes)
    {
        ...
    }

    ...
}
\end{verbatim}
\end{enumerate}

\subsection{DataType Mapping}\label{datatype-mapping}

For a better understanding of Xamarin code and example apps, see this
list to compare type mapping between platforms. You must write Xamarin
apps in C\#, which has some differences compared to native code:

\begin{itemize}
\item
  Delegate (iOS) or listener (Android) classes:

  These classes are important because they listen for a Screenlet's
  events. In Liferay Screens for Xamarin, Screenlet delegates and
  listeners are prefixed with an \texttt{I}. For example, Login
  Screenlet's delegate in native code is
  \texttt{LoginScreenletDelegate}, while in Xamarin it's
  \texttt{ILoginScreenletDelegate}. Similarly, Login Screenlet's
  listener in native code is \texttt{LoginListener}, while in Xamarin
  it's \texttt{ILoginListener}. Use a similar naming scheme when you
  define a class/interface pair where the class is a standard
  implementation of the interface.
\item
  Getter and setter methods:

  To get or set a value in native code, you use its getter and setter
  methods. In Liferay Screens for Xamarin, you should convert such
  methods to properties. If you have only one of these methods, you can
  call the method itself. For example:

\begin{verbatim}
// If you implemented a setter and a getter, call the property
loginScreenlet.Listener = this;

// Otherwise, call the method
loginScreenlet.getListener();
\end{verbatim}
\item
  Pascal case convention:

  C\# code is usually written in Pascal case. However, you should use
  Camel case for protected instance fields or parameters.
\end{itemize}

\subsection{Language Equivalents between Swift and
C}\label{language-equivalents-between-swift-and-c}

\begin{itemize}
\item
  Protocols in Swift are analogous to interfaces in C\#:

\begin{verbatim}
// Swift
protocol DoThings {
    func MyMethod() -> String
}


// C#
interface DoThings
{
    string MyMethod();
}
\end{verbatim}
\item
  Initializers in Swift are analogous to constructors in C\#:

\begin{verbatim}
// Swift
class MyClass {
    var myVar : String = ""

    init(myVar : String) {
        self.myVar = myVar
    }
}

var testing = MyClass(myVar: "Test")


// C#
class MyClass {
    protected string myVar = "";

    public MyClass() {}

    public MyClass(string myVar) {
        this.myVar = myVar;
    }
}

var testing = new MyClass(myVar: "Test");
\end{verbatim}
\end{itemize}

To learn more about language equivalents between Swift and C\#, see
\href{https://download.microsoft.com/download/4/6/9/469501F4-5F6B-4E51-897C-9A216CFB30A3/SwiftCSharpPoster.pdf}{this
quick reference}.

\subsection{Language Equivalents between Java and
C}\label{language-equivalents-between-java-and-c}

To extend or implement a class or interface, Java requires that you use
the \texttt{extends} or \texttt{implements} keywords. C\# doesn't
require this:

\begin{verbatim}
// Java
class Bird extends Vertebrate implements Actions {
    ...
}


// C#
class Bird : Vertebrate, Actions {
    ...
}
\end{verbatim}

To learn more about language equivalents between Java and C\#, see
\href{https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=1&cad=rja&uact=8&ved=0ahUKEwjbr8bgz_XXAhWMMyYKHeUPA5wQFgg7MAA&url=http\%3A\%2F\%2Fdownload.microsoft.com\%2Fdownload\%2FD\%2FE\%2FE\%2FDEE91FC0-7AA9-4F6E-9FFA-8658AA0FA080\%2FCSharp\%2520for\%2520Java\%2520Developers\%2520-\%2520Cheat\%2520Sheet.pdf&usg=AOvVaw1i0RzOcmyol7LhD59k9cUE}{the
C\# for Java developers cheat sheet}.

\subsection{FAQs}\label{faqs-1}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Do I have to use Visual Studio?

  No, but we strongly recommend it. If you wish, however, you can use
  Xamarin Studio or Visual Studio Code instead.
\item
  What's the meaning of \texttt{{[}Export(...){]}} above delegate method
  names?

  In short, this attribute makes properties and methods available in
  Objective-C.
  \href{https://developer.xamarin.com/api/type/MonoTouch.Foundation.ExportAttribute/}{Xamarin's
  documentation} explains this attribute in detail.
\end{enumerate}

\subsection{Related Topics}\label{related-topics-272}

\href{/docs/7-1/tutorials/-/knowledge_base/t/preparing-xamarin-projects-for-liferay-screens}{Preparing
Xamarin Projects for Liferay Screens}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-screenlets-in-xamarin-apps}{Using
Screenlets in Xamarin Apps}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-views-in-xamarin-android}{Using
Views in Xamarin.Android}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-xamarin-views-and-themes}{Creating
Xamarin Views and Themes}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-themes-in-xamarin-ios}{Using
Themes in Xamarin.iOS}

\chapter{Mobile SDK}\label{mobile-sdk}

Want to wield Liferay's power in your mobile apps? Thanks to Liferay's
Mobile SDK, you can do just that. The Liferay Mobile SDK provides a way
to streamline consuming Liferay core web services, Liferay utilities,
and custom app web services. It's a low-level layer that wraps Liferay
JSON web services, making them easy to call in native mobile apps. It
takes care of authentication, makes HTTP requests (synchronously or
asynchronously), parses JSON results, and handles server-side exceptions
so you can concentrate on \emph{using} the services in your app. The
Liferay Mobile SDK bridges the gap between your native app and Liferay
services. The official project
\href{https://www.liferay.com/community/liferay-projects/liferay-mobile-sdk/overview}{page}
gives you access to the SDK releases, provides the latest SDK news, and
has forums for you to engage in mobile app development discussions. The
Liferay Mobile SDK is available as separate downloads for Android and
iOS.

\begin{figure}
\centering
\includegraphics{./images/mobile-sdk-diagram.png}
\caption{Liferay's Mobile SDK enables your native app to communicate
with Liferay.}
\end{figure}

There are two different types of Mobile SDKs that you need to add to
your app's project, depending on the remote services you need to call.
Liferay's prebuilt Mobile SDK includes the classes required to construct
remote service calls in general. It also contains the classes required
to call the specific remote services of Liferay's \emph{core} portlets.
Core portlets are included with every Liferay installation (these are
also referred to as out-of-the-box or built-in portlets). However, you
need to build an additional Mobile SDK if you want to leverage your
custom portlet's remote services. Once built, this Mobile SDK contains
\emph{only} the classes required to call those services. Therefore, you
must install it in your app alongside Liferay's prebuilt Mobile SDK to
leverage your custom portlet's remote services.

Note that Liferay also provides
\href{https://www.liferay.com/products/liferay-screens}{Liferay Screens}
for constructing mobile apps that connect to Liferay. Screens uses
components called \emph{screenlets} to leverage and abstract the Mobile
SDK's low-level service calls. However, if there's not a screenlet for
your use case, or you need more control over the service call, then you
may want to use the Mobile SDK directly. You should read the Screens
tutorials in addition to the Mobile SDK tutorials here to decide which
better fits your needs.

This section's tutorials cover using the Mobile SDK in Android and iOS
app development. The following tutorials introduce these topics and are
followed by in-depth tutorials on each:

\begin{itemize}
\tightlist
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/creating-android-apps-that-use-the-mobile-sdk}{Creating
  Android Apps that Use the Mobile SDK}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/creating-ios-apps-that-use-the-mobile-sdk}{Creating
  iOS Apps that Use the Mobile SDK}
\end{itemize}

In addition, the following tutorial covers building Mobile SDKs to
support your custom portlet services:

\begin{itemize}
\tightlist
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/building-mobile-sdks}{Building
  Mobile SDKs}
\end{itemize}

Fasten your seatbelt--it's time to go mobile with Liferay's Mobile SDK!

\textbf{Related Topics:}

\href{/docs/7-1/tutorials/-/knowledge_base/t/android-apps-with-liferay-screens}{Android
Apps with Liferay Screens}

\href{/docs/7-1/tutorials/-/knowledge_base/t/ios-apps-with-liferay-screens}{iOS
Apps with Liferay Screens}

\href{/docs/7-1/tutorials/-/knowledge_base/t/building-mobile-sdks}{Building
Mobile SDKs}

\chapter{Creating Android Apps that Use the Mobile
SDK}\label{creating-android-apps-that-use-the-mobile-sdk}

The Liferay Mobile SDK provides a way to streamline the consumption of
Liferay DXP's core web services and utilities, as well as those of
custom apps. It wraps Liferay DXP's JSON web services, making them easy
to call in native mobile apps. It handles authentication, makes HTTP
requests (synchronously or asynchronously), parses JSON results, and
handles server-side exceptions so you can concentrate on \emph{using}
the services in your app.

The Liferay Mobile SDK comes with the Liferay Android SDK. The official
\href{https://www.liferay.com/community/liferay-projects/liferay-mobile-sdk/overview}{project
page} gives you access to the SDK releases, provides the latest SDK
news, and has forums for you to engage in mobile app development
discussions. Once you configure the Mobile SDK in your app, you can
invoke Liferay DXP services in it.

\begin{figure}
\centering
\includegraphics{./images/mobile-sdk-diagram.png}
\caption{Liferay's Mobile SDK enables your native app to communicate
with Liferay DXP.}
\end{figure}

The Android Mobile SDK app development tutorials cover these topics:

\begin{itemize}
\tightlist
\item
  Making Liferay and Custom Portlet Services Available in Your Android
  App
\item
  Invoking Liferay Services in Your Android App
\item
  Invoking Services Asynchronously from Your Android App
\item
  Sending Your Android App's Requests Using Batch Processing
\end{itemize}

A great way to start is by setting up the Mobile SDK your Android
project. This makes Liferay DXP's services available in your app.

\section{Related Topics}\label{related-topics-273}

\href{/docs/7-1/tutorials/-/knowledge_base/t/invoking-liferay-services-in-your-android-app}{Invoking
Liferay Services in Your Android App}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-ios-apps-that-use-the-mobile-sdk}{Creating
iOS Apps that Use the Mobile SDK}

\href{/docs/7-1/tutorials/-/knowledge_base/t/building-mobile-sdks}{Building
Mobile SDKs}

\section{Making Liferay and Custom Portlet Services Available in Your
Android
App}\label{making-liferay-and-custom-portlet-services-available-in-your-android-app}

You must install the correct Mobile SDKs in your Android project to call
the remote services you need in your app. You should first install
Liferay's prebuilt Mobile SDK. This is required for any app that
leverages Liferay. To call your custom portlet's services, you also need
to install the Mobile SDK that you built for it. For instructions on
building a Mobile SDK for your custom portlet, see the tutorial
\href{/docs/7-1/tutorials/-/knowledge_base/t/building-mobile-sdks}{Building
Mobile SDKs}.

This tutorial shows you how to install Liferay's prebuilt Mobile SDK,
and any custom built Mobile SDKs. First, you'll learn how to use Gradle
or Maven to install Liferay's prebuilt Mobile SDK. You'll then learn how
to install a Mobile SDK manually, which is required for installing any
custom built Mobile SDKs. Now go forth and fear no remote service!

\subsection{Adding the SDK to Your Gradle
Project}\label{adding-the-sdk-to-your-gradle-project}

If your Android project is using Gradle as the build system, you can add
Liferay's prebuilt Mobile SDK as a
\href{/docs/7-1/tutorials/-/knowledge_base/t/configuring-dependencies}{dependency}
to your project. All versions are available at the JCenter and Maven
Central repositories. Both repositories are listed here, but you only
need to have one in your app:

\begin{verbatim}
repositories {
  jcenter()
  mavenCentral()
}

dependencies {
  compile group: 'com.liferay.mobile', name: 'liferay-android-sdk', version: '7.1.+'
}
\end{verbatim}

If you get errors such as
\texttt{Duplicate\ files\ copied\ in\ APK\ META-INF/NOTICE} when
building with Gradle, add this to your \texttt{build.gradle} file:

\begin{verbatim}
android {
    ...
    packagingOptions {
        exclude 'META-INF/LICENSE'
        exclude 'META-INF/NOTICE'
    }
    ...
}
\end{verbatim}

That's all there is to it! When your project syncs with your Gradle
files, Liferay's prebuilt Mobile SDK downloads to your project. The
instructions for doing this with Maven are shown next.

\subsection{Adding the SDK to Your Maven
Project}\label{adding-the-sdk-to-your-maven-project}

You can also add the Liferay's prebuilt Mobile SDK as a
\href{/docs/7-1/tutorials/-/knowledge_base/t/configuring-dependencies}{dependency}
to your project using Maven. To do so, add the following code to your
\texttt{pom.xml} file:

\begin{verbatim}
<dependency>
    <groupId>com.liferay.mobile</groupId>
    <artifactId>liferay-android-sdk</artifactId>
    <version>LATEST</version>
</dependency>
\end{verbatim}

Awesome! However, what if you're not using Gradle or Maven? What if you
want to install a custom built Mobile SDK? No problem! The next section
shows you how to install a Mobile SDK manually.

\subsection{Manually Adding the SDK to Your Android
Project}\label{manually-adding-the-sdk-to-your-android-project}

Use the following steps to manually set up a Mobile SDK in your Android
project:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  To install Liferay's prebuilt Mobile SDK, first
  \href{https://github.com/liferay/liferay-mobile-sdk/releases/}{download}
  the latest version of \texttt{liferay-android-sdk-{[}version{]}.jar}.
  If you built your own Mobile SDK, find its JAR file on your machine.
  This is detailed in the
  \href{/docs/7-1/tutorials/-/knowledge_base/t/building-mobile-sdks}{Building
  Mobile SDKs} tutorial.
\item
  Copy the JAR into your Android project's \texttt{/libs} folder.
\item
  If you're manually installing Liferay's prebuilt Mobile SDK, you also
  need to download and copy these dependencies to your Android Project's
  \texttt{/libs} folder:

  \begin{itemize}
  \tightlist
  \item
    \href{http://search.maven.org/remotecontent?filepath=org/apache/httpcomponents/httpclient-android/4.3.3/httpclient-android-4.3.3.jar}{\texttt{httpclient-android-4.3.3.jar}}
  \item
    \href{http://search.maven.org/remotecontent?filepath=org/apache/httpcomponents/httpmime/4.3.3/httpmime-4.3.3.jar}{\texttt{httpmime-4.3.3.jar}}
  \end{itemize}
\item
  Start using it!
\end{enumerate}

Great! Now you know how to manually install a Mobile SDK in your Android
apps.

\subsection{Making Custom Portlet Services Available in Your Android
App}\label{making-custom-portlet-services-available-in-your-android-app}

If you want to invoke remote web services for your custom portlet, then
you need to generate its client libraries by building an Android Mobile
SDK yourself. Building an SDK is covered in the tutorial
\href{/docs/7-1/tutorials/-/knowledge_base/t/building-mobile-sdks}{Building
Mobile SDKs}. Once you build an SDK to a JAR file, you can install it
using the manual installation steps above (make sure to use the JAR file
you built instead of Liferay's prebuilt JAR file). Note that because
your custom built SDKs contain \emph{only} the client libraries for
calling your custom portlet services, you must install them alongside
Liferay's prebuilt SDK. Liferay's prebuilt SDK contains additional
classes that are required to construct any remote service call.

Super! Now that the remote services you need are available in your app,
you're ready to call them.

\subsection{Related Topics}\label{related-topics-274}

\href{/docs/7-1/tutorials/-/knowledge_base/t/invoking-liferay-services-in-your-android-app}{Invoking
Liferay Services in Your Android App}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-ios-apps-that-use-the-mobile-sdk}{Creating
iOS Apps that Use the Mobile SDK}

\href{/docs/7-1/tutorials/-/knowledge_base/t/building-mobile-sdks}{Building
Mobile SDKs}

\section{Invoking Liferay Services in Your Android
App}\label{invoking-liferay-services-in-your-android-app}

Once the appropriate Mobile SDKs are set up in your Android project, you
can access and invoke Liferay DXP services in your app. This tutorial
takes you through the steps you must follow to invoke these services:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Create a session.
\item
  Import the Liferay DXP services you need to call.
\item
  Create a service object and call the service methods.
\end{enumerate}

Since some service calls require special treatment, this tutorial also
shows you how to handle them. But first, you'll learn about securing
Liferay DXP's JSON web services in the portal.

\subsection{Securing JSON Web
Services}\label{securing-json-web-services-3}

The Liferay Mobile SDK calls Liferay DXP's JSON web services, which are
enabled by default. The web services you call via the Mobile SDK must
remain enabled for those calls to work. It's possible, however, to
disable the web services that you don't need to call. For instructions
on this, see the tutorial
\href{/docs/7-1/tutorials/-/knowledge_base/t/configuring-json-web-services}{Configuring
JSON Web Services}. You can also use
\href{/docs/7-1/tutorials/-/knowledge_base/t/service-access-policies}{Service
Access Policies} for more fine-grained control over accessible services.

\subsection{Step 1: Create a Session}\label{step-1-create-a-session}

A session is a conversion state between the client and server, that
consists of multiple requests and responses between the two. You need a
session to pass requests between your app and the Mobile SDK. In most
cases, sessions need to be created with user authentication. The imports
and code required to create a session are shown here:

\begin{verbatim}
import com.liferay.mobile.android.auth.basic.BasicAuthentication;
import com.liferay.mobile.android.service.Session;
import com.liferay.mobile.android.service.SessionImpl;
...
Session session = new SessionImpl("http://10.0.2.2:8080", 
    new BasicAuthentication("test@example.com", "test"));
\end{verbatim}

The arguments to \texttt{SessionImpl} are used to create the session.
The first parameter is the URL of the Liferay instance you're connecting
to. If you're running your app on Android Studio's emulator,
\texttt{http://10.0.2.2:8080} is equivalent to
\texttt{http://localhost:8080}. Be sure to replace this with the correct
address for your server.

\noindent\hrulefill

\textbf{Warning:} Be careful when using administrator credentials on a
production Liferay instance, as you'll have permission to call any
service. Make sure not to modify data by accident. Of course, the
default administrator credentials should be disabled on a production
Liferay instance.

\noindent\hrulefill

The second parameter creates a new \texttt{BasicAuthentication} object
containing the user's credentials. Depending on the authentication
method used by your Liferay instance, you need to provide the user's
email address, screen name, or user ID. You also need to provide the
user's password. The \texttt{BasicAuthentication} object tells the
session to use Basic Authentication to authenticate each service call.
The Mobile SDK also supports OAuth authentication, as long as the OAuth
Provider portlet is deployed to your Liferay instance. To learn how to
use OAuth authentication with the Mobile SDK, see the
\href{https://github.com/brunofarache/liferay-android-sdk-oauth}{OAuth
sample app}. Also, note that the OAuth Provider portlet is only
available to customers with an active Liferay subscription.

If you're building a sign in view for your app, you can use the
\texttt{SignIn} utility class to check if the credentials given by the
user are valid.

\begin{verbatim}
import com.liferay.mobile.android.auth.SignIn;
...
SignIn.signIn(session, new JSONObjectAsyncTaskCallback() {

    @Override
    public void onSuccess(JSONObject userJSONObject) {
        System.out.println("Successful sign-in, user details: " + userJSONObject)
    }

    @Override
    public void onFailure(Exception e) {
        e.printStackTrace();
    }

});
\end{verbatim}

Note that the Mobile SDK doesn't keep a persistent connection or session
with the server. Each request is sent with the user's credentials
(except when using OAuth). However, the \texttt{SignIn} class provides a
way to return user information after a successful sign-in.

Next, you're shown how to create an unauthenticated session in the
limited cases where this is possible.

\subsubsection{Creating an Unauthenticated
Session}\label{creating-an-unauthenticated-session}

In some cases, it's possible to create a \texttt{Session} instance
without user credentials. However, most Liferay remote methods don't
accept unauthenticated remote calls. Making a call with an
unauthenticated session generates an
\texttt{Authentication\ access\ required} exception in most cases.

Unauthenticated service calls only work if the remote method in the
Liferay instance or your plugin has the \texttt{@AccessControlled}
annotation. This is shown here for the hypothetical class
\texttt{FooServiceImpl} and its method \texttt{bar}:

\begin{verbatim}
import com.liferay.portal.security.ac.AccessControlled;
...
public class FooServiceImpl extends FooServiceBaseImpl {
...
    @AccessControlled(guestAccessEnabled = true)
    public void bar() { ... }
...
\end{verbatim}

To make such a call, you need to use the constructor that accepts the
server URL only:

\begin{verbatim}
Session session = new SessionImpl("http://10.0.2.2:8080");
\end{verbatim}

Fantastic! Now that you have a session, you can use it to call Liferay's
services.

\subsection{Step 2: Import the Liferay Services You
Need}\label{step-2-import-the-liferay-services-you-need}

First, you should determine the Liferay services you need to call. You
can find the available services at
\href{http://localhost:8080/api/jsonws}{\texttt{http://localhost:8080/api/jsonws}}.
Be sure to replace \texttt{http://localhost:8080} in this URL with your
server's address.

Add the imports for the services you need to call. For example, if
you're building a blogs app, you can import \texttt{BlogsEntryService}:

\begin{verbatim}
import com.liferay.mobile.android.v62.blogsentry.BlogsEntryService;
\end{verbatim}

Note that the Liferay version (\texttt{.v62}) is used in the package
namespace. Since the Mobile SDK is built for a specific Liferay version,
service classes for different Liferay versions are separated by their
package names. In this example, the Mobile SDK classes use the
\texttt{.v62} package, which means this Mobile SDK is compatible with
Liferay 6.2. Mobile SDK classes compatible with Liferay 7.0 use the
\texttt{v7} package. This namespacing lets your app support multiple
Liferay versions.

\subsection{Step 3: Create a Service Object and Call its Service
Methods}\label{step-3-create-a-service-object-and-call-its-service-methods}

Once you have a session and the required imports, you're ready to make
the service call. This is done by creating a service object for the
service you want to call, and then calling its service methods. For
example, if you're creating a blogs app, you need to use
\texttt{BlogsEntryService} to get all the blogs entries from a site.
This is demonstrated by the following code:

\begin{verbatim}
BlogsEntryService service = new BlogsEntryService(session);

JSONArray jsonArray = service.getGroupEntries(10184, 0, 0, -1, -1);
\end{verbatim}

This fetches all blog entries from the \emph{Guest} site. In this
example, the \emph{Guest} site's \texttt{groupId} is \texttt{10184}.
Note that many service methods require \texttt{groupId} as a parameter.
You can get the user's groups by calling the \texttt{getUserSites()}
method from \texttt{GroupService}.

Service method return types can be \texttt{void}, \texttt{String},
\texttt{JSONArray}, or \texttt{JSONObject}. Primitive type wrappers can
be \texttt{Boolean}, \texttt{Integer}, \texttt{Long}, or
\texttt{Double}.

This \texttt{BlogsEntryService} call is a basic example of a synchronous
service call; the method only returns after the request finishes.
However, Android doesn't allow network communication from an app's main
UI thread. Service calls issued from the main UI thread need need to be
asynchronous. For instructions on doing this, see the tutorial
\href{/docs/7-1/tutorials/-/knowledge_base/t/invoking-services-asynchronously-from-your-android-app}{Invoking
Services Asynchronously from Your Android App}.

Great! Now you're familiar with the basics of accessing Liferay services
through the Mobile SDK. However, there are some special cases you may
run into when making service calls from your app. These are discussed in
the following sections.

\subsection{Non-Primitive Arguments}\label{non-primitive-arguments}

There are some special cases in which a service method's arguments
aren't primitives. In these cases, you should use
\texttt{JSONObjectWrapper}. For example:

\begin{verbatim}
JSONObjectWrapper wrapper = new JSONObjectWrapper(new JSONObject());
\end{verbatim}

You must pass a JSON containing the object properties and their values.
On the server side, your object is instantiated and setters for each
property are called with the values from the JSON you passed.

There are other cases in which service methods require interfaces or
abstract classes as arguments. Since it's impossible for the SDK to
guess which implementation you want to use, you must initialize
\texttt{JSONObjectWrapper} with the class name. For example:

\begin{verbatim}
JSONObjectWrapper wrapper = new JSONObjectWrapper(className, new JSONObject());
\end{verbatim}

The server looks for the class name in its classpath and instantiates
the object for you. It then calls setters, as in the previous example.
The abstract class \texttt{OrderByComparator} is a good example of this.
This is discussed next.

\subsubsection{OrderByComparator}\label{orderbycomparator}

On the server side, \texttt{OrderByComparator} is an abstract class. You
must therefore pass the name of a class that implements it. For example:

\begin{verbatim}
String className = "com.liferay.portlet.bookmarks.util.comparator.EntryNameComparator";

JSONObjectWrapper orderByComparator = new JSONObjectWrapper(className, new JSONObject());
\end{verbatim}

If the service you're calling accepts \texttt{null} for a comparator
argument, pass \texttt{null} to the service call.

You may want to set the ascending property for a comparator.
Unfortunately, as of Liferay 6.2, most Liferay
\texttt{OrderByComparator} implementations don't have a setter for this
property and it isn't possible to set from the Mobile SDK. Future
Liferay versions may address this. However, you may have a custom
\texttt{OrderByComparator} that has a setter for ascending. In this
case, you can use the following code:

\begin{verbatim}
String className = "com.example.MyOrderByComparator";

JSONObject jsonObject = new JSONObject();
jsonObject.put("ascending", true);

JSONObjectWrapper orderByComparator = new JSONObjectWrapper(className, jsonObject);
\end{verbatim}

For more examples, see the test case
\href{https://github.com/liferay/liferay-mobile-sdk/blob/master/android/src/test/java/com/liferay/mobile/android/OrderByComparatorTest.java}{\texttt{OrderByComparatorTest.java}}.

\subsubsection{ServiceContext}\label{servicecontext}

Another non-primitive argument is \texttt{ServiceContext}. It requires
special attention because most Liferay service methods require it.
However, you aren't required to pass it to the SDK; you can pass
\texttt{null} instead. The server then creates a \texttt{ServiceContext}
instance for you, using default values.

If you need to set properties for \texttt{ServiceContext}, you can do so
by adding them to a new \texttt{JSONObject} and then passing it as the
\texttt{ServiceContext} argument:

\begin{verbatim}
JSONObject jsonObject = new JSONObject();
jsonObject.put("addGroupPermissions", true);
jsonObject.put("addGuestPermissions", true);

JSONObjectWrapper serviceContext = new JSONObjectWrapper(jsonObject);
\end{verbatim}

For more examples, see the test case
\href{https://github.com/liferay/liferay-mobile-sdk/blob/master/android/src/test/java/com/liferay/mobile/android/ServiceContextTest.java}{\texttt{ServiceContextTest.java}}.

\subsubsection{Binaries}\label{binaries}

Some Liferay services require argument types such as byte arrays
(\texttt{byte{[}{]}}) and Files (\texttt{java.io.File}).

The Mobile SDK converts byte arrays to strings before sending the POST
request. For example, \texttt{"hello".getBytes("UTF-8")} becomes a JSON
array such as \texttt{"{[}104,101,108,108,111{]}"}. The Mobile SDK does
this for you so you don't have worry about it; you only need to pass the
byte array to the method.

However, you need to be careful when using such methods. This is because
you're allocating memory for the whole byte array, which may cause
memory issues if the content is large.

Other Liferay service methods require \texttt{java.io.File} as an
argument. In these cases, the Mobile SDK requires
\texttt{InputStreamBody} instead. To accomodate this, you need to create
an \texttt{InputStream} and pass it to the \texttt{InputStreamBody}
constructor, along with the file's mime type and name. For example:

\begin{verbatim}
InputStream is = context.getAssets().open("file.png");
InputStreamBody file = new InputStreamBody(is, "image/png", "file.png");
\end{verbatim}

The Mobile SDK sends a multipart form request to the Liferay instance.
On the server side, a \texttt{File} instance is created and sent to the
service method you're calling.

It's also possible to cancel or monitor service calls that upload data
to Liferay. Every service that uploads data returns an
\texttt{AsyncTask} instance. You can use it to cancel the upload if
needed. If want to listen for upload progress to create a progress bar,
you can create an \texttt{UploadProgressAsyncTaskCallback} callback and
set it to the current \texttt{Session} object. Its \texttt{onProgress}
method is called for each byte chunk sent. It passes the total number of
uploaded bytes so far. For example:

\begin{verbatim}
session.setCallback(

    new UploadProgressAsyncTaskCallback<JSONObject>() {

        (...)

        public void onProgress(int totalBytes) {
            // This method will be called for each byte chunk sent.
            // The totalBytes argument will contain the total number
            // of uploaded bytes, from 0 to the total size of the
            // request.
        }

        (...)

    }
);
\end{verbatim}

For more examples on this subject, see the \texttt{addFileEntry*}
methods in
\href{https://github.com/liferay/liferay-mobile-sdk/blob/master/android/src/test/java/com/liferay/mobile/android/DLAppServiceTest.java}{\texttt{DLAppServiceTest.java}}.

As you can see, the Mobile SDK does a great deal of work for you even
when special service method arguments are required.

\subsection{Related Topics}\label{related-topics-275}

\href{/docs/7-1/tutorials/-/knowledge_base/t/invoking-services-asynchronously-from-your-android-app}{Invoking
Services Asynchronously from Your Android App}

\href{/docs/7-1/tutorials/-/knowledge_base/t/building-mobile-sdks}{Building
Mobile SDKs}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-ios-apps-that-use-the-mobile-sdk}{Creating
iOS Apps that Use the Mobile SDK}

\section{Invoking Services Asynchronously from Your Android
App}\label{invoking-services-asynchronously-from-your-android-app}

Android doesn't allow synchronous HTTP requests to be made from the main
UI thread. You can use Android's
\href{http://developer.android.com/reference/android/os/AsyncTask.html}{\texttt{AsyncTask}}
to make synchronous requests from threads other than the main UI thread.
If you don't want to use \texttt{AsyncTask}, you can make asynchronous
requests through the Mobile SDK. To do so, you need to implement and
instantiate a callback class, and then set it to the session. When the
Mobile SDK makes your service calls for that session, it then makes them
asynchronously. To make synchronous calls again, set \texttt{null} as
the session's callback.

With the following steps, this tutorial shows you how to implement
asynchronous requests in your Android app:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Implement and instantiate your callback class.
\item
  Set the callback on the session.
\item
  Call Liferay services.
\end{enumerate}

Now go ahead and get started!

\subsection{Implementing and Instantiating Your Callback
Class}\label{implementing-and-instantiating-your-callback-class}

Before implementing and instantiating your callback class, you should
add the required imports. The imports you add depend on the return type
of the service method you're calling. For example, if you need to call
the service method \texttt{getGroupEntries} to retrieve blog entries
from a site's Blogs portlet, you need to import the Mobile SDK's
\texttt{AsyncTaskCallback} and \texttt{JSONArrayAsyncTaskCallback}:

\begin{verbatim}
import com.liferay.mobile.android.task.callback.AsyncTaskCallback;
import com.liferay.mobile.android.task.callback.typed.JSONArrayAsyncTaskCallback;
\end{verbatim}

This is because the \texttt{getGroupEntries} returns a
\texttt{JSONArray}. There are multiple \texttt{AsyncTaskCallback}
implementations, one for each method return type:

\begin{itemize}
\tightlist
\item
  \texttt{JSONObjectAsyncTaskCallback}
\item
  \texttt{JSONArrayAsyncTackCallback}
\item
  \texttt{StringAsyncTaskCallback}
\item
  \texttt{BooleanAsyncTaskCallback}
\item
  \texttt{IntegerAsyncTaskCallback}
\item
  \texttt{LongAsyncTaskCallback}
\item
  \texttt{DoubleAsyncTaskCallback}
\end{itemize}

It's also possible to use a generic \texttt{AsyncTaskCallback}
implementation called \texttt{GenericAsyncTaskCallback}. To do so, you
must implement a transform method and handle JSON parsing yourself.

If you still don't want to use any of these callbacks, you can implement
\texttt{AsyncTaskCallback} directly. However, you should be careful when
doing so. You should always get the first element of the
\texttt{JSONArray} passed as a parameter to the
\texttt{onPostExecute(JSONArray\ jsonArray)} method (for example,
\texttt{jsonArray.get(0)}).

Next, implement and instantiate your callback class. When implementing
your callback class, you need to implement its \texttt{onFailure} and
\texttt{onSuccess} methods. These methods respectivley determine what
your app does when the request fails or succeeds. The
\texttt{onFailure()} method is called if an exception occurs during the
request. This could be triggered by a connection exception (e.g., a
request timeout) or a \texttt{ServerException}. If a
\texttt{ServerException} occurs, it's because something went wrong on
the server side. For example, if you pass a \texttt{groupId} that
doesn't exist, the Liferay instance complains about it, and the Mobile
SDK wraps the error message with \texttt{ServerException}.

The \texttt{onSuccess} method is called on the main UI thread after the
request finishes. Since the request is asynchronous, the service call
immediately returns a \texttt{null} object. The service delivers the
service's real return value to the callback's \texttt{onSuccess()}
method, instead.

Example code is shown here for \texttt{AsyncTaskCallback} and
\texttt{JSONArrayAsyncTaskCallback}:

\begin{verbatim}
AsyncTaskCallback callback = new JSONArrayAsyncTaskCallback() {

    public void onFailure(Exception exception) {
        // Implement exception handling code
    }

    public void onSuccess(JSONArray result) {
        // Called after request has finished successfully
    }

};
\end{verbatim}

Now that you have your callback class, you can set it to the session.

\subsection{Setting the Callback to the
Session}\label{setting-the-callback-to-the-session}

Once you've implemented and instantiated your callback class, you're
ready to set it to the session. If you haven't created a session yet, do
so now. The tutorial
\href{/docs/7-1/tutorials/-/knowledge_base/t/invoking-liferay-services-in-your-android-app}{Invoking
Liferay Services in Your Android App} shows you how to create a session.
Now you're ready to set the callback to the session. For example, this
is done here for \texttt{AsyncTaskCallback}:

\begin{verbatim}
session.setCallback(callback);
\end{verbatim}

Pretty simple! Now you're ready to make the service call.

\subsection{Making the Service Call}\label{making-the-service-call}

Last but certainly not least, make the service call. This is done the
same as calling any other service: create a service object from the
session and use it to make the service call. This is also described in
the tutorial
\href{/docs/7-1/tutorials/-/knowledge_base/t/invoking-liferay-services-in-your-android-app}{Invoking
Liferay Services in Your Android App}. An example service call that gets
all the blog entries from a site's Blogs portlet is shown here:

\begin{verbatim}
service.getGroupEntries(10184, 0, 0, -1, -1);
\end{verbatim}

The example code from the above sections is shown together here:

\begin{verbatim}
import com.liferay.mobile.android.task.callback.AsyncTaskCallback;
import com.liferay.mobile.android.task.callback.typed.JSONArrayAsyncTaskCallback;

...

AsyncTaskCallback callback = new JSONArrayAsyncTaskCallback() {

    public void onFailure(Exception exception) {
        // Implement exception handling code
    }

    public void onSuccess(JSONArray result) {
        // Called after request has finished successfully
    }

};

// create a session first
session.setCallback(callback);

// create a service object first
service.getGroupEntries(10184, 0, 0, -1, -1);
\end{verbatim}

Great! Now you know how to invoke services asynchronously from your
Android app.

\subsection{Related Topics}\label{related-topics-276}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-ios-apps-that-use-the-mobile-sdk}{Creating
iOS Apps that Use the Mobile SDK}

\href{/docs/7-1/tutorials/-/knowledge_base/t/building-mobile-sdks}{Building
Mobile SDKs}

\section{Sending Your Android App's Requests Using Batch
Processing}\label{sending-your-android-apps-requests-using-batch-processing}

The Mobile SDK also allows sending requests in batch. This can be much
more efficient than sending separate requests. For example, suppose you
want to delete ten blog entries in a site's Blogs portlet at the same
time. Instead of making a request for each deletion, you can create a
batch of calls and send them all together.

This tutorial shows you how to implement batch processing for your
Android app. It's assumed that you already know how to invoke Liferay
services from your Android app. If you don't, see the tutorial
\href{/docs/7-1/tutorials/-/knowledge_base/t/invoking-liferay-services-in-your-android-app}{Invoking
Liferay Services in Your Android App}. Now get ready to whip up a fresh
batch of service calls!

\subsection{Implementing Batch
Processing}\label{implementing-batch-processing}

Making service calls in batch only requires two extra steps over making
them one at a time:

\begin{itemize}
\tightlist
\item
  Create a batch session with \texttt{BatchSessionImpl}.
\item
  Make the batch service calls with the \texttt{invoke} method of
  \texttt{BatchSessionImpl}.
\end{itemize}

The rest of the steps are the same as making other service calls. You
still need a service object, and you still need to call its service
methods. As an example, here's a code snippet from an app that deletes a
Blogs portlet's blog entries synchronously in batch:

\begin{verbatim}
import com.liferay.mobile.android.service.BatchSessionImpl;

BatchSessionImpl batch = new BatchSessionImpl(session);
BlogsEntryService service = new BlogsEntryService(batch);

service.deleteEntry(1);
service.deleteEntry(2);
service.deleteEntry(3);

JSONArray jsonArray = batch.invoke();
\end{verbatim}

So what's going on here? After the import, \texttt{BatchSessionImpl} is
used with a pre-existing session to create a batch session. Note that
the \texttt{BatchSessionImpl} constructor takes either credentials or a
session. Passing a session to the constructor is useful when you already
have a \texttt{Session} object and want to reuse the same credentials.
After creating the service object, several \texttt{deleteEntry} service
calls are created. Since the service object is created with a batch
session, these calls aren't made immediately; they return \texttt{null}
instead. The calls aren't made until issued in batch by calling the
\texttt{invoke()} method on the batch session object. It returns a
\texttt{JSONArray} containing the results for each service call. Since
this example contains three \texttt{deleteEntry} calls, the
\texttt{jsonArray} contains three objects. The results are ordered the
same as the service calls.

Great! But what if you want to make batch calls asynchronously? No
problem! Set the callback as a \texttt{BatchAsyncTaskCallback} instance:

\begin{verbatim}
import com.liferay.mobile.android.task.callback.BatchAsyncTaskCallback;

batch.setCallback(new BatchAsyncTaskCallback() {

    public void onFailure(Exception exception) {
    }

    public void onSuccess(JSONArray results) {
        // The result is always a JSONArray 
    }

});
\end{verbatim}

This is similar to the procedure for making asynchronous calls as
described in the tutorial
\href{/docs/7-1/tutorials/-/knowledge_base/t/invoking-services-asynchronously-from-your-android-app}{Invoking
Services Asynchronously from Your Android App}. Awesome! Now you know
how to make efficient service calls in batch!

\subsection{Related Topics}\label{related-topics-277}

\href{/docs/7-1/tutorials/-/knowledge_base/t/invoking-liferay-services-in-your-android-app}{Invoking
Liferay Services in Your Android App}

\href{/docs/7-1/tutorials/-/knowledge_base/t/invoking-services-asynchronously-from-your-android-app}{Invoking
Services Asynchronously from Your Android App}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-ios-apps-that-use-the-mobile-sdk}{Creating
iOS Apps that Use the Mobile SDK}

\section{Using OAuth 2 in the Android Mobile
SDK}\label{using-oauth-2-in-the-android-mobile-sdk}

You can use \href{https://oauth.net/2/}{OAuth 2} to authenticate with
the following \href{https://oauth.net/2/grant-types/}{OAuth 2 grant
types}:

\begin{itemize}
\item
  \href{https://oauth.net/2/grant-types/authorization-code/}{\textbf{Authorization
  Code (PKCE for native apps):}} Redirects users to a page in their
  mobile browser where they enter their credentials. Following login,
  the browser redirects users back to the mobile app. User credentials
  can't be compromised via the app because it never accesses them---it
  uses a token that can be revoked. This is also useful if users don't
  want to enter their credentials in the app. For example, users may not
  want to enter their Twitter credentials directly in a 3rd-party
  Twitter app, preferring instead to authenticate via Twitter's official
  site. Note that the site you redirect to for authentication must have
  OAuth 2 implemented.
\item
  \href{https://oauth.net/2/grant-types/password/}{\textbf{Resource
  Owner Password:}} Users authenticate by entering their credentials
  directly in the app.
\item
  \href{https://oauth.net/2/grant-types/client-credentials/}{\textbf{Client
  Credentials:}} Authenticates without requiring user interaction. This
  is useful when the app needs to access its own resources, not those of
  a specific user.
\end{itemize}

This tutorial shows you how to use these grant types with the Mobile
SDK. Note that before getting started, you may want to see
\href{/docs/7-1/deploy/-/knowledge_base/d/oauth-2-0}{Liferay DXP's OAuth
2.0 documentation} for instructions on registering an OAuth 2.0
application in the portal.

\subsection{Authorization Code (PKCE)}\label{authorization-code-pkce-2}

To authenticate via the Authorization Code grant type, you must call
this \texttt{OAuth2SignIn} method:

\begin{verbatim}
OAuth2SignIn.signInWithRedirect(Activity activity, Session session, String clientId, 
    List<String> scopes, Uri redirectUri, CustomTabsIntent customTabsIntent)
\end{verbatim}

Here are descriptions of this method's parameters:

\begin{itemize}
\tightlist
\item
  \texttt{activity}: The activity to use to present the mobile browser.
\item
  \texttt{session}: The session that you want to authenticate. Its
  \texttt{server} property must be set.
\item
  \texttt{clientId}: The ID of the portal's OAuth 2 application that you
  want to use. To find this value, navigate to that application in the
  portal's OAuth 2 Admin portlet.
\item
  \texttt{scopes}: The portal permissions to request. You can define a
  set of permissions associated with an OAuth 2 application in the
  portal's OAuth 2 Admin portlet. Use this property to request a subset
  of those permissions.
\item
  \texttt{redirectUri}: The URI that the user is redirected to after
  successful login in the mobile browser. You must configure this URI in
  the portal via the OAuth 2 Admin portlet, and associate the URI with
  the Android app.
\item
  \texttt{customTabsIntent}: The object used to customize the appearance
  of the mobile browser window shown for authentication.
\end{itemize}

This \texttt{signInWithRedirect} method opens the mobile browser to
initiate authentication. You must also configure the redirect URI in
your Android app, which sends the user back to the Android app when
authentication completes.

Here's an example of this workflow:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Configure the redirect URI in the portal via the OAuth2 Administration
  portlet. In the portal, navigate to \emph{Control Panel} →
  \emph{Configuration} → \emph{OAuth2 Administration} and select or
  \href{/docs/7-1/deploy/-/knowledge_base/d/oauth-2-0\#creating-an-application}{create}
  the OAuth 2 application you want to use. Then enter the redirect URI
  in the \emph{Callback URIs} field. The redirect URI in this example is
  \texttt{my-app://my-app}:

  \begin{figure}
  \centering
  \includegraphics{./images/mobile-oauth2-redirect-url.png}
  \caption{Enter the redirect URI in the portal's OAuth 2 application
  you want to use.}
  \end{figure}
\item
  In your Android app, register your redirect URI by editing the
  \texttt{AndroidManifest.xml} file. Add the following code to this
  file:

\begin{verbatim}
<activity
android:name="com.liferay.mobile.android.auth.oauth2.OAuth2RedirectActivity"
    tools:node="replace">
    <intent-filter>
        <action android:name="android.intent.action.VIEW"/>
        <category android:name="android.intent.category.DEFAULT"/>
        <category android:name="android.intent.category.BROWSABLE"/>

        <data android:scheme="<your-scheme>"/>
    </intent-filter>
</activity>
\end{verbatim}

  If you don't want to use a custom scheme and you need to use HTTPS,
  add this instead:

\begin{verbatim}
<activity
    android:name="com.liferay.mobile.android.auth.oauth2.OAuth2RedirectActivity"
    tools:node="replace">
    <intent-filter>
        <action android:name="android.intent.action.VIEW"/>
        <category android:name="android.intent.category.DEFAULT"/>
        <category android:name="android.intent.category.BROWSABLE"/>
        <data android:scheme="https"
              android:host="your.custom.domain"
              android:path="/oauth2redirect"/>
    </intent-filter>
</activity>
\end{verbatim}
\item
  In the activity in which you want to perform the authentication, call
  \texttt{OAuth2SignIn.signInWithRedirect}:

\begin{verbatim}
private void doLogin() {
    Session session = new SessionImpl("http://my-server.com");
    OAuth2SignIn.signInWithRedirect(this, session, "54321", new ArrayList<>(), 
    Uri.parse("my-app://my-app"), null);
}
\end{verbatim}

  This opens the mobile browser with the login page.
\item
  In the same activity, you must override the method
  \texttt{onActivityResult} to receive the authentication's result. In
  this method, you do this by calling the method
  \texttt{OAuth2SignIn.resumeAuthorizationFlowWithIntent}:

\begin{verbatim}
@Override
protected void onActivityResult(int requestCode, int resultCode, Intent intent) {
    super.onActivityResult(requestCode, resultCode, intent);

    if (requestCode == OAuth2SignIn.REDIRECT_REQUEST_CODE) {
        Session session = new SessionImpl("http://my-server.com");
        OAuth2SignIn.resumeAuthorizationFlowWithIntent(this, session, intent,
        new SessionCallback() {
            @Override
            public void onSuccess(Session session) {
                // Login success
            }

            @Override
            public void onFailure(Exception e) {
                // Login error
            }
        );
    }
}
\end{verbatim}
\end{enumerate}

\subsection{Resource Owner Password}\label{resource-owner-password-2}

Authenticating via the Resource Owner Password grant type is similar to
authenticating via the PKCE grant type, except you don't need to
configure a redirect URL. You instead handle the user's credentials
directly in your Android app via a different \texttt{OAuth2SignIn}
method:

\begin{verbatim}
public static Session signInWithUsernameAndPassword(String username, String password, Session session,
    String clientId, String clientSecret, List<String> scopes, SessionCallback callback)
\end{verbatim}

Compared to the \texttt{OAuth2SignIn.signInWithRedirect} method used for
the PKCE grant type, this one requires the user's credentials instead of
a redirect URI. It also requires the OAuth 2 application's client secret
from the portal, and a callback.

Here are descriptions of this method's parameters:

\begin{itemize}
\tightlist
\item
  \texttt{username}: The user's username.
\item
  \texttt{password}: The user's password.
\item
  \texttt{session}: The session that you want to authenticate. Its
  \texttt{server} property must be set.
\item
  \texttt{clientId}: The ID of the portal's OAuth 2 application that you
  want to use. To find this value, navigate to that application in the
  portal's OAuth 2 Admin portlet.
\item
  \texttt{clientSecret}: The client secret of the same OAuth 2
  application in the portal.
\item
  \texttt{scopes}: The portal permissions to request. You can define a
  set of permissions associated with an OAuth 2 application in the
  portal's OAuth 2 Admin portlet. Use this property to request a subset
  of those permissions.
\item
  \texttt{callback}: A \texttt{SessionCallback} object containing the
  authentication's result. If authentication succeeds, you receive a
  non-null session containing the authentication; otherwise you receive
  an error.
\end{itemize}

\noindent\hrulefill

\textbf{Note:} You can call the
\texttt{OAuth2SignIn.signInWithUsernameAndPassword} method without a
callback by passing \texttt{null} in place of the callback. This causes
the request to execute synchronously. If you provide a callback, the
request is executed asynchronously in another thread and the callback
receives the response.

\noindent\hrulefill

Here's an example of calling the
\texttt{OAuth2SignIn.signInWithUsernameAndPassword} method for the
Resource Owner Password grant type. After creating the session, the
method is called with a \texttt{SessionCallback} created as an anonymous
inner class:

\begin{verbatim}
Session session = new SessionImpl("http://my-server.com");

OAuth2SignIn.signInWithUsernameAndPassword("username", "password", session, "12345", "12345", 
    new ArrayList<>(), new SessionCallback() {

    @Override
    public void onSuccess(Session session) {
        // Login correct
    }

    @Override
    public void onFailure(Exception e) {
        // Login error
    }
});
\end{verbatim}

\subsection{Client Credentials}\label{client-credentials-2}

The OAuth 2 Client Credentials grant type authenticates without
requiring user interaction. This is useful when the app needs to access
its own resources, not those of a specific user.

\noindent\hrulefill

\textbf{Warning:} The Client Credentials grant type poses a security
risk to the portal. To authenticate without user credentials, the mobile
app must contain the OAuth 2 application's client ID and client secret.
Anyone who can access those values via the mobile app can also
authenticate without user credentials.

\noindent\hrulefill

To authenticate with the Client Credentials grant type, you must call
the \texttt{OAuth2SignIn.clientCredentialsSignIn} method. Note that this
method lacks arguments for user credentials or redirect URIs:

\begin{verbatim}
public static Session clientCredentialsSignIn(Session session, String clientId, String clientSecret,
    List<String> scopes, SessionCallback callback)
\end{verbatim}

Here are descriptions of this method's parameters:

\begin{itemize}
\tightlist
\item
  \texttt{sesssion}: The session that you want to authenticate. Its
  \texttt{server} property must be set.
\item
  \texttt{clientId}: The ID of the portal's OAuth 2 application that you
  want to use. To find this value, navigate to that application in the
  portal's OAuth 2 Admin portlet.
\item
  \texttt{clientSecret}: The client secret of the same OAuth 2
  application in the portal.
\item
  \texttt{scopes}: The portal permissions to request. You can define a
  set of permissions associated with an OAuth 2 application in the
  portal's OAuth 2 Admin portlet. Use this property to request a subset
  of those permissions.
\item
  \texttt{callback}: A \texttt{SessionCallback} object containing the
  authentication's result. If authentication succeeds, you receive a
  non-null session containing the authentication; otherwise you receive
  an error.
\end{itemize}

\noindent\hrulefill

\textbf{Note:} You can call the
\texttt{OAuth2SignIn.clientCredentialsSignIn} method without a callback
by passing \texttt{null} in place of the callback. This causes the
request to execute synchronously. If you provide a callback, the request
is executed asynchronously in another thread and the callback receives
the response.

\noindent\hrulefill

Here's an example of calling the
\texttt{OAuth2SignIn.clientCredentialsSignIn} method for the Resource
Owner Password grant type. After creating the session, the method is
called with a \texttt{SessionCallback} created as an anonymous inner
class:

\begin{verbatim}
Session session = new SessionImpl("http://my-server.com");

OAuth2SignIn.clientCredentialsSignIn(session, "12345", "12345", new ArrayList<>(), 
    new SessionCallback() {

    @Override
    public void onSuccess(Session session) {
        // Login correct
    }

    @Override
    public void onFailure(Exception e) {
        // Login error
    }
});
\end{verbatim}

\subsection{Related Topics}\label{related-topics-278}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-oauth-2-in-liferay-screens-for-android}{Using
OAuth 2 in Liferay Screens for Android}

\href{/docs/7-1/deploy/-/knowledge_base/d/oauth-2-0}{OAuth 2.0}

\chapter{Creating iOS Apps that Use the Mobile
SDK}\label{creating-ios-apps-that-use-the-mobile-sdk}

The Liferay Mobile SDK provides a way to streamline the consumption of
Liferay DXP's core web services and utilities, as well as those of
custom apps. It wraps Liferay DXP's JSON web services, making them easy
to call in native mobile apps. It handles authentication, makes HTTP
requests (synchronously or asynchronously), parses JSON results, and
handles server-side exceptions so you can concentrate on \emph{using}
the services in your app.

The Liferay Mobile SDK comes with the Liferay iOS SDK. The official
\href{https://www.liferay.com/community/liferay-projects/liferay-mobile-sdk/overview}{project
page} gives you access to the SDK releases, provides the latest SDK
news, and has forums for you to engage in mobile app development
discussions. Once you configure the Mobile SDK in your app, you can
invoke Liferay DXP services in it.

\begin{figure}
\centering
\includegraphics{./images/mobile-sdk-diagram.png}
\caption{Liferay's Mobile SDK enables your native app to communicate
with Liferay.}
\end{figure}

The iOS Mobile SDK app development tutorials cover these topics:

\begin{itemize}
\tightlist
\item
  Making Liferay and Custom Portlet Services Available in Your iOS App
\item
  Invoking Liferay Services in Your iOS App
\item
  Invoking Services Asynchronously from Your iOS App
\item
  Sending Your iOS App's Requests Using Batch Processing
\end{itemize}

A great way to start is by setting up the Mobile SDK your iOS project.
This makes Liferay DXP's services available in your app.

\section{Related Topics}\label{related-topics-279}

\href{/docs/7-1/tutorials/-/knowledge_base/t/invoking-liferay-services-in-your-ios-app}{Invoking
Liferay Services in Your iOS App}

\href{/docs/7-1/tutorials/-/knowledge_base/t/building-mobile-sdks}{Building
Mobile SDKs}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-android-apps-that-use-the-mobile-sdk}{Creating
Android Apps that Use the Mobile SDK}

\section{Making Liferay and Custom Portlet Services Available in Your
iOS
App}\label{making-liferay-and-custom-portlet-services-available-in-your-ios-app}

Your iOS app is no doubt pretty great, or at least off to a great start.
Now you want it to access Liferay services. How do you accomplish this?
Use Liferay's iOS Mobile SDK, of course! You must install the correct
Mobile SDKs in your iOS project to call the remote services you need in
your app. You should first install Liferay's prebuilt Mobile SDK. This
is required for any app that leverages Liferay. To call your custom
portlet's services, you also need to install the Mobile SDK that you
built for it. For instructions on building a Mobile SDK for your custom
portlet, see the tutorial
\href{/docs/7-1/tutorials/-/knowledge_base/t/building-mobile-sdks}{Building
Mobile SDKs}.

This tutorial shows you how to install Liferay's prebuilt Mobile SDK,
and any custom built Mobile SDKs. First, you'll learn how to use
\href{https://cocoapods.org/}{CocoaPods} to install Liferay's prebuilt
Mobile SDK. You'll then learn how to install a Mobile SDK manually,
which is required for installing any custom built Mobile SDKs. Now go
forth and fear no remote service!

\subsection{Installing the SDK Using
CocoaPods}\label{installing-the-sdk-using-cocoapods}

Using CocoaPods is the simplest way to install Liferay's prebuilt Mobile
SDK. The steps for doing so are shown here:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Make sure you have \href{https://cocoapods.org/}{CocoaPods} installed.
\item
  Create a file called \texttt{Podfile} in your project. Add the
  following line in this file:

\begin{verbatim}
 pod 'Liferay-iOS-SDK'
\end{verbatim}
\item
  Run \texttt{pod\ install} from your project's directory. This
  downloads the latest version of the Liferay iOS Mobile SDK and creates
  a \texttt{.xcworkspace} file. CocoaPods also downloads all the
  necessary dependencies and configures your workspace. Note that you
  may have to run \texttt{pod\ repo\ update} before running
  \texttt{pod\ install}; this ensures you have the latest version of the
  CocoaPods repository on your machine.
\item
  Use the \texttt{.xcworkspace} file to open your project in Xcode.
\item
  If you're importing dependencies as frameworks
  (\texttt{use\_frameworks!} in your Podfile), you need to import the
  \texttt{LRMobileSDK} module:

\begin{verbatim}
 @import LRMobileSDK; // (Objective-C)
 import LRMobileSDK // (Swift)
\end{verbatim}
\end{enumerate}

For more information on how CocoaPods works, see their
\href{http://guides.cocoapods.org/using/index.html}{documentation}.
Next, you'll learn how to install a Mobile SDK manually.

\subsection{Installing an iOS SDK
Manually}\label{installing-an-ios-sdk-manually}

You can also install Mobile SDKs manually. This is required if you built
one for your custom portlet's services. You can also install install
Liferay's prebuilt Mobile SDK manually if you don't want to use
CocoaPods.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  To install Liferay's prebuilt Mobile SDK, first
  \href{https://github.com/liferay/liferay-mobile-sdk/releases}{download}
  the latest version of the Liferay iOS Mobile SDK ZIP file. If you
  built your own Mobile SDK, find its ZIP file on your machine. This is
  detailed in the
  \href{/docs/7-1/tutorials/-/knowledge_base/t/building-mobile-sdks}{Building
  Mobile SDKs} tutorial.
\item
  Unzip the file into your Xcode project.
\item
  Within Xcode, right-click on your project and click \emph{Add Files to
  `Project Name'}.
\item
  Add the \texttt{core} and \texttt{v7} folders. Note the \texttt{v7}
  folder's name can change for each Liferay version. In this example,
  the SDK is built for Liferay 7.0.
\item
  If you're manually installing Liferay's prebuilt Mobile SDK, it also
  requires
  \href{https://github.com/AFNetworking/AFNetworking/releases/tag/2.6.3}{AFNetworking
  2.6.3}. Add its source code to your project.
\end{enumerate}

Great! Now you know how to manually install a Mobile SDK in your iOS
apps.

\subsection{Understanding Liferay and iOS
Compatibility}\label{understanding-liferay-and-ios-compatibility}

Each Liferay Mobile SDK is designed to work with a specific Liferay
version. The Liferay Mobile SDK version number reflects this. The first
two digits of each Mobile SDK's version number correspond to the
compatible Liferay version. For example, a Mobile SDK version
\texttt{6.2.*} is compatible with Liferay 6.2, while a Mobile SDK
version \texttt{7.0.*} is compatible with Liferay 7.0. Any digits after
the first two correspond to the internal Liferay Mobile SDK build.

The Mobile SDK's service class names are also suffixed with the Mobile
SDK's version number. This lets your app support several Liferay
versions. For example, you can add Mobile SDK versions \texttt{6.2.0.22}
and \texttt{7.0.3} to the same project. The Mobile SDK service classes
supporting Liferay versions 6.2 and 7.0 end in \texttt{\_v62.m} and
\texttt{\_v7.m}, respectively. To find out the Liferay versions your app
connects to, use the
\texttt{{[}LRPortalVersionUtil\ getPortalVersion:...{]}} method.

The Liferay iOS Mobile SDK is compatible with iOS versions 7.0 and up.
Older iOS versions may work, but compatibility is untested.

\subsection{Making Custom Portlet Services Available in Your iOS
App}\label{making-custom-portlet-services-available-in-your-ios-app}

If you want to invoke remote web services for your custom portlet, then
you need to generate its client libraries by building an iOS Mobile SDK
yourself. Building an SDK is covered in the tutorial
\href{/docs/7-1/tutorials/-/knowledge_base/t/building-mobile-sdks}{Building
Mobile SDKs}. Once you build an SDK to a ZIP file, you can install it
using the manual installation steps above (make sure to use the ZIP file
you built instead of Liferay's prebuilt ZIP file). Note that because
your custom built SDKs contain \emph{only} the client libraries for
calling your custom portlet services, you must install them alongside
Liferay's prebuilt SDK. Liferay's prebuilt SDK contains additional
classes that are required to construct any remote service call.

\subsection{Related Topics}\label{related-topics-280}

\href{/docs/7-1/tutorials/-/knowledge_base/t/building-mobile-sdks}{Building
Mobile SDKs}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-android-apps-that-use-the-mobile-sdk}{Creating
Android Apps that Use the Mobile SDK}

\section{Invoking Liferay Services in Your iOS
App}\label{invoking-liferay-services-in-your-ios-app}

Once the appropriate Mobile SDKs are set up in your iOS project, you can
access and invoke @product services in your app. This tutorial takes you
through the steps you must follow to invoke these services:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Create a session.
\item
  Import the @product services you need to call.
\item
  Create a service object and call the service methods.
\end{enumerate}

Since some service calls require special treatment, this tutorial also
shows you how to handle them. Note that the code snippets in this
tutorial are written in Objective-C.

First, you'll learn about securing Liferay DXP's JSON web services in
the portal.

\subsection{Securing JSON Web
Services}\label{securing-json-web-services-4}

The Liferay Mobile SDK calls Liferay DXP's JSON web services, which are
enabled by default. The web services you call via the Mobile SDK must
remain enabled for those calls to work. It's possible, however, to
disable the web services that you don't need to call. For instructions
on this, see the tutorial
\href{/docs/7-1/tutorials/-/knowledge_base/t/configuring-json-web-services}{Configuring
JSON Web Services}. You can also use
\href{/docs/7-1/tutorials/-/knowledge_base/t/service-access-policies}{Service
Access Policies} for more fine-grained control over accessible services.

\subsection{Step 1: Create a Session}\label{step-1-create-a-session-1}

A session is a conversion state between the client and server,
consisting of multiple requests and responses between the two. You need
a session to pass requests between your app and the Mobile SDK. In most
cases, sessions need to be created with user authentication. The imports
and code required to create a session are shown here:

\begin{verbatim}
#import "LRBasicAuthentication.h"
#import "LRSession.h"

LRSession *session = [[LRSession alloc] initWithServer:@"http://localhost:8080" 
    authentication:[[LRBasicAuthentication alloc] initWithUsername:@"test@example.com" password:@"test"]];
\end{verbatim}

The \texttt{LRSession} object is created with initializers specifying
the Liferay instance to connect to and the credentials of the user to
authenticate. The \texttt{initWithServer} parameter sets the URL of the
Liferay instance you're connecting to. In this case, the Liferay
instance is running on \texttt{http://localhost:8080}. The iOS emulator
is also running on the same machine. Next, the \texttt{authentication}
parameter takes an \texttt{LRBasicAuthentication} instance with the
credentials of the user to authenticate. Depending on the authentication
method used by your Liferay instance, you need to provide the user's
email address, screen name, or user ID to the \texttt{initWithUsername}
parameter. You also need to provide the user's password to the
\texttt{password} parameter.

Using \texttt{LRBasicAuthentication} tells the session to authenticate
each service call with Basic Authentication. The Mobile SDK also
supports OAuth 2 authentication. For instructions on this, see the
tutorial
\href{/docs/7-1/tutorials/-/knowledge_base/t/using-oauth-2-in-the-ios-mobile-sdk}{Using
OAuth 2 in the iOS Mobile SDK}.

\noindent\hrulefill

\textbf{Warning:} Be careful when using administrator credentials on a
production portal instance, as you'll have permission to call any
service. Make sure not to modify data accidentally. Of course, the
default administrator credentials should be disabled on a production
portal instance.

\noindent\hrulefill

If you're building a sign in view for your app, you can use the
\texttt{LRSignIn} utility class to check if the credentials given by the
user are valid:

\begin{verbatim}
#import "LRSignIn.h"

[session
    onSuccess:^(id result) {
        user = result;
        [monitor signal];
    }
    onFailure:^(NSError *e) {
        error = e;
        [monitor signal];
    }
];

[LRSignIn signInWithSession:session callback:session.callback error:&error];
\end{verbatim}

The Mobile SDK doesn't keep a persistent connection or session with the
server. Each request is sent with the user's credentials (except when
using OAuth). However, the \texttt{SignIn} class provides a way to
return user information after a successful sign-in.

You can persist credentials with \texttt{LRCredentialStorage}. It safely
saves the username and password in the keychain:

\begin{verbatim}
[LRCredentialStorage storeCredentialForServer:@"http://localhost:8080" 
    username:@"test@example.com" password:@"test"];
\end{verbatim}

After credentials are stored, you can retrieve them with:

\begin{verbatim}
NSURLCredential *credential = [LRCredentialStorage getCredential];
\end{verbatim}

Alternatively, you can create an \texttt{LRSession} instance directly
with:

\begin{verbatim}
LRSession *session = [LRCredentialStorage getSession];
\end{verbatim}

For more examples of this, see
\href{https://github.com/liferay/liferay-mobile-sdk/blob/ios-6.2.0.17/ios/Test/CredentialStorageTest.m}{\texttt{CredentialStorageTest.m}}.

Next, you're shown how to create an unauthenticated session in the
limited cases where this is possible.

\subsubsection{Creating an Unauthenticated
Session}\label{creating-an-unauthenticated-session-1}

In some cases, it's possible to create an \texttt{LRSession} instance
without user credentials. However, most Liferay remote methods don't
accept unauthenticated remote calls. Making a call with an
unauthenticated session generates an
\texttt{Authentication\ access\ required} exception in most cases.

Unauthenticated service calls only work if the remote method in the
Liferay instance or your plugin has the \texttt{@AccessControlled}
annotation. This is shown here for the hypothetical class
\texttt{FooServiceImpl} and its method \texttt{bar}:

\begin{verbatim}
import com.liferay.portal.security.ac.AccessControlled;
...
public class FooServiceImpl extends FooServiceBaseImpl {
...
    @AccessControlled(guestAccessEnabled = true)
    public void bar() { ... }
...
\end{verbatim}

To make such a call, you need to use the constructor that accepts the
server URL only:

\begin{verbatim}
LRSession *session = [[LRSession alloc] initWithServer:@"http://localhost:8080"];
\end{verbatim}

Fantastic! Now that you have a session, you can use it to call Liferay's
services.

\subsection{Step 2: Import the Service}\label{step-2-import-the-service}

First, you should determine the Liferay services you need to call. You
can find the available services at
\href{http://localhost:8080/api/jsonws}{\texttt{http://localhost:8080/api/jsonws}}.
Be sure to replace \texttt{http://localhost:8080} in this URL with your
server's address.

Once you determine the services you need to call, add their imports. For
example, if you're building a blogs app, you can import
\texttt{LRBlogsEntryService}:

\begin{verbatim}
#import "LRBlogsEntryService_v62.h"
\end{verbatim}

Note that the Liferay version (\texttt{\_v62}) is used in the service
class's name. This corresponds to the Liferay version it's compatible
with. In this example, \texttt{\_v62} is used, which means this Mobile
SDK class is compatible with Liferay 6.2. Mobile SDK classes compatible
with Liferay 7.0 use \texttt{\_v7} instead. Because service class names
contain the Liferay version they're compatible with, you can use several
Mobile SDKs simultaneously to support different Liferay versions in the
same app.

\subsection{Step 3: Calling the
Service}\label{step-3-calling-the-service}

Once you have a session and have imported the service class, you're
ready to make the service call. This is done by creating a service
object for the service you want to call, and then calling its service
methods. For example, if you're creating a blogs app, you need to use
\texttt{LRBlogsEntryService} to get all the blogs entries from a site.
This is demonstrated by the following code.

\begin{verbatim}
LRBlogsEntryService_v62 *service = [[LRBlogsEntryService_v62 alloc] initWithSession:session];

NSError *error;
NSArray *entries = [service getGroupEntriesWithGroupId:10184 status:0 start:-1 end:-1 error:&error];
\end{verbatim}

This fetches all blog entries from the \emph{Guest} site. In this
example, the \emph{Guest} site's \texttt{groupId} is \texttt{10184}.
Note that many service methods require \texttt{groupId} as a parameter.
You can get the user's groups by calling
\texttt{{[}LRGroupService\_v62\ getUserSites:\&error{]}}.

Service method return types can be \texttt{void}, \texttt{NSString},
\texttt{NSArray}, \texttt{NSDictionary}, \texttt{NSNumber}, and
\texttt{BOOL}.

This \texttt{LRBlogsEntryService} call is a basic example of a
synchronous service call. The method in a synchronous service call
returns only after the request is finished.

\subsection{Non-Primitive Arguments}\label{non-primitive-arguments-1}

There are some special cases in which service method arguments aren't
primitives. In these cases, you should use \texttt{LRJSONObjectWrapper}.
For example:

\begin{verbatim}
LRJSONObjectWrapper *wrapper = [[LRJSONObjectWrapper alloc] 
    initWithJSONObject:[NSDictionary dictionary]];
\end{verbatim}

You must pass a dictionary containing the object's properties and their
values. On the server side, your object is instantiated and setters for
each property are called with the values from the dictionary.

There are some other cases in which service methods require interfaces
or abstract classes as arguments. Since it's impossible for the SDK to
guess which implementation you want to use, you must initialize
\texttt{LRJSONObjectWrapper} with the class name. For example:

\begin{verbatim}
LRJSONObjectWrapper *wrapper = [[LRJSONObjectWrapper alloc] 
    initWithClassName:@"com.example.MyClass" jsonObject:[NSDictionary dictionary]];
\end{verbatim}

The server looks for the class name in its classpath and instantiates
the object for you. It then calls setters, as in the previous example.
The abstract class \texttt{OrderByComparator} is a good example of this.
This is discussed next.

\subsubsection{OrderByComparator}\label{orderbycomparator-1}

On the server side, \texttt{OrderByComparator} is an abstract class. You
must therefore pass the name of a class that implements it. For example:

\begin{verbatim}
NSString *className = @"com.liferay.portlet.bookmarks.util.comparator.EntryNameComparator";

LRJSONObjectWrapper *orderByComparator = [[LRJSONObjectWrapper alloc] initWithClassName:className jsonObject:[NSDictionary dictionary]];
\end{verbatim}

If the service you're calling accepts \texttt{null} for a comparator
argument, pass \texttt{nil} to the service call.

You may want to set the ascending property for a comparator.
Unfortunately, as of Liferay 6.2, most Liferay
\texttt{OrderByComparator} implementations don't have a setter for this
property and it isn't possible to set from the Mobile SDK. Future
Liferay versions may address this. However, you may have a custom
\texttt{OrderByComparator} that has a setter for ascending. In this
case, you can use the following code:

\begin{verbatim}
NSString *className = @"com.example.MyOrderByComparator";

NSDictionary *jsonObject = @{
    @"ascending": @(YES)
};

LRJSONObjectWrapper *orderByComparator = [[LRJSONObjectWrapper alloc] 
    initWithClassName:className jsonObject:jsonObject];
\end{verbatim}

For more examples, see the test case
\href{https://github.com/liferay/liferay-mobile-sdk/blob/ios-6.2.0.17/ios/Test/OrderByComparatorTest.m}{\texttt{OrderByComparatorTest.m}}.

\subsubsection{ServiceContext}\label{servicecontext-1}

Another non-primitive argument is \texttt{ServiceContext}. It requires
special attention because most Liferay service methods require it.
However, you aren't required to pass it to the SDK; you can pass
\texttt{nil} instead. The server then creates a \texttt{ServiceContext}
instance for you, using default values.

If you need to set properties for \texttt{ServiceContext}, you can do so
by adding them to a new \texttt{NSDictionary} and then passing it as the
\texttt{ServiceContext} argument:

\begin{verbatim}
NSDictionary *jsonObject = @{
    @"addGroupPermissions": @(YES),
    @"addGuestPermissions": @(YES)
};

LRJSONObjectWrapper *serviceContext = [[LRJSONObjectWrapper alloc] initWithJSONObject:jsonObject];
\end{verbatim}

For more examples, see the test case
\href{https://github.com/liferay/liferay-mobile-sdk/blob/ios-6.2.0.17/ios/Test/ServiceContextTest.m}{\texttt{ServiceContextTest.m}}.

\subsubsection{Binaries}\label{binaries-1}

Some Liferay services require binary argument types like \texttt{NSData}
or \texttt{LRUploadData}. The Mobile SDK converts \texttt{NSData}
instances to \texttt{NSString} before sending the POST request. For
example, \texttt{{[}@"hello"\ dataUsingEncoding:NSUTF8StringEncoding{]}}
becomes a JSON array such as \texttt{"{[}104,101,108,108,111{]}"}. The
Mobile SDK does this for you, so you don't have worry about it; you only
need to pass the \texttt{NSData} instance to the method.

However, you need to be careful when using such methods. This is because
you're allocating memory for the whole \texttt{NSData}, which may cause
memory issues if the content is large.

Other Liferay service methods require \texttt{java.io.File} as an
argument. In these cases the Mobile SDK requires \texttt{LRUploadData}
instead. Here are two examples of creating \texttt{LRUploadData}
instances:

\begin{verbatim}
LRUploadData *upload = [[LRUploadData alloc] 
    initWithData:data fileName:@"file.png" mimeType:@"image/png"];

LRUploadData *upload = [[LRUploadData alloc] 
    initWithInputStream:is length:length fileName:@"file.png" mimeType:@"image/png"];
\end{verbatim}

The first constructor accepts an \texttt{NSData} argument, while the
second accepts \texttt{NSInputStream}. As you can see, you also need to
pass the file's mime type and name. The \texttt{length} is the size in
bytes of the content being sent. The SDK sends a multipart form request
to the Liferay instance. On the server side, a \texttt{File} instance is
created and sent to the service method you're calling.

It's also possible to monitor service calls that upload data to Liferay.
If want to listen for upload progress to create a progress bar, you can
create a \texttt{LRProgressDelegate} delegate and set it to an
\texttt{LRUploadData} object. Its \texttt{onProgressBytes} method is
called for each byte chunk sent. It passes the bytes that were sent, the
total number of bytes sent so far, and the total request size. For
example:

\begin{verbatim}
@interface ProgressDelegate : NSObject <LRProgressDelegate>

@end

@implementation ProgressDelegate

- (void)onProgressBytes:(NSUInteger)bytes sent:(long long)sent
    total:(long long)total {

        // bytes contains the byte values that were sent.
        // sent will contain the total number of bytes sent.
        // total will contain the total size of the request in bytes.

}

@end
\end{verbatim}

For more examples of this, see the test case
\href{https://github.com/liferay/liferay-mobile-sdk/blob/ios-6.2.0.17/ios/Test/FileUploadTest.m}{\texttt{FileUploadTest.m}}.

\subsection{Related Topics}\label{related-topics-281}

\href{/docs/7-1/tutorials/-/knowledge_base/t/building-mobile-sdks}{Building
Mobile SDKs}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-android-apps-that-use-the-mobile-sdk}{Creating
Android Apps that Use the Mobile SDK}

\section{Invoking Services Asynchronously from Your iOS
App}\label{invoking-services-asynchronously-from-your-ios-app}

The main drawback of using synchronous requests from your app is that
each request must terminate before another can begin. If you're sending
a large number of synchronous requests, performance suffers as a
bottleneck forms while each one waits to be processed. Fortunately,
Liferay's iOS SDK allows \emph{asynchronous} HTTP requests. To do so,
you need to set a callback to the session object. If you want to make
synchronous requests again, you can set the callback to \texttt{nil}.

With the following steps, this tutorial shows you how to implement
asynchronous requests in your iOS app:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Implement your callback class.
\item
  Instantiate your callback class and set it to the session.
\item
  Call Liferay services.
\end{enumerate}

Objective-C is used in the code snippets that follow. Let the requesting
begin!

\subsection{Implementing Your Callback
Class}\label{implementing-your-callback-class}

To configure asynchronous requests, first create a class that conforms
to the \texttt{LRCallback} protocol. When implementing this callback
class, you need to implement its \texttt{onFailure} and
\texttt{onSuccess} methods. These methods respectively determine what
your app does when the request fails or succeeds. If a server side
exception or a connection error occurs during the request, the
\texttt{onFailure} method is called with an \texttt{NSError} instance
that contains information about the error. Note that the
\texttt{onSuccess} result parameter doesn't have a specific type. When
deciding what to cast it to, you need to check the type in the service
method signature.

The example code here implements a callback class for an app that
retrieves blog entries from a Blogs portlet. The service method for this
call is \texttt{getGroupEntriesWithGroupId}, which returns an
\texttt{NSArray} instance. The \texttt{onSuccess} method's result
parameter is therefore cast to this type:

\begin{verbatim}
#import "LRCallback.h"

@interface BlogsEntriesCallback : NSObject <LRCallback>

@end


#import "BlogsEntriesCallback.h"

@implementation BlogsEntriesCallback

- (void)onFailure:(NSError *)error {
    // Implement error handling code
}

- (void)onSuccess:(id)result {
    // Called after request has finished successfully
    NSArray *entries = (NSArray *)result;
}

@end
\end{verbatim}

Awesome! Now you have a callback class that you can use with the
session.

\subsection{Set the Callback to the
Session}\label{set-the-callback-to-the-session}

Next, create an instance of this callback and set it to the session. If
you haven't created a session yet, do so now. The tutorial
\href{/docs/7-1/tutorials/-/knowledge_base/t/invoking-liferay-services-in-your-ios-app}{Invoking
Liferay Services in Your iOS App} shows you how to create a session. Now
you're ready to set the callback to the session. For example, this is
done here for \texttt{BlogsEntriesCallback}:

\begin{verbatim}
BlogsEntriesCallback *callback = [[BlogsEntriesCallback alloc] init];

[session setCallback:callback];
\end{verbatim}

Pretty simple! Now you're ready to make the service call.

\subsection{Making the Service Call}\label{making-the-service-call-1}

Last but certainly not least, make the service call. This is done the
same as calling any other service: create a service object from the
session and use it to make the service call. This is also described in
the tutorial
\href{/docs/7-1/tutorials/-/knowledge_base/t/invoking-liferay-services-in-your-ios-app}{Invoking
Liferay Services in Your iOS App}. Here, an example service call that
gets all the blog entries from a site's Blogs portlet is shown:

\begin{verbatim}
[service getGroupEntriesWithGroupId:10184 status:0 start:-1 end:-1 error:&error];
\end{verbatim}

Since the request is asynchronous, \texttt{getGroupEntriesWithGroupId}
immediately returns \texttt{nil}. Once the request finishes
successfully, the \texttt{onSuccess} method of your callback is invoked
with the results on the main UI thread.

Great! Now you know how to make asynchronous requests in your iOS apps.
However, there's another way to accomplish the same thing. This is
discussed next.

\subsection{Using Blocks as Callbacks}\label{using-blocks-as-callbacks}

Instead of implementing a separate callback class, you can use an
Objective-C block as a callback. An example of this is shown here for an
asynchronous call that retrieves a user's sites. Note that this includes
all the code required to make the call:

\begin{verbatim}
LRSession *session = [[LRSession alloc] 
    initWithServer:@"http://localhost:8080" username:@"test@example.com" password:@"test"];

[session
    onSuccess:^(id result) {
        // Called after request has finished successfully
    }
    onFailure:^(NSError *e) {
        // Implement error handling code
    }
];

LRGroupService_v62 *service = [[LRGroupService_v62 alloc] initWithSession:session];

NSError *error;
[service getUserSites:&error];
\end{verbatim}

When using a block as a callback, take care not to also set an
\texttt{LRCallback} instance to the session. If you do, it gets
overridden. Otherwise, support for blocks works the same way as
described in the previous sections.

Super! Now you know two different ways to make asynchronous service
requests in your iOS apps.

\subsection{Related Topics}\label{related-topics-282}

\href{/docs/7-1/tutorials/-/knowledge_base/t/invoking-liferay-services-in-your-ios-app}{Invoking
Liferay Services in Your iOS App}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-android-apps-that-use-the-mobile-sdk}{Creating
Android Apps that Use the Mobile SDK}

\section{Sending Your iOS App's Requests Using Batch
Processing}\label{sending-your-ios-apps-requests-using-batch-processing}

The Mobile SDK also allows sending requests in batch. This can be much
more efficient than sending separate requests. For example, suppose you
want to delete ten blog entries in a site's Blogs portlet at the same
time. Instead of making a request for each deletion, you can create a
batch of calls and send them all together.

This tutorial shows you how to implement batch processing for your iOS
app. It's assumed that you already know how to invoke Liferay services
from your iOS app. If you don't, see the tutorial
\href{/docs/7-1/tutorials/-/knowledge_base/t/invoking-liferay-services-in-your-ios-app}{Invoking
Liferay Services in Your iOS App}. Objective-C is used in the code
snippets that follow. Now it's time to whip up a fresh batch of
requests!

\subsection{Implementing Batch
Processing}\label{implementing-batch-processing-1}

Making service calls in batch only requires two extra steps over making
them one at a time:

\begin{itemize}
\tightlist
\item
  Create a batch session with \texttt{LRBatchSession}.
\item
  Make the batch service calls with the \texttt{invoke} method of
  \texttt{LRBatchSession}.
\end{itemize}

The rest of the steps are the same as making other service calls. You
still need a service object, and you still need to call its service
methods. As an example, here's a code snippet from an app that deletes a
Blogs portlet's blog entries synchronously in batch:

\begin{verbatim}
#import "LRBatchSession.h"

LRBatchSession *batch = [[LRBatchSession alloc] 
    initWithServer:@"http://localhost:8080" username:@"test@example.com" password:@"test"];
LRBlogsEntryService_v62 *service = [[LRBlogsEntryService_v62 alloc] initWithSession:batch];
NSError *error;

[service deleteEntryWithEntryId:1 error:&error];
[service deleteEntryWithEntryId:2 error:&error];
[service deleteEntryWithEntryId:3 error:&error];

NSArray *entries = [batch invoke:&error];
\end{verbatim}

So what's going on here? After the import, \texttt{LRBatchSession} is
used with a Liferay instance's URL and a user's credentials to create a
batch session. You can alternatively pass a pre-existing
\texttt{session} to the constructor. This is useful when you already
have a session object and want to reuse the same credentials. Next, the
service calls are made as usual (in this case,
\texttt{deleteEntryWithEntryId}). With asynchronous calls, these methods
return \texttt{nil} right away. Finally, call
\texttt{{[}batch\ invoke:\&error{]}}. This returns an \texttt{NSArray}
containing the results for each service call (the return type for batch
calls is always \texttt{NSArray}). Since there are three
\texttt{deleteEntryWithEntryId} calls, the \texttt{entries} array
contains three objects. The order of the results matches the order of
the service calls.

If you want to make batch calls asynchronously, set the callback to the
session as usual.

\begin{verbatim}
[batch setCallback:callback];
\end{verbatim}

Great! Now you know how to utilize batch processing to speed up your
app's requests.

\subsection{Related Topics}\label{related-topics-283}

\href{/docs/7-1/tutorials/-/knowledge_base/t/invoking-liferay-services-in-your-ios-app}{Invoking
Liferay Services in Your iOS App}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-android-apps-that-use-the-mobile-sdk}{Creating
Android Apps that Use the Mobile SDK}

\section{Using OAuth 2 in the iOS Mobile
SDK}\label{using-oauth-2-in-the-ios-mobile-sdk}

You can use \href{https://oauth.net/2/}{OAuth 2} to authenticate using
the following \href{https://oauth.net/2/grant-types/}{OAuth 2 grant
types}:

\begin{itemize}
\item
  \href{https://oauth.net/2/grant-types/authorization-code/}{\textbf{Authorization
  Code (PKCE for native apps):}} Redirects users to a page in their
  mobile browser where they enter their credentials. Following login,
  the browser redirects users back to the mobile app. User credentials
  can't be compromised via the app because it never accesses them---it
  uses a token that can be easily revoked. This is also useful if users
  don't want to enter their credentials in the app. For example, users
  may not want to enter their Twitter credentials directly in a
  3rd-party Twitter app, preferring instead to authenticate via
  Twitter's official site. Note that the site you redirect to for
  authentication must have OAuth 2 implemented.
\item
  \href{https://oauth.net/2/grant-types/password/}{\textbf{Resource
  Owner Password:}} Users authenticate by entering their credentials
  directly in the app.
\item
  \href{https://oauth.net/2/grant-types/client-credentials/}{\textbf{Client
  Credentials:}} Authenticates without requiring user interaction. This
  is useful when the app needs to access its own resources, not those of
  a specific user.
\end{itemize}

This tutorial shows you how to use these grant types with the Mobile
SDK. Note that before getting started, you may want to see
\href{/docs/7-1/deploy/-/knowledge_base/d/oauth-2-0}{Liferay DXP's OAuth
2.0 documentation} for instructions on registering an OAuth 2.0
application in the portal.

\subsection{Authorization Code (PKCE)}\label{authorization-code-pkce-3}

To authenticate via the Authorization Code grant type, you must call the
following \texttt{LROAuth2SignIn} method:

\begin{verbatim}
LROAuth2SignIn.signIn(withRedirectURL: URL, session: LRSession, clientId: String, 
    scopes: [String], callback: (LRSession?, Error?) -> Void) -> LROAuth2AuthorizationFlow
\end{verbatim}

Here are descriptions of this method's parameters:

\begin{itemize}
\tightlist
\item
  \texttt{withRedirectURL}: The URL that the user is redirected to after
  successful login in the mobile browser. You must configure this URL in
  the portal via the OAuth 2 Admin portlet, and
  \href{https://developer.apple.com/documentation/uikit/core_app/communicating_with_other_apps_using_custom_urls}{associate
  the URL with the iOS app}.
\item
  \texttt{session}: The session that you want to authenticate. Its
  \texttt{server} property must be set.
\item
  \texttt{clientId}: The ID of the portal's OAuth 2 application that you
  want to use. To find this value, navigate to that application in the
  portal's OAuth 2 Admin portlet.
\item
  \texttt{scopes}: The portal permissions to request. You can define a
  set of permissions associated with an OAuth 2 application in the
  portal's OAuth 2 Admin portlet. Use this property to request a subset
  of those permissions.
\item
  \texttt{callback}: A function called with the authentication's result.
  If authentication succeeds, you receive a non-null session containing
  the authentication; otherwise you receive an error.
\end{itemize}

This \texttt{LROAuth2SignIn.signIn} method returns an
\texttt{LROAuth2AuthorizationFlow} object that represents an ongoing
authentication request. You must save this as an \texttt{AppDelegate}
property and then call the \texttt{LROAuth2AuthorizationFlow} method
\texttt{resumeAuthorizationFlowWithURL} in the
\texttt{application(\_:open:options:)} method.

Here's an example of this workflow:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Configure the redirect URI in the portal via the OAuth2 Administration
  portlet. In the portal, navigate to \emph{Control Panel} →
  \emph{Configuration} → \emph{OAuth2 Administration} and select or
  \href{/docs/7-1/deploy/-/knowledge_base/d/oauth-2-0\#creating-an-application}{create}
  the OAuth 2 application you want to use. Then enter the redirect URI
  in the \emph{Callback URIs} field. The redirect URI in this example is
  \texttt{my-app://my-app}:

  \begin{figure}
  \centering
  \includegraphics{./images/mobile-oauth2-redirect-url.png}
  \caption{Enter the redirect URL in the portal's OAuth 2 application
  you want to use.}
  \end{figure}
\item
  In your iOS app, register your redirect URL via the \emph{Info} tab in
  your project settings. For instructions on this, see the section
  \emph{Register Your URL Scheme} in
  \href{https://developer.apple.com/documentation/uikit/core_app/communicating_with_other_apps_using_custom_urls}{Apple's
  documentation on using custom URLs}.

  \begin{figure}
  \centering
  \includegraphics{./images/ios-register-url.png}
  \caption{Register the redirect URL in your iOS app.}
  \end{figure}
\item
  In your \texttt{AppDelegate}, create a
  \texttt{LROAuth2AuthorizationFlow} property. You'll set this property
  later when you call the \texttt{LROAuth2SignIn.signIn} method:

\begin{verbatim}
var authorizationFlow: LROAuth2AuthorizationFlow?
\end{verbatim}
\item
  In the view controller in which you'll call
  \texttt{LROAuth2SignIn.signIn}, define the callback that runs with the
  authentication's result. This callback can perform any action you
  need. In this example, if the authentication succeeds the callback
  prints a success message and calls a sample method that tests the
  session's user credentials; otherwise it prints an error message:

\begin{verbatim}
let oauth2Callback: (LRSession?, Error?) -> Void = { session, error in
    if let session = session {
        print("Login successful")
        testCredentials(session: session)
    }
    else {
        print(error!)
    }
}
\end{verbatim}
\item
  In the same view controller, call the \texttt{LROAuth2SignIn.signIn}
  method with the above parameters. Set the resulting
  \texttt{LROAuth2AuthorizationFlow} to the \texttt{AppDelegate}
  property you created in step 3. This example does this in a
  \texttt{loginWithRedirect()} method:

\begin{verbatim}
func loginWithRedirect() {
    let session = LRSession(server: "http://my-server.com")
    let redirectUrl = URL(string: "my-app://my-app")!
    let clientIdRedirect = "54321"

    let authorizationFlow = LROAuth2SignIn.signIn(withRedirectURL: redirectUrl,
        session: session, clientId: clientIdRedirect, scopes: [], callback: oauth2Callback)

    (UIApplication.shared.delegate as! AppDelegate).authorizationFlow = authorizationFlow
}
\end{verbatim}
\item
  In your \texttt{AppDelegate}'s \texttt{application(\_:open:options:)}
  method, call the \texttt{LROAuth2AuthorizationFlow} method
  \texttt{resumeAuthorizationFlow} with the URL. For more information on
  the \texttt{application(\_:open:options:)} method, see the section
  \emph{Handle Incoming URLs} in
  \href{https://developer.apple.com/documentation/uikit/core_app/communicating_with_other_apps_using_custom_urls}{Apple's
  documentation on using custom URLs}:

\begin{verbatim}
@UIApplicationMain
class AppDelegate: UIResponder, UIApplicationDelegate {

    ...

    var authorizationFlow: LROAuth2AuthorizationFlow?

    func application(_ app: UIApplication, open url: URL,
        options: [UIApplicationOpenURLOptionsKey : Any] = [:]) -> Bool {

        if let authorizationFlow = authorizationFlow {
            return authorizationFlow.resumeAuthorizationFlow(with: url)
        }
    }

    ...

}
\end{verbatim}
\end{enumerate}

\subsection{Resource Owner Password}\label{resource-owner-password-3}

Authenticating via the Resource Owner Password grant type is similar to
authenticating via the PKCE grant type, except you don't need a redirect
URL. You instead handle the user's credentials directly in your iOS app
via a slightly different \texttt{LROAuth2SignIn.signIn} method:

\begin{verbatim}
LROAuth2SignIn.signIn(withUsername: String, password: String, session: LRSession, clientId: String, 
    clientSecret: String, scopes: [String], callback: (LRSession?, Error?) -> Void) -> LRSession?
\end{verbatim}

Compared to the \texttt{LROAuth2SignIn.signIn} method used for the PKCE
grant type, this one requires the user's credentials instead of a
redirect URL. It also requires the OAuth 2 application's client secret
from the portal.

Here are descriptions of this method's parameters:

\begin{itemize}
\tightlist
\item
  \texttt{withUsername}: The user's username.
\item
  \texttt{password}: The user's password.
\item
  \texttt{session}: The session that you want to authenticate. Its
  \texttt{server} property must be set.
\item
  \texttt{clientId}: The ID of the portal's OAuth 2 application that you
  want to use. To find this value, navigate to that application in the
  portal's OAuth 2 Admin portlet.
\item
  \texttt{clientSecret}: The client secret of the same OAuth 2
  application in the portal.
\item
  \texttt{scopes}: The portal permissions to request. You can define a
  set of permissions associated with an OAuth 2 application in the
  portal's OAuth 2 Admin portlet. Use this property to request a subset
  of those permissions.
\item
  \texttt{callback}: A function called with the authentication's result.
  If authentication succeeds, you receive a non-null session containing
  the authentication; otherwise you receive an error.
\end{itemize}

\noindent\hrulefill

\textbf{Note:} You can call the \texttt{LROAuth2SignIn.signIn} method
without a callback by passing \texttt{nil} as the \texttt{callback}
argument. This causes the request to execute synchronously. If you
provide a callback, the request is executed asynchronously in another
thread and the callback receives the response.

\noindent\hrulefill

Follow these steps to call the \texttt{LROAuth2SignIn.signIn} method for
the Resource Owner Password grant type:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  If you want to provide a callback, define it in the view controller in
  which you'll call \texttt{LROAuth2SignIn.signIn}. This callback can
  perform any action you need. In this example, if the authentication
  succeeds the callback prints a success message and calls a sample
  method that tests the session's user credentials; otherwise it prints
  an error message:

\begin{verbatim}
let oauth2Callback: (LRSession?, Error?) -> Void = { session, error in
    if let session = session {
        print("Login successful")
        testCredentials(session: session)
    }
    else {
        print(error!)
    }
}
\end{verbatim}
\item
  In the same view controller, call the \texttt{LROAuth2SignIn.signIn}
  method with the above parameters. This example does this in a
  \texttt{loginWithUsernameAndPassword()} method:

\begin{verbatim}
func loginWithUsernameAndPassword() {
    if password.isEmpty {
        fatalError("you have to enter the password")
    }

    let session = LRSession(server: "http://my-server.com")
    let clientId = "12345"
    let clientSecret = "12345"

    _ = try? LROAuth2SignIn.signIn(withUsername: "test@example.com", password: password,
                session: session, clientId: clientId, clientSecret: clientSecret, scopes: [], 
                callback: oauth2Callback)
}
\end{verbatim}
\end{enumerate}

\subsection{Client Credentials}\label{client-credentials-3}

The OAuth 2 Client Credentials grant type authenticates without
requiring user interaction. This is useful when the app needs to access
its own resources, not those of a specific user.

\noindent\hrulefill

\textbf{Warning:} The Client Credentials grant type poses a security
risk to the portal. To authenticate without user credentials, the mobile
app must contain the OAuth 2 application's client ID and client secret.
Anyone who can access those values via the mobile app can also
authenticate without user credentials.

\noindent\hrulefill

To authenticate with the Client Credentials grant type, you must call
the \texttt{LROAuth2SignIn.signIn} method that lacks arguments for user
credentials or redirect URLs:

\begin{verbatim}
LROAuth2SignIn.clientCredentialsSignIn(with: LRSession, clientId: String, 
    clientSecret: String, scopes: [String], callback: (LRSession?, Error?) -> Void)
\end{verbatim}

Here are descriptions of this method's parameters:

\begin{itemize}
\tightlist
\item
  \texttt{with}: The session that you want to authenticate. Its
  \texttt{server} property must be set.
\item
  \texttt{clientId}: The ID of the portal's OAuth 2 application that you
  want to use. To find this value, navigate to that application in the
  portal's OAuth 2 Admin portlet.
\item
  \texttt{clientSecret}: The client secret of the same OAuth 2
  application in the portal.
\item
  \texttt{scopes}: The portal permissions to request. You can define a
  set of permissions associated with an OAuth 2 application in the
  portal's OAuth 2 Admin portlet. Use this property to request a subset
  of those permissions.
\item
  \texttt{callback}: A function called with the authentication's result.
  If authentication succeeds, you receive a non-null session containing
  the authentication; otherwise you receive an error.
\end{itemize}

\noindent\hrulefill

\textbf{Note:} You can call the \texttt{LROAuth2SignIn.signIn} method
without a callback by passing \texttt{nil} as the \texttt{callback}
argument. This causes the request to execute synchronously. If you
provide a callback, the request is executed asynchronously in another
thread and the callback receives the response.

\noindent\hrulefill

Follow these steps to call the \texttt{LROAuth2SignIn.signIn} method for
the Client Credentials grant type:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  If you want to provide a callback, define it in the view controller in
  which you'll call \texttt{LROAuth2SignIn.signIn}. This callback can
  perform any action you need. In this example, if the authentication
  succeeds the callback prints a success message and calls a sample
  method that tests the session's user credentials; otherwise it prints
  an error message:

\begin{verbatim}
let oauth2Callback: (LRSession?, Error?) -> Void = { session, error in
    if let session = session {
        print("Login successful")
        testCredentials(session: session)
    }
    else {
        print(error!)
    }
}
\end{verbatim}
\item
  In the same view controller, call the \texttt{LROAuth2SignIn.signIn}
  method with the above parameters. This example does this in a
  \texttt{loginWithClientCredentials()} method:

\begin{verbatim}
func loginWithClientCredentials() {

    let session = LRSession(server: "http://my-server.com")
    let clientId = "12345"
    let clientSecret = "12345"

    _ = try? LROAuth2SignIn.clientCredentialsSignIn(with: session, clientId: clientId, 
                clientSecret: clientSecret, scopes: [], callback: oauth2Callback)
}
\end{verbatim}
\end{enumerate}

\subsection{Related Topics}\label{related-topics-284}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-oauth-2-in-liferay-screens-for-ios}{Using
OAuth 2 in Liferay Screens for iOS}

\href{/docs/7-1/deploy/-/knowledge_base/d/oauth-2-0}{OAuth 2.0}

\section{Building Mobile SDKs}\label{building-mobile-sdks}

The Liferay Mobile SDK lets you connect your Android and iOS apps to a
Liferay DXP instance. By accessing built-in portal services through
Liferay's prebuilt Mobile SDK, your apps can access the out-of-the-box
functionality in a Liferay DXP instance. But what if you want to call
custom services that belong to a custom portlet? No problem! In this
case, you need to build your own Mobile SDK that can call these custom
portlet services.

Note that when you build a Mobile SDK for a portlet, it contains
\emph{only} the classes needed to call that portlet's remote services.
You still need to install Liferay's prebuilt Mobile SDK in your app. It
contains the framework required to construct remote service calls in
general.

The Liferay Mobile SDK project contains a Mobile SDK Builder that
generates a custom Mobile SDK for the Android and iOS platforms. The
Mobile SDK Builder does this by generating client libraries that let
your native mobile apps invoke a custom portlet's remote web services.
Think of the Mobile SDK Builder as a
\href{/docs/7-1/tutorials/-/knowledge_base/t/service-builder-web-services}{Service
Builder} on the client side.

This tutorial covers how to build a custom Mobile SDK for Android and
iOS. You'll begin by making sure the remote services are configured for
any custom portlets you have.

\subsection{Configuring Your Portlet's Remote
Services}\label{configuring-your-portlets-remote-services}

For the Mobile SDK Builder to discover a portlet's remote services, the
services must be available and accompanied by a Web Service Deployment
Descriptor (WSDD). For instructions on creating a portlet's remote
services and building its WSDD,
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-remote-services}{click
here}.

Next, you'll download the Liferay Mobile SDK's source code.

\subsection{Downloading the Liferay Mobile
SDK}\label{downloading-the-liferay-mobile-sdk}

To build a Mobile SDK for your custom portlet's services, you need to
have the \href{https://github.com/liferay/liferay-mobile-sdk}{Liferay
Mobile SDK's source code} on your local machine. This code also contains
the Mobile SDK Builder. You can get this code by cloning the Mobile SDK
project via Git, or by downloading it from GitHub. To clone the Mobile
SDK project with Git, open a terminal and navigate to the directory on
your machine in which you want to put the Mobile SDK. Then run this
command:

\begin{verbatim}
git clone git@github.com:liferay/liferay-mobile-sdk.git
\end{verbatim}

Since the Mobile SDK changes frequently, you should check out the latest
stable release for your chosen mobile platform (Android or iOS).
\href{https://github.com/liferay/liferay-mobile-sdk/releases}{Click
here} to see the list of available stable releases. Stable releases
correspond to tags in GitHub that begin with the mobile platform and end
with the Liferay Mobile SDK version. For example, the
\texttt{android-7.0.6} tag corresponds to version 7.0.6 of the Liferay
Mobile SDK for Android. To check out this tag in a new branch of the
same name, you can use this command:

\begin{verbatim}
git checkout tags/android-7.0.6 -b android-7.0.6
\end{verbatim}

Alternatively, you can download the ZIP or TAR.GZ file listed under each
tag on GitHub.

Now you're ready to build the Mobile SDK!

\subsection{Building a Liferay Mobile
SDK}\label{building-a-liferay-mobile-sdk}

After you've downloaded the Mobile SDK's source code, you must build the
module in which you'll build your custom portlet's Mobile SDK. The
Mobile SDK Builder comes with a command line wizard that helps you build
this module. To start the wizard, run the following command in the
Mobile SDK source code's root folder:

\begin{verbatim}
./gradlew createModule
\end{verbatim}

This starts the wizard with the most commonly required properties it
needs to generate code for your portlet. If you need more control over
these properties, run the same command with the \texttt{all} argument:

\begin{verbatim}
./gradlew createModule -P=all
\end{verbatim}

The wizard should look similar to this screenshot. Note that default
values are in square brackets with blue text:

\begin{figure}
\centering
\includegraphics{./images/mobile-sdk-create-module.png}
\caption{The Mobile SDK Builder's wizard lets you specify property
values for building your module.}
\end{figure}

So what properties are available, and what do they do? Fantastic
question! You can set the following properties during or after running
\texttt{createModule}. If you want or need to set these properties after
running \texttt{createModule}, you can do so in your module's
\texttt{gradle.properties} file. The values in parentheses are the keys
used in \texttt{gradle.properties}:

\begin{itemize}
\item
  \texttt{Context\ (context)}: Your portlet's web context. For example,
  if you're generating a Mobile SDK for Liferay DXP's Calendar portlet,
  which is generally deployed to the \texttt{calendar} context, then you
  should set the context value to \texttt{calendar}. If there are no
  services available at the specified context, you may have forgotten to
  generate your portlet's WSDD.
\item
  \texttt{Platforms\ (platforms)}: The platforms to build the Mobile SDK
  for. By default, you can generate code for Android and iOS
  (\texttt{android,ios}).
\item
  \texttt{Server\ URL\ (url)}: Your Liferay DXP instance's URL. To
  discover your services, the Mobile SDK Builder tries to connect to
  this instance at the specified context.
\item
  \texttt{Filter\ (filter)}: Specifies the portlet entities the Mobile
  SDK can access. A blank value specifies all portlet entity services.
  For example, the Calendar portlet's entities include
  \texttt{CalendarBooking} and \texttt{CalendarResource}. To generate a
  Mobile SDK for only the \texttt{CalendarBooking} entity, set the
  filter's value to \texttt{calendarbooking} (all lowercase).
\item
  \texttt{Module\ Version\ (version)}: The version number appended to
  your Mobile SDK's JAR (Android) and ZIP files (iOS). The sections on
  packaging your Mobile SDK explain this further.
\item
  \texttt{Package\ Name\ (packageName)}: On Android, this is the package
  your Mobile SDK's classes are written to (iOS doesn't use packages).
  Note that the Liferay DXP version is appended to the end of the
  package name. For example, if you're using Liferay Portal 7.0 or
  Liferay DXP Digital Enterprise 7.0, and specify
  \texttt{com.liferay.mobile.android} as the package name, the Mobile
  SDK Builder appends \texttt{v7} to the package name, yielding
  \texttt{com.liferay.mobile.android.v7}. This prevents collisions
  between classes with the same name, which lets you use Mobile SDKs for
  more than one portal version in the same app. You can use the
  \texttt{Portal\ Version} property to change the portal version.
\item
  \texttt{POM\ Description\ (description)}: Your POM file's description.
\end{itemize}

Note that there's also a \texttt{destination} property that can only be
set in the \texttt{gradle.properties} file. This property specifies the
destination for the generated source files. You won't generally need to
change this.

After you set the properties you need, the Mobile SDK Builder generates
your module in the folder \texttt{modules/\$\{your\_portlet\_context\}}.

Now you can build your Mobile SDK. To do this, navigate to your module
and run this command:

\begin{verbatim}
../../gradlew generate
\end{verbatim}

By default, the builder writes the source files to
\texttt{android/src/gen/java} and \texttt{ios/Source} in your module's
folder.

If you update your portlet's remote services on the server side and need
to update your Mobile SDK, simply run \texttt{../../gradlew\ generate}
again.

Awesome! Now you know how to create and regenerate a Mobile SDK for your
custom portlet's remote services. Next, you'll finish by packaging your
Mobile SDK for the Android and iOS.

\subsubsection{Packaging Your Mobile SDK for
Android}\label{packaging-your-mobile-sdk-for-android}

To package your Mobile SDK in a JAR file for use in an Android project,
run the following command from your module's folder:

\begin{verbatim}
../../gradlew jar
\end{verbatim}

This packages your Mobile SDK in the following file:

\begin{itemize}
\tightlist
\item
  \texttt{modules/\$\{your\_portlet\_context\}/build/libs/liferay-\$\{your\_portlet\_context\}-android-sdk-\$\{version\}.jar}
\end{itemize}

To call your portlet's remote services, you must first install this file
in your Android project. To do so, copy the file into your Android app's
\texttt{app/libs} folder. Note that you must also install Liferay's
prebuilt Mobile SDK in your app.
\href{/docs/7-1/tutorials/-/knowledge_base/t/making-liferay-and-custom-portlet-services-available-in-your-android-app\#adding-the-sdk-to-your-gradle-project}{Click
here} for instructions on doing this.

Also note that if you regenerate your Mobile SDK to include new
functionality, you can update your module's version in its
\texttt{gradle.properties} file. For example, if you added or changed a
service method in the Mobile SDK you initially built, you could update
it's version by setting \texttt{version=1.1} in your module's
\texttt{gradle.properties} file.

To learn how to use the Mobile SDK in your Android app, see the rest of
the
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-android-apps-that-use-the-mobile-sdk}{Android
Mobile SDK documentation}. You can also use your Mobile SDK to create
custom Screenlets in
\href{/docs/7-1/tutorials/-/knowledge_base/t/android-apps-with-liferay-screens}{Liferay
Screens}.

\subsubsection{Packaging Your Mobile SDK for
iOS}\label{packaging-your-mobile-sdk-for-ios}

To package your Mobile SDK in a ZIP file for use in an iOS project, run
the following command from your module's folder:

\begin{verbatim}
../../gradlew zip
\end{verbatim}

This packages your Mobile SDK in the following file:

\begin{itemize}
\tightlist
\item
  \texttt{modules/\$\{your\_portlet\_context\}/build/liferay-\$\{your\_portlet\_context\}-ios-sdk-\$\{version\}.zip}
\end{itemize}

To call your portlet's remote services, you must first install this file
in your Xcode project. To do so, simply unzip it and add its files to
your Xcode project.

To learn how to use the Mobile SDK in your iOS app, see the rest of the
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-ios-apps-that-use-the-mobile-sdk}{iOS
Mobile SDK documentation}. You can also use your Mobile SDK to create
custom Screenlets in
\href{/docs/7-1/tutorials/-/knowledge_base/t/ios-apps-with-liferay-screens}{Liferay
Screens}.

\subsection{Related Topics}\label{related-topics-285}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-android-apps-that-use-the-mobile-sdk}{Creating
Android Apps that Use the Mobile SDK}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-ios-apps-that-use-the-mobile-sdk}{Creating
iOS Apps that Use the Mobile SDK}

\href{/docs/7-1/tutorials/-/knowledge_base/t/android-apps-with-liferay-screens}{Android
Apps with Liferay Screens}

\href{/docs/7-1/tutorials/-/knowledge_base/t/ios-apps-with-liferay-screens}{iOS
Apps with Liferay Screens}

\chapter{Tracking Custom Assets}\label{tracking-custom-assets}

\href{https://help.liferay.com/hc/en-us/categories/360000608871-Liferay-Analytics-Cloud-Admin-Guide}{Liferay
Analytics Cloud} can detect and analyze built-in Liferay DXP assets like
Forms, Blogs, Documents and Media, and Web Content. To analyze assets in
your custom app, however, you must tag your app's HTML so the Analytics
Cloud JavaScript plugin can detect and track user interaction with your
assets.

\section{Asset Events}\label{asset-events}

The Analytics Cloud JavaScript plugin contains the following events that
you can track:

\texttt{AssetClicked}: User clicks the asset area. Also carries
information about the tag clicked.

\texttt{AssetDepthReached}: Scroll event in the asset area. Also carries
information about the content depth the user reached (e.g., how far down
a blog post the user scrolled).

\texttt{AssetViewed}: User views the asset.

\texttt{AssetDownloaded}: User clicks a link that downloads the asset.

\texttt{AssetSubmitted}: Form submission in the asset area. This
requires an input type of \texttt{submit} to be placed under an HTML
\texttt{form} element.

\section{Required Metadata}\label{required-metadata}

You must have the following information to enable tracking for a custom
entity. You must specify this information in HTML via the attributes
listed:

\textbf{Asset Type (String):} The asset type to track. The HTML
attribute for this is \texttt{data-analytics-asset-type}. Note that the
value for this attribute \textbf{is not} your entity's exact type. For
custom entities, this value is always \texttt{custom}.

\textbf{Asset ID (String):} The asset's unique identifier. The HTML
attribute for this is \texttt{data-analytics-asset-id}.

\textbf{Asset Category (String, Optional):} The category of the custom
app that contains the asset. The HTML attribute for this is
\texttt{data-analytics-asset-category}. You can use this to identify the
custom app by name (e.g., ``polls''). Note that within a category, all
asset IDs must be unique.

\textbf{Asset Title (String, Optional):} The asset's title. The HTML
attribute for this is \texttt{data-analytics-asset-title}.

\section{Tracking Asset Events}\label{tracking-asset-events}

For example, if you want to track a poll in a custom Polls app, you
might use HTML like this:

\begin{verbatim}
<div>
<h1> What's your favorite food? </h1>
<form action="/submit.php">
<div>
  <input type="radio" id="sushi" name="food" value="Sushi"
     checked>
  <label for="sushi">Sushi</label>
</div>
<div>
  <input type="radio" id="pizza" name="food" value="Pizza">
  <label for="pizza">Pizza</label>
</div>
<input type="submit" value="Submit" />
</form>
</div>
\end{verbatim}

To track this poll's events, add the above attributes to the
\texttt{div}:

\begin{verbatim}
<div data-analytics-asset-type="custom"
  data-analytics-asset-id="favorite-food-poll"
  data-analytics-asset-category="polls"
  data-analytics-asset-title="What is your favorite food Poll">

<h1> What's your favorite food? </h1>
...
</div>
\end{verbatim}

Note that you must add these attributes to each individual asset that
you want Analytics Cloud to track. However, you can populate the
attributes' values via a script, therefore automating this process for
each asset.

\subsection{Tracking Downloads}\label{tracking-downloads}

To track downloads, you must tag the element that triggers the action
with this attribute:

\begin{verbatim}
data-analytics-asset-action="download"
\end{verbatim}

For example, here's the above poll with a download link for a PDF file
that contains the poll's instructions:

\begin{verbatim}
<div data-analytics-asset-type="custom"
  data-analytics-asset-id="favorite-food-poll"
  data-analytics-asset-category="polls"
  data-analytics-asset-title="What is your favorite food Poll">

<a href="/poll-instructions.pdf" data-analytics-asset-action="download">Download the Poll Instructions </a>

<h1> What's your favorite food? </h1>
...
</div>
\end{verbatim}

\section{Related Topics}\label{related-topics-286}

\href{/docs/7-1/tutorials/-/knowledge_base/t/asset-framework}{Asset
Framework}

\href{https://help.liferay.com/hc/en-us/categories/360000608871-Liferay-Analytics-Cloud-Admin-Guide}{Liferay
Analytics Cloud Admin Guide}

\chapter{Web Experience Management}\label{web-experience-management}

Web Experience Management encompasses Liferay's features and tools for
building Sites and creating content. Many of these, like Web Content
Management and Page Templates, are graphical tools used by
administrators and marketers. Others, like Page Fragments, let web
developers to flex their muscles in content creation. These tutorials
cover where web development intersects with user experience and how to
use Liferay's Web Experience frameworks to integrate custom applications
into Liferay DXP.

Specifically, you'll learn about

\begin{itemize}
\item
  Developing Fragments
\item
  Screen Navigation
\end{itemize}

\chapter{Developing Page Fragments}\label{developing-page-fragments}

The goal of Page Fragments is to take a mock-up design and realize it on
a web page as accurately as possible. To do this, developers are given a
space where they have a ``blank slate.'' You have three tools at your
disposal to accomplish this:

\textbf{HTML}: The markup of the fragment. Fragments use standard HTML
with special tags to add dynamic behavior.

\textbf{CSS}: CSS styles and positions the fragment's markup.

\textbf{JavaScript}: JavaScript provides dynamic behavior to the
fragment.

The HTML, CSS, and JavaScript are all completely standard, just like
anywhere else on the web, but are also enhanced with Liferay-specific
features. You can specify text and images as editable, as well as
providing for ``rich text'': that is, text with additional formatting.
Liferay portlets can also be embedded in Fragments as ``widgets,''
making pages with Fragments more dynamic than regular web content.

\section{Creating a Fragment}\label{creating-a-fragment}

The first example is simple. If you aren't sure about the basics of
Fragments and Collections, you should read
\href{/docs/7-1/user/-/knowledge_base/u/creating-fragments}{Creating
Page Fragments} first so you know what you're getting yourself into.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Go to \emph{Site Administration} and for your selected site click
  \emph{Build} → \emph{Fragments}.
\item
  Create a new Collection named \emph{Developing Fragments}.
\item
  Inside of the new Collection, create a new Fragment named \emph{Basic
  Fragment}.
\end{enumerate}

You're now on the Fragment editing page. There are four panes on this
screen. You enter HTML in the top left pane, CSS in the top right,
JavaScript in the bottom left, and preview the results in the bottom
right.

You can look at the three editing panes as if each were writing to a
separate file. Everything in the HTML pane goes to \texttt{index.html},
the CSS pane goes to \texttt{index.css}, and the JavaScript one goes to
\texttt{index.js}. The preview pane renders everything as it will look
on the page. Here's how this works:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add the following code inside the \texttt{div} in the HTML pane:

\begin{verbatim}
  <h1>
      This text is styled, so it will look pretty!
  </h1>
\end{verbatim}
\item
  Add the following code to the CSS pane inside the fragment block:

\begin{verbatim}
  width: 100%;
  background-color: white;
  text-align: center;
  padding: 2em 0;
  font-size: 28px;
\end{verbatim}
\item
  Add this code below it and replace the \texttt{\#\#\#\#\#} with the
  auto-generated number provided for the fragment

\begin{verbatim}
.fragment_##### h1 {
  font-weight: 100;
  width: calc(100% - 1em);
  max-width: 60ch;
  margin: 0 auto;
  font-size: 28px;
 }
\end{verbatim}
\item
  Click \emph{Publish} to save your work and make it available to add to
  a content page.
\end{enumerate}

As you work, you can observe the preview in the preview pane.

\begin{figure}
\centering
\includegraphics{./images/fragment-editor-basic.png}
\caption{The Fragment editor with HTML and CSS code and a live preview.}
\end{figure}

From here, the Fragment can be used to create a Content Page. To see
this process in action, see the
\href{/docs/7-1/user/-/knowledge_base/u/building-content-pages-from-fragments}{Building
Content Pages from Fragments} tutorial. Next, you'll explore some
Fragment-specific tags.

\section{Fragment Specific Tags}\label{fragment-specific-tags}

While HTML, CSS, and JavaScript are universal tools for building
websites, Liferay DXP includes some additional tools to make fragments
more powerful. One tag can make text editable not just in the HTML
editor, but also at the time of publishing. The other enables you to
embed Liferay portlets into your fragment in the form of ``Widgets.''

\subsection{Making Text Editable}\label{making-text-editable}

Making text editable allows the marketer or web admin to modify the text
before publishing it. This way, you can reuse a single fragment with
different headings or different text for different pages. Fragments make
creating content easy and this feature can save you the work of
duplicating work just to change the text.

You can make any text of a fragment editable by enclosing it in an
\texttt{\textless{}lfr-editable\textgreater{}} tag like this:

\begin{verbatim}
<lfr-editable id="unique-id" type="text">
   This is editable text!    
</lfr-editable>
\end{verbatim}

The \texttt{lfr-editable} tag doesn't render without a unique
\texttt{id}.

The following three \texttt{type} options are available inside of of
\texttt{lfr-editable} tag:

\texttt{text}: Creates a space for plain text that can be edited before
publishing.

\texttt{image}: Must contain a valid
\texttt{\textless{}img\textgreater{}} tag which can then be replaced
with any image before publishing---including those from Documents and
Media.

\texttt{rich-text}: Provides rich text formatting, such as bold,
italics, underline, links, and predefined styles.

\noindent\hrulefill

\textbf{Note:} If you want to make text inside an HTML element editable,
you must use the \texttt{rich-text} type. The \texttt{text} type strips
HTML formatting out of the text before rendering.

\noindent\hrulefill

Now add editable text to a Fragment, add the Fragment to a Content Page,
and then edit the text before publishing:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Go back into the Fragment you were working on before.
\item
  Inside the \texttt{\textless{}h1\textgreater{}} in the HTML pane,
  surround the text with \texttt{\textless{}lfr-editable\textgreater{}}
  tags so that it looks like this.

\begin{verbatim}
<h1>
  <lfr-editable id="heading" type="text">
      This text is styled, so it will look pretty!
  </lfr-editable>
</h1>
\end{verbatim}
\item
  Click \emph{Publish}.
\end{enumerate}

Now your fragment contains editable text. Add it to a Content Page to be
published:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Go to \emph{Navigation} → \emph{Site Pages}.
\item
  Select the \emph{Page Templates} tab at the top.
\item
  Create a new Collection named \emph{Templates for Developing
  Fragments} and a New Page Template inside of it named \emph{Editable
  Page Template}.
\item
  From the menu on the right, add your fragment to the page.
\item
  Click on the text that you defined as editable and change it.
\end{enumerate}

\begin{figure}
\centering
\includegraphics{./images/editing-fragment-text.png}
\caption{You can edit text in the Page Template editor.}
\end{figure}

Similarly, the \texttt{rich-text} type provides the same functionality
with additional features in the editor.

The template saves automatically, and when it is turned into a page, the
new text is displayed.

\subsection{Making Images Editable}\label{making-images-editable}

Like text, you can set images images as editable. An editable image can
be selected from the user's local files or from the Documents and Media
Library. You must be careful with defining styles for editable images
since an image that without the proper dimensions or that is forced into
a poorly sized space can have major negative effects on your layout.

Images use the same \texttt{\textless{}lfr-editable\textgreater{}} tag
as text, but with the \texttt{image} type, like this:

\begin{verbatim}
<lfr-editable id="unique-id" type="image">
   <img src="...">
</lfr-editable>
\end{verbatim}

After you add the \texttt{lfr-editable} tag with the type \texttt{image}
to a Fragment, when you add that Fragment to a page, you can then click
on the editable image and select a replacement.

\subsection{Including Widgets Within A
Fragment}\label{including-widgets-within-a-fragment}

You can add more dynamic behavior to a Fragment by including a widget.
Currently, you can only embed a portlet as a widget, but other types of
widgets will be available in the future.

To include a widget you need to know its registered name. For example,
the Site Navigation Menu portlet is registered as \texttt{nav}. Each
portlet which is registered has an \texttt{lfr-widget-{[}name{]}} tag
that's used to embed it. For example: the Navigation Menu tag is
\texttt{\textless{}lfr-widget-nav\ /\textgreater{}}. You could embed it
in a block like this:

\begin{verbatim}
<div class="nav-widget">
    <lfr-widget-nav>
    </lfr-widget-nav>
</div>
\end{verbatim}

Implement this in your Fragment:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Go to the \emph{Fragments} page.
\item
  Go to the \emph{Developing Fragments} collection and add a new
  Fragment inside of it named \emph{Widget Fragment}.
\item
  Insert the following code in the main
  \texttt{\textless{}div\textgreater{}} in the HTML pane:

\begin{verbatim}
<div class="container-fluid">
  <div class="row">
    <div class="col-md-10">
       <lfr-widget-nav>
       </lfr-widget-nav>
    </div>
  </div>
</div>
\end{verbatim}
\item
  Click \emph{Publish}.
\end{enumerate}

Now you need to add it to a Content Page to display it.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Go to \emph{Navigation} → \emph{Site Pages}.
\item
  Select the \emph{Page Templates} tab at the top.
\item
  Go to the \emph{Templates for Developing Fragments Collection}.
\item
  Create a new Page Template named \emph{Widget Page Template}.
\item
  In the new Page Template, from the menu on the right, add your
  fragment to the page.
\item
  Exit the template editor and it saves automatically.
\item
  Go to the \emph{Pages} tab.
\item
  Click the \texttt{+} icon to create a new page.
\item
  Select the \emph{Widget Page Template} and save.
\item
  Now go back to your site, and select your new page.
\end{enumerate}

For the full list of widgets that can be imbedded, see the
\href{/docs/7-1/reference/-/knowledge_base/r/embedding-widgets-in-page-fragments}{Embedding
Widgets in Page Fragments} reference article.

\subsection{Embedding Your Widget in a
Fragment}\label{embedding-your-widget-in-a-fragment}

If you have a custom widget that you want to embed in a fragment, you
can configure that widget to be embeddable. In order to embed your
widget, it must be an OSGi Component. Inside the \texttt{@Component}
annotation for the portlet class that you want to embed, add this
property:

\begin{verbatim}
"com.liferay.fragment.entry.processor.portlet.alias=app-name"
\end{verbatim}

When you deploy your widget, it's available to add. The name you specify
in the property must be appended to the \texttt{lfr-widget} tag like
this:

\begin{verbatim}
<lfr-widget-app-name>
</lfr-widget-app-name>
\end{verbatim}

\noindent\hrulefill

\textbf{NOTE:} According to the W3C HTML standards, custom elements
cannot be self closing. Therefore, even though you cannot add anything
between the opening and closing
\texttt{\textless{}lfr-widget...\textgreater{}} tags, you cannot use the
self closing notation for the tag.

\noindent\hrulefill

Embedding widgets in Fragments opens a world of options. Now that you've
explored some of the power of Fragments, next you'll learn about best
practices for development.

\section{Recommendations and Best
Practices}\label{recommendations-and-best-practices}

In general all your code should be semantic and highly reusable. A main
concern is making sure that everything is namespaced properly so it
won't interfere with other elements on the page outside of the Fragment.

\subsection{CSS}\label{css}

While you can write any CSS in a fragment, it's recommended to prefix it
with a class specific to the fragment to avoid impacting other
fragments. To facilitate this, when creating a new fragment, the HTML
includes a \texttt{div} with an automatically generated class name and
the CSS shows a sample selector using that class. Use it as the basis
for all selectors you add.

\subsection{JavaScript}\label{javascript}

Avoid adding a lot of JavaScript code, since it isn't easily reusable.
Instead, reference external JS libraries.

\subsection{Developing A Fragment Using Desktop
Tools}\label{developing-a-fragment-using-desktop-tools}

You can develop a fragment using any preferred desktop tools. Since the
Fragment is HTML, CSS, and JavaScript, you could use a text editor or a
specialized tool with its own built in previews.

To import a Collection into Liferay, it must be archived in a
\texttt{.zip} with the contents in the following format:

\begin{itemize}
\item
  \texttt{collection.json}: a text file which describes your collection
  with the format
  \texttt{\{"name":"\textless{}collection-name\textgreater{}","description":"\textless{}collection-description\textgreater{}"\}}

  \begin{itemize}
  \item
    \texttt{{[}fragment-name{]}/}: a folder containing all of the files
    for a single Page Fragment.

    \begin{itemize}
    \item
      \texttt{fragment.json}: a text file that describes a Page Fragment
      with the format
      \texttt{\{"jsPath":"src/index.js","htmlPath":"src/index.html","cssPath":"src/index.css","name":"\textless{}fragment-name\textgreater{}"\}}
    \item
      \texttt{src/}: a folder containing the source code files for the
      fragment.

      \begin{itemize}
      \item
        \texttt{index.html}: the HTML source for the fragment
      \item
        \texttt{index.css}: the CSS source for the fragment
      \item
        \texttt{index.js}: the JavaScript source for the fragment
      \end{itemize}
    \end{itemize}
  \end{itemize}
\end{itemize}

A collection can contain any number of fragments, so you can have lots
of subfolders in the collection. This format is the same as what's
exported from within Liferay.

Developers can also create fragments to be imported into an existing
collection. Put them in a similarly formatted \texttt{.zip}, but without
the Collection information at the top level:

\begin{itemize}
\item
  \texttt{{[}fragment-name{]}/}: a folder containing all the files for a
  single Page Fragment.
\item
  \texttt{fragment.json}: a text file that describes a Page Fragment
  with the format
  \texttt{\{"jsPath":"src/index.js","htmlPath":"src/index.html","cssPath":"src/index.css","name":"\textless{}fragment-name\textgreater{}"\}}
\item
  \texttt{src/}: a folder containing the source code files for the
  fragment.

  \begin{itemize}
  \item
    \texttt{index.html}: the HTML source for the fragment
  \item
    \texttt{index.css}: the CSS source for the fragment
  \item
    \texttt{index.js}: the JavaScript source for the fragment
  \end{itemize}
\end{itemize}

Multiple fragments can be included in a single \texttt{.zip} file with
each having its own folder at the top level.

\chapter{Screen Navigation Framework}\label{screen-navigation-framework}

The Screen Navigation Framework is for customizing and extending
application UIs. You can use it to make Liferay's applications your own
and to make your applications customizable by others.

To make this work, the framework assumes a specific structure for
screens and supports one or two levels of navigation. Each item in the
top level navigation is a \texttt{ScreenNavigationCategory}. Each item
in the second level is a \texttt{ScreenNavigationEntry}. Categories are
usually represented by tabs, while entries use a second level of
navigation. You need not have any Entries in your application, but you
must have at least one Category.

\begin{figure}
\centering
\includegraphics{./images/screen-nav-sample-screen-1.png}
\caption{A typical application using screen navigation has three
categories and numerous entries.}
\end{figure}

The Screen structure normally renders Navigation Categories as
horizontal tabs at the top of the page and Navigation Entries as a
vertical list of items along the left side of the page. The screen box
containing the content uses the rest of the screen. You can customize
this default layout for your needs.

Secondary navigation is optional; you may only need category tabs with
no additional navigation.

\begin{figure}
\centering
\includegraphics{./images/screen-nav-one-level.png}
\caption{Secondary navigation is optional; you may opt to have only
tabs.}
\end{figure}

\section{Using the Framework for Your
Application}\label{using-the-framework-for-your-application}

The Screen Navigation Framework comprises two parts: Java classes for
your screens and a tag library for your front-end. First you'll create
the necessary Java classes and then add the front-end support through
JSPs.

\subsection{Adding Screens to Your Application's
Back-end}\label{adding-screens-to-your-applications-back-end}

You must create at least one Navigation Category. To add screens to your
application, first you must add at least one Navigation Category for the
top level navigation. Then you can add additional Navigation Entries for
each page that you need.

First, add a Navigation Category

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a component that implements the
  \texttt{ScreenNavigationCategory} interface.
\item
  Implement the following methods in your component:

  \textbf{\texttt{getCategoryKey()}}: returns the category's primary
  key.

  \textbf{\texttt{getLabel(Locale\ locale)}}: returns the label of the
  key.

  \textbf{\texttt{getScreenNavigationKey()}}: returns the navigation key
  that the category belongs in, as defined in your application.
\end{enumerate}

Next, add a Navigation Entry.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a component which implements \texttt{ScreenNavigationEntry}.
\item
  Implement the following methods in your component:

  \textbf{\texttt{getCategoryKey()}}: returns the category's primary
  key.

  \textbf{\texttt{getEntryKey()}}: returns the entry's primary key.

  \textbf{\texttt{getLabel()}}: returns the entries label.

  \textbf{\texttt{getScreenNavigationKey()}}: returns the navigation key
  for the category of the current entry.

  \textbf{\texttt{isVisible(User\ user,\ T\ screenModelBean)}}: boolean
  for whether or not the entry should be visible for the current user.

  \textbf{\texttt{render(HttpServletRequest\ request,\ HttpServletResponse\ response)}}:
  renders the entry.
\end{enumerate}

You can implement your render method any way that you want as long as it
provides a way to render HTML. Liferay developers typically use JSPs,
shown below.

\subsection{Adding Screens to Your Application's
Front-end}\label{adding-screens-to-your-applications-front-end}

To use JSPs to render your screens, you must invoke the
\texttt{JSPRenderer} component in your \texttt{render} method and create
the JSP that renders the HTML.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a \texttt{render} method which uses \texttt{JSPRenderer} like
  this:

\begin{verbatim}
@Override
public void render(HttpServletRequest request, HttpServletResponse response)
throws IOException {

    _jspRenderer.renderJSP(request, response, "/my-category/view-category.jsp");
}
\end{verbatim}
\item
  Add the following code at the bottom of your class to use the
  reference annotation to access the \texttt{JSPRenderer}:

\begin{verbatim}
@Reference
private JSPRenderer _jspRenderer;
\end{verbatim}
\item
  Create a JSP that includes the
  \texttt{liferay-frontend:screen-navigation} taglib and the necessary
  parameters like this:

\begin{verbatim}
<liferay-frontend:screen-navigation key=
"<%= AssetCategoriesConstants.CATEGORY_KEY_GENERAL %>"
modelBean="<%= category %>"
portletURL="<%= portletURL %>"
/>
\end{verbatim}
\end{enumerate}

The parameters it needs are \texttt{key}, \texttt{modelBean}, and
\texttt{portletURL}.

\begin{itemize}
\item
  \textbf{Key}: a unique name for the navigation in this application.
\item
  \textbf{modelBean}: the model that is being rendered
\item
  \textbf{portletURL}: the portlet URL used to build the titles for each
  link.
\end{itemize}

In the next section, you'll see how to extend an existing Liferay class
with more screens.

\section{Adding Custom Screens to Liferay
Applications}\label{adding-custom-screens-to-liferay-applications}

You can extend certain Liferay Applications with custom screens. Custom
screens can add configuration for features you've developed, integrating
them seamlessly with the original application.

\subsection{Categories Administration}\label{categories-administration}

The Categories Administration application supports adding Custom Screens
to provide additional options for editing a category. To demonstrate
adding a new Screen Navigation Entry and Category, you'll add one to
Categories Administration.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a new Java class in the \texttt{asset-categories-admin-web}
  module named \texttt{CategoryCustomScreenNavigationEntry} that
  implements \texttt{ScreenNavigationCategory} and
  \texttt{ScreenNavigationEntry}.
\item
  Add the following Component annotation above the class declaration:

\begin{verbatim}
 @Component(
     property = {
       "screen.navigation.category.order:Integer=1",
       "screen.navigation.entry.order:Integer=1"
     },
     service = {ScreenNavigationCategory.class, ScreenNavigationEntry.class}
 )
\end{verbatim}

  The \texttt{screen.navigation.category.order} and
  \texttt{screen.navigation.entry.order} determine where in the
  navigation the items appear. Higher is first in the navigation.

  In the \texttt{service} declaration, declare it as defining a
  \texttt{ScreenNavigationCategory}, \texttt{ScreenNavigationEntry}, or
  both.
\item
  For the class body, insert this code:

\begin{verbatim}
@Override
public String getCategoryKey() {
    return "custom-screen";
}

@Override
public String getEntryKey() {
    return "custom-screen";
}

@Override
public String getLabel(Locale locale) {
    return LanguageUtil.get(locale, "custom-screen");
}

@Override
public String getScreenNavigationKey() {
    return AssetCategoriesConstants.CATEGORY_KEY_GENERAL;
}

@Override
public void render(HttpServletRequest request, HttpServletResponse response)
    throws IOException {

   _jspRenderer.renderJSP(request, response, "/category/custom-screen.jsp");
}

@Reference
private JSPRenderer _jspRenderer;
\end{verbatim}
\item
  Create a \texttt{custom-screen.jsp} in the
  \texttt{/resources/META-INF/resources/category/} folder.
\item
  At the top of your JSP class, insert the following scriplet at the top
  to use the Screen Navigation UI:

\begin{verbatim}
<%
String redirect = ParamUtil.getString(request, "redirect", assetCategoriesDisplayContext.getEditCategoryRedirect());

long categoryId = ParamUtil.getLong(request, "categoryId");

AssetCategory category = AssetCategoryLocalServiceUtil.fetchCategory(categoryId);

long parentCategoryId = BeanParamUtil.getLong(category, request, "parentCategoryId");

long vocabularyId = ParamUtil.getLong(request, "vocabularyId");

portletDisplay.setShowBackIcon(true);
portletDisplay.setURLBack(redirect);

renderResponse.setTitle(((category == null) ? LanguageUtil.get(request, "add-new-category") : category.getTitle(locale)));
%>
\end{verbatim}
\item
  Below that insert the following tag:

\begin{verbatim}
<liferay-frontend:screen-navigation key=
"<%= AssetCategoriesConstants.CATEGORY_KEY_GENERAL %>"
modelBean="<%= category %>"
portletURL="<%= portletURL %>"
/>
\end{verbatim}
\item
  For the rest of the JSP, create your custom screen.
\end{enumerate}

Now you can use that pattern to create additional screens for whatever
you need.

\chapter{Product Navigation}\label{product-navigation}

Liferay's product navigation consists of the main menus you use to
customize, configure, and navigate the system. When you edit a page,
switch to a different Site scope, access a User's credentials, etc.,
you're using the default navigation menus. Providing a customization to
a default menu can help give your Liferay instance a unique touch. You
can extend and customize the default product navigation to fit your
need.

There are four product navigation sections that you can extend: Product
Menu, Control Menu, Simulation Menu, and User Personal Menu.

\begin{figure}
\centering
\includegraphics{./images/product-navigation-summary.png}
\caption{The main product navigation menus include the Product Menu,
Control Menu, and Simulation Menu.}
\end{figure}

The Product Menu is on the left, and displays the Control Panel, User
account settings, and Site Administration functionality. The Control
Menu is on top, offering navigation to the Product Menu, Simulation Menu
(the right menu), and the \emph{Add} button. When certain settings are
enabled (e.g., Staging, Page Customization, etc.), more tools are
offered. The Simulation Menu offers options to simulate your Site's look
for different scenarios (devices, user segments, etc.). Finally, the
User Personal Menu holds selectable items containing a user's own
account settings.

In this section of tutorials, you'll learn about the various ways you
can extend and customize Liferay's product navigation to fit your needs.

\chapter{Customizing the Product
Menu}\label{customizing-the-product-menu}

By default, Liferay's Product Menu consists of three main sections:
Control Panel, User Menu, and Site Administration. These sections are
called panel categories. For instance, the Control Panel is a single
panel category, and when clicking on it, you see four child panel
categories: \emph{Users}, \emph{Sites}, \emph{Apps}, and
\emph{Configuration}. Clicking a child panel category shows panel apps.

\noindent\hrulefill

\textbf{Note:} The Product Menu cannot be changed by applying a new
theme. To change the layout/style of the Product Menu, you must create
and deploy a theme contributor. See the
\href{/docs/7-1/tutorials/-/knowledge_base/t/packaging-independent-ui-resources-for-your-site}{Theme
Contributors} tutorial for more details.

\noindent\hrulefill

The Product Menu is intuitive and easy to use---but you can still change
it any way you want. You can reorganize the panel categories and apps,
or add completely new categories and populate them with custom panel
apps. Here you'll learn how to provide new or modified panel categories
and panel apps for the Product Menu.

\section{Adding Custom Panel
Categories}\label{adding-custom-panel-categories}

As you navigate the Product Menu, you can see that Panel Apps like
\emph{Web Content} and \emph{Site Settings} are organized into Panel
Categories such as \emph{Content} and \emph{Configuration}. This
tutorial explains how to add new Panel Categories to the menu. Adding
new Panel Apps is covered in the next section.

There are three steps to creating a new category:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create the OSGi structure and metadata.
\item
  Implement Liferay's Frameworks.
\item
  Define the Control Menu Category.
\end{enumerate}

\subsection{Creating the OSGi Module}\label{creating-the-osgi-module}

First you must create the project.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create an OSGi module using your favorite third party tool, or use
  \href{/docs/7-1/tutorials/-/knowledge_base/t/blade-cli}{Blade CLI}.
  Blade CLI offers a
  \href{/docs/7-1/reference/-/knowledge_base/r/panel-app-template}{Panel
  App} template, which is for creating a panel category and panel app.
\item
  Create a unique package name in the module's \texttt{src} directory
  and create a new Java class in that package. To follow naming
  conventions, give your class a unique name followed by
  \texttt{PanelCategory} (e.g., \texttt{ControlPanelCategory}).
\end{enumerate}

\subsection{Implementing Liferay's
Frameworks}\label{implementing-liferays-frameworks}

Next, you must connect your OSGi module to Liferay's frameworks and use
those to define information about your entry. This takes only two steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Insert the \texttt{@Component} annotation declaring the panel category
  keys.
\item
  Implement the \texttt{PanelCategory} interface.
\end{enumerate}

Both of these steps are described below.

\subsubsection{Insert the @Component
Annotation}\label{insert-the-component-annotation}

Directly above the class's declaration, insert the following annotation:

\begin{verbatim}
    @Component(
        immediate = true,
        property = {
            "panel.category.key=" + [Panel Category Key],
            "panel.category.order:Integer=[int]"
        },
        service = PanelCategory.class
    )
\end{verbatim}

The \texttt{property} element designates two properties that should be
assigned for your category. The \texttt{panel.category.key} specifies
the parent category for your custom category. You can find popular
parent categories to assign in the
\href{https://docs.liferay.com/dxp/apps/web-experience/latest/javadocs/com/liferay/application/list/constants/PanelCategoryKeys.html}{\texttt{PanelCategoryKeys}}
class. For instance, if you wanted to create a child category in the
Control Panel, you could assign
\texttt{PanelCategoryKeys.CONTROL\_PANEL}. Likewise, if you wanted to
create a root category, like the Control Panel or Site Administration,
you could assign \texttt{PanelCategoryKeys.ROOT}.

The \texttt{panel.category.order:Integer} property specifies the order
in which your category is displayed. The higher the number (integer),
the lower your category is listed among other sibling categories
assigned to a parent.

Finally, your \texttt{service} element should specify the
\texttt{PanelCategory.class} service. You can view an example of a
similar \texttt{@Component} annotation for the
\texttt{UserPanelCategory} class below.

\begin{verbatim}
    @Component(
        immediate = true,
        property = {
            "panel.category.key=" + PanelCategoryKeys.ROOT,
            "panel.category.order:Integer=200"
        },
        service = PanelCategory.class
    )
\end{verbatim}

\noindent\hrulefill

\textbf{Note:} To insert a panel category between existing categories in
the default menu, you must know the
\texttt{panel.category.order:Integer} property for the existing
categories. Default categories with a given panel.category.key are
numbered in increments of 100, starting with 100.

For example, the Product Menu's three main sections---Control Panel,
User Menu, and Site Administration---have
\texttt{panel.category.order:Integer} properties of 100, 200, and 300,
respectively. A new panel inserted between Control Panel and User Menu
would need a \texttt{panel.category.key} of ROOT and a
\texttt{panel.category.order:Integer} of 150.

\noindent\hrulefill

\subsubsection{Implement the PanelCategory
Interface}\label{implement-the-panelcategory-interface}

The \texttt{PanelCategory} interface requires you to implement the
following methods:

\begin{itemize}
\tightlist
\item
  \texttt{getNotificationCount}: returns the number of notifications to
  be shown in the panel category.
\item
  \texttt{include}: renders the body of the panel category.
\item
  \texttt{includeHeader}: renders the panel category header.
\item
  \texttt{isActive}: whether the panel is selected.
\item
  \texttt{isPersistState}: whether to persist the panel category's state
  to the database. This saves the state of the panel category when
  navigating away from the menu.
\end{itemize}

You can reduce the number of methods you must implement if you extend a
base class that already implements the \texttt{PanelCategory} interface.
The recommended way to do this is by extending the
\href{https://docs.liferay.com/dxp/apps/web-experience/latest/javadocs/com/liferay/application/list/BasePanelCategory.html}{\texttt{BasePanelCategory}}
or
\href{https://docs.liferay.com/dxp/apps/web-experience/latest/javadocs/com/liferay/application/list/BaseJSPPanelCategory.html}{\texttt{BaseJSPPanelCategory}}
abstract classes. Typically, the \texttt{BasePanelCategory} is extended
for basic categories (e.g., the Control Panel category) that only
display the category name. To add more complex functionality, you can
then provide a custom UI for your panel using any front-end technology
by implementing the \texttt{include()} or \texttt{includeHeader()} from
the \texttt{PanelCategory} interface.

If you plan to use JSPs as the front-end technology, extend a base class
called \texttt{BaseJSPPanelCategory} that already implements the methods
\texttt{include()} and \texttt{includeHeader()} for you. This is covered
in more detail below.

\noindent\hrulefill

\textbf{Note:} In this tutorial, example JSPs describe how to provide
functionality to panel categories and apps. JSPs, however, are not the
only way to provide front-end functionality to your categories/apps. You
can create your own class implementing \texttt{PanelCategory} to use
other technologies such as FreeMarker.

\noindent\hrulefill

\subsection{Defining the Control Menu
Category}\label{defining-the-control-menu-category}

After establishing the framework you're using to create the category,
you must add any other methods that are necessary to create your custom
panel category. As you learned earlier, you can extend the
\texttt{BasePanelCategory} and \texttt{BaseJSPPanelCategory} abstract
classes to implement \texttt{PanelCategory}.

\subsubsection{BasePanelCategory}\label{basepanelcategory}

If you need something simple for your panel category like a name,
extending \texttt{BasePanelCategory} is probably sufficient. For
example, the
\href{https://github.com/liferay/liferay-portal/blob/7.0.3-ga4/modules/apps/web-experience/product-navigation/product-navigation-control-panel/src/main/java/com/liferay/product/navigation/control/panel/internal/application/list/ControlPanelCategory.java}{\texttt{ControlPanelCategory}}
extends \texttt{BasePanelCategory} and specifies a \texttt{getLabel}
method to set and display the panel category name.

\begin{verbatim}
    @Override
    public String getLabel(Locale locale) {
        return LanguageUtil.get(locale, "control-panel");
    }
\end{verbatim}

\subsubsection{BaseJSPPanelCategory}\label{basejsppanelcategory}

If you need more complex functionality, extend
\texttt{BaseJSPPanelCategory} and use JSPs to render the panel category.
For example, the
\href{https://github.com/liferay/liferay-portal/blob/7.0.3-ga4/modules/apps/web-experience/product-navigation/product-navigation-site-administration/src/main/java/com/liferay/product/navigation/site/administration/internal/application/list/SiteAdministrationPanelCategory.java}{\texttt{SiteAdministrationPanelCategory}}
specifies the \texttt{getHeaderJspPath} and \texttt{getJspPath} methods.
You could create a JSP with the UI you want to render and specify its
path in methods like these:

\begin{verbatim}
    @Override
    public String getHeaderJspPath() {
        return "/sites/site_administration_header.jsp";
    }

    @Override
    public String getJspPath() {
        return "/sites/site_administration_body.jsp";
    }
\end{verbatim}

One JSP renders the panel category's header (displayed when panel is
collapsed) and the other its body (displayed when panel is expanded).

You must also specify the servlet context from where you are loading the
JSP files. If this is inside an OSGi module, make sure your
\texttt{bnd.bnd} file has defined a web context path:

\begin{verbatim}
    Bundle-SymbolicName: com.sample.my.module.web
    Web-ContextPath: /my-module-web
\end{verbatim}

Then reference the Servlet context using the symbolic name of your
module like this:

\begin{verbatim}
    @Override
    @Reference(
        target = "(osgi.web.symbolicname=com.sample.my.module.web)",
        unbind = "-"
    )
    public void setServletContext(ServletContext servletContext) {
        super.setServletContext(servletContext);
    }
\end{verbatim}

Excellent! You've successfully created a custom panel category to
display in the Product Menu. In many cases, a panel category holds panel
apps for users to access. You'll learn about how to add a panel app to a
panel category next.

\section{Adding Custom Panel Apps}\label{adding-custom-panel-apps}

After you have created a Category, create a Panel app to go in it:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create an OSGi module using your favorite third party tool, or use
  \href{/docs/7-0/tutorials/-/knowledge_base/t/blade-cli}{Blade CLI}.
  Blade CLI offers a
  \href{/docs/7-0/reference/-/knowledge_base/r/panel-app-template}{Panel
  App} template to help generate a basic panel category and panel app.
\item
  Create a unique package name in the module's \texttt{src} directory,
  and create a new Java class in that package. To follow naming
  conventions, give your class a unique name followed by \emph{PanelApp}
  (e.g., \texttt{JournalPanelApp}).
\item
  Directly above the class's declaration, insert the following
  annotation:

\begin{verbatim}
@Component(
    immediate = true,
    property = {
        "panel.app.order:Integer=INTEGER"
        "panel.category.key=" + PANEL_CATEGORY_KEY,
    },
    service = PanelApp.class
)
\end{verbatim}

  These properties and attributes are similar to those discussed in the
  previous
  \href{/docs/7-1/tutorials/-/knowledge_base/t/adding-custom-panel-categories}{tutorial}.
  The \texttt{panel.category.key} assigns your panel app to a panel
  category. The \texttt{panel.app.order:Integer} property specifies the
  order your panel app appears among other panel apps in the same
  category. For example, if you want to add a panel app to Site
  Administration → \emph{Content}, add the following property:

\begin{verbatim}
"panel.category.key=" + PanelCategoryKeys.SITE_ADMINISTRATION_CONTENT
\end{verbatim}

  Visit the
  \href{https://docs.liferay.com/dxp/apps/web-experience/latest/javadocs/com/liferay/application/list/constants/PanelCategoryKeys.html}{PanelCategoryKeys}
  class for keys you can use to specify default panel categories in
  Liferay.

  Set the \texttt{service} attribute to \texttt{PanelApp.class}. You can
  view an example of a similar \texttt{@Component} annotation for the
  \texttt{JournalPanelApp} class below.

\begin{verbatim}
@Component(
    immediate = true,
    property = {
        "panel.app.order:Integer=100",
        "panel.category.key=" + PanelCategoryKeys.SITE_ADMINISTRATION_CONTENT
    },
    service = PanelApp.class
)
\end{verbatim}
\item
  Implement the \texttt{PanelApp} interface by extending the
  \href{https://docs.liferay.com/dxp/apps/web-experience/latest/javadocs/com/liferay/application/list/BasePanelApp.html}{BasePanelApp}
  abstract class. As you learned in the previous
  \href{/docs/7-1/tutorials/-/knowledge_base/t/adding-custom-panel-categories}{tutorial}
  on panel categories, if you must create a more complex UI to render in
  the panel, you can.

  If you want to use JSPs to render that UI, extend
  \href{https://docs.liferay.com/dxp/apps/web-experience/latest/javadocs/com/liferay/application/list/BaseJSPPanelApp.html}{BaseJSPPanelApp}.
  This provides additional methods you can use to incorporate JSP
  functionality into your app's listing in the Product Menu.

  JSPs are not the only way to provide front-end functionality to your
  panel apps. You can create your own class implementing
  \texttt{PanelCategory} to use other technologies such as FreeMarker.
\item
  If you are implementing the
  \href{https://docs.liferay.com/dxp/apps/web-experience/latest/javadocs/com/liferay/application/list/PanelApp.html}{PanelApp}
  interface without extending a base class, you must implement its
  methods. The \texttt{BlogsPanelApp} is a simple example of how to
  specify your portlet as a panel app. This class extends
  \texttt{BasePanelApp}, overriding the \texttt{getPortletId} and
  \texttt{setPortlet} methods. These methods specify and set the Blogs
  portlet as a panel app.

  Each panel app must belong to a portlet and each portlet can have at
  most one panel app. If more than one panel app is needed, another
  portlet must be created. By default, the panel app only appears if the
  user has permission to view the associated portlet.

  This is how those methods look for the Blogs portlet:

\begin{verbatim}
@Override
public String getPortletId() {
    return BlogsPortletKeys.BLOGS_ADMIN;
}

@Override
@Reference(
    target = "(javax.portlet.name=" + BlogsPortletKeys.BLOGS_ADMIN + ")",
    unbind = "-"
)
public void setPortlet(Portlet portlet) {
    super.setPortlet(portlet);
}
\end{verbatim}

  You can also customize your panel app's appearance in the Product
  Menu. As you learned before, the \texttt{BaseJSPPanelApp} abstract
  class can be extended to provide further functionality with JSPs.
\end{enumerate}

Now you know how to add or modify a panel app in the Product Menu. Not
only does Liferay provide a simple solution to add new panel categories
and apps, it also gives you the flexibility to add a more complex UI to
the Product Menu using any technology.

\chapter{Customizing the Control
Menu}\label{customizing-the-control-menu}

The Control Menu is the most visible and accessible menu in Liferay. For
example, on your home page, the Control Menu offers default options for
accessing the Product Menu, Simulation Menu, and Add Menu. You can think
of this menu as the gateway to configuring options in Liferay.

\begin{figure}
\centering
\includegraphics{./images/control-menu-home.png}
\caption{The Control Menu has three configurable areas: left, right, and
middle. It also displays the title and type of page that you are
currently viewing.}
\end{figure}

If you navigate away from the home page, the Control Menu adapts and
provides helpful functionality for whatever option you're using. For
example, if you navigate to Site Administration → \emph{Content} →
\emph{Web Content}, you see a Control Menu with different functionality
tailored for that option.

\begin{figure}
\centering
\includegraphics{./images/control-menu-web-content.png}
\caption{When switching your context to web content, the Control Menu
adapts to provide helpful options for that area.}
\end{figure}

The default Control Menu contains three categories representing the
left, middle, and right portions of the menu. You can create navigation
entries for each category.

\noindent\hrulefill

\textbf{Note:} You can add the Control Menu to a theme by adding the
following snippet into your \texttt{portal\_normal.ftl}:

\begin{verbatim}
 <@liferay.control_menu />
\end{verbatim}

The other product navigation menus (e.g., Product Menu, Simulation Menu)
are included in this tag, so specifying the above snippet embeds all
three menus into your theme. Embedding the User Personal Bar is slightly
different. Visit the
\href{/docs/7-1/tutorials/-/knowledge_base/t/providing-the-user-personal-bar}{Providing
the User Personal Bar} tutorial for more information.

\noindent\hrulefill

You can reference a sample Control Menu Entry by visiting the
\href{/docs/7-1/reference/-/knowledge_base/r/control-menu-entry-template}{Control
Menu Entry} article.

Next you'll learn how to customize the Control Menu.

\section{Creating Control Menu
Entries}\label{creating-control-menu-entries}

Now you'll create entries to customize the Control Menu. Make sure to
read
\href{/docs/7-1/tutorials/-/knowledge_base/t/adding-custom-panel-categories}{Adding
Custom Panel Categories} before beginning this tutorial. This tutorial
assumes you know how to create a panel category. Creating a Control Menu
Entry follows the same pattern as creating a category:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create the OSGi structure and metadata.
\item
  Implement Liferay's Frameworks.
\item
  Define the Control Menu Entry.
\end{enumerate}

\subsection{Creating the OSGi Module}\label{creating-the-osgi-module-1}

First you must create the project.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a generic OSGi module. Your module must contain a Java class,
  \texttt{bnd.bnd} file, and build file (e.g., \texttt{build.gradle} or
  \texttt{pom.xml}). You'll create your Java class next if your project
  does not already define one.
\item
  Create a unique package name in the module's \texttt{src} directory
  and create a new Java class in that package. Give your class a unique
  name followed by \emph{ProductNavigationControlMenuEntry}
  (e.g.,\texttt{StagingProductNavigationControlMenuEntry}).
\end{enumerate}

\subsection{Implementing Liferay's
Frameworks}\label{implementing-liferays-frameworks-1}

Next, you need to connect your OSGi module to Liferay's frameworks and
use those to define information about your entry.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Directly above the class's declaration, insert this code:

\begin{verbatim}
@Component(
    immediate = true,
    property = {
        "product.navigation.control.menu.category.key=" + [Control Menu Category],
        "product.navigation.control.menu.category.order:Integer=[int]"
    },
    service = ProductNavigationControlMenuEntry.class
)
\end{verbatim}

  The \texttt{product.navigation.control.menu.category.key} property
  specifies your entry's category. The default Control Menu provides
  three categories: Sites (left portion), Tools (middle portion), and
  User (right portion).

  \begin{figure}
  \centering
  \includegraphics{./images/control-menu-areas.png}
  \caption{This image shows where your entry will reside depending on
  the category you select.}
  \end{figure}

  To specify the category, reference the appropriate key in the
  \href{https://docs.liferay.com/dxp/apps/web-experience/latest/javadocs/com/liferay/product/navigation/control/menu/constants/ProductNavigationControlMenuCategoryKeys.html}{ProductNavigationControlMenuCategoryKeys}
  class. For example, this property places your entry in the middle
  portion of the Control Menu:

\begin{verbatim}
"product.navigation.control.menu.category.key=" + ProductNavigationControlMenuCategoryKeys.TOOLS
\end{verbatim}

  Like panel categories, you must specify an integer to place your entry
  in the category. Entries are ordered from left to right: an entry with
  order \texttt{1} appears to the left of an entry with order
  \texttt{2}. If the order is not specified, it's chosen at random based
  on which service was registered first in the OSGi container. Finally,
  your \texttt{service} element should specify the
  \texttt{ProductNavigationControlMenuEntry.class} service.
\item
  Implement the
  \href{https://docs.liferay.com/dxp/apps/web-experience/latest/javadocs/com/liferay/product/navigation/control/menu/ProductNavigationControlMenuEntry.html}{\texttt{ProductNavigationControlMenuEntry}}
  interface. You can also extend the
  \href{https://docs.liferay.com/dxp/apps/web-experience/latest/javadocs/com/liferay/product/navigation/control/menu/BaseProductNavigationControlMenuEntry.html}{\texttt{BaseProductNavigationControlMenuEntry}}
  or
  \href{https://docs.liferay.com/dxp/apps/web-experience/latest/javadocs/com/liferay/product/navigation/control/menu/BaseJSPProductNavigationControlMenuEntry.html}{\texttt{BaseJSPProductNavigationControlMenuEntry}}
  abstract classes. Typically, the
  \texttt{BaseProductNavigationControlMenuEntry} is extended for basic
  entries (e.g., \texttt{IndexingProductNavigationControlMenuEntry})
  that only display a link with text or a simple icon. If you want to
  provide a more complex UI with buttons or a sub-menu, you can override
  the \texttt{include()} and \texttt{includeBody()} methods. If you use
  JSPs for generating the UI, you can extend
  \texttt{BaseJSPProductNavigationControlMenuEntry} to save time. This
  is covered in more detail below.
\end{enumerate}

\subsection{Defining the Control Menu
Entry}\label{defining-the-control-menu-entry}

Now you must define your Control Menu Entry. Here are some examples for
defining your entry.

\subsubsection{Control Menu Examples}\label{control-menu-examples}

The
\href{https://github.com/liferay/liferay-portal/blob/7.0.3-ga4/modules/apps/foundation/portal-search/portal-search-web/src/main/java/com/liferay/portal/search/web/internal/product/navigation/control/menu/IndexingProductNavigationControlMenuEntry.java}{\texttt{IndexingProductNavigationControlMenuEntry}}
is a simple example for providing text and an icon. It extends the
\texttt{BaseProductNavigationControlMenuEntry} class and is used when
Liferay is indexing. The indexing entry is displayed in the \emph{Tools}
(middle) area of the Control Menu with a \emph{Refresh} icon and text
stating \emph{The Portal is currently indexing}.

The
\href{https://github.com/liferay/liferay-portal/blob/7.0.3-ga4/modules/apps/web-experience/product-navigation/product-navigation-product-menu-web/src/main/java/com/liferay/product/navigation/product/menu/web/internal/product/navigation/control/menu/ProductMenuProductNavigationControlMenuEntry.java}{\texttt{ProductMenuProductNavigationControlMenuEntry}}
is more sophisticated. This entry appears in the \emph{Sites} (left)
area of the Control Menu, but unlike the previous example, it extends
the \texttt{BaseJSPProductNavigationControlMenuEntry} class. This
provides several more methods that use JSPs to define your entry's UI.
There are two methods to notice:

\begin{verbatim}
    @Override
    public String getBodyJspPath() {
        return "/portlet/control_menu/product_menu_control_menu_entry_body.jsp";
    }

    @Override
    public String getIconJspPath() {
        return "/portlet/control_menu/product_menu_control_menu_entry_icon.jsp";
    }
\end{verbatim}

The \texttt{getIconJspPath()} method provides the Product Menu icon
(\includegraphics{./images/icon-menu.png} →
\includegraphics{./images/icon-menu-open.png}), and the
\texttt{getBodyJspPath()} method adds the UI body for the entry outside
of the Control Menu. The latter method must be used when providing a UI
outside the Control Menu. You can test this by opening and closing the
Product Menu on the home page.

Finally, if you provide functionality that is exclusively inside the
Control Menu, the \texttt{StagingProductNavigationControlMenuEntry}
class calls its JSP like this:

\begin{verbatim}
    @Override
    public String getIconJspPath() {
        return "/control_menu/entry.jsp";
    }
\end{verbatim}

The \texttt{entry.jsp} is returned, which embeds the Staging Bar portlet
into the Control Menu.

You must also specify the servlet context for the JSP files. If this is
inside an OSGi module, make sure your \texttt{bnd.bnd} file defines a
web context path:

\begin{verbatim}
    Bundle-SymbolicName: com.sample.my.module.web
    Web-ContextPath: /my-module-web
\end{verbatim}

And then reference the Servlet context using the symbolic name of your
module:

\begin{verbatim}
    @Override
    @Reference(
        target = "(osgi.web.symbolicname=com.sample.my.module.web)",
        unbind = "-"
    )
    public void setServletContext(ServletContext servletContext) {
        super.setServletContext(servletContext);
    }
\end{verbatim}

\subsubsection{Displaying Your Control Menu
Entry}\label{displaying-your-control-menu-entry}

Part of creating the entry is defining when it appears. The Control Menu
shows different entries depending on the displayed page. You can specify
when your entry appears with the \texttt{isShow(HttpServletRequest)}
method.

For example, the \texttt{IndexingProductNavigationControlMenuEntry}
class queries the number of indexing jobs when calling \texttt{isShow}.
If the query count is \texttt{0}, the indexing entry doesn't appear in
the Control Menu:

\begin{verbatim}
    @Override
    public boolean isShow(HttpServletRequest request) throws PortalException {
        int count = _indexWriterHelper.getReindexTaskCount(
            CompanyConstants.SYSTEM, false);

        if (count == 0) {
            return false;
        }

        return super.isShow(request);
    }
\end{verbatim}

The \texttt{StagingProductNavigationControlMenuEntry} class selects the
pages to appear. The staging entry never appears if the page is an
administration page (e.g., \emph{Site Administration}, \emph{My
Account}, etc.):

\begin{verbatim}
    @Override
    public boolean isShow(HttpServletRequest request) throws PortalException {
        ThemeDisplay themeDisplay = (ThemeDisplay)request.getAttribute(
            WebKeys.THEME_DISPLAY);

        Layout layout = themeDisplay.getLayout();

        // This controls if the page is an Administration Page

        if (layout.isTypeControlPanel()) {
            return false;
        }

        // This controls if Staging is enabled

        if (!themeDisplay.isShowStagingIcon()) {
            return false;
        }

        return true;
    }
\end{verbatim}

\subsubsection{Defining Dependencies}\label{defining-dependencies}

Define dependencies for your Control Menu Entry in your build file
(e.g., \texttt{build.grade} or \texttt{pom.xml}). For example, some
popular dependencies (in Gradle format) are defined below:

\begin{verbatim}
    dependencies {
        compileOnly group: "com.liferay", name: "com.liferay.product.navigation.control.menu.api", version: "[VERSION]"
        compile group: "com.liferay", name: "com.liferay.product.navigation.taglib", version: "[VERSION]"
        compileOnly group: "com.liferay.portal", name: "com.liferay.portal.kernel", version: "[VERSION]"
        compileOnly group: "javax.servlet", name: "javax.servlet-api", version: "[VERSION]"
        compile group: "javax.servlet.jsp", name: "javax.servlet.jsp-api", version: "[VERSION]"
        compileOnly group: "org.osgi", name: "org.osgi.service.component.annotations", version: "[VERSION]"
    }
\end{verbatim}

Your project may require more dependencies, depending on your module's
functionality.

Excellent! You've created your entry in one of the three default panel
categories in the Control Menu. You learned a basic way and an advanced
way of providing that entry, and learned how to apply both.

\section{Defining Icons and Tooltips}\label{defining-icons-and-tooltips}

When creating a Control Menu entry, you can use an icon in addition to
or in place of text. You can also use tooltips to provide a more in
depth explanation.

\subsection{Control Menu Entry Icons}\label{control-menu-entry-icons}

You can provide a Lexicon or CSS icon in your
\texttt{*ControlMenuEntry}. To use a Lexicon icon, you should override
the methods in \texttt{ProductMenuProductNavigationControlMenuEntry}
like this one:

\begin{verbatim}
    public String getIconCssClass(HttpServletRequest request) {
        return "";
    }

    public String getIcon(HttpServletRequest request) {
        return "lexicon-icon";
    }

    public String getMarkupView(HttpServletRequest request) {
        return "lexicon";
    }
\end{verbatim}

Likewise, you can use a CSS icon by overriding the
\texttt{ProductMenuProductNavigationControlMenuEntry} methods like this
one:

\begin{verbatim}
    public String getIconCssClass(HttpServletRequest request) {
        return "icon-css";
    }

    public String getIcon(HttpServletRequest request) {
        return "";
    }

    public String getMarkupView(HttpServletRequest request) {
        return "";
    }
\end{verbatim}

You can find these icons in the
\href{https://liferay.github.io/clay/content/icons-lexicon/}{icons-lexicon}
and
\href{https://liferay.github.io/clay/content/icons-font-awesome/}{icons-font-awesome}
components, respectively.

\subsubsection{Control Menu Entry
Tooltips}\label{control-menu-entry-tooltips}

To provide a tooltip for the Control Menu entry, create a
\texttt{getLabel} method like this:

\begin{verbatim}
    @Override
    public String getLabel(Locale locale) {
        ResourceBundle resourceBundle = ResourceBundleUtil.getBundle(
            "content.Language", locale, getClass());

        return LanguageUtil.get(
            resourceBundle, "the-portal-is-currently-reindexing");
    }
\end{verbatim}

You need to create a \texttt{Language.properties} to store your labels.
You can learn more about resource bundles in the
\href{/docs/7-1/tutorials/-/knowledge_base/t/internationalization}{Internationalization}
tutorials.

\section{Extending the Simulation
Menu}\label{extending-the-simulation-menu}

When testing how pages and apps appear for users, it's important to
simulate their views in as many ways as possible. The Simulation Menu on
the right-side of the main page allows this, and you can extend the menu
if you need to simulate something that it does not provide.

First, you must get accustomed to using panel categories/apps. This is
covered in detail in the
\href{/docs/7-1/tutorials/-/knowledge_base/t/customizing-the-product-menu}{Customizing
The Product Menu} tutorial. Once you know how to create panel categories
and panel apps, continue with this tutorial.

There are few differences between the Simulation Menu and Product Menu,
mostly because they extend the same base classes. The Simulation Menu,
by default, is made up of only one panel category and one panel app.
Liferay provides the
\href{https://github.com/liferay/liferay-portal/blob/7.1.3-ga4/modules/apps/product-navigation/product-navigation-simulation-web/src/main/java/com/liferay/product/navigation/simulation/web/internal/application/list/SimulationPanelCategory.java}{\texttt{SimulationPanelCategory}}
class, a hidden category needed to hold the
\texttt{DevicePreviewPanelApp}. This is the app and functionality you
see in the Simulation Menu by default.

\begin{figure}
\centering
\includegraphics{./images/simulation-menu-preview.png}
\caption{The Simulation Menu offers a device preview application.}
\end{figure}

To provide your own functionality in the Simulation Menu, you must
create a panel app in \texttt{SimulationPanelCategory}. If you want to
add extensive functionality, you can even create additional panel
categories in the menu to divide up your panel apps. This tutorial
covers the simpler case of creating a panel app for the already present
hidden category.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Follow the steps documented in
  \href{/docs/7-0/tutorials/-/knowledge_base/t/customizing-the-product-menu\#adding-custom-panel-apps}{Adding
  Custom Panel Apps} for creating custom panel apps. Once you've created
  the foundation of your panel app, move on to learn how to tweak it so
  it customizes the Simulation Menu.

  You can generate a Simulation Panel App by using Blade CLI's
  \href{/docs/7-1/reference/-/knowledge_base/r/simulation-panel-entry-template}{Simulation
  Panel Entry template}. You can also refer to the
  \href{/docs/7-1/reference/-/knowledge_base/r/simulation-panel-app}{Simulation
  Panel App sample} for a working example.
\item
  Since this tutorial assumes you're providing more functionality to the
  existing simulation category, set the simulation category in the
  \texttt{panel.category.key} of the \texttt{@Component} annotation:

\begin{verbatim}
"panel.category.key=" + SimulationPanelCategory.SIMULATION
\end{verbatim}

  In order to use this constant, you must add a dependency on
  \href{https://repository.liferay.com/nexus/content/repositories/liferay-public-releases/com/liferay/com.liferay.product.navigation.simulation/}{\texttt{com.liferay.product.navigation.simulation}}.

  Be sure to also specify the order to display your new panel app, which
  was explained in
  \href{/docs/7-0/tutorials/-/knowledge_base/t/customizing-the-product-menu\#adding-custom-panel-apps}{Adding
  Custom Panel Apps}.
\item
  This tutorial assumes you're using JSPs. Therefore, you should extend
  the
  \href{https://docs.liferay.com/dxp/apps/web-experience/latest/javadocs/com/liferay/application/list/BaseJSPPanelApp.html}{\texttt{BaseJSPPanelApp}}
  abstract class, which implements the
  \href{https://docs.liferay.com/dxp/apps/web-experience/latest/javadocs/com/liferay/application/list/PanelApp.html}{\texttt{PanelApp}}
  interface and also provides additional methods necessary for
  specifying JSPs to render your panel app's UI. Remember that you can
  also implement your own \texttt{include()} method to use any front-end
  technology you want, if you want to use a technology other than JSP
  (e.g., FreeMarker).
\item
  Define your simulation view. For instance, in
  \texttt{DevicePreviewPanelApp}, the \texttt{getJspPath} method points
  to the \texttt{simulation-device.jsp} file in the
  \texttt{resources/META-INF/resources} folder, where the device
  simulation interface is defined. Optionally, you can also add your own
  language keys, CSS, or JavaScript resources in your simulation module.

  The right servlet context is also provided by implementing this
  method:

\begin{verbatim}
@Override
@Reference(
    target = "(osgi.web.symbolicname=com.liferay.product.navigation.simulation.device)",
    unbind = "-"
)
public void setServletContext(ServletContext servletContext) {
    super.setServletContext(servletContext);
}
\end{verbatim}

  As explained in
  \href{/docs/7-0/tutorials/-/knowledge_base/t/customizing-the-product-menu}{Customizing
  The Product Menu}, a panel app should be associated with a portlet.
  This makes the panel app visible only when the user has permission to
  view the portlet. This panel app is associated to the Simulation
  Device portlet using these methods:

\begin{verbatim}
@Override
public String getPortletId() {
    return ProductNavigationSimulationPortletKeys.
        PRODUCT_NAVIGATION_SIMULATION;
}

@Override
@Reference(
    target = "(javax.portlet.name=" + ProductNavigationSimulationPortletKeys.PRODUCT_NAVIGATION_SIMULATION + ")",
    unbind = "-"
)
public void setPortlet(Portlet portlet) {
    super.setPortlet(portlet);
}
\end{verbatim}

  Audience Targeting also provides a good example of how to extend the
  Simulation Menu. When the Audience Targeting app is deployed, the
  Simulation Menu is extended to offer Audience Targeting User Segments
  and Campaigns. You can simulate particular scenarios for campaigns and
  users directly from the Simulation Menu. Its panel app class is
  similar to \texttt{DevicePreviewPanelApp}, except it points to a
  different portlet and JSP.

  \begin{figure}
  \centering
  \includegraphics{./images/simulation-menu-at.png}
  \caption{The Audience Targeting app extends the Simulation Menu to
  help simulate different users and campaign views.}
  \end{figure}
\item
  You can combine your simulation options with the device simulation
  options by interacting with the device preview iFrame. To retrieve the
  device preview frame in an \texttt{aui:script} block of your custom
  simulation view's JavaScript, you can use this code:

\begin{verbatim}
var iframe = A.one('#simulationDeviceIframe');
\end{verbatim}

  Then you can modify the device preview frame URL like this:

\begin{verbatim}
iframe.setAttribute('src', newUrlWithCustomParameters);
\end{verbatim}
\end{enumerate}

Now that you know how to extend the necessary panel categories and panel
apps to modify the Simulation Menu,
\href{/docs/7-1/tutorials/-/knowledge_base/t/starting-module-development\#creating-a-module}{create
a module} of your own and customize the Simulation Menu so it's most
helpful for your needs.

\section{Providing the User Personal
Bar}\label{providing-the-user-personal-bar}

The User Personal Bar displays options unique to the current user. By
default, this menu appears as an avatar button that expands the User
Settings sub-menu in the Product Menu. In a custom theme, the User
Personal Bar could appear anywhere in the interface.

\begin{figure}
\centering
\includegraphics{./images/user-personal-bar.png}
\caption{By default, the User Personal Menu contains the signed-in
user's avatar, which navigates to the Product Menu when selected.}
\end{figure}

Although Liferay's default User Personal Bar is bare-bones, you can add
more functionality to fit your needs. Unlike other product navigation
menus (e.g., Product Menu), the User Personal Bar does not require the
extension/creation of panel categories and panel apps.

The User Personal Bar can be seen as a placeholder in every Liferay
theme. By default, Liferay provides one sample \emph{User Personal Bar}
portlet that fills that placeholder, but the portlet Liferay provides
can be replaced by other portlets.

\noindent\hrulefill

\textbf{Note:} You can add the User Personal Bar to your theme by adding
the following snippet into your \texttt{portal\_normal.ftl}:

\begin{verbatim}
 <@liferay.user_personal_bar />
\end{verbatim}

\noindent\hrulefill

In this tutorial, you'll learn how to customize the User Personal Bar.
You'll create a single Java class where you'll specify a portlet to
replace the existing default portlet.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/starting-module-development}{Create
  an OSGi module}.
\item
  Create a unique package name in the module's \texttt{src} directory
  and create a new Java class in that package.
\item
  Above the class declaration, insert the following annotation:

\begin{verbatim}
@Component(
    immediate = true,
    property = {
        "model.class.name=" + PortalUserPersonalBarApplicationType.UserPersonalBar.CLASS_NAME,
        "service.ranking:Integer=10"
    },
    service = ViewPortletProvider.class
)
\end{verbatim}

  The \texttt{model.class.name} property must be set to the class name
  of the entity type you want the portlet to handle. In this case, you
  want your portlet to be provided based on whether it can be displayed
  in the User Personal Bar.

  You should also specify the service rank for your new portlet so it
  overrides the default. Make sure to set the
  \texttt{service.ranking:Integer} property to a number that is ranked
  higher than the portlet being used by default.

  Since you only want the User Personal Bar to display your portlet, the
  \texttt{service} element should be \texttt{ViewPortletProvider.class}.
\item
  Update the class's declaration to extend the
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/BasePortletProvider.html}{BasePortletProvider}
  abstract class and implement \texttt{ViewPortletProvider}:

\begin{verbatim}
public class ExampleViewPortletProvider extends BasePortletProvider implements ViewPortletProvider {
\end{verbatim}
\item
  Specify the portlet you want in the User Personal Bar by declaring the
  following method in your class:

\begin{verbatim}
@Override
public String getPortletName() {
    return PORTLET_NAME;
}
\end{verbatim}

  Replace the \texttt{PORTLET\_NAME} text with the portlet you want to
  provide Liferay when it requests one to be viewed in the User Personal
  Bar. For example, Liferay declares
  \texttt{com\_liferay\_product\_navigation\_user\_personal\_bar\_web\_portlet\_ProductNavigationPersonalBarPortlet}
  for its default User Personal Bar portlet.
\end{enumerate}

You've successfully provided a portlet to be displayed in the User
Personal Bar. If you want to inspect the entire module used for
Liferay's default User Personal Bar, see
\href{https://github.com/liferay/liferay-portal/tree/7.1.x/modules/apps/product-navigation/product-navigation-user-personal-bar-web}{product-navigation-user-personal-bar-web}.
Besides the \texttt{*ViewPortletProvider} class, this module contains
two classes defining constants and a portlet class defining the default
portlet to provide. Although these additional classes are not required,
your module should have access to the portlet you want to provide.

\chapter{Collaboration}\label{collaboration}

The collaboration suite helps users interact and create content
together. This can be as simple as a quick conversation in the Message
Boards app or as complex as joint file management via the Documents and
Media Library. Users can Blog their experiences and share knowledge with
the Wiki. Comments can be posted on all content. Integrated applications
mean the whole is greater than the sum of the parts: together, users
create something of value that couldn't exist if they were working in
isolation.

Underlying the collaboration suite is a set of powerful APIs so you can
leverage these features in your own apps. For example, if your app lets
users create a custom content type, you can tie into the collaboration
suite's social API to let users comment on and rate that content. You
can also customize how your app's users select items from the Documents
and Media Library, send custom alerts and announcements, and much, much
more. The tutorials in this section show you how.

\chapter{Item Selector}\label{item-selector}

An \emph{Item Selector} is a UI component for selecting entities in a
user-friendly manner. Many Liferay apps use Item Selectors to let users
select items such as images, videos, audio files, documents, and pages.
For example, the Documents and Media Library lets users select files.

\begin{figure}
\centering
\includegraphics{./images/item-selector-dialog-02.png}
\caption{Item Selectors let users browse and select different kinds of
entities.}
\end{figure}

The Item Selector API provides a framework for you to use, extend, and
create Item Selectors in your own apps. The tutorials in this section
show you how to use this framework.

Here are some use cases for the Item Selector API:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Letting your app's users select entities via an Item Selector.
\item
  Configuring an Item Selector to select your app's custom entity.
\item
  Customizing the selection experience by adding a new \emph{selection
  view} for an entity.
\end{enumerate}

You'll learn what a selection view is, along with the Item Selector
API's other components, in the next tutorial.

\section{Understanding the Item Selector API's
Components}\label{understanding-the-item-selector-apis-components}

Before working with the Item Selector API, you should learn about its
components. You'll work with these components as you leverage the API in
your apps:

\begin{itemize}
\item
  \textbf{Selection views:} These are the framework's key components.
  They show entities of particular types from different sources. For
  example, an Item Selector configured to show images might show
  selection views from Documents and Media, a third-party image
  provider, or a drag-and-drop UI.
\item
  \textbf{Markup:} A markup file that renders the selection view. You
  have a great deal of flexibility in the markup language you choose.
  For example, you can use a JSP, FreeMarker, or even pure HTML and
  JavaScript.
\item
  \textbf{Return Type:} A class that represents the type of information
  returned from the entities selected by the users. For example, if
  users select images and you want to return the selected image's URL,
  then you need a URL return type class. Each return type class must
  implement the
  \href{https://docs.liferay.com/dxp/apps/collaboration/latest/javadocs/com/liferay/item/selector/ItemSelectorReturnType.html}{\texttt{ItemSelectorReturnType}
  interface}. Such classes are named after the data they return and
  suffixed with \texttt{ItemSelectorReturnType}. For example, the URL
  return type class is \texttt{URLItemSelectorReturnType}.
\item
  \textbf{Criterion:} A class that represents the entity selected by the
  users. For example, if users select images then you need an image
  criterion class. Each criterion class must implement the
  \href{https://docs.liferay.com/dxp/apps/collaboration/latest/javadocs/com/liferay/item/selector/ItemSelectorCriterion.html}{\texttt{ItemSelectorCriterion}
  interface}. Criterion classes are named for the entity they represent
  and suffixed with \texttt{ItemSelectorCriterion}. For example, the
  criterion class for images is \texttt{ImageItemSelectorCriterion}.
\item
  \textbf{Criterion Handler:} A class that gets the appropriate
  selection view. Each criterion requires a criterion handler. Criterion
  handler classes extend the
  \href{https://docs.liferay.com/dxp/apps/collaboration/latest/javadocs/com/liferay/item/selector/BaseItemSelectorCriterionHandler.html}{\texttt{BaseItemSelectorCriterionHandler}
  class} with the criterion's entity as a type argument. Criterion
  handler classes are named after the criterion's entity and suffixed by
  \texttt{ItemSelectorCriterionHandler}. For example, the image
  criterion handler class is \texttt{ImageItemSelectorCriterionHandler}.
  It extends
  \texttt{BaseItemSelectorCriterionHandler\textless{}ImageItemSelectorCriterion\textgreater{}}.
\end{itemize}

This diagram shows how these components interact to form a working API.

\begin{figure}
\centering
\includegraphics{./images/item-selector-architecture.png}
\caption{Item Selector views (selection views) are determined by the
return type and criterion, and rendered by the markup.}
\end{figure}

\subsection{Related Topics}\label{related-topics-287}

\href{/docs/7-1/tutorials/-/knowledge_base/t/selecting-entities-using-the-item-selector}{Selecting
Entities Using an Item Selector}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-custom-item-selector-entities}{Creating
Custom Item Selector Entities}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-custom-item-selector-views}{Creating
Custom Item Selector Views}

\section{Selecting Entities Using an Item
Selector}\label{selecting-entities-using-an-item-selector}

An Item Selector lets users select entities such as images, videos,
documents, and sites. You can use an Item Selector in your app to let
users select such entities. This tutorial shows you how to do this via
these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{Determine the Criteria for an Item Selector:} You must first
  define which entities an Item Selector can let users select.
\item
  \textbf{Get an Item Selector for Your Criteria:} If your criteria is
  for images, for example, then in this step you'll get an Item Selector
  capable of selecting images.
\item
  \textbf{Use an Item Selector Dialog:} Display the Item Selector in
  your UI.
\end{enumerate}

\begin{figure}
\centering
\includegraphics{./images/item-selector-dialog-01.png}
\caption{An Item Selector makes selecting entities a breeze.}
\end{figure}

\subsection{Determining Item Criteria}\label{determining-item-criteria}

The first step is determining entity types to select from the Item
Selector and the data you expect from them. What kind of entity do you
want to select? Do you want to select a user, an image, a video, or
something else?

Once you know the entities you want, you need \emph{criterion} classes
to represent them in the Item Selector. Criterion classes must implement
the
\href{https://docs.liferay.com/dxp/apps/collaboration/latest/javadocs/com/liferay/item/selector/ItemSelectorCriterion.html}{\texttt{ItemSelectorCriterion}
interface}. The
\href{/docs/7-1/reference/-/knowledge_base/r/item-selector-criterion-and-return-types}{Item
Selector Criterion and Return Types} reference lists criterion classes
Liferay's apps and app suites provide.

If there's no criterion class for your entity, you can create your own
\href{https://docs.liferay.com/dxp/apps/collaboration/latest/javadocs/com/liferay/item/selector/ItemSelectorCriterion.html}{\texttt{ItemSelectorCriterion}
class}.

Then determine the type of information (return type) you expect from the
entities when users select them. Do you expect a URL? A Universally
Unique Identifier (UUID)? A primary key? Each return type must be
represented by an implementation of the
\href{https://docs.liferay.com/dxp/apps/collaboration/latest/javadocs/com/liferay/item/selector/ItemSelectorReturnType.html}{\texttt{ItemSelectorReturnType}
class}. The
\href{/docs/7-1/reference/-/knowledge_base/r/item-selector-criterion-and-return-types}{Item
Selector Criterion and Return Types} reference also lists return type
classes Liferay DXP's apps and app suites provide.

If there's no return type class that meets your needs, you can implement
your own
\href{https://docs.liferay.com/dxp/apps/collaboration/latest/javadocs/com/liferay/item/selector/ItemSelectorReturnType.html}{\texttt{ItemSelectorReturnType}
class}.

\noindent\hrulefill

\textbf{Note}: Each criterion must have at least one
\texttt{ItemSelectorReturnType} (return type) associated with it.

\noindent\hrulefill

For example, if you want to allow users to select an image and want the
image's URL returned, you could use the
\texttt{ImageItemSelectorCriterion} criterion class and the
\texttt{URLItemSelectorReturnType} return type.

The criterion and return types are collectively referred to as the Item
Selector's \emph{criteria}. The Item Selector uses it to decide which
selection views (tabs of items) to show.

Once you've defined your criteria, you can get an Item Selector to use
with it.

\subsection{Getting an Item Selector for the
Criteria}\label{getting-an-item-selector-for-the-criteria}

To use an Item Selector with your criteria, you must get that Item
Selector's URL. The URL is needed to open the Item Selector dialog in
your UI. To get this URL, you must get an \texttt{ItemSelector}
reference and call its
\href{https://docs.liferay.com/dxp/apps/collaboration/latest/javadocs/com/liferay/item/selector/ItemSelector.html\#getItemSelectorURL-com.liferay.portal.kernel.portlet.RequestBackedPortletURLFactory-java.lang.String-com.liferay.item.selector.ItemSelectorCriterion...-}{\texttt{getItemSelectorURL}
method} with the following parameters:

\begin{itemize}
\tightlist
\item
  \texttt{RequestBackedPortletURLFactory}: A factory that creates
  portlet URLs.
\item
  \texttt{ItemSelectedEventName}: A unique, arbitrary JavaScript event
  name that the Item Selector triggers when the element is selected.
\item
  \texttt{ItemSelectorCriterion}: The criterion (or an array of
  criterion objects) that specifies the type of elements to make
  available in the Item Selector.
\end{itemize}

The following code demonstrates getting a URL to an Item Selector
configured with criteria for images:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Use Declarative Services to get an \texttt{ItemSelector} OSGi Service
  Component:

\begin{verbatim}
import com.liferay.item.selector.ItemSelector;
import org.osgi.service.component.annotations.Reference;

...

@Reference
private ItemSelector _itemSelector
\end{verbatim}

  The component annotations are available in the
  \href{http://mvnrepository.com/artifact/org.osgi/org.osgi.service.component.annotations}{\texttt{org.osgi.service.component.annotations}
  module}.
\item
  Create the factory you'll use to create the URL. To do this, invoke
  the \texttt{RequestBackedPortletURLFactoryUtil.create} method with the
  current request object. The request can be an
  \texttt{HttpServletRequest} or \texttt{PortletRequest}:

\begin{verbatim}
RequestBackedPortletURLFactory requestBackedPortletURLFactory =
    RequestBackedPortletURLFactoryUtil.create(request);
\end{verbatim}
\item
  Create a list of return types expected for the image entity. The
  return types list consists of a URL return type
  \texttt{URLItemSelectorReturnType}:

\begin{verbatim}
List<ItemSelectorReturnType> desiredItemSelectorReturnTypes =
    new ArrayList<>();
desiredItemSelectorReturnTypes.add(new URLItemSelectorReturnType());
\end{verbatim}
\item
  Create a criterion object for images
  (\texttt{ImageItemSelectorCriterion}):

\begin{verbatim}
ImageItemSelectorCriterion imageItemSelectorCriterion =
    new ImageItemSelectorCriterion();
\end{verbatim}
\item
  Use the criterion's \texttt{setDesiredItemSelectorReturnTypes} method
  to set the return types list from step 3 to the criterion:

\begin{verbatim}
imageItemSelectorCriterion.setDesiredItemSelectorReturnTypes(
    desiredItemSelectorReturnTypes);
\end{verbatim}
\item
  Call the Item Selector's \texttt{getItemSelectorURL} method to get an
  Item Selector URL based on the criterion. The method requires the URL
  factory, an arbitrary event name, and a series of criterion (one, in
  this case):

\begin{verbatim}
PortletURL itemSelectorURL = _itemSelector.getItemSelectorURL(
    requestBackedPortletURLFactory, "sampleTestSelectItem",
    imageItemSelectorCriterion);
\end{verbatim}
\end{enumerate}

There are a few things to keep in mind when getting an Item Selector's
URL:

\begin{itemize}
\item
  You can invoke the URL object's \texttt{toString} method to get its
  value.
\item
  You can configure an Item Selector to use any number of criterion. The
  criterion can use any number of return types.
\item
  The order of the Item Selector's criteria determines the selection
  view order. For example, if you pass the Item Selector an
  \texttt{ImageItemSelectorCriterion} followed by a
  \texttt{VideoItemSelectorCriterion}, the Item Selector displays the
  image selection views first.
\item
  The return type order is also significant. A view uses the first
  return type it supports from each criterion's return type list.
\end{itemize}

Now that you've got a URL to an Item Selector, you can start using that
Item Selector in your UI.

\subsection{Using the Item Selector
Dialog}\label{using-the-item-selector-dialog}

To open the Item Selector in your UI, you must use the JavaScript
component \texttt{LiferayItemSelectorDialog} from
\href{http://alloyui.com/}{AlloyUI's}
\texttt{liferay-item-selector-dialog} module. The component listens for
the item selected event that you specified for the Item Selector URL.
The event returns the selected element's information according to its
return type.

Here are the steps for using the Item Selector dialog in a JSP:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Declare the AUI tag library:

\begin{verbatim}
<%@ taglib prefix="aui" uri="http://liferay.com/tld/aui" %>
\end{verbatim}
\item
  Define the UI element that you'll use to open the Item Selector
  dialog. For example, this creates a \emph{Choose} button with the ID
  \texttt{chooseImage}:

\begin{verbatim}
<aui:button name="chooseImage" value="Choose" />
\end{verbatim}
\item
  Get the Item Selector's URL:

\begin{verbatim}
<%
String itemSelectorURL = GetterUtil.getString(request.getAttribute("itemSelectorURL"));
%>
\end{verbatim}
\item
  Add the \texttt{\textless{}aui:script\textgreater{}} tag and set it to
  use the \texttt{liferay-item-selector-dialog} module:

\begin{verbatim}
<aui:script use="liferay-item-selector-dialog">

</aui:script>
\end{verbatim}
\item
  Inside the \texttt{\textless{}aui:script\textgreater{}} tag, attach an
  event handler to the UI element you created in step 2. For example,
  this attaches a click event and a function to the \emph{Choose}
  button:

\begin{verbatim}
<aui:script use="liferay-item-selector-dialog">

    $('#<portlet:namespace />chooseImage').on(
    'click',
      function(event) {
        <!-- function logic goes here -->
      }
    );

</aui:script>
\end{verbatim}

  Inside the function, you must create a new instance of the
  \texttt{LiferayItemSelectorDialog} AlloyUI component and configure it
  to use the Item Selector. The next steps walk you through this.
\item
  Now you must create the function logic. First, create a new instance
  of the Liferay Item Selector dialog:

\begin{verbatim}
var itemSelectorDialog = new A.LiferayItemSelectorDialog(  
    {
        ...
    }
);
\end{verbatim}
\item
  Inside the braces of the \texttt{LiferayItemSelectorDialog}
  constructor, first set set the \texttt{eventName} attribute. This
  makes the dialog listen for the item selected event. The event name is
  the the Item Selector's event name that you specified in your Java
  code (the code that gets the Item Selector URL):

\begin{verbatim}
eventName: 'ItemSelectedEventName',
\end{verbatim}
\item
  Immediately after the \texttt{eventName} setting, set the \texttt{on}
  attribute to implement a function that operates on the selected item
  change. For example, this function sets its variables for the newly
  selected item. The information available to parse depends on the
  return type(s) that were set. As the comment indicates, you must add
  the logic for using the selected element:

\begin{verbatim}
on: {
        selectedItemChange: function(event) {
            var selectedItem = event.newVal;

            if (selectedItem) {
                var itemValue = JSON.parse(
                selectedItem.value
                );
                itemSrc = itemValue.url;

                <!-- use item as needed -->
            }
        }
},
\end{verbatim}
\item
  Immediately after the \texttt{on} setting, set the \texttt{title}
  attribute to the dialog's title:

\begin{verbatim}
title: '<liferay-ui:message key="select-image" />',
\end{verbatim}
\item
  Immediately after the \texttt{title} setting, set the \texttt{url}
  attribute to the previously retrieved Item Selector URL. This
  concludes the attribute settings inside the
  \texttt{LiferayItemSelectorDialog} constructor:

\begin{verbatim}
url: '<%= itemSelectorURL.toString() %>'
\end{verbatim}
\item
  To conclude the logic of the function from step 4, open the Item
  Selector dialog by calling its \texttt{open} method:

\begin{verbatim}
itemSelectorDialog.open();
\end{verbatim}
\end{enumerate}

Here's the complete example code for these steps:

\begin{verbatim}
<%@ taglib prefix="aui" uri="http://liferay.com/tld/aui" %>

<aui:button name="chooseImage" value="Choose" />

<%
String itemSelectorURL = GetterUtil.getString(request.getAttribute("itemSelectorURL"));
%>

<aui:script use="liferay-item-selector-dialog">

    $('#<portlet:namespace />chooseImage').on(
        'click', 
        function(event) {
            var itemSelectorDialog = new A.LiferayItemSelectorDialog(  
                {
                    eventName: 'ItemSelectedEventName',
                    on: {
                            selectedItemChange: function(event) {
                                var selectedItem = event.newVal;

                                if (selectedItem) {
                                    var itemValue = JSON.parse(
                                    selectedItem.value
                                    );
                                    itemSrc = itemValue.url;

                                    <!-- use item as needed -->
                                }
                            }
                    },
                    title: '<liferay-ui:message key="select-image" />',
                    url: '<%= itemSelectorURL.toString() %>'
                }
            );
            itemSelectorDialog.open();
        }
    );
</aui:script>
\end{verbatim}

When the user clicks the \emph{Choose} button, a new dialog opens,
rendering the Item Selector with the views that support the criterion
and return type(s) that were set.

Great! Now you know how to select entities using an Item Selector. Using
the Item Selector API, you can give your app's users the power of
choice!

\subsection{Related Articles}\label{related-articles-2}

\href{/docs/7-1/tutorials/-/knowledge_base/t/understanding-the-item-selector-apis-components}{Understanding
the Item Selector API's Components}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-custom-item-selector-views}{Creating
Custom Item Selector Views}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-custom-item-selector-entities}{Creating
Custom Item Selector Entities}

\href{/docs/7-1/tutorials/-/knowledge_base/t/front-end-taglibs}{Front-End
Taglibs}

\section{Creating Custom Item Selector
Entities}\label{creating-custom-item-selector-entities}

Does your app require users to select an item that the Item Selector
isn't configured for? No problem. You can create a new entity.

This tutorial explains how to create a new entity for the Item Selector.

\subsection{Creating Item Selector
Criterion}\label{creating-item-selector-criterion}

First, you must create a new criterion for your entity:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a class that extends the
  \href{https://docs.liferay.com/dxp/apps/collaboration/latest/javadocs/com/liferay/item/selector/BaseItemSelectorCriterion.html}{\texttt{BaseItemSelectorCriterion}
  class}. This class specifies what kind of entity the user is selecting
  and what information the Item Selector should return. The methods
  inherited from \texttt{BaseItemSelectorCriterion} provide the logic
  for obtaining this information.

  Note that you can use this class to pass information to the view if
  needed. For example, the
  \href{https://docs.liferay.com/dxp/apps/web-experience/latest/javadocs/com/liferay/journal/item/selector/criterion/JournalItemSelectorCriterion.html}{\texttt{JournalItemSelectorCriterion}
  class} passes information about the primary key so the view can use
  it:

\begin{verbatim}
public class JournalItemSelectorCriterion extends BaseItemSelectorCriterion {

        public JournalItemSelectorCriterion() {
        }

        public JournalItemSelectorCriterion(long resourcePrimKey) {
                _resourcePrimKey = resourcePrimKey;
        }

        public long getResourcePrimKey() {
                return _resourcePrimKey;
        }

        public void setResourcePrimKey(long resourcePrimKey) {
                _resourcePrimKey = resourcePrimKey;
        }

        private long _resourcePrimKey;

}
\end{verbatim}
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** Criterion fields should be serializable and should expose a
 public empty constructor (as shown above).
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\item
  Create an OSGi component class that implements the
  \href{https://docs.liferay.com/dxp/apps/collaboration/latest/javadocs/com/liferay/item/selector/BaseItemSelectorCriterionHandler.html}{\texttt{BaseItemSelectorCriterionHandler}
  class}. Each criterion requires a criterion handler, which is
  responsible for obtaining the proper selection view.

  This example creates a criterion handler for the
  \texttt{TaskItemSelectorCriterion} class:

\begin{verbatim}
@Component(service = ItemSelectorCriterionHandler.class)
public class TaskItemSelectorCriterionHandler extends 
    BaseItemSelectorCriterionHandler<TaskItemSelectorCriterion> {

    public Class <TaskItemSelectorCriterion> getItemSelectorCriterionClass() {
        return TasksItemSelectorCriterionHandler.class;
    }

    @Activate
    @Override
    protected void activate(BundleContext bundleContext) {
            super.activate(bundleContext);
    }

}
\end{verbatim}

  The \texttt{@Activate} and \texttt{@Override} tokens are required to
  activate this OSGi component.
\end{enumerate}

Depending on your app's needs, you may not need to create a return type.
If your entity returns information that is already defined by an
existing return type, you can use that return type instead. You can view
the default available criteria in the reference document
\href{/docs/7-1/reference/-/knowledge_base/r/item-selector-criterion-and-return-types}{Item
Selector Criterion and Return Types}. If, however, your entity returns
information that is not covered by an existing return type, you'll need
to create a new return type next.

\subsection{Creating Item Selector Return
Types}\label{creating-item-selector-return-types}

To create a return type, you must create a class that implements the
\href{https://docs.liferay.com/dxp/apps/collaboration/latest/javadocs/com/liferay/item/selector/ItemSelectorReturnType.html}{\texttt{ItemSelectorReturnType}
interface}. You should name such classes after their entity, and suffix
them with \texttt{ItemSelectorReturnType}. For example, if you were to
create a return type for a task item, its return type class would be
\texttt{TaskItemSelectorReturnType}. Such a
\texttt{*ItemSelectorReturnType} class is used as an identifier by the
Item Selector and does not return any information itself. The return
type class is an API that connects the return type to the Item Selector
views. Whenever the return type is used, the view must ensure that the
proper information is returned. It's recommended that you specify the
information that the return type returns, as well as the format, as
Javadoc. For example, here's the example return type class
\texttt{TaskItemSelectorReturnType}:

\begin{verbatim}
/**
* This return type should return the task ID and the user who
* created the task as a string.
*
* @author Joe Bloggs
*/
public class TaskItemSelectorReturnType implements ItemSelectorReturnType{

}
\end{verbatim}

Nice work! Your new entity's criterion and return type classes can be
used by your app to create the Item Selector's URL. To learn how to
obtain the Item Selector URL's, see the tutorial
\href{/docs/7-1/tutorials/-/knowledge_base/t/selecting-entities-using-the-item-selector}{Selecting
Entities Using the Item Selector}.

Once you have the Item Selector's URL, a selection view is responsible
for returning the proper entity information specified by the return
type. To create such a selection view for your entity, see the tutorial
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-custom-item-selector-views}{Creating
Custom Item Selector Views}.

\subsection{Related Topics}\label{related-topics-288}

\href{/docs/7-1/tutorials/-/knowledge_base/t/understanding-the-item-selector-apis-components}{Understanding
the Item Selector API's Components}

\href{/docs/7-1/tutorials/-/knowledge_base/t/selecting-entities-using-the-item-selector}{Selecting
Entities using the Item Selector}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-custom-item-selector-views}{Creating
Custom Item Selector Views}

\section{Creating Custom Item Selector
Views}\label{creating-custom-item-selector-views}

Item Selector's default selection views may provide everything you need
for your app. Custom selection views are required, however, for certain
situations. For example, if you want your users to be able to select
images from an external image provider, then you must create a custom
selection view. You can create a custom selection view by following the
steps in this tutorial. Before getting started, you'll learn a bit more
about selection views.

Note that the view the Item Selector presents is determined by the type
of entity the user is selecting. The Item Selector can also render
multiple views for the same entity type. For example, several selection
views are available when a user selects an image. Each selection view is
a tab in the UI that corresponds to the image's location.

\begin{figure}
\centering
\includegraphics{./images/item-selector-tabs.png}
\caption{An entity type can have multiple selection views.}
\end{figure}

Each selection view is represented by an \texttt{*ItemSelectorCriterion}
class. The tabs in figure 1 are represented by the following
\texttt{*ItemSelectorCriterion}:

\begin{itemize}
\tightlist
\item
  \href{https://docs.liferay.com/dxp/apps/collaboration/latest/javadocs/com/liferay/blogs/item/selector/criterion/BlogsItemSelectorCriterion.html}{\texttt{BlogsItemSelectorCriterion}
  class}: Blog Images View
\item
  \href{https://docs.liferay.com/dxp/apps/collaboration/latest/javadocs/com/liferay/item/selector/criteria/image/criterion/ImageItemSelectorCriterion.html}{\texttt{ImageItemSelectorCriterion}
  class}: Documents and Media View
\item
  \href{https://docs.liferay.com/dxp/apps/collaboration/latest/javadocs/com/liferay/item/selector/criteria/url/criterion/URLItemSelectorCriterion.html}{\texttt{URLItemSelectorCriterion}
  class}: URL View
\item
  \href{https://docs.liferay.com/dxp/apps/collaboration/latest/javadocs/com/liferay/item/selector/criteria/upload/criterion/UploadItemSelectorCriterion.html}{\texttt{UploadItemSelectorCriterion}
  class}: Upload Image View
\end{itemize}

You'll create a custom selection view by following these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Configure your selection view's OSGi module.
\item
  Implement the selection view's class.
\item
  Write your selection view's markup.
\end{enumerate}

\subsection{Configuring Your Selection View's OSGi
Module}\label{configuring-your-selection-views-osgi-module}

Follow these steps to configure your selection view's module:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add these dependencies to your module's \texttt{build.gradle}:

\begin{verbatim}
dependencies {
        compileOnly group: "com.liferay", name: "com.liferay.item.selector.api", version: "2.0.0"
        compileOnly group: "com.liferay", name: "com.liferay.item.selector.criteria.api", version: "2.0.0"
        compileOnly group: "com.liferay.portal", name: "com.liferay.portal.impl", version: "2.0.0"
        compileOnly group: "com.liferay.portal", name: "com.liferay.portal.kernel", version: "2.0.0"
        compileOnly group: "com.liferay.portal", name: "com.liferay.util.taglib", version: "2.0.0"
        compileOnly group: "javax.portlet", name: "portlet-api", version: "2.0"
        compileOnly group: "javax.servlet", name: "javax.servlet-api", version: "3.0.1"
        compileOnly group: "org.osgi", name: "org.osgi.service.component.annotations", version: "1.3.0"
}
\end{verbatim}
\item
  Add your module's information to the \texttt{bnd.bnd} file. For
  example, this configuration adds the information for a module called
  \texttt{My\ Custom\ View}:

\begin{verbatim}
Bundle-Name: My Custom View
Bundle-SymbolicName: com.liferay.docs.my.custom.view
Bundle-Version: 1.0.0
\end{verbatim}
\item
  Add a \texttt{Web-ContextPath} to your \texttt{bnd.bnd} to point to
  your module's resources:

\begin{verbatim}
Include-Resource:\
        META-INF/resources=src/main/resources/META-INF/resources
Web-ContextPath: /my-custom-view
\end{verbatim}

  If you don't have a \texttt{Web-ContextPath}, your module won't know
  where your resources are. The \texttt{Include-Resource} header points
  to the relative path for the module's resources.
\end{enumerate}

Now that your module is configured, you can create the selection view's
class.

\subsection{Implementing Your Selection View's
Class}\label{implementing-your-selection-views-class}

To create a new selection view, you must first know what kind of
entities you want it to present (images, videos, users, etc.). This
determines the specific \texttt{ItemSelectorCriterion} you need to use.
For example, a selection view for images must use
\texttt{ImageItemSelectorCriterion}.

You must also know the entity's return type (the information type you
expect from entities when users select them). For example, if a selected
entity returns its URL, you would use \texttt{URLItemSelectorReturnType}
for the return type.

For a full list of the criterion and returns types available in Liferay
DXP's apps, see the reference document
\href{/docs/7-1/reference/-/knowledge_base/r/item-selector-criterion-and-return-types}{Item
Selector Criterion and Return Types}.

Once you've determined these things, follow these steps to create your
selection view's class:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create an \texttt{ItemSelectorView} component class that implements
  the
  \href{https://docs.liferay.com/dxp/apps/collaboration/latest/javadocs/com/liferay/item/selector/ItemSelectorView.html}{\texttt{ItemSelectorView}
  interface}. Use the criterion the view requires as a type argument to
  this interface. In the \texttt{@Component} annotation, set the
  \texttt{item.selector.view.order} property to the order you want it to
  appear in when displayed alongside other selector views of the same
  criterion. The lower this value is, the higher the view's priority is
  and the sooner it appears in the order.

  For example, this example selector view class is for images, so it
  implements \texttt{ItemSelectorView} with the
  \href{https://docs.liferay.com/dxp/apps/collaboration/latest/javadocs/com/liferay/item/selector/criteria/image/criterion/ImageItemSelectorCriterion.html}{\texttt{ImageItemSelectorCriterion}
  class} as a type argument. The \texttt{@Component} annotation sets the
  \texttt{item.selector.view.order} property to \texttt{200} and
  registers the class as an \texttt{ItemSelectorView} service:

\begin{verbatim}
@Component(
    property = {"item.selector.view.order:Integer=200"},
    service = ItemSelectorView.class
)
public class SampleItemSelectorView
    implements ItemSelectorView<ImageItemSelectorCriterion> {...
\end{verbatim}

  Note that the criteria order can also be specified in the app's
  \href{https://docs.liferay.com/dxp/apps/collaboration/latest/javadocs/com/liferay/item/selector/ItemSelector.html\#getItemSelectorURL-com.liferay.portal.kernel.portlet.RequestBackedPortletURLFactory-java.lang.String-com.liferay.item.selector.ItemSelectorCriterion...-}{\texttt{getItemSelectorURL}
  method}.
\item
  Create getter methods for the criterion class, servlet context, and
  return types. You'll use these in the steps that follow:

\begin{verbatim}
@Override
public Class<ImageItemSelectorCriterion> getItemSelectorCriterionClass() 
{
    return ImageItemSelectorCriterion.class;
}

@Override            
public ServletContext getServletContext() {
    return _servletContext;
}

@Override            
public List<ItemSelectorReturnType> getSupportedItemSelectorReturnTypes() {
    return _supportedItemSelectorReturnTypes;
}
\end{verbatim}

  Note that the
  \href{https://docs.liferay.com/dxp/apps/collaboration/latest/javadocs/com/liferay/item/selector/ItemSelectorView.html\#getSupportedItemSelectorReturnTypes--}{\texttt{getSupportedItemSelectorReturnTypes}
  method} returns a list of \texttt{ItemSelectorReturnType}s. You'll
  populate this list in a later step to specify the return types that
  the selection view supports.
\item
  Configure the title, search options, and visibility settings for the
  selection view. You'll do this via these methods:

  \begin{itemize}
  \item
    \href{https://docs.liferay.com/dxp/apps/collaboration/latest/javadocs/com/liferay/item/selector/ItemSelectorView.html\#getTitle-java.util.Locale-}{\texttt{getTitle}}:
    returns the localized title of the tab to display in the Item
    Selector dialog.
  \item
    \href{https://docs.liferay.com/dxp/apps/collaboration/latest/javadocs/com/liferay/item/selector/ItemSelectorView.html\#isShowSearch--}{\texttt{isShowSearch()}}:
    returns whether the Item Selector view should show the search field.
  \end{itemize}
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** To implement search, return `true` for this method. The
 `renderHTML` method, covered in the next section, indicates whether a user
 performed a search based on the value of the `search` parameter. Then the
 keywords the user searched can be obtained as follows:
 
     String keywords = ParamUtil.getString(request, "keywords");
\end{verbatim}

\noindent\hrulefill

\begin{verbatim}
- [`isVisible()`](https://docs.liferay.com/dxp/apps/collaboration/latest/javadocs/com/liferay/item/selector/ItemSelectorView.html#isVisible-com.liferay.portal.kernel.theme.ThemeDisplay-):
returns whether the Item Selector view is visible. In most cases, you'll 
want to set this to `true`. You can use this method to add conditional logic 
to disable the view. 

Here's an example configuration for the `Sample Selector` selection view: 

    @Override
    public String getTitle(Locale locale) {
        return "Sample Selector";
    }

    @Override
    public boolean isShowSearch() {
        return false;
    }

    @Override
    public boolean isVisible(ThemeDisplay themeDisplay) {
        return true;
    }
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{3}
\item
  Use the
  \href{https://docs.liferay.com/dxp/apps/collaboration/latest/javadocs/com/liferay/item/selector/ItemSelectorView.html\#renderHTML-javax.servlet.ServletRequest-javax.servlet.ServletResponse-T-javax.portlet.PortletURL-java.lang.String-boolean-}{\texttt{renderHTML}
  method} to set the render settings for your view. In addition to the
  servlet request and response, this method takes the following
  arguments:

  \begin{itemize}
  \tightlist
  \item
    \texttt{itemSelectorCriterion}: the \texttt{*ItemSelectorCriterion}
    required to display the selection view.
  \item
    \texttt{portletURL}: the portlet URL used to invoke the Item
    Selector.
  \item
    \texttt{itemSelectedEventName}: the event name that the caller
    listens for. When an element is selected, the view fires a
    JavaScript event with this name.
  \item
    \texttt{search}: a search boolean that specifies when the selection
    view should render search results. When the user performs a search,
    this boolean should be set to \texttt{true}.
  \end{itemize}

  Here's an example implementation of a \texttt{renderHTML} method that
  points to a JSP file (\texttt{sample.jsp}) to render the view. Note
  that the \texttt{itemSelectedEventName} is passed as a request
  attribute so it can be used in the view markup. The view markup is
  specified via the \texttt{ServletContext} method
  \texttt{getRequestDispatcher}. Although this example uses JSPs, you
  can use another language such as FreeMarker to render the markup:

\begin{verbatim}
@Override
public void renderHTML(
    ServletRequest request, ServletResponse response,
    ImageItemSelectorCriterion itemSelectorCriterion,
    PortletURL portletURL, String itemSelectedEventName,
    boolean search
)
throws IOException, ServletException {

    request.setAttribute(_ITEM_SELECTED_EVENT_NAME,
        itemSelectedEventName);

    ServletContext servletContext = getServletContext();

    RequestDispatcher requestDispatcher =
        servletContext.getRequestDispatcher("/sample.jsp");

    requestDispatcher.include(request, response);
}
\end{verbatim}
\item
  Use the \texttt{@Reference} annotation to reference your module's
  class for the \texttt{setServletContext} method. In the annotation,
  use the \texttt{target} parameter to specify the available services
  for the servlet context. This example uses the
  \texttt{osgi.web.symbolicname} property to specify the
  \texttt{com.liferay.selector.sample.web} class as the default value.
  You should also use the \texttt{unbind\ =\ \_} parameter to specify
  that there's no unbind method for this module. In the method body,
  simply set the servlet context variable:

\begin{verbatim}
@Reference(
    target =
    "(osgi.web.symbolicname=com.liferay.item.selector.sample.web)",
    unbind = "-"
)
public void setServletContext(ServletContext servletContext) {
    _servletContext = servletContext;
}
\end{verbatim}
\item
  Define the \texttt{\_supportedItemSelectorReturnTypes} list that you
  referenced in step 2 with the return types that this view supports.
  This example adds the
  \href{https://docs.liferay.com/dxp/apps/collaboration/latest/javadocs/com/liferay/item/selector/criteria/URLItemSelectorReturnType.html}{\texttt{URLItemSelectorReturnType}
  class} and
  \href{https://docs.liferay.com/dxp/apps/collaboration/latest/javadocs/com/liferay/item/selector/criteria/FileEntryItemSelectorReturnType.html}{\texttt{FileEntryItemSelectorReturnType}
  class} to the list of supported return types (you can use more return
  types if needed). More return types means that the view is more
  reusable. Also note that this example defines its servlet context
  variable at the bottom of the file:

\begin{verbatim}
private static final List<ItemSelectorReturnType>
    _supportedItemSelectorReturnTypes =
    Collections.unmodifiableList(
        ListUtil.fromArray(
            new ItemSelectorReturnType[] {
                new FileEntryItemSelectorReturnType(),
                new URLItemSelectorReturnType()
            }));

 private ServletContext _servletContext;
\end{verbatim}
\end{enumerate}

For a real-world example of a view class, see the
\href{https://github.com/liferay/liferay-portal/blob/7.1.x/modules/apps/site-navigation/site-navigation-item-selector-web/src/main/java/com/liferay/site/navigation/item/selector/web/internal/SiteNavigationMenuItemItemSelectorView.java}{\texttt{SiteNavigationMenuItemItemSelectorView}
class}.

\subsection{Writing Your View Markup}\label{writing-your-view-markup}

Now that you've implemented your selection view's class, you must write
the markup that renders the view. The exact markup you write depends on
your app's needs. It also depends on your personal preferences, as you
can write it with taglibs, AUI components, or even pure HTML and
JavaScript. Therefore, there's no standard or typical view markup, even
for simple applications. Regardless, the markup must do two key things:

\begin{itemize}
\tightlist
\item
  Render the entities for the user to select.
\item
  When an entity is selected, pass the information specified by the Item
  Selector return type via a JavaScript event.
\end{itemize}

For example, the example view class in the previous section passes the
JavaScript event name as a request attribute in the \texttt{renderHTML}
method. You can therefore use this event name in the markup:

\begin{verbatim}
Liferay.fire(
        `<%= {ITEM_SELECTED_EVENT_NAME} %>',

        {
            data:{
                the-data-your-client-needs-according-to-the-return-type
            }
        }
);
\end{verbatim}

For a complete, real-world example, see the
\href{https://github.com/liferay/liferay-portal/blob/7.0.x/modules/apps/web-experience/layout/layout-item-selector-web/src/main/resources/META-INF/resources/layouts.jsp}{\texttt{layouts.jsp}}
view markup for the
\href{https://github.com/liferay/liferay-portal/tree/7.0.x/modules/apps/web-experience/layout/layout-item-selector-web}{\texttt{com.liferay.layout.item.selector.web}}
module. Even though this example is for the previous version of Liferay
DXP, it still applies to 7.0. Here's a walkthrough of this
\texttt{layouts.jsp} file:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  This \texttt{layouts.jsp} file first defines some variables. Note that
  \texttt{LayoutItemSelectorViewDisplayContext} is an optional class
  that contains additional information about the criteria and view:

\begin{verbatim}
<%
LayoutItemSelectorViewDisplayContext layoutItemSelectorViewDisplayContext = 
    (LayoutItemSelectorViewDisplayContext)request.getAttribute(
    BaseLayoutsItemSelectorView.LAYOUT_ITEM_SELECTOR_VIEW_DISPLAY_CONTEXT);

LayoutItemSelectorCriterion layoutItemSelectorCriterion = 
    layoutItemSelectorViewDisplayContext.getLayoutItemSelectorCriterion();

Portlet portlet = PortletLocalServiceUtil.getPortletById(company.getCompanyId(), 
    portletDisplay.getId());
%>
\end{verbatim}
\item
  This snippet imports a CSS file for styling and places it in the
  \texttt{\textless{}head\textgreater{}} of the page:

\begin{verbatim}
<liferay-util:html-top>
        <link href="<%= PortalUtil.getStaticResourceURL(
        request, application.getContextPath() + "/css/main.css", 
        portlet.getTimestamp()) 
        %>" rel="stylesheet" type="text/css" />
</liferay-util:html-top>
\end{verbatim}

  You can learn more about using the \texttt{liferay-util} taglibs in
  the tutorial
  \href{/docs/7-0/tutorials/-/knowledge_base/t/using-the-liferay-util-taglib}{Using
  the Liferay Util Taglib}.
\item
  This snippet creates the UI to display the layout entities. It uses
  the
  \href{https://docs.liferay.com/dxp/portal/7.0-latest/taglibs/modules/apps/web-experience/layout/com.liferay.layout.taglib/liferay-layout/layouts-tree.html}{\texttt{liferay-layout:layouts-tree}
  taglib} along with the \href{https://liferay.github.io/clay/}{Lexicon}
  design language to create
  \href{https://liferay.github.io/clay/content/cards/}{cards}:

\begin{verbatim}
<div class="container-fluid-1280 layouts-selector">
    <div class="card-horizontal main-content-card">
            <div class="card-row card-row-padded">
                    <liferay-layout:layouts-tree
                            checkContentDisplayPage="<%= layoutItemSelectorCriterion.isCheckDisplayPage() %>"
                            draggableTree="<%= false %>"
                            expandFirstNode="<%= true %>"
                            groupId="<%= scopeGroupId %>"
                            portletURL="<%= layoutItemSelectorViewDisplayContext.getEditLayoutURL() %>"
                            privateLayout="<%= layoutItemSelectorViewDisplayContext.isPrivateLayout() %>"
                            rootNodeName="<%= layoutItemSelectorViewDisplayContext.getRootNodeName() %>"
                            saveState="<%= false %>"
                            selectedLayoutIds="<%= layoutItemSelectorViewDisplayContext.getSelectedLayoutIds() %>"
                            selPlid="<%= layoutItemSelectorViewDisplayContext.getSelPlid() %>"
                            treeId="treeContainer"
                    />
            </div>
    </div>
</div>
\end{verbatim}

  This renders the following UI:

  \begin{figure}
  \centering
  \includegraphics{./images/layouts-item-selector-view.png}
  \caption{The Layouts Item Selector view uses Lexicon and Liferay
  Layout taglibs to create the UI.}
  \end{figure}
\item
  This portion of the \texttt{aui:script} returns the path for the page:

\begin{verbatim}
<aui:script use="aui-base">
    var LString = A.Lang.String;

    var getChosenPagePath = function(node) {
            var buffer = [];

            if (A.instanceOf(node, A.TreeNode)) {
                    var labelText = LString.escapeHTML(node.get('labelEl').text());

                    buffer.push(labelText);

                    node.eachParent(
                            function(treeNode) {
                                    var labelEl = treeNode.get('labelEl');

                                    if (labelEl) {
                                            labelText = LString.escapeHTML(labelEl.text());

                                            buffer.unshift(labelText);
                                    }
                            }
                    );
            }

            return buffer.join(' > ');
    };
\end{verbatim}
\item
  The following snippet passes the return type data when the layout
  (entity) is selected. Note the \texttt{url} and \texttt{uuid}
  variables retrieve the URL or UUID for the layout:

\begin{verbatim}
    var setSelectedPage = function(event) {
            var disabled = true;

            var messageText = '<%= UnicodeLanguageUtil.get(request, "there-is-no-selected-page") %>';

            var lastSelectedNode = event.newVal;

            var labelEl = lastSelectedNode.get('labelEl');

            var link = labelEl.one('a');

            var url = link.attr('data-url');
            var uuid = link.attr('data-uuid');

            var data = {};

            if (link && url) {
                    disabled = false;

                    data.layoutpath = getChosenPagePath(lastSelectedNode);
\end{verbatim}
\item
  This checks if the return type information is a URL or a UUID. It then
  sets the value for the JSON object's \texttt{data} attribute
  accordingly. The last line adds the \texttt{CKEditorFuncNum} for the
  editor to the JSON object's \texttt{data} attribute:

\begin{verbatim}
                    <c:choose>
                            <c:when test="<%= Objects.equals(layoutItemSelectorViewDisplayContext.getItemSelectorReturnTypeName(), URLItemSelectorReturnType.class.getName()) %>">
                                    data.value = url;
                            </c:when>
                            <c:when test="<%= Objects.equals(layoutItemSelectorViewDisplayContext.getItemSelectorReturnTypeName(), UUIDItemSelectorReturnType.class.getName()) %>">
                                    data.value = uuid;
                            </c:when>
                    </c:choose>
            }

            <c:if test="<%= Validator.isNotNull(layoutItemSelectorViewDisplayContext.getCkEditorFuncNum()) %>">
                    data.ckeditorfuncnum: <%= layoutItemSelectorViewDisplayContext.getCkEditorFuncNum() %>;
            </c:if>
\end{verbatim}

  The \texttt{data-url} and \texttt{data-uuid} attributes are in the
  HTML markup for the Layouts Item Selector. The HTML markup for an
  instance of the Layouts Item Selector is shown here:

  \begin{figure}
  \centering
  \includegraphics{./images/layouts-item-selector-html.png}
  \caption{The URL and UUID can be seen in the \texttt{data-url} and
  \texttt{data-uuid} attributes of the Layout Item Selector's HTML
  markup.}
  \end{figure}
\item
  The JavaScript trigger event specified in the Item Selector return
  type is fired, passing the data JSON object with the required return
  type information:

\begin{verbatim}
            Liferay.Util.getOpener().Liferay.fire(
                    '<%= layoutItemSelectorViewDisplayContext.getItemSelectedEventName() %>',
                    {
                            data: data
                    }
            );
    };
\end{verbatim}
\item
  Finally, the layout is set to the selected page:

\begin{verbatim}
    var container = A.one('#<portlet:namespace />treeContainerOutput');

    if (container) {
            container.swallowEvent('click', true);

            var tree = container.getData('tree-view');

            tree.after('lastSelectedChange', setSelectedPage);
    }
</aui:script>
\end{verbatim}
\end{enumerate}

Your new selection view is automatically rendered by the Item Selector
in every portlet that uses the criterion and return types you defined,
without modifying anything in those portlets.

Great! Now you know how to create custom views for the Item Selector.

\subsection{Related Topics}\label{related-topics-289}

\href{/docs/7-1/tutorials/-/knowledge_base/t/understanding-the-item-selector-apis-components}{Understanding
the Item Selector API's Components}

\href{/docs/7-1/tutorials/-/knowledge_base/t/selecting-entities-using-the-item-selector}{Selecting
Entities Using the Item Selector}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-custom-item-selector-entities}{Creating
Custom Item Selector Entities}

\chapter{Documents and Media API}\label{documents-and-media-api}

Liferay DXP's Documents and Media library stores uploaded files so users
can use, manage, and share them. For example, users can embed files in
content, organize them in folders, edit and collaborate on them with
other users, and more. See the
\href{/docs/7-1/user/-/knowledge_base/u/managing-documents-and-media}{user
guide} for more information on the Documents and Media library's
features.

A powerful API underlies the Documents and Media library's
functionality. You can leverage this API in your own apps. For example,
you could create an app that lets users upload files to the Documents
and Media library. Your app could even let users update, delete, and
copy files.

The tutorials in this section show you how to use the Documents and
Media library's API. Note that this is a large API and it may seem
daunting at first. To keep backwards compatibility, the API has
different entry points and multiple methods or classes with similar
functionality. Fortunately, you don't need to learn all of them. These
tutorials therefore focus on the API's most useful classes and methods.

Also note that the Documents and Media app is itself a consumer of this
API---Liferay's developers used the API to implement the app's
functionality. Therefore, these tutorials use code from this app as an
example of how to use the API.

\section{Getting Started with the Documents and Media
API}\label{getting-started-with-the-documents-and-media-api}

Before you start using the Documents and Media API, you must learn these
things:

\begin{itemize}
\tightlist
\item
  \hyperref[key-interfaces]{\textbf{Key Interfaces:}} The interfaces
  you'll use most while using the API.
\item
  \hyperref[getting-a-service-reference]{\textbf{Getting a Service
  Reference:}} How to get a service reference that lets you call the
  API's services.
\item
  \hyperref[specifying-repositories]{\textbf{Specifying Repositories:}}
  How to specify which Documents and Media repository you want.
\item
  \hyperref[specifying-folders]{\textbf{Specifying Folders:}} How to
  specify which folder you want.
\end{itemize}

\subsection{Key Interfaces}\label{key-interfaces}

The Documents and Media API contains several key interfaces:

\begin{itemize}
\item
  \textbf{Documents and Media Services:} These interfaces expose all the
  available Documents and Media functionality:

  \begin{itemize}
  \tightlist
  \item
    \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppLocalService.html}{\texttt{DLAppLocalService}}:
    The local service.
  \item
    \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppService.html}{\texttt{DLAppService}}:
    The remote service. This service wraps the local service methods in
    permission checks.
  \end{itemize}

  Note that Liferay used
  \href{/docs/7-1/tutorials/-/knowledge_base/t/service-builder}{Service
  Builder} to create these services. Because the remote service contains
  permission checks, it's a
  \href{/docs/7-1/tutorials/-/knowledge_base/t/creating-remote-services\#using-service-builder-to-generate-remote-services}{best
  practice} to call it instead of the local service. See the section
  below for instructions on getting a service reference.
\item
  \textbf{Entity Interfaces:} These interfaces represent entities in the
  Documents and Media library. Here are the primary ones you'll use:

  \begin{itemize}
  \tightlist
  \item
    \texttt{FileEntry}: Represents a file.
  \item
    \texttt{Folder}: Represents a folder.
  \item
    \texttt{FileShortcut}: Represents a shortcut to a file.
  \end{itemize}
\end{itemize}

\subsection{Getting a Service
Reference}\label{getting-a-service-reference}

Before you can do anything with the Documents and Media API, you must
get a service reference. If you're using OSGi modules, use the
\texttt{@Reference} annotation to
\href{/docs/7-1/tutorials/-/knowledge_base/t/osgi-services-and-dependency-injection-with-declarative-services}{get
a service reference in an OSGi component via Declarative Services}. For
example, this code gets a reference to \texttt{DLAppService}:

\begin{verbatim}
@Reference
private DLAppService _dlAppService;
\end{verbatim}

If you're using a standard web module (WAR file), use a
\href{/docs/7-1/tutorials/-/knowledge_base/t/service-trackers}{Service
Tracker} to get a reference to the service instead.

Getting the reference this way ensures that you leverage OSGi's
\href{/docs/7-1/tutorials/-/knowledge_base/t/leveraging-dependencies}{dependency
management} features. If you must use the Documents and Media services
outside of an OSGi component (e.g., in a JSP), then you can use the
services' static \texttt{*Util} classes:

\begin{itemize}
\tightlist
\item
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppServiceUtil.html}{\texttt{DLAppServiceUtil}}
\item
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppLocalServiceUtil.html}{\texttt{DLAppLocalServiceUtil}}
\end{itemize}

\subsection{Specifying Repositories}\label{specifying-repositories}

Many methods in the Documents and Media API contain a
\texttt{repositoryId} parameter that identifies the Documents and Media
repository where the operation is performed. A Site (group) can have
multiple repositories, but only one can be accessed via the portal UI.
This is called the Site (group) repository, which is effectively a
Site's default repository. To access this repository via the API,
provide the group ID as the \texttt{repositoryId}.

You can also get the \texttt{repositoryId} via file
(\texttt{FileEntry}), folder (\texttt{Folder}), and file shortcut
(\texttt{FileShortcut}) entities. Each of these entities has a
\texttt{getRepositoryId} method that gets the ID of its repository. For
example, this code gets the repository ID of the \texttt{FileEntry}
object \texttt{fileEntry}:

\begin{verbatim}
long repositoryId = fileEntry.getRepositoryId();
\end{verbatim}

There may also be cases that require a \texttt{Repository} object. You
can get one by creating a \texttt{RepositoryProvider} reference and
passing the repository ID to its \texttt{getRepository} method:

\begin{verbatim}
@Reference
private RepositoryProvider repositoryProvider;

Repository repository = repositoryProvider.getRepository(repositoryId);
\end{verbatim}

Even if you only have an entity ID (e.g., a file ID or folder ID), you
can still use \texttt{RepositoryProvider} to get a \texttt{Repository}
object. To do so, call the \texttt{RepositoryProvider} method for the
entity type with the entity ID as its argument. For example, this code
gets a folder's \texttt{Repository} by calling the
\texttt{RepositoryProvider} method \texttt{getFolderRepository} with the
folder's ID:

\begin{verbatim}
Repository repository = repositoryProvider.getFolderRepository(folderId);
\end{verbatim}

See the
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/repository/RepositoryProvider.html}{\texttt{RepositoryProvider}
Javadoc} for a list of the methods for other entity types.

Note that there are ways to create repositories programmatically,
including repositories private to specific apps. For simplicity,
however, the tutorials here access the default site repository.

\subsection{Specifying Folders}\label{specifying-folders}

Many API methods require the ID of a folder that they perform operations
in or on. For example, such methods may contain parameters like
\texttt{folderId} or \texttt{parentFolderId}. Also note that you can use
the constant \texttt{DLFolderConstants.DEFAULT\_PARENT\_FOLDER\_ID} to
specify the root folder of your current repository.

\subsection{Related Topics}\label{related-topics-290}

\href{/docs/7-1/tutorials/-/knowledge_base/t/service-builder}{Service
Builder}

\href{/docs/7-1/tutorials/-/knowledge_base/t/osgi-services-and-dependency-injection-with-declarative-services}{OSGi
Services and Dependency Injection with Declarative Services}

\href{/docs/7-1/tutorials/-/knowledge_base/t/leveraging-dependencies}{Leveraging
Dependencies}

\href{/docs/7-1/tutorials/-/knowledge_base/t/service-trackers}{Service
Trackers}

\chapter{Creating Files, Folders, and
Shortcuts}\label{creating-files-folders-and-shortcuts}

The primary use case for the API is to create files, folders, and file
shortcuts in the Documents and Media library.

If you've used other Liferay APIs, the Docs \& Media API follows the
same conventions. In general, methods that do similar things tend to
have similar names. When you must create an entity (whatever it is),
look for methods that follow the pattern \texttt{add{[}ModelName{]}},
where \texttt{{[}ModelName{]}} is the name of the entity's data model
object. As the
\href{/docs/7-1/tutorials/-/knowledge_base/t/getting-started-with-the-documents-and-media-api}{getting
started tutorial} explains, you'll use
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppService.html}{\texttt{DLAppService}}
to access the API. This service object contains the following methods
for adding entities:

\begin{itemize}
\tightlist
\item
  \texttt{addFileEntry}: Adds a file.
\item
  \texttt{addFolder}: Adds a folder.
\item
  \texttt{addFileShortcut}: Adds a shortcut to a file.
\end{itemize}

The tutorials that follow show you how to use these methods.

\section{Creating Files}\label{creating-files}

To create files (\texttt{FileEntry} entities) in the Documents and Media
library, you must use the
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppService.html}{\texttt{DLAppService}}
interface's \texttt{addFileEntry} methods. There are three such methods,
and they differ by the data type used to create the file. Click each
method to see a full description of the method and its parameters:

\begin{itemize}
\item
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppService.html\#addFileEntry-long-long-java.lang.String-java.lang.String-java.lang.String-java.lang.String-java.lang.String-byte:A-com.liferay.portal.kernel.service.ServiceContext-}{\texttt{addFileEntry(...,\ byte{[}{]}\ bytes,\ ...)}}
\item
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppService.html\#addFileEntry-long-long-java.lang.String-java.lang.String-java.lang.String-java.lang.String-java.lang.String-java.io.File-com.liferay.portal.kernel.service.ServiceContext-}{\texttt{addFileEntry(...,\ File\ file,\ ...)}}
\item
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppService.html\#addFileEntry-long-long-java.lang.String-java.lang.String-java.lang.String-java.lang.String-java.lang.String-java.io.InputStream-long-com.liferay.portal.kernel.service.ServiceContext-}{\texttt{addFileEntry(...,\ InputStream\ is,\ long\ size,\ ...)}}
\end{itemize}

Note that the following arguments are optional:

\begin{itemize}
\tightlist
\item
  \texttt{sourceFileName}: This keeps track of the uploaded file. It
  infers the content type if that file has an extension.
\item
  \texttt{mimeType}: Defaults to a binary stream. If omitted, Documents
  and Media tries to infer the type from the file extension.
\item
  \texttt{description}: The file's description to display in the portal.
\item
  \texttt{changeLog}: Descriptions for file versions.
\item
  \texttt{is} and \texttt{size}: In the method that takes an
  \texttt{InputStream}, you can use \texttt{null} for the \texttt{is}
  parameter. If you do this, however, you must use \texttt{0} for the
  \texttt{size} parameter.
\end{itemize}

Follow these steps to create a file via the \texttt{DLAppService} method
\texttt{addFileEntry}. Note that these steps use the method that
contains \texttt{InputStream}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Get a reference to \texttt{DLAppService}:

\begin{verbatim}
@Reference
private DLAppService _dlAppService;
\end{verbatim}

  For more information on this, see the section on
  \href{/docs/7-1/tutorials/-/knowledge_base/t/getting-started-with-the-documents-and-media-api\#getting-a-service-reference}{getting
  a service reference} in the getting started tutorial.
\item
  Get the data needed to populate the \texttt{addFileEntry} method's
  arguments. Since it's common to create a file with data submitted by
  the end user, you can extract the data from the request. This example
  does so via
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/upload/UploadPortletRequest.html}{\texttt{UploadPortletRequest}}
  and
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/util/ParamUtil.html}{\texttt{ParamUtil}},
  but you can get the data any way you wish:

\begin{verbatim}
long repositoryId = ParamUtil.getLong(uploadPortletRequest, "repositoryId");
long folderId = ParamUtil.getLong(uploadPortletRequest, "folderId");
String sourceFileName = uploadPortletRequest.getFileName("file");
String title = ParamUtil.getString(uploadPortletRequest, "title");
String description = ParamUtil.getString(uploadPortletRequest, "description");
String changeLog = ParamUtil.getString(uploadPortletRequest, "changeLog");
boolean majorVersion = ParamUtil.getBoolean(uploadPortletRequest, "majorVersion");

try (InputStream inputStream = uploadPortletRequest.getFileAsStream("file")) {

    String contentType = uploadPortletRequest.getContentType("file");
    long size = uploadPortletRequest.getSize("file");

    ServiceContext serviceContext = ServiceContextFactory.getInstance(
            DLFileEntry.class.getName(), uploadPortletRequest);
}
\end{verbatim}

  For more information on getting repository and folder IDs, see the
  \href{/docs/7-1/tutorials/-/knowledge_base/t/getting-started-with-the-documents-and-media-api}{getting
  started tutorial's} sections on specifying repositories and folders.
  For more information on \texttt{ServiceContext}, see the tutorial
  \href{/docs/7-1/tutorials/-/knowledge_base/t/understanding-servicecontext}{Understanding
  ServiceContext}.
\item
  Call the service reference's \texttt{addFileEntry} method with the
  data from the previous step. Note that this example does so inside the
  previous step's try-with-resources statement:

\begin{verbatim}
try (InputStream inputStream = uploadPortletRequest.getFileAsStream("file")) {

    ...

    FileEntry fileEntry = _dlAppService.addFileEntry(
                        repositoryId, folderId, sourceFileName, contentType, title, 
                        description, changeLog, inputStream, size, serviceContext);
}
\end{verbatim}

  The method returns a \texttt{FileEntry} object, which this example
  sets to a variable for later use. Note, however, that you don't have
  to do this.
\end{enumerate}

You can find the full code for this example in the
\texttt{updateFileEntry} method of Liferay DXP's
\href{https://github.com/liferay/liferay-portal/blob/master/modules/apps/document-library/document-library-web/src/main/java/com/liferay/document/library/web/internal/portlet/action/EditFileEntryMVCActionCommand.java}{\texttt{EditFileEntryMVCActionCommand}}
class. This class uses the Documents and Media API to implement almost
all the \texttt{FileEntry} actions that the Documents and Media app
supports. Also note that this \texttt{updateFileEntry} method, as well
as the rest of \texttt{EditFileEntryMVCActionCommand}, contains
additional logic to suit the specific needs of the Documents and Media
app.

\subsection{Related Topics}\label{related-topics-291}

\href{/docs/7-1/tutorials/-/knowledge_base/t/updating-files}{Updating
Files}

\href{/docs/7-1/tutorials/-/knowledge_base/t/deleting-files}{Deleting
Files}

\href{/docs/7-1/tutorials/-/knowledge_base/t/moving-folders-and-files}{Moving
Folders and Files}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-folders}{Creating
Folders}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-file-shortcuts}{Creating
File Shortcuts}

\section{Creating Folders}\label{creating-folders}

To create folders (\texttt{Folder} entities) in the Documents and Media
library, you must use the
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppService.html}{\texttt{DLAppService}}
interface's \texttt{addFolder} method:

\begin{verbatim}
addFolder(long repositoryId, 
        long parentFolderId, 
        String name, 
        String description, 
        ServiceContext serviceContext)
\end{verbatim}

See
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppService.html\#addFolder-long-long-java.lang.String-java.lang.String-com.liferay.portal.kernel.service.ServiceContext-}{this
method's Javadoc} for a description of the parameters. Note that the
\texttt{description} parameter is optional.

Follow these steps to create a folder with the \texttt{DLAppService}
method \texttt{addFolder}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Get a reference to \texttt{DLAppService}:

\begin{verbatim}
@Reference
private DLAppService _dlAppService;
\end{verbatim}

  For more information on this, see the section on
  \href{/docs/7-1/tutorials/-/knowledge_base/t/getting-started-with-the-documents-and-media-api\#getting-a-service-reference}{getting
  a service reference} in the getting started tutorial.
\item
  Get the data needed to populate the \texttt{addFolder} method's
  arguments. Since it's common to create a folder with data submitted by
  the end user, you can extract the data from the request. This example
  does so via \texttt{javax.portlet.ActionRequest} and
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/util/ParamUtil.html}{\texttt{ParamUtil}}:

\begin{verbatim}
long repositoryId = ParamUtil.getLong(actionRequest, "repositoryId");
long parentFolderId = ParamUtil.getLong(actionRequest, "parentFolderId");
String name = ParamUtil.getString(actionRequest, "name");
String description = ParamUtil.getString(actionRequest, "description");

ServiceContext serviceContext = ServiceContextFactory.getInstance(
            DLFolder.class.getName(), actionRequest);
\end{verbatim}

  For more information on getting repository and folder IDs, see the
  \href{/docs/7-1/tutorials/-/knowledge_base/t/getting-started-with-the-documents-and-media-api}{getting
  started tutorial's} sections on specifying repositories and folders.
  For more information on \texttt{ServiceContext}, see the tutorial
  \href{/docs/7-1/tutorials/-/knowledge_base/t/understanding-servicecontext}{Understanding
  ServiceContext}.
\item
  Call the service reference's \texttt{addFolder} method with the data
  from the previous step:

\begin{verbatim}
Folder folder = _dlAppService.addFolder(
                        repositoryId, parentFolderId, name, description, 
                        serviceContext);
\end{verbatim}

  The method returns a \texttt{Folder} object, which this example sets
  to a variable for later use. Note, however, that you don't have to do
  this.
\end{enumerate}

You can find the full code for this example in the \texttt{updateFolder}
method of Liferay DXP's
\href{https://github.com/liferay/liferay-portal/blob/master/modules/apps/document-library/document-library-web/src/main/java/com/liferay/document/library/web/internal/portlet/action/EditFolderMVCActionCommand.java}{\texttt{EditFolderMVCActionCommand}}
class. This class uses the Documents and Media API to implement almost
all the \texttt{Folder} actions that the Documents and Media app
supports. Also note that this \texttt{updateFolder} method, as well as
the rest of \texttt{EditFolderMVCActionCommand}, contains additional
logic to suit the specific needs of the Documents and Media app.

\subsection{Folders and External
Repositories}\label{folders-and-external-repositories}

By creating a folder that acts as a proxy for an external repository
(e.g., SharePoint), you can effectively mount that repository inside a
Site's default repository. When users enter this special folder, they
see the external repository. These folders are called \emph{mount
points}. You can create one via the API by setting the
\href{/docs/7-1/tutorials/-/knowledge_base/t/understanding-servicecontext}{Service
Context's} \texttt{mountPoint} attribute to \texttt{true}, and then
using that Service Context in the \texttt{addFolder} method:

\begin{verbatim}
serviceContext.setAttribute("mountPoint", true);
\end{verbatim}

Note that the \texttt{repositoryId} of such a folder indicates the
external repository the folder points to---not the repository the folder
exists. Also, mount point folders can only exist in the default Site
repository.

\subsection{Related Topics}\label{related-topics-292}

\href{/docs/7-1/tutorials/-/knowledge_base/t/updating-folders}{Updating
Folders}

\href{/docs/7-1/tutorials/-/knowledge_base/t/deleting-folders}{Deleting
Folders}

\href{/docs/7-1/tutorials/-/knowledge_base/t/copying-folders}{Copying
Folders}

\href{/docs/7-1/tutorials/-/knowledge_base/t/moving-folders-and-files}{Moving
Folders and Files}

\section{Creating File Shortcuts}\label{creating-file-shortcuts}

To create file shortcuts (\texttt{FileShortcut} entities) in the
Documents and Media library, you must use the
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppService.html}{\texttt{DLAppService}}
interface's \texttt{addFileShortcut} method:

\begin{verbatim}
addFileShortcut(long repositoryId, 
                long folderId, 
                long toFileEntryId, 
                ServiceContext serviceContext)
\end{verbatim}

See
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppService.html\#addFileShortcut-long-long-long-com.liferay.portal.kernel.service.ServiceContext-}{this
method's Javadoc} for a description of the parameters. Note that all
this method's parameters are mandatory.

Keep these things in mind when creating shortcuts:

\begin{itemize}
\tightlist
\item
  You can create a shortcut to a file in a different Site, if that file
  and its resulting shortcut are in the same portal instance.
\item
  You can't create folder shortcuts.
\item
  Shortcuts can only exist in the default Site repository. If you try to
  invoke \texttt{addFileShortcut} with an external repository's ID
  (e.g., a SharePoint repository), the operation fails. Because not all
  repositories have the same features, the Documents and Media API only
  supports the common denominators for all repositories: files and
  folders.
\end{itemize}

Follow these steps to create a file shortcut with the
\texttt{DLAppService} method \texttt{addFileShortcut}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Get a reference to \texttt{DLAppService}:

\begin{verbatim}
@Reference
private DLAppService _dlAppService;
\end{verbatim}

  For more information on this, see the section on
  \href{/docs/7-1/tutorials/-/knowledge_base/t/getting-started-with-the-documents-and-media-api\#getting-a-service-reference}{getting
  a service reference} in the getting started tutorial.
\item
  Get the data needed to populate the \texttt{addFileShortcut} method's
  arguments. Since it's common to create a file shortcut with data
  submitted by the end user, you can extract the data from the request.
  This example does so via \texttt{javax.portlet.ActionRequest} and
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/util/ParamUtil.html}{\texttt{ParamUtil}},
  but you can get the data any way you wish:

\begin{verbatim}
long repositoryId = ParamUtil.getLong(actionRequest, "repositoryId");
long folderId = ParamUtil.getLong(actionRequest, "folderId");
long toFileEntryId = ParamUtil.getLong(actionRequest, "toFileEntryId");

ServiceContext serviceContext = ServiceContextFactory.getInstance(
                    DLFileShortcutConstants.getClassName(), actionRequest);
\end{verbatim}

  For more information on getting repository and folder IDs, see the
  \href{/docs/7-1/tutorials/-/knowledge_base/t/getting-started-with-the-documents-and-media-api}{getting
  started tutorial's} sections on specifying repositories and folders.
  For more information on \texttt{ServiceContext}, see the tutorial
  \href{/docs/7-1/tutorials/-/knowledge_base/t/understanding-servicecontext}{Understanding
  ServiceContext}.
\item
  Call the service reference's \texttt{addFileShortcut} method with the
  data from the previous step:

\begin{verbatim}
FileShortcut fileShortcut = _dlAppService.addFileShortcut(
                                    repositoryId, folderId, toFileEntryId, 
                                    serviceContext);
\end{verbatim}

  The method returns a \texttt{FileShortcut} object, which this example
  sets to a variable for later use. Note, however, that you don't have
  to do this.
\end{enumerate}

You can find the full code for this example in the
\texttt{updateFileShortcut} method of Liferay DXP's
\href{https://github.com/liferay/liferay-portal/blob/master/modules/apps/document-library/document-library-web/src/main/java/com/liferay/document/library/web/internal/portlet/action/EditFileShortcutMVCActionCommand.java}{\texttt{EditFileShortcutMVCActionCommand}}
class. This class uses the Documents and Media API to implement almost
all the \texttt{FileShortcut} actions that the Documents and Media app
supports. Also note that this \texttt{updateFileShortcut} method, as
well as the rest of \texttt{EditFileShortcutMVCActionCommand}, contains
additional logic to suit the specific needs of the Documents and Media
app.

\subsection{Related Topics}\label{related-topics-293}

\href{/docs/7-1/tutorials/-/knowledge_base/t/deleting-file-shortcuts}{Deleting
File Shortcuts}

\href{/docs/7-1/tutorials/-/knowledge_base/t/updating-file-shortcuts}{Updating
File Shortcuts}

\chapter{Deleting Entities}\label{deleting-entities}

Now that you know how to
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-files-folders-and-shortcuts}{create
Documents and Media entities}, you should learn how to delete them. Note
that the exact meaning of \emph{delete} depends on the portal
configuration and the delete operation you choose. This is because the
\href{/docs/7-1/user/-/knowledge_base/u/restoring-deleted-assets}{Recycle
Bin}, which is enabled by default, can be used to recover deleted items.
Deletions via
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppService.html}{\texttt{DLAppService}},
however, are permanent. To send items to the Recycle Bin, you must use
the Capabilities API.

This section of tutorials shows you how to use \texttt{DLAppService} to
delete entities from the Documents and Media library. The last tutorial
in this section shows you how to move entities to the Recycle Bin via
the Capabilities API.

\section{Deleting Files}\label{deleting-files}

There are two methods you can use to delete files:

\begin{itemize}
\item
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppService.html\#deleteFileEntry-long-}{\texttt{deleteFileEntry(long\ fileEntryId)}}
\item
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppService.html\#deleteFileEntryByTitle-long-long-java.lang.String-}{\texttt{deleteFileEntryByTitle(long\ repositoryId,\ long\ folderId,\ String\ title)}}
\end{itemize}

These methods differ only in how they identify a file for deletion. The
combination of the \texttt{folderId} and \texttt{title} parameters in
\texttt{deleteFileEntryByTitle} uniquely identify a file because it's
impossible for two files in the same folder to share a name.

Follow these steps to delete a file:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Get a reference to \texttt{DLAppService}:

\begin{verbatim}
@Reference
private DLAppService _dlAppService;
\end{verbatim}

  For more information on this, see the section on
  \href{/docs/7-1/tutorials/-/knowledge_base/t/getting-started-with-the-documents-and-media-api\#getting-a-service-reference}{getting
  a service reference} in the getting started tutorial.
\item
  Get the data needed to populate the arguments of the
  \texttt{deleteFileEntry*} method you wish to use. Since it's common to
  delete a file specified by the end user, you can extract the data you
  need from the request. This example does so via
  \texttt{javax.portlet.ActionRequest} and
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/util/ParamUtil.html}{\texttt{ParamUtil}},
  but you can get the data any way you wish. Also note that this example
  gets only the file entry ID because it uses \texttt{deleteFileEntry}:

\begin{verbatim}
long fileEntryId = ParamUtil.getLong(actionRequest, "fileEntryId");
\end{verbatim}

  If you want to use \texttt{deleteFileEntryByTitle} instead, you can
  also get the repository ID, folder ID, and title from the request. For
  more information on getting repository and folder IDs, see the
  \href{/docs/7-1/tutorials/-/knowledge_base/t/getting-started-with-the-documents-and-media-api}{getting
  started tutorial's} sections on specifying repositories and folders.
\item
  Call the service reference's \texttt{deleteFileEntry*} method you wish
  to use with the data from the previous step. This example calls
  \texttt{deleteFileEntry} with the file entry's ID:

\begin{verbatim}
_dlAppService.deleteFileEntry(fileEntryId);
\end{verbatim}
\end{enumerate}

You can find the full code for this example in the
\texttt{deleteFileEntry} method of Liferay DXP's
\href{https://github.com/liferay/liferay-portal/blob/master/modules/apps/document-library/document-library-web/src/main/java/com/liferay/document/library/web/internal/portlet/action/EditFileEntryMVCActionCommand.java}{\texttt{EditFileEntryMVCActionCommand}}
class. This class uses the Documents and Media API to implement almost
all the \texttt{FileEntry} actions that the Documents and Media app
supports. Also note that this \texttt{deleteFileEntry} method, as well
as the rest of \texttt{EditFileEntryMVCActionCommand}, contains
additional logic to suit the specific needs of the Documents and Media
app.

\subsection{Related Topics}\label{related-topics-294}

\href{/docs/7-1/tutorials/-/knowledge_base/t/moving-entities-to-the-recycle-bin}{Moving
Entities to the Recycle Bin}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-files}{Creating
Files}

\href{/docs/7-1/tutorials/-/knowledge_base/t/updating-files}{Updating
Files}

\href{/docs/7-1/tutorials/-/knowledge_base/t/moving-folders-and-files}{Moving
Folders and Files}

\section{Deleting File Versions}\label{deleting-file-versions}

When a file is modified, Documents and Media creates a new file version
and leaves the previous version intact. Over time, old file versions can
accumulate and consume precious storage space. Fortunately, you can use
the Documents and Media API to delete them. Note, however, that there's
no way to send file versions to the Recycle Bin---once you delete them,
they're gone forever.

You can delete file versions with the
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppService.html}{\texttt{DLAppService}}
method \texttt{deleteFileVersion}:

\begin{verbatim}
deleteFileVersion(long fileEntryId, String version)
\end{verbatim}

See
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppService.html\#deleteFileVersion-long-java.lang.String-}{this
method's Javadoc} for a description of the parameters.

Follow these steps to use \texttt{deleteFileVersion} to delete a file
version:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Get a reference to \texttt{DLAppService}:

\begin{verbatim}
@Reference
private DLAppService _dlAppService;
\end{verbatim}

  For more information on this, see the section on
  \href{/docs/7-1/tutorials/-/knowledge_base/t/getting-started-with-the-documents-and-media-api\#getting-a-service-reference}{getting
  a service reference} in the getting started tutorial.
\item
  Get the file entry ID and version for the file you want to delete.
  Since it's common to delete a file version specified by the end user,
  you can extract these parameters from the request. This example does
  so via \texttt{javax.portlet.ActionRequest} and
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/util/ParamUtil.html}{\texttt{ParamUtil}},
  but you can do this any way you wish:

\begin{verbatim}
long fileEntryId = ParamUtil.getLong(actionRequest, "fileEntryId");
String version = ParamUtil.getString(actionRequest, "version");
\end{verbatim}
\item
  Use the service reference to call the \texttt{deleteFileVersion}
  method with the file entry ID and version from the previous step:

\begin{verbatim}
_dlAppService.deleteFileVersion(fileEntryId, version);
\end{verbatim}
\end{enumerate}

You can find the full code for this example in the
\texttt{deleteFileEntry} method of Liferay DXP's
\href{https://github.com/liferay/liferay-portal/blob/master/modules/apps/document-library/document-library-web/src/main/java/com/liferay/document/library/web/internal/portlet/action/EditFileEntryMVCActionCommand.java}{\texttt{EditFileEntryMVCActionCommand}}
class. This class uses the Documents and Media API to implement almost
all the \texttt{FileEntry} actions that the Documents and Media app
supports. Also note that this \texttt{deleteFileEntry} method, as well
as the rest of \texttt{EditFileEntryMVCActionCommand}, contains
additional logic to suit the specific needs of the Documents and Media
app.

\subsection{Identifying File Versions}\label{identifying-file-versions}

Since there may be many versions of a file, it's useful to identify
programmatically old versions for deletion. You can do this with
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/util/comparator/FileVersionVersionComparator.html}{\texttt{FileVersionVersionComparator}}.

The following example creates such a comparator and uses its
\texttt{compare} method to identify old versions of a file. The code
does so by iterating through each
\href{/docs/7-1/user/-/knowledge_base/u/workflow}{approved} version of
the file (\texttt{fileVersion}). Each iteration uses the
\texttt{compare} method to test that file version
(\texttt{fileVersion.getVersion()}) against the same file's current
version (\texttt{fileEntry.getVersion()}). If this comparison is greater
than \texttt{0}, then the iteration's file version
(\texttt{fileVersion}) is old and is deleted by
\texttt{deleteFileVersion}:

\begin{verbatim}
FileVersionVersionComparator comparator = new FileVersionVersionComparator();

for (FileVersion fileVersion: fileEntry.getVersions(WorkflowConstants.STATUS_APPROVED)) {

    if (comparator.compare(fileEntry.getVersion(), fileVersion.getVersion()) > 0) {

        dlAppService.deleteFileVersion(fileVersion.getFileEntryId(), fileVersion.getVersion());
    }
}
\end{verbatim}

\subsection{Related Topics}\label{related-topics-295}

\href{/docs/7-1/tutorials/-/knowledge_base/t/deleting-files}{Deleting
Files}

\href{/docs/7-1/tutorials/-/knowledge_base/t/deleting-file-shortcuts}{Deleting
File Shortcuts}

\href{/docs/7-1/tutorials/-/knowledge_base/t/deleting-folders}{Deleting
Folders}

\href{/docs/7-1/tutorials/-/knowledge_base/t/moving-entities-to-the-recycle-bin}{Moving
Entities to the Recycle Bin}

\section{Deleting File Shortcuts}\label{deleting-file-shortcuts}

The Documents and Media API also lets you delete file shortcuts. To do
so, use the
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppService.html}{\texttt{DLAppService}}
method
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppService.html\#deleteFileShortcut-long-}{\texttt{deleteFileShortcut}}
with the ID of the shortcut you want to delete:

\begin{verbatim}
deleteFileShortcut(long fileShortcutId)
\end{verbatim}

Follow these steps to use this method to delete a file shortcut:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Get a reference to \texttt{DLAppService}:

\begin{verbatim}
@Reference
private DLAppService _dlAppService;
\end{verbatim}

  For more information on this, see the section on
  \href{/docs/7-1/tutorials/-/knowledge_base/t/getting-started-with-the-documents-and-media-api\#getting-a-service-reference}{getting
  a service reference} in the getting started tutorial.
\item
  Get the file shortcut's ID. Since it's common to delete a file
  shortcut specified by the end user, you can extract its ID from the
  request. This example does so via \texttt{javax.portlet.ActionRequest}
  and
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/util/ParamUtil.html}{\texttt{ParamUtil}},
  but you can do this any way you wish:

\begin{verbatim}
long fileShortcutId = ParamUtil.getLong(actionRequest, "fileShortcutId");
\end{verbatim}
\item
  Use the service reference to call the \texttt{deleteFileShortcut}
  method with the file shortcut ID from the previous step:

\begin{verbatim}
_dlAppService.deleteFileShortcut(fileShortcutId);
\end{verbatim}
\end{enumerate}

You can find the full code for this example in the
\texttt{deleteFileShortcut} method of Liferay DXP's
\href{https://github.com/liferay/liferay-portal/blob/master/modules/apps/document-library/document-library-web/src/main/java/com/liferay/document/library/web/internal/portlet/action/EditFileShortcutMVCActionCommand.java}{\texttt{EditFileShortcutMVCActionCommand}}
class. This class uses the Documents and Media API to implement almost
all the \texttt{FileShortcut} actions that the Documents and Media app
supports. Also note that this \texttt{deleteFileShortcut} method, as
well as the rest of \texttt{EditFileShortcutMVCActionCommand}, contains
additional logic to suit the specific needs of the Documents and Media
app.

\subsection{Related Topics}\label{related-topics-296}

\href{/docs/7-1/tutorials/-/knowledge_base/t/moving-entities-to-the-recycle-bin}{Moving
Entities to the Recycle Bin}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-file-shortcuts}{Creating
File Shortcuts}

\href{/docs/7-1/tutorials/-/knowledge_base/t/updating-file-shortcuts}{Updating
File Shortcuts}

\section{Deleting Folders}\label{deleting-folders}

Deleting folders is similar to
\href{/docs/7-1/tutorials/-/knowledge_base/t/deleting-files}{deleting
files}. There are two methods you can use to delete a folder. Click each
method to see its Javadoc:

\begin{itemize}
\item
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppService.html\#deleteFolder-long-}{\texttt{deleteFolder(long\ folderId)}}
\item
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppService.html\#deleteFolder-long-long-java.lang.String-}{\texttt{deleteFolder(long\ repositoryId,\ long\ parentFolderId,\ String\ name)}}
\end{itemize}

Which method you use is up to you---they both delete a folder. Follow
these steps to use one of these methods to delete a folder:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Get a reference to \texttt{DLAppService}:

\begin{verbatim}
@Reference
private DLAppService _dlAppService;
\end{verbatim}

  For more information on this, see the section on
  \href{/docs/7-1/tutorials/-/knowledge_base/t/getting-started-with-the-documents-and-media-api\#getting-a-service-reference}{getting
  a service reference} in the getting started tutorial.
\item
  Get the data needed to populate the arguments of the
  \texttt{deleteFolder*} method you wish to use. Since it's common to
  delete a folder specified by the end user, you can extract the data
  you need from the request. This example does so via
  \texttt{javax.portlet.ActionRequest} and
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/util/ParamUtil.html}{\texttt{ParamUtil}},
  but you can get the data any way you wish. Also note that this example
  gets only the folder ID because the next step deletes the folder with
  \texttt{deleteFolder(folderId)}:

\begin{verbatim}
long folderId = ParamUtil.getLong(actionRequest, "folderId");
\end{verbatim}

  If you want to use the other \texttt{deleteFolder} method, you can
  also get the repository ID, parent folder ID, and folder name from the
  request. For more information on getting repository and folder IDs,
  see the
  \href{/docs/7-1/tutorials/-/knowledge_base/t/getting-started-with-the-documents-and-media-api}{getting
  started tutorial's} sections on specifying repositories and folders.
\item
  Call the service reference's \texttt{deleteFolder*} method you wish to
  use with the data from the previous step. This example calls
  \texttt{deleteFolder} with the folder's ID:

\begin{verbatim}
_dlAppService.deleteFolder(folderId);
\end{verbatim}
\end{enumerate}

You can find the full code for this example in the
\texttt{deleteFolders} method of Liferay DXP's
\href{https://github.com/liferay/liferay-portal/blob/master/modules/apps/document-library/document-library-web/src/main/java/com/liferay/document/library/web/internal/portlet/action/EditFolderMVCActionCommand.java}{\texttt{EditFolderMVCActionCommand}}
class. This class uses the Documents and Media API to implement almost
all the \texttt{Folder} actions that the Documents and Media app
supports. Also note that this \texttt{deleteFolders} method, as well as
the rest of \texttt{EditFolderMVCActionCommand}, contains additional
logic to suit the specific needs of the Documents and Media app.

\subsection{Related Topics}\label{related-topics-297}

\href{/docs/7-1/tutorials/-/knowledge_base/t/moving-entities-to-the-recycle-bin}{Moving
Entities to the Recycle Bin}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-folders}{Creating
Folders}

\href{/docs/7-1/tutorials/-/knowledge_base/t/updating-folders}{Updating
Folders}

\href{/docs/7-1/tutorials/-/knowledge_base/t/copying-folders}{Copying
Folders}

\href{/docs/7-1/tutorials/-/knowledge_base/t/moving-folders-and-files}{Moving
Folders and Files}

\href{/docs/7-1/tutorials/-/knowledge_base/t/deleting-files}{Deleting
Files}

\section{Moving Entities to the Recycle
Bin}\label{moving-entities-to-the-recycle-bin}

Instead of deleting entities, you can move them to the
\href{/docs/7-1/user/-/knowledge_base/u/restoring-deleted-assets}{Recycle
Bin}. Note that the Recycle Bin isn't part of the Documents and Media
API. Although you can use the Recycle Bin API directly, in the case of
Documents and Media it's better to use the Capabilities API. This is
because some third-party repositories (e.g., SharePoint) don't support
Recycle Bin functionality. The Capabilities API lets you verify that the
repository you're working in supports the Recycle Bin. It's therefore a
best practice to always use the Capabilities API when moving entities to
the Recycle Bin.

Follow these steps to use the Capabilities API to move an entity to the
Recycle Bin:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Verify that the repository supports the Recycle Bin. Do this by
  calling the
  \href{/docs/7-1/tutorials/-/knowledge_base/t/getting-started-with-the-documents-and-media-api\#specifying-repositories}{repository
  object's} \texttt{isCapabilityProvided} method with
  \texttt{TrashCapability.class} as its argument. This example does so
  in \texttt{if} statement's condition:

\begin{verbatim}
if (repository.isCapabilityProvided(TrashCapability.class)) {
    // The code to move the entity to the Recycle Bin
    // You'll write this in the next step
}
\end{verbatim}
\item
  Move the entity to the Recycle Bin if the repository supports it. To
  do this, first get a \texttt{TrashCapability} reference by calling the
  repository object's \texttt{getCapability} method with
  \texttt{TrashCapability.class} as its argument. Then call the
  \texttt{TrashCapability} method that moves the entity to the Recycle
  Bin. For example, this code calls \texttt{moveFileEntryToTrash} to
  move a file to the Recycle Bin:

\begin{verbatim}
if (repository.isCapabilityProvided(TrashCapability.class)) {

    TrashCapability trashCapability = repository.getCapability(TrashCapability.class);
    trashCapability.moveFileEntryToTrash(user.getUserId(), fileEntry);
}
\end{verbatim}

  See the
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/repository/capabilities/TrashCapability.html}{\texttt{TrashCapability}
  Javadoc} for information on the methods you can use to move other
  types of entities to the Recycle Bin.
\end{enumerate}

\subsection{Related Topics}\label{related-topics-298}

\href{/docs/7-1/tutorials/-/knowledge_base/t/deleting-files}{Deleting
Files}

\href{/docs/7-1/tutorials/-/knowledge_base/t/deleting-folders}{Deleting
Folders}

\href{/docs/7-1/tutorials/-/knowledge_base/t/deleting-file-shortcuts}{Deleting
File Shortcuts}

\href{/docs/7-1/tutorials/-/knowledge_base/t/moving-folders-and-files}{Moving
Folders and Files}

\chapter{Updating Entities}\label{updating-entities}

Like
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-files-folders-and-shortcuts}{creating}
and
\href{/docs/7-1/tutorials/-/knowledge_base/t/deleting-entities}{deleting}
entities, updating entities is a key task when working with Documents
and Media. The methods in the Documents and Media API for creating and
updating entities are similar. There are, however, a few important
differences. The tutorials in this section show you how to update
entities and highlight these differences.

\section{Updating Files}\label{updating-files}

Updating a file is a bit more complicated than
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-files}{creating
one}. This is due to the way the update operation handles a file's
metadata and content. To update only a file's content, you must also
supply the file's existing metadata. Otherwise, the update operation
could lose the metadata. The opposite, however, isn't true. You can
modify a file's metadata without re-supplying the content. In such an
update, the file's content is automatically copied to the new version of
the file. To make this easier to remember, follow these rules when
updating files:

\begin{itemize}
\tightlist
\item
  Always provide all metadata.
\item
  Only provide the file's content when you want to change it.
\end{itemize}

\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppService.html}{\texttt{DLAppService}}
has three \texttt{updateFileEntry} methods that you can use to update a
file. These methods differ only in the file content's type. Click each
method to see its Javadoc, which contains a full description of its
parameters:

\begin{itemize}
\item
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppService.html\#updateFileEntry-long-java.lang.String-java.lang.String-java.lang.String-java.lang.String-java.lang.String-boolean-byte:A-com.liferay.portal.kernel.service.ServiceContext-}{\texttt{updateFileEntry(...,\ byte{[}{]}\ bytes,\ ...)}}
\item
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppService.html\#updateFileEntry-long-java.lang.String-java.lang.String-java.lang.String-java.lang.String-java.lang.String-boolean-java.io.File-com.liferay.portal.kernel.service.ServiceContext-}{\texttt{updateFileEntry(...,\ File\ file,\ ...)}}
\item
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppService.html\#updateFileEntry-long-java.lang.String-java.lang.String-java.lang.String-java.lang.String-java.lang.String-boolean-java.io.InputStream-long-com.liferay.portal.kernel.service.ServiceContext-}{\texttt{updateFileEntry(...,\ InputStream\ is,\ long\ size,\ ...)}}
\end{itemize}

Keep these things in mind when using these methods:

\begin{itemize}
\item
  To retain the original file's title and description, you must provide
  those parameters to \texttt{updateFileEntry}. Omitting them deletes
  any existing title and description.
\item
  If you supply \texttt{null} in place of the file's content (e.g.,
  \texttt{bytes}, \texttt{file}, or \texttt{is}), the update
  automatically uses the file's existing content. Do this only if you
  want to update the file's metadata.
\item
  If you use \texttt{false} for the \texttt{majorVersion} parameter, the
  update increments the file version by \texttt{0.1} (e.g., from
  \texttt{1.0} to \texttt{1.1}). If you use \texttt{true} for this
  parameter, the update increments the file version to the next
  \texttt{.0} value (e.g., from \texttt{1.0} to \texttt{2.0},
  \texttt{1.1} to \texttt{2.0}, etc.).
\end{itemize}

Follow these steps to update a file. Note that the example in these
steps uses the \texttt{updateFileEntry} method that contains
\texttt{InputStream}, but you can adapt the example to the other methods
if you wish:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Get a reference to \texttt{DLAppService}:

\begin{verbatim}
@Reference
private DLAppService _dlAppService;
\end{verbatim}

  For more information on this, see the section on
  \href{/docs/7-1/tutorials/-/knowledge_base/t/getting-started-with-the-documents-and-media-api\#getting-a-service-reference}{getting
  a service reference} in the getting started tutorial.
\item
  Get the data needed to populate the \texttt{updateFileEntry} method's
  arguments. Since it's common to update a file with data submitted by
  the end user, you can extract the data from the request. This example
  does so via
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/upload/UploadPortletRequest.html}{\texttt{UploadPortletRequest}}
  and
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/util/ParamUtil.html}{\texttt{ParamUtil}},
  but you can get the data any way you wish:

\begin{verbatim}
long repositoryId = ParamUtil.getLong(uploadPortletRequest, "repositoryId");
long folderId = ParamUtil.getLong(uploadPortletRequest, "folderId");
String sourceFileName = uploadPortletRequest.getFileName("file");
String title = ParamUtil.getString(uploadPortletRequest, "title");
String description = ParamUtil.getString(uploadPortletRequest, "description");
String changeLog = ParamUtil.getString(uploadPortletRequest, "changeLog");
boolean majorVersion = ParamUtil.getBoolean(uploadPortletRequest, "majorVersion");

try (InputStream inputStream = uploadPortletRequest.getFileAsStream("file")) {

    String contentType = uploadPortletRequest.getContentType("file");
    long size = uploadPortletRequest.getSize("file");

    ServiceContext serviceContext = ServiceContextFactory.getInstance(
            DLFileEntry.class.getName(), uploadPortletRequest);
}
\end{verbatim}

  For more information on getting repository and folder IDs, see the
  \href{/docs/7-1/tutorials/-/knowledge_base/t/getting-started-with-the-documents-and-media-api}{getting
  started tutorial's} sections on specifying repositories and folders.
  For more information on \texttt{ServiceContext}, see the tutorial
  \href{/docs/7-1/tutorials/-/knowledge_base/t/understanding-servicecontext}{Understanding
  ServiceContext}.
\item
  Call the service reference's \texttt{updateFileEntry} method with the
  data from the previous step. Note that this example does so inside the
  previous step's try-with-resources statement:

\begin{verbatim}
try (InputStream inputStream = uploadPortletRequest.getFileAsStream("file")) {

    ...

    FileEntry fileEntry = _dlAppService.updateFileEntry(
                            fileEntryId, sourceFileName, contentType, title,
                            description, changeLog, majorVersion, inputStream, size,
                            serviceContext);
}
\end{verbatim}

  The method returns a \texttt{FileEntry} object, which this example
  sets to a variable for later use. Note, however, that you don't have
  to do this.
\end{enumerate}

You can find the full code for this example in the
\texttt{updateFileEntry} method of Liferay DXP's
\href{https://github.com/liferay/liferay-portal/blob/master/modules/apps/document-library/document-library-web/src/main/java/com/liferay/document/library/web/internal/portlet/action/EditFileEntryMVCActionCommand.java}{\texttt{EditFileEntryMVCActionCommand}}
class. This class uses the Documents and Media API to implement almost
all the \texttt{FileEntry} actions that the Documents and Media app
supports. Also note that this \texttt{updateFileEntry} method, as well
as the rest of \texttt{EditFileEntryMVCActionCommand}, contains
additional logic to suit the specific needs of the Documents and Media
app.

\subsection{Related Topics}\label{related-topics-299}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-files}{Creating
Files}

\href{/docs/7-1/tutorials/-/knowledge_base/t/deleting-files}{Deleting
Files}

\href{/docs/7-1/tutorials/-/knowledge_base/t/moving-folders-and-files}{Moving
Folders and Files}

\section{Updating Folders}\label{updating-folders}

The Documents and Media API lets you
\href{/docs/7-1/tutorials/-/knowledge_base/t/copying-and-moving-entities}{copy
or move} folders to a different location. Options for in-place folder
updates, however, are limited. You can only update a folder's name and
description. You can do this with the
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppService.html}{\texttt{DLAppService}}
method \texttt{updateFolder}:

\begin{verbatim}
updateFolder(long folderId, String name, String description, ServiceContext serviceContext)
\end{verbatim}

All parameters except the description are mandatory. For a full
description of this method and its parameters, see its
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppService.html\#updateFolder-long-java.lang.String-java.lang.String-com.liferay.portal.kernel.service.ServiceContext-}{Javadoc}.

Follow these steps to use this method to update a folder:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Get a reference to \texttt{DLAppService}:

\begin{verbatim}
@Reference
private DLAppService _dlAppService;
\end{verbatim}

  For more information on this, see the section on
  \href{/docs/7-1/tutorials/-/knowledge_base/t/getting-started-with-the-documents-and-media-api\#getting-a-service-reference}{getting
  a service reference} in the getting started tutorial.
\item
  Get the data needed to populate the \texttt{updateFolder} method's
  arguments. Since it's common to update a folder with data submitted by
  the end user, you can extract the data from the request. This example
  does so via \texttt{javax.portlet.ActionRequest} and
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/util/ParamUtil.html}{\texttt{ParamUtil}},
  but you can get the data any way you wish:

\begin{verbatim}
long folderId = ParamUtil.getLong(actionRequest, "folderId");
String name = ParamUtil.getString(actionRequest, "name");
String description = ParamUtil.getString(actionRequest, "description");

ServiceContext serviceContext = ServiceContextFactory.getInstance(
            DLFolder.class.getName(), actionRequest);
\end{verbatim}

  For more information on getting folder IDs, see the
  \href{/docs/7-1/tutorials/-/knowledge_base/t/getting-started-with-the-documents-and-media-api}{getting
  started tutorial's} section on specifying folders. For more
  information on \texttt{ServiceContext}, see the tutorial
  \href{/docs/7-1/tutorials/-/knowledge_base/t/understanding-servicecontext}{Understanding
  ServiceContext}.
\item
  Call the service reference's \texttt{updateFolder} method with the
  data from the previous step:

\begin{verbatim}
_dlAppService.updateFolder(folderId, name, description, serviceContext);
\end{verbatim}
\end{enumerate}

You can find the full code for this example in the \texttt{updateFolder}
method of Liferay DXP's
\href{https://github.com/liferay/liferay-portal/blob/master/modules/apps/document-library/document-library-web/src/main/java/com/liferay/document/library/web/internal/portlet/action/EditFolderMVCActionCommand.java}{\texttt{EditFolderMVCActionCommand}}
class. This class uses the Documents and Media API to implement almost
all the \texttt{Folder} actions that the Documents and Media app
supports. Also note that this \texttt{updateFolder} method, as well as
the rest of \texttt{EditFolderMVCActionCommand}, contains additional
logic to suit the specific needs of the Documents and Media app.

\subsection{Related Topics}\label{related-topics-300}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-folders}{Creating
Folders}

\href{/docs/7-1/tutorials/-/knowledge_base/t/deleting-folders}{Deleting
Folders}

\href{/docs/7-1/tutorials/-/knowledge_base/t/copying-folders}{Copying
Folders}

\href{/docs/7-1/tutorials/-/knowledge_base/t/moving-folders-and-files}{Moving
Folders and Files}

\section{Updating File Shortcuts}\label{updating-file-shortcuts}

The Documents and Media API lets you update file shortcuts
(\texttt{FileShortcut} entities). You can update a shortcut to change
the file it points to or the folder it resides in. You can do this via
the
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppService.html}{\texttt{DLAppService}}
method \texttt{updateFileShortcut}:

\begin{verbatim}
updateFileShortcut(long fileShortcutId, long folderId, long toFileEntryId, ServiceContext serviceContext)
\end{verbatim}

All of this method's parameters are mandatory. To retain any of the
shortcut's original values, you must provide them to this method. For a
full description of the parameters, see the method's
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppService.html\#updateFileShortcut-long-long-long-com.liferay.portal.kernel.service.ServiceContext-}{Javadoc}.

Follow these steps to use this method to update a file shortcut:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Get a reference to \texttt{DLAppService}:

\begin{verbatim}
@Reference
private DLAppService _dlAppService;
\end{verbatim}

  For more information on this, see the section on
  \href{/docs/7-1/tutorials/-/knowledge_base/t/getting-started-with-the-documents-and-media-api\#getting-a-service-reference}{getting
  a service reference} in the getting started tutorial.
\item
  Get the data needed to populate the \texttt{updateFileShortcut}
  method's arguments. Since it's common to update a file shortcut with
  data submitted by the end user, you can extract the data from the
  request. This example does so via \texttt{javax.portlet.ActionRequest}
  and
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/util/ParamUtil.html}{\texttt{ParamUtil}},
  but you can get the data any way you wish:

\begin{verbatim}
long fileShortcutId = ParamUtil.getLong(actionRequest, "fileShortcutId");
long folderId = ParamUtil.getLong(actionRequest, "folderId");
long toFileEntryId = ParamUtil.getLong(actionRequest, "toFileEntryId");

ServiceContext serviceContext = ServiceContextFactory.getInstance(
            DLFileShortcutConstants.getClassName(), actionRequest);
\end{verbatim}

  For more information on getting folder IDs, see the
  \href{/docs/7-1/tutorials/-/knowledge_base/t/getting-started-with-the-documents-and-media-api}{getting
  started tutorial's} section on specifying folders. For more
  information on \texttt{ServiceContext}, see the tutorial
  \href{/docs/7-1/tutorials/-/knowledge_base/t/understanding-servicecontext}{Understanding
  ServiceContext}.
\item
  Call the service reference's \texttt{updateFileShortcut} method with
  the data from the previous step:

\begin{verbatim}
_dlAppService.updateFileShortcut(
        fileShortcutId, folderId, toFileEntryId, serviceContext);
\end{verbatim}
\end{enumerate}

You can find the full code for this example in the
\texttt{updateFileShortcut} method of Liferay DXP's
\href{https://github.com/liferay/liferay-portal/blob/master/modules/apps/document-library/document-library-web/src/main/java/com/liferay/document/library/web/internal/portlet/action/EditFileShortcutMVCActionCommand.java}{\texttt{EditFileShortcutMVCActionCommand}}
class. This class uses the Documents and Media API to implement almost
all the \texttt{FileShortcut} actions that the Documents and Media app
supports. Also note that this \texttt{updateFileShortcut} method, as
well as the rest of \texttt{EditFileShortcutMVCActionCommand}, contains
additional logic to suit the specific needs of the Documents and Media
app.

\subsection{Related Topics}\label{related-topics-301}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-file-shortcuts}{Creating
File Shortcuts}

\href{/docs/7-1/tutorials/-/knowledge_base/t/deleting-file-shortcuts}{Deleting
File Shortcuts}

\chapter{File Check-out and Check-in}\label{file-check-out-and-check-in}

The Document Library lets users
\href{/docs/7-1/user/-/knowledge_base/u/checking-out-and-editing-files}{check
out files} for editing. Only the user who checked out the file can edit
it. This prevents conflicting edits on the same file from multiple
users. The Documents and Media API allows these check-in/check-out
operations:

\begin{itemize}
\tightlist
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/file-checkout}{File
  Check-out}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/file-checkin}{File
  Check-in}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/cancelling-a-checkout}{Cancelling
  a Check-out}
\end{itemize}

The tutorials in this section show you how to do these operations.

\section{File Check-out}\label{file-check-out}

Here's what happens when you check out a file:

\begin{itemize}
\item
  A private working copy of the file is created that only you and
  administrators can access. Until you check the file back in or cancel
  your changes, any edits you make are stored in the private working
  copy.
\item
  Other users can't change or edit any version of the file. This state
  remains until you cancel or check in your changes.
\end{itemize}

The main
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppService.html}{\texttt{DLAppService}}
method for checking out a file is this \texttt{checkOutFileEntry}
method:

\begin{verbatim}
checkOutFileEntry(long fileEntryId, ServiceContext serviceContext)
\end{verbatim}

If this method throws an exception, then you should assume the checkout
failed and repeat the operation. For a full description of the method
and its parameters, see its
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppService.html\#checkOutFileEntry-long-com.liferay.portal.kernel.service.ServiceContext-}{Javadoc}.

Follow these steps to use this method to check out a file:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Get a reference to \texttt{DLAppService}:

\begin{verbatim}
@Reference
private DLAppService _dlAppService;
\end{verbatim}

  For more information on this, see the section on
  \href{/docs/7-1/tutorials/-/knowledge_base/t/getting-started-with-the-documents-and-media-api\#getting-a-service-reference}{getting
  a service reference} in the getting started tutorial.
\item
  Get the data needed to populate the \texttt{checkOutFileEntry}
  method's arguments. Since it's common to check out a file in response
  to an action by the end user, you can extract the data from the
  request. This example does so via \texttt{javax.portlet.ActionRequest}
  and
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/util/ParamUtil.html}{\texttt{ParamUtil}},
  but you can get the data any way you wish:

\begin{verbatim}
long fileEntryId = ParamUtil.getLong(actionRequest, "fileEntryId");

ServiceContext serviceContext = ServiceContextFactory.getInstance(actionRequest);
\end{verbatim}

  For more information on \texttt{ServiceContext}, see the tutorial
  \href{/docs/7-1/tutorials/-/knowledge_base/t/understanding-servicecontext}{Understanding
  ServiceContext}.
\item
  Call the service reference's \texttt{checkOutFileEntry} method with
  the data from the previous step:

\begin{verbatim}
_dlAppService.checkOutFileEntry(fileEntryId, serviceContext);
\end{verbatim}
\end{enumerate}

You can find the full code for this example in the
\texttt{checkOutFileEntries} method of Liferay DXP's
\href{https://github.com/liferay/liferay-portal/blob/master/modules/apps/document-library/document-library-web/src/main/java/com/liferay/document/library/web/internal/portlet/action/EditFileEntryMVCActionCommand.java}{\texttt{EditFileEntryMVCActionCommand}}
class. This class uses the Documents and Media API to implement almost
all the \texttt{FileEntry} actions that the Documents and Media app
supports. Also note that this \texttt{checkOutFileEntries} method, as
well as the rest of \texttt{EditFileEntryMVCActionCommand}, contains
additional logic to suit the specific needs of the Documents and Media
app.

\subsection{Fine-tuning Checkout}\label{fine-tuning-checkout}

You can control how the checkout is performed by setting the following
attributes in the \texttt{ServiceContext} parameter:

\begin{itemize}
\item
  \texttt{manualCheckInRequired}: By default, the system automatically
  checks out/in a file when a user edits it. Setting this attribute to
  \texttt{true} prevents this, therefore requiring manual check-out and
  check-in.
\item
  \texttt{existingDLFileVersionId}: The system typically reuses the
  private working copy across different check-out/check-in sequences.
  There's little chance for conflicting edits because only one user at a
  time can access the private working copy. To force the system to
  create a new private working copy each time, omit this attribute or
  set it to \texttt{0}.
\item
  \texttt{fileVersionUuid}: This is used by
  \href{/docs/7-1/user/-/knowledge_base/u/staging-content-for-publication}{staging},
  but can be ignored for normal use. Setting this attribute causes the
  system to create the new private working copy version with the given
  UUID.
\end{itemize}

To set these attributes, use the \texttt{ServiceContext} method
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/service/ServiceContext.html\#setAttribute-java.lang.String-java.io.Serializable-}{\texttt{setAttribute(String\ name,\ Serializable\ value)}}.
Here's an example of setting the \texttt{manualCheckInRequired}
attribute to \texttt{true}:

\begin{verbatim}
serviceContext.setAttribute("manualCheckInRequired", Boolean.TRUE)
\end{verbatim}

\subsection{Related Topics}\label{related-topics-302}

\href{/docs/7-1/tutorials/-/knowledge_base/t/file-checkin}{File
Check-in}

\href{/docs/7-1/tutorials/-/knowledge_base/t/cancelling-a-checkout}{Cancelling
a Check-out}

\href{/docs/7-1/tutorials/-/knowledge_base/t/updating-files}{Updating
Files}

\section{File Check-in}\label{file-check-in}

After checking out and editing a file, you must check it back in for
other users to see the new version. Once you do so, you can't access the
private working copy. The next time the file is checked out, the private
working copy's contents are overwritten.

The
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppService.html}{\texttt{DLAppService}}
method for checking in a file is \texttt{checkInFileEntry}:

\begin{verbatim}
checkInFileEntry(long fileEntryId, boolean majorVersion, String changeLog, 
                ServiceContext serviceContext)
\end{verbatim}

For a full description of the method and its parameters, see its
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppService.html\#checkInFileEntry-long-boolean-java.lang.String-com.liferay.portal.kernel.service.ServiceContext-}{Javadoc}.
This method uses the private working copy to create a new version of the
file. As the
\href{/docs/7-1/tutorials/-/knowledge_base/t/updating-files}{Updating
Files tutorial} explains, the \texttt{majorVersion} parameter's setting
determines how the file's version number is incremented.

Follow these steps to use \texttt{checkInFileEntry} to check in a file:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Get a reference to \texttt{DLAppService}:

\begin{verbatim}
@Reference
private DLAppService _dlAppService;
\end{verbatim}

  For more information on this, see the section on
  \href{/docs/7-1/tutorials/-/knowledge_base/t/getting-started-with-the-documents-and-media-api\#getting-a-service-reference}{getting
  a service reference} in the getting started tutorial.
\item
  Get the data needed to populate the \texttt{checkInFileEntry} method's
  arguments. Since it's common to check in a file in response to an
  action by the end user, you can extract the data from the request.
  This example does so via \texttt{javax.portlet.ActionRequest} and
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/util/ParamUtil.html}{\texttt{ParamUtil}},
  but you can get the data any way you wish:

\begin{verbatim}
long fileEntryId = ParamUtil.getLong(actionRequest, "fileEntryId");
boolean majorVersion = ParamUtil.getBoolean(actionRequest, "majorVersion");
String changeLog = ParamUtil.getString(actionRequest, "changeLog");

ServiceContext serviceContext = ServiceContextFactory.getInstance(actionRequest);
\end{verbatim}

  For more information on \texttt{ServiceContext}, see the tutorial
  \href{/docs/7-1/tutorials/-/knowledge_base/t/understanding-servicecontext}{Understanding
  ServiceContext}.
\item
  Call the service reference's \texttt{checkInFileEntry} method with the
  data from the previous step:

\begin{verbatim}
_dlAppService.checkInFileEntry(
        fileEntryId, majorVersion, changeLog, serviceContext);
\end{verbatim}
\end{enumerate}

You can find the full code for this example in the
\texttt{checkInFileEntries} method of Liferay DXP's
\href{https://github.com/liferay/liferay-portal/blob/master/modules/apps/document-library/document-library-web/src/main/java/com/liferay/document/library/web/internal/portlet/action/EditFileEntryMVCActionCommand.java}{\texttt{EditFileEntryMVCActionCommand}}
class. This class uses the Documents and Media API to implement almost
all the \texttt{FileEntry} actions that the Documents and Media app
supports. Also note that this \texttt{checkInFileEntries} method, as
well as the rest of \texttt{EditFileEntryMVCActionCommand}, contains
additional logic to suit the specific needs of the Documents and Media
app.

\subsection{Related Topics}\label{related-topics-303}

\href{/docs/7-1/tutorials/-/knowledge_base/t/file-checkout}{File
Check-out}

\href{/docs/7-1/tutorials/-/knowledge_base/t/cancelling-a-checkout}{Cancelling
a Check-out}

\href{/docs/7-1/tutorials/-/knowledge_base/t/updating-files}{Updating
Files}

\section{Canceling a Check-out}\label{canceling-a-check-out}

The Documents and Media API also lets you cancel a check-out. Use
caution with this operation---it discards any edits made since
check-out. If you're sure you want to cancel a check-out, do so with the
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppService.html}{\texttt{DLAppService}}
method \texttt{cancelCheckOut}:

\begin{verbatim}
cancelCheckOut(long fileEntryId)
\end{verbatim}

For a full description of this method and its parameter, see its
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppService.html\#cancelCheckOut-long-}{Javadoc}.
If you invoke this method without error, you can safely assume that it
discarded the private working copy and unlocked the file. Other users
should now be able to check out and edit the file.

Follow these steps to cancel a check-out:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Get a reference to \texttt{DLAppService}:

\begin{verbatim}
@Reference
private DLAppService _dlAppService;
\end{verbatim}

  For more information on this, see the section on
  \href{/docs/7-1/tutorials/-/knowledge_base/t/getting-started-with-the-documents-and-media-api\#getting-a-service-reference}{getting
  a service reference} in the getting started tutorial.
\item
  Get the ID of the file whose check-out you want to cancel. Since it's
  common to cancel a check-out in response to a user action, you can
  extract the file ID from the request. This example does so via
  \texttt{javax.portlet.ActionRequest} and
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/util/ParamUtil.html}{\texttt{ParamUtil}},
  but you can get it any way you wish:

\begin{verbatim}
long fileEntryId = ParamUtil.getLong(actionRequest, "fileEntryId");
\end{verbatim}
\item
  Call the service reference's \texttt{cancelCheckOut} method with the
  file's ID:

\begin{verbatim}
_dlAppService.cancelCheckOut(fileEntryId);
\end{verbatim}
\end{enumerate}

You can find the full code for this example in the
\texttt{cancelFileEntriesCheckOut} method of Liferay DXP's
\href{https://github.com/liferay/liferay-portal/blob/master/modules/apps/document-library/document-library-web/src/main/java/com/liferay/document/library/web/internal/portlet/action/EditFileEntryMVCActionCommand.java}{\texttt{EditFileEntryMVCActionCommand}}
class. This class uses the Documents and Media API to implement almost
all the \texttt{FileEntry} actions that the Documents and Media app
supports. Also note that this \texttt{cancelFileEntriesCheckOut} method,
as well as the rest of \texttt{EditFileEntryMVCActionCommand}, contains
additional logic to suit the specific needs of the Documents and Media
app.

\subsection{Related Topics}\label{related-topics-304}

\href{/docs/7-1/tutorials/-/knowledge_base/t/file-checkout}{File
Check-out}

\href{/docs/7-1/tutorials/-/knowledge_base/t/file-checkin}{File
Check-in}

\href{/docs/7-1/tutorials/-/knowledge_base/t/updating-files}{Updating
Files}

\chapter{Copying and Moving Entities}\label{copying-and-moving-entities}

Although the Documents and Media API lets you copy and move entities,
these operations have some important caveats and limitations. Keep these
things in mind when copying entities:

\begin{itemize}
\tightlist
\item
  There's no way to copy files---you can only copy folders. However,
  copying a folder also copies its contents, which can include files.
\item
  Folders can only be copied within their current repository.
\end{itemize}

The move operation doesn't have these restrictions. It's possible to
move files and folders between different repositories. In general,
however, the move operation is a bit more complicated than the copy
operation. For example, the API's behavior changes depending on whether
you move entities to a different repository or within the same one.

The tutorials in this section cover these differences, and more.

\section{Copying Folders}\label{copying-folders}

The Documents and Media API lets you copy folders within a repository.
You can't, however, copy a folder between different repositories. Also
note that copying a folder also copies its contents.

To copy a folder, use the
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppService.html}{\texttt{DLAppService}}
method \texttt{copyFolder}:

\begin{verbatim}
copyFolder(long repositoryId, long sourceFolderId, long parentFolderId, String name, 
        String description, ServiceContext serviceContext)
\end{verbatim}

For a full description of the method and its parameters, see its
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppService.html\#copyFolder-long-long-long-java.lang.String-java.lang.String-com.liferay.portal.kernel.service.ServiceContext-}{Javadoc}.

Follow these steps to use this method to copy a folder:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Get a reference to \texttt{DLAppService}:

\begin{verbatim}
@Reference
private DLAppService _dlAppService;
\end{verbatim}

  For more information on this, see the section on
  \href{/docs/7-1/tutorials/-/knowledge_base/t/getting-started-with-the-documents-and-media-api\#getting-a-service-reference}{getting
  a service reference} in the getting started tutorial.
\item
  Get the data needed to populate the \texttt{copyFolder} method's
  arguments. How you do this depends on your use case. The copy
  operation in this example takes place in the default Site repository
  and retains the folder's existing name and description. It therefore
  needs the folder's group ID (to specify the default site repository),
  name, and description. Also note that because the destination folder
  in this example is the repository's root folder, the parent folder ID
  isn't needed---Liferay DXP supplies a constant for specifying a
  repository's root folder.

  In the following code,
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/util/ParamUtil.html}{\texttt{ParamUtil}}
  gets the folder's ID from the request
  (\texttt{javax.portlet.ActionRequest}), and the service reference's
  \href{/7.1-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppService.html\#getFolder-long-}{\texttt{getFolder}}
  method gets the corresponding folder object. The folder's
  \texttt{getGroupId()}, \texttt{getName()}, and
  \texttt{getDescription()} methods then get the folder's group ID,
  name, and description, respectively:

\begin{verbatim}
long folderId = ParamUtil.getLong(actionRequest, "folderId");

Folder folder = _dlAppService.getFolder(folderId);
long groupId = folder.getGroupId();
String folderName = folder.getName();
String folderDescription = folder.getDescription();

ServiceContext serviceContext = ServiceContextFactory.getInstance(
            DLFolder.class.getName(), actionRequest);
\end{verbatim}

  For more information on getting repository and folder IDs, see the
  \href{/docs/7-1/tutorials/-/knowledge_base/t/getting-started-with-the-documents-and-media-api}{getting
  started tutorial's} sections on specifying repositories and folders.
  For more information on \texttt{ServiceContext}, see the tutorial
  \href{/docs/7-1/tutorials/-/knowledge_base/t/understanding-servicecontext}{Understanding
  ServiceContext}.
\item
  Call the service reference's \texttt{copyFolder} method with the data
  from the previous step. Note that this example uses the
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/model/DLFolderConstants.html}{\texttt{DLFolderConstants}}
  constant \texttt{DEFAULT\_PARENT\_FOLDER\_ID} to specify the
  repository's root folder as the destination folder:

\begin{verbatim}
_dlAppService.copyFolder(
        groupId, folderId, DLFolderConstants.DEFAULT_PARENT_FOLDER_ID, 
        folderName, folderDescription, serviceContext);
\end{verbatim}
\end{enumerate}

Keep in mind that you can change any of these values to suit your copy
operation. For example, if your copy takes place in a repository other
than the default Site repository, you would specify that repository's ID
in place of the group ID. You could also specify a different destination
folder, and/or change the new folder's name and/or description.

\subsection{Related Topics}\label{related-topics-305}

\href{/docs/7-1/tutorials/-/knowledge_base/t/getting-started-with-the-documents-and-media-api}{Getting
Started with the Documents and Media API}

\href{/docs/7-1/tutorials/-/knowledge_base/t/understanding-servicecontext}{Understanding
Service Context}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-folders}{Creating
Folders}

\href{/docs/7-1/tutorials/-/knowledge_base/t/updating-folders}{Updating
Folders}

\href{/docs/7-1/tutorials/-/knowledge_base/t/deleting-folders}{Deleting
Folders}

\href{/docs/7-1/tutorials/-/knowledge_base/t/moving-folders-and-files}{Moving
Folders and Files}

\section{Moving Folders and Files}\label{moving-folders-and-files}

The move operation is more flexible than the
\href{/docs/7-1/tutorials/-/knowledge_base/t/copying-folders}{copy
operation}. Copying only works with folders, and you can't copy between
repositories. The move operation, however, works with files and folders
within or between repositories.

\noindent\hrulefill

\textbf{Note:} Depending on the repository implementation, you may get
unexpected behavior when moving folders between repositories. Moving a
folder also moves its contents via separate move operations for each
item in the folder. In some repository implementations, if any move
sub-operation fails, the parent move operation also fails. In other
repository implementations, the results of successful sub-operations
remain even if others fail, which leaves a partially complete move of
the whole folder.

\noindent\hrulefill

To move a folder, use the
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppService.html}{\texttt{DLAppService}}
method \texttt{moveFolder}:

\begin{verbatim}
moveFolder(long folderId, long parentFolderId, ServiceContext serviceContext)
\end{verbatim}

For a full description of this method and its parameters, see its
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppService.html\#moveFolder-long-long-com.liferay.portal.kernel.service.ServiceContext-}{Javadoc}.
This method is similar to \texttt{copyFolder}, but it doesn't let you
change the folder's name or description, and it can move folders between
repositories. Folder contents are moved with the folder.

The operation for moving a file is almost identical to moving a folder.
To move a file, use the \texttt{DLAppService} method
\texttt{moveFileEntry}:

\begin{verbatim}
moveFileEntry(long fileEntryId, long newFolderId, ServiceContext serviceContext)
\end{verbatim}

For a full description of this method and its parameters, see its
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppService.html\#moveFileEntry-long-long-com.liferay.portal.kernel.service.ServiceContext-}{Javadoc}.

Follow these steps to use \texttt{moveFolder} and \texttt{moveFileEntry}
to move a folder and a file, respectively. Although this example does
both just to demonstrate the procedure:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Get a reference to \texttt{DLAppService}:

\begin{verbatim}
@Reference
private DLAppService _dlAppService;
\end{verbatim}

  For more information on this, see the section on
  \href{/docs/7-1/tutorials/-/knowledge_base/t/getting-started-with-the-documents-and-media-api\#getting-a-service-reference}{getting
  a service reference} in the getting started tutorial.
\item
  Get the data needed to populate the method arguments. Since moving
  folders and files is typically done in response to a user action, you
  can get the data from the request. This example does so via
  \texttt{javax.portlet.ActionRequest} and
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/util/ParamUtil.html}{\texttt{ParamUtil}},
  but you can get the data any way you wish:

\begin{verbatim}
// Get the folder IDs
long folderId = ParamUtil.getLong(actionRequest, "folderId");
long newFolderId = ParamUtil.getLong(actionRequest, "newFolderId");

// Get the file ID
long fileEntryId = ParamUtil.getLong(actionRequest, "fileEntryId");

ServiceContext serviceContext = ServiceContextFactory.getInstance(
        DLFileEntry.class.getName(), actionRequest);
\end{verbatim}

  For more information on getting folder IDs, see the
  \href{/docs/7-1/tutorials/-/knowledge_base/t/getting-started-with-the-documents-and-media-api}{getting
  started tutorial's} section on specifying folders. For more
  information on \texttt{ServiceContext}, see the tutorial
  \href{/docs/7-1/tutorials/-/knowledge_base/t/understanding-servicecontext}{Understanding
  ServiceContext}.
\item
  Call the service reference's method(s). This example calls
  \texttt{moveFolder} to move a folder (\texttt{folderId}) to a
  different folder (\texttt{newFolderId}). It then calls
  \texttt{moveFileEntry} to move a file (\texttt{fileEntryId}) to the
  same destination folder:

\begin{verbatim}
_dlAppService.moveFolder(folderId, newFolderId, serviceContext);

_dlAppService.moveFileEntry(fileEntryId, newFolderId, serviceContext);
\end{verbatim}
\end{enumerate}

\subsection{Related Topics}\label{related-topics-306}

\href{/docs/7-1/tutorials/-/knowledge_base/t/copying-folders}{Copying
Folders}

\chapter{Getting Entities}\label{getting-entities}

The Documents and Media API contains many methods for getting entities
from a repository. Most methods in
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppService.html}{\texttt{DLAppService}}
are for getting single entities (e.g., a file or folder), a collection
of entities that match certain characteristics, or the number of such
entities. Because there are so many similar methods for getting
entities, these tutorials don't describe them all in detail. All of them
are covered in the
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppService.html}{reference
documentation}.

\section{Getting Files}\label{getting-files}

Getting files is one of the most common tasks you'll perform with the
Documents and Media API. There are two main method families for getting
files:

\begin{itemize}
\tightlist
\item
  \texttt{getFileEntries}: Gets files from a specific repository.
\item
  \texttt{getGroupFileEntries}: Gets files from a Site (group),
  regardless of repository.
\end{itemize}

Since these method families are common, their methods share many
parameters:

\begin{itemize}
\tightlist
\item
  \texttt{repositoryId}: The ID of the repository to get files from. To
  specify the default Site repository, use the \texttt{groupId} (Site
  ID).
\item
  \texttt{folderId}: The ID of the folder to get files from. Note that
  these methods don't traverse the folder structure---they only get
  files directly from the specified folder. To specify the repository's
  root folder, use the constant
  \texttt{DLFolderConstants.DEFAULT\_PARENT\_FOLDER\_ID}.
\item
  \texttt{start} and \texttt{end}: Integers that specify the lower and
  upper bounds, respectively, of collection items to include in a page
  of results. If you don't want to use pagination, use
  \texttt{QueryUtil.ALL\_POS} for these parameters.
\item
  \texttt{obc}: The comparator to use to order collection items.
  Comparators are
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/util/OrderByComparator.html}{\texttt{OrderByComparator}}
  implementations that sort collection items.
\item
  \texttt{fileEntryTypeId}: The ID of the file type to retrieve. Use
  this to retrieve files of a specific type.
\item
  \texttt{mimeTypes}: The MIME types of the files to retrieve. Use this
  to retrieve files of the specified MIME types. You can specify MIME
  types via the constants in
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/util/ContentTypes.html}{\texttt{ContentTypes}}.
\end{itemize}

Note that the \texttt{obc} parameter must be an implementation of
\texttt{OrderByComparator}. Although you can implement your own
comparators, Liferay DXP already contains a few useful implementations
in the package
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/util/comparator/package-summary.html}{\texttt{com.liferay.document.library.kernel.util.comparator}}:

\begin{itemize}
\tightlist
\item
  \texttt{RepositoryModelCreateDateComparator}: Sorts by creation date.
\item
  \texttt{RepositoryModelModifiedDateComparator}: Sorts by modification
  date.
\item
  \texttt{RepositoryModelReadCountComparator}: Sorts by number of views.
\item
  \texttt{RepositoryModelSizeComparator}: Sorts by file size.
\item
  \texttt{RepositoryModelTitleComparator}: Sorts by title.
\end{itemize}

As an example, this
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppService.html\#getFileEntries-long-long-java.lang.String:A-int-int-com.liferay.portal.kernel.util.OrderByComparator-}{\texttt{getFileEntries}}
method contains all the above parameters except \texttt{fileEntryTypeId}
(it contains \texttt{mimeTypes} instead):

\begin{verbatim}
List<FileEntry> getFileEntries(
        long repositoryId, 
        long folderId, 
        String[] mimeTypes, 
        int start, 
        int end, 
        OrderByComparator<FileEntry> obc
)
\end{verbatim}

Follow these steps to use this method to get a list of files. Note that
the example in these steps gets all the PNG images from the root folder
of a Site's default repository, sorted by title:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Get a reference to \texttt{DLAppService}:

\begin{verbatim}
@Reference
private DLAppService _dlAppService;
\end{verbatim}

  For more information on this, see the section on
  \href{/docs/7-1/tutorials/-/knowledge_base/t/getting-started-with-the-documents-and-media-api\#getting-a-service-reference}{getting
  a service reference} in the getting started tutorial.
\item
  Get the data needed to populate the method's arguments. You can do
  this any way you wish. As the next step describes, Liferay DXP
  provides constants and a comparator for all the arguments this example
  needs besides the group ID. This example gets the group ID by using
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/util/ParamUtil.html}{\texttt{ParamUtil}}
  with the request (\texttt{javax.portlet.ActionRequest}):

\begin{verbatim}
long groupId = ParamUtil.getLong(actionRequest, "groupId");
\end{verbatim}

  It's also possible to get the group ID via the
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/theme/ThemeDisplay.html}{\texttt{ThemeDisplay}}.
  Calling the \texttt{ThemeDisplay} method \texttt{getScopeGroupId()}
  gets the ID of your app's current site (group):

\begin{verbatim}
ThemeDisplay themeDisplay = (ThemeDisplay) request.getAttribute(WebKeys.THEME_DISPLAY);
long groupId = themeDisplay.getScopeGroupId();
\end{verbatim}

  For more information, see the
  \href{/docs/7-1/tutorials/-/knowledge_base/t/data-scopes}{Data Scopes
  tutorial}.
\item
  Use the data from the previous step to call the service reference
  method you want to use to get the files. This example calls the above
  \texttt{getFileEntries} method with the group ID from the previous
  step, and constants and a comparator for the remaining arguments:

\begin{verbatim}
List<FileEntry> fileEntries = 
        _dlAppService.getFileEntries(
                groupId, 
                DLFolderConstants.DEFAULT_PARENT_FOLDER_ID, 
                new String[] {ContentTypes.IMAGE_PNG}, 
                QueryUtil.ALL_POS, 
                QueryUtil.ALL_POS, 
                new RepositoryModelTitleComparator<>()
        );
\end{verbatim}

  Here's a description of the arguments used in this example:

  \begin{itemize}
  \tightlist
  \item
    \texttt{groupId}: Using the group ID as the repository ID specifies
    that the operation takes place in the default site repository.
  \item
    \texttt{DLFolderConstants.DEFAULT\_PARENT\_FOLDER\_ID}: Uses the
    \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/model/DLFolderConstants.html}{\texttt{DLFolderConstants}}
    constant \texttt{DEFAULT\_PARENT\_FOLDER\_ID} to specify the
    repository's root folder.
  \item
    \texttt{new\ String{[}{]}\ \{ContentTypes.IMAGE\_PNG\}}: Uses the
    \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/util/ContentTypes.html}{\texttt{ContentTypes}}
    constant \texttt{IMAGE\_PNG} to specify PNG images.
  \item
    \texttt{QueryUtil.ALL\_POS}: Uses the
    \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/dao/orm/QueryUtil.html}{\texttt{QueryUtil}}
    constant \texttt{ALL\_POS} for the start and end positions in the
    results. This specifies all results, bypassing pagination.
  \item
    \texttt{new\ RepositoryModelTitleComparator\textless{}\textgreater{}()}:
    Creates a new
    \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/util/comparator/RepositoryModelTitleComparator.html}{\texttt{RepositoryModelTitleComparator}},
    which sorts the results by title.
  \end{itemize}
\end{enumerate}

Remember, this is just one of many \texttt{getFileEntries} and
\texttt{getGroupFileEntries} methods. To see all such methods, see the
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppService.html}{\texttt{DLAppService}
Javadoc}.

\subsection{Related Topics}\label{related-topics-307}

\href{/docs/7-1/tutorials/-/knowledge_base/t/getting-started-with-the-documents-and-media-api}{Getting
Started with the Documents and Media API}

\href{/docs/7-1/tutorials/-/knowledge_base/t/getting-folders}{Getting
Folders}

\href{/docs/7-1/tutorials/-/knowledge_base/t/getting-multiple-entity-types}{Getting
Multiple Entity Types}

\section{Getting Folders}\label{getting-folders}

The Documents and Media API can get folders in a similar way to getting
files. The main difference is that folder retrieval methods may have an
additional argument to tell the system whether to include \emph{mount
folders}. Mount folders are mount points for external repositories
(e.g.~Alfresco or SharePoint) that appear as regular folders in a Site's
default repository. They let users navigate seamlessly between
repositories. To account for this, some folder retrieval methods include
the boolean parameter \texttt{includeMountFolders}. Setting this
parameter to \texttt{true} includes mount folders in the results, while
omitting it or setting it to \texttt{false} excludes them.

For example, to get a list of a parent folder's subfolders from a
repository, including any mount folders, use the
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppService.html\#getFolders-long-long-boolean-}{\texttt{getFolders}}
method:

\begin{verbatim}
getFolders(long repositoryId, long parentFolderId, boolean includeMountFolders)
\end{verbatim}

Follow these steps to use this method to get the folders from a parent
folder. Note that the example in these steps gets the folders in the
default Site repository's root folder:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Get a reference to \texttt{DLAppService}:

\begin{verbatim}
@Reference
private DLAppService _dlAppService;
\end{verbatim}

  For more information on this, see the section on
  \href{/docs/7-1/tutorials/-/knowledge_base/t/getting-started-with-the-documents-and-media-api\#getting-a-service-reference}{getting
  a service reference} in the getting started tutorial.
\item
  Get the data needed to populate the method's arguments any way you
  wish. This \texttt{getFolders} method needs a repository ID, a parent
  folder ID, and a boolean value that indicates whether to include mount
  folders in the results. To specify the default site repository, you
  can use the group ID as the repository ID. This example gets the group
  ID from the request (\texttt{javax.portlet.ActionRequest}) via
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/util/ParamUtil.html}{\texttt{ParamUtil}}:

\begin{verbatim}
long groupId = ParamUtil.getLong(actionRequest, "groupId");
\end{verbatim}

  It's also possible to get the group ID via the
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/theme/ThemeDisplay.html}{\texttt{ThemeDisplay}}.
  Calling the \texttt{ThemeDisplay} method \texttt{getScopeGroupId()}
  gets the ID of your app's current site (group). For more information,
  see the \href{/docs/7-1/tutorials/-/knowledge_base/t/data-scopes}{Data
  Scopes tutorial}.

\begin{verbatim}
ThemeDisplay themeDisplay = (ThemeDisplay) request.getAttribute(WebKeys.THEME_DISPLAY);
long groupId = themeDisplay.getScopeGroupId();
\end{verbatim}

  Note that getting the parent folder ID isn't necessary because this
  example uses the root folder, for which Liferay DXP provides a
  constant. Also, the boolean value can be provided directly---it
  doesn't need to be retrieved from somewhere. For more information on
  getting repository and folder IDs, see the
  \href{/docs/7-1/tutorials/-/knowledge_base/t/getting-started-with-the-documents-and-media-api}{getting
  started tutorial's} sections on specifying repositories and folders.
\item
  Call the service reference's \texttt{getFolders} method with the data
  from the previous step and any other values you want to provide. Note
  that this example uses
  \texttt{DLFolderConstants.DEFAULT\_PARENT\_FOLDER\_ID} to specify the
  repository's root folder as the parent folder. It also uses
  \texttt{true} to include any mount folders in the results:

\begin{verbatim}
_dlAppService.getFolders(groupId, DLFolderConstants.DEFAULT_PARENT_FOLDER_ID, true)
\end{verbatim}
\end{enumerate}

Note that this is one of many methods you can use to get folders. The
rest are listed in the
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppService.html}{\texttt{DLAppService}
Javadoc}.

\subsection{Related Topics}\label{related-topics-308}

\href{/docs/7-1/tutorials/-/knowledge_base/t/getting-started-with-the-documents-and-media-api}{Getting
Started with the Documents and Media API}

\href{/docs/7-1/tutorials/-/knowledge_base/t/getting-files}{Getting
Files}

\href{/docs/7-1/tutorials/-/knowledge_base/t/getting-multiple-entity-types}{Getting
Multiple Entity Types}

\section{Getting Multiple Entity
Types}\label{getting-multiple-entity-types}

There are also methods in the Documents and Media API that retrieve
lists containing several entity types. These methods use many of the
same parameters as those already described for retrieving files and
folders. For example,
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppService.html\#getFileEntriesAndFileShortcuts-long-long-int-int-int-}{this
method} gets files and shortcuts from a given repository and folder. The
\texttt{status} parameter specifies a
\href{/docs/7-1/user/-/knowledge_base/u/workflow}{workflow} status. As
before, the \texttt{start} and \texttt{end} parameters control
pagination of the entities:

\begin{verbatim}
getFileEntriesAndFileShortcuts(long repositoryId, long folderId, int status, int start, int end)
\end{verbatim}

To see all such methods, see the
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppService.html}{\texttt{DLAppService}
Javadoc}.

Follow these steps to use the above
\texttt{getFileEntriesAndFileShortcuts} method. Note that the example in
these steps gets all the files and shortcuts in the default Site
repository's root folder:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Get a reference to \texttt{DLAppService}:

\begin{verbatim}
@Reference
private DLAppService _dlAppService;
\end{verbatim}

  For more information on this, see the section on
  \href{/docs/7-1/tutorials/-/knowledge_base/t/getting-started-with-the-documents-and-media-api\#getting-a-service-reference}{getting
  a service reference} in the getting started tutorial.
\item
  Get the data needed to populate the method's arguments any way you
  wish. To specify the default Site repository, you can use the group ID
  as the repository ID. This example gets the group ID from the request
  (\texttt{javax.portlet.ActionRequest}) via
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/util/ParamUtil.html}{\texttt{ParamUtil}}:

\begin{verbatim}
long groupId = ParamUtil.getLong(actionRequest, "groupId");
\end{verbatim}

  Getting the parent folder ID, workflow status, and start and end
  parameters isn't necessary because Liferay DXP provides constants for
  them. The next step shows this in detail.
\item
  Call the service reference method with the data from the previous step
  and any other values you want to provide. This example calls
  \texttt{getFileEntriesAndFileShortcuts} with the group ID from the
  previous step and constants for the remaining arguments:

\begin{verbatim}
_dlAppService.getFileEntriesAndFileShortcuts(
        groupId, 
        DLFolderConstants.DEFAULT_PARENT_FOLDER_ID, 
        WorkflowConstants.STATUS_APPROVED, 
        QueryUtil.ALL_POS, 
        QueryUtil.ALL_POS
)
\end{verbatim}

  Here's a description of the arguments used in this example:

  \begin{itemize}
  \tightlist
  \item
    \texttt{groupId}: Using the group ID as the repository ID specifies
    that the operation takes place in the default site repository.
  \item
    \texttt{DLFolderConstants.DEFAULT\_PARENT\_FOLDER\_ID}: Uses the
    \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/model/DLFolderConstants.html}{\texttt{DLFolderConstants}}
    constant \texttt{DEFAULT\_PARENT\_FOLDER\_ID} to specify the
    repository's root folder.
  \item
    \texttt{WorkflowConstants.STATUS\_APPROVED}: Uses the
    \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/workflow/WorkflowConstants.html}{\texttt{WorkflowConstants}}
    constant \texttt{STATUS\_APPROVED} to specify only files/folders
    that have been approved via workflow.
  \item
    \texttt{QueryUtil.ALL\_POS}: Uses the
    \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/dao/orm/QueryUtil.html}{\texttt{QueryUtil}}
    constant \texttt{ALL\_POS} for the start and end positions in the
    results. This specifies all results, bypassing pagination.
  \end{itemize}
\end{enumerate}

\subsection{Related Topics}\label{related-topics-309}

\href{/docs/7-1/tutorials/-/knowledge_base/t/getting-started-with-the-documents-and-media-api}{Getting
Started with the Documents and Media API}

\href{/docs/7-1/tutorials/-/knowledge_base/t/getting-files}{Getting
Files}

\href{/docs/7-1/tutorials/-/knowledge_base/t/getting-folders}{Getting
Folders}

\chapter{Adaptive Media}\label{adaptive-media}

The Adaptive Media app lets administrators tailor the quality of images
to the device viewing those images. For information on using this app,
see
\href{/docs/7-1/user/-/knowledge_base/u/adapting-your-media-across-multiple-devices}{the
Adaptive Media user guide}.

If you want to leverage Adaptive Media in your own app, you're in the
right place! The tutorials here explain how to use adapted images in
your app. You'll also learn how to change Adaptive Media's image
processing.

Onwards!

\section{Displaying Adapted Images in Your
App}\label{displaying-adapted-images-in-your-app}

To display
\href{/docs/7-1/user/-/knowledge_base/u/adapting-your-media-across-multiple-devices}{adapted
images} in your apps, Adaptive Media offers a convenient tag library in
\href{https://github.com/liferay/com-liferay-adaptive-media/tree/master/adaptive-media-image-taglib}{the
module \texttt{com.liferay.adaptive.media.image.taglib}}. This taglib
only has one mandatory attribute: \texttt{fileVersion}. This attribute
indicates the file version of the adapted image that you want to
display. You can also add as many attributes as needed, such as
\texttt{class}, \texttt{style}, \texttt{data-sample}, and so on. Any
attributes you add are then added to the adapted images in the markup
the taglib renders.

This tutorial uses
\href{https://github.com/sergiogonzalez/adaptive-media-samples}{the
Adaptive Media Samples app} to show you how to use this taglib. When
added to a page, this app displays all the adapted images from the
current site's Documents and Media app, provided that
\href{/docs/7-1/user/-/knowledge_base/u/adding-image-resolutions}{Adaptive
Media image resolutions} and Documents and Media images exist.

Follow these steps to use the taglib:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Include the module taglib dependency in your project. If you're using
  Gradle, for example, you must add the following line in your project's
  \texttt{build.gradle} file:

\begin{verbatim}
provided group: "com.liferay", name: "com.liferay.adaptive.media.image.taglib", version: "1.0.0"
\end{verbatim}

  For example,
  \href{https://github.com/sergiogonzalez/adaptive-media-samples/blob/master/adaptive-media-sample-web/build.gradle}{the
  Adaptive Media Samples app's \texttt{build.gradle} file} contains this
  taglib.
\item
  Declare the taglib in your JSP:

\begin{verbatim}
<%@ taglib uri="http://liferay.com/tld/adaptive-media-image" prefix="liferay-adaptive-media" %>
\end{verbatim}

  For example,
  \href{https://github.com/sergiogonzalez/adaptive-media-samples/blob/master/adaptive-media-sample-web/src/main/resources/META-INF/resources/init.jsp}{the
  Adaptive Media Samples app's \texttt{init.jsp}} declares all the
  taglibs the app needs.
\item
  Use the taglib wherever you want the adapted image to appear in your
  app's JSP files:

\begin{verbatim}
<liferay-adaptive-media:img class="img-fluid" fileVersion="<%= fileEntry.getFileVersion() %>" />
\end{verbatim}

  For example,
  \href{https://github.com/sergiogonzalez/adaptive-media-samples/blob/master/adaptive-media-sample-web/src/main/resources/META-INF/resources/view.jsp}{the
  Adaptive Media Samples app's \texttt{view.jsp}} uses the taglib to
  display the adapted images in a grid with the \texttt{col-md-6}
  \href{/docs/7-1/tutorials/-/knowledge_base/t/creating-layout-templates-manually}{column
  container class}. Looking at the markup the app generates, you can see
  that it uses the \texttt{\textless{}picture\textgreater{}} tag as
  described in the article
  \href{/docs/7-1/user/-/knowledge_base/u/creating-content-with-adapted-images}{Creating
  Content with Adapted Images}.

  \begin{figure}
  \centering
  \includegraphics{./images/adaptive-media-sample.png}
  \caption{The Adaptive Media Samples app shows all the site's adapted
  images.}
  \end{figure}
\end{enumerate}

Well done! Now you know how to display adapted images in your app.

\subsection{Related Topics}\label{related-topics-310}

\href{/docs/7-1/tutorials/-/knowledge_base/t/finding-adapted-images}{Finding
Adapted Images}

\href{/docs/7-1/tutorials/-/knowledge_base/t/changing-adaptive-medias-image-scaling}{Changing
Adaptive Media's Image Scaling}

\href{/docs/7-1/user/-/knowledge_base/u/adapting-your-media-across-multiple-devices}{Adapting
Your Media Across Multiple Devices}

\section{Finding Adapted Images}\label{finding-adapted-images}

In most cases, you can rely on the Adaptive Media taglib to
\href{/docs/7-1/tutorials/-/knowledge_base/t/displaying-adapted-images-in-your-app}{display
adapted images in your app}. This taglib uses the file version you give
it to query Adaptive Media's finder API and display the adapted image
appropriate for the device making the request. If you need more control,
however, you can write your own query with the API instead of using the
taglib. For example, if you have an app that needs a specific image in a
specific dimension, it's best to query Adaptive Media's finder API
directly. You can then display the image however you like (e.g., with an
HTML \texttt{\textless{}img\textgreater{}} tag).

Adaptive Media's finder API lets you write queries that get adapted
images based on certain search criteria and filters. For example, you
can get adapted images that match a file version or resolution or are
ordered by an attribute like image width. You can even get adapted
images that match approximate attribute values (\emph{fuzzy}
attributes).

This tutorial shows you how to call Adaptive Media's API to get adapted
images in your app. First, you'll learn how to construct such API calls.

\subsection{Calling Adaptive Media's
API}\label{calling-adaptive-medias-api}

The entry point to Adaptive Media's API is
\href{https://github.com/liferay/com-liferay-adaptive-media/blob/master/adaptive-media-image-api/src/main/java/com/liferay/adaptive/media/image/finder/AMImageFinder.java}{the
\texttt{AMImageFinder} interface}. To use it, you must first inject the
OSGi component in your class, which must also be an OSGi component, as
follows:

\begin{verbatim}
@Reference
private AMImageFinder _amImageFinder;
\end{verbatim}

This makes an \texttt{AMImageFinder} instance available. It has one
method, \texttt{getAdaptiveMediaStream}, that returns a stream of
\texttt{AdaptiveMedia} objects. This method takes a \texttt{Function}
that creates an \texttt{AMQuery} (the query for adapted images) via
\texttt{AMImageQueryBuilder}, which can search adapted images based on
different attributes (e.g., width, height, order, etc.). The
\texttt{AMImageQueryBuilder} methods you call depend on the exact query
you want to construct.

For example, here's a general \texttt{getAdaptiveMediaStream} call:

\begin{verbatim}
Stream<AdaptiveMedia<AMImageProcessor>> adaptiveMediaStream =
    _amImageFinder.getAdaptiveMediaStream(
        amImageQueryBuilder -> amImageQueryBuilder.methodToCall(arg).done());
\end{verbatim}

The argument to \texttt{getAdaptiveMediaStream} is a lambda expression
that returns an \texttt{AMQuery} constructed via
\texttt{AMImageQueryBuilder}. Note that \texttt{methodToCall(arg)} is a
placeholder for the \texttt{AMImageQueryBuilder} method you want to call
and its argument. The exact call depends on the criteria you want to use
to select adapted images. The \texttt{done()} call that follows this,
however, isn't a placeholder--it creates and returns the
\texttt{AMQuery} regardless of which \texttt{AMImageQueryBuilder}
methods you call.

For more information on creating \texttt{AMQuery} instances, see
\href{https://github.com/liferay/com-liferay-adaptive-media/blob/master/adaptive-media-image-api/src/main/java/com/liferay/adaptive/media/image/finder/AMImageQueryBuilder.java}{the
Javadoc for \texttt{AMImageQueryBuilder}}.

Next, you'll see specific examples of constructing calls that get
adapted images.

\subsection{Getting Adapted Images for a Specific File
Version}\label{getting-adapted-images-for-a-specific-file-version}

To get adapted images for a specific file version, you must call the
\texttt{AMImageQueryBuilder} method \texttt{forFileVersion} with a
\href{https://docs.liferay.com/portal/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/repository/model/FileVersion.html}{\texttt{FileVersion}
object} as an argument:

\begin{verbatim}
Stream<AdaptiveMedia<AMImageProcessor>> adaptiveMediaStream =
    _amImageFinder.getAdaptiveMediaStream(
        amImageQueryBuilder -> amImageQueryBuilder.forFileVersion(fileVersion).done());
\end{verbatim}

To get the adapted images for the latest approved file version, use the
\texttt{forFileEntry} method with a
\href{https://docs.liferay.com/portal/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/repository/model/FileVersion.html}{\texttt{FileEntry}
object}:

\begin{verbatim}
Stream<AdaptiveMedia<AMImageProcessor>> adaptiveMediaStream =
    _amImageFinder.getAdaptiveMediaStream(
        amImageQueryBuilder -> amImageQueryBuilder.forFileEntry(fileEntry).done());
\end{verbatim}

Note that these calls only return the adapted images for
\href{/docs/7-0/user/-/knowledge_base/u/managing-image-resolutions}{enabled
image resolutions}. Adapted images for disabled resolutions aren't
included in the stream. To retrieve all adapted images regardless of any
image resolution's status, you must also call the
\texttt{withConfigurationStatus} method with the constant
\texttt{AMImageQueryBuilder.ConfigurationStatus.ANY}:

\begin{verbatim}
Stream<AdaptiveMedia<AMImageProcessor>> adaptiveMediaStream =
    _amImageFinder.getAdaptiveMediaStream(
        amImageQueryBuilder -> amImageQueryBuilder.forFileVersion(fileVersion)
            .withConfigurationStatus(AMImageQueryBuilder.ConfigurationStatus.ANY).done());
\end{verbatim}

To get adapted images for a specific file version when the image
resolution is disabled, make the same call but instead use the constant
\texttt{AMImageQueryBuilder.ConfigurationStatus.DISABLED}:

\begin{verbatim}
Stream<AdaptiveMedia<AMImageProcessor>> adaptiveMediaStream =
    _amImageFinder.getAdaptiveMediaStream(
        amImageQueryBuilder -> amImageQueryBuilder.forFileVersion(fileVersion)
            .withConfigurationStatus(AMImageQueryBuilder.ConfigurationStatus.DISABLED).done());
\end{verbatim}

Next, you'll learn how to get adapted images for a specific image
resolution.

\subsection{Getting the Adapted Images for a Specific Image
Resolution}\label{getting-the-adapted-images-for-a-specific-image-resolution}

By providing an image resolution's UUID to \texttt{AMImageFinder}, you
can get that resolution's adapted images. This UUID is defined when
\href{/docs/7-0/user/-/knowledge_base/u/adding-image-resolutions}{adding
the resolution} in the Adaptive Media app. To get a resolution's adapted
images, you must pass that resolution's UUID to the
\texttt{forConfiguration} method.

For example, this code gets the adapted images that match a file
version, and belong to an image resolution with the UUID
\texttt{hd-resolution}. It returns the adapted images regardless of
whether the resolution is enabled or disabled:

\begin{verbatim}
Stream<AdaptiveMedia<AMImageProcessor>> adaptiveMediaStream =
    _amImageFinder.getAdaptiveMediaStream(
        amImageQueryBuilder -> amImageQueryBuilder.forFileVersion(fileVersion)
            .forConfiguration("hd-resolution").done());
\end{verbatim}

Next, you'll learn how to return adapted images in a specific order.

\subsection{Getting Adapted Images in a Specific
Order}\label{getting-adapted-images-in-a-specific-order}

It's also possible to define the order in which
\texttt{getAdaptiveMediaStream} returns adapted images. To do this, call
the \texttt{orderBy} method with your sort criteria just before calling
the \texttt{done()} method. The \texttt{orderBy} method takes two
arguments: the first specifies the image attribute to sort by (e.g.,
width/height), while the second specifies the sort order (e.g.,
ascending/descending).

For example, this code gets all the adapted images regardless of whether
the image resolution is enabled, and puts them in ascending order by the
image width:

\begin{verbatim}
Stream<AdaptiveMedia<AMImageProcessor>> adaptiveMediaStream =
    _amImageFinderImpl.getAdaptiveMediaStream(
        amImageQueryBuilder -> amImageQueryBuilder.forFileVersion(_fileVersion)
            .withConfigurationStatus(AMImageQueryBuilder.ConfigurationStatus.ANY)
            .orderBy(AMImageAttribute.AM_IMAGE_ATTRIBUTE_WIDTH, AMImageQueryBuilder.SortOrder.ASC)
            .done());
\end{verbatim}

The \texttt{orderBy} arguments
\texttt{AMImageAttribute.AM\_IMAGE\_ATTRIBUTE\_WIDTH} and
\texttt{AMImageQueryBuilder.SortOrder.ASC} specify the image width and
ascending sort, respectively. You can alternatively use
\texttt{AMImageAttribute.AM\_IMAGE\_ATTRIBUTE\_HEIGHT} to sort by image
height, and \texttt{AMImageQueryBuilder.SortOrder.DESC} to perform a
descending sort.

Next, you'll learn how to specify approximate attribute values when
getting adapted images.

\subsection{Getting Adapted Images with Fuzzy
Attributes}\label{getting-adapted-images-with-fuzzy-attributes}

Adaptive Media also lets you get adapted images that match \emph{fuzzy
attributes} (approximate attribute values). For example, fuzzy
attributes let you ask for adapted images whose height is around 200px,
or whose size is around 100kb. The API returns a stream with elements
ordered by how close they are to the specified attribute. For example,
imagine that there are four image resolutions that have adapted images
with the heights 150px, 350px, 600px, and 900px. Searching for adapted
images whose height is approximately 400px returns this order in the
stream: 350px, 600px, 150px, 900px.

So how close, exactly, is \emph{close}? It depends on the attribute. In
the case of width, height, and length, a numeric comparison orders the
images. In the case of content type, file name, or UUID, the comparison
is more tricky because these attributes are strings and thus delegated
to
\href{https://docs.oracle.com/javase/8/docs/api/java/lang/String.html\#compareTo-java.lang.String-}{the
Java \texttt{String.compareTo} method}.

To specify a fuzzy attribute, call the \texttt{with} method with your
search criteria just before calling the \texttt{done()} method. The
\texttt{with} method takes two arguments: the image attribute, and that
attribute's approximate value. For example, this code gets adapted
images whose height
(\texttt{AMImageAttribute.AM\_IMAGE\_ATTRIBUTE\_HEIGHT}) is
approximately 400px:

\begin{verbatim}
Stream<AdaptiveMedia<AMImageProcessor>> adaptiveMediaStream =
    _amImageFinderImpl.getAdaptiveMediaStream(
        amImageQueryBuilder -> amImageQueryBuilder.forFileVersion(_fileVersion)
            .with(AMImageAttribute.AM_IMAGE_ATTRIBUTE_HEIGHT, 400).done());
\end{verbatim}

To search for image width instead, use
\texttt{AMImageAttribute.AM\_IMAGE\_ATTRIBUTE\_WIDTH} as the first
argument to the \texttt{width} method.

\subsection{Using the Adaptive Media
Stream}\label{using-the-adaptive-media-stream}

Once you have the \texttt{AdaptiveMedia} stream, you can get the
information you need from it. For example, this code prints the URI for
each adapted image:

\begin{verbatim}
adaptiveMediaStream.forEach(
    adaptiveMedia -> {
        System.out.println(adaptiveMedia.getURI());
    }
);
\end{verbatim}

You can also get other values and attributes from the
\texttt{AdaptiveMedia} stream. Here are a few examples:

\begin{verbatim}
// Get the InputStream 
adaptiveMedia.getInputStream()

// Get the content length
adaptiveMedia.getValueOptional(AMAttribute.getContentLengthAMAttribute())

// Get the image height
adaptiveMedia.getValueOptional(AMImageAttribute.AM_IMAGE_ATTRIBUTE_HEIGHT)
\end{verbatim}

Awesome! Now you know how to find and use adapted images.

\subsection{Related Topics}\label{related-topics-311}

\href{/docs/7-1/tutorials/-/knowledge_base/t/displaying-adapted-images-in-your-app}{Displaying
Adapted Images in Your App}

\href{/docs/7-1/tutorials/-/knowledge_base/t/changing-adaptive-medias-image-scaling}{Changing
Adaptive Media's Image Scaling}

\href{/docs/7-1/user/-/knowledge_base/u/adapting-your-media-across-multiple-devices}{Adapting
Your Media Across Multiple Devices}

\section{Changing Adaptive Media's Image
Scaling}\label{changing-adaptive-medias-image-scaling}

As described in
\href{/docs/7-1/user/-/knowledge_base/u/adapting-your-media-across-multiple-devices}{the
Adaptive Media user guide}, Adaptive Media scales images to match the
image resolutions defined by the Liferay DXP administrator. The default
scaling is usually suitable, but you can also customize it to your
needs. Before doing so, however, you should understand how this scaling
works.

\subsection{Understanding Image Scaling in Adaptive
Media}\label{understanding-image-scaling-in-adaptive-media}

Adaptive Media contains an extension point that lets you replace the way
it scales images.
\href{https://github.com/liferay/liferay-portal/blob/7.1.x/modules/apps/adaptive-media/adaptive-media-image-api/src/main/java/com/liferay/adaptive/media/image/scaler/AMImageScaler.java}{The
\texttt{AMImageScaler} interface} defines Adaptive Media's image scaling
logic. Out of the box, Adaptive Media provides two implementations of
this interface:

\begin{itemize}
\item
  \href{https://github.com/liferay/liferay-portal/blob/7.1.x/modules/apps/adaptive-media/adaptive-media-image-impl/src/main/java/com/liferay/adaptive/media/image/internal/scaler/AMDefaultImageScaler.java}{\texttt{AMDefaultImageScaler}}:
  The default image scaler. It's always enabled and uses
  \texttt{java.awt} for its image processing and scaling.
\item
  \href{https://github.com/liferay/liferay-portal/blob/7.1.x/modules/apps/adaptive-media/adaptive-media-image-impl/src/main/java/com/liferay/adaptive/media/image/internal/scaler/AMGIFImageScaler.java}{\texttt{AMGIFImageScaler}}:
  A scaler that works only with GIF images. It depends on the
  installation of the external tool
  \href{https://www.lcdf.org/gifsicle/}{gifsicle} in the Liferay DXP
  instance. This scaler must be enabled in \emph{Control Panel} →
  \emph{System Settings}.
\end{itemize}

You must register image scalers in Liferay DXP's OSGi container using
the \texttt{AMImageScaler} interface. Each scaler must also set the
\texttt{mime.type} property to the MIME type it handles. For example, if
you set a scaler's MIME type to \texttt{image/jpeg}, then that scaler
can only handle \texttt{image/jpeg} images. If you specify the special
MIME type \texttt{*}, the scaler can process any image. Note that
\href{https://github.com/liferay/liferay-portal/blob/7.1.x/modules/apps/adaptive-media/adaptive-media-image-impl/src/main/java/com/liferay/adaptive/media/image/internal/scaler/AMDefaultImageScaler.java}{the
\texttt{AMDefaultImageScaler}} is registered using \texttt{mime.type=*},
while
\href{https://github.com/liferay/liferay-portal/blob/7.1.x/modules/apps/adaptive-media/adaptive-media-image-impl/src/main/java/com/liferay/adaptive/media/image/internal/scaler/AMGIFImageScaler.java}{the
\texttt{AMGIFImageScaler}} is registered using
\texttt{mime.type=image/gif}. Both scalers, like all scalers, implement
\texttt{AMImageScaler}.

You can add as many image scalers as you need, even for the same MIME
type. Even so, Adaptive Media uses only one scaler per image, using this
process to determine the best one:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Select only the image scalers registered with the same MIME type as
  the image.
\item
  Select the enabled scalers from those selected in the first step
  (\href{https://github.com/liferay/liferay-portal/blob/7.1.x/modules/apps/adaptive-media/adaptive-media-image-api/src/main/java/com/liferay/adaptive/media/image/scaler/AMImageScaler.java}{the
  \texttt{AMImageScaler}} method \texttt{isEnabled()} returns
  \texttt{true} for enabled scalers).
\item
  Of the scalers selected in the second step, select the scaler with the
  highest \texttt{service.ranking}.
\end{enumerate}

If these steps return no results, they're repeated, but the first step
uses the special MIME type \texttt{*}. Also note that if an image scaler
is registered for specific MIME types and has a higher
\texttt{service.ranking}, it's more likely to be chosen than if it's
registered for the special MIME type \texttt{*} or has a lower
\texttt{service.ranking}.

\subsection{Creating an Image Scaler}\label{creating-an-image-scaler}

Now that you know how Adaptive Media scales images, you'll learn how to
customize this scaling. As an example, you'll see a sample image scaler
that customizes the scaling of PNG images.

Follow these steps to create a custom image scaler:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Create your scaler class to implement \texttt{AMImageScaler}. You must
  also annotate your scaler class with \texttt{@Component}, setting
  \texttt{mime.type} properties for each of the scaler's MIME types, and
  registering an \texttt{AMImageScaler} service. If there's more than
  one scaler for the same MIME type, you must also set the
  \texttt{@Component} annotation's \texttt{service.ranking} property.
  For your scaler to take precedence over other scalers of the same MIME
  type, its service ranking property must be higher than that of the
  other scalers. If \texttt{service.ranking} isn't set, it defaults to
  \texttt{0}.
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** The `service.ranking` property isn't set for the image scalers
 included with Adaptive Media (`AMDefaultImageScaler` and
 `AMGIFImageScaler`). Their service ranking therefore defaults to `0`. To
 replace either scaler, you must set your scaler to the same MIME type and
 give it a service ranking higher than `0`.
\end{verbatim}

\noindent\hrulefill

\begin{verbatim}
For example, this sample image scaler scales PNG and x-PNG images, and has a
service ranking of `100`:

    @Component(
        immediate = true,
        property = {"mime.type=image/png", "mime.type=image/x-png", "service.ranking:Integer=100"},
        service = {AMImageScaler.class}
    )
    public class SampleAMPNGImageScaler implements AMImageScaler {...

This requires these imports:

    import com.liferay.adaptive.media.image.scaler.AMImageScaler;
    import org.osgi.service.component.annotations.Component;
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\item
  Implement the \texttt{isEnabled()} method to return \texttt{true} when
  you want to enable the scaler. In many cases, you always want the
  scaler enabled, so you can simply return \texttt{true} in this method.
  This is the case with the example \texttt{SampleAMPNGImageScaler}:

\begin{verbatim}
@Override
public boolean isEnabled() {
    return true;
}
\end{verbatim}

  This method gets more interesting when the scaler depends on other
  tools or features. For example, the \texttt{isEnabled()} method in
  \texttt{AMGIFImageScaler} determines whether gifsicle is enabled. This
  scaler must only be enabled when the tool it depends on, gifsicle, is
  also enabled:

\begin{verbatim}
@Override
public boolean isEnabled() {
    return _amImageConfiguration.gifsicleEnabled();
}
\end{verbatim}
\item
  Implement the \texttt{scaleImage} method. This method contains the
  scaler's business logic, and must return an
  \texttt{AMImageScaledImage} instance. For example, the example
  \texttt{scaleImage} implementation in \texttt{SampleAMPNGImageScaler}
  uses \texttt{AMImageConfigurationEntry} to get the maximum height and
  width values for the scaled image, and \texttt{FileVersion} to get the
  image to scale. The scaling is done with the help of a private inner
  class, assuming that the methods \texttt{\_scalePNG},
  \texttt{\_getScalePNGHeight}, \texttt{\_getScalePNGWidth}, and
  \texttt{\_getScalePNGSize} implement the actual scaling:

\begin{verbatim}
@Override
public AMImageScaledImage scaleImage(FileVersion fileVersion,
    AMImageConfigurationEntry amImageConfigurationEntry) {

    Map<String, String> properties = amImageConfigurationEntry.getProperties();

    int maxHeight = GetterUtil.getInteger(properties.get("max-height"));
    int maxWidth = GetterUtil.getInteger(properties.get("max-width"));

    try {
        InputStream inputStream =
            _scalePNG(fileVersion.getContentStream(false), maxHeight, maxWidth);

        int height = _getScalePNGHeight();
        int width = _getScalePNGWidth();
        long size = _getScalePNGSize();

        return new AMImageScaledImageImpl(inputStream, height, width, size);
    }
    catch (PortalException pe) {
        throw new AMRuntimeException.IOException(pe);
    }
}

private class AMImageScaledImageImpl implements AMImageScaledImage {

    @Override
    public int getHeight() {
        return _height;
    }

    @Override
    public InputStream getInputStream() {
        return _inputStream;
    }

    @Override
    public long getSize() {
        return _size;
    }

    @Override
    public int getWidth() {
        return _width;
    }

    private AMImageScaledImageImpl(InputStream inputStream, int height,
        int width, long size) {

        _inputStream = inputStream;
        _height = height;
        _width = width;
        _size = size;
    }

    private final int _height;
    private final InputStream _inputStream;
    private final long _size;
    private final int _width;

}
\end{verbatim}

  This requires these imports:

\begin{verbatim}
import com.liferay.adaptive.media.exception.AMRuntimeException;
import com.liferay.adaptive.media.image.configuration.AMImageConfigurationEntry;
import com.liferay.adaptive.media.image.scaler.AMImageScaledImage;
import com.liferay.portal.kernel.exception.PortalException;
import com.liferay.portal.kernel.repository.model.FileVersion;
import com.liferay.portal.kernel.util.GetterUtil;
import java.io.InputStream;
import java.util.Map;
\end{verbatim}
\end{enumerate}

Great! Now you know how to write your own image scalers.

\subsection{Related Topics}\label{related-topics-312}

\href{/docs/7-1/tutorials/-/knowledge_base/t/displaying-adapted-images-in-your-app}{Displaying
Adapted Images in Your App}

\href{/docs/7-1/tutorials/-/knowledge_base/t/finding-adapted-images}{Finding
Adapted Images}

\href{/docs/7-1/user/-/knowledge_base/u/adapting-your-media-across-multiple-devices}{Adapting
Your Media Across Multiple Devices}

\chapter{Social API}\label{social-api}

The social API lets users interact with content throughout the portal,
including content in your applications. For example, users can provide
feedback on content, share that content with others, subscribe to
receive notifications, and more. These features let users stay up to
date on the latest and greatest that you have to share.

The tutorials that follow show you how to take advantage of this social
API to enable these features in your own app.

\section{Applying Social Bookmarks}\label{applying-social-bookmarks}

When you enable social bookmarks, icons for sharing on Twitter,
Facebook, and Google Plus appear below your application's content.
Taglibs provide the markup you need to add this feature to your app.

\begin{figure}
\centering
\includegraphics{./images/social-bookmarks-inline.png}
\caption{Social bookmarks are enabled in the built-in Blogs portlet}
\end{figure}

Follow these steps to add social bookmarks to your app:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Make sure your entity is
  \href{/docs/7-1/tutorials/-/knowledge_base/t/asset-framework}{asset
  enabled}.
\item
  In your project's \texttt{build.gradle} file, add a dependency to the
  module
  \href{https://repository.liferay.com/nexus/content/repositories/liferay-public-releases/com/liferay/com.liferay.social.bookmarks.taglib/}{\texttt{com.liferay.social.bookmarks.taglib}}:

\begin{verbatim}
compileOnly group: "com.liferay", name: "com.liferay.social.bookmarks.taglib", version: "1.0.0"
\end{verbatim}
\item
  Choose a view in which to show the social bookmarks. For example, you
  can display them in one of your portlet's views.
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** You don't need to implement social bookmarks in your portlet's
 [asset renderers](/docs/7-1/tutorials/-/knowledge_base/t/rendering-an-asset).
 The Asset Publisher displays social bookmarks in asset renderers by default.
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{3}
\item
  In your view's JSP, include the \texttt{liferay-social-bookmarks}
  taglib declaration:

\begin{verbatim}
<%@ taglib uri="http://liferay.com/tld/social-bookmarks" prefix="liferay-social-bookmarks" %>
\end{verbatim}
\item
  Get an instance of your entity. You can do this however you wish. This
  example uses \texttt{ParamUtil} to get the entity's ID from the render
  request, then uses the entity's \texttt{-LocalServiceUtil} class to
  create an entity object:

\begin{verbatim}
<%
long entryId = ParamUtil.getLong(renderRequest, "entryId");
entry = EntryLocalServiceUtil.getEntry(entryId);
%>
\end{verbatim}
\item
  Use the \texttt{liferay-social-bookmarks:bookmarks} tag to add the
  social bookmarks component. Its attributes are described below:
\end{enumerate}

\texttt{className}: The entity's class name.

\texttt{classPK}: The Java class primary key of the entity.

\texttt{displayStyle}: The display style of the social bookmarks.
Possible values are \texttt{inline}, which displays them in a row, and
\texttt{menu}, which hides them in a menu.

\texttt{title}: A title for the content being shared.

\texttt{types}: A comma-delimited list of the social media services to
use (e.g., \texttt{facebook,twitter}). To use every social media service
available in the portal, omit this attribute or use
\texttt{\textless{}\%=\ null\ \%\textgreater{}} for its value.

\texttt{url}: A URL to the portal content being shared.

Here's an example of using the
\texttt{liferay-social-bookmarks:bookmarks} tag to add social bookmarks
for a blog entry in the Blogs app:

\begin{verbatim}
<liferay-social-bookmarks:bookmarks
        className="<%= BlogsEntry.class.getName() %>"
        classPK="<%= entry.getEntryId() %>"
        displayStyle="inline"
        title="<%= entry.getTitle() %>"
        types="facebook,twitter"
        url="<%= PortalUtil.getCanonicalURL(bookmarkURL.toString(), themeDisplay, layout) %>"
/>
\end{verbatim}

The \texttt{displayStyle} in this example is set to \texttt{inline}. The
screenshot at the beginning of this tutorial shows what this looks like.
The first three social bookmarks appear in a row, and the rest appear in
the \emph{Share} menu. If you use \texttt{menu} instead, all the social
bookmarks appear in the menu.

\begin{figure}
\centering
\includegraphics{./images/social-bookmarks-menu.png}
\caption{With \texttt{displayStyle} set to \texttt{menu}, the social
bookmarks all appear in the \emph{Share} menu.}
\end{figure}

The \texttt{title} is retrieved by the entry's \texttt{getTitle()}
method. Keep in mind that you should retrieve your entity's title with
the appropriate method for that entity.

Note that the \texttt{PortalUtil} method \texttt{getCanonicalURL} is
called for the \texttt{url}. This method constructs an SEO-friendly URL
from the page's full URL. For more information, see the
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/util/PortalUtil.html\#getCanonicalURL-java.lang.String-com.liferay.portal.kernel.theme.ThemeDisplay-com.liferay.portal.kernel.model.Layout-}{method's
Javadoc}.

\subsection{Related Topics}\label{related-topics-313}

\href{/docs/7-1/tutorials/-/knowledge_base/t/asset-framework}{Asset
Framework}

\section{Creating Social Bookmarks}\label{creating-social-bookmarks}

\href{/docs/7-1/tutorials/-/knowledge_base/t/applying-social-bookmarks}{Applying
social bookmarks} lets you link your app's content to the social
networks of your choice. By default, Liferay DXP supports social
bookmarks for Twitter, Facebook, LinkedIn, and Google Plus. You can also
create your own social bookmark by registering a component that
implements the \texttt{SocialBookmark} interface from the module
\texttt{com.liferay.social.bookmarks.api}. This tutorial shows you how
to do this.

\subsection{Implementing the SocialBookmark
Interface}\label{implementing-the-socialbookmark-interface}

Follow these steps to implement the \texttt{SocialBookmark} interface:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create your \texttt{*SocialBookmark} class and register a component
  that defines the \texttt{social.bookmarks.type} property. This
  property's value is what you enter for the
  \texttt{liferay-social-bookmarks:bookmarks} tag's \texttt{type}
  attribute when you use your social bookmark.

  For example, here's the definition for a Twitter social bookmark
  class:

\begin{verbatim}
@Component(immediate = true, property = "social.bookmarks.type=twitter")
public class TwitterSocialBookmark implements SocialBookmark {...
\end{verbatim}
\item
  Create a
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/util/ResourceBundleLoader.html}{\texttt{ResourceBundleLoader}}
  reference to help localize the social bookmark's name.

\begin{verbatim}
@Reference(
        target = "(bundle.symbolic.name=com.liferay.social.bookmark.twitter)"
)
private ResourceBundleLoader _resourceBundleLoader;
\end{verbatim}
\item
  Implement the \texttt{getName} method to return the social bookmark's
  name as a \texttt{String}. This method takes a
  \href{https://docs.oracle.com/javase/8/docs/api/java/util/Locale.html}{\texttt{Locale}}
  object that you can use for localization via
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/language/LanguageUtil.html}{\texttt{LanguageUtil}}
  and
  \href{https://docs.oracle.com/javase/8/docs/api/java/util/ResourceBundle.html}{\texttt{ResourceBundle}}:

\begin{verbatim}
@Override
public String getName(Locale locale) {
    ResourceBundle resourceBundle = _resourceBundleLoader.loadResourceBundle(locale);

    return LanguageUtil.get(resourceBundle, "twitter");
}
\end{verbatim}
\item
  Implement the \texttt{getPostURL} method to return the share URL. This
  method constructs the share URL from a title and URL, and uses
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/util/URLCodec.html}{\texttt{URLCodec}}
  to encode the title in the URL:

\begin{verbatim}
@Override
public String getPostURL(String title, String url) {
    return String.format(
        "https://twitter.com/intent/tweet?text=%s&tw_p=tweetbutton&url=%s", 
        URLCodec.encodeURL(title), url);
}
\end{verbatim}
\item
  Create a \texttt{ServletContext} reference:

\begin{verbatim}
@Reference(
        target = "(osgi.web.symbolicname=com.liferay.social.bookmark.twitter)"
)
private ServletContext _servletContext;
\end{verbatim}
\item
  Implement the \texttt{render} method, which is called when the inline
  display style is selected. Typically, this method renders a link to
  the share URL (e.g., a share button), but you can use it for whatever
  you need. To keep a consistent look and feel with the default social
  bookmarks, you can use a
  \href{/docs/7-1/tutorials/-/knowledge_base/t/clay-icons}{Clay icon}.

  This example gets a \texttt{RequestDispatcher} for the JSP that
  contains a Clay icon (\texttt{page.jsp}), and then includes that JSP
  in the response:

\begin{verbatim}
@Override
public void render(
                String target, String title, String url, HttpServletRequest request,
                HttpServletResponse response)
        throws IOException, ServletException {

        RequestDispatcher requestDispatcher =
                _servletContext.getRequestDispatcher("/page.jsp");

        requestDispatcher.include(request, response);
}
\end{verbatim}
\end{enumerate}

Next, you'll see an example of how to create a \texttt{page.jsp} file.

\subsection{Creating Your JSP}\label{creating-your-jsp}

The \texttt{page.jsp} file referenced in the above
\texttt{SocialBookmark} implementation uses
\href{/docs/7-1/tutorials/-/knowledge_base/t/clay-labels-and-links}{a
Clay link} (\texttt{clay:link}) to specify and style the Twitter icon
included with Clay. Follow these steps to create a JSP for your own
social bookmark:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add the \texttt{clay} and \texttt{liferay-theme} taglib declarations:

\begin{verbatim}
<%@ taglib uri="http://liferay.com/tld/clay" prefix="clay" %>
<%@ taglib uri="http://liferay.com/tld/theme" prefix="liferay-theme" %>
\end{verbatim}
\item
  Import
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/util/GetterUtil.html}{\texttt{GetterUtil}}
  and \texttt{SocialBookmark}:

\begin{verbatim}
<%@ page import="com.liferay.portal.kernel.util.GetterUtil" %>
<%@ page import="com.liferay.social.bookmarks.SocialBookmark" %>
\end{verbatim}
\item
  From the request, get a \texttt{SocialBookmark} instance and the
  social bookmark's title and URL:

\begin{verbatim}
<%
SocialBookmark socialBookmark = (SocialBookmark)request.getAttribute("liferay-social-bookmarks:bookmark:socialBookmark");
String title = GetterUtil.getString((String)request.getAttribute("liferay-social-bookmarks:bookmark:title"));
String url = GetterUtil.getString((String)request.getAttribute("liferay-social-bookmarks:bookmark:url"));
%>
\end{verbatim}

  The title and URL are set via the \texttt{liferay-social-bookmarks}
  tag library when
  \href{/docs/7-1/tutorials/-/knowledge_base/t/applying-social-bookmarks}{applying
  the social bookmark}.
\item
  Add the Clay link. This example sets the following \texttt{clay:link}
  attributes:

  \begin{itemize}
  \item
    \texttt{buttonStyle}: This example renders
    \href{/docs/7-1/tutorials/-/knowledge_base/t/clay-buttons\#types}{The
    button's type} as a secondary button.
  \item
    \texttt{elementClasses}: The custom CSS to use for styling the
    button (optional).
  \item
    \texttt{href}: The button's URL. You should specify this by calling
    your \texttt{SocialBookmark} instance's \texttt{getPostURL} method.
  \item
    \texttt{icon}: The button's icon. This example specifies the Twitter
    icon included in Clay (\texttt{twitter}).
  \item
    \texttt{title}: The button's title. This example uses the
    \texttt{SocialBookmark} instance's \texttt{getName} method.

\begin{verbatim}
<clay:link
        buttonStyle="secondary"
        elementClasses="btn-outline-borderless btn-sm lfr-portal-tooltip"
        href="<%= socialBookmark.getPostURL(title, url) %>"
        icon="twitter"
        title="<%= socialBookmark.getName(locale) %>"
/>
\end{verbatim}
  \end{itemize}
\end{enumerate}

To see a complete, real-world example of a social bookmark
implementation, see
\href{https://github.com/liferay/liferay-portal/tree/7.1.x/modules/apps/social/social-bookmark-twitter}{Liferay's
Twitter social bookmark code}.

\subsection{Related Topics}\label{related-topics-314}

\href{/docs/7-1/tutorials/-/knowledge_base/t/applying-social-bookmarks}{Applying
Social Bookmarks}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-the-clay-taglib-in-your-portlets}{Using
the Clay Taglib in Your Portlets}

\section{Adding Comments to Your App}\label{adding-comments-to-your-app}

Letting users comment on content makes your app come alive. Taglibs
provide the markup you need to add this feature. This tutorial shows you
how to use these taglibs to enable comments.

These steps use a sample Guestbook app as an example:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Make sure your entity is
  \href{/docs/7-1/tutorials/-/knowledge_base/t/asset-framework}{asset
  enabled}.
\item
  Choose a read-only view of the entity you want to enable comments on.
  You can display the comments component in your app's view, or if
  you've
  \href{/docs/7-1/tutorials/-/knowledge_base/t/rendering-an-asset}{implemented
  asset rendering} you can display it in the full content view in the
  Asset Publisher app.
\item
  Include the \texttt{liferay-ui}, \texttt{liferay-comment}, and
  \texttt{portlet} taglib declarations in your JSP:

\begin{verbatim}
<%@ taglib prefix="liferay-ui" uri="http://liferay.com/tld/ui" %>
<%@ taglib prefix="liferay-comment" uri="http://liferay.com/tld/comment" %>
<%@ taglib prefix="portlet" uri="http://java.sun.com/portlet_2_0" %>
\end{verbatim}
\item
  Use \texttt{ParamUtil} to get the entity's ID from the render request.
  Then create an entity object using the \texttt{-LocalServiceUtil}
  class. Here's an example that does this for a guestbook entry in the
  example Guestbook app:

\begin{verbatim}
<%
long entryId = ParamUtil.getLong(renderRequest, "entryId");
entry = EntryLocalServiceUtil.getEntry(entryId);
%>
\end{verbatim}
\item
  Create a collapsible panel for the comments using the
  \texttt{liferay-ui:panel-container} and \texttt{liferay-ui:panel}
  tags. This lets users hide the discussion area:

\begin{verbatim}
<liferay-ui:panel-container extended="<%=false%>"
  id="guestbookCollaborationPanelContainer" persistState="<%=true%>">
  <liferay-ui:panel collapsible="<%=true%>" extended="<%=true%>"
    id="guestbookCollaborationPanel" persistState="<%=true%>"
    title="Collaboration">
\end{verbatim}
\item
  Create a URL for the discussion using the \texttt{portlet:actionURL}
  tag:

\begin{verbatim}
<portlet:actionURL name="invokeTaglibDiscussion" var="discussionURL" />
\end{verbatim}
\item
  Use the \texttt{liferay-comment:discussion} tag to add the discussion.
  To let the user return to the JSP after making a comment, set the
  tag's \texttt{redirect} attribute to the current URL. You can use
  \texttt{PortalUtil.getCurrentURL((renderRequest))} to get the current
  URL from the \texttt{request} object. In this example, the current URL
  was earlier set to the \texttt{currentURL} variable:

\begin{verbatim}
    <liferay-comment:discussion className="<%=Entry.class.getName()%>"
      classPK="<%=entry.getEntryId()%>"
      formAction="<%=discussionURL%>" formName="fm2"
      ratingsEnabled="<%=true%>" redirect="<%=currentURL%>"
      userId="<%=entry.getUserId()%>" />

  </liferay-ui:panel>
</liferay-ui:panel-container>
\end{verbatim}
\end{enumerate}

If you haven't already connected your portlet's view to the JSP for your
entity,
\href{/docs/7-1/tutorials/-/knowledge_base/t/configuring-jsp-templates-for-an-asset-renderer}{see
the tutorial on Configuring JSP Templates}.

Great! Now you know how to let users comment on content in your asset
enabled portlets.

\subsection{Related Topics}\label{related-topics-315}

\href{/docs/7-1/tutorials/-/knowledge_base/t/asset-framework}{Asset
Framework}

\href{/docs/7-1/tutorials/-/knowledge_base/t/rating-assets}{Rating
Assets}

\section{Rating Assets}\label{rating-assets}

\href{/docs/7-1/tutorials/-/knowledge_base/t/asset-framework}{The asset
framework} supports a system that lets users rate content in apps. This
feature appears in many of Liferay DXP's built-in apps. For example,
users can rate articles published in the Blogs app. Using taglibs, you
can enable ratings for your app's content in only a few lines of code.
This tutorial shows you how.

\begin{figure}
\centering
\includegraphics{./images/social-ratings-thumbs.png}
\caption{Ratings let users quickly provide feedback on content.}
\end{figure}

Follow these steps to enable ratings in your app. Note that these steps
use the Guestbook app as an example. As its name implies, this app lets
users leave simple messages in a guestbook.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Make sure your entity is
  \href{/docs/7-1/tutorials/-/knowledge_base/t/asset-framework}{asset
  enabled}.
\item
  Choose a read-only view of the entity for which you want to enable
  ratings. You can display ratings in one of your portlet's views, or if
  you've
  \href{/docs/7-1/tutorials/-/knowledge_base/t/rendering-an-asset}{implemented
  asset rendering} you can display them in the full content view in the
  Asset Publisher app.
\item
  In the JSP, include the \texttt{liferay-ui} taglib declaration:

\begin{verbatim}
<%@ taglib prefix="liferay-ui" uri="http://liferay.com/tld/ui" %>
\end{verbatim}
\item
  Use \texttt{ParamUtil} to get the entity's ID from the render request.
  Then create an entity object using the \texttt{-LocalServiceUtil}
  class. Here's an example that does this for a guestbook entry in the
  example Guestbook app:

\begin{verbatim}
<%
long entryId = ParamUtil.getLong(renderRequest, "entryId");
entry = EntryLocalServiceUtil.getEntry(entryId);
%>
\end{verbatim}
\item
  Use the \texttt{liferay-ui:ratings} tag to add the ratings component
  for the entity:

\begin{verbatim}
<liferay-ui:ratings className="<%=Entry.class.getName()%>"
    classPK="<%=entry.getEntryId()%>" type="stars" />
\end{verbatim}

  The \texttt{type} attribute specifies the rating system to use:

  \begin{itemize}
  \tightlist
  \item
    \texttt{like}: Likes
  \item
    \texttt{stars}: Stars (five, by default)
  \item
    \texttt{thumbs}: Thumbs up/down (as shown in the above screenshot)
  \end{itemize}

  You can also make the rating type configurable by administrators. To
  do this, see the tutorial
  \href{/docs/7-1/tutorials/-/knowledge_base/t/implementing-ratings-type-selection-and-value-transformation}{Implementing
  Ratings Type Selection and Value Type Transformation}.
\end{enumerate}

Great! Now you know how to let users rate content in your asset-enabled
apps.

\subsection{Related Topics}\label{related-topics-316}

\href{/docs/7-1/tutorials/-/knowledge_base/t/asset-framework}{Asset
Framework}

\href{/docs/7-1/tutorials/-/knowledge_base/t/implementing-ratings-type-selection-and-value-transformation}{Implementing
Ratings Type Selection and Value Transformation}

\section{Implementing Ratings Type Selection and Value
Transformation}\label{implementing-ratings-type-selection-and-value-transformation}

Liferay DXP has three different mechanisms for rating content:

\begin{itemize}
\tightlist
\item
  Likes
\item
  Stars
\item
  Thumbs (up/down)
\end{itemize}

Prior to 7.0, there was no way for portal or site administrators to
select a rating type--it was hard-coded in each app. In 7.0 and later,
admins can select the rating type for an app's entities via the Control
Panel and Site Administration:

\begin{itemize}
\tightlist
\item
  \textbf{Portal admins:} can set the default rating type for the portal
\item
  \textbf{Site admins:} can override the default rating type for their
  site
\end{itemize}

All Liferay apps leverage this feature. Your apps can too: this tutorial
shows you how.

\subsection{Specifying an Entity's Rating
Type}\label{specifying-an-entitys-rating-type}

A custom app that uses ratings must define its rating type in an OSGi
component that implements the \texttt{PortletRatingsDefinition}
interface. This class declares the usage of ratings (specifying the
portlet and the entity) and the default rating type (that can be
overridden by portal and site admins).

Follow these steps to implement \texttt{PortletRatingsDefinition} to
define your app's rating type:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Register the class as an OSGi component and set the
  \texttt{model.class.name} property to the fully qualified class name
  of the class that will use this rating definition. For example, this
  example rating definition is for a blog entry, so the
  \texttt{model.class.name} property is set to
  \texttt{com.liferay.portlet.blogs.model.BlogsEntry}:

\begin{verbatim}
@Component(
    property = {
        "model.class.name=com.liferay.portlet.blogs.model.BlogsEntry"
    }
)
public class BlogsPortletRatingsDefinition implements PortletRatingsDefinition {...
\end{verbatim}
\item
  The \texttt{PortletRatingsDefinition} interface has two methods that
  you must implement:

  \begin{itemize}
  \item
    \texttt{getDefaultRatingsType}: returns the entity's default rating
    type, which portal and site admins can override. You can do this via
    the
    \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/ratings/kernel/RatingsType.html}{\texttt{RatingsType}
    enum}, which lets you use \texttt{LIKE}, \texttt{STARS}, or
    \texttt{THUMBS} to set the rating type:

\begin{verbatim}
@Override
public RatingsType getDefaultRatingsType() {
    return RatingsType.THUMBS;
}
\end{verbatim}
  \item
    \texttt{getPortletId}: returns the portlet ID of the main portlet
    that uses the entity. You can do this via the
    \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/util/PortletKeys.html}{\texttt{PortletKeys}
    enum}, which defines many constants that correspond to the portlet
    IDs of the built-in portlets. This example specifies the Blogs
    portlet:

\begin{verbatim}
@Override
public String getPortletId() {
    return PortletKeys.BLOGS;
}
\end{verbatim}
  \end{itemize}
\end{enumerate}

Next, you'll learn how to transform values between rating types.

\subsection{Transforming Ratings Values Between Rating
Types}\label{transforming-ratings-values-between-rating-types}

The rating values are stored in the database as normalized values. This
permits switching among different rating types without modifying the
underlying data. When administrators change an entity's rating type, its
best match is computed. Here's a list of the default transformations
between rating types:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  When changing from stars to:

  \begin{itemize}
  \tightlist
  \item
    \textbf{Like:} A value of 3, 4, or 5 stars is considered a like; a
    value of 1 or 2 stars is omitted.
  \item
    \textbf{Thumbs up/down:} A value of 3, 4, or 5 stars is considered a
    thumbs up; a value of 1 or 2 stars is considered a thumbs down.
  \end{itemize}
\item
  When changing from thumbs up/down to:

  \begin{itemize}
  \tightlist
  \item
    \textbf{Like:} A like is considered a thumbs up.
  \item
    \textbf{Stars:} A thumbs down is considered 1 star; a thumbs up is
    considered 5 stars.
  \end{itemize}
\item
  When changing from like to:

  \begin{itemize}
  \tightlist
  \item
    \textbf{Stars:} A like is considered 5 stars.
  \item
    \textbf{Thumbs up/down:} A like is considered a thumbs up.
  \end{itemize}
\end{enumerate}

There may be some cases, however, where you want to apply different
criteria to determine the new rating values. A mechanism exists to let
you do this, but it modifies the stored rating values. To define such
transformations, create an OSGi component that implements the
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/ratings/kernel/transformer/RatingsDataTransformer.html}{\texttt{RatingsDataTransformer}
interface}.

\noindent\hrulefill

\textbf{Note:} The portal doesn't provide a default
\texttt{RatingsDataTransformer} implementation. Unless you provide such
an implementation, the stored rating values always remain the same while
the portal interprets existing values for the selected rating type.

\noindent\hrulefill

When implementing \texttt{RatingsDataTransformer}, implement the
\texttt{transformRatingsData} method to transform the data. This
method's arguments include the \texttt{RatingsType} variables
\texttt{fromRatingsType} and \texttt{toRatingsType}, which contain the
rating type to transform from and to, respectively. These values let you
write your custom transformation's logic. You can write this logic by
implementing the interface
\texttt{ActionableDynamicQuery.PerformActionMethod} as an anonymous
inner class in the \texttt{transformRatingsData} method, implementing
the \texttt{performAction} method with your transformation's logic.

For example, follow these steps to implement a
\texttt{RatingsDataTransformer}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create an OSGi component class that implements
  \texttt{RatingsDataTransformer}:

\begin{verbatim}
@Component
public class DummyRatingsDataTransformer implements RatingsDataTransformer {...
\end{verbatim}
\item
  In this class, implement the \texttt{transformRatingsData} method.
  Note that it contains the \texttt{RatingsType} variables
  \texttt{fromRatingsType} and \texttt{toRatingsType}:

\begin{verbatim}
@Override
public ActionableDynamicQuery.PerformActionMethod transformRatingsData(
        final RatingsType fromRatingsType, final RatingsType toRatingsType)
    throws PortalException {

}
\end{verbatim}
\item
  In the \texttt{transformRatingsData} method, implement the interface
  \texttt{ActionableDynamicQuery.PerformActionMethod} as an anonymous
  inner class:

\begin{verbatim}
return new ActionableDynamicQuery.PerformActionMethod() {

};
\end{verbatim}
\item
  In the anonymous \texttt{ActionableDynamicQuery.PerformActionMethod}
  implementation, implement the \texttt{performAction} method to perform
  your transformation. This example irreversibly transforms the rating
  type from like to stars, resetting the value to \texttt{0}. The
  \texttt{if} statement uses the \texttt{fromRatingsType} and
  \texttt{toRatingsType} values to specify that the transformation only
  occurs when going from likes to stars. The transformation is performed
  via \texttt{RatingsEntry} and its \texttt{-LocalServiceUtil}. After
  getting a
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/ratings/kernel/model/RatingsEntry.html}{\texttt{RatingsEntry}
  object}, its \texttt{setScore} method sets the rating score to
  \texttt{0}.
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/ratings/kernel/service/RatingsEntryLocalServiceUtil.html}{The
  \texttt{RatingsEntryLocalServiceUtil}} method
  \texttt{updateRatingsEntry} then updates the \texttt{RatingsEntry} in
  the database:

\begin{verbatim}
@Override
public void performAction(Object object)
    throws PortalException {

    if (fromRatingsType.getValue().equals(RatingsType.LIKE) &&
        toRatingsType.getValue().equals(RatingsType.STARS)) {

        RatingsEntry ratingsEntry = (RatingsEntry) object;

        ratingsEntry.setScore(0);

        RatingsEntryLocalServiceUtil.updateRatingsEntry(
            ratingsEntry);
    }
}
\end{verbatim}
\end{enumerate}

Here's the complete class for this example:

\begin{verbatim}
@Component
public class DummyRatingsDataTransformer implements RatingsDataTransformer {
    @Override
    public ActionableDynamicQuery.PerformActionMethod transformRatingsData(
            final RatingsType fromRatingsType, final RatingsType toRatingsType)
        throws PortalException {

        return new ActionableDynamicQuery.PerformActionMethod() {

            @Override
            public void performAction(Object object)
                throws PortalException {

                if (fromRatingsType.getValue().equals(RatingsType.LIKE) &&
                    toRatingsType.getValue().equals(RatingsType.STARS)) {

                    RatingsEntry ratingsEntry = (RatingsEntry) object;

                    ratingsEntry.setScore(0);

                    RatingsEntryLocalServiceUtil.updateRatingsEntry(
                        ratingsEntry);
                }
            }
        };
    }

}
\end{verbatim}

Once you've implemented ratings type selection and value type
transformation for your app's entities, you can configure the default
ratings type values through the Control Panel by going to
\emph{Configuration} → \emph{Instance Settings}, and selecting the
\emph{Social} tab. To override the default values for a site, go to Site
Administration → \emph{Configuration} → \emph{Site Settings}, and select
the \emph{Social} tab.

Nice work! Now you know how to set an entity's rating type. You also
know how to implement a rating data transformer. We salute you with a
thumbs up!

\subsection{Related Topics}\label{related-topics-317}

\href{/docs/7-1/tutorials/-/knowledge_base/t/asset-framework}{Asset
Framework}

\href{/docs/7-1/tutorials/-/knowledge_base/t/rating-assets}{Rating
Assets}

\section{Flagging Inappropriate Asset
Content}\label{flagging-inappropriate-asset-content}

In a perfect world, people would post nice, kind, and decent content.
They would reply to comments with constructive feedback and never lash
out at each other. Unfortunately, sometimes people have a bad day and
decide to take their frustrations out in inappropriate posts. No worries
though, the asset framework supports a system for flagging content in
apps. Letting users flag inappropriate content takes much of the work
off site administrators.

This tutorial shows you how to enable content flagging in a portlet.

\begin{figure}
\centering
\includegraphics{./images/social-flags.png}
\caption{Flags for letting users mark objectionable content are enabled
in the Message Boards portlet.}
\end{figure}

Follow these steps to enable content flagging in your app:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Make sure your entity is
  \href{/docs/7-0/tutorials/-/knowledge_base/t/asset-framework}{asset
  enabled}.
\item
  Choose a read-only view of the entity you want to enable flags on. You
  can display flags in one of your app's views, or if you've
  \href{/docs/7-1/tutorials/-/knowledge_base/t/rendering-an-asset}{implemented
  asset rendering} you can display it in the full content view in the
  Asset Publisher app.
\item
  In your JSP, include the \texttt{liferay-flags} taglib declaration:

\begin{verbatim}
<%@ taglib prefix="liferay-flags" uri="http://liferay.com/tld/flags" %>
\end{verbatim}
\item
  Use \texttt{ParamUtil} to get the entity's ID from the render request.
  Then use your \texttt{-LocalServiceUtil} class to create an entity
  object:

\begin{verbatim}
<%
long entryId = ParamUtil.getLong(renderRequest, "entryId");
entry = EntryLocalServiceUtil.getEntry(entryId);
%>
\end{verbatim}
\item
  Use the
  \href{https://docs.liferay.com/dxp/apps/collaboration/latest/taglibdocs/liferay-flags/flags.html}{tag
  \texttt{liferay-flags:flags}} to add the flags component:

\begin{verbatim}
<liferay-flags:flags
    className="<%= Entry.class.getName() %>"
    classPK="<%= entry.getEntryId() %>"
    contentTitle="<%= title %>"
    message="flag-this-content"
    reportedUserId="<%= reportedUserId %>"
/>
\end{verbatim}

  The \texttt{reportedUserId} attribute specifies the user who flagged
  the asset.
\end{enumerate}

Great! Now you know how to let users flag content in your asset-enabled
apps.

\subsection{Related Topics}\label{related-topics-318}

\href{/docs/7-1/tutorials/-/knowledge_base/t/asset-framework}{Asset
Framework}

\href{/docs/7-1/tutorials/-/knowledge_base/t/rating-assets}{Rating
Assets}

\chapter{Export/Import and Staging}\label{exportimport-and-staging}

The Export/Import and Staging features give users the power to plan page
publication and manage content. The Export/Import feature lets users
export content from the portal and import external content into the
portal. Providing the export feature in your application gives users the
flexibility of exporting content they've created in your application to
other places, such as another portal instance, or to save the content
for a later use. Import does the opposite: it brings the data from a LAR
file into your portal.

For instance, suppose you're managing an online education course.
Because of the nature of an online course, the site's data (grades,
assignments, etc.) is purged every semester to make way for new incoming
students. In a scenario like this, there is a need to frequently store a
complete record of all data given during a course. The institution
offering the course must keep records of the course's data for a minimum
number of years. To abide by these requirements, having a gradebook
application with an export/import feature would let you clear the
application's data for a new semester, but save the previous class's
work. You could export the students' grades as a LAR file and save it
outside the course's site. If the grades ever needed to be accessed
again, you could import the LAR and view the student records.

The Export/Import feature adds another dimension to your application by
letting you produce reusable content and import content from other
places. To learn more about using the Export/Import feature, visit the
\href{/docs/7-1/user/-/knowledge_base/u/exporting-importing-widget-data}{Exporting/Importing
App Data} User Guide section.

Staging lets you change your Site behind the scenes without affecting
the live Site, and then you can publish all the changes in one fell
swoop. Keep in mind that Staging leverages the Export/Import framework.
When publishing your staged content to the live Site, you're essentially
importing content from the staged Site and exporting it to the live
Site. If you include staging support in your application, your users can
stage its content until it's ready.

For example, if you have an application that provides information
intended only during a specific holiday, supporting the Staging
environment lets users save your application's assets specific for that
holiday. They'll reside in the Staging environment until they're ready
for publishing. To learn more about Staging, visit the
\href{/docs/7-1/user/-/knowledge_base/u/staging-content-for-publication}{Staging
Content for Publication} section.

Besides configuring these features for your application, you can also
access APIs that let you write custom code, extending Liferay's default
functionality.

In this section of tutorials, you'll learn how to implement Staging and
the Export/Import framework. The main areas of Staging code to focus on
are outlined below:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/model/StagedModel.html}{StagedModel}:
  The \texttt{StagedModel} is the cornerstone of Staging. All content
  that must be handled in Staging should implement this interface; it
  provides the behavior contract for the entities Staging uses during
  the Staging process.
\item
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/exportimport/kernel/lar/StagedModelDataHandler.html}{StagedModelDataHandler}:
  These data handlers are responsible for handling one specific entity
  class. For example, the \texttt{BookmarksEntryStagedModelDataHandler}
  handles the \texttt{BookmarksEntry} during Staging: exporting data,
  serializing content, finding existing entries, etc.
\item
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/exportimport/kernel/lar/PortletDataHandler.html}{PortletDataHandler}:
  These data handlers are responsible for handling aspects of the
  portlet's configuration and publication during Staging.
\item
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/dao/orm/ExportActionableDynamicQuery.html}{ExportActionableDynamicQuery}:
  This framework is useful when developing Staging support. Its purpose
  is to query data from the database and process it during publication.
  It's automatically generated if your entity contains the right fields
  so there's no need to worry about configuring it.
\item
  \href{https://docs.liferay.com/dxp/apps/web-experience/latest/javadocs/com/liferay/exportimport/content/processor/ExportImportContentProcessor.html}{ExportImportContentProcessor}
  and
  \href{https://docs.liferay.com/dxp/apps/web-experience/latest/javadocs/com/liferay/exportimport/portlet/preferences/processor/ExportImportPortletPreferencesProcessor.html}{ExportImportPortletPreferencesProcessor}:
  Advanced frameworks only needed in special cases. The
  \texttt{ExportImportContentProcessor} lets you process your content
  during a publication process. The
  \texttt{ExportImportPortletPreferencesProcessor} lets you process your
  portlet preferences (application's configuration) during a publication
  process.
\end{enumerate}

\section{Decision to Implement
Staging}\label{decision-to-implement-staging}

Staging is an advanced publication tool that lets you create or modify
your site before releasing it to the public. Most of Liferay DXP's
included applications (e.g., Web Content, Bookmarks, etc.) support
Staging. Implementing Staging in your own application can be beneficial,
but how do you know if it's the right move?

Not every application needs to support Staging and Export/Import. The
most important question to consider during the decision process is

\emph{What part of your application are you primarily focused on using
Staging for?}

When Staging is enabled, all pages and applications are staged
automatically. Liferay DXP's architecture separates the application and
its configuration from the actual content, meaning that content can
exist without any application to display it and vice versa. Although
Staging supports all applications and their configurations by default,
not all applications' content is supported by Staging.

Implementing Staging for your application means you're defining the
logic for how the Staging framework should process, serialize, and
de-serialize your app's content, and how to insert it into a database.

Therefore, if you want to track your application's content, you should
implement Staging in your application. Here are a few other scenarios
where you should implement Staging in your application:

\begin{itemize}
\tightlist
\item
  You're using remote staging. When publishing to a remote live site,
  your content must be transferred to a different Liferay DXP
  installation. Therefore, Staging must be able to recognize the content
  to facilitate the transfer.
\item
  You want a space where you can freely edit and test your content
  before publishing it to a live audience.
\item
  Your content is being referenced from another content type that
  supports Staging.
\item
  You want to process your portlet's preferences during publication
  (i.e., you might want to publish some content with it or complete
  extra steps).
\item
  You want to process the content during publication (e.g., writing
  validation for your content during the import process).
\end{itemize}

If none of these options are beneficial for you, implementing Staging in
your application is unnecessary.

When content supports Staging and Staging is enabled, it is created in a
Staging group and is only published to a live site when that site is
published. When content is \textbf{not} supported by Staging, it is
never added to a Staging group and is not reviewable during the Staging
publication process; it's added and removed from the live site only.

From a technical standpoint, publishing an entity or content follows the
process below:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  The entity's possible references are discovered and processed.
\item
  The entity's fields are processed.
\item
  The entity is serialized into a LAR file.
\item
  The LAR is transferred to the live site (local or remote live).
\item
  After de-serialization, the entity's fields are processed.
\item
  The entity is added to the database.
\end{enumerate}

Awesome! You should now have a good idea about whether you should
implement Staging for your application.

\section{Understanding Staged Models}\label{understanding-staged-models}

To track an entity of an application with the Staging framework, you
must implement the
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/model/StagedModel.html}{StagedModel}
interface in the app's model classes. It provides the behavior contract
for entities during the Staging process. For example, the Bookmarks
application manages
\href{https://docs.liferay.com/dxp/apps/collaboration/latest/javadocs/com/liferay/bookmarks/model/BookmarksEntry.html}{BookmarksEntry}s
and
\href{https://docs.liferay.com/dxp/apps/collaboration/latest/javadocs/com/liferay/bookmarks/model/BookmarksFolder.html}{BookmarksFolder}s,
and both implement the \texttt{StagedModel} interface. Once you've
configured your staged models, you can create staged model data
handlers, which supply information about a staged model (entity) and its
referenced content to the Export/Import and Staging frameworks. See the
\href{/docs/7-1/tutorials/-/knowledge_base/t/understanding-data-handlers}{Understanding
Data Handlers} tutorial for more information.

There are two ways to create staged models for your application's
entities:

\begin{itemize}
\tightlist
\item
  Using Service Builder to generate the required Staging implementations
  (\href{/docs/7-1/tutorials/-/knowledge_base/t/generating-staged-models-using-service-builder}{tutorial}).
\item
  Implementing the required Staging interfaces manually
  (\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-staged-models-manually}{tutorial}).
\end{itemize}

You can follow step-by-step procedures for creating staged models for
your entities by visiting their respective tutorials.

Using Service Builder to generate your staged models is the easiest way
to create staged models for your app. You define the necessary columns
in your \texttt{service.xml} file and set the \texttt{uuid} attribute to
\texttt{true}. Then you run Service Builder, which generates the
required code for your new staged models.

Implementing the necessary staged model logic \emph{manually} should be
done if you \textbf{don't} want to extend your model with special
attributes only required to generate Staging logic (i.e., not needed by
your business logic). In this case, you should adapt your business logic
to meet the Staging framework's needs. You'll learn more about this
later.

You'll explore the provided staged model interfaces next.

\subsection{Staged Model Interfaces}\label{staged-model-interfaces}

The
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/model/StagedModel.html}{StagedModel}
interface must be implemented by your app's model classes, but this is
typically done through inheritance by implementing one of the interfaces
that extend the base interface:

\begin{itemize}
\tightlist
\item
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/model/StagedAuditedModel.html}{StagedAuditedModel}
\item
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/model/StagedGroupedModel.html}{StagedGroupedModel}
\end{itemize}

You must implement these when you want to use certain features of the
Staging framework like automatic group mapping or entity level
\emph{Last Publish Date} handling. So how do you choose which is right
for you?

The \texttt{StagedAuditedModel} interface provides all the audit fields
to the model that implements it. You can check the
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/model/AuditedModel.html}{AuditedModel}
interface for the specific audit fields provided. The
\texttt{StagedAuditedModel} interface is intended for models that
function independent from the group concept (sometimes referred to as
company models). If your model is a group model, you should not
implement the \texttt{StagedAuditedModel} interface.

The \texttt{StagedGroupedModel} interface must be implemented for group
models. For example, if your application requires the \texttt{groupId}
column, your model is a group model. If your model satisfies both the
\texttt{StagedGroupModel} and \texttt{StagedAuditedModel} requirements,
it should implement \texttt{StagedGroupedModel}. Your model should only
implement the \texttt{StagedAuditedModel} if it doesn't fulfill the
grouped model needs, but does fulfill the audited model needs. If your
model does not fulfill either the \texttt{StagedAuditedModel} or
\texttt{StagedGroupedModel} requirements, you should implement the base
\texttt{StagedModel} interface.

As an example for extending your model class, you can visit the
\href{https://docs.liferay.com/dxp/apps/collaboration/latest/javadocs/com/liferay/bookmarks/model/BookmarksEntryModel.html}{BookmarksEntryModel}
class, which extends the \texttt{StagedGroupedModel} interface; this is
done because bookmark entries are group models.

\begin{verbatim}
public interface BookmarksEntryModel extends BaseModel<BookmarksEntry>,
    ShardedModel, StagedGroupedModel, TrashedModel, WorkflowedModel {
\end{verbatim}

Now that you have a better understanding about staged model interfaces,
you'll dive into the attributes used in Staging and why they're
important.

\subsection{Important Attributes in
Staging}\label{important-attributes-in-staging}

If you'd like to generate your staged models using
\href{/docs/7-1/tutorials/-/knowledge_base/t/service-builder}{Service
Builder}, you must define the proper attributes in your project's
\texttt{service.xml} file. If you'd like more detail on how this is
done, see the
\href{/docs/7-1/tutorials/-/knowledge_base/t/generating-staged-models-using-service-builder}{Generating
Staged Models using Service Builder} tutorial. You'll learn some general
information about this process next.

One of the most important attributes used by the Staging framework is
the UUID (Universally Unique Identifier). This attribute must be set to
\texttt{true} in your \texttt{service.xml} file for Service Builder to
recognize your model as an eligible staged model. The UUID is used to
differentiate entities between environments. Because the UUID always
remains the same, it's unique across multiple systems. Why is this so
important?

Suppose you're using
\href{/docs/7-1/user/-/knowledge_base/u/enabling-remote-live-staging}{remote
staging} and you create a new entity on your local staging site and
publish it to your remote live site. What happens when you go back to
modify the entity on your local site and want to publish those changes?
Without a UUID, the Staging framework has no way to know the local and
remote entities are the same. To publish entities properly, the Staging
framework needs entities uniquely identified across systems to recognize
the original entity on the remote site and update it. The UUID provides
that.

In addition to the UUID, there are several columns that must be defined
in your \texttt{service.xml} file for Service Builder to define your
model as a staged model:

\begin{itemize}
\tightlist
\item
  \texttt{companyId}
\item
  \texttt{createDate}
\item
  \texttt{modifiedDate}
\end{itemize}

If you want a staged grouped model, also include the \texttt{groupId}
and \texttt{lastPublishDate} columns. If you want a staged audited
model, include the \texttt{userId} and \texttt{userName} columns.

Next, you'll learn how to build staged models from scratch.

\subsection{Adapting Your Business Logic to Build Staged
Models}\label{adapting-your-business-logic-to-build-staged-models}

What if you don't want to extend your model with special attributes that
may not be needed in your business logic? In this case, you should adapt
your business logic to meet the Staging framework's needs. Liferay
provides the
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/model/adapter/builder/ModelAdapterBuilder.html}{ModelAdapterBuilder}
framework, which lets you adapt your model classes to staged models.

As an example, assume you have an app that is fully developed and you
want to configure it to work with Staging. Your app, however, does not
require a UUID for any of its entities, and therefore, does not provide
them. Instead of configuring your app to handle UUIDs just for the sake
of generating staged models, you can leverage the Model Adapter Builder
to build your staged models.

Another example for building staged models from scratch is for
applications that use REST services to access their attributes instead
of the database. Since this kind of app is developed to pull its
attributes from a remote system, it would be more convenient to build
your staged models yourself instead of relying on Service Builder, which
is database driven.

To adapt your model classes to staged models, follow the steps outlined
below:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a \texttt{Staged{[}Entity{]}} interface, which extends the
  model specific interface (e.g., \texttt{{[}Entity{]}}) and the
  appropriate staged model interface (e.g., \texttt{StagedModel}). This
  class serves as the Staged Model Adapter.
\item
  Create a \texttt{Staged{[}Entity{]}Impl} class that implements the
  \texttt{Staged{[}Entity{]}} interface and provides necessary logic for
  your entity model to be recognized as a staged model.
\item
  Create a \texttt{Staged{[}Entity{]}ModelAdapterBuilder} class that
  implements
  \texttt{ModelAdapterBuilder\textless{}{[}Entity{]},\ Staged{[}Entity{]}\textgreater{}}.
  This class adapts the original model to the newly created Staged Model
  Adapter.
\item
  Adapt your existing model and call one of the provided APIs to export
  or import the entity automatically.
\end{enumerate}

\begin{figure}
\centering
\includegraphics{./images/staged-model-adapter-diagram.png}
\caption{The Staged Model Adapter class extends your entity and staged
model interfaces.}
\end{figure}

\begin{figure}
\centering
\includegraphics{./images/model-adapter-builder-diagram.png}
\caption{The Model Adapter Builder gets an instance of the model and
outputs a staged model.}
\end{figure}

To step through the process for leveraging the Model Adapter Builder for
an existing app, visit the
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-staged-models-manually}{Creating
Staged Models Manually} tutorial.

\section{Generating Staged Models Using Service
Builder}\label{generating-staged-models-using-service-builder}

{This document has been updated and ported to Liferay Learn and is no
longer maintained here.}

A Staged model is an essential building block to implementing the
Staging and Export/Import frameworks in your application. Instead of
having to create staged models for your app manually, you can leverage
\href{/docs/7-1/tutorials/-/knowledge_base/t/service-builder}{Service
Builder} to generate the necessary staged model logic for you. Before
diving into this tutorial, make sure you've read the
\href{/docs/7-1/tutorials/-/knowledge_base/t/understanding-staged-models}{Understanding
Staged Models} tutorial for information on how staged models work. Also,
if your app doesn't use Liferay's Service Builder, you must configure it
in your project. If you need help doing this, follow the
\href{/docs/7-1/tutorials/-/knowledge_base/t/defining-an-object-relational-map-with-service-builder}{Defining
an Object-Relational Map with Service Builder} tutorial.

This tutorial assumes you have a Service Builder project with
\texttt{*api} and \texttt{*service} modules. If you want to follow along
with this tutorial, download the staged-model-example Service Builder
project. This is a bare-bones project that you can test to observe the
Staging-related changes generated by running Service Builder. This
tutorial assumes your project is built with Gradle. The example
project's \texttt{service.xml} file contains the following
configuration:

\begin{verbatim}
<service-builder package-path="com.liferay.docs">
    <namespace>FOO</namespace>
    <entity local-service="true" name="Foo" remote-service="true" uuid="true">

        <!-- PK fields -->

        <column name="fooId" primary="true" type="long" />

        <!-- Group instance -->

        <column name="groupId" type="long" />

        <!-- Audit fields -->

        <column name="companyId" type="long" />
        <column name="createDate" type="Date" />
        <column name="modifiedDate" type="Date" />

        ...
        ...

    </entity>
</service-builder>
\end{verbatim}

For simplicity, you'll track the Service Builder-generated changes
applied to an entity model file to observe how staged models are
assigned to your entity. Keep in mind the specific
\href{/docs/7-1/tutorials/-/knowledge_base/t/understanding-staged-models\#important-attributes-in-staging}{staged
attributes} necessary for each staged model. Depending on the attributes
defined in your \texttt{service.xml} file, Service Builder assigns your
entity model to a specific staged model type.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Navigate to your project's \texttt{*service} module at the command
  line. Run Service Builder (e.g., \texttt{gradlew\ buildService}) to
  generate your project's models based on the current
  \texttt{service.xml} configuration.
\item
  Open your project's \texttt{{[}Entity{]}Model.java} interface and
  observe the inherited interfaces.

\begin{verbatim}
public interface FooModel extends BaseModel<Foo>, ShardedModel, StagedModel {
\end{verbatim}

  Your model was generated as a staged model! This is because the UUID
  is set to \texttt{true} and the \texttt{companyId},
  \texttt{createDate}, and \texttt{modifiedDate} columns are defined.
  There is much more logic generated for your app behind the scenes, but
  this shows that Service Builder deemed your entity eligible for the
  Staging and Export/Import frameworks.
\item
  Add the \texttt{userId} and \texttt{userName} columns to your
  \texttt{service.xml} file:

\begin{verbatim}
    <column name="userId" type="long" />
    <column name="userName" type="String" />
\end{verbatim}
\item
  Rerun Service Builder and observe your \texttt{{[}Entity{]}Model.java}
  interface again:

\begin{verbatim}
public interface FooModel extends BaseModel<Foo>, GroupedModel, ShardedModel,
    StagedAuditedModel {
\end{verbatim}

  Your model is now a staged audited model!
\item
  Add the \texttt{lastPublishDate} column to your \texttt{service.xml}
  file:

\begin{verbatim}
<column name="lastPublishDate" type="Date" />
\end{verbatim}
\item
  Rerun Service Builder and observe your \texttt{{[}Entity{]}Model.java}
  interface again:

\begin{verbatim}
public interface FooModel extends BaseModel<Foo>, ShardedModel,
    StagedGroupedModel {
\end{verbatim}

  Your model is now a staged grouped model! The \texttt{groupId} column
  is also required to extend the \texttt{StagedGroupedModel} interface,
  but it was already defined in the original \texttt{service.xml} file.
\end{enumerate}

Fantastic! You've witnessed firsthand how easy it is to generate staged
models using Service Builder.

\section{Creating Staged Models
Manually}\label{creating-staged-models-manually}

There are times when using
\href{/docs/7-1/tutorials/-/knowledge_base/t/understanding-staged-models\#important-attributes-in-staging}{Service
Builder to generate your staged models} is not practical. In these
cases, you should create your staged models manually. Make sure to read
the
\href{/docs/7-1/tutorials/-/knowledge_base/t/understanding-staged-models\#adapting-your-business-logic-to-build-staged-models}{Adapting
Your Business Logic to Build Staged Models} section to determine if
creating staged models manually is beneficial for your use case.

In this tutorial, you'll explore how the Asset Link framework (a Liferay
DXP framework used for
\href{/docs/7-1/user/-/knowledge_base/u/defining-content-relationships}{relating
assets}) manually creates staged models. This framework is separate from
Staging and is referenced solely as an example for how to leverage the
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/model/adapter/builder/ModelAdapterBuilder.html}{ModelAdapterBuilder}
framework, which lets you adapt your model classes to staged models.

Asset links do not provide UUIDs by default; however, they still need to
be tracked in the Staging and Export/Import frameworks. Therefore, they
require staged models. Since they don't provide a UUID, Service Builder
cannot generate staged models for asset links. The Asset Link framework
has to create staged models differently using the Model Adapter Builder.
The naming convention for this interface typically follows the
\texttt{Staged{[}Entity{]}} syntax. The Asset Link framework uses a
generic entity called \texttt{AssetLink}.

Follow the steps below to leverage the Model Adapter Builder in your
app.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a new interface that extends one of the
  \href{/docs/7-1/tutorials/-/knowledge_base/t/understanding-staged-models\#staged-model-interfaces}{staged
  model interfaces} and your model specific interface. For example,

\begin{verbatim}
public interface StagedAssetLink extends AssetLink, StagedModel {

}
\end{verbatim}

  This interface should define methods required for your model to
  qualify as a staged model. For asset links, methods for retrieving
  entry UUIDs (among others) are defined:

\begin{verbatim}
public String getEntry1Uuid();

public String getEntry2Uuid();
\end{verbatim}

  These will be implemented by a new implementation class later.
\item
  Create an implementation class that implements your new
  \texttt{Staged{[}Entity{]}}. For example, the Asset Link framework
  does this:

\begin{verbatim}
public class StagedAssetLinkImpl implements StagedAssetLink {

}
\end{verbatim}

  This class provides necessary logic for your entity model to be
  recognized as a staged model. Below is a subset of logic in the
  example \texttt{StagedAssetLinkImpl} class used to populate UUIDs for
  asset link entries:

\begin{verbatim}
public StagedAssetLinkImpl(AssetLink assetLink) {
     _assetLink = assetLink;

    ...

     populateUuid();
}

@Override
public String getEntry1Uuid() {
    if (Validator.isNotNull(_entry1Uuid)) {
        return _entry1Uuid;
    }

    populateEntry1Attributes();

    return _entry1Uuid;
}

@Override
public String getEntry2Uuid() {
    if (Validator.isNotNull(_entry2Uuid)) {
        return _entry2Uuid;
    }

    populateEntry2Attributes();

    return _entry2Uuid;
}

protected void populateEntry1Attributes() {

    ...

    AssetEntry entry1 = AssetEntryLocalServiceUtil.fetchAssetEntry(
        _assetLink.getEntryId1());

    ...

    _entry1Uuid = entry1.getClassUuid();
}

protected void populateEntry2Attributes() {

    ...

    AssetEntry entry2 = AssetEntryLocalServiceUtil.fetchAssetEntry(
        _assetLink.getEntryId2());

    ...

    _entry2Uuid = entry2.getClassUuid();
}

protected void populateUuid() {

    ...

    String entry1Uuid = getEntry1Uuid();
    String entry2Uuid = getEntry2Uuid();

    ...

    _uuid = entry1Uuid + StringPool.POUND + entry2Uuid;
        }
}

private AssetLink _assetLink;
private String _entry1Uuid;
private String _entry2Uuid;
private String _uuid;
\end{verbatim}

  This logic retrieves asset link entries and populates UUIDs for them
  usable by the Staging and Export/Import frameworks. With the newly
  generated UUIDs, asset link model classes can be converted to staged
  models.
\item
  Create a Model Adapter Builder class and implement the
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/model/adapter/builder/ModelAdapterBuilder.html}{ModelAdapterBuilder}
  interface. You should define the entity type and your Staged Model
  Adapter class when implementing the interface:

\begin{verbatim}
public class StagedAssetLinkModelAdapterBuilder
    implements ModelAdapterBuilder<AssetLink, StagedAssetLink> {

    @Override
    public StagedAssetLink build(AssetLink assetLink) {
        return new StagedAssetLinkImpl(assetLink);
    }

}
\end{verbatim}

  For the \texttt{StagedAssetLinkModelAdapterBuilder}, the entity type
  is \texttt{AssetLink} and the Staged Model Adapter is
  \texttt{StagedAssetLink}. Your app should follow a similar design. The
  Model Adapter Builder outputs a new instance of the
  \texttt{Staged{[}Entity{]}Impl} object.
\item
  Now you need to adapt your existing business logic to call the
  provided APIs. You can call the
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/model/adapter/ModelAdapterUtil.html}{ModelAdapterUtil}
  class to create an instance of your Staged Model Adapter. See how the
  Asset Link framework does this below:

\begin{verbatim}
StagedAssetLink stagedAssetLink = ModelAdapterUtil.adapt(
    assetLink, AssetLink.class, StagedAssetLink.class);
\end{verbatim}

  Once you've created
  \href{/docs/7-1/tutorials/-/knowledge_base/t/developing-staged-model-data-handlers}{Staged
  Model Data Handlers}, you can begin exporting/importing your now
  Staging-compatible entities:

\begin{verbatim}
StagedModelDataHandlerUtil.exportStagedModel(
    portletDataContext, stagedAssetLink);
\end{verbatim}

  Visit the
  \href{/docs/7-1/tutorials/-/knowledge_base/t/understanding-data-handlers}{Understanding
  Data Handlers} tutorial if you're unfamiliar with how data handlers
  work.
\end{enumerate}

Awesome! You've successfully adapted your business logic to build staged
models!

\section{Understanding Data Handlers}\label{understanding-data-handlers}

A common requirement for many data driven applications is to import and
export data. This \emph{could} be accomplished by accessing your
database directly and running SQL queries to export/import data;
however, this has several drawbacks:

\begin{itemize}
\tightlist
\item
  Working with different database vendors might require customized SQL
  scripts.
\item
  Access to the database may be tightly controlled, restricting the
  ability to export/import on demand.
\item
  You'd have to come up with your own means of storing and parsing the
  data.
\end{itemize}

Liferay provides a more convenient and reliable way to export/import
your data without accessing the database.

\subsection{Liferay Archive (LAR) File}\label{liferay-archive-lar-file}

An easier way to export/import your application's data is to use a
Liferay ARchive (LAR) file. Liferay provides the LAR feature to address
the need to export/import data in a database agnostic manner. So what
exactly is a LAR file?

A LAR file is a compressed file (ZIP archive) Liferay DXP uses to
export/import data. LAR files can be created for single portlets, pages,
or sets of pages. Portlets that are LAR-capable provide an interface to
let you control how their data is imported/exported. There are several
Liferay DXP use cases that require the use of LAR files:

\begin{itemize}
\tightlist
\item
  Backing up and restoring portlet-specific data without requiring a
  full database backup.
\item
  Cloning sites.
\item
  Specifying a template to be used for users' public or private pages.
\item
  Using Local Live or Remote Live staging.
\end{itemize}

The data handler framework is available so developers don't have to
create/modify a LAR file manually. \textbf{It is strongly recommended
never to modify a LAR file.} You should always use Liferay's provided
data handler APIs to construct it.

Knowing how a LAR file is constructed, however, is beneficial to
understand the overall purpose of your application's data handlers.
Next, you'll explore a LAR file's anatomy.

\subsubsection{LAR File Anatomy}\label{lar-file-anatomy}

What is a LAR file? You know the general concept for \emph{why} it's
used, but you may want to know what lives inside to make your
export/import processes work. With a fundamental understanding for how a
LAR file is constructed, you can better understand what your data
handlers generate behind the scenes.

Below is the structure of a simple LAR file. It illustrates the
exportation of a single Bookmarks entry and the portlet's configuration:

\begin{itemize}
\tightlist
\item
  \texttt{Bookmarks\_Admin-201701091904.portlet.lar}

  \begin{itemize}
  \tightlist
  \item
    \texttt{group}

    \begin{itemize}
    \tightlist
    \item
      \texttt{20143}

      \begin{itemize}
      \tightlist
      \item
        \texttt{com.liferay.bookmarks.model.BookmarksEntry}

        \begin{itemize}
        \tightlist
        \item
          \texttt{35005.xml}
        \end{itemize}
      \item
        \texttt{portlet}

        \begin{itemize}
        \tightlist
        \item
          \texttt{com\_liferay\_bookmarks\_web\_portlet\_BookmarksAdminPortlet}

          \begin{itemize}
          \tightlist
          \item
            \texttt{20137}

            \begin{itemize}
            \tightlist
            \item
              \texttt{portlet.xml}
            \end{itemize}
          \item
            \texttt{20143}

            \begin{itemize}
            \tightlist
            \item
              \texttt{portlet-data.xml}
            \end{itemize}
          \end{itemize}
        \end{itemize}
      \end{itemize}
    \end{itemize}
  \item
    \texttt{manifest.xml}
  \end{itemize}
\end{itemize}

You can tell from the LAR's generated name what information is contained
in the LAR: the Bookmarks Admin app's data. The \texttt{manifest.xml}
file sits at the root of the LAR file. It provides essential information
about the export process. The \texttt{manifest.xml} for the sample
Bookmarks LAR is pretty bare since it's not exporting much content, but
this file can become large when exporting pages of content. There are
four main parts (tags) to a \texttt{manifest.xml} file.

\begin{itemize}
\tightlist
\item
  \texttt{header}: contains information about the LAR file, current
  process, and site you're exporting (if necessary). For example, it can
  include locales, build information, export date, company ID, group ID,
  layouts, themes, etc.
\item
  \texttt{missing-references}: lists entities that must be validated
  during import. For example, suppose you're exporting a web content
  article that references an image (e.g., an embedded image residing in
  the document library). If the image was not selected for export, the
  image must already exist in the site where the article is imported.
  Therefore, the image would be flagged as a missing reference in the
  LAR file. If the missing reference does not exist in the site when the
  LAR is imported, the import process fails. If your import fails, the
  Import UI shows you the missing references that weren't validated.
\item
  \texttt{portlets}: defines the portlets (i.e., portlet data) exported
  in the LAR. Each portlet definition has basic information on the
  exported portlet and points to the generated \texttt{portlet.xml} for
  more specialized portlet information.
\item
  \texttt{manifest-summary}: contains information on what has been
  exported. The Staging and Export frameworks export or publish some
  entities even though they weren't marked for it, because the process
  respects data integrity. This section holds information for all the
  entities that have been processed. The entities defining a non-zero
  \texttt{addition-count} attribute are displayed in the Export/Import
  UI.
\end{itemize}

The \texttt{manifest.xml} file also defines layout information if you've
exported pages in your LAR. For example, your manifest could have
\texttt{LayoutSet}, \texttt{Layout}, and \texttt{LayoutFriendlyURL} tags
specifying staged models and their various references in an exported
page.

Now that you've learned about the LAR's \texttt{manifest.xml} and how
it's used to store high-level data about your export process, you can
dive deeper into the LAR file's \texttt{group} folder. The
\texttt{group} folder has two main parts:

\begin{itemize}
\tightlist
\item
  Entities
\item
  Portlets
\end{itemize}

If you look at the anatomy of the sample Bookmarks LAR, you'll notice
that \texttt{group/{[}groupId{]}} folder holds a folder named after the
entity you're exporting (e.g.,
\texttt{com.liferay.bookmarks.model.BookmarksEntry}) and a
\texttt{portlet} folder holding a folder named after the portlet from
which you're exporting (e.g.,
\texttt{com\_liferay\_bookmarks\_web\_portlet\_BookmarksAdminPortlet}).
For each entity/portlet you export, there are subsequent folders holding
data about them. Entities and portlets can also be stored in a
\texttt{company} folder. Although the majority of entities belong to a
group, some exist outside of a group scope (e.g., users).

If you open the
\texttt{/group/20143/com.liferay.bookmarks.model.BookmarksEntry/35005.xml}
file, you'll find serialized data about the entity, which is similar to
what is stored in the database.

The \texttt{portlet} folder holds all the portlets you exported. Each
portlet has its own folder that holds various XML files with data
describing the exported content. There are three main XML files that can
be generated for a single portlet:

\begin{itemize}
\tightlist
\item
  \texttt{portlet.xml}: provides essential information about the
  portlet, similar to a manifest file. For example, this can include the
  portlet ID, high-level entity information stored in the portlet (e.g.,
  web content articles in a web content portlet), permissioning, etc.
\item
  \texttt{portlet-data.xml}: describes specific entity data stored in
  the portlet. For example, for the web content portlet, articles stored
  in the portlet are defined in \texttt{staged-model} tags and are
  linked to their serialized entity XML files.
\item
  \texttt{portlet-preferences.xml}: defines the settings of the portlet.
  For example, this can include portlet preferences like the portlet
  owner, default user, article IDs, etc.
\end{itemize}

Note that when you import a LAR, it only includes the portlet data. You
have to deploy the portlet to be able to use it.

You now know how exported entities, portlets, and pages are defined in a
LAR file. For a summarized outline of what you've learned about LAR file
construction, see the diagram below.

\begin{figure}
\centering
\includegraphics{./images/lar-diagram.png}
\caption{Entities, Portlets, and Pages are defined in a LAR in different
places.}
\end{figure}

Excellent! You now have a fundamental understanding for how a LAR file
is generated and how it's structured.

Next, you'll learn about data handler fundamentals and the prerequisites
required to implement them.

\subsection{Data Handler Fundamentals}\label{data-handler-fundamentals}

To leverage the Export/Import framework's ability to export/import a LAR
file, you can implement Data Handlers in your application. There are two
types of data handlers: \emph{Portlet Data Handlers} and \emph{Staged
Model Data Handlers}.

A Portlet Data Handler imports/exports portlet specific data to a LAR
file. These classes only have the role of querying and coordinating
between staged model data handlers. For example, the Bookmarks
application's portlet data handler tracks system events dealing with
Bookmarks entities. It also configures the Export/Import UI options for
the Bookmarks application.

To track each entity of an application for staging, you should create
staged models by implementing the
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/model/StagedModel.html}{StagedModel}
interface. Staged models are the parent interface of an entity in the
Staging framework. For more information on staged models, see the
\href{/docs/7-1/tutorials/-/knowledge_base/t/understanding-staged-models}{Understanding
Staged Models} tutorial.

A Staged Model Data Handler supplies information about a staged model
(entity) to the Export/Import framework, defining a display name for the
UI, deleting an entity, etc. It's also responsible for exporting
referenced content. For example, if a Bookmarks entry resides in a
Bookmarks folder, the \texttt{BookmarksEntry} staged model data handler
invokes the export of the \texttt{BookmarksFolder}.

\begin{figure}
\centering
\includegraphics{./images/data-handler-diagram.png}
\caption{The Data Handler framework uses portlet data handlers and
staged model data handlers to track and export/import portlet and staged
model information, respectively.}
\end{figure}

You're not required to implement a staged model data handler for every
entity in your application, but they're necessary for any entity you
want to export/import or have the staging framework track.

Before implementing data handlers, make sure your application is ready
for the Export/Import and Staging frameworks by running Service Builder
in your application. Using Service Builder to create staged models is
not required, but is recommended since it generates many requirements
for you. To ensure Service Builder recognizes your entity as a staged
model, you must set the \texttt{uuid} attribute to \texttt{true} in your
\texttt{service.xml} file and have the following columns declared:

\begin{itemize}
\tightlist
\item
  \texttt{companyId}
\item
  \texttt{groupId}
\item
  \texttt{userId}
\item
  \texttt{userName}
\item
  \texttt{createDate}
\item
  \texttt{modifiedDate}
\end{itemize}

You can learn how to create a \texttt{service.xml} file for your
application by visiting the
\href{/docs/7-1/tutorials/-/knowledge_base/t/defining-an-object-relational-map-with-service-builder}{Defining
an Object-Relational Map with Service Builder} tutorial.

To learn how to develop data handlers for your app, visit the
\href{/docs/7-1/tutorials/-/knowledge_base/t/developing-portlet-data-handlers}{Developing
Portlet Data Handlers} and
\href{/docs/7-1/tutorials/-/knowledge_base/t/developing-staged-model-data-handlers}{Developing
Staged Model Data Handlers} tutorials.

\section{Developing Portlet Data
Handlers}\label{developing-portlet-data-handlers}

There are two types of data handlers you can implement: \emph{Portlet
Data Handlers} and \emph{Staged Model Data Handlers}. For more
information on the fundamentals behind Liferay's data handlers and how a
LAR file is constructed, see the
\href{/docs/7-1/tutorials/-/knowledge_base/t/understanding-data-handlers}{Understanding
Data Handlers} tutorial. In this tutorial, you'll create a Portlet Data
Handler for a Bookmarks application.

\noindent\hrulefill

\textbf{Note:} You must ensure your application is properly configured
to use data handlers. For more information on how to do this, see the
\href{/docs/7-1/tutorials/-/knowledge_base/t/understanding-data-handlers\#data-handler-fundamentals}{Data
Handler Fundamentals} section.

\noindent\hrulefill

A Portlet Data Handler imports/exports portlet specific data to a LAR
file. These classes only have the role of querying and coordinating
between
\href{/docs/dev/tutorials/-/knowledge_base/t/lop/tutorials/-/knowledge_base/developing-staged-model-data-handlers}{staged
model data handlers}. For example, the Bookmarks application's portlet
data handler tracks system events dealing with Bookmarks entities. It
also configures the Export/Import UI options for the Bookmarks
application.

The following steps create the \texttt{BookmarksPortletDataHandler}
class used for the Bookmarks application.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a new package in your existing Service Builder project for your
  data handler classes. For instance, the Bookmarks application's data
  handler classes reside in the \texttt{bookmarks-service} module's
  \texttt{com.liferay.bookmarks.internal.exportimport.data.handler}
  package.
\item
  Create your \texttt{-PortletDataHandler} class for your application in
  the new \texttt{-exportimport.data.handler} package and have it
  implement the
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/exportimport/kernel/lar/PortletDataHandler.html}{PortletDataHandler}
  interface by extending the
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/exportimport/kernel/lar/BasePortletDataHandler.html}{BasePortletDataHandler}
  class. For example,

\begin{verbatim}
public class BookmarksPortletDataHandler extends BasePortletDataHandler {
\end{verbatim}
\item
  Create an \texttt{@Component} annotation section above the class
  declaration. This annotation registers this class as a portlet data
  handler in the OSGi service registry.

\begin{verbatim}
@Component(
    immediate = true,
    property = {
        "javax.portlet.name=" + BookmarksPortletKeys.BOOKMARKS,
        "javax.portlet.name=" + BookmarksPortletKeys.BOOKMARKS_ADMIN
    },
    service = PortletDataHandler.class
)
\end{verbatim}

  There are a few annotation attributes you should set:

  \begin{itemize}
  \tightlist
  \item
    The \texttt{immediate} element directs the container to activate the
    component immediately once its provided module has started.
  \item
    The \texttt{property} element sets various properties for the
    component service. You must associate the portlets you wish to
    handle with this service so they function properly in the
    export/import environment. For example, since the Bookmarks data
    handler is used for two portlets, they're both configured using the
    \texttt{javax.portlet.name} property.
  \item
    The \texttt{service} element should point to the
    \texttt{PortletDataHandler.class} interface.
  \end{itemize}
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** In previous versions of Liferay DXP, you had to register the portlet
 data handler in a portlet's `liferay-portlet.xml` file. The registration
 process is now completed automatically by OSGi using the `@Component`
 annotation.
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{3}
\item
  Set what the portlet data handler controls and the portlet's
  Export/Import UI by adding an \texttt{activate} method:

\begin{verbatim}
@Activate
protected void activate() {
    setDataPortletPreferences("rootFolderId");
    setDeletionSystemEventStagedModelTypes(
        new StagedModelType(BookmarksEntry.class),
        new StagedModelType(BookmarksFolder.class));
    setExportControls(
        new PortletDataHandlerBoolean(
            NAMESPACE, "entries", true, false, null,
            BookmarksEntry.class.getName()));
    setImportControls(getExportControls());
}
\end{verbatim}

  This method is called during initialization of the component by using
  the
  \href{https://osgi.org/javadoc/r6/residential/org/osgi/service/component/annotations/Activate.html}{@Activate}
  annotation. This method is invoked after dependencies are set and
  before services are registered.

  The four \texttt{set} methods called in the
  \texttt{BookmarksPortletDataHandler}'s \texttt{activate} method are
  described below:

  \begin{itemize}
  \tightlist
  \item
    \texttt{setDataPortletPreferences}: sets portlet preferences the
    Bookmarks application should handle.
  \item
    \texttt{setDeletionSystemEventStagedModelTypes}: sets the staged
    model deletions that the portlet data handler should track. For the
    Bookmarks application, Bookmark entries and folders are tracked.
  \item
    \texttt{setExportControls}: adds fine grained controls over export
    behavior that are rendered in the Export UI. For the Bookmarks
    application, a checkbox is added to select Bookmarks content
    (entries) to export.
  \item
    \texttt{setImportControls}: adds fine grained controls over import
    behavior that are rendered in the Import UI. For the Bookmarks
    application, a checkbox is added to select Bookmarks content
    (entries) to import.
  \end{itemize}

  \begin{figure}
  \centering
  \includegraphics{./images/export-import-controls.png}
  \caption{You can select the content types you'd like to export/import
  in the UI.}
  \end{figure}

  For more information on these methods, visit the
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/exportimport/kernel/lar/PortletDataHandler.html}{PortletDataHandler}
  API.
\item
  For the Bookmarks portlet data handler to reference its entry and
  folder staged models successfully, you must set them in your class:

\begin{verbatim}
@Reference(unbind = "-")
protected void setBookmarksEntryLocalService(
    BookmarksEntryLocalService bookmarksEntryLocalService) {

    _bookmarksEntryLocalService = bookmarksEntryLocalService;
}

@Reference(unbind = "-")
protected void setBookmarksFolderLocalService(
    BookmarksFolderLocalService bookmarksFolderLocalService) {

    _bookmarksFolderLocalService = bookmarksFolderLocalService;
}

private BookmarksEntryLocalService _bookmarksEntryLocalService;
private BookmarksFolderLocalService _bookmarksFolderLocalService;
\end{verbatim}

  The \texttt{set} methods must be annotated with the
  \href{https://osgi.org/javadoc/r6/residential/org/osgi/service/component/annotations/Reference.html}{@Reference}
  annotation. Visit the
  \href{/docs/7-1/tutorials/-/knowledge_base/t/invoking-local-services}{Invoking
  Local Services} tutorial for more information on using the
  \texttt{@Reference} annotation in Liferay DXP.

  \textbf{Important:} Liferay DXP's official Bookmarks app does not use
  local services in its portlet data handler; instead, it uses the
  \href{https://docs.liferay.com/dxp/apps/web-experience/latest/javadocs/com/liferay/exportimport/staged/model/repository/StagedModelRepository.html}{StagedModelRepository}
  framework. This is a new framework, but is a viable option when
  setting up your portlet data handlers. For more information on this,
  see the
  \href{/docs/7-1/tutorials/-/knowledge_base/t/providing-entity-specific-local-services-for-staging}{Providing
  Entity-Specific Local Services for Staging} tutorial section. Since
  local services are more widely used in custom apps, this tutorial
  covers those instead.
\item
  You must create a namespace for your entities so the Export/Import
  framework can identify your application's entities from other entities
  in Liferay DXP. The Bookmarks application's namespace declaration
  looks like this:

\begin{verbatim}
public static final String NAMESPACE = "bookmarks";
\end{verbatim}

  You'll see how this namespace is used later.
\item
  Your portlet data handler should retrieve the data related to its
  staged model entities so it can properly export/import it. Add this
  functionality by inserting the following methods:

\begin{verbatim}
@Override
protected String doExportData(
        final PortletDataContext portletDataContext, String portletId,
        PortletPreferences portletPreferences)
    throws Exception {

    Element rootElement = addExportDataRootElement(portletDataContext);

    if (!portletDataContext.getBooleanParameter(NAMESPACE, "entries")) {
        return getExportDataRootElementString(rootElement);
    }

    portletDataContext.addPortletPermissions(
        BookmarksConstants.RESOURCE_NAME);

    rootElement.addAttribute(
        "group-id", String.valueOf(portletDataContext.getScopeGroupId()));

    ExportActionableDynamicQuery folderActionableDynamicQuery =
        _bookmarksFolderLocalService.
            getExportActionableDynamicQuery(portletDataContext);

    folderActionableDynamicQuery.performActions();

    ActionableDynamicQuery entryActionableDynamicQuery =
        _bookmarksEntryLocalService.
            getExportActionableDynamicQuery(portletDataContext);

    entryActionableDynamicQuery.performActions();

    return getExportDataRootElementString(rootElement);
}

@Override
protected PortletPreferences doImportData(
        PortletDataContext portletDataContext, String portletId,
        PortletPreferences portletPreferences, String data)
    throws Exception {

    if (!portletDataContext.getBooleanParameter(NAMESPACE, "entries")) {
        return null;
    }

    portletDataContext.importPortletPermissions(
        BookmarksConstants.RESOURCE_NAME);

    Element foldersElement = portletDataContext.getImportDataGroupElement(
        BookmarksFolder.class);

    List<Element> folderElements = foldersElement.elements();

    for (Element folderElement : folderElements) {
        StagedModelDataHandlerUtil.importStagedModel(
            portletDataContext, folderElement);
    }

    Element entriesElement = portletDataContext.getImportDataGroupElement(
        BookmarksEntry.class);

    List<Element> entryElements = entriesElement.elements();

    for (Element entryElement : entryElements) {
        StagedModelDataHandlerUtil.importStagedModel(
            portletDataContext, entryElement);
    }

    return null;
}
\end{verbatim}

  The \texttt{doExportData} method first checks if anything should be
  exported. The \texttt{portletDataContext.getBooleanParameter(...)}
  method checks if the user selected Bookmarks entries for export.
  Later, the \texttt{ExportImportActionableDynamicQuery} framework runs
  a query against bookmarks folders and entries to find ones which
  should be exported to the LAR file.

  The \texttt{-ActionableDynamicQuery} classes are automatically
  generated by Service Builder and are available in your application's
  local service. It queries the database searching for certain
  Staging-specific parameters (e.g., \texttt{createDate} and
  \texttt{modifiedDate}), and based on those parameters, finds a list of
  exportable records from the staged model data handler.

  The \texttt{doImportData} queries for Bookmark entry and folder data
  in the imported LAR file that should be added to the database. This is
  done by extracting XML elements from the LAR file by using utility
  methods from the
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/exportimport/kernel/lar/StagedModelDataHandlerUtil.html}{StagedModelDataHandlerUtil}
  class. The extracted elements tell Liferay DXP what data to import
  from the LAR file.
\item
  Add a method that deletes the portlet's data. The Staging framework
  has an option called \emph{Delete Portlet Data Before Importing} that
  lets the user delete portlet data before importing any new data. The
  \texttt{doDeleteData(...)} method is called to execute this deletion
  operation.

\begin{verbatim}
@Override
protected PortletPreferences doDeleteData(
        PortletDataContext portletDataContext, String portletId,
        PortletPreferences portletPreferences)
    throws Exception {

    if (portletDataContext.addPrimaryKey(
            BookmarksPortletDataHandler.class, "deleteData")) {

        return portletPreferences;
    }

    _bookmarksEntryLocalService.deleteEntries(
        portletDataContext.getScopeGroupId(),
        BookmarksFolderConstants.DEFAULT_PARENT_FOLDER_ID);

    _bookmarksFolderLocalService.deleteFolders(
        portletDataContext.getScopeGroupId());

    return portletPreferences;
}
\end{verbatim}

  This method can also return a modified version of the portlet
  preferences if it contains references to data that no longer exists.
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** This is a legacy feature that was useful when deletions were not
 propagated between Sites. This cleaned the portlet's data, allowing you to
 see everything associated with the portlet during every publication. It's
 unnecessary now that Staging can recognize deletions across all Sites. It's,
 however, still offered as a feature of Staging and is implemented in
 Liferay's Bookmarks app, so it's included here.
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{8}
\item
  Add a method that counts the number of affected entities based on the
  current export or staging process:

\begin{verbatim}
@Override
protected void doPrepareManifestSummary(
        PortletDataContext portletDataContext,
        PortletPreferences portletPreferences)
    throws Exception {

    ActionableDynamicQuery entryExportActionableDynamicQuery =
        _bookmarksEntryLocalService.
            getExportActionableDynamicQuery(portletDataContext);

    entryExportActionableDynamicQuery.performCount();

    ActionableDynamicQuery folderExportActionableDynamicQuery =
        _bookmarksFolderLocalService.
            getExportActionableDynamicQuery(portletDataContext);

    folderExportActionableDynamicQuery.performCount();
}
\end{verbatim}

  This number is displayed in the Export and Staging UI. Note that since
  the Staging framework traverses the entity graph during export, the
  built-in components provide an approximate value in some cases.

  \begin{figure}
  \centering
  \includegraphics{./images/manifest-summary-count.png}
  \caption{The number of modified Bookmarks entities are displayed in
  the Export UI.}
  \end{figure}
\item
  Set the XML schema version for the XML files included in your exported
  LAR file:

\begin{verbatim}
public static final String SCHEMA_VERSION = "1.0.0";

@Override
public String getSchemaVersion() {
    return SCHEMA_VERSION;
}

@Override
public boolean validateSchemaVersion(String schemaVersion) {
    return _portletDataHandlerHelper.validateSchemaVersion(
        schemaVersion, getSchemaVersion());
}
\end{verbatim}

  The schema version is used to perform component related validation
  before importing data. It's added to the
  \href{/docs/7-1/tutorials/-/knowledge_base/t/understanding-data-handlers\#liferay-archive-lar-file}{LAR
  file} for each application being processed. During import, the
  environment's schema version is compared to the LAR file's schema
  version. Validating the schema version avoids broken data when
  importing. See the
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/exportimport/kernel/lar/PortletDataHandler.html\#getSchemaVersion--}{PortletDataHandler.getVersionScheme()}
  method's Javadoc for more information.
\end{enumerate}

Awesome! You've set up your portlet data handler and your application
can now support the Export/Import framework and display a UI for it. Be
sure to also implement staged model data handlers for your staged
models. See the
\href{/docs/7-1/tutorials/-/knowledge_base/t/developing-staged-model-data-handlers}{Developing
Staged Model Data Handlers} to do this for the Bookmarks app.

\section{Developing Staged Model Data
Handlers}\label{developing-staged-model-data-handlers}

There are two types of data handlers you can implement: \emph{Portlet
Data Handlers} and \emph{Staged Model Data Handlers}. For more
information on the fundamentals behind Liferay's data handlers and how a
LAR file is constructed, see the
\href{/docs/7-1/tutorials/-/knowledge_base/t/understanding-data-handlers}{Understanding
Data Handlers} tutorial. In this tutorial, you'll learn how to create a
Staged Model Data Handler for a Bookmarks application.

\noindent\hrulefill

\textbf{Note:} You must ensure your application is properly configured
to use data handlers. For more information on how to do this, see the
\href{/docs/7-1/tutorials/-/knowledge_base/t/understanding-data-handlers\#data-handler-fundamentals}{Data
Handler Fundamentals} section.

\noindent\hrulefill

A Staged Model Data Handler supplies information about a staged model
(entity) to the Export/Import framework, defining a display name for the
UI, deleting an entity, etc. It's also responsible for exporting
referenced content. For example, if a Bookmarks entry resides in a
Bookmarks folder, the \texttt{BookmarksEntry} staged model data handler
invokes the export of the \texttt{BookmarksFolder}.

This tutorial assumes you've already created
\href{/docs/7-1/tutorials/-/knowledge_base/t/understanding-staged-models}{staged
models}. The Bookmarks application has two staged models: entries and
folders. Creating data handlers for these two entities is similar, so
you'll examine how this is done for Bookmark entries.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a new package in your existing Service Builder project for your
  data handler classes. For instance, the Bookmarks application's data
  handler classes reside in the \texttt{bookmarks-service} module's
  \texttt{com.liferay.bookmarks.internal.exportimport.data.handler}
  package.
\item
  Create a \texttt{-StagedModelDataHandler} class in the
  \texttt{-exportimport.data.handler} package. The staged model data
  handler class should extend the
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/exportimport/kernel/lar/BaseStagedModelDataHandler.html}{BaseStagedModelDataHandler}
  class and the entity type should be specified as its parameter. You
  can see how this was done for the
  \texttt{BookmarksEntryStagedModelDataHandler} class below:

\begin{verbatim}
public class BookmarksEntryStagedModelDataHandler
    extends BaseStagedModelDataHandler<BookmarksEntry> {
\end{verbatim}
\item
  Create an \texttt{@Component} annotation section above the class
  declaration. This annotation is responsible for registering the class
  as a staged model data handler similar to the portlet data handler.

\begin{verbatim}
@Component(immediate = true, service = StagedModelDataHandler.class)
\end{verbatim}

  The \texttt{immediate} element directs the container to activate the
  component immediately once its provided module has started. The
  \texttt{service} element should point to the
  \texttt{StagedModelDataHandler.class} interface.
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** In previous versions of Liferay DXP, you had to register the staged
 model data handler in a portlet's `liferay-portlet.xml` file. The
 registration process is now completed automatically by OSGi using the
 `@Component` annotation.
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{3}
\item
  Create a getter and setter method for the local service of the staged
  model for which you want to provide a data handler:

\begin{verbatim}
@Override
protected BookmarksEntryLocalService getBookmarksEntryLocalService() {
    return _bookmarksEntryLocalService;
}

@Reference(unbind = "-")
protected void setBookmarksEntryLocalService(
    BookmarksEntryLocalService bookmarksEntryLocalService) {

    _bookmarksEntryLocalService = bookmarksEntryLocalService;
}

private BookmarksEntryLocalService _bookmarksEntryLocalService;
\end{verbatim}

  These methods are used to link this data handler with the staged model
  for bookmark entries.

  \textbf{Important:} Liferay DXP's official Bookmarks app does not use
  local services in its staged model data handlers; instead, it uses the
  \href{https://docs.liferay.com/dxp/apps/web-experience/latest/javadocs/com/liferay/exportimport/staged/model/repository/StagedModelRepository.html}{StagedModelRepository}
  framework. This is a new framework, but is a viable option when
  setting up your staged model data handlers. For more information on
  this, see the
  \href{/docs/7-1/tutorials/-/knowledge_base/t/providing-entity-specific-local-services-for-staging}{Providing
  Entity-Specific Local Services for Staging} tutorial section. Since
  local services are more widely used in custom apps, this tutorial
  covers those instead.
\item
  You must provide the class names of the models the data handler
  tracks. You can do this by overriding the
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/exportimport/kernel/lar/StagedModelDataHandler.html}{StagedModelDataHandler}'s
  \texttt{getClassnames()} method:

\begin{verbatim}
public static final String[] CLASS_NAMES = {BookmarksEntry.class.getName()};

@Override
public String[] getClassNames() {
    return CLASS_NAMES;
}
\end{verbatim}

  As a best practice, you should have one staged model data handler per
  staged model. It's possible to use multiple class types, but this is
  not recommended.
\item
  Add a method that retrieves the staged model's display name:

\begin{verbatim}
@Override
public String getDisplayName(BookmarksEntry entry) {
    return entry.getName();
}
\end{verbatim}

  The display name is presented with the progress bar during the
  export/import process.

  \begin{figure}
  \centering
  \includegraphics{./images/staged-model-display-name.png}
  \caption{Your staged model data handler provides the display name in
  the Export/Import UI.}
  \end{figure}
\item
  A staged model data handler should ensure everything required for its
  operation is also exported. For example, in the Bookmarks application,
  an entry requires its folder to keep the folder structure intact.
  Therefore, the folder should be exported first followed by the entry.

  Add methods that import and export your staged model and its
  references.

\begin{verbatim}
@Override
protected void doExportStagedModel(
        PortletDataContext portletDataContext, BookmarksEntry entry)
    throws Exception {

    if (entry.getFolderId() !=
            BookmarksFolderConstants.DEFAULT_PARENT_FOLDER_ID) {

        StagedModelDataHandlerUtil.exportReferenceStagedModel(
            portletDataContext, entry, entry.getFolder(),
            PortletDataContext.REFERENCE_TYPE_PARENT);
    }

    Element entryElement = portletDataContext.getExportDataElement(entry);

    portletDataContext.addClassedModel(
        entryElement, ExportImportPathUtil.getModelPath(entry), entry);
}

@Override
protected void doImportStagedModel(
        PortletDataContext portletDataContext, BookmarksEntry entry)
    throws Exception {

    Map<Long, Long> folderIds =
        (Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(
            BookmarksFolder.class);

    long folderId = MapUtil.getLong(
        folderIds, entry.getFolderId(), entry.getFolderId());

    ServiceContext serviceContext =
        portletDataContext.createServiceContext(entry);

    BookmarksEntry importedEntry = null;

    if (portletDataContext.isDataStrategyMirror()) {

        BookmarksEntry existingEntry =
            _bookmarksEntryLocalService. fetchBookmarksEntryByUuidAndGroupId(
                entry.getUuid(), portletDataContext.getScopeGroupId());

        if (existingEntry == null) {

            serviceContext.setUuid(entry.getUuid());
            importedEntry = _bookmarksEntryLocalService.addEntry(                   
              userId, portletDataContext.getScopeGroupId(), folderId, entry.getName(), entry.getUrl(), entry.getDescription(), serviceContext);
        }
        else {
            importedEntry = _bookmarksEntryLocalService.updateEntry(
                userId, existingEntry.getEntryId(), portletDataContext.getScopeGroupId(), folderId, entry.getName(), entry.getUrl(), entry.getDescription(),    serviceContext);
        }
    }
    else {
        importedEntry = _bookmarksEntryLocalService.addEntry(userId, portletDataContext.getScopeGroupId(), folderId,entry.getName(), entry.getUrl(), entry.getDescription(),    serviceContext);
    }

    portletDataContext.importClassedModel(entry, importedEntry);
}
\end{verbatim}

  The \texttt{doExportStagedModel} method retrieves the Bookmark entry's
  data element from the
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/exportimport/kernel/lar/PortletDataContext.html}{PortletDataContext}
  and then adds the class model characterized by that data element to
  the \texttt{PortletDataContext}. The \texttt{PortletDataContext} is
  used to populate the LAR file with your application's data during the
  export process. Note that once an entity has been exported, subsequent
  calls to the export method won't actually repeat the export process
  multiple times, ensuring optimal performance.

  An important feature of the import process is that all exported
  reference elements in the Bookmarks example are automatically imported
  when needed. The \texttt{doImportStagedModel} method does not need to
  import the reference elements manually; it must only find the new
  assigned ID for the folder before importing the entry.

  The \texttt{PortletDataContext} keeps this information and a slew of
  other data up-to-date during the import process. The old ID and new ID
  mapping can be reached by using the
  \texttt{portletDataContext.getNewPrimaryKeysMap()} method as shown in
  the example. The method proceeds with checking the import mode (e.g.,
  \emph{Copy As New} or \emph{Mirror}) and, depending on the process
  configuration and existing environment, the entry is either added or
  updated.
\item
  When importing a LAR (i.e., publishing to the live Site), the import
  process expects all of an entity's references to be available and
  validates their existence.

  For example, if you republish an updated bookmarks folder to the live
  Site and did not include some of its existing entries in the
  publication, these entries are considered missing references. A more
  practical example of this would be an image included in a web content
  article. If the image included in the web content lives on a different
  Site (i.e., the image is contained in a different group) or was not
  included in the publication process, it's considered a missing
  reference of the web content article.

  Since you have references from two separate Sites with differing IDs,
  the system can't match them during publication. For example, suppose
  you export a bookmark entry as a missing reference with a primary key
  (ID) of \texttt{1}. When importing that information, the LAR only
  provides the ID but not the entry itself. Therefore, during the import
  process, the Data Handler framework searches for the entry to replace
  by its UUID, but the entry to replace has a different ID (primary key)
  of \texttt{2}. You must provide a way to handle these missing
  references.

  To do this, you must add a method that maps the missing reference's
  primary key from the export to the existing primary key during import.
  Since the reference's UUID is constant across systems, it's used to
  complete the mapping of differing primary keys. Note that a reference
  can only be missing on the live Site if it has already been published
  previously. Therefore, when publishing a bookmarks folder for the
  first time, the system doesn't check for missing references.

  Add this method to your class:

\begin{verbatim}
@Override
protected void doImportMissingReference(
        PortletDataContext portletDataContext, String uuid, long groupId,
        long entryId)
    throws Exception {

    BookmarksEntry existingEntry = fetchMissingReference(uuid, groupId);

    if (existingEntry == null) {
        return;
    }

    Map<Long, Long> entryIds =
        (Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(
            BookmarksEntry.class);

    entryIds.put(entryId, existingEntry.getEntryId());
}
\end{verbatim}

  This method maps the existing staged model to the old ID in the
  reference element. When a reference is exported as missing, the Data
  Handler framework calls this method during the import process and
  updates the new primary key map in the portlet data context.
\end{enumerate}

Fantastic! You've created a data handler for your staged model. The
Export/Import framework can now track your entity's behavior and data.
Be sure to also implement a portlet data handler to manage portlet
specific data. See the
\href{/docs/7-1/tutorials/-/knowledge_base/t/developing-portlet-data-handlers}{Developing
Portlet Data Handlers}. to do this for the Bookmarks app.

\chapter{Providing Entity-Specific Local Services for
Staging}\label{providing-entity-specific-local-services-for-staging}

When creating your data handlers, you must leverage your app's local
services to perform Staging-related tasks for its entities. When the
Staging framework operates on entities (i.e., staged models), it often
cannot manage important information from the entity's local services
alone; instead, you're forced to reinvent basic functionality so the
Staging framework can access it. This is caused by services not sharing
a common ancestor (i.e., interface or base class).

The \emph{Staged Model Repository} framework removes this barrier by
linking an app's staged model to a local service. This lets the Staging
framework call a staged model repository independently based on the
entity being processed. This gives you access to entity-specific methods
tailored specifically for the staged model data you're handling.

\begin{figure}
\centering
\includegraphics{./images/staged-model-repository.png}
\caption{Staged Model Repositories provide a Staging-specific layer of
functionality for your local services.}
\end{figure}

What kind of \emph{entity-specific} methods are we talking about here?
Your data handlers only expose a specific set of actions, like export
and import methods. The Staged Model Repository framework provides CRUD
operations for a specific staged model that are not exposed using local
services.

The staged model repository does not avoid using your app's local
services. It only provides an additional layer that provides
Staging-specific functionality. So how does this work? A brief Staging
process is outlined below:

\begin{itemize}
\tightlist
\item
  \texttt{*StagedModelDataHandler} de-serializes the provided
  \href{/docs/7-1/tutorials/-/knowledge_base/t/understanding-data-handlers\#liferay-archive-lar-file}{LAR
  file's} XML into a model.
\item
  \texttt{*StagedModelRepository} updates the model based on the
  environment and business logic, providing entity-specific CRUD
  operations for Staging purposes (e.g., UUID manipulation).
\item
  Local services are called from the \texttt{*StagedModelRepository} and
  handles the remainder of the process.
\end{itemize}

Pretty cool, right? Read on to learn how to implement and use the Staged
Model Repository framework in your app.

\section{Implementing the Staged Model Repository
Framework}\label{implementing-the-staged-model-repository-framework}

Providing specialized local services for your app's staging
functionality lets you abstract the additional staging-specific
information away from your data handlers. Before you can begin using the
Staged Model Repository framework in your app, you must implement it.

Below is a quick example that demonstrates implementing the
\texttt{StagedModelRepository} interface to use for a staged model. This
example references Liferay's Bookmarks app and Bookmarks Entry entities.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In your app's \texttt{-service} bundle, create a package that holds
  your Staged Model Repository classes (e.g.,
  \texttt{com.liferay.bookmarks.exportimport.staged.model.repository}).
  If you do not have a \texttt{-service} bundle, visit the
  \href{/docs/7-1/tutorials/-/knowledge_base/t/service-builder}{Service
  Builder} tutorials for info on generating an app's services. You must
  have them to leverage most Staging features.
\item
  Create your \texttt{-StagedModelRepository} class in the new package
  and implement the \texttt{StagedModelRepository} interface in the
  class' declaration. For example,

\begin{verbatim}
public class BookmarksEntryStagedModelRepository
    implements StagedModelRepository<BookmarksEntry> {
\end{verbatim}

  Be sure also to include the staged model type parameter for this
  repository (e.g., \texttt{BookmarksEntry}).
\item
  Add an \texttt{@Component} annotation for your staged model repository
  class that looks like this:

\begin{verbatim}
@Component(
    immediate = true,
    property = "model.class.name=FULLY_QUALIFIED_MODEL_CLASS",
    service = StagedModelRepository.class
)
\end{verbatim}

  There are a few annotation attributes you should set:

  \begin{itemize}
  \tightlist
  \item
    The \texttt{immediate} element directs the container to activate the
    component immediately once its provided module has started.
  \item
    The \texttt{property} element sets various properties for the
    component service. You must associate the model class you wish to
    handle with this service so it's recognized by the data handlers
    leveraging it. You'll learn more about this later.
  \item
    The \texttt{service} element should point to the
    \texttt{StagedModelRepository.class} interface.
  \end{itemize}

  The \texttt{BookmarksEntryStagedModelRepository}'s \texttt{@Component}
  annotation looks like this:

\begin{verbatim}
@Component(
    immediate = true,
    property = "model.class.name=com.liferay.bookmarks.model.BookmarksEntry",
    service = StagedModelRepository.class
)
\end{verbatim}
\item
  Implement the \texttt{StagedModelRepository} interface's methods in
  your staged model repository. You can reference the
  \href{https://docs.liferay.com/dxp/apps/web-experience/latest/javadocs/com/liferay/exportimport/staged/model/repository/StagedModelRepository.html}{Javadoc}
  for this interface to learn what each method is intended for.

  As an example, you'll step through a couple method implementations to
  get a taste for how it works.

  Implementing the \texttt{addStagedModel(...)} method for a Bookmarks
  entry looks like this:

\begin{verbatim}
@Override
public BookmarksEntry addStagedModel(
        PortletDataContext portletDataContext,
        BookmarksEntry bookmarksEntry)
    throws PortalException {

    long userId = portletDataContext.getUserId(
        bookmarksEntry.getUserUuid());

    ServiceContext serviceContext = portletDataContext.createServiceContext(
        bookmarksEntry);

    if (portletDataContext.isDataStrategyMirror()) {
        serviceContext.setUuid(bookmarksEntry.getUuid());
    }

    return _bookmarksEntryLocalService.addEntry(
        userId, bookmarksEntry.getGroupId(), bookmarksEntry.getFolderId(),
        bookmarksEntry.getName(), bookmarksEntry.getUrl(),
        bookmarksEntry.getDescription(), serviceContext);
}
\end{verbatim}

  This method sets the user ID and service context based on the portlet
  data context. The
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/exportimport/kernel/lar/PortletDataContext.html}{\texttt{PortletDataContext}}
  is used to populate the LAR file with your application's data during
  the export process. Next it sets the UUID, which is required to
  differentiate staged content between Sites. Lastly, the entity's local
  service is called.

  Just calling the \texttt{BookmarksEntryLocalService.addEntry(...)}
  method would not have been enough to satisfy the staged model data
  handler's needs (i.e., the UUID requirement). With the staged model
  repository layer, however, you can add staging specific requirements
  on top of the present local services to serve your data handlers'
  needs.

  Not every method implementation requires additional staging
  information. For example, deleting Bookmarks Entries and deleting
  Bookmarks Entry staged models are functionally the same, so your
  staged model repository's method would look like this:

\begin{verbatim}
@Override
public void deleteStagedModels(PortletDataContext portletDataContext)
    throws PortalException {

    _bookmarksEntryLocalService.deleteEntries(
        portletDataContext.getScopeGroupId(),
        BookmarksFolderConstants.DEFAULT_PARENT_FOLDER_ID);
}
\end{verbatim}

  Since nothing additional is required for deleting staged models, the
  staged model repository calls the local service's
  \texttt{deleteEntries(...)} method with no additional changes.

  Finish implementing the \texttt{StagedModelRepository} so it's usable
  in your data handlers.
\end{enumerate}

Awesome! You've implemented the Staged Model Repository framework for
your app! If you're interested in leveraging this framework after the
implementation process, see the
\href{/docs/7-1/tutorials/-/knowledge_base/t/using-the-staged-model-repository-framework}{Using
the Staged Model Repository Framework} tutorial.

\section{Using the Staged Model Repository
Framework}\label{using-the-staged-model-repository-framework}

Leveraging the Staged Model Repository framework in your app is easy
once you've
\href{/docs/7-1/tutorials/-/knowledge_base/t/implementing-the-staged-model-repository-framework}{created
staged model repository implementation classes}.

You'll step through a quick example to demonstrate leveraging the
\texttt{StagedModelRepository} interface in a staged model data handler.
The code snippets originate from Liferay's Bookmarks app and Bookmarks
Entries.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a getter and setter method to make a
  \texttt{StagedModelRepository} object available for the
  \texttt{BookmarksEntry} entity:

\begin{verbatim}
@Override
protected StagedModelRepository<BookmarksEntry> getStagedModelRepository() {
    return _stagedModelRepository;
}

@Reference(
    target = "(model.class.name=com.liferay.bookmarks.model.BookmarksEntry)",
    unbind = "-"
)
protected void setStagedModelRepository(
    StagedModelRepository<BookmarksEntry> stagedModelRepository) {

    _stagedModelRepository = stagedModelRepository;
}

private StagedModelRepository<BookmarksEntry> _stagedModelRepository;
\end{verbatim}

  This instantiates a \texttt{\_stagedModelRepository} object that the
  staged model data handler can use to access \texttt{BookmarksEntry}
  CRUD operations. Notice the setter method's \texttt{@Reference}
  annotation. This injects the component service of the
  \texttt{BookmarksEntryStagedModelRepository} into the
  \texttt{\_stagedModelRepository} object. The component service was
  created in the
  \href{/docs/7-1/tutorials/-/knowledge_base/t/implementing-the-staged-model-repository-framework}{Implementing
  the Staged Model Repository Framework} tutorial when setting the
  \texttt{@Component} annotation for the staged model repository.
\item
  Call your \texttt{\_stagedModelRepository} object to leverage its
  specialized staging logic. Now that you have access to CRUD operations
  via the \texttt{\_stagedModelRepository} object, you can skip the
  headache of providing a slew of parameters and additional
  functionality in the local service to do simple things like add a
  Bookmarks entry. For example, here's the old way:

\begin{verbatim}
serviceContext.setUuid(entry.getUuid());

newEntry = _bookmarksEntryLocalService.addEntry(
    userId, portletDataContext.getScopeGroupId(), folderId, entry.getName(), entry.getUrl(), entry.getDescription(), serviceContext);
\end{verbatim}

  Now with access to the entry's staged model repository, updating an
  entry the data handler can use looks like this:

\begin{verbatim}
newEntry = _stagedModelRepository.updateStagedModel(portletDataContext, importedEntry);
\end{verbatim}

  The large number of parameters and UUID setter the local service
  method requires aren't needed when leveraging the staged model
  repository, because the staged model repository abstracts these
  requirements away from the data handler. The
  \texttt{\_bookmarksEntryLocalService.addEntry(...)} method is called
  from the \texttt{BookmarksEntryStagedModelRepository} class.
\end{enumerate}

Great! You've successfully leveraged your staged model repository from a
data handler!

\section{Using the Export/Import Lifecycle Listener
Framework}\label{using-the-exportimport-lifecycle-listener-framework}

The \texttt{ExportImportLifecycleListener} framework lets developers
write code that listens for certain staging or export/import events
during the publication process. The staging and export/import processes
have many behind-the-scenes events that you cannot listen to by default.
Some of these, like export successes and import failures, may be events
on which you'd want to take some action. You also have the ability to
listen for processes comprised of many events and implement custom code
when these processes are initiated. Here is a short list of events you
could listen for:

\begin{itemize}
\tightlist
\item
  Staging has started
\item
  A portlet export has failed
\item
  An entity export has succeeded
\end{itemize}

The concept of listening for export/import and staging events sounds
cool, but you may be curious as to why listening for certain events is
useful. Listening for events can help you know more about your
application's state. Suppose you'd like a detailed log of when certain
events occur during an import process. You could configure a listener to
listen for certain import events you're interested in and print
information about those events to your console when they occur.

Liferay DXP uses this framework by default in several cases. For
instance, the cache is cleared when a web content import process
finishes. To accomplish this, the lifecycle listener framework listens
for an event that specifies that a web content import process has
completed. Once that event occurs, there is an event listener that
automatically clears the cache. You could implement this sort of
functionality yourself for any event. You can listen for a specific
event and then complete an action based on when that event occurs. For a
list of events you can listen for during Export/Import and Staging
processes, see
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/exportimport/kernel/lifecycle/ExportImportLifecycleConstants.html}{ExportImportLifecycleConstants}.

Some definitions are in order:

\textbf{Events} are particular actions that occur during processing.

\textbf{Processes} are longer running groups of events.

In this tutorial, you'll learn how to use the
\texttt{ExportImportLifecycleListener} framework to listen for
processes/events during the staging and export/import lifecycles.

\subsection{Listening to Lifecycle
Events}\label{listening-to-lifecycle-events}

To begin creating your lifecycle listener, you must create a module.
Follow the steps below:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/starting-module-development\#creating-a-module}{Create
  an OSGi module}.
\item
  Create a unique package name in the module's \texttt{src} directory
  and create a new Java class in that package. To follow naming
  conventions, begin the class name with the entity or action name
  you're processing, followed by \emph{ExportImportLifecycleListener}
  (e.g., \texttt{LoggerExportImportLifecycleListener}).
\item
  You must extend one of the two Base classes provided with the
  Export/Import Lifecycle Listener framework:
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/exportimport/kernel/lifecycle/BaseExportImportLifecycleListener.html}{BaseExportImportLifecycleListener}
  or
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/exportimport/kernel/lifecycle/BaseProcessExportImportLifecycleListener.html}{BaseProcessExportImportLifecycleListener}.
  To choose, you'll need to consider what parts of a lifecycle you want
  to listen for.

  Extend the \texttt{BaseExportImportLifecycleListener} class if you
  want to listen for specific \emph{events} during a lifecycle. For
  example, you may want to write custom code if a layout export fails.

  Extend the \texttt{BaseProcessExportImportLifecycleListener} class if
  you want to listen for \emph{processes} during a lifecycle. For
  example, you may want to write custom code if a site publication
  fails. Keep in mind that a process usually consists of many individual
  events. Methods provided by this base class are only run once when the
  desired process action occurs.
\item
  Directly above the class's declaration, insert the following
  annotation:

\begin{verbatim}
@Component(immediate = true, 
            service = ExportImportLifecycleListener.class)
\end{verbatim}

  This annotation declares the implementation class of the component and
  specifies that the portal should start the module immediately.
\item
  Specify the methods you want to implement in your class.
\end{enumerate}

Once you've successfully created your export/import lifecycle listener
module, generate the module's JAR file and copy it to Liferay DXP's
\texttt{osgi/modules} folder. Once your module is installed and
activated in your instance's service registry, your lifecycle listener
is ready for use in your Portal instance.

If you're still thirsting for more information on this framework, you're
in luck! Here's an example, using the
\href{https://docs.liferay.com/dxp/apps/web-experience/latest/javadocs/com/liferay/exportimport/lifecycle/LoggerExportImportLifecycleListener.html}{LoggerExportImportLifecycleListener}.
This listener extends the \texttt{BaseExportImportLifecycleListener}, so
you immediately know that it deals with lifecycle events.

The first method \texttt{getStagedModelLogFragment} retrieves the staged
model's log fragment, which is the lifecycle listener's logging
information on events. The next method \texttt{isParallel()} determines
whether your listener should run in parallel with the import/export
process, or if the calling method should stop, execute the listener, and
return to where the event was fired after the listener has finished. The
following method is the \texttt{onExportImportLifecycleEvent(...)}
method, which consumes the lifecycle event and passes it through the
base class's method (as long as Debug mode is not enabled).

Each remaining method is called to print logging information for the
user. For example, when a layout export starts, succeeds, or fails,
logging information directly related to that event is printed. In
summary, the \texttt{LoggerExportImportLifecycleListener} uses the
lifecycle listener framework to print messages to the log when an
export/import event occurs. Anther good example of an event lifecycle
listener is the
\href{https://docs.liferay.com/dxp/apps/web-experience/latest/javadocs/com/liferay/exportimport/lifecycle/CacheExportImportLifecycleListener.html}{CacheExportImportLifecycleListener}.

For an example of a lifecycle listener extending the
\texttt{BaseProcessExportImportLifecycleListener} class, inspect the
\href{https://docs.liferay.com/dxp/apps/web-experience/latest/javadocs/com/liferay/exportimport/lifecycle/ExportImportProcessCallbackLifecycleListener.html}{ExportImportProcessCallbackLifecycleListener}
class. Instead of listening for lifecycle events, this class only
listens for process actions.

Terrific! You learned about the Export/Import Lifecycle Listener
framework, and you've learned how to create your own listener for
events/processes that occur during export/import of your portal's
content.

\section{Initiating New Export/Import
Processes}\label{initiating-new-exportimport-processes}

The Staging and Export/Import features are the building blocks for
creating, managing, and publishing a site. These features can be
accessed in the \emph{Publishing Tools} menu. You can also, however,
start these processes programmatically. This lets you provide new
interfaces or mimic the functionality of these features in your own
application.

Providing the ability to stage your application's assets makes using
your application much more site administrator-friendly. Your new assets
no longer have to be saved somewhere off-site until they're ready to be
published. You can publish them to a staging environment, test their
usability, and save them to a page. Once the time is right for
publishing, you can publish your application's assets to the live site
with one mouse click. The export/import feature offers similar
conveniences: if you want to export your application's assets to use in
another place or you need to clear its data but save a copy you can
implement the export feature. Implementing the import feature lets you
bring your assets/data back into your application.

To initiate a export/import or staging process, you must pass in an
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/exportimport/kernel/model/ExportImportConfiguration.html}{ExportImportConfiguration}
object. This object encapsulates many parameters and settings that are
required while the export/import is running. Having one single object
with all your necessary data makes executing these frameworks quick and
easy.

For example, when you want to implement the export feature, you must
call services offered by the
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/exportimport/kernel/service/ExportImportService.html}{ExportImportService}
interface. All the methods in this interface require an
\texttt{ExportImportConfiguration} object. Liferay DXP provides a way to
generate these configuration objects, so you can easily pass them in
your service methods.

It's also important to know that \texttt{ExportImportConfiguration} is
an Liferay DXP entity, similar to \texttt{User} or \texttt{Group}. This
means that the \texttt{ExportImportConfiguration} framework offers local
and remote services, models, persistence classes, and more.

In this tutorial, you'll learn about the
\texttt{ExportImportConfiguration} framework and how you can take
advantage of provided services and factories to create these controller
objects. Once they're created, you can easily implement whatever
import/export functionality you need.

Your first step is to create an \texttt{ExportImportConfiguration}
object and use it to initiate your custom export/import or staging
process.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Use the Export/Import Configuration factory classes to build your
  \texttt{ExportImportConfiguration} object. Below is a common way to do
  it:

\begin{verbatim}
Map<String, Serializable> exportLayoutSettingsMap =
    ExportImportConfigurationSettingsMapFactory.
        buildExportLayoutSettingsMap(...);

ExportImportConfiguration exportImportConfiguration =
    exportImportConfigurationLocalService.
        addDraftExportImportConfiguration(
            user.getUserId(),
            ExportImportConfigurationConstants.TYPE_EXPORT_LAYOUT,
            exportLayoutSettingsMap);
\end{verbatim}

  This example uses the
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/exportimport/kernel/configuration/ExportImportConfigurationSettingsMapFactory.html}{ExportImportConfigurationSettingsMapFactory}
  to create a layout export settings map. Then this map is used as a
  parameter to create an \texttt{ExportImportConfiguration} by calling
  an \emph{add} method in the entity's local service interface. The
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/exportimport/kernel/service/ExportImportConfigurationLocalService.html}{ExportImportConfigurationLocalService}
  provides several useful methods to create and modify your custom
  \texttt{ExportImportConfiguration}.

  The \texttt{ExportImportConfigurationSettingsMapFactory} provides many
  \texttt{build} methods to create settings maps for various scenarios,
  like importing, exporting, and publishing layouts and portlets. For
  examples of this particular scenario, you can reference
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-impl/com/liferay/portal/service/impl/UserGroupLocalServiceImpl.html\#exportLayouts-long-java.util.Map-}{UserGroupLocalServiceImpl.exportLayouts(\ldots)}
  and
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-impl/com/liferay/portal/service/impl/GroupLocalServiceImpl.html\#addDefaultGuestPublicLayoutsByLAR-com.liferay.portal.kernel.model.Group-java.io.File-}{GroupLocalServiceImpl.addDefaultGuestPublicLayoutsByLAR(\ldots)}.

  There are two other important factories provided by this framework
  that are useful during the creation of
  \texttt{ExportImportConfiguration} objects:

  \begin{itemize}
  \tightlist
  \item
    \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/exportimport/kernel/configuration/ExportImportConfigurationFactory.html}{ExportImportConfigurationFactory}:
    This factory builds \texttt{ExportImportConfiguration} objects used
    for default local/remote publishing.
  \item
    \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/exportimport/kernel/configuration/ExportImportConfigurationParameterMapFactory.html}{ExportImportConfigurationParameterMapFactory}:
    This factory builds parameter maps, which are required during
    export/import and publishing.
  \end{itemize}
\item
  Call the appropriate service to initiate the export/import or staging
  process. There are two important service interfaces that you can use
  in the cases of exporting, importing, and staging:
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/exportimport/kernel/service/ExportImportLocalService.html}{ExportImportLocalService}
  and
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/exportimport/kernel/service/StagingLocalService.html}{StagingLocalService}.
  In the previous step's example code snippet, you created an
  \texttt{ExportImportConfiguration} object intended for exporting
  layouts. Here's how to initiate that process:

\begin{verbatim}
files[0] = exportImportLocalService.exportLayoutsAsFile(
    exportImportConfiguration);
\end{verbatim}

  By calling this interface's method, you're exporting layouts from
  Liferay DXP into a \texttt{java.io.File} array. Notice that your
  \texttt{ExportImportConfiguration} object is the only needed parameter
  in the method. Your configuration object holds all the required
  parameters and settings necessary to export your layouts from Liferay
  DXP. Although this example code resides in Liferay DXP, you could
  easily use this framework from your own project.
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** If you're not calling the export/import or staging service methods
 from an OSGi module, you should not use the interface. The Liferay
 OSGi container automatically handles interface referencing, which is why
 using the interface is permitted for modules. If you're calling
 export/import or staging service methods outside of a module, you should use
 their service Util classes (e.g., `ExportImportLocalServiceUtil`).
\end{verbatim}

\noindent\hrulefill

It's that easy! To start your own export/import or staging process, you
must create an \texttt{ExportImportConfiguration} object using a
combination of the three provided \texttt{ExportImportConfiguration}
factories. Once you have your configuration object, provide it as a
parameter in one of the many service methods available to you by the
Export/Import or Staging interfaces to begin your desired process.

\chapter{Liferay Forms}\label{liferay-forms}

The \href{/docs/7-1/user/-/knowledge_base/u/forms}{Liferay Forms}
application is a full-featured form building tool for collecting data.
There's lots of built-in functionality, and for the pieces you're
missing, there's lots of extensibility.

This section of tutorials shows developers how to

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Store form entry data in an alternative format. The default storage
  type is JSON.
\item
  Create new form field types.
\end{enumerate}

This list will continue to grow as new tutorials on customizing and
extending Liferay Forms are written.

\chapter{Form Field Types}\label{form-field-types}

The Forms application contains many highly configurable field types
out-of-the-box. Most use cases are met with one of the existing field
types.

\begin{figure}
\centering
\includegraphics{./images/forms-field-types.png}
\caption{The Forms application has useful out-of-the-box field types,
but you can add your own if you need to.}
\end{figure}

If you're reading this, however, your use case probably wasn't met with
the default field types. For example, perhaps you need a color picker
field. You could create a select field that lists color names. Some
users don't, however, know that \emph{Gamboge} is the color of spicy
mustard (maybe a little darker), and anyway, seeing colors is better
than reading their names, so you can create a field that shows colors.

Another example is a dedicated \emph{time} field. Even with a text field
and a tooltip that tells people to \emph{enter the time in the format
\texttt{hour:minute}}, some users still enter something indecipherable.
You can fix this by adding a \emph{time} field to Liferay DXP's Forms
application. If you have your own ideas for create your own field types,
keep reading to find out how.

These tutorials show you how to

\begin{itemize}
\item
  create a module that adds a \emph{Time} form field type with a
  timepicker
\item
  add custom configuration options to your field types
\end{itemize}

\noindent\hrulefill

\textbf{Example project:} The source code for the example \emph{time}
project developed in these tutorials can be downloaded for your
convenience. Click
\href{https://portal.liferay.dev/documents/113763090/114000653/dynamic-data-mapping-type-time.zip}{here}
to begin downloading the source code zip file.

\noindent\hrulefill

Before getting started, learn the structure of a form field type.

\section{Anatomy of a Field Type
Module}\label{anatomy-of-a-field-type-module}

All form field type modules have a similar structure. Here's the
directory structure of the \texttt{dynamic-data-mapping-type-time}
module developed in these tutorials:

\begin{verbatim}
.babelrc
.npmbundlerrc
bnd.bnd
build.gradle
package-lock.json
package.json
src
└── main
    ├── java
    │   └── com
    │       └── liferay
    │           └── dynamic
    │               └── data
    │                   └── mapping
    │                       └── type
    │                           └── time
    │                               ├── TimeDDMFormFieldRenderer.java
    │                               ├── TimeDDMFormFieldTemplateContextContributor.java
    │                               ├── TimeDDMFormFieldType.java
    │                               └── TimeDDMFormFieldTypeSettings.java
    └── resources
        ├── content
        │   └── Language.properties
        └── META-INF
            └── resources
                ├── config.js
                ├── time.es.js
                ├── time_field.js
                └── time.soy
\end{verbatim}

You don't need \texttt{*TemplateContextContributor.java} or
\texttt{*TypeSettings.java} in the initial module (see
\href{/docs/7-1/tutorials/-/knowledge_base/t/rendering-form-field-settings}{Rendering
Form Field Settings} to learn more about these classes). The initial
module consists of these Java classes and resources:

\texttt{*DDMFormFieldRenderer.java}: Controls the template's rendering.
Sets the language, declares the namespace, and loads the template
resources on activation of the Component. Extending the abstract class
that implements the \texttt{DDMFormFieldRenderer} makes your work here
easier.

\texttt{*DDMFormFieldType.java}: Defines the form field type in the
back-end. If you extend the abstract class that implements the
interface, you automatically include the default form configuration
options for your form field type. In that case, override the interface's
\texttt{getName} method and you're done. To see the default
configuration options your form field type inherits, look at the
\texttt{DefaultDDMFormFieldTypeSettings} class in the
\texttt{dynamic-data-mapping-api} module.

\texttt{config.js}: Auto-generated if you use Blade CLI,
\texttt{config.js} defines the dependencies of all declared JavaScript
components.

\texttt{{[}name-of-field-type{]}\_field.js}: The JavaScript file
modeling your field.

\texttt{{[}name-of-field-type{]}.es.js}: The JavaScript file that
configures the template rendering (the
\texttt{{[}name-of-field-type{]}.soy} rendering).

\texttt{{[}name-of-field-type{]}.soy}: The template that defines the
appearance of the field.

\texttt{Language\_xx\_XX.properties}: Define any terms that must be
\href{/docs/7-1/tutorials/-/knowledge_base/t/localizing-your-application}{translated
into different languages}.

In addition to the Java classes, Soy templates, and JavaScript files, a
form field type contains the following files:

\texttt{.babelrc}: The \href{https://babeljs.io/}{Babel} configuration
file.

\texttt{.npmbundlerrc}: The
\href{/docs/7-1/reference/-/knowledge_base/r/liferay-npm-bundler}{liferay-npm-bundler}
configuration file.

\texttt{bnd.bnd}: The module's metadata.

\texttt{build.gradle}: The module's dependencies and build properties.

\texttt{package.json}: The npm module manager.

\texttt{package-lock.json}: Automatically generated to track the npm
modules dependencies.

Get started creating the time field in the next tutorial.

\section{Creating Form Field Types}\label{creating-form-field-types}

Liferay's Forms application does not contain a dedicated time field
out-of-the-box. For ease of use and to ensure proper time data is
collected, you'll develop a time field and learn how Liferay DXP's field
types work at the same time.

There are several steps involved in creating a form field type:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Creating the Form Field Type's Java class.
\item
  Creating the Form Field Type Renderer Java class.
\item
  Defining the field's behavior in JavaScript and Soy templates.
\end{enumerate}

\noindent\hrulefill

\textbf{Blade Template:} To jump-start your project, use
\href{/docs/7-1/tutorials/-/knowledge_base/t/blade-cli}{Blade CLI} or
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-modules-with-liferay-ide}{Liferay
Dev Studio}. There's a Blade template for creating form fields. Using
the CLI, enter

\begin{verbatim}
 blade create -t form-field -v 7.1 -p com.liferay.docs.formfieldtype -c Time DDMTypeTime
\end{verbatim}

This gives you a \texttt{DDMTypeTime} module with a similar structure to
what's above. The Java classes are in the package
\texttt{com.liferay.docs.formfield} under \texttt{src/main/java/} and
the frontend resources (JavaScript and Soy files) are in
\texttt{sr/main/resources/META-INF/resources}.

A known limitation in the form-field template requires the use of camel
case in the project name (\texttt{DDMTypeTime}). Trying to use kebab
case instead (\texttt{ddm-type-time}) generates a non-functioning
module. This is fixed with the release of Blade 3.3. Run
\texttt{blade\ version} from the command line to see the version of
Blade you're running.

Using Blade CLI or Liferay Dev Studio, you get a project skeleton with
much of the boilerplate filled in, so you can focus immediately on
coding.

\noindent\hrulefill

Start by setting up the project's metadata.

\subsection{Specifying OSGi Metadata}\label{specifying-osgi-metadata-1}

First specify the necessary OSGi metadata in a \texttt{bnd.bnd} file
(see \href{http://bnd.bndtools.org/chapters/800-headers.html}{here} for
more information). Here's what it would look like for a module in a
folder called \texttt{dynamic-data-mapping-type-time}:

\begin{verbatim}
Bundle-Name: Liferay Dynamic Data Mapping Type Time
Bundle-SymbolicName: com.liferay.dynamic.data.mapping.type.time
Bundle-Version: 1.0.0
Liferay-JS-Config: /META-INF/resources/config.js
Web-ContextPath: /dynamic-data-mapping-type-time
\end{verbatim}

Point to the JavaScript configuration file (\texttt{config.js}) that
defines JavaScript modules added by your module (you'll get to that
later) and set the Web Context Path to the modules root folder, so your
module's resources are made available upon module activation.

Next craft the OSGi Component that marks your class as an implementation
of \texttt{DDMFormFieldType}.

\subsection{Creating a DDMFormFieldType
Component}\label{creating-a-ddmformfieldtype-component}

If you're creating a \emph{Time} field type, define the Component at the
top of your \texttt{*DDMFormFieldType} class like this:

\begin{verbatim}
@Component(
  immediate = true,
  property = {
    "ddm.form.field.type.description=time-field-type-description",
    "ddm.form.field.type.display.order:Integer=10",
    "ddm.form.field.type.icon=time",
    "ddm.form.field.type.js.class.name=Liferay.DDM.Field.Time",
    "ddm.form.field.type.js.module=liferay-ddm-form-field-time",
    "ddm.form.field.type.label=time-field-type-label",
    "ddm.form.field.type.name=time"
  },
  service = DDMFormFieldType.class
)
\end{verbatim}

Define the field type's properties (\texttt{property=...}) and declare
that you're implementing the \texttt{DDMFormFieldType} service
(\texttt{service=...}).

\texttt{DDMFormFieldType} Components can have several properties:

\begin{description}
\tightlist
\item[\texttt{ddm.form.field.type.description}]
An optional property describing the field type. Its localized value
appears in the form builder's sidebar, just below the field's label.
\item[\texttt{ddm.form.field.type.display.order}]
An Integer defining the field type's position in the sidebar.
\item[\texttt{ddm.form.field.type.icon}]
The icon for the field type. Choosing one of the
\href{https://lexicondesign.io/docs/patterns/icons.html}{Lexicon icons}
makes your form field blend in with the existing form field types.
\item[\texttt{ddm.form.field.type.js.class.name}]
The field type's JavaScript class name---the JavaScript file defines the
field type's behavior.
\item[\texttt{ddm.form.field.type.js.module}]
The name of the JavaScript module provided to the Form engine so the
module can be loaded when needed.
\item[\texttt{ddm.form.field.type.label}]
The field type's label. Its localized value appears in the form
builder's sidebar.
\item[\texttt{ddm.form.field.type.name}]
The field type's name must be unique. Each Component in a field type
module references the field type name, and it's used by OSGi service
trackers to filter the field's capabilities (for example, rendering and
validation).
\end{description}

Next code the \texttt{*DDMFormFieldType} class.

\subsection{Implementing
DDMFormFieldType}\label{implementing-ddmformfieldtype}

Implementing the field type in Java is made easier because of
\texttt{BaseDDMFormFieldType}, an abstract class you can leverage in
your code.

After extending \texttt{BaseDDMFormFieldType}, override the
\texttt{getName} method by specifying the name of your new field type:

\begin{verbatim}
public class TimeDDMFormFieldType extends BaseDDMFormFieldType {

    @Override
    public String getName() {
        return "time";
    }

}
\end{verbatim}

That's all there is to defining the field type. Next determine how your
field type is rendered.

\section{Rendering Field Types}\label{rendering-field-types}

Before you get to the front-end coding necessary to render your field
type, there's another Component to define and a Java class to code.

\subsection{\texorpdfstring{Implementing a
\texttt{DDMFormFieldRenderer}}{Implementing a DDMFormFieldRenderer}}\label{implementing-a-ddmformfieldrenderer}

The Component only has one property, \texttt{ddm.form.field.type.name},
and then you declare that you're adding a \texttt{DDMFormFieldRenderer}
implementation to the OSGi framework:

\begin{verbatim}
@Component(
    immediate = true, 
    property = "ddm.form.field.type.name=time",
    service = DDMFormFieldRenderer.class
)
\end{verbatim}

Extend \texttt{BaseDDMFormFieldRenderer}, an abstract class implementing
the API's only required method, \texttt{render}. The Form engine calls
the render method for every form field type present in a form, and
returns the plain HTML of the rendered field type. The abstract
implementation also includes some utility methods. Here's what the time
field's \texttt{DDMFormFieldRenderer} looks like:

\begin{verbatim}
public class TimeDDMFormFieldRenderer extends BaseDDMFormFieldRenderer {

    @Override
    public String getTemplateLanguage() {
        return TemplateConstants.LANG_TYPE_SOY;
    }

    @Override
    public String getTemplateNamespace() {
        return "DDMTime.render";
    }

    @Override
    public TemplateResource getTemplateResource() {
        return _templateResource;
    }

    @Activate
    protected void activate(Map<String, Object> properties) {
        _templateResource = getTemplateResource("/META-INF/resources/time.soy");
    }

    private TemplateResource _templateResource;

}
\end{verbatim}

Set the templating language (Soy closure templates), the template
namespace (\texttt{DDMTime}) and name (\texttt{render}), and point to
the location of the templates within your module
(\texttt{/META-INF/resources/time.soy}).

\subsection{Writing the Soy Template}\label{writing-the-soy-template}

Now it's time to write the template you referenced in the renderer
class: \texttt{time.soy} in the case of the time field type.

\noindent\hrulefill

\textbf{Note:}
\href{https://developers.google.com/closure/templates/}{Closure
templates} are a templating system for building UI elements. Liferay DXP
developers chose to build the Forms UI with closure templates because
they enable a smooth, responsive repainting of the UI as a user enters
data. With closure templates there's no need to reload the entire page
from the server when the UI is updated by the user: only the relevant
portion of the page is updated from the server. This makes for a smooth
user experience.

\noindent\hrulefill

Create

\begin{verbatim}
src/main/resources/META-INF/resources/time.soy
\end{verbatim}

and populate it with this:

\begin{verbatim}
{namespace DDMTime}

/**
* Defines the delegated template for the time field.
*/
{deltemplate ddm.field variant="'time'"}
    {call .render data="all" /}
{/deltemplate}

/**
* Prints the time field.
*/
{template .render}
    {@param name: string}
    {@param pathThemeImages: string}
    {@param value: ?}
    {@param visible: bool}
    {@param? dir: string}
    {@param? label: string}
    {@param? predefinedValue: string}
    {@param? readOnly: bool}
    {@param? required: bool}
    {@param? showLabel: bool}
    {@param? tip: string}

    {let $displayValue: $value ? $value : $predefinedValue ? $predefinedValue : '' /}

    <div class="form-group {$visible ? '' : 'hide'} liferay-ddm-form-field-time"
        data-fieldname="{$name}">
        {if $showLabel or $required}
            <label for="{$name}">
                {if $showLabel}
                    {$label}{sp}
                {/if}

                {if $required}
                    <svg aria-hidden="true" class="lexicon-icon lexicon-icon-asterisk reference-mark">
                        <use xlink:href="{$pathThemeImages}/lexicon/icons.svg#asterisk" />
                    </svg>
                {/if}
            </label>
        {/if}

        {if $showLabel}
            {if $tip}
                <span class="form-text">{$tip}</span>
            {/if}
        {/if}

        <div class="input-group">
            <div class="input-group-item">
                <input class="field form-control"
                    {if $dir}dir="{$dir}"{/if}
                    {if $readOnly}disabled{/if}
                    id="{$name}"
                    name="{$name}"
                    type="text"
                    value="{$displayValue}">
            </div>
        </div>
    </div>
{/template}
\end{verbatim}

There are four important things to do in the template:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Define the template namespace. The template namespace can define
  multiple templates for your field type by adding the namespace as a
  prefix.

\begin{verbatim}
{namespace DDMTime}
\end{verbatim}
\item
  Set the template that's called to render the time field. The
  \texttt{variant="\textquotesingle{}time\textquotesingle{}"} identifies
  the time field, and the \texttt{.render} names the template that
  renders it. The template itself follows and is defined through the
  block \texttt{\{template\ .render\}...\{/template\}}.

\begin{verbatim}
/**
* Defines the delegated template for the time field.
*/
{deltemplate ddm.field variant="'time'"}
    {call .render data="all" /}
{/deltemplate}
\end{verbatim}
\item
  Describe the template parameters. The template above uses some of the
  parameters as flags to display or hide some parts of the HTML (for
  example, the \texttt{\$required} parameter). All listed parameters are
  available by default.

\begin{verbatim}
{@param name: string}
{@param pathThemeImages: string}
{@param value: ?}
{@param visible: bool}
{@param? dir: string}
{@param? label: string}
{@param? predefinedValue: string}
{@param? readOnly: bool}
{@param? required: bool}
{@param? showLabel: bool}
{@param? tip: string}
\end{verbatim}
\item
  Write the template logic (everything encapsulated by the
  \texttt{\{template\ .render\}...\{/template\}} block). In the above
  example the template does these things:

  \begin{itemize}
  \item
    Checks whether to show the label of the field and if so, adds it.
  \item
    Checks if the field is required and adds \texttt{asterisk} if it is.
  \item
    Checks if a tip is provided and displays it.
  \item
    Provides the markup for the time field in the
    \texttt{\textless{}input\textgreater{}} tag. In this case a text
    input field is defined.
  \end{itemize}
\end{enumerate}

Once the template is defined, write the JavaScript file modeling your
field.

\subsection{Writing the JavaScript
Files}\label{writing-the-javascript-files}

Create a \texttt{time\_field.js} file and give it these contents:

\begin{verbatim}
AUI.add(
    'liferay-ddm-form-field-time',
    function(A) {
        var TimeField = A.Component.create(
            {
                ATTRS: {
                    type: {
                        value: 'time'
                    }
                },

                EXTENDS: Liferay.DDM.Renderer.Field,

                NAME: 'liferay-ddm-form-field-time',

                prototype: {
                }
            }
        );

        Liferay.namespace('DDM.Field').Time = TimeField;
    },
    '',
    {
        requires: ['liferay-ddm-form-renderer-field']
    }
);
\end{verbatim}

The JavaScript above creates a component called \texttt{TimeField}. The
component extends \texttt{Liferay.DDM.Renderer.Field}, which gives you
automatic injection of the default field parameters.

Next write the \texttt{*.es.js} file to configure the Soy template's
rendering. Create a file called \texttt{time.es.js} and populate it:

\begin{verbatim}
import Component from 'metal-component';
import Soy from 'metal-soy';
import templates from './time.soy';
/**
 * Time Component
 */
class Time extends Component {}
// Register component
Soy.register(Time, templates, 'render');
if (!window.DDMTime) {
    window.DDMTime = {
    };
}
window.DDMTime.render = Time;
export default Time;
\end{verbatim}

This dictates that the Soy template is called to render the
\texttt{Time} component. Then create the \texttt{config.js} file:

\begin{verbatim}
;(function() {
    AUI().applyConfig(
        {
            groups: {
                'field-time': {
                    base: MODULE_PATH + '/',
                    combine: Liferay.AUI.getCombine(),
                    filter: Liferay.AUI.getFilterConfig(),
                    modules: {
                        'liferay-ddm-form-field-time': {
                            condition: {
                                trigger: 'liferay-ddm-form-renderer'
                            },
                            path: 'time_field.js',
                            requires: [
                                'liferay-ddm-form-renderer-field'
                            ]
                        }
                    },
                    root: MODULE_PATH + '/'
                }
            }
        }
    );
})();
\end{verbatim}

This file is entirely boilerplate. In fact, if you use Blade CLI to
generate a field type module, you won't need to touch this file.
Functionally, it's a JavaScript file that defines the dependencies of
the declared JavaScript components (\texttt{requires...}), and where the
files are located (\texttt{path...}). The Alloy loader uses
\texttt{config.js} when it satisfies dependencies for each JavaScript
component. For more information about the Alloy loader see its
\href{/docs/7-1/tutorials/-/knowledge_base/t/loading-amd-modules-in-liferay}{tutorial}.

\begin{figure}
\centering
\includegraphics{./images/forms-time-field-type.png}
\caption{Add your own form field types to the Forms application.}
\end{figure}

If you build and deploy your new field type module, you get exactly what
you described in the \texttt{time.soy} file: a single text input field.
Of course, that's not what you want! You need a time picker.

\subsection{Adding Behavior to the
Field}\label{adding-behavior-to-the-field}

To do more than provide a text input field, define additional behavior
in the \texttt{time\_field.js} file.

To add an AlloyUI timepicker, first specify that your component requires
the \texttt{aui-timepicker} in the \texttt{requires...} block of the
\texttt{time\_field.js} and \texttt{config.js}:

\begin{verbatim}
{
    requires: ['aui-timepicker','liferay-ddm-form-renderer-field']
}
\end{verbatim}

Change the default rendering of the field by overwriting the base
\texttt{render} logic, instantiating the time picker, and adding the
chosen time to the field. This occurs in the \texttt{prototype} block:

\begin{verbatim}
prototype: {
    render: function() {
        var instance = this;

        TimeField.superclass.render.apply(instance, arguments);

        instance.timePicker = new A.TimePicker(
            {
                trigger: instance.getInputSelector(),
                popover: {
                    zIndex: 1
                },
                after: {
                    selectionChange: A.bind('afterSelectionChange', instance)
                }
            }
        );
    },

    afterSelectionChange: function(event) {
        var instance = this;

        var time = event.newSelection;

        instance.set('value', time);
    }
}
\end{verbatim}

Invoke the original render method---it prints markup required by the
Alloy time picker. Then instantiate the time picker, passing the field
type input as a \texttt{trigger}. In addition, add a callback method
(\texttt{afterSelectionChange}) to be executed \texttt{after} the time
is chosen in the time picker. This method updates the field's value. See
the \href{http://alloyui.com/tutorials/timepicker/}{Alloy documentation
for more information}.

Now when the field is rendered, there's a real time picker.

\begin{figure}
\centering
\includegraphics{./images/forms-timepicker.png}
\caption{The Alloy UI Timepicker in action.}
\end{figure}

Now you know how to create a new field type and define its behavior.
Currently, the field type only contains the default settings it inherits
from its superclasses. If that's not sufficient, create additional
settings for your field type. See the next tutorial to learn how.

\section{Adding Settings to Form Field
Types}\label{adding-settings-to-form-field-types}

Once you develop a
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-form-field-types}{Form
Field Type}, you might need to add settings to it. For example, a Time
field might accept different time formats. Here you'll learn how to add
settings to form field types by adding a \emph{mask} and a
\emph{placeholder} to the Time field type created in the previous
tutorial.

\noindent\hrulefill

\textbf{Note:} To learn more about using masks with the AUI Timepicker,
go \href{http://alloyui.com/tutorials/timepicker/}{here}. The mask just
sets the format used to display the time choices. Use the
\href{http://pubs.opengroup.org/onlinepubs/007908799/xsh/strftime.html}{strftime
format} to pick the mask you want.

\noindent\hrulefill

To add settings to form field types, take these steps:

\begin{itemize}
\item
  Write an interface that extends the default field type configuration,
  \texttt{DefaultDDMFormFieldTypeSettings}.
\item
  Update the \texttt{*FormFieldType} to refer the new interface created
  on the previous step.
\item
  Update the \texttt{*FormFieldRenderer} so it makes the new
  configuration options available to the JavaScript component and/or the
  Soy template for rendering.
\item
  Update the JavaScript component (defined in \texttt{time\_field.js} in
  our example) to configure the new settings and their default values.
\item
  Update the Soy template to include settings that must be rendered in a
  form (the placeholder, in our example).
\end{itemize}

First craft the interface that controls your field's settings.

\subsection{Extending the Default Type
Settings}\label{extending-the-default-type-settings}

To add type settings, you need a \texttt{*TypeSettings} class that
extends \texttt{DefaultDDMFormFieldTypeSettings}. Since this example
works with a Time field type, call it
\texttt{TimeDDMFormFieldTypeSettings}.

This class sets up the \emph{Field Type} configuration form.

\begin{figure}
\centering
\includegraphics{./images/forms-text-settings.png}
\caption{Like your custom field types, the text field type's settings
are configured in a Java interface.}
\end{figure}

Here's what it looks like:

\begin{verbatim}
package com.liferay.dynamic.data.mapping.type.time;

import com.liferay.dynamic.data.mapping.annotations.DDMForm;
import com.liferay.dynamic.data.mapping.annotations.DDMFormField;
import com.liferay.dynamic.data.mapping.annotations.DDMFormLayout;
import com.liferay.dynamic.data.mapping.annotations.DDMFormLayoutColumn;
import com.liferay.dynamic.data.mapping.annotations.DDMFormLayoutPage;
import com.liferay.dynamic.data.mapping.annotations.DDMFormLayoutRow;
import com.liferay.dynamic.data.mapping.form.field.type.DefaultDDMFormFieldTypeSettings;

@DDMForm
@DDMFormLayout(
    paginationMode = com.liferay.dynamic.data.mapping.model.DDMFormLayout.TABBED_MODE,
    value = {
        @DDMFormLayoutPage(
            title = "%basic",
            value = {
                @DDMFormLayoutRow(
                    {
                        @DDMFormLayoutColumn(
                            size = 12,
                            value = {
                                "label", "required", "tip", "mask",
                                "placeholder"
                            }
                        )
                    }
                )
            }
        ),
        @DDMFormLayoutPage(
            title = "%properties",
            value = {
                @DDMFormLayoutRow(
                    {
                        @DDMFormLayoutColumn(
                            size = 12,
                            value = {
                                "dataType", "name", "showLabel", "repeatable",
                                "type", "validation", "visibilityExpression"
                            }
                        )
                    }
                )
            }
        )
    }
)
public interface TimeDDMFormFieldTypeSettings
    extends DefaultDDMFormFieldTypeSettings {

    @DDMFormField(label = "%mask", predefinedValue="%I:%M %p")
    public String mask();

    @DDMFormField(label = "%placeholder-text")
    public String placeholder();
    
}
\end{verbatim}

Most of the work you need to do is in the class's annotations.

This class sets up a dynamic form with all the settings the form field
type needs. The form layout presented here gives your form the look and
feel of a native form field type. See the note below for more
information on the DDM annotations used in this form.

One thing to note is that all the default settings must be present in
your settings form. Note the list of settings present for each tab (each
\texttt{@DDMFormLayoutPage}) above. If you must make one of the default
settings unusable in the settings form for your field type, configure a
\emph{hide rule} for the field. Form field rules are configured using
the \texttt{@DDMFormRule} annotation.

The interface extends \texttt{DefaultDDMFormFieldTypeSettings}. That's
why the default settings can be used in the class annotation without
setting them up in the class, as was necessary for the mask and
placeholder.

\noindent\hrulefill

\textbf{DDM Annotations:} The \texttt{@DDMForm} annotation on this class
allows the form engine to convert the interface definition into a
dynamic form. This makes it really intuitive to lay out your settings
form.

For now, here are brief explanations for the annotations used in the
above example:

\begin{description}
\tightlist
\item[\texttt{@DDMForm}]
Instantiates a new \texttt{DDMForm}. Creates a dynamic form from the
annotation.
\item[\texttt{@DDMFormLayout}]
Takes two variables: \texttt{paginationMode} and \texttt{value}. The
pagination mode is a String that controls how the layout pages are
displayed. The \texttt{paginationMode} can be \texttt{TABBED\_MODE},
\texttt{SINGLE\_PAGE\_MODE}, \texttt{SETTINGS\_MODE}, or
\texttt{WIZARD\_MODE}. Under \texttt{value}, specify any
\texttt{@DDMFormLayoutPage}s that you want to use.
\item[\texttt{@DDMFormLayoutPage}]
The sections of the type settings form. It takes two variables:
\texttt{title} and \texttt{value}, where title is a String value that
names the section of the form and value is one or more
\texttt{@DDMFormLayoutRow}s.
\end{description}

The layout page titles \texttt{\%basic} and \texttt{\%properties} are
common to all of Liferay DXP's field types, but you can use whatever
titles you want. To change the title of a layout page, specify the title
in the annotation properties (\texttt{title\ \ =\ "\%advanced"}, for
example), and then create a new key in the language resources files. For
example, use \texttt{advanced=Advanced} in the
\texttt{Language.properties}.

\begin{description}
\tightlist
\item[\texttt{@DDMFormLayoutRow}]
Lay out the number of columns you want in the row. Most settings forms
have just one row and one column.
\item[\texttt{@DDMFormLayoutColumn}]
Lay out the columns your settings form needs. Most settings forms have
one row and one column. Each column accepts two argument, \texttt{size}
and \texttt{value}.
\item[\texttt{@DDMFormField}]
Add new fields to the settings form. In this example, the \texttt{mask}
and \texttt{placeholder} settings are configured with this annotation.
Don't forget to add the settings language keys (\texttt{mask} and
\texttt{placeholder-text}) to the language resources files.
\end{description}

\noindent\hrulefill

Once your \texttt{*TypeSettings} class is finished, update the
\texttt{*Type} class for your form field type.

\subsection{Updating the Type Class}\label{updating-the-type-class}

The class \texttt{TimeDDMFormFieldType} currently has one method,
\texttt{getName}, returning the name of the current form field. Add a
new method to reference \texttt{TimeDDMFormFieldTypeSettings} that holds
the specific settings of the Time field. This method already exists in
the base class (\texttt{BaseDDMFormFieldType}), so override it:

\begin{verbatim}
@Override
public Class<? extends DDMFormFieldTypeSettings>
    getDDMFormFieldTypeSettings() {

    return TimeDDMFormFieldTypeSettings.class;
}
\end{verbatim}

Next, render new Time field settings.

\section{Rendering Form Field
Settings}\label{rendering-form-field-settings}

Once the settings are added to the class backing the field's settings,
make sure the \texttt{*Renderer} can get the settings and update the
front-end code.

\subsection{Passing Settings to the Renderer
Class}\label{passing-settings-to-the-renderer-class}

Send the new configuration settings to the Soy template so they can be
displayed to the end user. Create a new Java class implementing the
interface \texttt{DDMFormFieldTemplateContextContributor} and modify the
existing class \texttt{*DDMFormFieldRenderer}.

The \texttt{DDMFormFieldTemplateContextContributor} interface has a
single method named \texttt{getParameters}. It gets the new
configuration settings, specific for a form field type, and sends for
the resources that need them, like the Soy template. To get these
settings, create a new class,
\texttt{TimeDDMFormFieldTemplateContextContributor}. First create its
OSGI component annotation and the class declaration:

\begin{verbatim}
@Component(
    immediate = true,
    property = "ddm.form.field.type.name=time",
    service = {
        DDMFormFieldTemplateContextContributor.class,
        TimeDDMFormFieldTemplateContextContributor.class
    }
)
public class TimeDDMFormFieldTemplateContextContributor
    implements DDMFormFieldTemplateContextContributor {
\end{verbatim}

Then override \texttt{getParameters} to get the new configurations
settings, \texttt{placeholder} and \texttt{mask}:

\begin{verbatim}
    @Override
    public Map<String, Object> getParameters(
        DDMFormField ddmFormField,
        DDMFormFieldRenderingContext ddmFormFieldRenderingContext) {

        Map<String, Object> parameters = new HashMap<>();

        parameters.put(
            "placeholder", (String)ddmFormField.getProperty("placeholder"));
        parameters.put("mask", (String)ddmFormField.getProperty("mask"));

        return parameters;
    }

}
\end{verbatim}

Now pass the configuration settings to the template with a new method,
\texttt{populateOptionalContext}, in \texttt{TimeDDMFormFieldRenderer}:

\begin{verbatim}
@Override
protected void populateOptionalContext(
    Template template, DDMFormField ddmFormField,
    DDMFormFieldRenderingContext ddmFormFieldRenderingContext) {

    Map<String, Object> parameters =
        timeDDMFormFieldTemplateContextContributor.getParameters(
            ddmFormField, ddmFormFieldRenderingContext);

    template.putAll(parameters);
}

@Reference
protected TimeDDMFormFieldTemplateContextContributor
    timeDDMFormFieldTemplateContextContributor;
\end{verbatim}

The \texttt{populateOptionalContext} method takes three parameters: The
template object, the \texttt{DDMFormField}, and the
\texttt{DDMFormFieldRenderingContext}. The \texttt{DDMFormField}
represents the definition of the field type instance: you can use this
object to access the configurations set for the field type (the mask and
placeholder settings in our case). The
\texttt{DDMFormFieldRenderingContext} object contains extra information
about the form like the user's locale, the HTTP request and response
objects, the portlet namespace, and more (all of its included properties
can be found
\href{https://docs.liferay.com/ce/apps/forms-and-workflow/latest/javadocs/com/liferay/dynamic/data/mapping/render/DDMFormFieldRenderingContext.html}{here}).

The OSGI reference (\texttt{@Reference}) provides access to the
\texttt{TimeDDMFormFieldTemplateContextContributor} service.

Now the JavaScript component and the Soy template can access the new
settings. Next, update the JavaScript Component so it handles these
properties and can use them, whether passing them to the template
context (similar to the \texttt{*Renderer}, only this time for
client-side rendering), or using them to configure the behavior of the
JavaScript component itself.

\noindent\hrulefill

\textbf{Note:} Remember that the Soy template is used for server side
and client side rendering. By defining the settings you're adding in
both the Java Renderer and the JavaScript Renderer, you're allowing for
the best possible user experience. For example, if a form builder is in
the form builder configuring a form field type, the configuration
entered can be directly passed to the template and become visible in the
UI almost instantly. However, when the user clicks into a form field
initially to begin editing, the rendering occurs from the server side.

\noindent\hrulefill

Next configure the JavaScript component to include the new settings.

\subsection{Adding Settings to the JavaScript
Component}\label{adding-settings-to-the-javascript-component}

The JavaScript component must know about the new settings. First
configure them as attributes of the component:

\begin{verbatim}
ATTRS: {
    mask: {
        value: '%I:%M %p'
    },
    placeholder: {
        value: ''
    },
    type: {
        value: 'time'
    }
},
\end{verbatim}

The mask setting has a default value of \texttt{\%I:\%M\ \%p}, and the
placeholder is blank. Now that the new settings are declared as
attributes of the component, make the JavaScript component pass the
placeholder configuration to the Soy template on the client side. Just
like in the Java renderer, pass the placeholder configuration to the
template context. In this case, override the
\texttt{getTemplateContext()} method to pass in the placeholder
configuration. Add this to the \texttt{prototype} section of the
JavaScript component definition:

\begin{verbatim}
getTemplateContext: function() {
    var instance = this;

    return A.merge(
        TimeField.superclass.getTemplateContext.apply(instance, arguments),
        {
            placeholder: instance.get('placeholder')
        }
    );
},
\end{verbatim}

Then in the component's render method, add the mask as an
\href{http://alloyui.com/api/classes/A.TimePicker.html\#attr_mask}{attribute
of the AUI Timepicker} using
\texttt{mask:\ instance.get(\textquotesingle{}mask\textquotesingle{})}.

\begin{verbatim}
render: function() {
    var instance = this;

    TimeField.superclass.render.apply(instance, arguments);

    instance.timePicker = new A.TimePicker(
        {
            trigger: instance.getInputSelector(),
            mask: instance.get('mask'),
            popover: {
                zIndex: 1
            },
            after: {
                selectionChange: A.bind('afterSelectionChange', instance)
            }
        }
    );
},
\end{verbatim}

Now the field type JavaScript component is configured to include the
settings. All you have left to do is to update the Soy template so the
placeholder can be rendered in the form with the time field.

\subsection{Updating the Soy Template}\label{updating-the-soy-template}

Add the placeholder setting to your Soy template's logic.

The whole template is included below, but the only additions are in the
list of parameters (adds the placeholder to the list of parameters---the
\texttt{?} indicates that the placeholder is not required), and then in
the \texttt{\textless{}input\textgreater{}} tag, where you use the
parameter value to configure the placeholder HTML property with the
proper value.

\begin{verbatim}
{namespace DDMTime}

/**
* Defines the delegated template for the time field.
*/
{deltemplate ddm.field variant="'time'"}
    {call .render data="all" /}
{/deltemplate}

/**
* Prints the time field.
*/
{template .render}
    {@param name: string}
    {@param pathThemeImages: string}
    {@param value: ?}
    {@param visible: bool}
    {@param? placeholder: string}
    {@param? dir: string}
    {@param? label: string}
    {@param? predefinedValue: string}
    {@param? readOnly: bool}
    {@param? required: bool}
    {@param? showLabel: bool}
    {@param? tip: string}

    {let $displayValue: $value ? $value : $predefinedValue ? $predefinedValue : '' /}

    <div class="form-group {$visible ? '' : 'hide'} liferay-ddm-form-field-time"
        data-fieldname="{$name}">
        {if $showLabel or $required}
            <label for="{$name}">
                {if $showLabel}
                    {$label}{sp}
                {/if}

                {if $required}
                    <svg aria-hidden="true" class="lexicon-icon lexicon-icon-asterisk reference-mark">
                        <use xlink:href="{$pathThemeImages}/lexicon/icons.svg#asterisk" />
                    </svg>
                {/if}
            </label>
        {/if}

        {if $showLabel}
            {if $tip}
                <span class="form-text">{$tip}</span>
            {/if}
        {/if}

        <div class="input-group">
            <div class="input-group-item">
                <input class="field form-control"
                    {if $dir}dir="{$dir}"{/if}
                    {if $readOnly}disabled{/if}
                    id="{$name}"
                    name="{$name}"
                    placeholder="{$placeholder}"
                    type="text"
                    value="{$displayValue}">
            </div>
        </div>
    </div>
{/template}
\end{verbatim}

The mask is not needed in the Soy template because it's only used in the
JavaScript for configuring the behavior of the timepicker. You don't
need the dynamic rendering of the Soy template to take the mask setting
and configure it in the form. The mask set by the form builder is
captured in the rendering of the timepicker itself.

Now when you build the project and deploy your time field, you have a
fully developed \emph{time} form field type, complete with the proper
JavaScript behavior and with additional settings.

\section{Forms Storage Adapters}\label{forms-storage-adapters}

When a User adds a form record, the Forms API routes the processing of
the request through the storage adapter API. The same is true for the
other \emph{CRUD} operations performed on form entries (read, update,
and delete operations). The default implementation of the storage
service is called \texttt{JSONStorageAdapter}, and as its name implies,
it implements the \texttt{StorageAdapter} interface to provide JSON
storage of form entry data.

The DDM backend can \emph{adapt} to other data storage formats for form
records. Want to store your data in XML? YAML? No problem. Because the
storage API is separated from the regular service calls used to populate
the database table for form entries, a developer can even choose to
store form data outside the Liferay database.

Define your own format to save form entries by
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-projects-with-blade-cli}{writing
an OSGi component} that implements the \texttt{StorageAdapter}
interface. The interface follows the \emph{CRUD} approach, so
implementing it requires that you write methods to create, read, update
and delete form values.

\noindent\hrulefill

\textbf{Note:} When you add a new storage adapter, it can only be used
with new Forms. All existing Forms continue to use the adapter selected
(JSON by default) at the time of their creation, and a different storage
adapter cannot be selected.

\noindent\hrulefill

The example storage adapter in this tutorial serializes form data to be
stored in a simple file, stored on the file system.

\begin{figure}
\centering
\includegraphics{./images/forms-storage-type.png}
\caption{Choose a Storage Type for your form records.}
\end{figure}

Note that these code snippets include the references to the services
they're calling directly beneath the first method that uses the service.
It's a Liferay code convention to place these at the very end of the
class.

\subsection{Implementing a Storage
Adapter}\label{implementing-a-storage-adapter}

First declare the class a \texttt{Component} that provides a
\texttt{StorageAdapter} implementation. To implement a storage adapter,
extend the abstract \texttt{BaseStorageAdapter} class.

\begin{verbatim}
@Component(service = StorageAdapter.class)
public class FileSystemStorageAdapter extends BaseStorageAdapter {
\end{verbatim}

\subsubsection{Step 1: Name the Storage
Type}\label{step-1-name-the-storage-type}

The only method without a base implementation in the abstract class is
\texttt{getStorageType}. For the file system storage example, just make
it return \texttt{"File\ System"}.

\begin{verbatim}
@Override
public String getStorageType() {
    return "File System";
}
\end{verbatim}

Return a human readable String, as \texttt{getStorageType} determines
what appears in the UI when the form creator is selecting a storage type
for their form. The String value you return here is added to the
\texttt{StorageAdapterRegistry}'s Map of storage adapters.

\subsubsection{Step 2: Override the CRUD
Methods}\label{step-2-override-the-crud-methods}

Next override the \texttt{doCreateMethod} to return a \texttt{long} that
identifies each form record with a unique file ID:

\begin{verbatim}
@Override
protected long doCreate(
    long companyId, long ddmStructureId, DDMFormValues ddmFormValues, 
    ServiceContext serviceContext)
    throws Exception {

    validate(ddmFormValues, serviceContext);

    long fileId = _counterLocalService.increment();

    DDMStructureVersion ddmStructureVersion =
        _ddmStructureVersionLocalService.getLatestStructureVersion(
            ddmStructureId);

    long classNameId = PortalUtil.getClassNameId(
        FileSystemStorageAdapter.class.getName());

    _ddmStorageLinkLocalService.addStorageLink(
        classNameId, fileId, ddmStructureVersion.getStructureVersionId(),
        serviceContext);

    saveFile(
        ddmStructureVersion.getStructureVersionId(), fileId, ddmFormValues);

    return fileId;
}

@Reference
private CounterLocalService _counterLocalService;

@Reference
private DDMStorageLinkLocalService _ddmStorageLinkLocalService;

@Reference
private DDMStructureVersionLocalService _ddmStructureVersionLocalService;
\end{verbatim}

The first line in this method (and the subsequent \texttt{doUpdate}
method) calls a
\hyperref[step-3-validating-form-entries]{\texttt{validate}} method
that's not yet written, so don't save the class until you've written
that method.

In addition to returning the file ID, add a storage link via the
\texttt{DDMStorageLinkLocalService}. The DDM Storage Link associates
each form record with the DDM Structure backing the form.

The \texttt{addStorageLink} method takes class name ID as retrieved by
\texttt{PortalUtil.getClassNameId}, the \texttt{fileId} (used as the
primary key for the file storage type), the structure version ID, and
the service context. There's also a call to a \texttt{saveFile} method,
which serializes the forms record's values and uses two additional
utility methods (\texttt{getStructureFolder} and \texttt{getFile}) to
write a \texttt{java.io.File} object. There are some other utility
methods invoked as well:

\begin{verbatim}
private File getFile(long structureId, long fileId) {
    return new File(
        getStructureFolder(structureId), String.valueOf(fileId));
}

private File getStructureFolder(long structureId) {
    return new File(String.valueOf(structureId));
}

private void saveFile(
        long structureVersionId, long fileId, DDMFormValues formValues)
    throws IOException {

    String serializedDDMFormValues = _ddmFormValuesJSONSerializer.serialize(
        formValues);

    File formEntryFile = getFile(structureVersionId, fileId);

    FileUtil.write(formEntryFile, serializedDDMFormValues);
}

@Reference
private DDMFormValuesJSONSerializer _ddmFormValuesJSONSerializer;
\end{verbatim}

Note the call to the \texttt{write} method.\texttt{FileUtil} is a
Liferay utility class for manipulating \texttt{java.io.File} objects. By
default, the \texttt{write} method writes the data into the user home
folder of your system.

Override the \texttt{doDeleteByClass} method to delete the \texttt{File}
using the \texttt{classPK}:

\begin{verbatim}
@Override
protected void doDeleteByClass(long classPK) throws Exception {
    DDMStorageLink storageLink =
        _ddmStorageLinkLocalService.getClassStorageLink(classPK);

    FileUtil.delete(getFile(storageLink.getStructureId(), classPK));

    _ddmStorageLinkLocalService.deleteClassStorageLink(classPK);
}
\end{verbatim}

Once the file is deleted, its storage links should also be deleted. Use
\texttt{doDeleteByDDMStructure} for this logic:

\begin{verbatim}
@Override
protected void doDeleteByDDMStructure(long ddmStructureId)
    throws Exception {

    FileUtil.deltree(getStructureFolder(ddmStructureId));

    _ddmStorageLinkLocalService.deleteStructureStorageLinks(ddmStructureId);
}
\end{verbatim}

To retrieve the form record's values from the \texttt{File} object where
they were written, override \texttt{doGetDDMFormValues}:

\begin{verbatim}
@Override
protected DDMFormValues doGetDDMFormValues(long classPK) throws Exception {
    DDMStorageLink storageLink =
        _ddmStorageLinkLocalService.getClassStorageLink(classPK);

    DDMStructureVersion structureVersion =
        _ddmStructureVersionLocalService.getStructureVersion(
            storageLink.getStructureVersionId());

    String serializedDDMFormValues = FileUtil.read(
        getFile(structureVersion.getStructureVersionId(), classPK));

    return _ddmFormValuesJSONDeserializer.deserialize(
        structureVersion.getDDMForm(), serializedDDMFormValues);
}

@Reference
private DDMFormValuesJSONDeserializer _ddmFormValuesJSONDeserializer;
\end{verbatim}

Override the \texttt{doUpdate} method so the record's values can be
overwritten. This example calls the \texttt{saveFile} utility method
provided earlier:

\begin{verbatim}
@Override
protected void doUpdate(
        long classPK, DDMFormValues ddmFormValues,
        ServiceContext serviceContext)
    throws Exception {

    validate(ddmFormValues, serviceContext);

    DDMStorageLink storageLink =
        _ddmStorageLinkLocalService.getClassStorageLink(classPK);

    saveFile(
        storageLink.getStructureVersionId(), storageLink.getClassPK(),
        ddmFormValues);
}
\end{verbatim}

Once the CRUD logic is defined, deploy and test the storage adapter.

\subsection{Step 3: Validating Form
Entries}\label{step-3-validating-form-entries}

The \texttt{doCreate} and \texttt{doUpdate} methods above both include
this line:

\begin{verbatim}
validate(ddmFormValues, serviceContext);
\end{verbatim}

Because the Storage Adapter handles User entered data, it's important to
validate that the entries include only appropriate data. Add a
\texttt{validate} method to the \texttt{StorageAdapter}:

\begin{verbatim}
protected void validate(
    DDMFormValues ddmFormValues, ServiceContext serviceContext)
    throws Exception {

    boolean validateDDMFormValues = GetterUtil.getBoolean(
        serviceContext.getAttribute("validateDDMFormValues"), true);

    if (!validateDDMFormValues) {
        return;
    }

    _ddmFormValuesValidator.validate(ddmFormValues);
}
\end{verbatim}

Make sure to do three things:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Retrieve the value of the \texttt{validateDDMFormValues} attribute.
\item
  If \texttt{validateDDMFormValues} is false, exit the validation
  without doing anything.

  When a User accesses a form at its dedicated link, there's a periodic
  auto-save process of in-progress form values. There's no need to
  validate this data until the User hits the \emph{Submit} button on the
  form, so the auto-save process sets the \texttt{validateDDMFormValues}
  attribute to \texttt{false}.
\item
  Otherwise, call the validate method from the
  \texttt{DDMFormValuesValidator} service.
\end{enumerate}

Once the necessary logic is in place, deploy and test the Storage
Adapter.

\subsection{Enabling the Storage
Adapter}\label{enabling-the-storage-adapter}

The storage adapter is enabled at the individual form level. Create a
new form, and select the Storage Adapter \emph{before saving or
publishing the form}. If you wait until first Saving the Form, the
default Storage Adapter is already assigned to the Form, and this
setting is no longer editable.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Go to the Site Menu → Content → Forms, and click the \emph{Add} button
  (\includegraphics{./images/icon-add.png}).
\item
  In the Form Builder view, click the \emph{Options} button
  (\includegraphics{./images/icon-options.png}) and open the
  \emph{Settings} window.
\item
  From the select list field called \emph{Select a Storage Type}, choose
  the desired type and click \emph{Done}.
\end{enumerate}

Now all the form's entries are stored in the desired format.

\chapter{Workflow}\label{workflow}

Use the workflow framework to run assets through a business process that
suit your organization's needs. Workflow processes are created using XML
or via the handy
\href{https://help.liferay.com/hc/en-us/articles/360017894912-Kaleo-Designer}{Kaleo
Designer} tool that comes with DE subscriptions.

\begin{figure}
\centering
\includegraphics{./images/legal-marketing-def.png}
\caption{If you don't like XML, the visual Kaleo Designer makes
designing workflows easy and intuitive.}
\end{figure}

This set of tutorials delves into the following workflow framework
topics:

\begin{itemize}
\tightlist
\item
  Creating Workflow Definitions (using XML)
\item
  Enabling Assets for Workflow
\item
  Creating Workflow Engine Adapters
\end{itemize}

To manage workflow definitions and define their assignment schemes,
check out the \href{/docs/7-1/user/-/knowledge_base/u/workflow}{workflow
section of the administrator documentation}(not yet written).

\chapter{Crafting XML Workflow
Definitions}\label{crafting-xml-workflow-definitions}

You don't need a fancy visual designer to build workflows. To be clear,
Kaleo Designer may make you a faster workflow designer through its
graphical interface. If you plan to build lots of workflow processes, a
Digital Enterprise subscription gets you access to Kaleo Designer. But
with a little copy and paste from existing workflows and a little
handcrafted XML, you can build any workflow and attain workflow
wizard-hood in the process. Follow this set of tutorials to learn what
elements you can put into your definitions.

\section{Existing Workflow
Definitions}\label{existing-workflow-definitions}

Only one workflow definition is installed by default: Single Approver.
Several more, however, are embedded in the source code of your Liferay
DXP installation. If you're comfortable extracting the XML files from a
JAR file embedded in an LPKG file, you're welcome to follow the steps
below to obtain the workflow definitions. To obtain the files more
conveniently, download a ZIP file
\href{https://portal.liferay.dev/documents/113763090/114000653/Workflow+Definitions+Zip.zip}{here}.

To extract the definitions for yourself, navigate to

\begin{verbatim}
[Liferay Home]/osgi/marketplace
\end{verbatim}

and open (using an archive manager)
\texttt{Liferay\ CE\ Forms\ and\ Workflow.lpkg}. Open the JAR file named

\begin{verbatim}
com.liferay.portal.workflow.kaleo.runtime.impl-[version].jar
\end{verbatim}

In the JAR file, navigate to

\begin{verbatim}
META-INF/definitions/
\end{verbatim}

and extract the four XML workflow definition files. These definitions
provide good reference material for many of the workflow features and
elements described in these articles. In fact, most of the XML snippets
you see here are lifted directly from these definitions.

\section{Schema}\label{schema}

The XML structure of a workflow definition is defined in an XSD file:

\begin{verbatim}
liferay-worklow-definition-7_0_0.xsd
\end{verbatim}

Declare the schema at the top of the workflow definition file:

\begin{verbatim}
<?xml version="1.0"?>
<workflow-definition
    xmlns="urn:liferay.com:liferay-workflow_7.0.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
    xsi:schemaLocation="urn:liferay.com:liferay-workflow_7.0.0 
        http://www.liferay.com/dtd/liferay-workflow-definition_7_0_0.xsd">
\end{verbatim}

To read 464 lines of beautifully formatted XML that defines how to write
more XML (it's practically poetic), check out the XSD
\href{https://www.liferay.com/dtd/liferay-workflow-definition_7_0_0.xsd}{here}.
Otherwise, move on to entering the definition's metadata.

\section{Metadata}\label{metadata}

Give the definition a name, description, and version:

\begin{verbatim}
<name>Category Specific Approval</name>
<description>A single approver can approve a workflow content.</description>
<version>1</version>
\end{verbatim}

All these tags are optional. If present the first time a definition is
saved, the \texttt{\textless{}name\textgreater{}} tag serves as a unique
identifier for the definition. If not specified (or added sometime after
the first save), a random unique name is generated and used to identify
the workflow.

Once the schema and metadata are in place, it's time to turn up the
funky beats and get into the flow (the workflow). Learn about workflow
nodes in the next article.

\section{Workflow Definition Nodes}\label{workflow-definition-nodes}

After your definition's schema and metadata are in place, begin defining
the process. \emph{Node} elements, with their sub-elements, are
fundamental building blocks making up workflow definitions.

\textbf{State Nodes} don't require user input. The workflow does
whatever is specified in the state node's \texttt{actions} tag (a
notification and/or a custom script), and then moves to the provided
transition. Workflows start and end with a state. The initial state node
often only contains a transition:

\begin{verbatim}
    <state>
        <name>created</name>
        <initial>true</initial>
        <transitions>
            <transition>
                <name>Determine Branch</name>
                <target>determine-branch</target>
                <default>true</default>
            </transition>
        </transitions>
    </state>
\end{verbatim}

If a notification or script is required in your state node, use an
\texttt{actions} tag. Here's an \texttt{action} element containing a
Groovy script. This is found in many terminal state nodes and marks the
asset as approved in the workflow.

\begin{verbatim}
    <actions>
        <action>
            <name>Approve</name>
            <description>Approve</description>
            <script>
                <![CDATA[
                com.liferay.portal.kernel.workflow.WorkflowStatusManagerUtil.
                    updateStatus(com.liferay.portal.kernel.workflow.WorkflowConstants.     
                        getLabelStatus("approved"), workflowContext);]]>
            </script>
            <script-language>groovy</script-language>
            <execution-type>onEntry</execution-type>
        </action>
    </actions>
\end{verbatim}

\textbf{Conditions} let you inspect the asset (or its execution context)
and do something, like send it to a particular transition.

Here's the \texttt{determine-branch} condition from the Category
Specific Approval workflow definition:

\begin{verbatim}
    <condition>
        <name>determine-branch</name>
        <script>
            <![CDATA[
                import com.liferay.asset.kernel.model.AssetCategory;
                import com.liferay.asset.kernel.model.AssetEntry;
                import com.liferay.asset.kernel.model.AssetRenderer;
                import com.liferay.asset.kernel.model.AssetRendererFactory;
                import com.liferay.asset.kernel.service.AssetEntryLocalServiceUtil;
                import com.liferay.portal.kernel.util.GetterUtil;
                import com.liferay.portal.kernel.workflow.WorkflowConstants;
                import com.liferay.portal.kernel.workflow.WorkflowHandler;
                import com.liferay.portal.kernel.workflow.WorkflowHandlerRegistryUtil;

                import java.util.List;

                String className = (String)workflowContext.get(WorkflowConstants.CONTEXT_ENTRY_CLASS_NAME);

                WorkflowHandler workflowHandler = WorkflowHandlerRegistryUtil.getWorkflowHandler(className);

                AssetRendererFactory assetRendererFactory = workflowHandler.getAssetRendererFactory();

                long classPK = GetterUtil.getLong((String)workflowContext.get(WorkflowConstants.CONTEXT_ENTRY_CLASS_PK));

                AssetRenderer assetRenderer = workflowHandler.getAssetRenderer(classPK);

                AssetEntry assetEntry = assetRendererFactory.getAssetEntry(assetRendererFactory.getClassName(), assetRenderer.getClassPK());

                List<AssetCategory> assetCategories = assetEntry.getCategories();

                returnValue = "Content Review";

                for (AssetCategory assetCategory : assetCategories) {
                    String categoryName = assetCategory.getName();

                    if (categoryName.equals("legal")) {
                        returnValue = "Legal Review";

                        return;
                    }
                }
            ]]>
        </script>
        <script-language>groovy</script-language>
        <transitions>
            <transition>
                <name>Legal Review</name>
                <target>legal-review</target>
                <default>false</default>
            </transition>
            <transition>
                <name>Content Review</name>
                <target>content-review</target>
                <default>false</default>
            </transition>
        </transitions>
    </condition>
\end{verbatim}

This example checks the asset category to choose the processing path,
whether to transition to the \emph{Legal Review} task or the
\emph{Content Review} task.

The \texttt{returnValue} variable points from the condition to a
transition, and its value must match a valid transition name. This
script looks up the asset in question, retrieves its
\href{/docs/7-0/user/-/knowledge_base/u/organizing-content-with-tags-and-categories\#defining-categories-for-content}{asset
category}, and sets an initial \texttt{returnValue}. Then it checks to
see if the asset has been marked with the \emph{legal} category. If not
it goes through \emph{Content Review} (to the content-review task in the
workflow), and if it does it goes through \emph{Legal Review} (to the
legal-review task in the workflow).

\textbf{Forks and Joins:} Forks split the workflow process, and joins
bring the process back to a unified branch. Processing must always be
brought back using a Join (or a Join XOR), and the number of forks and
joins in a workflow definition must be equal.

\begin{verbatim}
    <fork>
        <name>fork-1</name>
        <transitions>
            <transition>
                <name>transition-1</name>
                <target>task-1</target>
                <default>true</default>
            </transition>
            <transition>
                <name>transition-2</name>
                <target>task-2</target>
                <default>false</default>
            </transition>
        </transitions>
    </fork>
    <join>
        <name>join-1</name>
        <transitions>
            <transition>
                <name>transition-4</name>
                <target>EndNode</target>
                <default>true</default>
            </transition>
        </transitions>
    </join>
\end{verbatim}

The workflow doesn't move past the join until the asset transitions to
it from both of the forks. To fork the workflow process, but then allow
the processing to continue when only one fork is completed, use a Join
XOR.

A Join XOR differs from a join in one important way: it removes the
constraint that both forks must be completed before processing can
continue. The asset must complete just one of the forks before
processing continues.

\begin{verbatim}
    <join-xor>
        <name>join-xor</name>
        <transitions>
            <transition>
                <name>transition3</name>
                <target>EndNode</target>
                <default>true</default>
            </transition>
        </transitions>
    </join-xor>
\end{verbatim}

\href{/docs/7-1/tutorials/-/knowledge_base/t/workflow-task-nodes}{\textbf{Task
nodes}} are at the core of the workflow definition. They're the part
where a user interacts with the asset in some way. Tasks can also have
sub-elements, including notifications, assignments, and task timers.

Here's the \texttt{content-review} task from the Category Specific
Approval workflow, with some of the \texttt{role} assignment tags cut
out for brevity:

\begin{verbatim}
    <task>
        <name>content-review</name>
        <actions>
            <notification>
                <name>Review Notification</name>
                <template>You have a new submission waiting for your review in the workflow.</template>
                <template-language>text</template-language>
                <notification-type>email</notification-type>
                <notification-type>user-notification</notification-type>
                <execution-type>onAssignment</execution-type>
            </notification>
        </actions>
        <assignments>
            <roles>
                <role>
                    <role-type>organization</role-type>
                    <name>Organization Administrator</name>
                </role>
                ...
            </roles>
        </assignments>
        <task-timers>
            <task-timer>
                <name></name>
                <delay>
                    <duration>1</duration>
                    <scale>hour</scale>
                </delay>
                <blocking>false</blocking>
                <timer-actions>
                    <timer-notification>
                        <name></name>
                        <template></template>
                        <template-language>text</template-language>
                        <notification-type>user-notification</notification-type>
                    </timer-notification>
                </timer-actions>
            </task-timer>
        </task-timers>
        <transitions>
            <transition>
                <name>approve</name>
                <target>approved</target>
                <default>true</default>
            </transition>
            <transition>
                <name>reject</name>
                <target>update</target>
                <default>false</default>
            </transition>
        </transitions>
    </task>
\end{verbatim}

Learn more about workflow tasks in the next article.

\section{Workflow Task Nodes}\label{workflow-task-nodes}

Task nodes are fundamental parts of a workflow definition. When you
define your organization's business processes and design corresponding
workflows, you likely first envision the tasks. As the name implies,
tasks are the part of the workflow where \emph{work} is done. A user
enters the picture and must interact with the submitted asset. Users
often take the role of reviewer, deciding if an asset from the workflow
is acceptable for publication or needs more work.

Unlike other workflow nodes, task nodes have Assignments, because a user
is expected to \emph{do something} (often approve or reject the
submitted asset) when a workflow process enters the task node.

Commonly, task nodes contain task timers, assignments, actions (which
can include notifications and scripts), and transitions. Notifications
and actions aren't limited to task nodes, but task nodes and their
assignments deserve their own article (this one).

Check out the Review task in the Single Approver definition, noting that
several \texttt{\textless{}role\textgreater{}} tags are excluded from
this snippet for brevity:

\begin{verbatim}
<task>
    <name>review</name>
    <actions>
        <notification>
            <name>Review Notification</name>
            <template>${userName} sent you a ${entryType} for review in the workflow.</template>
            <template-language>freemarker</template-language>
            <notification-type>email</notification-type>
            <notification-type>user-notification</notification-type>
            <execution-type>onAssignment</execution-type>
        </notification>
        <notification>
            <name>Review Completion Notification</name>
            <template><![CDATA[Your submission was reviewed<#if taskComments?has_content> and the reviewer applied the following ${taskComments}</#if>.]]></template>
            <template-language>freemarker</template-language>
            <notification-type>email</notification-type>
            <recipients>
                <user />
            </recipients>
            <execution-type>onExit</execution-type>
        </notification>
    </actions>
    <assignments>
        <roles>
            <role>
                <role-type>organization</role-type>
                <name>Organization Administrator</name>
            </role>
            ...
        </roles>
    </assignments>
    <transitions>
        <transition>
            <name>approve</name>
            <target>approved</target>
        </transition>
        <transition>
            <name>reject</name>
            <target>update</target>
            <default>false</default>
        </transition>
    </transitions>
</task>
\end{verbatim}

There are two \texttt{actions} in the review task, both
\texttt{\textless{}notification\textgreater{}}s. Each notification may
contain a name, template, notification-type, execution-type, and
recipients. Besides notifications, You can also use the
\texttt{\textless{}action\textgreater{}} tag. These have a name and a
\href{/docs/7-1/user/-/knowledge_base/u/leveraging-the-script-engine-in-workflow}{script}
and are more often used in state nodes than tasks.

\subsection{Assignments}\label{assignments}

Workflow tasks are completed by a user. Assignments make sure the right
users can access the tasks. You can choose how you want to configure
your assignments.

You can choose to add assignments to specific roles, to multiple roles
of a role type (organization, site, or regular role types), to the asset
creator, to resource actions, or to specific users. Additionally, you
can write a script to define the assignment. For an example, see the
\texttt{single-approver-definition-scripted-assignment.xml}.

\begin{verbatim}
<assignments>
    <roles>
        <role>
            <role-type>organization</role-type>
            <name>Organization Administrator</name>
        </role>
    </roles>
</assignments>
\end{verbatim}

The above assignment specifies that an Organization Administrator must
complete the task.

\begin{verbatim}
<assignments>
    <user>
        <user-id>20156</user-id>
    </user>
</assignments>
\end{verbatim}

The above assignment specifies that only the user with the user ID of
20156 may complete the task. Alternatively, specify the
\texttt{\textless{}screen-name\textgreater{}} or
\texttt{\textless{}email-address\textgreater{}} of the user.

\begin{verbatim}
    <assignments>
        <scripted-assignment>
            <script>
                <![CDATA[
                        import com.liferay.portal.kernel.model.Group;
                        import com.liferay.portal.kernel.model.Role;
                        import com.liferay.portal.kernel.service.GroupLocalServiceUtil;
                        import com.liferay.portal.kernel.service.RoleLocalServiceUtil;
                        import com.liferay.portal.kernel.util.GetterUtil;
                        import com.liferay.portal.kernel.workflow.WorkflowConstants;

                        long companyId = GetterUtil.getLong((String)workflowContext.get(WorkflowConstants.CONTEXT_COMPANY_ID));

                        long groupId = GetterUtil.getLong((String)workflowContext.get(WorkflowConstants.CONTEXT_GROUP_ID));

                        Group group = GroupLocalServiceUtil.getGroup(groupId);

                        roles = new ArrayList<Role>();

                        Role adminRole = RoleLocalServiceUtil.getRole(companyId, "Administrator");

                        roles.add(adminRole);

                        if (group.isOrganization()) {
                            Role role = RoleLocalServiceUtil.getRole(companyId, "Organization Content Reviewer");

                            roles.add(role);
                        }
                        else {
                            Role role = RoleLocalServiceUtil.getRole(companyId, "Site Content Reviewer");

                            roles.add(role);
                        }

                        user = null;
                    ]]>
                </script>
            <script-language>groovy</script-language>
        </scripted-assignment>
    </assignments>
\end{verbatim}

The above assignment assigns the task to the \emph{Administrator} role,
then checks whether the \emph{group} of the asset is an Organization. If
it is, the \emph{Organization Content Reviewer} role is assigned to it.
If it's not, the task is assigned to the \emph{Site Content Reviewer}
role.

Note the
\texttt{roles\ =\ new\ ArrayList\textless{}Role\textgreater{}();} line
above. In a scripted assignment, the \texttt{roles} variable is where
you specify any roles the task is assigned to. For example, when
\texttt{roles.add(adminRole);} is called, the Administrator role is
added to the assignment.

Assigning tasks to Roles, Organizations, or Asset Creators is a
straightforward concept, but what does it mean to assign a workflow task
to a Resource Action? Imagine an \emph{UPDATE} resource action. If your
workflow definition specifies the UPDATE action in an assignment, then
anyone who has permission to update the type of asset being processed in
the workflow is assigned to the task. You can configure multiple
assignments for a task.

\subsection{Resource Action
Assignments}\label{resource-action-assignments}

\emph{Resource actions} are operations performed by users on an
application or entity. For example, a user might have permission to
update Message Boards Messages. This is called an UPDATE resource
action, because the user can update the resource. If you're uncertain
about what resource actions are, refer to the developer tutorial on the
\href{/docs/7-1/tutorials/-/knowledge_base/t/defining-application-permissions}{permission
system} for a more detailed explanation.

To find all the resource actions that have been created, you need access
to the Roles Admin application in the Control Panel (in other words, you
need permission for the VIEW action on the roles resource).

\begin{itemize}
\tightlist
\item
  Navigate to Control Panel → Users → Roles.
\item
  Add a new Regular Role. See the
  \href{/docs/7-1/user/-/knowledge_base/u/roles-and-permissions}{article
  on managing roles} for more information.
\item
  Once the role is added, navigate to the Define Permissions interface
  for the role.
\item
  Find the resource whose action should define your workflow assignment.
\end{itemize}

Here's what the assignment's XML looks like:

\begin{verbatim}
<assignments>
    <resource-actions>
        <resource-action>UPDATE</resource-action>
    </resource-actions>
</assignments>
\end{verbatim}

Now when the workflow proceeds to the task with the resource action
assignment, users with \texttt{UPDATE} permission on the resource (for
example, Message Boards Messages) are notified of the task and can
assign it to themselves (if the notification is set to Task Assignees).
Specifically, users see the tasks in their \emph{My Workflow Tasks}
application under the tab \emph{Assigned to My Roles}.

Use all upper case letters for resource action names. Here are some
common resource actions:

\begin{verbatim}
UPDATE
ADD
DELETE
VIEW
PERMISSIONS
SUBSCRIBE
ADD_DISCUSSION
\end{verbatim}

Determine the probable resource action name from the permissions screen
for a resource. For example, in Message Boards, one of the permissions
displayed on that screen is \emph{Add Discussion}. Convert that to all
uppercase and replace the space with an underscore, and you have the
action name.

\subsection{Task Timers}\label{task-timers}

Task timers trigger an action after a specified time period passes.
Timers are useful for ensuring a task does not go unattended for a long
time. Available timer actions include sending an additional
notification, reassigning the asset, or creating a timer action.

\begin{verbatim}
<task-timers>
    <task-timer>
        <name></name>
        <delay>
            <duration>1</duration>
            <scale>hour</scale>
        </delay>
        <blocking>false</blocking>
        <recurrence>
            <duration>10</duration>
            <scale>minute</scale>
        </recurrence>
        <timer-actions>
            <timer-notification>
                <name></name>
                <template></template>
                <template-language>text</template-language>
                <notification-type>user-notification</notification-type>
            </timer-notification>
        </timer-actions>
    </task-timer>
</task-timers>
\end{verbatim}

The above task timer creates a notification. Specify a time period in
the \texttt{\textless{}delay\textgreater{}} tag, and specify what action
to take when the time expires in the
\texttt{\textless{}timer-actions\textgreater{}} block. The
\texttt{\textless{}blocking\textgreater{}} element specifies whether the
timer actions may recur. If blocking is set to \texttt{false}, timer
actions may recur. In a \texttt{recurrence} element, specify the
recurrence interval using a \texttt{duration} and a \texttt{scale}, as
demonstrated above. The above recurrence element specifies that the
timer actions run again every ten minutes after the initial occurrence.
Setting blocking to true prevents timer actions from recurring.

\begin{verbatim}
<timer-actions>
    <reassignments>
       <assignments>
         <roles>
          <role>
              <role-type></role-type>
              <name></name>
          </role>
          ...
         </roles>
       </assignments>
    </reassignments>
</timer-actions>
\end{verbatim}

The above snippet demonstrates how to set up a reassignment action.

Like \texttt{\textless{}action\textgreater{}} elements,
\texttt{\textless{}timer-action\textgreater{}} elements can contain
scripts.

\begin{verbatim}
<timer-actions>
    <timer-action>
        <name>doSomething</name>
        <description>Do something cool when time runs out.</description>
        <script>
           ...
        </script>
        <script-language>groovy</script-language>
    </timer-action>
</timer-actions>
\end{verbatim}

The above example isn't functional but it demonstrates setting up a
\texttt{\textless{}script\textgreater{}} in your task timer.
\href{/docs/7-1/user/-/knowledge_base/u/leveraging-the-script-engine-in-workflow}{Read
the Scripting in Workflow article} for more information.

\noindent\hrulefill

\textbf{Note:} A \texttt{timer-action} can contain all the same tags as
an \texttt{action}, with one exception: \texttt{execution-type}. Timer
actions are always triggered once the time is up, so specifying and
execution type of \texttt{onEntry}, for example, isn't meaningful inside
a timer.

\noindent\hrulefill

Tasks are at the core of the workflow definition. Once you understand
how to create tasks and the other
\href{/docs/7-1/tutorials/-/knowledge_base/t/workflow-definition-nodes}{workflow
nodes} and add transitions between the nodes, you're on the cusp of
workflow wizard-hood.

\section{Workflow Notifications}\label{workflow-notifications}

While an asset is in a workflow, relevant Users should be notified about
certain events, like when a review task is completed. Any workflow node
with an \texttt{\textless{}actions\textgreater{}} element can have
notifications.

\begin{verbatim}
<actions>
    <action>
        <notification>
            <name>Creator Modification Notification</name>
            <template>Your submission was rejected by ${userName}, please modify and resubmit.</template>
            <template-language>freemarker</template-language>
            <notification-type>email</notification-type>
            <notification-type>user-notification</notification-type>
            <execution-type>onAssignment</execution-type>
        </notification>
    </actions>
</actions>
\end{verbatim}

The above Creator Modification Notification sends a notification message
in two ways: via email and via user notification (this goes to the
Notifications widget in the User's Site). The message is defined in a
FreeMarker template and sent once a task assignment is created. But who
receives the notification? If no recipients are explicitly specified via
a \texttt{recipients} tag, the asset's creator receives the
notification.

\subsection{Notification Options}\label{notification-options}

There are several elements that can be specified in a
\texttt{\textless{}notification\textgreater{}}:

\begin{description}
\item[\textbf{Name}]
Set the name of the notification in the
\texttt{\textless{}name\textgreater{}} element. This information is used
to display the notification in the \emph{My Workflow Tasks} widget of a
User's personal Site.
\item[\textbf{Template}]
The \texttt{\textless{}template\textgreater{}} element contains the
message of the notification. The syntax is determined by the template
language you're using.
\item[\textbf{Template Language}]
Choose from \texttt{freemarker}, \texttt{velocity}, or plain
\texttt{text} in the \texttt{\textless{}template-language\textgreater{}}
tag.
\item[\textbf{Notification Type}]
Choose whether to send an \texttt{email}, \texttt{user-notification}
(via the Notification widget), \texttt{im} (instant message), or
\texttt{private-message} in the
\texttt{\textless{}notification-type\textgreater{}} tag.

\begin{verbatim}
<notification-type>email</notification-type>
\end{verbatim}
\item[\textbf{Execution Type}]
Choose to link the sending of the notification to entry into the node
(\texttt{onEntry}), when a task is assigned (\texttt{onAssignment}), or
when the workflow processing is leaving a node (\texttt{onExit}). If you
specify a notification to be sent on assignment, the assignee is
notified automatically.
\item[\textbf{Recipients}]
Decide who should receive the notification in the
\texttt{\textless{}recipients\textgreater{}} tag:

\begin{verbatim}
<recipients>
    [SEE BELOW FOR THE AVAILABLE RECIPIENT TAGS]
</recipients>
\end{verbatim}
\end{description}

Available recipient tags are

\begin{itemize}
\item
  \texttt{\textless{}user\textgreater{}}: notify the User that sent the
  asset through the workflow. Specify the tag as
  \texttt{\textless{}user\ /\textgreater{}}. To notify a specific user,
  enter the \texttt{userId}:

\begin{verbatim}
  <recipients>
      <user />
  </recipients>
  <recipients>
      <user>
          <user-id>20139</user-id>
      </user
  </recipients>
\end{verbatim}
\item
  \texttt{\textless{}roles\textgreater{}}: notify specific Roles, either
  by ID or by their type and name.

\begin{verbatim}
  <recipients>
      <roles>
          <role>
              <role-id>33621</role-id>
          </role>
      </roles>
  </recipients>
  <recipients>
      <roles>
          <role>
              <role-type>regular</role-type>
              <name>Power User</name>
              <auto-create>false</auto-create>
          </role>
      </roles>
  </recipients>
\end{verbatim}
\item
  \texttt{\textless{}assignees\ /\textgreater{}}: notify the task
  assignees.
\item
  \texttt{\textless{}scripted-recipient\textgreater{}}: use a script to
  identify notification recipients.

\begin{verbatim}
  <recipients>
      <scripted-recipient>
          <script>
              <![CDATA[Script logic goes here]]>
          </script>
          <script-language>groovy</script-language>
      </scripted-recipient>
  </recipients>
\end{verbatim}
\end{itemize}

If the notification type is \texttt{email}, you can specify the
\texttt{recipientType} attribute of the
\texttt{\textless{}recipients\textgreater{}} tag as \emph{To},
\emph{CC}, or \emph{BCC}.

\begin{verbatim}
<recipients receptionType="cc">
    <roles>
        <role>
            <role-type>regular</role-type>
            <name>Manager</name>
        </role>
    </roles>
</recipients>
\end{verbatim}

By default, \texttt{recipientType} is \texttt{to}.

As always, read the
\href{https://www.liferay.com/dtd/liferay-workflow-definition_7_1_0.xsd}{schema
for all the details}.

\section{Liferay's Workflow
Framework}\label{liferays-workflow-framework}

Enabling your application's entities to support workflow is so easy, you
could do it in your sleep (but don't try). Workflow-enabled entities
require two things:

\begin{itemize}
\item
  A workflow handler class to interact with Liferay's workflow back-end
  and the entity's service layer.
\item
  Some extra fields in their database table that help keep track of
  their status, along with methods in the service layer that update
  them.
\end{itemize}

You have, therefore, two tasks to enable workflow:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a \texttt{WorkflowHandler} class for your application.
\item
  Update your service layer to integrate it with workflow.
\end{enumerate}

Time to get started.

\subsection{Creating a Workflow
Handler}\label{creating-a-workflow-handler}

The workflow handler should go in the module containing service
implementations. It's nice to keep your back-end code separate from your
view layer and controller (in the MVC pattern).

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a Component class. It should extend
  \texttt{BaseWorkflowHandler\textless{}T\textgreater{}}, an abstract
  class that provides a default implementation of the
  \texttt{WorkflowHandler\textless{}T\textgreater{}} service. Pass the
  interface for your model as the type parameter for the class.

\begin{verbatim}
public class FooEntityWorkflowHandler extends BaseWorkflowHandler<FooEntity>
\end{verbatim}
\item
  Since you're publishing a service to be consumed in the OSGi runtime,
  your workflow handler class must be registered. If you're using
  Declarative Services, make it a Component class, using the
  \texttt{@Component} annotation.

\begin{verbatim}
@Component(
    property = {"model.class.name=com.my.app.package.model.FooEntity"},
    service = WorkflowHandler.class
)
\end{verbatim}

  It needs one property, to set \texttt{model.class.name} to the fully
  qualified class name of the class you passed as the type parameter. It
  must also declare the type of service being implemented
  (\texttt{WorkflowHandler.class}).
\item
  There are three methods to override in the workflow handler, and the
  first two are boilerplate methods:

\begin{verbatim}
@Override
public String getClassName() {
    return FooEntity.class.getName();
}
\end{verbatim}

  \texttt{getClassName} returns the model class's fully qualified class
  name (\texttt{com.my.app.package.model.FooEntity}, for example).

\begin{verbatim}
@Override
public String getType(Locale locale) {
    return ResourceActionsUtil.getModelResource(locale, getClassName());
}
\end{verbatim}

  \texttt{getType} returns the model resource name
  (\texttt{model.resource.com.my.app.package.model.FooEntity}, for
  example).

\begin{verbatim}
@Override
public FooEntity updateStatus(int status, Map<String, Serializable> workflowContext) {
\end{verbatim}

  Most of the heavy lifting is in the \texttt{updateStatus} method. It
  returns a call to a local service method of the same name (for
  example, \texttt{FooEntityLocalService.updateStatus}), so the status
  returned from the workflow back-end can be persisted to the entity
  table in the database.
\item
  The \texttt{updateStatus} method needs a user ID, the primary key for
  the class (for example, \texttt{fooEntityId}), the workflow status,
  the service context, and the workflow context. The status and the
  workflow context can be obtained from the workflow back-end. The other
  parameters can be obtained from the workflow context.

\begin{verbatim}
@Override
public FooEntity updateStatus(
        int status, Map<String, Serializable> workflowContext)
    throws PortalException {

    long userId = GetterUtil.getLong(
        (String)workflowContext.get(WorkflowConstants.CONTEXT_USER_ID));
    long classPK = GetterUtil.getLong(
        (String)workflowContext.get(
            WorkflowConstants.CONTEXT_ENTRY_CLASS_PK));

    ServiceContext serviceContext = (ServiceContext)workflowContext.get(
        "serviceContext");

    return _fooEntityLocalService.updateStatus(
        userId, classPK, status, serviceContext, workflowContext);
}
\end{verbatim}
\end{enumerate}

Now your entity can be handled by Liferay's workflow framework. Next,
update the service methods to account for workflow status and add a new
method to update the status of an entity in the database.

\subsection{Updating the Service
Layer}\label{updating-the-service-layer}

In most Liferay applications,
\href{/docs/7-1/tutorials/-/knowledge_base/t/service-builder}{Service
Builder} is used to create database fields. First, you must update the
service layer:

\begin{itemize}
\item
  The service layer must populate the new fields when entities are added
  to the database.
\item
  The service layer must send the entity through Liferay's workflow, and
  it needs to handle the workflow status of the entity when it's
  returned by the workflow.
\item
  The service layer needs getters that return entities by workflow
  status (usually \emph{approved}).
\end{itemize}

After this is done, the View layer should account for the workflow
status of displayed entities.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Make sure your entity database table has \texttt{status},
  \texttt{statusByUserId}, \texttt{statusByUserName}, and
  \texttt{statusDate} fields. If you're using service builder, add this
  to your \texttt{service.xml} if you haven't already:

\begin{verbatim}
<column name="status" type="int" />
<column name="statusByUserId" type="long" />
<column name="statusByUserName" type="String" />
<column name="statusDate" type="Date" />
\end{verbatim}
\item
  Wherever you're setting the other database fields in your persistence
  code, set the workflow status as a draft and set the other fields.

\begin{verbatim}
fooEntity.setStatus(WorkflowConstants.STATUS_DRAFT);
fooEntity.setStatusByUserId(userId);
fooEntity.setStatusByUserName(user.getFullName());
fooEntity.setStatusDate(serviceContext.getModifiedDate(null));
\end{verbatim}
\end{enumerate}

With Service Builder driven Liferay applications, this is in the local
service implementation class (\texttt{-LocalServiceImpl}).

When an entity is added to the database, the application must detect
whether workflow is enabled. If not, it automatically marks the entity
as approved so it appears in the UI. Otherwise, it's left in draft
status and the workflow back-end handles it. Thankfully, this whole
process is easily done with a single call to
\texttt{WorkflowHandlerRegistryUtil.startWorkflowInstance}.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  At the end of any method that adds a new entity to your database, call
  the workflow service:

\begin{verbatim}
WorkflowHandlerRegistryUtil.startWorkflowInstance(fooEntity.getCompanyId(),
        fooEntity.getGroupId(), fooEntity.getUserId(), FooEntity.class.getName(),
        fooEntity.getPrimaryKey(), fooEntity, serviceContext);
\end{verbatim}
\item
  Once you've set the database fields for workflow status and started
  the workflow instance, implement the \texttt{updateStatus} method that
  must be called in the workflow handler. The workflow handler gets the
  entity's status from the workflow back-end and passes it to your
  service layer, which persists the updated entity to the database.

\begin{verbatim}
fooEntity.setStatus(status);
fooEntity.setStatusByUserId(user.getUserId());
fooEntity.setStatusByUserName(user.getFullName());
fooEntity.setStatusDate(serviceContext.getModifiedDate(now));

fooEntityPersistence.update(fooEntity);
\end{verbatim}
\item
  After setting the workflow fields for the entity, think about the
  specifics of your situation and whether any additional logic should be
  added to this method. For instance, if your entities are Liferay
  Assets already, you must change the visibility of the asset depending
  on its workflow status, so the Asset Publisher doesn't show entities
  that haven't yet been approved in the workflow process.

\begin{verbatim}
if (status == WorkflowConstants.STATUS_APPROVED) {

    assetEntryLocalService.updateEntry(
        FooEntity.class.getName(), fooEntityId, fooEntity.getDisplayDate(),
        null, true, true);
}

else {

    assetEntryLocalService.updateVisible(
        fooEntity.class.getName(), entryId, false);
}
\end{verbatim}

  If approved, Workflow updates the asset with the publication date, a
  \texttt{listable} boolean, and a \texttt{visible} boolean being
  updated to reflect the current state of the asset. If the workflow
  status is anything other than approved, its visibility is set to
  \texttt{false}.
\item
  Before leaving the service layer, add a call to
  \texttt{deleteWorkflowInstanceLinks} in the \texttt{deleteEntity}
  method. Here's what it looks like:

\begin{verbatim}
workflowInstanceLinkLocalService.deleteWorkflowInstanceLinks(
    fooEntity.getCompanyId(), fooEntity.getGroupId(),
    FooEntity.class.getName(), fooEntity.getFooEntityId());
\end{verbatim}

  When you send an entity to the workflow framework via the
  \texttt{startWorkflowInstance} call, it creates an entry in the
  \texttt{workflowinstancelink} database table. This \texttt{delete}
  call ensures there are no orphaned entries in the
  \texttt{workflowinstancelinks} table.
\item
  To get the \texttt{WorkflowInstanceLocalService} injected into your
  \texttt{*LocalServiceBaseImpl} so you can call its methods in the
  \texttt{LocalServiceImpl}, add this to your entity declaration in
  \texttt{service.xml}:

\begin{verbatim}
<reference entity="WorkflowInstanceLink" package-path="com.liferay.portal" />
\end{verbatim}
\end{enumerate}

For an example of a fully implemented \texttt{updateStatus} method, see
the
\texttt{com.liferay.portlet.blogs.service.impl.BlogsEntryLocalServiceImpl}
class in \texttt{portal-impl}.

Save your work and run Service Builder. Once you've accounted for
workflow status in your service layer, there's only one thing left to
do: update the user interface.

\subsection{Workflow Status and the View
Layer}\label{workflow-status-and-the-view-layer}

If you have an application with database entities, you're likely
displaying them. Once you enable workflow, you should only display
approved entities to your end users.

This involves the following steps:

\begin{itemize}
\item
  Create a \emph{finder} for your entities that accounts for the
  \texttt{status} field in your database table.
\item
  Expose the finder in a \emph{getter} method of your service layer.
\item
  Update the view layer to use the new getter for displaying entities
  (e.g., in a Search Container).
\end{itemize}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  If you're using Service Builder, define your finder in your
  application's \texttt{service.xml} and let Service Builder generate it
  for you.

\begin{verbatim}
<finder name="G_S" return-type="Collection">
    <finder-column name="groupId"></finder-column>
    <finder-column name="status"></finder-column>
</finder>
\end{verbatim}
\item
  Make sure you have a getter in your service layer that uses the new
  finder.

\begin{verbatim}
public List<FooEntity> getFooEntities(long groupId, int status)
       throws SystemException {
    return fooEntityPersistence.findByG_S(groupId,
         WorkflowConstants.STATUS_APPROVED);
}
\end{verbatim}
\item
  Finally, update your JSP to use the appropriate getter.

\begin{verbatim}
<liferay-ui:search-container-results
    results="<%=FooEntityLocalServiceUtil.getFooEntities(scopeGroupId,
              fooEntityId(), Workflowconstants.STATUS_APPROVED, searchContainer.getStart(),
              searchContainer.getEnd())%>"
    ...
\end{verbatim}
\end{enumerate}

In an \emph{administrative}-type application (in other words, one that's
displayed in the Site Menu's \emph{Content} section) you might want to
display all the entities with their current workflow status (for
example, include workflow status as a column in the search container).
To do so, use the \texttt{\textless{}aui:worklfow-status\textgreater{}}
tag.

\begin{verbatim}
    <aui:workflow-status markupView="lexicon" showIcon="<%= false %>" showLabel="<%= false %>" status="<%= fooEntity.getStatus() %>" />
\end{verbatim}

Great! You created one new class, updated your \texttt{add} methods,
added one new method in the service layer, and updated your view.
Workflow is fully implemented and ready to use in your Liferay
application.

\chapter{Managing User-Associated Data Stored by Custom
Applications}\label{managing-user-associated-data-stored-by-custom-applications}

7.0 makes it possible for administrators to
\href{/docs/7-1/user/-/knowledge_base/u/managing-user-data}{delete or
anonymize} User Associated Data (UAD), providing a useful tool for
compliance with the EU's General Data Protection Regulation (GDPR). Out
of the box, this tool only supports Liferay applications (blogs, web
content, etc.), but you can also anonymize data stored by your custom
apps.

If your app was created using Service Builder, anonymization is easy.
Follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Include dependencies on \texttt{com.liferay.petra.string} and
  \texttt{com.liferay.portal.kernel} in your service module's build
  script.
\item
  Identify the fields that must be anonymized in the service module's
  \texttt{service.xml} file.
\item
  Run Service Builder. Provide a build script for the \texttt{-uad}
  module that is generated.
\item
  Provide your application's name to the anonymization UI. If you skip
  this step, your app is labeled using the \texttt{Bundle-SymbolicName}
  from the \texttt{-uad} module's \texttt{bnd.bnd} file.
\end{enumerate}

Anonymization of apps not created using Service Builder will be covered
separately.

\section{Include Dependencies}\label{include-dependencies}

To compile the code that Service Builder generates, you need
dependencies on Petra and 3.23.0 or later of Liferay \texttt{kernel} in
your service module's \texttt{build.gradle}:

\begin{verbatim}
dependencies {
    compileOnly group: "com.liferay.portal", name: "com.liferay.portal.kernel", version: "3.23.0"
    compileOnly group: "com.liferay", name: "com.liferay.petra.string", version: "2.0.0"
    ...
}
\end{verbatim}

\section{Choose Fields to Anonymize}\label{choose-fields-to-anonymize}

Next you must identify fields to anonymize by attaching anonymization
attributes to elements in the \texttt{-service} module's
\texttt{service.xml} file. There are two ways to do this.

\begin{itemize}
\item
  The \texttt{uad-anonymize-field-name} attribute indicates a field
  whose value is replaced by that of the anonymous user in the UAD
  deletion process.
\item
  The \texttt{uad-nonanonymizable} attribute indicates data that cannot
  be anonymized automatically and must be reviewed by an administrator.
\end{itemize}

For example, in the blogs application,
\texttt{uad-anonymize-field-name="fullName"} is appended to the
\texttt{userName} column in \texttt{service.xml}:

\begin{verbatim}
<column name="userName" type="String" uad-anonymize-field-name="fullName" />
\end{verbatim}

This indicates that the user name of a blog entry's author should be
replaced by the anonymous user's \texttt{fullName}.

The content of a blog post, in contrast, cannot be anonymized
automatically:

\begin{verbatim}
<column name="content" type="String" uad-nonanonymizable="true" />
\end{verbatim}

The \texttt{uad-nonanonymizable} value of \texttt{true} indicates that
the \texttt{content} field must be reviewed by an administrator to
remove a blog author's UAD.

\section{Run Service Builder!}\label{run-service-builder}

At this point, you're ready to run Service Builder. This generates a new
\texttt{-uad} module based on the values you added to
\texttt{service.xml}. The new module is generated without a build
script, so you must provide one. It should include dependencies on
\texttt{osgi.service.component.annotations}, \texttt{kernel},
\texttt{Petra}, the \texttt{-api} module of the UAD application, as well
as your own application's \texttt{-api} module. The build script should
look like this:

\begin{verbatim}
dependencies {
  compileOnly group: "com.liferay.portal", name: "com.liferay.portal.kernel", version: "3.23.0"
  compileOnly group: "com.liferay", name: "com.liferay.user.associated.data.api", version: "3.0.2"
  compileOnly group: "com.liferay", name: "com.liferay.petra.string", version: "1.0.0"
  compileOnly group: "org.osgi", name: "org.osgi.service.component.annotations", version: "1.3.0"
  compileOnly project(":modules:custom:custom-api")
  ...
  }
\end{verbatim}

At this point you can compile your application. Before you deploy it,
however, you should to make sure the UAD application recognizes it in a
way that makes sense to administrators.

\noindent\hrulefill

\textbf{Note:} Depending on how you created your project---for instance,
if you used Blade's Service Builder template rather than Liferay Dev
Studio's---you may have to include the new \texttt{-uad} module in your
\texttt{settings.gradle} file before you can compile:

\begin{verbatim}
 include "myapp-api", "myapp-service", "myapp-uad"
\end{verbatim}

\noindent\hrulefill

\section{Provide Your App's Name to the
UI}\label{provide-your-apps-name-to-the-ui}

The simplest way to provide your app's name to the anonymization UI is
to include a language key in your \texttt{Language.properties} file:
\texttt{application.name.{[}Bundle-SymbolicName{]}=} where the bracketed
text is the \texttt{Bundle-SymbolicName} from your \texttt{-uad}
module's \texttt{bnd.bnd} file. For example:
\texttt{application.name.com.liferay.docs.custom.portlet=Custom\ App}.

That's the recommended approach for custom apps, but if you look at the
source code for Liferay DXP itself, you see that it isn't used. Why not?
Because it has the downside of creating multiple language keys to label
a single application, which can be confusing. To avoid multiplying
language keys, Liferay applications use the
\texttt{com.liferay.lang.merger.} plugin. Here's what it looks like:

\begin{verbatim}
apply plugin: "com.liferay.lang.merger"

dependencies {

...

}

mergeLang {
    setting("../blogs-web/src/main/resources/content") {
        transformKey "javax.portlet.title.com_liferay_blogs_web_portlet_BlogsPortlet", "application.name.com.liferay.blogs.uad"
    }

    sourceDirs = ["../blogs-web/src/main/resources/content"]
}
\end{verbatim}

This is from the \texttt{-uad} module's \texttt{build.gradle} file in
Liferay DXP's Blogs application. The \texttt{setting} property
identifies the location of the \texttt{Language.properties} file (by
Gradle convention, the \texttt{sourceDirs} property must match
\texttt{setting}). \texttt{transformKey} passes in first the language
key for the application's name, and then the
\texttt{Bundle-SymbolicName} from the \texttt{-uad} module's
\texttt{bnd.bnd} file. The plugin takes the value of the first parameter
and assigns it to the second parameter. The end result is that a key
from \texttt{Language.properties} provides the name of the application
to the anonymization UI---but no additional language keys need to be
created or maintained.

That's it! You can now delete or anonymize User Associated Data stored
by your app.

\chapter{Configurable Applications}\label{configurable-applications}

Many applications must be configurable, whether by end users or
administrators. A viable configuration solution must support use cases
ranging from setting a location for a weather display to more complex
cases like settings for a mail or time sheet application.

The Portlet standard's portlet preferences API can be used for portlet
configuration, but it's intended for storing user preferences. This
limits its usefulness for enabling administrator configuration; plus it
can only be used with portlets. Instead, application developers tend to
create ad hoc configuration methods. But this isn't necessary.

There's a full-featured configuration API that's easy to use, and it's
not limited to portlets. Any class can use the configuration API to set
configuration values in the UI. It's used throughout Liferay DXP's
applications. We like it, and we think you'll like it too.

The following tutorials show you how to use it.

\chapter{Making Applications
Configurable}\label{making-applications-configurable}

A configurable application allows a user with appropriate permissions to
change certain aspects of the application, within bounds set by the
developer. Liferay's configuration framework simplifies the task by
auto-generating a UI if you define the configuration options in a Java
interface. This way, you don't have to create your own application
configuration framework.

Complete these three high level tasks to integrate your application with
the configuration framework:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Provide a way to set configurations in the user interface.
\item
  Set the scope at which the application can be configured.
\item
  Read configuration values in your business logic.
\end{enumerate}

This tutorial demonstrates both adding your application's configuration
form to the System Settings application in the Control Panel and
categorizing the configuration. Subsequent tutorials show you how to

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Set the \emph{scope} of the configuration. Read more about
  configuration scope
  \href{/docs/7-1/user/-/knowledge_base/u/system-settings\#configuration-scope}{here}.
\item
  Read configuration values from various contexts.
\end{enumerate}

\noindent\hrulefill

\textbf{Note:} To see a working application configuration, deploy the
\texttt{configuration-action}
\href{https://github.com/liferay/liferay-blade-samples/tree/7.1/gradle/apps/configuration-action}{Blade
sample} and navigate to System Settings (\emph{Control Panel} →
\emph{Configuration} → \emph{System Settings}). Go to \emph{Platform} →
\emph{Third Party}. In the System Scope, open the \emph{Message display
configuration} entry and edit the fields as you wish.

Add the \emph{Blade Message Portlet} to a page to test your
configuration choices.

\noindent\hrulefill

You don't need much prior knowledge to use the configuration API, but
understanding a few key concepts is useful before diving into the code.

\begin{description}
\tightlist
\item[\textbf{Typed Configuration}]
The method described here uses \emph{typed} configuration. The
application configuration isn't just a list of key-value pairs. Values
can have types, like \texttt{Integer}, a list of \texttt{Strings}, a
URL, etc. You can even use your own types, although that's beyond the
scope of this tutorial. Typed configurations are easier to use than
untyped configurations, and they prevent many programmatic errors.
Configuration options should be programmatically explicit, so developers
can use autocomplete in modern IDEs to find out all configuration
options of a given application or one of its components.
\item[\textbf{Modularity}]
Modern applications are \emph{modular} and built as a collection of
lightweight
\href{/docs/7-1/tutorials/-/knowledge_base/t/fundamentals\#components}{components}.
\item[\textbf{Configuration Scope}]
If your application must support different configurations at different
scopes, the APIs described below handle most of the burden for you. You
should still understand the term \emph{configuration scope} even if you
don't plan to scope the application's configuration. Here are the most
common configuration scopes:
\end{description}

\begin{itemize}
\item
  \emph{System} configurations are unique for the complete installation
  of the application.
\item
  \emph{Virtual Instance} configurations can vary per virtual instance.
\item
  \emph{Site} configuration can vary per site.
\item
  \emph{Portlet Instance} configurations apply to a single application
  placed on a page (i.e., portlets). Each placement (instance) of the
  application on the page can have a different configuration.
\end{itemize}

Enough with the conceptual stuff. You're ready to get started with some
code. If you already had a portlet or service that was configurable
using the traditional mechanisms of Liferay Portal 6.2 and before, refer
to the
\href{/docs/7-0/tutorials/-/knowledge_base/t/transitioning-from-portlet-preferences-to-the-configuration-api}{Transitioning
from Portlet Preferences to the Configuration API} tutorial.

\section{Creating A Configuration
Interface}\label{creating-a-configuration-interface}

First, you'll learn how to create a configuration at the system scope.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a Java interface to represent the configuration and its default
  values. Using a Java interface allows for an advanced type system for
  each configuration option. Here is the configuration interface for the
  Liferay Forms application:

\begin{verbatim}
@Meta.OCD(
    id = "com.liferay.dynamic.data.mapping.form.web.configuration.DDMFormWebConfiguration",
    localization = "content/Language", name = "ddm-form-web-configuration-name"
)
public interface DDMFormWebConfiguration {

    @Meta.AD(
        deflt = "1", description = "autosave-interval-description",
        name = "autosave-interval-name", required = false
    )
    public int autosaveInterval();

    @Meta.AD(
        deflt = "descriptive", name = "default-display-view",
        optionLabels = {"Descriptive", "List"},
        optionValues = {"descriptive", "list"}, required = false
    )
    public String defaultDisplayView();

}
\end{verbatim}

  It defines two configuration options, the autosave interval (with a
  default of one minute) and the default display view, which can be
  descriptive or list, but defaults to descriptive. Here's what the two
  Java annotations in the above snippet do:

  \begin{enumerate}
  \def\labelenumii{\arabic{enumii}.}
  \item
    \textbf{Meta.OCD:} Registers this class as a configuration with a
    specific id. \textbf{The ID must be the fully qualified
    configuration class name.}
  \item
    \textbf{Meta.AD:} Specifies
    \href{http://bnd.bndtools.org/chapters/210-metatype.html}{optional
    metadata} about the field, such as whether it's a required field or
    if it has a default value. Note that if you set a field as required
    and don't specify a default value, the system administrator must
    specify a value in order for your application to work properly. Use
    the \texttt{deflt} property to specify a default value.
  \end{enumerate}

  The fully-qualified name of the \texttt{Meta} class above is
  \texttt{aQute.bnd.annotation.metatype.Meta}. For more information
  about this class and the \texttt{Meta.OCD} and \texttt{Meta.AD}
  annotations, please refer to the
  \href{http://bnd.bndtools.org/chapters/210-metatype.html}{bndtools
  documentation}.

  The cool thing about configuration interfaces is that once you have
  one, you also have an auto-generated UI!
\item
  To use the \texttt{Meta.OCD} and \texttt{Meta.AD} annotations in your
  modules, you must
  \href{/docs/7-0/tutorials/-/knowledge_base/t/configuring-dependencies}{specify
  a dependency} on the bnd library. We recommend using bnd version 3.
  Here's an example of how to include this dependency in a Gradle
  project:

\begin{verbatim}
dependencies {
    compile group: "biz.aQute.bnd", name: "biz.aQute.bndlib", version: "3.1.0"
}
\end{verbatim}
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** The annotations `@Meta.OCD` and `@Meta.AD` are part of the bnd
 library, but as of OSGi standard version R6, they're included in the OSGi core
 under the names `@ObjectClassDefinition` and `@AttributeDefinition`. The OSGi
 annotations can be used for simple cases like the one described in this
 tutorial. However, a key difference between the two libraries is that the bnd
 annotations are available at runtime, while the OSGi annotations are not.
 Because runtime availability is necessary for some of the Liferay-specific features
 described below, we recommend defaulting to the bnd annotations.
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\item
  Add the following line to your project's \texttt{bnd.bnd} file:

\begin{verbatim}
-metatype: *
\end{verbatim}

  This line lets bnd use your configuration interface to generate an XML
  configuration file. This provides a lot of information about your
  application's configuration options. Enough, in fact, to generate a
  \href{/docs/7-1/user/-/knowledge_base/u/system-settings}{System
  Settings} user interface automatically.
\end{enumerate}

Just by registering a configuration interface, you get a fully capable
UI form auto-generated in the System Settings application. By default,
configurations are placed in Platform → Third Party. Make it easier to
find for your application's users by categorizing the configuration
somewhere logical. The next tutorial show you how to do that.

\section{Categorizing the
Configuration}\label{categorizing-the-configuration}

Because it's easy to make any application or service configurable, there
are already lots of configuration options in Liferay DXP by default. If
you've deployed custom applications and services, there are even more.
To make it easier for portal administrators to find the right
configuration options, specify a category for the configuration in the
auto-generated System Settings UI.

By default, the following System Settings sections are defined. All
available categories are nested beneath these sections:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Content Management
\item
  Social
\item
  Platform
\item
  Security
\item
  Commerce
\item
  Other
\end{enumerate}

\noindent\hrulefill

\textbf{Note:} Sections appear if they contain at least one
configuration category. Categories appear if they contain at least one
configuration. The visible sections and categories depend on the
deployed modules.

\noindent\hrulefill

If you don't specify a category, your application's configuration
resides in Platform → Third Party. Usually, you'll want to place your
configurations in an existing category or create your own.

.

\subsection{Specifying a Configuration
Category}\label{specifying-a-configuration-category}

If you looked in the source code at the Liferay Forms configuration
interface (it's in the Forms \& Workflow suite's Liferay Dynamic Data
Mapping Form Web module), you'll notice something was left out of the
code snippet above. The \texttt{@Meta.OCD} annotation is directly
preceded by

\begin{verbatim}
    @ExtendedObjectClassDefinition(
        category = "dynamic-data-mapping",
        scope = ExtendedObjectClassDefinition.Scope.GROUP
    )
\end{verbatim}

This annotation does two things:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Specifies the \texttt{dynamic-data-mapping} category.
\item
  Sets the
  \href{/docs/7-1/user/-/knowledge_base/u/system-settings\#configuration-scope}{scope}
  of the configuration.
\end{enumerate}

The fully qualified class name of the
\texttt{@ExtendedObjectClassDefinition} class is
\texttt{com.liferay.portal.configuration.metatype.annotations.ExtendedObjectClassDefinition}.

Note: The infrastructure used by System Settings assumes the
\texttt{configurationPid} is the same as the fully qualified class name
of the interface. If they don't match, it can't provide any information
through \texttt{ExtendedObjectClassConfiguration}.

The \texttt{@ExtendedObjectClassDefinition} annotation is distributed
through the \texttt{com.liferay.portal.configuration.metatype} module,
which you can
\href{/docs/7-1/tutorials/-/knowledge_base/t/configuring-dependencies}{configure
as a dependency}.

\subsection{Creating New Sections and
Categories}\label{creating-new-sections-and-categories}

Configurations should be in the most intuitive location (section and
category) so administrators find them. If your configurations don't fit
into the existing categories or category sections, create your own by
implementing the \texttt{ConfigurationCategory} interface.

Here's code that creates the \emph{Content Management} section and the
\emph{Dynamic Data Mapping} category:

\begin{verbatim}
    @Component
    public class DynamicDataMappingConfigurationCategory
        implements ConfigurationCategory {

        @Override
        public String getCategoryIcon() {
            return "dynamic-data-list";
        }

        @Override
        public String getCategoryKey() {
            return _KEY;
        }

        @Override
        public String getCategorySection() {
            return _CATEGORY_SET_KEY;
        }

        private static final String _CATEGORY_SET_KEY = "content-management";

        private static final String _KEY = "dynamic-data-mapping";

    }
\end{verbatim}

The \texttt{getCategorySection} method returns the String with the new
section's key. Similarly, \texttt{getCategoryKey} returns the key for
the new category. Provide localized values for these keys in your
module's \texttt{src/main/resources/content/Language.properties} file.

Next you'll specify the scope of your application's configuration.

\section{Scoping Configurations}\label{scoping-configurations}

Applications can have different configurations depending on the scope:
per virtual instance (a.k.a. \texttt{Company}), site (a.k.a.
\texttt{Group}), or portlet instance. The Configuration Provider API
(based on the standard OSGi Configuration Admin API shown in the
previous section) handles this for you.

Scoping the configuration is specifying the scope where the
configuration values are set or overridden. Anything set at a less
granular scope is just a default for the configuration. It can always be
overridden at the configuration's current scope. For example, a site
scoped configuration can have its defaults set at the system scope (via
System Settings). However, once the configuration is changed at the site
scope, it ignores the higher level scope forever. It can also be
configured in other places at the same scope. From the database level,
this means there could be multiple configuration values for the
application, all scoped to the site level, because the values set in one
site don't matter if the context in which you need the value is a
different site. This is covered in more detail
\href{/docs/7-1/user/-/knowledge_base/u/system-settings\#configuration-scope}{here}.

Here's how to scope a configuration:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Set the scope in the configuration interface.
\item
  Enable the configuration for scoped retrieval by creating a
  configuration bean declaration.
\item
  Retrieve scoped configurations with a configuration provider.
\end{enumerate}

The third step is covered in the
\href{/docs/7-1/tutorials/-/knowledge_base/t/reading-configuration-values-from-a-configuration-provider}{configuration
provider} tutorial. This article covers the first two steps. Start by
setting the scope in the configuration interface.

\subsection{Step 1: Setting the Configuration
Scope}\label{step-1-setting-the-configuration-scope}

Use the \texttt{@ExtendedObjectClassDefinition} annotation to specify
the configuration's scope. The scope you choose must match how the
configuration object is retrieved through the
\href{/docs/7-1/tutorials/-/knowledge_base/t/reading-configuration-values-from-a-configuration-provider}{configuration
provider} configuration provider. Pass one of these valid scope options
to \texttt{@ExtendedObjectClassDefinition}:

\texttt{Scope.GROUP}: for site scope \texttt{Scope.COMPANY}: for virtual
instance scope \texttt{Scope.SYSTEM}: for system scope
\texttt{Scope.PORTLET\_INSTANCE}: for the portlet instance scope

Here is an example:

\begin{verbatim}
@ExtendedObjectClassDefinition(
    category = "dynamic-data-mapping",
    scope = ExtendedObjectClassDefinition.Scope.GROUP
)
@Meta.OCD(
    id = "com.liferay.dynamic.data.mapping.form.web.configuration.
        DDMFormWebConfiguration",
    localization = "content/Language", 
    name = "ddm-form-web-configuration-name"
)

public interface DDMFormWebConfiguration {
\end{verbatim}

The scope property makes it appear in System Settings so an
administrator can change its value. In future releases it may serve
additional purposes.

\subsection{Step 2: Enabling the Configuration for Scoped
Retrieval}\label{step-2-enabling-the-configuration-for-scoped-retrieval}

If you set the configuration scope, you must retrieve the configuration
values from the same scope. To retrieve a scoped configuration, use a
\href{/docs/7-1/tutorials/-/knowledge_base/t/reading-configuration-values-from-a-configuration-provider}{Configuration
Provider}:

\begin{verbatim}
JournalGroupServiceConfiguration configuration =
    configurationProvider.getGroupConfiguration(
        JournalGroupServiceConfiguration.class, groupId);
\end{verbatim}

This is an example from the Journal module that gets a site-scoped
configuration from the configuration provider. To enable scoped
retrieval of a configuration, the application's configuration must be
registered with a \texttt{ConfigurationBeanDeclaration}.

\noindent\hrulefill

\textbf{Note:} \texttt{ConfigurationProvider} is part of Liferay's
kernel API so you don't need a new dependency to use it. However, its
implementation is distributed as a module called
\texttt{portal-configuration-module-configuration}, so make sure it is
installed.

\noindent\hrulefill

To create a configuration bean declaration:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Register the configuration class by implementing
  \texttt{ConfigurationBeanDeclaration}.

\begin{verbatim}
@Component
public class JournalGroupServiceConfigurationBeanDeclaration
    implements ConfigurationBeanDeclaration {
\end{verbatim}
\item
  This class has one method that returns the class of the interface you
  created in the previous section. It enables the system to keep track
  of configuration changes as they happen, making requests for the
  configuration very fast.

\begin{verbatim}
@Override
public Class<?> getConfigurationBeanClass() {
    return JournalGroupServiceConfiguration.class;
}
\end{verbatim}
\end{enumerate}

\subsection{Step 3: Retrieving Scoped
Configurations}\label{step-3-retrieving-scoped-configurations}

If you set the configuration scope, then you must retrieve the
configuration values from the same scope. To retrieve a scoped
configuration, use a
\href{/docs/7-1/tutorials/-/knowledge_base/t/reading-configuration-values-from-a-configuration-provider}{Configuration
Provider}:

\begin{verbatim}
JournalGroupServiceConfiguration configuration =
    configurationProvider.getGroupConfiguration(
        JournalGroupServiceConfiguration.class, groupId);
\end{verbatim}

This is an example from the Journal module that gets a site-scoped
configuration from the configuration provider. The \texttt{groupId}
variable is important since it identifies which site the configuration
value should be read from.

That's all there is to it. Now the configuration is scoped and supports
scoped retrieval.

\section{Reading Configuration Values from a
Component}\label{reading-configuration-values-from-a-component}

Once you have the
\href{/docs/7-1/tutorials/-/knowledge_base/t/making-applications-configurable}{application
configured} so that administrators can configure it in System Settings,
you might be wondering how to read the configuration from your
application's Java code.

The answer is that there are several ways. Which one you use depends on
the context from which the configuration must be read:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  From any Component class
\item
  From an MVC portlet's JSP
\item
  From an MVC portlet's Portlet class
\item
  From a non-Component class
\end{enumerate}

This tutorial shows the first usage, reading the configuration from a
Component class.

\subsection{Reading Configurations from a Component
Class}\label{reading-configurations-from-a-component-class}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  First set the \texttt{configurationPid} Component property as the
  fully qualified class name of the configuration class:

\begin{verbatim}
@Component(configurationPid = "com.liferay.dynamic.data.mapping.form.web.configuration.DDMFormWebConfiguration")
\end{verbatim}
\item
  Then provide an \texttt{activate} method, annotated with
  \texttt{@Activate} to ensure the method is invoked as soon as the
  Component is started, and \texttt{@Modified} so it's invoked whenever
  the configuration is modified.

\begin{verbatim}
@Activate
@Modified
protected void activate(Map<String, Object> properties) {
    _formWebConfiguration = ConfigurableUtil.createConfigurable(
        DDMFormWebConfiguration.class, properties);
}

private volatile DDMFormWebConfiguration _formWebConfiguration;
\end{verbatim}

  The \texttt{activate()} method calls the method
  \texttt{ConfigurableUtil.createConfigurable()} to convert a map of the
  configuration's properties to a typed class, which is easier to
  handle. The configuration is stored in a \texttt{volatile} field.
  Don't forget to make it \texttt{volatile} to prevent thread safety
  problems.
\item
  Once the activate method is set up, retrieve particular properties
  from the configuration wherever they're needed:

\begin{verbatim}
public void orderCar(String model) {
    order("car", model, _configuration.favoriteColor);
}
\end{verbatim}

  This is dummy code: don't try to find it in the Liferay source code.
  The String configuration value of \texttt{favoriteColor} is passed to
  the \texttt{order} method call, presumably so that whatever model car
  is ordered will be ordered in the configured favorite color.
\end{enumerate}

\noindent\hrulefill

\textbf{Note:} The bnd library also provides a class called
\texttt{aQute.bnd.annotation.metatype.Configurable} with a
\texttt{createConfigurable()} method. You can use that instead of
Liferay's
\texttt{com.liferay.portal.configuration.metatype.bnd.util.ConfigurableUtil}
without any problems. Liferay's developers created the
\texttt{ConfigurableUtil} class to improve the performance of bnd's
implementation, and it's used in internal code. Feel free to use
whichever method you prefer.

\noindent\hrulefill

With very few lines of code, you have a configurable application that
dynamically changes its configuration, has an auto-generated UI, and
uses a simple API to access the configuration.

\section{Reading Configuration Values from a MVC
Portlet}\label{reading-configuration-values-from-a-mvc-portlet}

It's very common to read configuration values from a portlet class or
its JSPs. This tutorial shows how to add a configuration to the request
and read it from the view layer, and how to read it directly in the
portlet class. This tutorial uses dummy code from a portlet we'll call
the Example Configuration Portlet. The import statements are included in
the code snippets so that you can see the fully qualified class names
(FQCNs) of all the classes that are used.

\subsection{Accessing the Configuration Object in the Portlet
Class}\label{accessing-the-configuration-object-in-the-portlet-class}

Whether you need the configuration values in the portlet class or the
JSPs, the first step is to get access to the configuration object in the
\texttt{*Portlet} class.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Imports first:

\begin{verbatim}
package com.liferay.docs.exampleconfig;

import java.io.IOException;
import java.util.Map;

import javax.portlet.Portlet;
import javax.portlet.PortletException;
import javax.portlet.RenderRequest;
import javax.portlet.RenderResponse;

import org.osgi.service.component.annotations.Activate;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Modified;

import com.liferay.portal.kernel.portlet.bridges.mvc.MVCPortlet;

import com.liferay.portal.configuration.metatype.bnd.util.ConfigurableUtil;
\end{verbatim}
\item
  Portlet classes are Component classes. To mate the configuration with
  the Component, provide the \texttt{configurationPid} property with the
  FQCN of the configuration class.

\begin{verbatim}
@Component(
    configurationPid = "com.liferay.docs.exampleconfig.ExampleConfiguration",
    immediate = true,
    property = {
        "com.liferay.portlet.display-category=category.sample",
        "com.liferay.portlet.instanceable=true",
        "javax.portlet.security-role-ref=power-user,user",
        "javax.portlet.init-param.template-path=/",
        "javax.portlet.init-param.view-template=/view.jsp",
        "javax.portlet.resource-bundle=content.Language"
    },
    service = Portlet.class
)
public class ExampleConfigPortlet extends MVCPortlet {
\end{verbatim}

  Note that you can specify more than one configuration PID here, by
  enclosing the values in curly braces (\texttt{\{\}}) and placing
  commas between each PID.
\item
  Write an \texttt{activate} method annotated with \texttt{@Activate}
  and \texttt{@Modified}. See the
  \href{/docs/7-1/tutorials/-/knowledge_base/t/making-applications-configurable}{Making
  Applications Configurable} tutorial if you're unsure why these
  annotations are necessary:

\begin{verbatim}
@Activate
@Modified
protected void activate(Map<String, Object> properties) {
    _configuration = ConfigurableUtil.createConfigurable(
    ExampleConfiguration.class, properties);
}

private volatile ExampleConfiguration _configuration;
\end{verbatim}

  A volatile field \texttt{\_configuration} is created by the
  \texttt{createConfigurable} method. Now the field can be used to
  retrieve configuration values or to set the values in the request, so
  they can be retrieved in the application's JSPs.
\end{enumerate}

\subsection{Accessing the Configuration from a
JSP}\label{accessing-the-configuration-from-a-jsp}

In the case of reading from a JSP, add the configuration object to the
request object so its values can be read from the JSPs that comprise the
application's view layer.

\noindent\hrulefill

\textbf{Note:} There's a shortcut method for obtaining a portlet
instance configuration. The method described in this section takes a
straightforward approach that does not use this shortcut. See the
\href{/docs/7-1/tutorials/-/knowledge_base/t/reading-configuration-values-from-a-configuration-provider\#accessing-the-portlet-instance-configuration-through-the-portletdisplay}{Accessing
the Portlet Instance Configuration Through the \texttt{PortletDisplay}}
article to learn about the shorter method.

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add the configuration object to the request. Here's what it looks like
  in a simple portlet's \texttt{doView} method:

\begin{verbatim}
 @Override
 public void doView(RenderRequest renderRequest,
     RenderResponse renderResponse) throws IOException, PortletException {

     renderRequest.setAttribute(
         ExampleConfiguration.class.getName(), _configuration);

     super.doView(renderRequest, renderResponse);
 }
\end{verbatim}

  The main difference between this example and the component class
  covered in the
  \href{reading-configuration-values-from-a-component}{previous
  tutorial} is that this class is a portlet class and it sets the
  configuration object as a request attribute in its \texttt{doView()}
  method.
\item
  Read configuration values from a JSP. First add these imports to the
  top of your \texttt{view.jsp} file:

\begin{verbatim}
 <%@ page import="com.liferay.docs.exampleconfig.ExampleConfiguration" %>
 <%@ page import="com.liferay.portal.kernel.util.GetterUtil" %>
\end{verbatim}
\item
  In the JSP, obtain the configuration object from the request object
  and read the desired configuration value from it. Here's a
  \texttt{view.jsp} file that does this:

\begin{verbatim}
 <%@ include file="/init.jsp" %>

 <p>
     <b>Hello from the Example Configuration portlet!</b>
 </p>

 <%
 ExampleConfiguration configuration = (ExampleConfiguration) GetterUtil.getObject(
     renderRequest.getAttribute(ExampleConfiguration.class.getName()));

 String favoriteColor = configuration.favoriteColor();
 %>

 <p>Favorite color: <span style="color: <%= favoriteColor %>;"><%= favoriteColor %></span></p
\end{verbatim}
\end{enumerate}

The example code here would make the application display a message like
this:

\begin{verbatim}
Favorite color: blue
\end{verbatim}

The word \emph{blue} is written in blue text. Note that \emph{blue} is
displayed by default since you specified it as the default in your
\texttt{ExampleConfiguration} interface. If you go to \emph{Control
Panel} → \emph{Configuration} → \emph{System Settings} → \emph{Platform}
→ \emph{Third Party} and click on the \emph{Example configuration} link,
you can find the \texttt{Favorite\ color} setting and change its value.
The JSP reads the configuration, and refreshing the UI reflects this
update.

\subsection{Accessing the Configuration from the Portlet
Class}\label{accessing-the-configuration-from-the-portlet-class}

Now that you've seen a detailed example of accessing the configuration
values in a JSP, there's not much more to cover when accessing the
configuration directly in the \texttt{-Portlet} class. Wherever you
require the value of a configuration property, call
\texttt{\_configuration.propertyName} and you have access to the
currently configured value. For example, this code compares the
\texttt{favoriteColor} configuration value with a
\texttt{userFavoriteColor} that's fetched from the request object:

\begin{verbatim}
public boolean isFavoriteColorMatched {

    String userFavoriteColor = ParamUtil.getString(request, "userFavoriteColor");

    if (_configuration.favoriteColor == userFavoriteColor) {

        SessionMessages.add(request, "congratulateUser");

        return true;
    }

    return false;
}
\end{verbatim}

It returns true and adds a success message if the two Strings match each
other, but you can do anything that makes sense for your application's
controller logic.

That's all there is to reading configuration values in an MVC Portlet.
The next tutorial covers categorizing the configuration and accessing it
through a Configuration Provider.

\section{Reading Configuration Values from a Configuration
Provider}\label{reading-configuration-values-from-a-configuration-provider}

When an application is deployed, it's common to need different
configurations
\href{/docs/7-1/tutorials/-/knowledge_base/t/scoping-configurations}{depending
on the scope}. That means having different configurations for a given
application per virtual instance (a.k.a. Company), site (a.k.a. Group),
or portlet instance. Achieve this with little effort using the
Configuration Provider API that is based on the standard OSGi
Configuration Admin API.

\subsection{Using the Configuration
Provider}\label{using-the-configuration-provider}

When using the Configuration Provider, instead of receiving the
configuration directly, the class that wants to access it must

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Receive a \texttt{ConfigurationProvider} to obtain the configuration
\item
  Be registered with a \texttt{ConfigurationBeanDeclaration}.
\end{enumerate}

The tutorial on
\href{/docs/7-1/tutorials/-/knowledge_base/t/scoping-configurations}{scoping
configurations} demonstrates how to register the configuration with a
\texttt{ConfigurationBeanDeclaration}.

After registering with a \texttt{ConfigurationBeanDeclaration}, you're
ready to use a \texttt{ConfigurationProvider} to retrieve the scoped
configuration. Here's how you obtain a reference to it:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Here's the approach for components:

\begin{verbatim}
@Reference
protected void setConfigurationProvider(ConfigurationProvider configurationProvider) {
    _configurationProvider = configurationProvider;
}
\end{verbatim}
\item
  Here's the approach for Service Builder services:

\begin{verbatim}
@ServiceReference(type = ConfigurationProvider.class)
protected ConfigurationProvider configurationProvider;
\end{verbatim}
\item
  For Spring beans, it is possible to use the same mechanism as for
  Service Builder services (\texttt{@ServiceReference}). Check the
  documentation on
  \href{/docs/7-1/tutorials/-/knowledge_base/t/invoking-services-from-service-builder-code\#referencing-osgi-services}{how
  to integrate Spring beans with OSGi services} for more details.
\item
  For anything else, call the same methods from the utility class,
  \texttt{ConfigurationProviderUtil}. Be sure you call the utility
  methods in contexts where the portal is guaranteed to be initialized
  prior to the method call. This class is useful in the
  \href{/docs/7-0/user/-/knowledge_base/u/running-scripts-from-the-script-console}{scripting
  console}, for example. Here's an example method that uses the utility
  class. It comes from the export-import service, which is only called
  during the import and export of content from a running portal:

  protected boolean isValidateLayoutReferences() throws PortalException
  \{ long companyId = CompanyThreadLocal.getCompanyId();

\begin{verbatim}
ExportImportServiceConfiguration exportImportServiceConfiguration =
    ConfigurationProviderUtil.getCompanyConfiguration(
        ExportImportServiceConfiguration.class, companyId);

return exportImportServiceConfiguration.validateLayoutReferences();
\end{verbatim}

  \}
\end{enumerate}

To retrieve the configuration, use one of the following methods of the
provider:

\begin{description}
\tightlist
\item[\texttt{getCompanyConfiguration()}]
Used when you want to support different configurations per virtual
instance. In this case, the configuration is usually entered by an admin
through Control Panel → Configuration → Instance Settings. Since this UI
is not automatically generated (yet) you must extend the UI with your
own form.
\item[\texttt{getGroupConfiguration()}]
Used when you want to support different configurations per site (or, if
desired, per page scope). Usually this configuration is specified by an
admin through the Configuration menu option in an app accessing through
the site administration menu. That UI is developed as a portlet
configuration view.
\item[\texttt{getPortletInstanceConfiguration()}]
Used to obtain the configuration for a specific portlet instance. Most
often you should not be using this directly and use the convenience
method in \texttt{PortletDisplay} instead as shown below.
\item[\texttt{getSystemConfiguration}]
Used to obtain the configuration for the system scope. These settings
are specified by an admin via the System Settings application or with an
OSGi configuration file.
\end{description}

Here are a couple real world examples from Liferay's source code:

\begin{verbatim}
JournalGroupServiceConfiguration configuration =
    configurationProvider.getGroupConfiguration(
        JournalGroupServiceConfiguration.class, groupId);

MentionsGroupServiceConfiguration configuration =
  _configurationProvider.getCompanyConfiguration(
     MentionsGroupServiceConfiguration.class, entry.getCompanyId());
\end{verbatim}

Next, you'll learn a nifty way to to access a portlet instance
configuration from a JSP.

\subsection{Accessing the Portlet Instance Configuration Through the
PortletDisplay}\label{accessing-the-portlet-instance-configuration-through-the-portletdisplay}

Often you must access portlet instance settings from a JSP or from a
Java class that isn't an OSGi component. To read the settings in these
cases, a method was added to \texttt{PortletDisplay}, which is available
as a request object. Here is an example of how to use it:

\begin{verbatim}
RSSPortletInstanceConfiguration rssPortletInstanceConfiguration =
    portletDisplay.getPortletInstanceConfiguration(
        RSSPortletInstanceConfiguration.class);
\end{verbatim}

As you can see, it knows how to find the values and returns a typed bean
containing them just by passing the configuration class.

\section{Customizing the System Settings User
Interface}\label{customizing-the-system-settings-user-interface}

Liferay DXP applications use the Apache Felix Configuration Admin
Service to provide application configuration. By specifying a single
Configuration Interface class, the configuration data is typed and
scoped, and the application gains an auto-generated configuration user
interface, available in Control Panel → Configuration → System Settings
once the configuration is registered. If this is new information for
you, consider first reading the set of tutorials on
\href{/docs/7-1/tutorials/-/knowledge_base/t/making-applications-configurable}{Making
Applications Configurable}.

This tutorial describes how to customize the System Settings entry's
user interface in the following ways:

\begin{itemize}
\item
  Provide a custom form for a configuration object.
\item
  Write a completely custom configuration UI. This is useful especially
  if you aren't using the Configuration Admin service or any of
  Liferay's Configuration APIs.
\item
  Exclude a configuration object from System Settings. If you're
  providing a completely custom configuration UI but are still using
  Configuration Admin, you'll want to hide the auto-generated UI. If
  your configuration is not meant to be accessible to administrative
  Users (perhaps because it's too low level), you might want to exclude
  it from the System Settings UI.
\end{itemize}

\subsection{Providing Custom Configuration
Forms}\label{providing-custom-configuration-forms}

This method relies on an existing Config Admin configuration class, as
described
\href{/docs/7-1/tutorials/-/knowledge_base/t/making-applications-configurable}{here}.
Here's an example configuration class, from Liferay's own Currency
Converter application:

\begin{verbatim}
@ExtendedObjectClassDefinition(category = "localization")
@Meta.OCD(
    id = "com.liferay.currency.converter.web.configuration.CurrencyConverterConfiguration",
    localization = "content/Language",
    name = "currency-converter-configuration-name"
)
public interface CurrencyConverterConfiguration {

    @Meta.AD(deflt = "GBP|CNY|EUR|JPY|USD", name = "symbols", required = false)
    public String[] symbols();
}
\end{verbatim}

There's one configuration option, symbols, that takes an array of
values.

All that's necessary to customize an auto-generated form is one
additional class, an implementation of the
\texttt{ConfigurationFormRenderer} interface.

Implement its three methods:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \texttt{getPid}: Return the configuration object's ID. This is defined
  in the \texttt{id} property in the \texttt{*Configuration} class's
  \texttt{@Meta.OCD} annotation.
\item
  \texttt{getRequestParameters}: Read the parameters sent by the custom
  form and put them in a Map whose keys should be the names of the
  fields of the Configuration interface.
\item
  \texttt{render}: Render the custom form's fields, using your desired
  method (for example, JSPs or another template mechanism). The
  \texttt{\textless{}form\textgreater{}} tag itself is provided
  automatically and shouldn't be included in the
  \texttt{ConfigurationFormRenderer}.
\end{enumerate}

Here's a complete \texttt{ConfigurationFormRenderer} implementation:

\begin{verbatim}
@Component(immediate = true, service = ConfigurationFormRenderer.class)
public class CurrencyConverterConfigurationFormRenderer
    implements ConfigurationFormRenderer {

    @Override
    public String getPid() {
        return "com.liferay.currency.converter.web.configuration.CurrencyConverterConfiguration";
    }

    @Override
    public void render(HttpServletRequest request, HttpServletResponse response)
            throws IOException {
            
        String formHtml = "<input name=\"mysymbols\" />";

        PrintWriter writer = response.getWriter();

        writer.print(formHtml);

    }

    @Override
    public Map<String, Object> getRequestParameters(
            HttpServletRequest request) {

        Map<String, Object> params = new HashMap<>();

        String[] mysymbols = ParamUtil.getParameterValues(request, "mysymbols");

        params.put("symbols", mysymbols);

        return params;
    }
}
\end{verbatim}

The above example generates a custom rendering (HTML) for the form in
the \texttt{render()} method and reads the information entered in the
custom form in the \texttt{getRequestParameters()} method.

To see a complete demonstration, including JSP markup, read the
dedicated tutorial on creating a
\href{/docs/7-1/tutorials/-/knowledge_base/t/configuration-form-renderer}{configuration
form renderer}.

\subsection{Creating a Completely Custom Configuration
UI}\label{creating-a-completely-custom-configuration-ui}

In some cases, you want a completely custom UI for your configuration.
For example:

\begin{itemize}
\item
  Your application doesn't use Config Admin to provide its
  configuration. You have a completely different configuration backend,
  and you'll write a completely independent frontend.
\item
  Your application needs more flexibility in its UI, such as multiple
  configuration screens.
\end{itemize}

To accomplish this, write a \texttt{ConfigurationScreen} implementation.

At a high level you must

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Write a Component that declares itself an implementation of the
  \texttt{ConfigurationScreen} interface.
\item
  Implement \texttt{Configurationscreen}'s methods.
\item
  Create the UI by hand.
\end{enumerate}

Here's an example implementation:

\begin{verbatim}
@Component(immediate = true, service = ConfigurationScreen.class) 
public class SampleConfigurationScreen implements ConfigurationScreen {
\end{verbatim}

First declare the class an implementation of
\texttt{ConfigurationScreen}.

\begin{verbatim}
@Override 
public String getCategoryKey() { 

    return "third-party"; 

}

@Override 
public String getKey() { 

    return "sample-configuration-screen"; 

}

@Override 
public String getName(Locale locale) { 

    return "Sample Configuration Screen"; 

}
\end{verbatim}

Second, set the category key, the configuration entry's key, and its
localized name. This example puts the configuration entry, keyed
\texttt{sample-cofniguration-screen}, into the \texttt{third-party}
System Settings section. The String that appears in System Settings is
\emph{Sample Configuration Screen}.

\begin{verbatim}
@Override 
public String getScope() { 

    return "system"; 

}
\end{verbatim}

Third, set the
\href{/docs/7-1/tutorials/-/knowledge_base/t/scoping-configurations}{configuration
scope}.

\begin{verbatim}
@Override 
public void render(HttpServletRequest request, HttpServletResponse response) 
        throws IOException {

    _jspRenderer.renderJSP( _servletContext, request, response,
    "/sample_configuration_screen.jsp"); 

}

@Reference private JSPRenderer _jspRenderer;

@Reference(
    target ="(osgi.web.symbolicname=com.liferay.currency.converter.web)", 
    unbind = "-")
private ServletContext _servletContext;
\end{verbatim}

The most important step is to write the \texttt{render} method.This
example relies on the \texttt{JSPRenderer} service to delegate rendering
to a JSP.

It's beyond the scope of this tutorial to write the JSP markup. A
separate tutorial will provide a complete demonstration of the
\texttt{ConfigurationScreen} and implementation and the JSP markup to
demonstrate its usage.

\subsection{Excluding a Configuration UI from System
Settings}\label{excluding-a-configuration-ui-from-system-settings}

Providing a custom UI in System Settings is well and good, but what if
you instead must exclude your configuration from the System Settings UI?
For instance, if you're using Config Admin but also providing a
\texttt{ConfigurationScreen} implementation and a custom JSP, you'll get
two System Settings entries: the custom one you wrote \emph{and} the
auto-generated UI from Config Admin. Other times, a configuration is
required to be present for back-end developers but isn't intended to be
changed in the UI.

To exclude the UI entry, use the \texttt{ExtendedObjectClassDefinition}
annotation property called \texttt{generateUI}. It defaults to
\texttt{true}, so set it to \texttt{false} to suppress the
auto-generated UI. Here is an example:

\begin{verbatim}
@ExtendedObjectClassDefinition(generateUI=false)
@Meta.OCD(
  id = "com.foo.bar.LowLevelConfiguration",
)
public interface LowLevelConfiguration {

  public String[] foo();
  public String bar();

}
\end{verbatim}

Now the configuration is available to be managed programmatically or via
\href{/docs/7-1/user/-/knowledge_base/u/understanding-system-configuration-files}{.config
file}, but not via the System Settings UI.

\section{Configuration Form Renderer}\label{configuration-form-renderer}

There are various approaches to customizing the auto-generated System
Settings UI for your configurable application. To replace an
application's auto-generated configuration screen with a form built from
scratch, you follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Use a \texttt{DisplayContext} class to transfer data between back-end
  code and the desired JSP markup.
\item
  Implement the \texttt{ConfigurationFormRenderer} interface.
\item
  Render the configuration form. This tutorial demonstrates the use of a
  JSP and the previously created \texttt{DisplayContext} class.
\end{enumerate}

A generalized discussion on System Settings UI customization is found in
a
\href{/docs/7-1/tutorials/-/knowledge_base/t/customizing-the-system-settings-user-interface}{separate
tutorial}.

This tutorial demonstrates replacing the configuration UI for the
\emph{Language Template} System Settings entry, found in Control Panel →
Configuration → System Settings → Localization → Language Template. The
same steps apply when replacing your custom application's auto-generated
UI.

\begin{figure}
\centering
\includegraphics{./images/sys-settings-lang-template-default.png}
\caption{The auto-generated UI for the Language Template configuration
screen is sub-optimal. A select list with more human readable options is
preferable.}
\end{figure}

Specifically, the text input field labeled \emph{DDM Template Key} in
the auto-generated UI is replaced with a select list field type called
\emph{Language Selection Style}, populated with all possible DDM
Template Keys.

\subsection{\texorpdfstring{Creating a
\texttt{DisplayContext}}{Creating a DisplayContext}}\label{creating-a-displaycontext}

A \texttt{DisplayContext} class is a POJO that simplifies and minimizes
the use of Java logic in JSPs. Display context usage isn't required, but
it's a nice convention to follow. It's a kind of data transfer object,
where the \texttt{DisplayContext}'s setters are called from the Java
class providing the render logic (in this case the
\texttt{ConfigurationFormRenderer}'s \texttt{render} method), and the
getters are called from the JSP, removing the need for Java logic to be
written inside the JSP itself.

For this example, create a
\texttt{LanguageTemplateConfigurationDisplayContext} class with these
contents:

\begin{verbatim}
public class LanguageTemplateConfigurationDisplayContext {

    public void addTemplateValue(
        String templateKey, String templateDisplayName) {

        _templateValues.add(new String[] {templateKey, templateDisplayName});
    }

    public String getCurrentTemplateName() {
        return _currentTemplateName;
    }

    public String getFieldLabel() {
        return _fieldLabel;
    }

    public List<String[]> getTemplateValues() {
        return _templateValues;
    }

    public void setCurrentTemplateName(String currentTemplateName) {
        _currentTemplateName = currentTemplateName;
    }

    public void setFieldLabel(String fieldLabel) {
        _fieldLabel = fieldLabel;
    }

    private String _currentTemplateName;
    private String _fieldLabel;
    private final List<String[]> _templateValues = new ArrayList<>();

}
\end{verbatim}

Next implement the \texttt{ConfigurationFormRenderer}.

\subsection{\texorpdfstring{Implementing a
\texttt{ConfigurationFormRenderer}}{Implementing a ConfigurationFormRenderer}}\label{implementing-a-configurationformrenderer}

First create the component and class declarations. Set the
\texttt{service} property to \texttt{ConfigurationFormRenderer.class}:

\begin{verbatim}
@Component(
    configurationPid = "com.liferay.site.navigation.language.web.configuration.SiteNavigationLanguageWebTemplateConfiguration",
    immediate = true, service = ConfigurationFormRenderer.class
)
public class LanguageTemplateConfigurationFormRenderer
    implements ConfigurationFormRenderer {
\end{verbatim}

Next, write an \texttt{activate} method (decorated with
\texttt{@Activate} and \texttt{@Modified}) to to convert a map of the
configuration's properties to a typed class. The configuration is stored
in a volatile field. Don't forget to make it volatile to prevent thread
safety problems. See the article on
\href{/docs/7-1/tutorials/-/knowledge_base/t/reading-configuration-values-from-a-component}{reading
configuration values from a component class} for more information.

\begin{verbatim}
@Activate
@Modified
public void activate(Map<String, Object> properties) {
    _siteNavigationLanguageWebTemplateConfiguration =
        ConfigurableUtil.createConfigurable(
            SiteNavigationLanguageWebTemplateConfiguration.class,
            properties);
}

private volatile SiteNavigationLanguageWebTemplateConfiguration
    _siteNavigationLanguageWebTemplateConfiguration;
\end{verbatim}

Next override the \texttt{getPid} and \texttt{getRequestParameters}
methods:

\begin{verbatim}
@Override
public String getPid() {
    return "com.liferay.site.navigation.language.web.configuration." +
        "SiteNavigationLanguageWebTemplateConfiguration";
}
\end{verbatim}

Return the full configuration ID, as specified in the
\texttt{*Configuration} class's \texttt{@Meta.OCD} annotation.

\begin{verbatim}
@Override
public Map<String, Object> getRequestParameters(
    HttpServletRequest request) {

    Map<String, Object> params = new HashMap<>();

    String ddmTemplateKey = ParamUtil.getString(request, "ddmTemplateKey");

    params.put("ddmTemplateKey", ddmTemplateKey);

    return params;
}
\end{verbatim}

In the \texttt{getRequestParameters} method, map the parameters sent by
the custom form (obtained from the request) to the keys of the fields in
the Configuration interface.

Provide the render logic via the overridden \texttt{render} method. The
rendering approach demonstrated here uses a JSP. Recall that it's backed
by a \texttt{DisplayContext} class set into the request object. The
values set from this \texttt{render} method are available in the JSP via
the \texttt{DisplayContext} object's getters.

Loop through the DDM Template Keys for the given \texttt{groupId} and
set them into the display context with the \texttt{addTemplateKey}
method. Then set the other necessary values that the JSP needs. In this
case, set the title, the field label, and the redirect URL. Finally,
call \texttt{renderJSP} and pass in the \texttt{servletContext},
request, response, and the path to the JSP:

\begin{verbatim}
@Override
public void render(HttpServletRequest request, HttpServletResponse response)
    throws IOException {

    Locale locale = LocaleThreadLocal.getThemeDisplayLocale();

    LanguageTemplateConfigurationDisplayContext
        languageTemplateConfigurationDisplayContext =
            new LanguageTemplateConfigurationDisplayContext();

    languageTemplateConfigurationDisplayContext.setCurrentTemplateName(
        _siteNavigationLanguageWebTemplateConfiguration.ddmTemplateKey());

    long groupId = 0;

    Group group = _groupLocalService.fetchCompanyGroup(
        CompanyThreadLocal.getCompanyId());

    if (group != null) {
        groupId = group.getGroupId();
    }

    List<DDMTemplate> ddmTemplates = _ddmTemplateLocalService.getTemplates(
        groupId, _portal.getClassNameId(LanguageEntry.class));

    for (DDMTemplate ddmTemplate : ddmTemplates) {
        languageTemplateConfigurationDisplayContext.addTemplateValue(
            ddmTemplate.getTemplateKey(), ddmTemplate.getName(locale));
    }

    languageTemplateConfigurationDisplayContext.setFieldLabel(
        LanguageUtil.get(
            ResourceBundleUtil.getBundle(
                locale, LanguageTemplateConfigurationFormRenderer.class),
            "language-selection-style"));

    request.setAttribute(
        LanguageTemplateConfigurationDisplayContext.class.getName(),
        languageTemplateConfigurationDisplayContext);

    _jspRenderer.renderJSP(
        _servletContext, request, response,
        "/configuration/site_navigation_language_web_template.jsp");
}
\end{verbatim}

Specify the required service references at the bottom of the class. Be
careful to target the proper servlet context, passing the
\texttt{bundle-SymbolicName} of the module (found in its
\texttt{bnd.bnd} file) into the \texttt{osgi.web.symbolicname} property
of the reference target:

\begin{verbatim}
@Reference
private DDMTemplateLocalService _ddmTemplateLocalService;

@Reference
private GroupLocalService _groupLocalService;

@Reference
private JSPRenderer _jspRenderer;

@Reference
private Portal _portal;

@Reference(
    target = "(osgi.web.symbolicname=com.liferay.site.navigation.language.web)",
    unbind = "-"
)
private ServletContext _servletContext;
\end{verbatim}

Once the configuration form renderer is implemented, you can write the
JSP markup for the form.

\subsection{Writing the JSP Markup}\label{writing-the-jsp-markup}

Now write the JSP:

\begin{verbatim}
<%@ include file="/init.jsp" %>

<%
LanguageTemplateConfigurationDisplayContext
    languageTemplateConfigurationDisplayContext = (LanguageTemplateConfigurationDisplayContext)request.getAttribute(LanguageTemplateConfigurationDisplayContext.class.getName());

String currentTemplateName = languageTemplateConfigurationDisplayContext.getCurrentTemplateName();
%>

<aui:select label="<%= HtmlUtil.escape(languageTemplateConfigurationDisplayContext.getFieldLabel()) %>" name="ddmTemplateKey" value="<%= currentTemplateName %>">

    <%
    for (String[] templateValue : languageTemplateConfigurationDisplayContext.getTemplateValues()) {
    %>

        <aui:option label="<%= templateValue[1] %>" selected="<%= currentTemplateName.equals(templateValue[0]) %>" value="<%= templateValue[0] %>" />

    <%
    }
    %>

</aui:select>
\end{verbatim}

The opening scriptlet gets the display context object from the request
so that all its getters are invoked whenever information from the
back-end is required. Right away, the \texttt{getCurrentTemplateName}
method is called, since the current template name is needed for the
first option's \texttt{ddmTemplateKey} display value as soon as the form
is rendered. This happens in the
\texttt{\textless{}aui:select\textgreater{}} tag. There's just a bit of
logic used to create an option for each of the available DDM templates
that can be chosen.

So what does this example look like when all is said and done?

\begin{figure}
\centering
\includegraphics{./images/sys-settings-lang-template-custom.png}
\caption{A select list provides a more user friendly configuration
experience than a text field.}
\end{figure}

Some configuration UIs require tweaking with a
\texttt{ConfigurationFormRenderer}. This tutorial shows a particularly
good example. Administrators encountering the Language Template entry in
System Settings won't know the DDM Template Keys they can use offhand.
Providing the available values in a select field wildly enhances the
user experience.

\chapter{Internationalization}\label{internationalization}

Localizing content and designing apps for different locales is a
straightforward process. You can centralize messages (language keys) and
translate them manually or automatically, including form localization
and setting text in either direction (left-to-right or right-to-left).
Customizing messages in apps is easy too. Read on to learn how to
internationalize your applications.

\section{Localizing Your Application}\label{localizing-your-application}

If you're writing a Liferay Application, you're probably a genius who is
also really cool, which means your application will be used throughout
the entire world. At least, if its messages can be translated into their
language, it will. Thankfully, Liferay makes it easy to support
translation of your application's language keys.

\noindent\hrulefill

\textbf{Note:} Even if you don't plan to translate your application into
multiple languages, use the localization pattern presented here for any
messages displayed in your user interface. It's much easier to change
the messages by updating a language properties file than by finding
every instance of a message and replacing it in your JSPs and Java
classes.

\noindent\hrulefill

You just need to create a default language properties file
(\texttt{Language.properties}) and one for each translation you'd like
to support (for example, \texttt{Language\_fr.properties} for your
French translation), and put them in the correct location in your
application. Use the two letter locale that corresponds to the language
you want to translate in your file names (for example,
\texttt{Language\_es.properties} provides a Spanish translation for each
key).

Application localization topics:

\begin{itemize}
\tightlist
\item
  \hyperref[what-are-language-keys]{What are Language Keys?}
\item
  \hyperref[what-locales-are-available-by-default]{What Locales are
  Available By Default?}
\item
  \hyperref[where-do-i-put-language-files]{Where do I Put Language
  Files?}
\item
  \hyperref[creating-a-language-module]{Creating a Language Module}
\item
  \hyperref[using-a-language-module]{Using a Language Module}
\item
  \hyperref[using-liferays-language-properties]{Using Liferay DXP's
  Language Properties}
\end{itemize}

\subsection{What are Language Keys?}\label{what-are-language-keys}

Each language property file holds key/value pairs. The key is the same
in all the language property files, while the value is translated in
each file. You specify the key in your user interface code, and the
appropriately translated message is returned automatically for your
users, depending on the locale being used in Liferay. If you have
Liferay running locally, append the URL with a supported locale to see
the translations (for example, enter \texttt{localhost:8080/es}).

\begin{figure}
\centering
\includegraphics{./images/locale-message-spain.png}
\caption{Append the locale to your running Liferay's URL and see
Liferay's translation power in action.}
\end{figure}

Language keys are just keys to use in place of a hard coded, fully
translated String value in your user interface code. You use a language
key in your JSP with a
\texttt{\textless{}liferay-ui:message\ /\textgreater{}} tag.

If you wanted to hard code a message, you'd use the tag like this:

\begin{verbatim}
<liferay-ui:message key="Howdy, Partner!" />
\end{verbatim}

In that case you'll get a properly capitalized and punctuated message in
your application.

Instead, specify a simple key instead of the final value:

\begin{verbatim}
<liferay-ui:message key="howdy-partner" />
\end{verbatim}

That way you can provide a translation of the key in a default language
properties file (\texttt{Language.properties}):

\begin{verbatim}
howdy-partner=Howdy, Partner!
\end{verbatim}

Either way, you get the same output. The properties file lets you put
all your messages in one place, and you can add additional language
properties files with translations later. You just need to make sure
there's a locale that corresponds to your translation.

The values from your default \texttt{Language.properties} file appear if
no locale is specified. If a locale is specified, a key from a file
corresponding to that local is retrieved. For example, if a Spanish
translation is sought, a \texttt{Language\_es.properties} file must be
present to provide the proper values. If it isn't, the default language
properties (from the \texttt{Language.properties} file) are used.

\subsection{What Locales are Available By
Default?}\label{what-locales-are-available-by-default}

There are a bunch of locales available by default in Liferay. Look in
the \texttt{portal.properties}
\href{https://docs.liferay.com/dxp/portal/7.1-latest/propertiesdoc/portal.properties.html\#Languages\%20and\%20Time\%20Zones}{file}
to find them.

\begin{verbatim}
locales=ar_SA,eu_ES,bg_BG,ca_AD,ca_ES,zh_CN,zh_TW,hr_HR,cs_CZ,da_DK,nl_NL,
    nl_BE,en_US,en_GB,en_AU,et_EE,fi_FI,fr_FR,fr_CA,gl_ES,de_DE,el_GR,
    iw_IL,hi_IN,hu_HU,in_ID,it_IT,ja_JP,ko_KR,lo_LA,lt_LT,nb_NO,fa_IR,
    pl_PL,pt_BR,pt_PT,ro_RO,ru_RU,sr_RS,sr_RS_latin,sl_SI,sk_SK,es_ES,
    sv_SE,tr_TR,uk_UA,vi_VN
\end{verbatim}

To provide a translation for one of these locales, specify the locale in
the file name containing the translated keys (for example,
\texttt{Language\_es.properties} holds the Spanish translation).

\subsection{Where do I Put Language
Files?}\label{where-do-i-put-language-files}

In an application with only one module that holds all your application's
views (for example, all its JSPs) and portlet components, create a
\texttt{src/main/resources/content} folder in that module, and place
your \texttt{Language.properties} and \texttt{Language\_xx.properties}
files there.

After that, make sure any portlet components (the \texttt{@Component}
annotation in your \texttt{-Portlet} classes) in the module include this
property:

\begin{verbatim}
"javax.portlet.resource-bundle=content.Language"
\end{verbatim}

Providing translated language properties files and specifying the
\texttt{javax.portlet.resource-bundle} property in your portlet
component is all you must do to point Liferay DXP at your translations.
Users see the translations for the locales they select.

In a more complicated, well-modularized application, you might have
language keys spread over multiple modules providing portlet components
and JSP files. Moreover, there might be a fair number of duplicated
language keys between the modules. Thankfully you don't need to maintain
language properties files in each module.

\subsection{Creating a Language
Module}\label{creating-a-language-module}

If you're crazy about modularity (and you should be), you might have an
application with multiple modules that provide the view layer. These
modules are often called web modules.

\begin{verbatim}
my-application/
my-application-web/
my-admin-application-web/
my-application-content-web/
my-application-api/
my-application-service/
\end{verbatim}

Each of these modules can have language keys and translations to
maintain, and there will probably be duplicate keys. You don't want to
end up with different values for the same key, and you don't want to
maintain language keys in multiple places. In this case, you need to go
even crazier with modularity and create a new module, which we'll call a
language module.

In the root project folder (the one that holds your service, API, and
web modules),
\href{/docs/7-1/tutorials/-/knowledge_base/t/starting-module-development\#creating-a-module}{create
a new module} to hold your app's language keys. For example, here's the
folder structure of a language module called
\texttt{my-application-lang}.

\begin{verbatim}
my-application-lang/
    bnd.bnd
    src/
        main/
            resources/
                content/
                    Language.properties
                    Language_ar.properties
                    Language_bg.properties
                    ...
\end{verbatim}

In the language module, create a \texttt{src/main/resources/content}
folder. Put your language properties files here. A
\texttt{Language.properties} file might look like this:

\begin{verbatim}
application=My Application
add-entity=Add Entity
\end{verbatim}

Create any translations you want, adding the translation locale ID to
the language file name. File \texttt{Language\_es.properties} might look
like this:

\begin{verbatim}
my-app-title=Mi Aplicación
add-entity=Añadir Entity
\end{verbatim}

On building the language module, Liferay DXP's
\texttt{ResourceBundleLoaderAnalyzerPlugin} detects the
\texttt{content/Language.properties} file and adds a resource bundle
\href{http://blog.osgi.org/2015/12/using-requirements-and-capabilities.html}{\emph{capability}}
to the module. A capability is a contract a module declares to Liferay
DXP's OSGi framework. Capabilities let you associate services with
modules that provide them. In this case, Liferay DXP registers a
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/util/ResourceBundleLoader.html}{ResourceBundleLoader}
service for the resource bundle capability.

Next, you'll configure a web module to use the language module resource
bundle.

\subsection{Using a Language Module}\label{using-a-language-module}

A module or traditional Liferay plugin can use a resource bundle from
another module and optionally include its own resource bundle. OSGi
manifest headers \texttt{Require-Capability} and
\texttt{Provide-Capability} make this possible, and it's especially easy
in modules generated from Liferay project templates. Instructions for
using a language module are divided into these environments:

\begin{itemize}
\tightlist
\item
  \hyperref[using-a-language-module-from-a-module]{Using a Language
  Module from a Module}
\item
  \hyperref[using-a-language-module-from-a-traditional-plugin]{Using a
  Language Module from a Traditional Plugin}
\end{itemize}

If you're using bnd with Maven or Gradle, you need only specify
Liferay's \texttt{-liferay-aggregate-resource-bundle:} bnd
instruction--at build time, Liferay's bnd plugin converts the
instruction to \texttt{Require-Capability} and
\texttt{Provide-Capability} parameters automatically. Both approaches
are demonstrated.

\subsubsection{Using a Language Module from a
Module}\label{using-a-language-module-from-a-module}

Modules generated from Liferay project templates have a Liferay bnd
build time instruction called
\texttt{-liferay-aggregate-resource-bundles}. It lets you use other
resource bundles (e.g., including their language keys) along with your
own. Here's how to do it:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open your module's \texttt{bnd.bnd} file.
\item
  Add the \texttt{-liferay-aggregate-resource-bundles:} bnd instruction
  and assign it the bundle symbolic names of modules whose resource
  bundles to aggregate with the current module's resource bundle.

\begin{verbatim}
-liferay-aggregate-resource-bundles: \
    [bundle.symbolic.name1],\
    [bundle.symbolic.name2]
\end{verbatim}
\end{enumerate}

For example, a module that uses resource bundles from modules
\texttt{com.liferay.docs.l10n.myapp1.lang} and
\texttt{com.liferay.docs.l10n.myapp2.lang} would set this in its
\texttt{bnd.bnd} file:

\begin{verbatim}
-liferay-aggregate-resource-bundles: \
    com.liferay.docs.l10n.myapp1.lang,\
    com.liferay.docs.l10n.myapp2.lang
\end{verbatim}

The current module's resource bundle is prioritized over those of the
listed modules.

\noindent\hrulefill

The
\href{/docs/7-1/reference/-/knowledge_base/r/shared-language-keys}{Shared
Language Key sample project} is a working example that demonstrates
aggregating resource bundles. You can deploy it in Gradle, Maven, and
Liferay Workspace build environments.

\noindent\hrulefill

At build time, Liferay's bnd plugin converts the bnd instruction to
\texttt{Require-Capability} and \texttt{Provide-Capability} parameters
automatically. In traditional Liferay plugins, you must specify the
parameters manually.

\noindent\hrulefill

\textbf{Note:} You can always specify the \texttt{Require-Capability}
and \texttt{Provide-\ \ Capability} OSGi manifest headers manually, as
the next section demonstrates.

\noindent\hrulefill

\subsubsection{Using a Language Module from a Traditional
Plugin}\label{using-a-language-module-from-a-traditional-plugin}

To use a language module, from a traditional Liferay plugin you must
specify the language module using \texttt{Require-Capability} and
\texttt{Provide-Capability} OSGi manifest headers in the plugin's
\texttt{liferay-plugin-package.properties} file.

Follow these steps to configure your traditional plugin to use a
language module:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open the plugin's \texttt{liferay-plugin-package.properties} file and
  add a \texttt{Require-Capability} header that filters on the language
  module's resource bundle capability. For example, if the language
  module's symbolic name is \texttt{myapp.lang}, you'd specify the
  requirement like this:

\begin{verbatim}
Require-Capability: liferay.resource.bundle;filter:="(bundle.symbolic.name=myapp.lang)"
\end{verbatim}
\item
  In the same \texttt{liferay-plugin-package.properties} file, add a
  \texttt{Provide-Capability} header that adds the language module's
  resource bundle \emph{as} this plugin's (the \texttt{myapp.web}
  plugin) own resource bundle:

\begin{verbatim}
Provide-Capability:\
liferay.resource.bundle;resource.bundle.base.name="content.Language",\
liferay.resource.bundle;resource.bundle.aggregate:String="(bundle.symbolic.name=myapp.lang)";bundle.symbolic.name=myapp.web;resource.bundle.base.name="content.Language";service.ranking:Long="4";\
servlet.context.name=myapp-web
\end{verbatim}
\end{enumerate}

In this case, the \texttt{myapp.web} plugin solely uses the language
module's resource bundle---the resource bundle aggregate only includes
language module \texttt{myapp.lang}.

Aggregating resource bundles comes into play when you want to use a
language module's resource bundle \emph{in addition to} your plugin's
resource bundle. These instructions show you how to do this, while
prioritizing your current plugin's resource bundle over the language
module resource bundle. In this way, the language module's language keys
compliment your plugin's language keys.

For example, a portlet whose bundle symbolic name is \texttt{myapp.web}
uses keys from language module \texttt{myapp.lang}, in addition to its
own. The portlet's \texttt{Provide-Capability} and
\texttt{Web-ContextPath} OSGi headers accomplish this.

\begin{verbatim}
Provide-Capability:\
liferay.resource.bundle;resource.bundle.base.name="content.Language",\
liferay.resource.bundle;resource.bundle.aggregate:String="(bundle.symbolic.name=myapp.web),(bundle.symbolic.name=myapp.lang)";bundle.symbolic.name=myapp.web;resource.bundle.base.name="content.Language";service.ranking:Long="4";\
servlet.context.name=myapp-web
\end{verbatim}

The example \texttt{Provide-Capability} header has two parts:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \texttt{liferay.resource.bundle;resource.bundle.base.name="content.Language"}
  declares that the module provides a resource bundle whose base name is
  \texttt{content.language}.
\item
  The
  \texttt{liferay.resource.bundle;resource.bundle.aggregate:String=...}
  directive specifies the list of bundles whose resource bundles are
  aggregated, the target bundle, the target bundle's resource bundle
  name, and this service's ranking:

  \begin{itemize}
  \tightlist
  \item
    \texttt{"(bundle.symbolic.name=myapp.web),(bundle.symbolic.name=myapp.lang)"}:
    The service aggregates resource bundles from bundles
    \texttt{bundle.symbolic.name=myapp.web} (the current module) and
    \texttt{bundle.symbolic.name=myapp.lang}. Aggregate as many bundles
    as desired. Listed bundles are prioritized in descending order.
  \item
    \texttt{bundle.symbolic.name=myapp.web;resource.bundle.base.name="content.Language"}:
    Override the \texttt{myapp.web} bundle's resource bundle named
    \texttt{content.Language}.
  \item
    \texttt{service.ranking:Long="4"}: The resource bundle's service
    ranking is \texttt{4}. The OSGi framework applies this service if it
    outranks all other resource bundle services that target
    \texttt{myapp.web}'s \texttt{content.Language} resource bundle.
  \item
    \texttt{servlet.context.name=myapp-web}: The target resource bundle
    is in servlet context \texttt{myapp-web}.
  \end{itemize}
\end{enumerate}

Now the language keys from the aggregated resource bundles compliment
your plugin's language keys.

Did you know that Liferay DXP's core language keys are also available to
your module? They're up next.

\subsection{Using Liferay's Language
Properties}\label{using-liferays-language-properties}

If you have Liferay DXP's source code, you can check out Liferay DXP's
core language properties by looking in the
\texttt{portal-impl/src/main/content} folder. Otherwise, you can look in
the \texttt{portal-impl.jar} that's in your Liferay bundle.

\begin{verbatim}
liferay-portal/portal-impl/src/content/Language_xx.properties

[Liferay Home]/tomcat-[version]/webapps/ROOT/WEB-INF/lib/portal-impl.jar
\end{verbatim}

These keys are available at runtime, so when you use any of Liferay
DXP's default keys in your user interface code, they're automagically
swapped out for the appropriately translated value. Using Liferay DXP's
keys where possible saves you time and ensures that your application
follows Liferay's UI conventions.

If you want to generate language files for each supported locale
automatically, or to configure your application to generate translations
automatically using the Microsoft Translator API, check out the tutorial
\href{/docs/7-1/tutorials/-/knowledge_base/t/automatically-generating-language-files}{Automatically
Generating Language Files}.

\section{Automatically Generating Language
Files}\label{automatically-generating-language-files}

If you already have a \texttt{Language.properties} file that holds
\href{/docs/7-1/tutorials/-/knowledge_base/t/localizing-your-application}{language
keys for your user interface messages}, or even a language module that
holds these keys, you're in the right place. In this tutorial, you'll
explore the following capabilities:

\begin{itemize}
\item
  Generating language properties files for each supported locale with a
  single command. This prevents you from having to create a language
  properties file for each locale manually. The same command also
  propagates the keys from the default language file to all translation
  files.
\item
  Generating automatic translations using Microsoft's Translator Text
  API. This prevents you from translating each message manually.
\end{itemize}

\subsection{Generating Language Files for Supported
Locales}\label{generating-language-files-for-supported-locales}

If you want to generate files automatically for all
\href{https://docs.liferay.com/dxp/portal/7.1-latest/propertiesdoc/portal.properties.html\#Languages\%20and\%20Time\%20Zones}{supported
locales}, you must make a small modification to your application's build
file.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Make sure your module's build includes the
  \href{https://github.com/liferay/liferay-portal/tree/master/modules/sdk/gradle-plugins-lang-builder}{\texttt{com.liferay.lang.builder}}
  plugin by putting it in your build script's classpath. If you're using
  \href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-workspace}{Liferay
  Workspace}, the Lang Builder is already available to your modules.

  Here's what a configuration of the \texttt{com.liferay.lang.builder}
  plugin looks in a \texttt{build.gradle} file:

\begin{verbatim}
    buildscript {
        dependencies {
            classpath 'com.liferay:com.liferay.gradle.plugins.lang.builder:latest.release'
        }

        repositories {
            maven {
                url "http://repository-cdn.liferay.com/nexus/content/groups/public"
            }
        }
    }

    apply plugin: "com.liferay.lang.builder"

    repositories {
        maven {
            url "http://repository-cdn.liferay.com/nexus/content/groups/public"
        }
    }
\end{verbatim}
\item
  Create (if necessary) a default \texttt{Language.properties} file in
  the \texttt{src/main/resources/content} folder.
\item
  Run the \texttt{gradlew\ buildLang} task from your project's root
  folder to generate default translation files.

  The generated files contain copies of all the keys and values in your
  default \texttt{Language.properties} files. Run the \texttt{buildLang}
  task each time you change the default language file.

  When the task completes, it prints \texttt{BUILD\ SUCCESSFUL} with
  this log output:

\begin{verbatim}
Translation is disabled because credentials are not specified
\end{verbatim}

  See the next section to learn how to provide credentials to enable
  translation services.
\end{enumerate}

Now you can begin translating your application's messages. If you want
to configure your app to generate automatic translations using the
Microsoft Translator Text API, keep reading.

\subsection{Translating Language Keys
Automatically}\label{translating-language-keys-automatically}

If you've configured the \texttt{com.liferay.lang.builder} plugin in
your app, you're almost there. Now you have to configure
\href{https://azure.microsoft.com/en-us/services/cognitive-services/translator-text-api/}{Microsoft's
Translator Text API} so you can generate automatic translations of your
language keys. You cannot, however, use Liferay's Lang Builder to
automatically translate language keys containing HTML (e.g.,
\texttt{\textless{}em\textgreater{}},
\texttt{\textless{}b\textgreater{}},
\texttt{\textless{}code\textgreater{}}, etc.). Language keys containing
HTML are automatically \emph{copied} to all supported language files.

\noindent\hrulefill

\textbf{Note:} These translations are best used as a starting point. A
machine translation can't match the accuracy of a real person who is
fluent in the language. Then again, if you only speak English and you
need a Hungarian translation, this is better and faster than your
attempts at a manual translation.

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Generate a translation subscription key for the Microsoft Translator
  Text API. Follow the instructions
  \href{http://docs.microsofttranslator.com/text-translate.html}{here}.
\item
  Make sure the \texttt{buildLang} task knows to use your subscription
  key for translation by setting the \texttt{translateSubscriptionKey}
  property:

\begin{verbatim}
buildLang {
    translateSubscriptionKey = "my-key"
}
\end{verbatim}

  For security reasons, you probably don't want to pass them directly in
  your application's build script. Instead, pass the credentials to a
  property that's stored in your
  \href{https://docs.gradle.org/current/userguide/build_environment.html}{local
  build environment}, and pass the property into your application's
  build script.

\begin{verbatim}
 buildLang {
   translateSubscriptionKey = langTranslateSubscriptionKey
}
\end{verbatim}
\end{enumerate}

So what would the complete \texttt{buildLang} configuration look like if
you followed all the steps above?

\begin{verbatim}
buildscript {
    dependencies {
        classpath 'com.liferay:com.liferay.gradle.plugins.lang.builder:latest.release'
    }

    repositories {
        maven {
            url "http://repository-cdn.liferay.com/nexus/content/groups/public"
        }
    }
}

apply plugin: "com.liferay.lang.builder"

buildLang {
   translateSubscriptionKey = langTranslateSubscriptionKey
}

repositories {
    maven {
        url "http://repository-cdn.liferay.com/nexus/content/groups/public"
    }
}
\end{verbatim}

Great! You can now generate language files and provide automatic
translations of your language keys.

\section{Using Liferay's Language
Settings}\label{using-liferays-language-settings}

For a given locale, you can
\href{/docs/7-1/tutorials/-/knowledge_base/t/overriding-language-keys}{override
Liferay DXP's core UI messages}. Modifying language key values provides
a lot of localization flexibility in itself, but we're always looking
for new ways to give you more control. There are language settings in
\texttt{Language\_xx.properties} files that give you even more
localization options.

\begin{itemize}
\item
  In the add and edit user forms, configure the name fields that are
  displayed and the field values available in select fields. For
  example, leave out the middle name field if you want, or alter the
  prefix selections.
\item
  Control the directionality of content and messages (left to right or
  right to left).
\end{itemize}

To see how these settings are configured, open Liferay DXP's core
\texttt{Language.properties} file in one of two ways:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  From Liferay Portal's source code. Navigate to

\begin{verbatim}
 liferay-portal/portal-impl/src/content/Language.properties
\end{verbatim}
\item
  From a bundle's \texttt{portal-impl.jar}.

\begin{verbatim}
 [Liferay Home]/tomcat-[version]/webapps/ROOT/WEB-INF/lib/portal-impl.jar
\end{verbatim}

  Just open the \texttt{content} folder in the JAR to find the language
  files.
\end{enumerate}

The first section in the \texttt{Language.properties} file is labeled
\emph{Language Settings}:

\begin{verbatim}
##
## Language Settings
##

lang.dir=ltr
lang.line.begin=left
lang.line.end=right
lang.user.default.portrait=initials
lang.user.initials.field.names=first-name,last-name
lang.user.name.field.names=prefix,first-name,middle-name,last-name,suffix
lang.user.name.prefix.values=Dr,Mr,Ms,Mrs
lang.user.name.required.field.names=last-name
lang.user.name.suffix.values=II,III,IV,Jr,Phd,Sr
\end{verbatim}

\noindent\hrulefill

\textbf{Note:} To use the language settings mentioned here, you need a
module, which is like a magic carpet on which your code and resources
ride triumphantly into Liferay DXP's OSGi runtime. Refer to the tutorial
on
\href{/docs/7-1/tutorials/-/knowledge_base/t/overriding-language-keys}{overriding
language keys} to set up a module with the following characteristics:

\begin{itemize}
\item
  Contains an implementation of \texttt{ResourceBundle} that is
  registered in the OSGi runtime.
\item
  Contains a \texttt{Language.properties} file for the locale whose
  properties you want to override.
\end{itemize}

\noindent\hrulefill

The user name properties are used to customize certain fields of the Add
and Edit user forms based on a user's locale.

\subsection{Localizing User Names}\label{localizing-user-names}

Customers come from all over the world, so naming conventions are
different between locales. Because of this, user name fields are
configurable in the following ways:

\begin{itemize}
\item
  Remove certain name fields and make others appear more than once. Some
  locales need more than one last name, for example.

\begin{verbatim}
 lang.user.name.field.names=prefix,first-name,middle-name,last-name,suffix
\end{verbatim}
\item
  Change the prefix and suffix values for a locale.

\begin{verbatim}
 lang.user.name.prefix.values=Dr,Mr,Ms,Mrs
 lang.user.name.suffix.values=II,III,IV,Jr,Phd,Sr
\end{verbatim}
\item
  Specify which fields are required.

\begin{verbatim}
 lang.user.name.required.field.names=last-name
\end{verbatim}
\end{itemize}

\noindent\hrulefill

\textbf{Note:} A user's first name is mandatory. Because of this, take
these two points into consideration when configuring a locale's user
name settings:

\begin{itemize}
\item
  The \texttt{first-name} field can't be removed from the field names
  list.

\begin{verbatim}
  lang.user.name.field.names=prefix,first-name,middle-name,last-name,suffix
\end{verbatim}
\item
  Because a first name is required, it's always implicitly included in
  the \emph{required field names} property:

\begin{verbatim}
  lang.user.name.required.field.names=last-name
\end{verbatim}

  Therefore, any fields you enter here are \emph{in addition to} the
  first name field. Last name is required by default, but you can
  disable it by deleting its value from the property:

\begin{verbatim}
  lang.user.name.required.field.names=
\end{verbatim}

  In that case, only a first name would be required.
\end{itemize}

\noindent\hrulefill

The properties for changing user name settings are those that begin with
\texttt{lang.user.name} in the language settings section of a locale's
language properties file.

For most of the
\href{https://docs.liferay.com/dxp/portal/7.1-latest/propertiesdoc/portal.properties.html\#Languages\%20and\%20Time\%20Zones}{locales
enabled by default}, the user name properties are specifically tailored
to that location.

\begin{verbatim}
locales.enabled=ca_ES,zh_CN,nl_NL,en_US,fi_FI,fr_FR,de_DE,iw_IL,hu_HU,ja_JP,pt_BR,es_ES
\end{verbatim}

For example, these are the English (i.e.,
\texttt{Language\_en.properties}) properties for setting user name
fields:

\begin{verbatim}
lang.user.name.field.names=prefix,first-name,middle-name,last-name,suffix
lang.user.name.prefix.values=Dr,Mr,Ms,Mrs
lang.user.name.required.field.names=last-name
lang.user.name.suffix.values=II,III,IV,Jr,Phd,Sr
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/english-user-name-fields.png}
\caption{The user name settings impact the way user information and
forms appear in Liferay.}
\end{figure}

Compare those to the Spanish (\texttt{Language\_es.properties})
settings:

\begin{verbatim}
lang.user.name.field.names=prefix,first-name,last-name
lang.user.name.prefix.values=Sr,Sra,Sta,Dr,Dra
lang.user.name.required.field.names=last-name
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/spanish-user-name-fields.png}
\caption{The Spanish user name settings omit the suffix and middle name
fields entirely.}
\end{figure}

The biggest difference between the English and Spanish form fields is
that the middle name and suffix fields are omitted in the Spanish
configuration. Other differences include the specific prefix values.

¡Muy excelente! Localizing the forms for adding and editing users is
accomplished using the same method by which Liferay DXP's UI messages
are localized: overriding one of its \texttt{Lanuguage\_xx.properties}
files.

\subsection{Identifying User Initials}\label{identifying-user-initials}

The default avatar displays a user's initials. Some cultures use
initials differently, so there's a way to configure them in the
\texttt{Language.properties} file.

\begin{verbatim}
lang.user.default.portrait=initials
lang.user.initials.field.names=first-name,last-name
\end{verbatim}

The \texttt{lang.user.default.portrait} property sets the type of
portrait to use for users. This can be set to \texttt{initials} or
\texttt{image}. If set to \texttt{image}, the default images defined by
the \texttt{image.default.user.female.portrait} or
\texttt{image.default.user.male.portrait} properties residing in the
\texttt{portal.properties} file are used. Therefore, the
\texttt{lang.user.initials.field.names} property is ignored.

\begin{figure}
\centering
\includegraphics{./images/initials-avatar.png}
\caption{The user's initials are displayed for their avatar by default.}
\end{figure}

If you're leveraging the user's initials for the default avatar, the
\texttt{lang.user.initials.field.names} property is used to organize how
the initials are displayed. Valid values for this property include
\texttt{first-name}, \texttt{middle-name}, and \texttt{last-name}, in
any order.

Now you can manage how a user's initials are displayed!

\subsection{Right to Left or Left to
Right?}\label{right-to-left-or-left-to-right}

The first three properties in the \texttt{Language.properties}'s
Language Settings section change the direction in which the language's
characters are displayed. Most languages are read from left to right,
but some languages are read from right to left (e.g., Arabic, Hebrew,
and Persian). You can also change it for languages that have been
traditionally displayed left to right (like English) as a funny
practical joke. Just don't tell anyone that you got the idea here.

Here's what the relevant language properties look like for a language
that should be displayed from right to left:

\begin{verbatim}
lang.dir=rtl
lang.line.begin=right
lang.line.end=left
\end{verbatim}

With these customizations, you can transform your UI into a
user-friendly environment no matter where your users are from.

\noindent\hrulefill

\textbf{Note:} You can prevent specific CSS rules from transforming
(flipping) with the \texttt{/*\ @noflip\ */} decoration. Place the
decoration to the left of the CSS rule to apply it. For example, this
rule gives a left margin of \texttt{20em} to the \texttt{body} no matter
if the selected language is LTR or RTL:

\begin{verbatim}
/* @noflip */ body {
 margin-left: 20em;
}
\end{verbatim}

You can also use the \texttt{.rtl} CSS selector for rules that
exclusively apply to RTL languages.

\chapter{Application Display
Templates}\label{application-display-templates}

In the past, when you needed to modify the UI of a widget, you had to
use a hook (e.g., HTML-related change) or a theme (e.g., CSS-related
change). It would be nice to apply particular display changes to
specific widget instances without having to redeploy any plugins.
Ideally, you should be able to provide authorized portal users the
ability to apply custom display interfaces to widgets.

Be of good cheer! That's precisely what
\href{/docs/7-1/user/-/knowledge_base/u/styling-widgets-with-application-display-templates}{Application
Display Templates} (ADTs) provide--the ability to customize the way
widgets appear on a page, removing limitations to the way your site's
content is displayed. With ADTs, you can define custom display templates
used to render asset-centric widgets. This isn't actually a new concept
in Liferay DXP; some widgets already had templating capabilities (e.g.,
\emph{Web Content} and \emph{Dynamic Data Lists}), in which you can
already add as many display options (or templates) as you want. Now you
can add them to your custom portlets, too.

Some portlets that already support Application Display Templates in 7.1
are

\begin{itemize}
\tightlist
\item
  \emph{Asset Publisher}
\item
  \emph{Blogs}
\item
  \emph{Breadcrumb}
\item
  \emph{Categories Navigation}
\item
  \emph{Language Selector}
\item
  \emph{Media Gallery}
\item
  \emph{Navigation Menu}
\item
  \emph{RSS Publisher}
\item
  \emph{Site Map}
\item
  \emph{Tags Navigation}
\item
  \emph{Wiki}
\end{itemize}

Continue on to add support for ADTs in your custom portlet.

\section{Implementing Application Display
Templates}\label{implementing-application-display-templates}

\href{/docs/7-1/user/-/knowledge_base/u/styling-widgets-with-application-display-templates}{Application
Display Templates} (ADTs) let you add custom display templates to your
widgets from the portal. The figure below shows what the Display
Template option looks like in a widget's Configuration menu.

\begin{figure}
\centering
\includegraphics{./images/adt-dropdown.png}
\caption{By using a custom display template, your portlet's display can
be customized.}
\end{figure}

In this tutorial, you'll learn how to use the Application Display
Templates API to add an ADT to a portlet.

\subsection{Using the Application Display Templates
API}\label{using-the-application-display-templates-api}

To leverage the ADT API, there are several steps you must follow. These
steps involve

\begin{itemize}
\tightlist
\item
  registering your portlet to use ADTs
\item
  defining permissions
\item
  exposing the ADT functionality to users
\end{itemize}

You'll walk through these steps next.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create and register a custom \texttt{*PortletDisplayTemplateHandler}
  component. Liferay provides the
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portletdisplaytemplate/BasePortletDisplayTemplateHandler.html}{\texttt{BasePortletDisplayTemplateHandler}}
  as a base implementation for you to extend. You can check the
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/template/TemplateHandler.html}{\texttt{TemplateHandler}}
  interface Javadoc to learn about each template handler method.

  The \texttt{@Component} annotation ties your handler to a specific
  portlet by setting the property \texttt{javax.portlet.name} to your
  portlet's name. The same property should be found in your portlet
  class. For example,

\begin{verbatim}
@Component(
    immediate = true,
    property = {
        "javax.portlet.name="+ AssetCategoriesNavigationPortletKeys.ASSET_CATEGORIES_NAVIGATION
    },
    service = TemplateHandler.class
)
\end{verbatim}

  Each of the methods in this class have a significant role in defining
  and implementing ADTs for your custom portlet. The list below
  highlights some of the methods defined specifically for ADTs:

  \textbf{getClassName():} Defines the type of entry your portlet is
  rendering.

  \textbf{getName():} Declares the name of your ADT type (typically, the
  name of the portlet).

  \textbf{getResourceName():} Specifies which resource is using the ADT
  (e.g., a portlet) for permission checking. This method must return the
  portlet's fully qualified portlet ID (e.g.,
  \texttt{com\_liferay\_wiki\_web\_portlet\_WikiPortlet}).

  \textbf{getTemplateVariableGroups():} Defines the variables exposed in
  the template editor.

  As an example \texttt{*PortletDisplayTemplateHandler} implementation,
  you can look at the
  \href{https://github.com/liferay/liferay-portal/blob/7.1.3-ga4/modules/apps/wiki/wiki-web/src/main/java/com/liferay/wiki/web/internal/portlet/template/WikiPortletDisplayTemplateHandler.java}{\texttt{WikiPortletDisplayTemplateHandler}}
  class.
\item
  Since the ability to add ADTs is new to your portlet, you must
  configure permissions so that administrative users can grant
  permissions to the roles that will be allowed to create and manage
  display templates. Add the action key
  \texttt{ADD\_PORTLET\_DISPLAY\_TEMPLATE} to your portlet's
  \texttt{/src/main/resources/resource-actions/default.xml} file:

\begin{verbatim}
<?xml version="1.0"?>
<!DOCTYPE resource-action-mapping PUBLIC "-//Liferay//DTD Resource Action Mapping 7.1.0//EN" "http://www.liferay.com/dtd/liferay-resource-action-mapping_7_1_0.dtd">
<resource-action-mapping>
    ...
    <portlet-resource>
        <portlet-name>yourportlet</portlet-name>
        <permissions>
            <supports>
                <action-key>ADD_PORTLET_DISPLAY_TEMPLATE</action-key>
                <action-key>ADD_TO_PAGE</action-key>
                <action-key>CONFIGURATION</action-key>
                <action-key>VIEW</action-key>
            </supports>
            ...
        </permissions>
    </portlet-resource>
    ...
</resource-action-mapping>
\end{verbatim}
\item
  Next, you must ensure that Liferay DXP can find the updated
  \texttt{default.xml} with the new resource action when you deploy the
  module. Create a file named \texttt{portlet.properties} in the
  \texttt{/resources} folder and add the following contents providing
  the path to your \texttt{default.xml}:

\begin{verbatim}
include-and-override=portlet-ext.properties
resource.actions.configs=resource-actions/default.xml
\end{verbatim}
\item
  Now that your portlet officially supports ADTs, you should expose the
  ADT option to your users. Include the
  \texttt{\textless{}liferay-ui:ddm-template-selector\textgreater{}} tag
  in the JSP file you're using to control your portlet's configuration.

  For example, it may be helpful for you to insert an
  \texttt{\textless{}aui:fieldset\textgreater{}} in your configuration
  JSP file like this:

\begin{verbatim}
<aui:fieldset>
    <div class="display-template">
        <liferay-ddm:template-selector
            classNameId="<%= YourEntity.class.getName() %>"
            displayStyle="<%= displayStyle %>"
            displayStyleGroupId="<%= displayStyleGroupId %>"
            refreshURL="<%= PortalUtil.getCurrentURL(request) %>"
            showEmptyOption="<%= true %>"
        />
    </div>
</aui:fieldset>
\end{verbatim}

  In this JSP, the
  \texttt{\textless{}liferay-ddm:template-selector\textgreater{}} tag
  specifies the Display Template drop-down menu to be used in the
  widget's Configuration menu. The variables \texttt{displayStyle} and
  \texttt{displayStyleGroupId} are preferences that your portlet stores
  when you use this taglib and your portlet uses the
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/BaseJSPSettingsConfigurationAction.html}{BaseJSPSettingsConfigurationAction}
  or
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/DefaultConfigurationAction.html}{DefaultConfigurationAction}.
  Otherwise, you must obtain the value of those parameters and store
  them manually in your configuration class.

  As an example JSP, see the Wiki widget's
  \href{https://github.com/liferay/liferay-portal/blob/7.1.3-ga4/modules/apps/wiki/wiki-web/src/main/resources/META-INF/resources/wiki/configuration.jsp}{\texttt{configuration.jsp}}.
\item
  You must now extend your view code to render your portlet with the
  selected ADT. This lets you decide which part of your view is rendered
  by the ADT and what is available in the template context.

  First, initialize the Java variables needed for the ADT:

\begin{verbatim}
<%
String displayStyle = GetterUtil.getString(portletPreferences.getValue("displayStyle", StringPool.BLANK));
long displayStyleGroupId = GetterUtil.getLong(portletPreferences.getValue("displayStyleGroupId", null), scopeGroupId);
%>
\end{verbatim}

  Next, you can test if the ADT is configured, grabs the entities to be
  rendered, and renders them using the ADT. The tag
  \texttt{\textless{}liferay-ddm:template-renderer\textgreater{}} aids
  with this process. It automatically uses the selected template, or
  renders its body if no template is selected.

  Here's some example code that demonstrates implementing this:

\begin{verbatim}
<liferay-ddm:template-renderer
    className="<%= YourEntity.class.getName() %>"
    contextObjects="<%= contextObjects %>"
    displayStyle="<%= displayStyle %>"
    displayStyleGroupId="<%= displayStyleGroupId %>"
    entries="<%= yourEntities %>"
>

    <%-- The code that will be rendered by default when there is no
    template available should be inserted here. --%>

</liferay-ddm:template-renderer>
\end{verbatim}

  In this step, you initialized variables dealing with the display
  settings (\texttt{displayStyle} and \texttt{displayStyleGroupId}) and
  passed them to the tag along with other parameters listed below:

  \begin{itemize}
  \tightlist
  \item
    \texttt{className}: your entity's class name.
  \item
    \texttt{contextObjects}: accepts a
    \texttt{Map\textless{}String,\ Object\textgreater{}} with any object
    you want to the template context.
  \item
    \texttt{entries}: accepts a list of your entities (e.g.,
    \texttt{List\textless{}YourEntity\textgreater{}}).
  \end{itemize}

  For an example that demonstrates implementing this, see
  \href{https://github.com/liferay/liferay-portal/blob/7.1.3-ga4/modules/apps/site-navigation/site-navigation-site-map-web/src/main/resources/META-INF/resources/configuration.jsp}{\texttt{configuration.jsp}}.
\end{enumerate}

Awesome! Your portlet now supports ADTs! Once your script is uploaded
into the portal and saved, users with the specified roles can select the
template when they're configuring the display settings of your portlet
on a page. You can visit the
\href{/docs/7-1/user/-/knowledge_base/u/styling-widgets-with-application-display-templates}{Styling
Widgets with Application Display Templates} section for more details on
using ADTs.

\section{Recommendations for Using
ADTs}\label{recommendations-for-using-adts}

You've harnessed a lot of power by learning to leverage the ADT API. Be
careful, for with great power, comes great responsibility! To that end,
you'll learn about some practices you can use to optimize your portlet's
performance and security.

First let's talk about security. You may want to hide some classes or
packages from the template context, to limit the operations that ADTs
can perform on your portal. Liferay provides some portal system
settings, which can be accessed by navigating to \emph{Control Panel} →
\emph{Configuration} → \emph{System Settings} → \emph{Template Engines}
→ \emph{FreeMarker Engine}, to define the restricted classes, packages,
and variables. In particular, you may want to add
\texttt{serviceLocator} to the list of default values assigned to the
FreeMarker Engine Restricted variables.

Application Display Templates introduce additional processing tasks when
your portlet is rendered. To minimize negative effects on performance,
make your templates as minimal as possible by focusing on the
presentation, while using the existing API for complex operations. The
best way to make Application Display Templates efficient is to know your
template context well, and understand what you can use from it.
Fortunately, you don't need to memorize the context information, thanks
to Liferay's advanced template editor!

To navigate to the template editor for ADTs, go to the Site Admin menu
and select \emph{Configuration} → \emph{Application Display Templates}
and then click \emph{Add} and select the specific portlet on which you
decide to create an ADT.

The template editor provides fields, general variables, and util
variables customized for the portlet you chose. These variable
references can be found on the left-side panel of the template editor.
You can use them by simply placing your cursor where you'd like the
variable placed, and clicking the desired variable to place it there.
You can learn more about the template editor in the
\href{/docs/7-1/user/-/knowledge_base/u/styling-widgets-with-application-display-templates}{Styling
Widgets with Application Display Templates} section.

Finally, don't forget to run performance tests and tune the template
cache options by modifying the \emph{Resource modification check} field
in \emph{System Settings} → \emph{Template Engines} → \emph{FreeMarker
Engine}.

The cool thing about ADTs is the power they provide to your portlets,
providing infinite ways of editing your portlet to provide new
interfaces for your portal users. Be sure to configure your FreeMarker
templates appropriately for the most efficient customization process.

\chapter{Audience Targeting}\label{audience-targeting}

Liferay's Audience Targeting application uses defined criteria to
display content to users, who are organized into segments. You can
target content to those user segments and create campaigns to expose
user segments to a certain set of assets. Visit
\href{/docs/7-1/user/-/knowledge_base/u/targeting-content-to-your-audience}{Targeting
Content to your Audience} for more information on Audience Targeting and
how to use it.

Audience Targeting can be used to do all this without any customization,
but it also contains a framework to be extended by developers.

There are a set of extension points you can use to customize its
functionality, including

\begin{itemize}
\tightlist
\item
  Rule Types
\item
  Report Types
\item
  Report Metrics
\end{itemize}

Audience Targeting extensions are created using OSGi modules. There are
convenient Blade CLI templates for creating these projects, but you can
create the modules any way you want.

\noindent\hrulefill

\textbf{Important:} Not all Audience Targeting features function using
the embedded HSQL database, so developers must use a Liferay-supported
database to make full use of Audience Targeting features.

\noindent\hrulefill

In these tutorials, you'll learn how to create these extension points
for your Audience Targeting application.

\section{Accessing the Content Targeting
API}\label{accessing-the-content-targeting-api}

With the Content Targeting API you can integrate Audience Targeting
features with third party applications or customize how Liferay's
applications interact with Audience Targeting. For example, you could
list user segments in your own application or update a campaign when
someone creates a calendar event.

In this tutorial, you'll learn how to give your application access to
the Content Targeting API. Then you can view some examples of how to use
the Java and JSON APIs that are available.

\subsection{Exposing the Content Targeting
API}\label{exposing-the-content-targeting-api}

Configuring your app to have access to the Content Targeting API
requires only one line of code. This line of code is a dependency that
should be added to your project's build file. Follow the instructions
below to add the Content Targeting API dependency for a Gradle project.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open the \texttt{build.gradle} file in your app's project folder.
\item
  Find the \texttt{dependencies\ \{\ ...\ \}} declaration and add the
  following line within that section:

\begin{verbatim}
compileOnly group: "com.liferay.content-targeting", name: "com.liferay.content.targeting.api", version: 5.0.0"
\end{verbatim}
\end{enumerate}

Your app now has access to the Content Targeting API and can take
advantage of everything Audience Targeting has to offer. Next, you'll
learn how to use the Content Targeting API by studying a few examples.

\subsection{Using the Content Targeting Java
API}\label{using-the-content-targeting-java-api}

You can call the Content Targeting API through Java or through JSON.

To display a list of existing user segments in your portlet using Java,

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Obtain an implementation of the \texttt{UserSegmentLocalService}
  provided by Audience Targeting by adding the following code to your
  Portlet class (e.g., the class that extends the \texttt{MVCPortlet}
  class):

\begin{verbatim}
@Reference(unbind = "-")
protected void setUserSegmentLocalService(
    UserSegmentLocalService userSegmentLocalService) {

    _userSegmentLocalService = userSegmentLocalService;
}

private UserSegmentLocalService _userSegmentLocalService;
\end{verbatim}

  When the Audience Targeting application is installed and an
  implementation of the \texttt{UserSegmentLocalService} is available,
  the \texttt{\_userSegmentLocalService} field is populated. Otherwise,
  the portlet is unavailable till this dependency is resolved.
\item
  Use the service to obtain a list of existing user segments and make it
  available to your view layer as a request attribute. To do this, add
  logic to your portlet class that obtains user segments and exposes
  them in a request attribute, like this:

\begin{verbatim}
ThemeDisplay themeDisplay = (ThemeDisplay)renderRequest.getAttribute(
    WebKeys.THEME_DISPLAY);

List<UserSegment> userSegments = null;

try {
    userSegments = _userSegmentLocalService.getUserSegments(
        themeDisplay.getScopeGroupId());
}
catch (Exception e) {
    _log.error(e, e);
}

renderRequest.setAttribute("userSegments", userSegments);

private static final Log _log = LogFactoryUtil.getLog(MyPortlet.class)
\end{verbatim}

  Notice that the \texttt{userSegments} list is populated by calling
  \texttt{UserSegmentLocalService}'s \texttt{getUserSegments} method.
  This service is part of the Content Targeting API.
\item
  Add this logic to your portlet's \texttt{view.jsp}:

\begin{verbatim}
<h2>User Segments</h2>

<ul>

    <%
    List<UserSegment> userSegments = (List<UserSegment>)request.getAttribute("userSegments");

    for (UserSegment userSegment : userSegments) {
    %>
        <li><%= userSegment.getName(locale) %></li>
    <%
    }
    %>

</ul>
\end{verbatim}

  This logic uses the \texttt{UserSegment} object to list the existing
  user segments. That's it! By importing the \texttt{UserSegment} and
  \texttt{UserSegmentLocalService} classes into your files, you have
  direct access to your portal's user segments through the Content
  Targeting Java API.
\end{enumerate}

\subsection{Using the Content Targeting JSON
API}\label{using-the-content-targeting-json-api}

You could do the same thing using the JSON API.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open your portlet's \texttt{view.jsp} file and insert the following
  code:

\begin{verbatim}
<h2>Campaigns</h2>

<ul id="<portlet:namespace/>campaigns">
</ul>

<aui:script use="aui-base">
    var campaignsList = A.one('#<portlet:namespace/>campaigns');

    Liferay.Service(
        '/ct.campaign/get-campaigns',
        {
            groupId: '<%= scopeGroupId %>'
        },
        function(response) {
            if (response.length) {
                A.Array.each(response, function(item) {
                    campaignsList.append('<li>' + item.name + '</li>');
                });
            }
        }
    );
</aui:script>
\end{verbatim}

  Notice that the Content Targeting API is called to retrieve the
  existing campaigns:

\begin{verbatim}
Liferay.Service(
    '/ct.campaign/get-campaigns',
    {
\end{verbatim}

  Then, each campaign is listed in the \texttt{campaignsList} and
  displayed in your portlet for users to see.
\end{enumerate}

If you want to view all the available methods (with examples) exposed in
the JSON API by Audience Targeting, you can visit the
\texttt{/api/jsonws} URL (e.g., \texttt{localhost:8080/api/jsonws}). As
you can see, accessing the Content Targeting JSON API is just as easy as
accessing the related Java API.

You've learned how to expose the Content Targeting API and use it in
your application. Next you'll learn to create custom rule types.

\chapter{Creating New Audience Targeting Rule
Types}\label{creating-new-audience-targeting-rule-types}

In Audience Targeting, a User Segment is defined as a group of users
that match a set of rules. Out of the box, Liferay provides several
types of rules that are based on characteristics such as age range,
gender, or location. You combine these rules to create User Segments.
For example, if you want to target probable buyers of a shoe that has a
particular style, you might create a User Segment composed of Females
over 40 who live in urban areas.

Audience Targeting ships with many rules for User Segments, but it's
also extensible: if there isn't a rule that fits your case, you can
create it yourself!

Creating a rule type involves targeting what you want to evaluate.
Suppose you own an Outdoor Sporting Goods store. On your website, you
want to promote goods appropriate for the current weather. If a user is
from Los Angeles and it's raining the day he or she visits your website,
you could show that user new umbrellas. If it's sunny, however, you
could show the user sunglasses instead. For this example, your
evaluation entity would be weather based on the user's location. To make
this work, you must do two things:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Retrieve the user's location so you can obtain that location's
  weather.
\item
  Let administrators set the value to compare with the user's current
  weather, using a UI component like a selection list of weather
  options.
\end{enumerate}

With this design, an administrator can set \emph{rainy} as the value for
the rule, and the rule could be added to a user segment targeted for
rain-related goods. When users visit your site, their user segment
assignments come from matching the weather in their current locations
with the rule's preset weather value (rainy). On a match, you show
rain-related content; otherwise, the user is part of a different user
segment and sees that segment's content, like a promotion for
sunglasses.

There are four steps to create a custom rule type:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a module and ensure it has the necessary Content Targeting API
  dependencies.
\item
  Define how your rule works by implementing the
  \href{https://repository.liferay.com/nexus/service/local/artifact/maven/redirect?r=liferay-public-releases&g=com.liferay.content-targeting&a=com.liferay.content.targeting.api&v=5.0.0&e=jar&c=javadoc}{\texttt{com.liferay.content.targeting.api.model.Rule}}
  interface's methods.
\item
  Create the rule evaluation criteria.
\item
  Define the Rule's UI.
\end{enumerate}

\begin{figure}
\centering
\includegraphics{./images/weather-rule-diagram.png}
\caption{This diagram breaks down the evaluation process for the weather
rule.}
\end{figure}

Now that you have an idea of how to plan your custom rule's development,
you can create one!

\section{Creating a Custom Rule Type}\label{creating-a-custom-rule-type}

First, you must create a module and ensure it has the necessary Content
Targeting API dependencies.

\noindent\hrulefill

\textbf{Note:} To view the Javadoc for the Content Targeting classes
mentioned in this article, download the
\href{https://repository.liferay.com/nexus/service/local/artifact/maven/redirect?r=liferay-public-releases&g=com.liferay.content-targeting&a=com.liferay.content.targeting.api&v=5.0.0&e=jar&c=javadoc}{Javadoc
JAR}.

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/starting-module-development\#creating-a-module}{Create
  a module} project for deploying a rule. A Blade CLI
  \href{/docs/7-1/reference/-/knowledge_base/r/content-targeting-rule-template}{content-targeting-rule}
  template is available to help you get started quickly. It sets the
  default configuration for you, and it contains boilerplate code so you
  can skip the file creation steps and get started right away. To use
  it, use this Blade command:

\begin{verbatim}
blade create -t content-targeting-rule weather-rule
\end{verbatim}
\item
  Make sure the dependencies are up to date, as sometimes the template
  gets out of sync with the latest release. Here are the dependency
  versions you should see in a Gradle based rule:

\begin{verbatim}
dependencies {
    compileOnly group: "com.liferay.content-targeting", name: "com.liferay.content.targeting.analytics.api", version: "5.0.0"
    compileOnly group: "com.liferay.content-targeting", name: "com.liferay.content.targeting.anonymous.users.api", version: "3.0.0"
    compileOnly group: "com.liferay.content-targeting", name: "com.liferay.content.targeting.api", version: "5.0.0"
    compileOnly group: "com.liferay.portal", name: "com.liferay.portal.kernel", version: "3.6.2"
    compileOnly group: "com.liferay.portal", name: "com.liferay.util.taglib", version: "2.0.0"
    compileOnly group: "javax.portlet", name: "portlet-api", version: "3.0.0"
    compileOnly group: "javax.servlet", name: "javax.servlet-api", version: "3.0.1"
    compileOnly group: "org.osgi", name: "org.osgi.service.component.annotations", version: "1.3.0"
}
\end{verbatim}

  You can learn more about exposing the Content Targeting API in the
  \href{/docs/7-1/tutorials/-/knowledge_base/t/accessing-the-content-targeting-api}{Accessing
  the Content Targeting API} tutorial. Once you've created your module
  and specified its dependencies, you must define your rule's behavior.
  How your rule behaves is controlled by a Java class file that you
  create.
\item
  In the module's \texttt{src} directory appears a generated class. To
  follow naming conventions, your class name should begin with the rule
  name you're creating, and end with \emph{Rule} (e.g.,
  \texttt{WeatherRule.java}). Your Java class should implement the
  \href{https://repository.liferay.com/nexus/service/local/artifact/maven/redirect?r=liferay-public-releases&g=com.liferay.content-targeting&a=com.liferay.content.targeting.api&v=5.0.0&e=jar&c=javadoc}{\texttt{com.liferay.content.targeting.api.model.Rule}}
  interface.

  You must implement the \texttt{Rule} interface, but there are
  \texttt{Rule} extension classes that provide helpful utilities that
  you can extend. For example, your rule can extend the
  \href{https://repository.liferay.com/nexus/service/local/artifact/maven/redirect?r=liferay-public-releases&g=com.liferay.content-targeting&a=com.liferay.content.targeting.api&v=5.0.0&e=jar&c=javadoc}{\texttt{com.liferay.content.targeting.api.model.BaseJSPRule}}
  class to support generating your rule's UI using JSPs. This tutorial
  demonstrates implementing the UI using a JSP and assumes the
  \texttt{Rule} interface is implemented by extending the
  \texttt{BaseJSPRule} class. For more information on choosing a UI for
  your rule, see
  \href{/develop/tutorial/-/knowledge_base/7-1/best-practices-for-audience-targeting\#selecting-a-ui-technology}{Selecting
  a UI Technology}.
\item
  Directly above the class's declaration should be the following
  annotation:

\begin{verbatim}
@Component(immediate = true, service = Rule.class)
\end{verbatim}

  This annotation declares the implementation class of the Component,
  and specifies to start the module immediately once deployed to Liferay
  DXP.
\end{enumerate}

Now that your Java class is set up, you must define how your rule works
by implementing the \texttt{Rule} interface's methods. You'll begin
implementing these methods next.

\noindent\hrulefill

\textbf{Note:} If you're planning on developing a social rule type that
classifies users based on their social network profile, remember that
the specific social network's SSO (Single Sign On) must be enabled and
configured properly. Visit the
\href{/docs/7-1/user/-/knowledge_base/u/liferay-audience-targeting-rules\#social-rules}{Social
Rules} section for more details.

\noindent\hrulefill

Next you'll define the view/save lifecycle for the weather rule.

\section{Defining a Rule's View/Save
Lifecycle}\label{defining-a-rules-viewsave-lifecycle}

The view/save lifecycle describes the process behind the scenes when an
administrator applies a rule to a user segment using the User Segment
Editor. You'll implement that now.

When the user opens the User Segment Editor, the render phase begins for
the rule creation. During the render phase, the HTML for the form is
generated and, if necessary, the \texttt{context} map is generated with
any parameters that you need to create the form. Once the HTML is
successfully retrieved and the user has set the values and clicked
\emph{Save}, the action phase begins.

When the action phase begins, the \texttt{processRule(...)} method takes
the values provided by the form and persists them. Once the rule
processing ends, the form is reloaded and the lifecycle restarts again.
The value(s) selected in the rule are stored and are ready to be
accessed once user segment evaluation begins.

In this section, you'll begin defining the weather rule's Java class.
This assumes that you followed the instructions in the previous
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-a-custom-rule-type}{tutorial},
creating the \texttt{WeatherRule} class and extending
\texttt{com.liferay.content.targeting.api.model.BaseJSPRule}.

\noindent\hrulefill

\textbf{Note:} To view the Javadoc for the Content Targeting classes
mentioned in this article, download the
\href{https://repository.liferay.com/nexus/service/local/artifact/maven/redirect?r=liferay-public-releases&g=com.liferay.content-targeting&a=com.liferay.content.targeting.api&v=5.0.0&e=jar&c=javadoc}{Javadoc
JAR}.

\noindent\hrulefill

If you used the \texttt{content-targeting-rule} Blade CLI template, your
project already extends \texttt{BaseJSPRule} and has a default
\texttt{view.jsp} file already created.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  If you didn't use the template, add the activation and deactivation
  methods to your class.

\begin{verbatim}
@Activate
@Override
public void activate() {
    super.activate();
}

@Deactivate
@Override
public void deActivate() {
    super.deActivate();
}
\end{verbatim}

  These methods call the super class
  \href{https://repository.liferay.com/nexus/service/local/artifact/maven/redirect?r=liferay-public-releases&g=com.liferay.content-targeting&a=com.liferay.content.targeting.api&v=5.0.0&e=jar&c=javadoc}{\texttt{com.liferay.content.targeting.api.model.BaseRule}}
  to implement necessary logging and processing for when your rule
  starts and stops. Make sure to include the
  \href{https://osgi.org/javadoc/r6/cmpn/org/osgi/service/component/annotations/Activate.html}{@Activate}
  and
  \href{https://osgi.org/javadoc/r6/cmpn/org/osgi/service/component/annotations/Deactivate.html}{@Deactivate}
  annotations, which are required.
\item
  Define the category for the Rule when displayed in the User Segment
  Editor. Find the \texttt{getRuleCategoryKey()} method and replace it
  with the code below:

\begin{verbatim}
@Override
public String getRuleCategoryKey() {
    return SessionAttributesRuleCategory.KEY;
}
\end{verbatim}

  This code puts the weather rule in the Session Attributes category. To
  put your rule into the appropriate category, use the
  \texttt{getRuleCategoryKey} method to return the category class's key.
  Available category classes include
  \href{https://repository.liferay.com/nexus/service/local/artifact/maven/redirect?r=liferay-public-releases&g=com.liferay.content-targeting&a=com.liferay.content.targeting.api&v=5.0.0&e=jar&c=javadoc}{\texttt{com.liferay.content.targeting.rule.categories.BehaviourRuleCategory}},
  \href{https://repository.liferay.com/nexus/service/local/artifact/maven/redirect?r=liferay-public-releases&g=com.liferay.content-targeting&a=com.liferay.content.targeting.api&v=5.0.0&e=jar&c=javadoc}{\texttt{com.liferay.content.targeting.rule.categories.SessionAttributesRuleCategory}},
  \href{https://repository.liferay.com/nexus/service/local/artifact/maven/redirect?r=liferay-public-releases&g=com.liferay.content-targeting&a=com.liferay.content.targeting.api&v=5.0.0&e=jar&c=javadoc}{\texttt{com.liferay.content.targeting.rule.categories.SocialRuleCategory}},
  and
  \href{https://repository.liferay.com/nexus/service/local/artifact/maven/redirect?r=liferay-public-releases&g=com.liferay.content-targeting&a=com.liferay.content.targeting.api&v=5.0.0&e=jar&c=javadoc}{\texttt{com.liferay.content.targeting.rule.categories.UserAttributesRoleCategory}}.

  \begin{figure}
  \centering
  \includegraphics{./images/new-category-rule.png}
  \caption{This example Weather rule was modified to reside in the
  Session Attributes category.}
  \end{figure}
\item
  Find the \texttt{populateContext()} method and replace it with the
  code below:

\begin{verbatim}
@Override
protected void populateContext(
    RuleInstance ruleInstance, Map<String, Object> context,
    Map<String, String> values) {

    String weather = "";

    if (!values.isEmpty()) {
        weather = GetterUtil.getString(values.get("weather"));
    }
    else if (ruleInstance != null) {
        weather = ruleInstance.getTypeSettings();
    }

    context.put("weather", weather);
}
\end{verbatim}

  To understand what this method accomplishes, you must examine the
  rule's configuration lifecycle.

  \begin{figure}
  \centering
  \includegraphics{./images/rule-lifecycle.png}
  \caption{An Audience Targeting rule must be configured by the user and
  processed before it can become part of a User Segment.}
  \end{figure}

  When the user opens the User Segment Editor, the render phase begins
  for the rule. The \texttt{getFormHTML(...)} method retrieves the HTML
  to display. You don't have to worry about implementing this method
  because it's already implemented in the \texttt{BaseJSPRule} class
  you're extending. The \texttt{getFormHTML} method calls the
  \texttt{populateContext(...)} method.

  You'll notice the \texttt{populateContext} method is not available in
  the
  \href{https://repository.liferay.com/nexus/service/local/artifact/maven/redirect?r=liferay-public-releases&g=com.liferay.content-targeting&a=com.liferay.content.targeting.api&v=5.0.0&e=jar&c=javadoc}{\texttt{com.liferay.content.targeting.api.model.Rule}}
  interface. This is because it's not needed in all cases. It's
  available by extending the \texttt{BaseJSPRule} class, and it needs
  more logic for the weather rule.

  The \texttt{populateContext} method generates a map with all the
  parameters your JSP view needs to render the rule's HTML. This map is
  stored in the \texttt{context} variable. This variable is a map
  defining the form evaluation context for Audience Targeting rules.
  Each rule contributes its specific parameters to it. The
  \texttt{populateContext} method above populates a \texttt{weather}
  context variable with the \texttt{weather} values from the
  \texttt{values} map parameter, which is then passed to the JSP.

  For the weather rule, the \texttt{populateContext} method accounts for
  three use cases:

  \begin{enumerate}
  \def\labelenumii{\alph{enumii}.}
  \item
    The rule was added but has no set values yet. In this case, the
    default values defined by the developer are injected (e.g.,
    \texttt{weather=""}).
  \item
    The rule was added and a value is set, but the request failed to
    complete (e.g., due to an error). In this case, the \texttt{values}
    parameter of the \texttt{populateContext} method contains the values
    that were intended to be saved, and they are injected so that they
    are displayed in the rule's view together with the error message.
  \item
    The rule was added and a value was successfully set. In this case,
    the \texttt{values} parameter is empty, and you must obtain the
    values that the form should display from storage and inject them in
    the context so they appear in the rule's HTML. The weather rule uses
    the \texttt{typeSettings} field of the rule instance, but complex
    rules could use services to store values.
  \end{enumerate}

  You can think of the \texttt{populateContext} method as the
  intermediary between your JSP and your back-end code. Creating the
  weather rule's UI using a JSP is covered in
  \href{/docs/7-1/tutorials/-/knowledge_base/t/defining-the-rules-ui}{Defining
  the Rule's UI}. Once the HTML is successfully retrieved and the user
  has set the weather value and clicked \emph{Save}, the action phase
  begins.
\item
  Replace the \texttt{processRule()} method with this code:

\begin{verbatim}
@Override
public String processRule(
    PortletRequest portletRequest, PortletResponse portletResponse,
    String id, Map<String, String> values) {

    return values.get("weather");
}
\end{verbatim}

  The \texttt{processRule(...)} method is invoked when the action phase
  is initiated. The \texttt{values} parameter only contains the value(s)
  the user added in the form. The logic you could add to a
  \texttt{processRule} method is outlined below.

  \begin{enumerate}
  \def\labelenumii{\alph{enumii}.}
  \item
    Obtain the value(s) from the \texttt{values} parameter.
  \item
    (Optional) Validate the data consistency and possible errors. If
    anything is wrong, throw an
    \href{https://repository.liferay.com/nexus/service/local/artifact/maven/redirect?r=liferay-public-releases&g=com.liferay.content-targeting&a=com.liferay.content.targeting.api&v=5.0.0&e=jar&c=javadoc}{\texttt{com.liferay.content.targeting.exception.InvalidRuleException}}
    and prohibit the values from being stored. In the weather rule
    scenario, when the rule is reloaded after an exception is thrown in
    the form, case 3b from the previous step occurs.
  \item
    Return the value to be stored in the rule instance's
    \texttt{typeSettings} field. The \texttt{typeSettings} field is
    managed by the framework in the Rule Instance table. If your rule
    has its own storage mechanism, then you should call your services in
    the \texttt{processRule} method.
  \end{enumerate}

  Once the rule processing ends, the form is reloaded and the lifecycle
  restarts again. The value(s) selected in the rule are stored and are
  ready to be accessed once user segment evaluation begins. You must add
  two more methods to the \texttt{WeatherRule} class before defining the
  rule's evaluation.
\item
  Define a way to retrieve the rule's localized summary. In many
  instances, you can do this by combining keys in the rule's resource
  bundle with the information stored for the rule. For the weather rule,
  you can return the rule's type settings, which contains the selected
  weather condition. Replace the generated \texttt{getSummary()} method
  with this one:

\begin{verbatim}
@Override
public String getSummary(RuleInstance ruleInstance, Locale locale) {
    return ruleInstance.getTypeSettings();
}
\end{verbatim}
\item
  Set the servlet context for your rule. This method was generated and
  can be left alone:

\begin{verbatim}
@Override
@Reference(
    target = "(osgi.web.symbolicname=weather)",
    unbind = "-"
)
public void setServletContext(ServletContext servletContext) {
    super.setServletContext(servletContext);
}
\end{verbatim}

  Setting the servlet context is only required for rules extending the
  \texttt{BaseJSPRule} class. The servlet context must be set for the
  rule to render its own JSP files. The \texttt{setServletContext}
  method is invoked automatically when the rule module is installed and
  resolved in Liferay. Make sure the \texttt{osgi.web.symbolicname} in
  the \texttt{target} property of the \texttt{@Reference} annotation is
  set to the same value as the \texttt{Bundle-SymbolicName} defined in
  the \texttt{bnd.bnd} file of the module.
\end{enumerate}

Next, you'll learn how to evaluate a rule that is configured and saved
to a user segment.

\section{Evaluating a Rule}\label{evaluating-a-rule}

After the administrator has successfully configured and saved your
custom rule to his or her user segment, your rule needs to fulfill its
purpose: to evaluate the preset weather value compared to a user's
weather value visiting the site. If the user's value matches the preset
value (along with the segment's other rules), that user is added to the
user segment.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  You must implement the \texttt{evaluate(...)} rule to begin the
  evaluation process. This method is part of the user segmentation
  lifecycle. When a page is loaded, Liferay invokes the
  \texttt{evaluate} method of the rule to determine if the current user
  belongs to the user segment. For the weather rule, add this
  \texttt{evaluate} method:

\begin{verbatim}
@Override
public boolean evaluate(
        HttpServletRequest request, RuleInstance ruleInstance,
        AnonymousUser anonymousUser)
    throws Exception {

    String userWeather = getUserWeather(anonymousUser);

    String weather = ruleInstance.getTypeSettings();

    if (Validator.equals(userWeather, weather)) {
            return true;
    }

    return false;
}
\end{verbatim}

  You acquire the user's weather by calling the \texttt{getUserWeather}
  method, which you'll define later. Then you get the preset weather
  value by accessing the rule instance's \texttt{typeSettings}
  parameter. Finally, you compare the two values. If they match, return
  \texttt{true}; otherwise return \texttt{false}. Remember that users
  are only added to User Segments when all the Rules in the User Segment
  return true.
\item
  Next, you need to retrieve the user's weather. As you learned earlier,
  you must access the user's location first. Add the logic below to do
  this.

\begin{verbatim}
protected String getCityFromUserProfile(long contactId, long companyId)
    throws PortalException, SystemException {

    List<Address> addresses = AddressLocalServiceUtil.getAddresses(companyId, Contact.class.getName(), contactId);

    if (addresses.isEmpty()) {
        return null;
    }

    Address address = addresses.get(0);

    return address.getCity() + StringPool.COMMA + address.getCountry().getA2();
}
\end{verbatim}

  This method retrieves the location by accessing the user's profile
  information. You could also have used a geo-location service to find
  this by the user's IP address. Once you have the user's location, you
  can find the current weather for that location.
\item
  Add the following method to retrieve a user's weather forecast.

\begin{verbatim}
protected String getUserWeather(AnonymousUser anonymousUser)
    throws PortalException, SystemException {

    User user = anonymousUser.getUser();

    String city = getCityFromUserProfile(user.getContactId(), user.getCompanyId());

    Http.Options options = new Http.Options();

    String location = HttpUtil.addParameter(API_URL, "q", city);
    location = HttpUtil.addParameter(location, "format", "json");

    options.setLocation(location);

    int weatherCode = 0;

    try {
        String text = HttpUtil.URLtoString(options);

        JSONObject jsonObject = JSONFactoryUtil.createJSONObject(text);

        weatherCode = jsonObject.getJSONArray("weather").getJSONObject(0).getInt("id");
    }
    catch (Exception e) {
        _log.error(e);
    }

    return getWeatherFromCode(weatherCode);
}

private static Log _log = LogFactoryUtil.getLog(WeatherRule.class);
\end{verbatim}

  This method calls the \texttt{getCityFromUserProfile} method to
  acquire the user's location. Then it retrieves the weather code for
  that location from a weather service.
\item
  Set the \texttt{API\_URL} field to the Open Weather Map's API URL:

\begin{verbatim}
private static final String API_URL = "http://api.openweathermap.org/data/2.5/weather";
\end{verbatim}

  For the weather rule, you can access Open Weather Map's APIs to
  retrieve the weather code.
\item
  The last thing is to convert the weather code to a string you can
  evaluate (e.g., \texttt{sunny}). Add the following method to convert
  Open Weather Map's weather codes:

\begin{verbatim}
protected String getWeatherFromCode(int code) {
    if (code == 800 || code == 801) {
        return "sunny";
    }
    else if (code > 801 && code < 805) {
        return "clouds";
    }
    else if (code >= 600 && code < 622) {
        return "snow";
    }
    else if (code >= 500 && code < 532) {
        return "rain";
    }

    return null;
}
\end{verbatim}

  All possible weather codes are
  \href{http://openweathermap.org/weather-conditions}{here}.
\end{enumerate}

Excellent! You've implemented the \texttt{evaluate} method and added the
necessary logic in your \texttt{-Rule} class to acquire a user's local
weather. The weather rule's behavior is defined and complete. The last
thing you need to do is create a JSP template.

\section{Defining the Rule's UI}\label{defining-the-rules-ui}

The Java code you've added to this point has assumed that a preset
weather value is available for comparing during the evaluation process.
To let administrators set that value, you must define a UI so your rule
can be configured during the view/save lifecycle. Create a
\texttt{view.jsp} file in your rule's module (e.g.,
\texttt{/src/main/resources/META-INF/resources/view.jsp}) and add the
following logic:

\begin{verbatim}
<%
Map<String, Object> context = (Map<String, Object>)request.getAttribute("context");

String weather = (String)context.get("weather");
%>

<aui:fieldset>
    <aui:select name="weather" value="<%= weather %>">
        <aui:option label="sunny" value="sunny" />
        <aui:option label="clouds" value="clouds" />
        <aui:option label="snow" value="snow" />
        <aui:option label="rain" value="rain" />
    </aui:select>
</aui:fieldset>
\end{verbatim}

The \texttt{weather} variable in the \texttt{context} map should be set
for the weather rule. When the user selects an option, it's passed from
the view template to the \texttt{populateContext} method.

\begin{figure}
\centering
\includegraphics{./images/select-box-rule.png}
\caption{The weather rule uses a \texttt{select} drop-down box to set
the weather value.}
\end{figure}

\noindent\hrulefill

\textbf{Note:} The weather rule uses JSP templates to display the rule's
view. Audience Targeting, however, is compatible with any UI technology.
Visit the
\href{/develop/tutorial/-/knowledge_base/7-1/best-practices-for-audience-targeting\#selecting-a-ui-technology}{Selecting
a UI Technology} section for details on how to use other UI technologies
like FreeMarker.

\noindent\hrulefill

You've created the weather rule and can now target users based on their
weather conditions. You can view the finished version of the weather
rule by downloading its
\href{https://portal.liferay.dev/documents/113763090/114000653/weather-7-1.zip/c1865f26-c4df-f4fa-a012-459e23d3b3c8?t=1565967914487}{ZIP
file}.

Now you've created and examined a fully functional rule and have the
knowledge to create your own.

\chapter{Tracking User Actions with Audience
Targeting}\label{tracking-user-actions-with-audience-targeting}

In Audience Targeting, a campaign defines a set of content targeted to
specific user segments during a time period. Reports allow campaign
administrators to learn how users behave in the context of a campaign by
monitoring their interaction over different elements of the site. Out of
the box, Liferay provides several metrics based on entity types that you
can track, such as content, forms, links, pages, etc. For example, if
you want track how many users watch a YouTube video that is published on
your site, you might create a custom report with the YouTube Videos
metric.

Audience Targeting ships with many metrics, but it's also extensible.
This means that if the default metrics available do not fulfill your
needs, you can create one yourself.

First you need to define some criteria about your metric:

\begin{itemize}
\tightlist
\item
  Entity to Track
\item
  Tracking Mechanism
\item
  Tracking Events
\item
  Differentiation Method
\end{itemize}

Creating a metric involves targeting what you want to track in a report.
Suppose you're the owner of a hardware store and you want to send emails
to your customers with the store's weekly newsletter. You send the email
every week, but you're in the dark about how many customers actually
open and read the newsletter. For this example, your entity to track is
the newsletter.

To track how many customers view the newsletter, you must create a
tracking mechanism. You can provide a custom tracking mechanism (e.g., a
servlet) or you can use the ones provided by Audience Targeting. For a
newsletter, you could use a transparent image as the tracking mechanism,
which would have the \emph{View} tracking event capability. Whenever the
image is viewed, the Audience Targeting app computes and stores the
information.

Finally, you must assign the metric to an entity. For a newsletter, you
could provide a Newsletter ID field that the user could fill in to
differentiate newsletters, if there's more than one.

To learn more about how metrics are used in the Audience Targeting
application, visit the
\href{https://dev.liferay.com/discover/portal/-/knowledge_base/7-1/managing-campaigns\#defining-metrics}{Defining
Metrics} section.

For this tutorial, you'll create a newsletter that can track who views
it. To do this you will,

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a module with the necessary Content Targeting API dependencies.
\item
  Define the metric's View/Save lifecycle.
\item
  Implement a tracking mechanism and differentiation method.
\item
  Define the UI.
\end{enumerate}

\begin{figure}
\centering
\includegraphics{./images/metric-template.png}
\caption{The sample Newsletter metric requires the newsletter name, ID,
and event type.}
\end{figure}

Now that you have an idea of how to plan your new metric, you'll begin
creating one next!

\section{Related Topics}\label{related-topics-319}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-projects-with-blade-cli}{Creating
Projects with Blade CLI}

\href{/docs/7-1/user/-/knowledge_base/u/defining-a-metrics-view-save-lifecycle}{Defining
a Metric's View/Save Lifecycle}

\href{/docs/7-1/user/-/knowledge_base/u/defining-the-metrics-ui}{Defining
the Metric's UI}

\section{Creating a Metric}\label{creating-a-metric}

Now that all of your criteria has been defined, you can get started
developing the actual metric:

\noindent\hrulefill

\textbf{Note:} To view the Javadoc for the Content Targeting classes
mentioned in this article, download the
\href{https://repository.liferay.com/nexus/service/local/artifact/maven/redirect?r=liferay-public-releases&g=com.liferay.content-targeting&a=com.liferay.content.targeting.api&v=5.0.0&e=jar&c=javadoc}{Javadoc
JAR}.

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/starting-module-development\#creating-a-module}{Create
  a module} project for deploying a metric. A Blade CLI
  \href{/docs/7-1/reference/-/knowledge_base/r/content-targeting-tracking-action-template}{content-targeting-tracking-action}
  template is available to help you get started quickly. It sets the
  default configuration for you, and it contains boilerplate code so you
  can skip the file creation steps and get started right away.
\item
  Make sure your module specifies the dependencies necessary for an
  Audience Targeting metric. For example, you should specify the Content
  Targeting API and necessary Liferay packages. For example, this is the
  example \texttt{build.gradle} file used from a Gradle based metric:

\begin{verbatim}
dependencies {
    compileOnly group: "com.liferay.content-targeting", name: "com.liferay.content.targeting.analytics.api", version: "5.0.0"
    compileOnly group: "com.liferay.content-targeting", name: "com.liferay.content.targeting.anonymous.users.api", version: "3.0.0"
    compileOnly group: "com.liferay.content-targeting", name: "com.liferay.content.targeting.api", version: "5.0.0"
    compileOnly group: "com.liferay.portal", name: "com.liferay.portal.kernel", version: "3.6.2"
    compileOnly group: "com.liferay.portal", name: "com.liferay.util.taglib", version: "2.0.0"
    compileOnly group: "javax.portlet", name: "portlet-api", version: "3.0.0"
    compileOnly group: "javax.servlet", name: "javax.servlet-api", version: "3.0.1"
    compileOnly group: "org.osgi", name: "org.osgi.service.component.annotations", version: "1.3.0"
}
\end{verbatim}

  You can learn more about exposing the Content Targeting API in the
  \href{/docs/7-1/tutorials/-/knowledge_base/t/accessing-the-content-targeting-api}{Accessing
  the Content Targeting API} tutorial. Once you've created your module
  and specified its dependencies, you'll need to define your metric's
  behavior. How your metric behaves is controlled by a Java class file
  that you create.
\item
  Create a unique package name in the module's \texttt{src} directory,
  and create a new Java class in that package. To follow naming
  conventions, your class name should begin with the metric's name
  you're creating and end with \emph{TrackingAction} (e.g.,
  \texttt{NewsletterTrackingAction.java}). Your Java class should
  implement the
  \texttt{com.liferay.content.targeting.api.model.TrackingAction}
  interface.

  You must implement the \texttt{TrackingAction} interface, but there
  are \texttt{TrackingAction} extension classes that provide helpful
  utilities that you can extend. For example, your metric can extend the
  \texttt{BaseJSPTrackingAction} class to support generating your
  metric's UI using JSPs. This tutorial demonstrates implementing the UI
  using a JSP and assumes the \texttt{TrackingAction} interface is
  implemented by extending the \texttt{BaseJSPTrackingAction} class. For
  more information on choosing a UI for your metric, see the
  \href{/develop/tutorial/-/knowledge_base/7-1/best-practices-for-audience-targeting\#selecting-a-ui-technology}{Selecting
  a UI Technology} section.
\item
  Directly above the class's declaration, insert the following
  annotation:

\begin{verbatim}
@Component(immediate = true, service = TrackingAction.class)
\end{verbatim}

  This declares the Component's implementation class and configures it
  to start immediately once deployed to Liferay DXP.
\end{enumerate}

Now that your Java class is set up, you must define how your metric
works by implementing the \texttt{TrackingAction} interface's methods.
You'll begin implementing these methods next.

\section{Defining a Metric's View/Save
Lifecycle}\label{defining-a-metrics-viewsave-lifecycle}

In this section, you will define the metric's view/save lifecycle: what
happens when a user applies a metric to a report using the Report
Editor.

\noindent\hrulefill

\textbf{Note:} To view the Javadoc for the Content Targeting classes
mentioned in this article, download the
\href{https://repository.liferay.com/nexus/service/local/artifact/maven/redirect?r=liferay-public-releases&g=com.liferay.content-targeting&a=com.liferay.content.targeting.api&v=5.0.0&e=jar&c=javadoc}{Javadoc
JAR}.

\noindent\hrulefill

You'll begin defining the newsletter metric's Java class. This assumes
that you followed the instructions in the previous article to create the
\texttt{NewsletterTrackingAction} class and extend
\texttt{com.liferay.content.targeting.api.model.BaseJSPTrackingAction}.
If you used the \texttt{content-targeting-tracking-action} Blade CLI
template, your project is already extending
\texttt{BaseJSPTrackingAction} and a default \texttt{view.jsp} file is
already created.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add the activation and deactivation methods to your class.

\begin{verbatim}
@Activate
@Override
public void activate() {
    super.activate();
}

@Deactivate
@Override
public void deActivate() {
    super.deActivate();
}
\end{verbatim}

  These methods call the super class
  \texttt{com.liferay.content.targeting.api.model.BaseTrackingAction} to
  implement necessary logging and processing for when your metric starts
  and stops. Make sure to include the
  \href{https://osgi.org/javadoc/r6/cmpn/org/osgi/service/component/annotations/Activate.html}{@Activate}
  and
  \href{https://osgi.org/javadoc/r6/cmpn/org/osgi/service/component/annotations/Deactivate.html}{@Deactivate}
  annotations, which are required.
\item
  Add the following method:

\begin{verbatim}
@Override
protected void populateContext(
    TrackingActionInstance trackingActionInstance,
    Map<String, Object> context, Map<String, String> values) {

    String alias = StringPool.BLANK;
    String elementId = StringPool.BLANK;
    String eventType = StringPool.BLANK;

    if (!values.isEmpty()) {
        alias = values.get("alias");
        elementId = values.get("elementId");
        eventType = values.get("eventType");
    }
    else if (trackingActionInstance != null) {
        alias = trackingActionInstance.getAlias();
        elementId = trackingActionInstance.getElementId();
        eventType = trackingActionInstance.getEventType();
    }

    context.put("alias", alias);
    context.put("elementId", elementId);
    context.put("eventType", eventType);
    context.put("eventTypes", getEventTypes());
}
\end{verbatim}

  To understand what this method accomplishes, you should look at the
  metric's configuration lifecycle.

  \begin{figure}
  \centering
  \includegraphics{./images/metric-lifecycle.png}
  \caption{An Audience Targeting metric must be configured by the user
  and processed before it can become part of a Report.}
  \end{figure}

  When the user opens the Report Editor, the render phase begins for the
  metric. The \texttt{getFormHTML(...)} method retrieves the HTML to
  display. You don't have to worry about implementing this method
  because it's already implemented in the \texttt{BaseJSPTrackingAction}
  class you're extending. The \texttt{getFormHTML} method calls the
  \texttt{populateContext(...)} method.

  You'll notice the \texttt{populateContext} method is not available in
  the \texttt{TrackingAction} interface. This is because it's not needed
  in all cases. It's available by extending the
  \texttt{BaseJSPTrackingAction} class, and you'll need to add more
  logic to it for the newsletter metric.

  The \texttt{populateContext} method generates a map with all the
  parameters your JSP view needs to render the metric's HTML. This map
  is stored in the \texttt{context} variable, which is pre-populated
  with basic values in the Portlet logic, and then each metric
  contributes its specific parameters to it. The
  \texttt{populateContext} method above populates the \texttt{alias},
  \texttt{elementId}, \texttt{eventType}, and \texttt{eventTypes}
  context variables with the adjacent values from the \texttt{values}
  map parameter, which is then passed to the JSP.

  For the newsletter metric, the \texttt{populateContext} method
  accounts for three use cases:

  \begin{enumerate}
  \def\labelenumii{\alph{enumii}.}
  \item
    The metric was added but has no set values yet. In this case, the
    default values defined by the developer are injected (e.g.,
    \texttt{alias=""}).
  \item
    The metric was added and a value is set, but the request failed to
    complete (e.g., due to an error). In this case, the \texttt{values}
    parameter of the \texttt{populateContext} method contains the values
    that were intended to be saved, and they are injected so that they
    are displayed in the metric's view together with the error message.
  \item
    The metric was added and a value was successfully set. In this case,
    the \texttt{values} parameter is empty, and you have to obtain the
    values from storage that the form should display and inject them in
    the context so they're displayed in the metric's HTML. The
    newsletter metric stores values in the metric's instance, but
    complex metrics could use services to store values.
  \end{enumerate}

  You can think of the \texttt{populateContext} method as the
  intermediary between your JSP and your backend code. You can see how
  to create the newsletter metric's UI using a JSP by skipping to the
  \href{/docs/7-1/tutorials/-/knowledge_base/t/defining-the-metrics-ui}{Defining
  the Metric's UI} section. Once the HTML is successfully retrieved and
  the user has set the newsletter's values and clicked \emph{Save}, the
  action phase begins.
\item
  Once the action phase begins, Audience Targeting processes the
  tracking action (metric). The \texttt{processTrackingAction(...)}
  method takes the values from the
  \href{/docs/7-1/tutorials/-/knowledge_base/t/defining-the-metrics-ui}{metric's
  UI form} and stores them in the corresponding fields of the
  \texttt{trackingActionInstance}. Since the \texttt{BaseTrackingAction}
  class provides a default implementation of this method that returns
  \texttt{null}, the \texttt{NewsletterTrackingAction} class does not
  need to implement it.

  If you need to process any custom fields in your metric, you should
  override this method. If you want your custom values to be stored in
  the \texttt{typeSettings} field of the
  \texttt{trackingActionInstance}, return their value instead of
  \texttt{null}.
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** For more complex cases, you can create your own services to store
 your metric's information to a database. You should invoke your services'
 update logic within the `processTrackingAction` method. For more information
 on creating services, see the
 [Service Builder](/docs/7-1/tutorials/-/knowledge_base/t/service-builder)
 tutorials.
\end{verbatim}

\noindent\hrulefill

\begin{verbatim}
Once the metric processing ends, the form is reloaded and the lifecycle
restarts again. The value(s) specified in the metric are stored and are
ready to be accessed once the report generation begins. Next, you must set
the event types that the newsletter metric should evaluate.
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{3}
\item
  Add the following method and private field:

\begin{verbatim}
@Override
public List<String> getEventTypes() {
    return ListUtil.fromArray(_EVENT_TYPES);
}

private static final String[] _EVENT_TYPES = {"view"};
\end{verbatim}

  This specifies that your newsletter metric only tracks who views the
  newsletter.
\item
  Define a way to retrieve the metric's localized summary. In many
  instances, you can do this by combining keys in the metric's resource
  bundle with the information stored for the metric. For the newsletter
  metric, you can provide information about the ID of the newsletter
  being tracked, which is stored in the \texttt{alias} field of the
  \texttt{trackingActionInstance} object.

\begin{verbatim}
@Override
public String getSummary(
    TrackingActionInstance trackingActionInstance, Locale locale) {

    return LanguageUtil.get(
        locale, trackingActionInstance.getTypeSettings());
}
\end{verbatim}
\item
  Set the servlet context for your metric.

\begin{verbatim}
@Override
@Reference(
    target = "(osgi.web.symbolicname=newsletter)",
    unbind = "-"
)
public void setServletContext(ServletContext servletContext) {
    super.setServletContext(servletContext);
}
\end{verbatim}

  This is only required for metrics extending the
  \texttt{BaseJSPTrackingAction} class. The servlet context must be set
  for the metric to render its own JSP files. The
  \texttt{setServletContext} method is invoked automatically when the
  metric module is installed and resolved in Liferay. Make sure the
  \texttt{osgi.web.symbolicname} in the \texttt{target} property of the
  \texttt{@Reference} annotation is set to the same value as the
  \texttt{Bundle-SymbolicName} defined in the \texttt{bnd.bnd} file of
  the module.
\end{enumerate}

Next, you'll define a tracking mechanism for your metric to use.

\section{Using a Tracking Mechanism}\label{using-a-tracking-mechanism}

An administrator has successfully configured and saved your custom
metric to his or her report. Now what? Your metric needs to fulfill its
purpose, which is to track the \texttt{view} event type for the defined
newsletter. To do this, you must define a tracking mechanism. For your
newsletter, you'll use a transparent image as the tracking mechanism,
which would have the \emph{View} tracking event capability. Whenever the
image is viewed, the newsletter metric computes and stores the
information.

For the newsletter metric, you'll use a tracking mechanism provided by
the Audience Targeting app.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Set the analytics processor that the Content Targeting API provides
  for tracking events. Add the following method and private field:

\begin{verbatim}
@Reference
protected void setAnalyticsProcessor(AnalyticsProcessor analyticsProcessor) {
    _analyticsProcessor = analyticsProcessor;
}

private AnalyticsProcessor _analyticsProcessor;
\end{verbatim}

  The analytics processor contains a servlet to track analytics from
  Liferay pages (views, clicks, etc.) and an API to leverage this
  tracking mechanism. In the \texttt{setAnalyticsProcesoor(...)} method,
  you're obtaining a reference of the current analytics processor to
  build the URL used to generate a transparent image. All you have to do
  is insert the generated URL into your newsletter's HTML, and the
  transparent image tracks who reads it. Everything is processed by the
  default Audience Targeting Analytics system automatically.

  Now that you've obtained a reference of the analytics processor, you
  need to add logic for generating the appropriate tracking URL.
\item
  Replace the \texttt{populateContext} method with the updated method:

\begin{verbatim}
@Override
protected void populateContext(
    TrackingActionInstance trackingActionInstance,
    Map<String, Object> context, Map<String, String> values) {

    String alias = StringPool.BLANK;
    String elementId = StringPool.BLANK;
    String eventType = StringPool.BLANK;
    String trackImageHTML = StringPool.BLANK;

    if (!values.isEmpty()) {
        alias = values.get("alias");
        elementId = values.get("elementId");
        eventType = values.get("eventType");
    }
    else if (trackingActionInstance != null) {
        alias = trackingActionInstance.getAlias();
        elementId = trackingActionInstance.getElementId();
        eventType = trackingActionInstance.getEventType();

        String trackImageURL = _analyticsProcessor.getTrackingURL(
            trackingActionInstance.getCompanyId(), 0, 0, "", 0,
            Campaign.class.getName(),
            new long[] {trackingActionInstance.getCampaignId()},
            trackingActionInstance.getElementId(), "view", "");

        trackImageHTML = "<img alt=\"\" src=\"" + trackImageURL + "\" />";
    }

    context.put("alias", alias);
    context.put("elementId", elementId);
    context.put("eventType", eventType);
    context.put("eventTypes", getEventTypes());
    context.put("trackImageHTML", trackImageHTML);
}
\end{verbatim}

  This updated method creates a new variable named
  \texttt{trackImageHTML}, retrieves a tracking URL using the analytics
  processor, and then populates the \texttt{trackImageHTML} context
  variable. When creating a new metric, the transparent image's URL
  field is not present in the metric's form. When the metric is
  initially saved, however, the URL is generated using the analytics
  processor and is available for copying.
\end{enumerate}

Excellent! You've obtained the analytics processor and can create the
transparent image tracking mechanism. The newsletter metric's behavior
is defined and complete. The last thing you need to do is create a JSP
template.

\section{Defining the Metric's UI}\label{defining-the-metrics-ui}

The Java code you've added to this point has assumed that there are
three configurable fields for your newsletter metric:

\begin{itemize}
\tightlist
\item
  \emph{Name:} used in reports that count the number of times a metric
  has been triggered. This is also known as the newsletter's alias.
\item
  \emph{Newsletter ID:} used to differentiate between newsletters.
\item
  \emph{Event Type:} used to differentiate several actions on the same
  newsletter, such as opening the newsletter or clicking on a link.
\end{itemize}

To let administrators set these values, you must define a UI so your
metric can be configured during the view/save lifecycle. Remember that
you must also define a field to display the generated transparent
image's URL. Create a \texttt{view.jsp} file in your metric's module
(e.g., \texttt{/src/main/resources/META-INF/resources/view.jsp}) and add
the following logic:

\begin{verbatim}
<%
Map<String, Object> context = (Map<String, Object>)request.getAttribute("context");

String alias = (String)context.get("alias");
String elementId = (String)context.get("elementId");
String eventType = (String)context.get("eventType");
List<String> eventTypes = (List<String>)context.get("eventTypes");
String trackImageHTML = (String)context.get("trackImageHTML");
%>

<aui:input helpMessage="name-help" label="name" name='<%= ContentTargetingUtil.GUID_REPLACEMENT + "alias" %>' type="text" value="<%= alias %>">
    <aui:validator name="required" />
</aui:input>

<aui:input helpMessage="enter-the-id-of-the-newsletter-to-be-tracked" label="newsletter-id" name='<%= ContentTargetingUtil.GUID_REPLACEMENT + "elementId" %>' type="text" value="<%= elementId %>">
    <aui:validator name="required" />
</aui:input>

<c:if test="<%= ListUtil.isNotEmpty(eventTypes) %>">
    <aui:select label="event-type" name='<%= ContentTargetingUtil.GUID_REPLACEMENT + "eventType" %>'>

        <%
        for (String curEventType : eventTypes) {
        %>

            <aui:option label="<%= curEventType %>" selected="<%= curEventType.equals(eventType) %>" value="<%= curEventType %>" />

        <%
        }
        %>

    </aui:select>
</c:if>

<c:if test="<%= !Validator.isBlank(trackImageHTML) %>">
    <span class="h5">
        <liferay-ui:message key="paste-this-code-at-the-beginning-of-your-newsletter" />
    </span>
    <label for='<%= renderResponse.getNamespace() + ContentTargetingUtil.GUID_REPLACEMENT + "trackImageHTML" %>' key="paste-this-code-at-the-beginning-of-your-newsletter" /></label>

    <liferay-ui:input-resource id='<%= renderResponse.getNamespace() + ContentTargetingUtil.GUID_REPLACEMENT + "trackImageHTML" %>' url="<%= trackImageHTML %>" />
</c:if>
\end{verbatim}

First, you instantiate the \texttt{context} variable and its attributes
you configured in your Java class's \texttt{populateContext} method.
Then you specify the appropriate fields Name, Newsletter ID, and Event
Type. Finally, you present the generated transparent image URL.

Notice that the input field names in the JSP are prefixed with
\texttt{ContentTargetingUtil.GUID\_REPLACEMENT}. This prefix is required
for multi-instantiable metrics, which are metrics that return
\texttt{true} in the \texttt{isInstantiable} method of their
\texttt{-TrackingAction} class and can be added more than once to the
Metrics form.

\begin{figure}
\centering
\includegraphics{./images/metric-generated-url.png}
\caption{Once you've saved the metric, you can copy the generated
transparent image URL into your newsletter's HTML to track who views
it.}
\end{figure}

Congratulations! You've created the newsletter metric and can now track
whether users viewed a newsletter. You can test if the metric is working
by copying the generated tracking image HTML into an email HTML editor,
sending it, and opening it as if it were an actual newsletter. Then open
the custom report containing the newsletter metric and select
\emph{Update Report}. A chart and table with the newsletter's view count
is shown.

You can view the finished version of the newsletter metric by
downloading its
\href{https://portal.liferay.dev/documents/113763090/114000653/newsletter-7-1.zip/47e5b490-dd9d-9201-8abd-09b534ff7507?t=1565967901027}{ZIP
file}.

Now you've created and examined a fully functional metric and have the
knowledge to create your own.

\section{Best Practices for Audience
Targeting}\label{best-practices-for-audience-targeting}

Now that you've created a rule, here are some best practices to keep in
mind when creating additional rules. Before going through some best
practices, you should understand the three components you can specify
for a rule:

\begin{itemize}
\tightlist
\item
  \emph{Rule Behavior}
\item
  \emph{UI for Configuration (optional)}
\item
  \emph{Language Keys (optional)}
\end{itemize}

You discuss rule behavior and its UI configuration in great detail in
the To learn more about language keys and how to create, use, and
generate them, visit the
\href{/docs/7-1/tutorials/-/knowledge_base/t/internationalization}{Internationalization}
tutorials.

\subsection{Selecting a UI Technology}\label{selecting-a-ui-technology}

Audience Targeting gives you the option to choose whatever frontend
technology you like, but JSP is the preferred technology for Audience
Targeting extension views. FreeMarker views, however, are still
supported through their respective base classes (e.g.,
\texttt{BaseFreemarkerRule} or \texttt{BaseFreemarkerTrackingAction}).
If you're interested in using a technology besides JSP or FreeMarker to
implement your UI, you can add a method \texttt{getFormHTML} to your
\texttt{-Rule} or \texttt{-TrackingAction} class. Here's an example of
implementing the \texttt{getFormHTML} method:

\begin{verbatim}
@Override
public String getFormHTML(
    RuleInstance ruleInstance, Map<String, Object> context,
    Map<String, String> values) {

    String content = "";

    try {
        populateContext(ruleInstance, context, values);

        content = ContentTargetingContextUtil.parseTemplate(
            getClass(), getFormTemplatePath(), context);
    }
    catch (Exception e) {
        _log.error(
            "Error while processing template " + getFormTemplatePath(), e);
    }

    return content;
}
\end{verbatim}

The \texttt{getFormHTML} is used to retrieve the HTML created by the
technology you choose, and to return it as a string that is viewable
from your rule's form. If you plan, therefore, on using an alternative
to JSP or FreeMarker, you must override this method by creating and
modifying it in your \texttt{-Rule} or \texttt{-TrackingAction} class.

\subsection{Other Best Practices}\label{other-best-practices}

Here are some things to consider as you implement and deploy Audience
Targeting rules:

\begin{itemize}
\item
  As an alternative to storing complex information in the
  \texttt{typeSettings} field, which is managed by the framework in the
  Rule Instance table, you may want to consider persisting to a database
  by using
  \href{/docs/7-1/tutorials/-/knowledge_base/t/service-builder}{Service
  Builder}, which is supported for Rule plugins.
\item
  If you deploy your rule into a production environment, you may want to
  consider adding your values to the cache (e.g., weather in different
  locations), since obtaining the same value on every request is very
  inefficient and could result in slowing down your portal. For example,
  when the \texttt{evaluate} method is called, you could obtain the
  current user ID, current user's weather forecast, and the time at
  which the user first visited the page. Then you could evaluate the
  rule only when the cached time is over three hours old. This would
  prevent the rule from evaluating every time the user visited the page.
  This is best done using services.
\item
  You can override the \texttt{BaseJSPRule.deleteData} method in your
  \texttt{-Rule}, so that it deletes any data associated with the rule
  that is currently being deleted.
\item
  If your rule handles data or references to data that can be staged
  (e.g., a reference to a page or web content article), you may need to
  override the \texttt{BaseRule.exportData} and
  \texttt{BaseRule.importData} methods, to manage the content properly.
\end{itemize}

\chapter{WYSIWYG Editors}\label{wysiwyg-editors}

WYSIWYG editors are an important part of content creation. Liferay's
platform supports several different editors, including CKEditor,
TinyMCE, and our flagship, AlloyEditor. This section of tutorials shows
how to customize these WYSIWYG editors for your apps and sites.

\section{Adding a WYSIWYG Editor to a
Portlet}\label{adding-a-wysiwyg-editor-to-a-portlet}

It's easy to include WYSIWYG editors in your portlet, thanks to the
\texttt{\textless{}liferay-editor:editor\ /\textgreater{}} tag.

\noindent\hrulefill

\textbf{Note:} The
\texttt{\textless{}liferay-ui:input-editor\ /\textgreater{}} tag is
deprecated as of 7.0 in favor of the
\texttt{\textless{}liferay-editor:editor\ /\textgreater{}} tag. Use the
\texttt{\textless{}liferay-editor:editor\ /\textgreater{}} tag to avoid
future issues.

\noindent\hrulefill

Below is an example configuration:

\begin{verbatim}
<%@ taglib uri="http://liferay.com/tld/editor" prefix="liferay-editor" %>

<div class="alloy-editor-container">
    <liferay-editor:editor
            contents="Default Content"
            cssClass="my-alloy-editor"
            editorName="alloyeditor"
            name="myAlloyEditor"
            placeholder="description"
            showSource="true" 
    /> 
</div>
\end{verbatim}

It is also possible to pass JavaScript functions through the
\texttt{onBlurMethod}, \texttt{onChangeMethod}, \texttt{onFocusMethod},
and \texttt{onInitMethod} attributes. Here is an example configuration
that uses the \texttt{onInitMethod} attribute to pass a JavaScript
function called \texttt{OnDescriptionEditorInit}:

\begin{verbatim}
<%@ taglib uri="http://liferay.com/tld/editor" prefix="liferay-editor" %>

<div class="alloy-editor-container">
    <liferay-editor:editor
        contents="Default Content"
        cssClass="my-alloy-editor"
        editorName="alloyeditor"
        name="myAlloyEditor"
        onInitMethod="OnDescriptionEditorInit"
        placeholder="description"
        showSource="true" />
</div>

<aui:script>
    function <portlet:namespace />OnDescriptionEditorInit() {
        <c:if test="<%= !customAbstract %>">
            document.getElementById(
              '<portlet:namespace />myAlloyEditor'
            ).setAttribute('contenteditable', false);
        </c:if>
    }
</aui:script>
\end{verbatim}

Below is an overview of the main attributes of the
\texttt{\textless{}liferay-editor:editor\ /\textgreater{}} tag:

\noindent\hrulefill

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.3333}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Attribute
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Type
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Description
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{autoCreate} & \texttt{java.lang.String} & Whether to show the
HTML edit view of the editor initially \\
contents & \texttt{java.lang.String} & Sets the initial contents of the
editor \\
\texttt{contentsLanguageId} & \texttt{java.lang.String} & Sets the
language ID for the input editor's text \\
\texttt{cssClass} & \texttt{java.lang.String} & A CSS class for styling
the component. \\
data & \texttt{java.util.Map} & Data that can be used as the
editorConfig \\
\texttt{editorName} & \texttt{java.lang.String} & The editor you want to
use (alloyeditor, ckeditor, tinymce, simple) \\
name & \texttt{java.lang.String} & A name for the input editor. The
default value is \texttt{editor}. \\
\texttt{onBlurMethod} & \texttt{java.lang.String} & A function to be
called when the input editor loses focus. \\
\texttt{onChangeMethod} & \texttt{java.lang.String} & A function to be
called on a change in the input editor. \\
\texttt{onFocusMethod} & \texttt{java.lang.String} & A function to be
called when the input editor gets focus. \\
\texttt{onInitMethod} & \texttt{java.lang.String} & A function to be
called when the input editor initializes. \\
\texttt{placeholder} & \texttt{java.lang.String} & Placeholder text to
display in the input editor. \\
\texttt{showSource} & \texttt{java.lang.String} & Whether to enable
editing the HTML source code of the content. The default value is
\texttt{true}. \\
\end{longtable}

\noindent\hrulefill

See the
\href{https://docs.liferay.com/dxp/apps/frontend-editor/latest/taglibdocs/liferay-editor/editor.html}{taglibdocs}
for the complete list of supported attributes.

As you can see, it's easy to include WYSIWYG editors in your portlets!

\subsection{Related Topics}\label{related-topics-320}

\href{/docs/7-1/tutorials/-/knowledge_base/t/adding-new-behavior-to-an-editor}{Adding
New Behavior to an Editor}

\href{/docs/7-1/tutorials/-/knowledge_base/t/modifying-an-editors-configuration}{Modifying
an Editor's Configuration}

\href{/docs/7-1/tutorials/-/knowledge_base/t/alloyeditor}{Modifying the
AlloyEditor}

\section{Modifying an Editor's
Configuration}\label{modifying-an-editors-configuration}

You can use many different kinds of WYSIWYG editors to edit content in
portlets. Depending on the content you're editing, you may want to
modify the editor to provide a customized configuration for your needs.
In this tutorial, you'll learn how to modify the default configuration
for Liferay DXP's supported WYSIWYG editors to meet your requirements.

\subsection{Updating the Editor's
Configuration}\label{updating-the-editors-configuration}

To modify the editor's configuration, create a module with a component
that implements the
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/editor/configuration/EditorConfigContributor.html}{\texttt{EditorConfigContributor}}
interface. Follow these steps to modify one of Liferay DXP's WYSIWYG
editors:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/starting-module-development\#creating-a-module}{Create
  an OSGi module}.
\item
  Open the portlet's \texttt{build.gradle} file and update the
  \texttt{com.liferay.portal.kernel} \texttt{version} to \texttt{3.6.2}.
  This is the version bundled with the Liferay DXP release.
\item
  Create a unique package name in the module's \texttt{src} directory,
  and create a new Java class in that package that extends the
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/editor/configuration/BaseEditorConfigContributor.html}{\texttt{BaseEditorConfigContributor}}
  class:
\item
  Create a component class that implements the
  \texttt{EditorConfigContributor} service:

\begin{verbatim}
@Component(
    property = {

    },

    service = EditorConfigContributor.class
)
\end{verbatim}
\item
  Add the following imports:

\begin{verbatim}
import com.liferay.portal.kernel.editor.configuration.BaseEditorConfigContributor;
import com.liferay.portal.kernel.editor.configuration.EditorConfigContributor;
import com.liferay.portal.kernel.json.JSONArray;
import com.liferay.portal.kernel.json.JSONFactoryUtil;
import com.liferay.portal.kernel.json.JSONObject;
import com.liferay.portal.kernel.portlet.RequestBackedPortletURLFactory;
import com.liferay.portal.kernel.theme.ThemeDisplay;
\end{verbatim}
\item
  Specify the editor's name, editor's configuration key, and/or the
  portlet name(s) where the editor resides. These three properties can
  be specified independently, or together, in any order. See the
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/editor/configuration/EditorConfigContributor.html}{\texttt{EditorConfigContributor}}
  interface's Javadoc for more information about the available
  properties and how to use them. The example configuration below
  modifies the AlloyEditor's Content Editor, identified by the
  \texttt{contentEditor} configuration key and \texttt{alloyeditor} name
  key.
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** If you're targeting all editors for a portlet, the
 `editor.config.key` is not required. For example, if you just want to target
 the Web Content portlet's editors, you can provide the configuration below:
 
     @Component(
     property = {"editor.name=ckeditor",
     "javax.portlet.name=com_liferay_journal_web_portlet_JournalPortlet",
     "service.ranking:Integer=100"
     }
\end{verbatim}

\noindent\hrulefill

\begin{verbatim}
Two portlet names are declared (Blogs and Blogs Admin), specifying that the 
service applies to the content editors in those portlets. Lastly, the 
configuration overrides the default one by providing a higher 
[service ranking](/docs/7-1/tutorials/-/knowledge_base/t/fundamentals#services):

    @Component(
        property = {
            "editor.config.key=contentEditor", "editor.name=alloyeditor",
            "javax.portlet.name=com_liferay_blogs_web_portlet_BlogsPortlet",
            "javax.portlet.name=com_liferay_blogs_web_portlet_BlogsAdminPortlet", 
            "service.ranking:Integer=100"
        },
        
        service = EditorConfigContributor.class
    )
\end{verbatim}

\noindent\hrulefill

\begin{verbatim}
 **NOTE:** If you want to create a global configuration that applies to an
 editor everywhere it's used, you must create two separate configurations:
 one configuration that targets just the editor and a second configuration
 that targets the Blogs and Blogs Admin portlets. For example, the two
 separate configurations below apply the updates to AlloyEditor everywhere
 it's used:
 
 Configuration one:
 ```java
 @Component(
     immediate = true,
     property = {
         "editor.name=alloyeditor",
         "service.ranking:Integer=100"
     },
 
     service = EditorConfigContributor.class
 )
 ```
 
 Configuration two:
 ```java
 @Component(
     immediate = true,
     property = {
         "editor.name=alloyeditor",
         "javax.portlet.name=com_liferay_blogs_web_portlet_BlogsPortlet",
         "javax.portlet.name=com_liferay_blogs_web_portlet_BlogsAdminPortlet",
         "service.ranking:Integer=100"
     },
 
     service = EditorConfigContributor.class
 )
 ```
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{6}
\item
  Override the \texttt{populateConfigJSONObject()} method to provide the
  custom configuration for the editor. This method updates the original
  configuration JSON object. It can also Update or delete existing
  configurations, or any other configuration introduced by another
  \texttt{*EditorConfigContributor}.

\begin{verbatim}
@Override
public void populateConfigJSONObject(
    JSONObject jsonObject, Map<String, Object> inputEditorTaglibAttributes,
    ThemeDisplay themeDisplay,
    RequestBackedPortletURLFactory requestBackedPortletURLFactory) {

}
\end{verbatim}
\item
  In the \texttt{populateConfigJSONObject} method, you must instantiate
  a
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/json/JSONObject.html}{\texttt{JSONObject}}
  to hold the current configuration of the editor. For instance, you
  could use the code snippet below to retrieve the available toolbars
  for the editor:

\begin{verbatim}
JSONObject toolbars = jsonObject.getJSONObject("toolbars");
\end{verbatim}
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** This toolbar configuration is only applicable for the AlloyEditor.
 If you choose a configuration that is supported by multiple editors, you
 could apply it to them all. To do this, you could specify all the editors
 (e.g., `"editor.name=alloyeditor"`, `"editor.name=ckeditor"`,
 `ckeditor_bbcode` etc.) in the `@Component` annotation  of your
 `EditorConfigContributor` implementation, as you did in step six. Use the
 links the bottom of this tutorial to view each editor's configuration
 options and requirements.
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{8}
\item
  Now that you've retrieved the toolbar, you can modify it. The example
  below adds a camera button to the AlloyEditor's Add toolbar. It
  extracts the \emph{Add} buttons out of the toolbar configuration
  object as a
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/json/JSONArray.html}{\texttt{JSONArray}},
  and then adds the button to that \texttt{JSONArray}:

\begin{verbatim}
if (toolbars != null) {
    JSONObject toolbarAdd = toolbars.getJSONObject("add");

    if (toolbarAdd != null) {
        JSONArray addButtons = toolbarAdd.getJSONArray("buttons");

        addButtons.put("camera");
    }
}
\end{verbatim}

  The configuration JSON object is passed to the editor with the
  modifications you've implemented in the
  \texttt{populateConfigJSONObject} method.
\item
  Finally, generate the module's JAR file and copy it to your
  \texttt{deploy} folder. Once the module is installed and activated in
  the service registry, your new editor configuration is available for
  use.
\end{enumerate}

Liferay DXP supports several different types of WYSIWYG editors, which
include (among others):

\begin{itemize}
\tightlist
\item
  \href{https://alloyeditor.com/api/1.5.0/Core.html}{AlloyEditor}
\item
  \href{http://docs.ckeditor.com/\#!/api/CKEDITOR.config}{CKEditor}
\item
  \href{http://www.tinymce.com/wiki.php/Configuration}{TinyMCE}
\end{itemize}

Make sure to visit each editor's configuration API to learn what each
editor offers for configuration settings.

\subsection{Related Topics}\label{related-topics-321}

\href{/docs/7-1/tutorials/-/knowledge_base/t/adding-new-behavior-to-an-editor}{Adding
New Behavior to an Editor}

\href{/docs/7-1/tutorials/-/knowledge_base/t/alloyeditor}{Modifying the
AlloyEditor}

\href{/docs/7-1/tutorials/-/knowledge_base/t/adding-a-wysiwyg-editor-to-a-portlet}{Adding
a WYSIWYG Editor to a Portlet}

\section{Adding New Behavior to an
Editor}\label{adding-new-behavior-to-an-editor}

You can select from several different WYSIWYG editors for your users,
and each is configurable and has its strengths and weaknesses.
Configuration alone, however, doesn't always expose the features you
want. In these cases, you can programmatically access the editor
instance to create the editor experience you want, using the
\texttt{liferay-util:dynamic-include} JavaScript extension point. It
injects JavaScript code right after the editor instantiation to
configure/change the editor.

\noindent\hrulefill

\textbf{Note:} By default, the CKEditor strips empty
\texttt{\textless{}i\textgreater{}} tags, such as those used for Font
Awesome icons, from published content, when switching between the Code
View and the Source View of the editor. You can disable this behavior by
using the \texttt{ckeditor\#additionalResources} or
\texttt{alloyeditor\#additionalResources}
\href{/docs/7-1/tutorials/-/knowledge_base/t/wysiwyg-editor-dynamic-includes}{extension
points} to
\href{/docs/7-1/tutorials/-/knowledge_base/t/adding-new-behavior-to-an-editor}{add
the following code} to the editor:

\begin{verbatim}
 CKEDITOR.dtd.$removeEmpty.i = 0
\end{verbatim}

\noindent\hrulefill

In this tutorial, you'll learn how to use this JavaScript extension
point.

\subsection{Injecting JavaScript into a WYSIWYG
Editor}\label{injecting-javascript-into-a-wysiwyg-editor}

The \texttt{liferay-util:dynamic-include} extension point is in
configurable editors' JSP files: it's the gateway for injecting
JavaScript into your editor instance:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a JS file containing your editor functionality in a folder that
  makes sense to reference, since you must register the file in your
  module. The extension point injects the JavaScript code right after
  editor initialization.

  Liferay injects JavaScript code for some applications:

  \begin{itemize}
  \tightlist
  \item
    \href{https://github.com/liferay/liferay-portal/blob/7.1.x/modules/apps/frontend-editor/frontend-editor-ckeditor-web/src/main/resources/META-INF/resources/_diffs/extension/creole_dialog_definition.js}{creole\_dialog\_definition.js}
    for the wiki
  \item
    \href{https://github.com/liferay/liferay-portal/blob/7.1.x/modules/apps/frontend-editor/frontend-editor-ckeditor-web/src/main/resources/META-INF/resources/_diffs/extension/creole_dialog_show.js}{creole\_dialog\_show.js}
    also for the wiki
  \item
    \href{https://github.com/liferay/liferay-portal/blob/7.1.x/modules/apps/frontend-editor/frontend-editor-ckeditor-web/src/main/resources/META-INF/resources/_diffs/extension/dialog_definition.js}{dialog\_definition.js}
    for various applications
  \end{itemize}

  These JS files redefine the fields that show in dialogs, depending on
  what the selected language (HTML, BBCode, Creole) supports. For
  example, Creole doesn't support background color in table cells, so
  the table cells are removed from the options displayed to the user
  when running in Creole mode.
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/starting-module-development\#creating-a-module}{Create
  a module} that can register your new JS file and inject it into your
  editor instance.
\item
  Create a unique package name in the module's \texttt{src} directory,
  and create a new Java class in that package. To follow naming
  conventions, your class name should begin with the editor you're
  modifying, followed by custom attributes, and ending with
  \emph{DynamicInclude} (e.g.,
  \texttt{CKEditorCreoleOnEditorCreateDynamicInclude.java}). Your Java
  class should implement the
  \href{https://github.com/liferay/liferay-portal/blob/7.1.x/portal-kernel/src/com/liferay/portal/kernel/servlet/taglib/DynamicInclude.java}{\texttt{DynamicInclude}}
  interface.
\item
  Directly above the class's declaration, insert the following
  annotation:

\begin{verbatim}
@Component(immediate = true, service = DynamicInclude.class)
\end{verbatim}

  This declares the component's implementation class and starts the
  module once deployed to Portal.
\item
  If you have not yet overridden the abstract methods from
  \texttt{DynamicInclude}, do that now. There are two implemented
  methods to edit: \texttt{include(...)} and \texttt{register(...)}.
\item
  In the \texttt{include(...)} method, retrieve the bundle containing
  your custom JS file. Retrieve the JS file as a URL and inject its
  contents into the editor. Here's the code that does this for the
  \texttt{creole\_dialog\_definition.js} file:

\begin{verbatim}
Bundle bundle = _bundleContext.getBundle();

URL entryURL = bundle.getEntry(
    "/META-INF/resources/html/editors/ckeditor/extension" +
        "/creole_dialog_definition.js");

StreamUtil.transfer(entryURL.openStream(), response.getOutputStream());
\end{verbatim}

  In the \texttt{include(...)} method, you can also retrieve editor
  configurations and choose the JS file to inject based on the
  configuration selected by the user. For example, this would be
  applicable for the use case that was suggested previously dealing with
  Creole's deficiency with displaying background colors in table cells.
  Liferay implemented this in the \texttt{include(...)} method in the
  \href{https://github.com/liferay/liferay-portal/blob/7.1.x/modules/apps/frontend-editor/frontend-editor-ckeditor-web/src/main/java/com/liferay/frontend/editor/ckeditor/web/internal/servlet/taglib/CKEditorCreoleOnEditorCreateDynamicInclude.java}{\texttt{CKEditorCreoleOnEditorCreateDynamicInclude}}
  class.
\item
  Make sure you've instantiated your bundle's context so you can
  successfully retrieve your bundle. As a best practice, do this by
  creating an activation method and then setting the
  \texttt{BundleContext} as a private field. Here's an example:

\begin{verbatim}
@Activate
protected void activate(BundleContext bundleContext) {
    _bundleContext = bundleContext;
}

private BundleContext _bundleContext;
\end{verbatim}

  This method uses the \texttt{@Activate} annotation, which specifies
  that it should be invoked once the service component has satisfied its
  requirements. For this default example, the \texttt{\_bundleContext}
  was used in the \texttt{include(...)} method.
\item
  Now register the editor you're customizing. For example, if you were
  injecting JS code into the CKEditor's JSP file, the code would look
  like this:

\begin{verbatim}
dynamicIncludeRegistry.register(
    "com.liferay.frontend.editor.ckeditor.web#ckeditor#onEditorCreate");
\end{verbatim}

  This registers the CKEditor into the Dynamic Include registry and
  specifies that JS code will be injected into the editor once it's
  created.

  Just as you can configure individual JSP pages to use a specific
  implementation of the available WYSIWYG editors, you can use those
  same implementation options for the registration process. Visit the
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/propertiesdoc/portal.properties.html\#Editors}{Editors}
  section of \texttt{portal.properties} for more details. For example,
  to configure the Creole implementation of the CKEditor, you could use
  the following key:

\begin{verbatim}
"com.liferay.frontend.editor.ckeditor.web#ckeditor_creole#onEditorCreate"
\end{verbatim}
\end{enumerate}

That's it! The JS code that you created is now injected into the editor
instance you've specified. You're now able to use JavaScript to add new
behavior to your Liferay DXP supported WYSIWYG editor!

\subsection{Related Topics}\label{related-topics-322}

\href{/docs/7-1/tutorials/-/knowledge_base/t/adding-new-behavior-to-an-editor}{Adding
New Behavior to an Editor}

\href{/docs/7-1/tutorials/-/knowledge_base/t/embedding-portlets-in-themes}{Embedding
Portlets in Themes}

\href{/docs/7-1/tutorials/-/knowledge_base/t/portlets}{Portlets}

\chapter{AlloyEditor}\label{alloyeditor}

AlloyEditor is a modern WYSIWYG editor built on top of CKEDITOR,
designed to create modern and gorgeous web content. AlloyEditor is the
default WYSIWYG editor.

\begin{figure}
\centering
\includegraphics{./images/alloyeditor-website.png}
\caption{AlloyEditor is the default WYSIWYG editor built on top of
CKEditor.}
\end{figure}

This section of tutorials shows how to modify the default AlloyEditor
configuration to meet your requirements.

\chapter{Adding Buttons to AlloyEditor's
Toolbars}\label{adding-buttons-to-alloyeditors-toolbars}

AlloyEditor's toolbars contain several useful functions out-of-the-box.
You may, however, want to customize the default configuration to include
a button you've created, to add an existing button to a toolbar, or to
add an
\href{/docs/7-1/reference/-/knowledge_base/r/ckeditor-plugin-reference-guide}{existing
CKEditor button that's bundled with Liferay DXP's AlloyEditor}. The
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/editor/configuration/EditorConfigContributor.html}{\texttt{EditorConfigContributor}
interface}, provides everything you need to modify an editor's
configuration, including adding buttons to AlloyEditor's toolbars.
\href{https://docs.ckeditor.com/ckeditor4/latest/api/CKEDITOR_config.html}{CKEditor
Configuration settings} that modify the editor's behavior (excluding UI
modifications) can also be passed down through this configuration
object.

The \texttt{com.liferay.docs.my.button} module is the example throughout
these tutorials. If you want to use it as a starting point for your own
configuration or follow along with the tutorials, you can download the
module's zip file from the
\href{https://github.com/liferay/liferay-docs/tree/7.1.x/en/develop/tutorials/code/osgi/modules/com.liferay.docs.my.button}{Github
repo}.

\section{Creating the OSGi Module and Configuring the
EditorConfigContributor
Class}\label{creating-the-osgi-module-and-configuring-the-editorconfigcontributor-class}

To add a button to the AlloyEditor's toolbars, you must first create an
OSGi component class of service type
\texttt{EditorConfigContributor.class}. Follow these steps to create and
configure the OSGi module:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/starting-module-development\#creating-a-module}{Create
  an OSGi module}, using
  \href{/docs/7-1/reference/-/knowledge_base/r/using-the-portlet-template}{Blade's
  portlet template}:

\begin{verbatim}
blade create -t portlet -p com.liferay.docs.my.button -c 
MyEditorConfigContributor my-new-button
\end{verbatim}
\item
  Open the portlet's \texttt{build.gradle} file and update the
  \texttt{com.liferay.portal.kernel} \texttt{version} to \texttt{3.6.2}.
  This is the version bundled with the Liferay DXP release.
\item
  Open the portlet class you created in step one
  (\texttt{MyEditorConfigContributor}) and add the following imports:

\begin{verbatim}
import com.liferay.portal.kernel.editor.configuration.BaseEditorConfigContributor;
import com.liferay.portal.kernel.editor.configuration.EditorConfigContributor;
import com.liferay.portal.kernel.json.JSONArray;
import com.liferay.portal.kernel.json.JSONFactoryUtil;
import com.liferay.portal.kernel.json.JSONObject;
import com.liferay.portal.kernel.portlet.RequestBackedPortletURLFactory;
import com.liferay.portal.kernel.theme.ThemeDisplay;
\end{verbatim}
\item
  Replace the \texttt{@Component} and properties with the properties
  below:

\begin{verbatim}
@Component(
    immediate = true,
    property = {
      "editor.name=alloyeditor",
      "service.ranking:Integer=100"
    },
    service = EditorConfigContributor.class  
)
\end{verbatim}

  This targets AlloyEditor for the configuration and overrides the
  default service by providing a higher
  \href{/docs/7-1/tutorials/-/knowledge_base/t/fundamentals\#services}{service
  ranking}. If you want to target a more specific configuration, you can
  find the available properties in the
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/editor/configuration/EditorConfigContributor.html}{\texttt{EditorConfigContributor}
  interface's Javadoc}.
\item
  Extend \texttt{BaseEditorConfigContributor} instead of
  \texttt{GenericPortlet}.
\item
  Replace the \texttt{doView()} method and contents with the
  \texttt{populateConfigJSONObject()} method shown below:

\begin{verbatim}
@Override
public void populateConfigJSONObject(
        JSONObject jsonObject, Map<String, Object> inputEditorTaglibAttributes,
        ThemeDisplay themeDisplay,
        RequestBackedPortletURLFactory requestBackedPortletURLFactory) {

}
\end{verbatim}
\item
  Inside the \texttt{populateConfigJSONObject()} method, retrieve the
  AlloyEditor's toolbars:

\begin{verbatim}
JSONObject toolbarsJSONObject = jsonObject.getJSONObject("toolbars");

if (toolbarsJSONObject == null) {
        toolbarsJSONObject = JSONFactoryUtil.createJSONObject();
}
\end{verbatim}
\item
  If you're adding a button for one of the
  \href{/docs/7-1/reference/-/knowledge_base/r/ckeditor-plugin-reference-guide}{CKEditor
  plugins bundled with the AlloyEditor}, add the code below to retrieve
  the extra plugins and add the plugin to the AlloyEditor's
  configuration. The example below adds the \texttt{clipboard} CKEditor
  plugin:

\begin{verbatim}
String extraPlugins = jsonObject.getString("extraPlugins");

if (Validator.isNotNull(extraPlugins)) {
  extraPlugins = extraPlugins + ",ae_uibridge,ae_autolink,
  ae_buttonbridge,ae_menubridge,ae_panelmenubuttonbridge,ae_placeholder,
  ae_richcombobridge,clipboard";
}
else {
  extraPlugins = "ae_uibridge,ae_autolink,ae_buttonbridge,ae_menubridge,
  ae_panelmenubuttonbridge,ae_placeholder,ae_richcombobridge,clipboard";
}

jsonObject.put("extraPlugins", extraPlugins);
\end{verbatim}

  AlloyEditor also comes with several plugins to bridge the gap between
  the CKEditor's UI and the AlloyEditor's UI. These are prefixed with
  the \texttt{ae\_} you see above. We recommend that you include them
  all to ensure compatibility.
\end{enumerate}

The \texttt{*EditorConfigContributor} class is prepared. Now you must
choose which toolbar you want to add the button(s) to: the
\href{/docs/7-1/tutorials/-/knowledge_base/t/adding-a-button-to-the-add-toolbar}{Add
Toolbar} or one of the
\href{/docs/7-1/tutorials/-/knowledge_base/t/adding-a-button-to-a-styles-toolbar}{Styles
Toolbars}.

\subsection{Related Topics}\label{related-topics-323}

\href{/docs/7-1/tutorials/-/knowledge_base/t/adding-new-behavior-to-an-editor}{Adding
New Behavior to an Editor}

\href{/docs/7-1/reference/-/knowledge_base/r/ckeditor-plugin-reference-guide}{CKEditor
Plugin Reference Guide}

\section{Adding a Button to the Add
Toolbar}\label{adding-a-button-to-the-add-toolbar}

The Add Toolbar appears in the AlloyEditor when your cursor is in the
editor and you click the Add button:

\begin{figure}
\centering
\includegraphics{./images/alloyeditor-add-toolbar.png}
\caption{The Add toolbar lets you add content to the editor.}
\end{figure}

Follow these steps to add a button to the AlloyEditor's Add Toolbar:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Inside the \texttt{populateConfigJSONObject()} method, retrieve the
  Add Toolbar:

\begin{verbatim}
JSONObject addToolbar = toolbarsJSONObject.getJSONObject("add");
\end{verbatim}
\item
  Retrieve the existing Add Toolbar buttons:

\begin{verbatim}
JSONArray addToolbarButtons = addToolbar.getJSONArray("buttons");
\end{verbatim}
\item
  Add the button to the existing buttons. Note that the button's name is
  case sensitive. The example below adds the \texttt{camera} button to
  the Add Toolbar:

\begin{verbatim}
addToolbarButtons.put("camera");
\end{verbatim}

  The camera button is just one of the buttons available by default with
  AlloyEditor, but they are not all enabled. Here's the full list of
  available buttons you can add to the Add Toolbar:

  \begin{itemize}
  \tightlist
  \item
    camera
  \item
    embed
  \item
    hline
  \item
    image
  \item
    table
  \end{itemize}

  See \href{https://alloyeditor.com/docs/features/}{here} for an
  explanation of each button's features.
\item
  Update the AlloyEditor's configuration with the changes you made:

\begin{verbatim}
addToolbar.put("buttons", addToolbarButtons);

toolbarsJSONObject.put("add", addToolbar);

jsonObject.put("toolbars", toolbarsJSONObject);
\end{verbatim}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/deploying-projects-with-blade-cli}{Deploy
  your module} and create new content that uses the AlloyEditor---like a
  blog entry or web content article---to see your new configuration in
  action!
\end{enumerate}

The \texttt{com.liferay.docs.my.button} module's updated Add Toolbar is
shown in the figure below:

\begin{figure}
\centering
\includegraphics{./images/alloyeditor-updated-add-toolbar.png}
\caption{The Updated Add toolbar lets you add pictures from a camera
directly to the editor.}
\end{figure}

\subsection{Related Topics}\label{related-topics-324}

\href{/docs/7-1/tutorials/-/knowledge_base/t/adding-new-behavior-to-an-editor}{Adding
New Behavior to an Editor}

\href{/docs/7-1/tutorials/-/knowledge_base/t/adding-a-button-to-a-styles-toolbar}{Adding
a Button to a Styles Toolbar}

\section{Adding a Button to a Styles
Toolbar}\label{adding-a-button-to-a-styles-toolbar}

A Styles Toolbar appears when content is selected or highlighted in
AlloyEditor. There are five Styles toolbars to choose from:

\texttt{embedurl}: Appears when embedded content is selected.

\begin{figure}
\centering
\includegraphics{./images/alloyeditor-embedurl-toolbar.png}
\caption{The embed URL Styles toolbar lets you format embedded content
in the editor.}
\end{figure}

\texttt{image}: Appears when an image is selected.

\begin{figure}
\centering
\includegraphics{./images/alloyeditor-image-toolbar.png}
\caption{The image Styles toolbar lets you format images in the editor.}
\end{figure}

\texttt{link}: Appears when a hyperlink is selected.

\begin{figure}
\centering
\includegraphics{./images/alloyeditor-link-toolbar.png}
\caption{The link Styles toolbar lets you format hyperlinks in the
editor.}
\end{figure}

\texttt{table}: Appears when a table is selected.

\begin{figure}
\centering
\includegraphics{./images/alloyeditor-table-toolbar.png}
\caption{The table Styles toolbar lets you format tables in the editor.}
\end{figure}

\texttt{text}: Appears when text is highlighted.

\begin{figure}
\centering
\includegraphics{./images/alloyeditor-text-toolbar.png}
\caption{The text Styles toolbar lets you format highlighted text in the
editor.}
\end{figure}

Follow these steps to add a button to one of the Styles toolbars:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Inside the \texttt{populateConfigJSONObject()} method, retrieve the
  Styles toolbar:

\begin{verbatim}
JSONObject stylesToolbar = toolbarsJSONObject.getJSONObject("styles");

if (stylesToolbar == null) {
        stylesToolbar = JSONFactoryUtil.createJSONObject();
}
\end{verbatim}
\item
  Retrieve the available selection toolbars:

\begin{verbatim}
JSONArray selectionsJSONArray = stylesToolbar.getJSONArray(
"selections");
\end{verbatim}
\item
  Iterate through the selection toolbars, select the one you want to add
  the button(s) to (\texttt{embedurl}, \texttt{image}, \texttt{link},
  \texttt{table}, or \texttt{text}), retrieve the existing buttons, and
  add your button. The example below adds the \texttt{clipboard}
  plugin's \texttt{Copy}, \texttt{Cut}, and \texttt{Paste} buttons to
  the \texttt{text} selection toolbar. Note that buttons are case
  sensitive and may be aliased or not match the name of the plugin.
  Search the plugin's
  \href{/docs/7-1/reference/-/knowledge_base/r/ckeditor-plugin-reference-guide}{\texttt{plugin.js}
  file} for \texttt{editor.ui.addButton} to find the button's name:

\begin{verbatim}
for (int i = 0; i < selectionsJSONArray.length(); i++) {
        JSONObject selection = selectionsJSONArray.getJSONObject(i);

        if (Objects.equals(selection.get("name"), "text")) {
                JSONArray buttons = selection.getJSONArray("buttons");

                buttons.put("Copy");
                buttons.put("Cut");
                buttons.put("Paste");
        }
}
\end{verbatim}

  The example above adds one of the
  \href{/docs/7-1/reference/-/knowledge_base/r/ckeditor-plugin-reference-guide}{CKEditor
  plugins bundled with Liferay DXP's AlloyEditor}. There are also
  several buttons available by default with the AlloyEditor, but they
  are not all enabled. The full list of existing buttons you can add to
  the Styles toolbars is shown in the table below, ordered by Toolbar:
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 text | table | image | link |
 ---- | ----- | ----- | ---- |
 bold | tableHeading | imageCenter | linkEdit |
 code | tableRow | imageLeft | |
 h1 | tableColumn | imageRight | |
 h2 | tableCell | | |
 indentBlock | tableRemove | | |
 italic | | | |
 link | | | |
 ol | | | |
 outdentBlock | | | |
 paragraphLeft | | | |
 paragraphRight | | | |
 paragraphCenter | | | |
 paragraphJustify | | | |
 quote | | | |
 removeFormat | | | |
 strike | | | |
 styles | | | |
 subscript | | | |
 superscript | | | |
 twitter | | | |
 ul | | | |
 underline | | | |
\end{verbatim}

\noindent\hrulefill

\begin{verbatim}
See 
[here](https://alloyeditor.com/docs/features/) 
for an explanation of each button's features.
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{3}
\item
  Update the AlloyEditor's configuration with the changes you made:

\begin{verbatim}
stylesToolbar.put("selections", selectionsJSONArray);

toolbarsJSONObject.put("styles", stylesToolbar);

jsonObject.put("toolbars", toolbarsJSONObject);
\end{verbatim}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/deploying-projects-with-blade-cli}{Deploy
  your module} and create a new piece of content that uses the
  AlloyEditor---such as a blog entry or web content article---to see
  your new configuration in action!
\end{enumerate}

The \texttt{com.liferay.docs.my.button} module's updated text styles
toolbar is shown in the figure below:

\begin{figure}
\centering
\includegraphics{./images/alloyeditor-updated-styles-toolbar.png}
\caption{The Updated text styles toolbar lets you copy, cut, and paste
text in the editor.}
\end{figure}

\subsection{Related Topics}\label{related-topics-325}

\href{/docs/7-1/tutorials/-/knowledge_base/t/adding-a-button-to-the-add-toolbar}{Adding
a Button to the Add Toolbar}

\href{/docs/7-1/reference/-/knowledge_base/r/ckeditor-plugin-reference-guide}{CKEditor
Plugin Reference Guide}

\chapter{Creating New Buttons for
AlloyEditor}\label{creating-new-buttons-for-alloyeditor}

AlloyEditor is built on \texttt{React.js} and uses \texttt{jsx} to
render each button in the editor. To add a new button to the
AlloyEditor, you must create an OSGi bundle that contains three key
pieces:

\begin{itemize}
\tightlist
\item
  A JSX file containing the button's configuration
\item
  A Java class that contributes the button to the list of available
  buttons
\item
  A Java class that adds the button to the AlloyEditor's toolbar
\end{itemize}

Below is the folder structure for a module that adds a new button:

\begin{itemize}
\tightlist
\item
  \texttt{frontend-editor-my-button-web}

  \begin{itemize}
  \item
    \texttt{src}

    \begin{itemize}
    \tightlist
    \item
      \texttt{main}

      \begin{itemize}
      \tightlist
      \item
        \texttt{java}

        \begin{itemize}
        \tightlist
        \item
          \texttt{com/liferay/frontend/editor/my/button/web/}

          \begin{itemize}
          \tightlist
          \item
            \texttt{editor}

            \begin{itemize}
            \tightlist
            \item
              \texttt{configuration}

              \begin{itemize}
              \tightlist
              \item
                \texttt{AlloyEditorMyButtonConfigContributor.java}
              \end{itemize}
            \item
              \texttt{servlet}

              \begin{itemize}
              \tightlist
              \item
                \texttt{taglib}

                \begin{itemize}
                \tightlist
                \item
                  \texttt{AlloyEditorMyButtonDynamicInclude.java}
                \end{itemize}
              \end{itemize}
            \end{itemize}
          \end{itemize}
        \end{itemize}
      \item
        \texttt{resources}

        \begin{itemize}
        \tightlist
        \item
          \texttt{META-INF}

          \begin{itemize}
          \tightlist
          \item
            \texttt{resources}

            \begin{itemize}
            \tightlist
            \item
              \texttt{js}

              \begin{itemize}
              \tightlist
              \item
                \texttt{my\_button.jsx}
              \end{itemize}
            \end{itemize}
          \end{itemize}
        \end{itemize}
      \end{itemize}
    \end{itemize}
  \item
    \texttt{.babelrc}
  \item
    \texttt{bnd.bnd}
  \item
    \texttt{build.gradle}
  \item
    \texttt{package.json}
  \end{itemize}
\end{itemize}

The tutorials in this section cover the following topics:

\begin{itemize}
\tightlist
\item
  How to create your button's OSGi bundle
\item
  How to create your button's JSX file
\item
  How to contribute your button to the list of available buttons
\end{itemize}

You can learn how to add your button to the editor's toolbars in the
\href{/docs/7-1/tutorials/-/knowledge_base/t/adding-buttons-to-alloyeditor-toolbars}{Adding
Buttons to AlloyEditor's Toolbars tutorials}.

The
\href{https://github.com/liferay/liferay-docs/tree/7.1.x/en/develop/tutorials/code/osgi/modules/com.liferay.docs.my.button/my-log-text-button}{\texttt{my-log-text-button}
bundle} is used as an example throughout this tutorial. You can
\href{https://github.com/liferay/liferay-docs/blob/7.1.x/en/develop/tutorials/code/osgi/modules/com.liferay.docs.my.button/my-log-text-button.zip}{download
the bundle's zip file} for reference, or use it as a starting point for
your project if you wish.

\section{Creating the AlloyEditor Button's OSGi
Bundle}\label{creating-the-alloyeditor-buttons-osgi-bundle}

Follow these steps to create your OSGi bundle for your new button:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/starting-module-development\#creating-a-module}{Create
  an OSGi module}
\item
  Add a
  \texttt{resources\textbackslash{}META-INF\textbackslash{}resources\textbackslash{}js}
  folder to your module's \texttt{src\textbackslash{}main} folder.
\item
  Specify your bundle's \texttt{Web-ContextPath} in its \texttt{bnd.bnd}
  file. An example BND file configuration is shown below with the
  \texttt{Web-ContextPath} pointing to the bundle's root folder. This is
  required to properly locate and load the module's JavaScript:

\begin{verbatim}
Bundle-Name: my-log-text-button
Bundle-SymbolicName: com.liferay.docs.portlet
Bundle-Version: 1.0.0
Web-ContextPath: /my-button-portlet-project
\end{verbatim}
\item
  Since the button's configuration is defined in a JSX file, it must be
  transpiled for the browser. You can do this by adding the
  \texttt{transpileJS} task to your \texttt{build.gradle} file. An
  example configuration is shown below:

\begin{verbatim}
configJSModules {
    enabled = false
}

dependencies {
  compileOnly group: "com.liferay.portal", name: "com.liferay.portal.kernel", version: "3.6.2"
  compileOnly group: "com.liferay.portal", name: "com.liferay.util.taglib", version: "2.0.0"
  compileOnly group: "javax.portlet", name: "portlet-api", version: "3.0.0"
  compileOnly group: "javax.servlet", name: "javax.servlet-api", version: "3.0.1"
  compileOnly group: "jstl", name: "jstl", version: "1.2"
  compileOnly group: "org.osgi", name: "osgi.cmpn", version: "6.0.0"
  compileOnly group: "org.osgi", name: "org.osgi.core", version: "6.0.0"
}

transpileJS {
    bundleFileName = "js/buttons.js"
    globalName = "AlloyEditor.Buttons"
    modules = "globals"
    srcIncludes = "**/*.jsx"
}
\end{verbatim}
\item
  Add the following \texttt{devDependencies} to your
  \texttt{package.json} file:

\begin{verbatim}
{
  "devDependencies": {
    "babel-preset-react": "^6.11.1",
    "metal-cli": "^4.0.1"
  },
  "name": "my-bundle-name",
  "version": "1.0.0"
}
\end{verbatim}
\item
  Add the following preset to your module's \texttt{.babelrc} file to
  transpile your JSX file:

\begin{verbatim}
{
  "presets": [
    "react"
  ]
}
\end{verbatim}
\end{enumerate}

\subsection{Related Topics}\label{related-topics-326}

\href{/docs/7-1/tutorials/-/knowledge_base/t/adding-new-behavior-to-an-editor}{Adding
New Behavior to an Editor}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-the-alloyeditor-buttons-jsx-file}{Creating
the Button's JSX File}

\href{/docs/7-1/tutorials/-/knowledge_base/t/contributing-the-button-to-alloyeditor}{Contributing
the Button to AlloyEditor}

\section{Creating the Button's JSX
File}\label{creating-the-buttons-jsx-file}

Follow these steps to create your button for AlloyEditor:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a \texttt{.jsx} file in your OSGi bundle's
  \texttt{resources\textbackslash{}META-INF\textbackslash{}resources\textbackslash{}js}
  folder. This file defines your button's configuration.
\item
  Inside the JSX file, define the React variables your buttons require
  (React, ReactDOM). The log text button only uses AlloyEditor's React:

\begin{verbatim}
(function() {
        'use strict';

        var React = AlloyEditor.React;
\end{verbatim}
\item
  Create your button's class:

\begin{verbatim}
var LogSelectedTextButton = React.createClass(
    {
        //button configuration goes here
    }
);
\end{verbatim}
\item
  Inside the \texttt{React.createClass()} method's configuration object,
  specify the
  \href{/docs/7-1/reference/-/knowledge_base/r/alloyeditor-button-reference-guide\#mixins}{mixins}
  your button requires. These provide additional functionality, making
  it easy to add features to your button, such as binding a shortcut key
  to your button. The example below uses the \texttt{ButtonStateClasses}
  and \texttt{ButtonKeystroke} mixins:

\begin{verbatim}
mixins: [AlloyEditor.ButtonStateClasses, AlloyEditor.ButtonKeystroke],
\end{verbatim}
\item
  Pass validating props for your button. These are defined for each
  instance of the button. At the very least, the \texttt{editor} must be
  defined. The example below sets up properties for the editor, label,
  and tabIndex:

\begin{verbatim}
propTypes: {
    /**
     * The editor instance where the component is being used.
     *
     * @instance
     * @memberof LogSelectedTextButton
     * @property {Object} editor
     */
    editor: React.PropTypes.object.isRequired,

    /**
     * The label that should be used for accessibility purposes.
     *
     * @instance
     * @memberof LogSelectedTextButton
     * @property {String} label
     */
    label: React.PropTypes.string,

    /**
     * The tabIndex of the button in its toolbar current state. A value other than -1
     * means that the button has focus and is the active element.
     *
     * @instance
     * @memberof LogSelectedTextButton
     * @property {Number} tabIndex
     */
    tabIndex: React.PropTypes.number
},
\end{verbatim}
\item
  Define the static properties for your button. You must at least
  provide the \texttt{key}. The \texttt{key} defines the button's name
  to specify in the
  \href{/docs/7-1/tutorials/-/knowledge_base/t/adding-buttons-to-alloyeditor-toolbars}{AlloyEditor's
  configuration}. The \texttt{my-log-text-button} module's static
  properties are shown below:

\begin{verbatim}
statics: {
    /**
     * The name which is used as an alias of the button in the configuration.
     *
     * @default myTestButton
     * @memberof LogSelectedTextButton
     * @property {String} key
     * @static
     */
    key: 'logSelectedText'
},
\end{verbatim}
\item
  Optionally define any default properties your button has for each
  instance using the \texttt{getDefaultProps} property. The example
  below uses the \texttt{ButtonKeystroke} mixin's required
  \texttt{command} and \texttt{keystroke} properties to set the shortcut
  keys for the button's \texttt{logText()} function:

\begin{verbatim}
getDefaultProps: function() {
    return {
        command: 'logText',
        keystroke: {
            fn: 'logText',
            keys: CKEDITOR.CTRL + CKEDITOR.SHIFT + 89 /*Y*/
        }
    };
},
\end{verbatim}
\item
  Define the HTML markup to render for your button. The example below
  uses the \texttt{getStateClasses()} method to retrieve the state class
  information provided by the \texttt{ButtonStateClasses} mixin and add
  it to the current \texttt{cssClass} value. It also uses Liferay Util's
  \texttt{getLexiconIconTpl()} method to retrieve a Lexicon icon to use
  for the button. See
  \href{https://v2.clayui.com/docs/components/icons.html}{Lexicon's
  Design Site} for a full list of the available icons.

\begin{verbatim}
render: function() {
        var cssClass = 'ae-button ' + this.getStateClasses();
        var svg = Liferay.Util.getLexiconIconTpl('desktop');

        return (
                <button
                    className={cssClass}
                    onClick={this._logText}
                    title="Log the selected text in the console"
                    dangerouslySetInnerHTML={{__html: svg}}
                />
        );
},
\end{verbatim}
\item
  Define your button's main action. Retrieving the
  \href{https://alloyeditor.com/api/1.5.0/Core.html\#nativeEditor}{\texttt{nativeEditor}},
  as shown in the example below, gives you access to the full API of
  CKEditor. From there, you can use any of the available
  \href{https://ckeditor.com/docs/ckeditor4/latest/api/CKEDITOR_editor.html\#methods}{\texttt{CKEditor.editor}
  methods} to interact with the editor's content. The example below
  chains the editor's
  \href{https://ckeditor.com/docs/ckeditor4/latest/api/CKEDITOR_editor.html\#method-getSelection}{\texttt{getSelection()}}
  and
  \href{https://ckeditor.com/docs/ckeditor4/latest/api/CKEDITOR_dom_selection.html\#method-getSelectedText}{\texttt{getSelectedText()}}
  methods to retrieve the user's highlighted text, and then it logs it
  to the browser's console:

\begin{verbatim}
/**
 * @protected
 * @method  _logText
 */
_logText: function() {
    var editor = this.props.editor.get('nativeEditor');
    var selectedText = editor.getSelection().getSelectedText();

    console.log("Your selected text is " + selectedText);
}
\end{verbatim}
\item
  Finally, add the button to the list of available buttons:

  AlloyEditor.Buttons{[}LogSelectedTextButton.key{]} =
  AlloyEditor.LogSelectedTextButton = LogSelectedTextButton;
\end{enumerate}

Now you know how to create a button for AlloyEditor!

\subsection{Related Topics}\label{related-topics-327}

\href{/docs/7-1/tutorials/-/knowledge_base/t/adding-new-behavior-to-an-editor}{Adding
New Behavior to an Editor}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-the-alloyeditor-buttons-osgi-bundle}{Creating
the AlloyEditor Button's OSGi Bundle}

\href{/docs/7-1/tutorials/-/knowledge_base/t/contributing-the-button-to-alloyeditor}{Contributing
the Button to AlloyEditor}

\section{Contributing the Button to
AlloyEditor}\label{contributing-the-button-to-alloyeditor}

Once you've created your button, you can add it to the list of available
buttons. This can be achieved thanks to some smartly placed
\texttt{\textless{}liferay-util:dynamic-include\ /\textgreater{}} tags
in the editor's infrastructure. To make your button available in the
AlloyEditor, you must extend the
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/servlet/taglib/BaseDynamicInclude.html}{\texttt{BaseDynamicInclude}
class}. Below is an example configuration that extends this class:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a Component class that implements the
  \texttt{DynamicInclude.class} service and extends
  \texttt{BaseDynamicInclude}:

\begin{verbatim}
@Component(immediate = true, service = DynamicInclude.class)
public class MyButtonDynamicInclude extends BaseDynamicInclude {
\end{verbatim}
\item
  Override the \texttt{include()} method to include a script with your
  transpiled JSX file. You can use the \texttt{StringBundler} to
  concatenate the script. Note the \texttt{sb.append("/js/buttons.js")}
  line below. This is the \texttt{bundleFileName} you defined in your
  \href{/docs/7-1/tutorials/-/knowledge_base/t/creating-the-alloyeditor-buttons-osgi-bundle}{bundle's
  \texttt{build.gradle} \texttt{transpileJS} task}:

\begin{verbatim}
@Override
public void include(
                HttpServletRequest request, HttpServletResponse response,
                String key)
        throws IOException {

        ThemeDisplay themeDisplay = (ThemeDisplay)request.getAttribute(
                WebKeys.THEME_DISPLAY);

        PrintWriter printWriter = response.getWriter();

        StringBundler sb = new StringBundler(7);

        sb.append("<script src=\"");
        sb.append(themeDisplay.getPortalURL());
        sb.append(PortalUtil.getPathProxy());
        sb.append(_servletContext.getContextPath());
        sb.append("/js/buttons.js");
        sb.append("\" ");
        sb.append("type=\"text/javascript\"></script>");

        printWriter.println(sb.toString());
}
\end{verbatim}
\item
  Override the \texttt{register()} method to use the
  \texttt{additionalResources} dynamic include to add your script. Note
  the \texttt{@Reference} annotation's \texttt{target} value is your
  bundle's symbolic name defined in its \texttt{bnd.bnd} file:

\begin{verbatim}
    @Override
    public void register(DynamicIncludeRegistry dynamicIncludeRegistry) {
            dynamicIncludeRegistry.register(
                    "com.liferay.frontend.editor.alloyeditor.web#alloyeditor#" +
                            "additionalResources");
    }

    @Reference(
            target = "(osgi.web.symbolicname=com.liferay.frontend.editor.alloyeditor.my.button.web)"
    )
    private ServletContext _servletContext;
\end{verbatim}

  \}
\end{enumerate}

Now that your button is included, you can follow the steps covered in
\href{/docs/7-1/tutorials/-/knowledge_base/t/adding-buttons-to-alloyeditor-toolbars}{Adding
Buttons to the AlloyEditor's Toolbars} tutorials to add the button to
the editor's toolbars.

\subsection{Related Topics}\label{related-topics-328}

\href{/docs/7-1/tutorials/-/knowledge_base/t/adding-new-behavior-to-an-editor}{Adding
New Behavior to an Editor}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-the-alloyeditor-buttons-jsx-file}{Creating
the Button's JSX File}

\href{/docs/7-1/tutorials/-/knowledge_base/t/wysiwyg-editor-dynamic-includes}{WYSIWYG
Editor Dynamic Includes}

\section{Embedding Content in the
AlloyEditor}\label{embedding-content-in-the-alloyeditor}

Whether it's a video from a popular streaming service, or an
entertaining podcast, embedded content is commonplace on the web.
Sharing content from a third party is sometimes required to properly
cover a topic. The \texttt{EmbedProvider} mechanism lets you embed third
party content in the AlloyEditor, while writing blog posts, web content
articles, etc. By default, the \texttt{EmbedProvider} mechanism is only
configured for embedding video content (Facebook, Twitch, Vimeo, and
YouTube) into the AlloyEditor. This tutorial shows how to include
additional video providers, and even add support for additional content
types.

An \texttt{EmbedProvider} requires four pieces of information:

\begin{itemize}
\tightlist
\item
  An ID: The content's ID
\item
  A Template: The required embed code for the provider
\item
  A URL Schemes: URL patterns that are supported for the provider
  template
\item
  A Type (optional): The provider category
\end{itemize}

When you add a supported URL to the editor, the \texttt{EmbedProvider}
transforms the URL into the embed code.

Follow these steps to create an \texttt{*EmbedProvider}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/starting-module-development\#creating-a-module}{Create
  a module} for the Embed Provider.
\item
  Add the following dependencies to the \texttt{build.gradle} file:

\begin{verbatim}
compileOnly group: "com.liferay", name:
"com.liferay.frontend.editor.api", version: "1.0.1"

compileOnly group: "com.liferay", name: "com.liferay.petra.string",
version: "2.0.0"
\end{verbatim}
\item
  Create a component class that implements the
  \texttt{EditorEmbedProvider} service:

\begin{verbatim}
@Component(
  immediate = true,
  service = EditorEmbedProvider.class
)
\end{verbatim}
\item
  Optionally set the \texttt{type} property to the content's type. If
  creating a provider for a content type other than video, you can
  create a new type constant and
  \href{/docs/7-1/tutorials/-/knowledge_base/t/creating-new-buttons-for-alloyeditor}{add
  a new button} for the content type. If you do create your own button,
  we recommend that you use the existing
  \href{https://github.com/liferay/liferay-portal/tree/7.1.x/modules/apps/frontend-editor/frontend-editor-alloyeditor-web/src/main/resources/META-INF/resources/js/extras/buttons/embed}{embed
  video button's JSX files} as an example to write your own files. By
  default, the provider is categorized as \texttt{UNKNOWN}. The example
  configuration below specifies the \texttt{VIDEO} type, using a
  constant provided by the
  \href{https://github.com/liferay/liferay-portal/blob/7.1.x/modules/apps/frontend-editor/frontend-editor-api/src/main/java/com/liferay/frontend/editor/api/embed/EditorEmbedProviderTypeConstants.java}{\texttt{EditorEmbedProviderTypeConstants}
  class}:

\begin{verbatim}
@Component(
  immediate = true,
  property = "type=" + EditorEmbedProviderTypeConstants.VIDEO,
  service = EditorEmbedProvider.class
)
\end{verbatim}
\item
  Implement the
  \href{https://github.com/liferay/liferay-portal/blob/7.1.x/modules/apps/frontend-editor/frontend-editor-api/src/main/java/com/liferay/frontend/editor/api/embed/EditorEmbedProvider.java}{\texttt{EditorEmbedProvider}
  interface}. An example configuration is shown below:

\begin{verbatim}
public class MyEditorEmbedProvider implements EditorEmbedProvider {

}
\end{verbatim}
\item
  Add the required imports:

\begin{verbatim}
import com.liferay.frontend.editor.api.embed.EditorEmbedProvider;
import com.liferay.frontend.editor.api.embed.EditorEmbedProviderTypeConstants;
import com.liferay.petra.string.StringBundler;
\end{verbatim}

  Note the \texttt{*TypeConstants} import is only needed if you're
  adding a Video type provider.
\item
  Override the \texttt{*EmbedProvider}'s \texttt{getId()} method to
  return the ID for the provider. An example configuration is shown
  below:

\begin{verbatim}
@Override
public String getId() {
    return "providerName";
}
\end{verbatim}
\item
  Override the \texttt{*EmbedProvider}'s \texttt{getTpl()} method to
  provide the embed template code (usually an iframe for the provider).
  The example below defines the template for a streaming video service.
  Note that \texttt{\{embedId\}} is a placeholder for the unique
  identifier for the embedded content:

\begin{verbatim}
@Override
public String getTpl() {
    return StringBundler.concat(
        "<iframe allow=\"autoplay; encrypted-media\" allowfullscreen ",
        "height=\"315\" frameborder=\"0\" ",
        "src=\"https://www.liferaylunarresortstreaming.com/embed/{embedId}?rel=0\" ",
        "width=\"560\"></iframe>");
}
\end{verbatim}
\item
  Override the \texttt{*EmbedProvider}'s \texttt{getURLSchemes()} method
  to return an array of supported URL schemes that have an embedded
  representation for the provider. URL schemes are defined using a
  JavaScript regular expression that indicates whether a URL matches the
  provider. Every URL scheme should contain a single matching group.
  Matches replace the \texttt{\{embedId\}} placeholder defined in the
  previous step:

\begin{verbatim}
@Override
public String[] getURLSchemes() {
    return new String[] {
        "https?:\\/\\/(?:www\\.)?liferaylunarresortstreaming.com\\/watch\\?v=(\\S*)$"
    };
}
\end{verbatim}
\item
  Deploy your module and open an app that uses the AlloyEditor, such as
  Blogs, and create a new entry. Click the \emph{add button} and select
  the video button---or your new content type button---and paste the
  content's URL. Click the \emph{checkmark} to confirm that the URL
  scheme is supported. The content is embedded into the editor.
\end{enumerate}

Now you know how to embed content in the AlloyEditor. Create a new
content entry, such as a blog post, and click the embed video
button---or the one you created---and paste the content's URL.

\subsection{Related Topics}\label{related-topics-329}

\href{/docs/7-1/tutorials/-/knowledge_base/t/adding-buttons-to-alloyeditor-toolbars}{Adding
Buttons to AlloyEditor's Toolbars}

\href{/docs/7-1/tutorials/-/knowledge_base/t/adding-new-behavior-to-an-editor}{Adding
New Behavior to an Editor}

\chapter{Servlets}\label{servlets}

\href{https://en.wikipedia.org/wiki/Java_servlet}{Java Servlets} are
foundational to Java EE. You can use servlets and servlet filters to
provide applications in your portal context and to process requests and
responses to specific URLs in your sites. The tutorials here cover
servlet technology and how it integrates with Liferay DXP.

\section{Servlets in a Module}\label{servlets-in-a-module}

You can use servlets or
\href{/docs/7-1/tutorials/-/knowledge_base/t/jax-rs}{JAX-RS} to provide
a lightweight web integration or a web endpoint to a browser client.
Servlets, rather than REST endpoints or portlets, let you control an
application's entire UI experience. Liferay DXP supports servlet based
applications and embeds
\href{https://osgi.org/specification/osgi.cmpn/7.0.0/service.http.whiteboard.html}{HTTP
Whiteboard} for servlets.

Here you'll examine a \hyperref[servlet-sample]{servlet sample} and
\hyperref[creating-a-servlet]{create your own servlet based
application}.

\subsection{Servlet Sample}\label{servlet-sample}

The \href{/docs/7-1/reference/-/knowledge_base/r/servlet}{servlet
sample} uses
\href{https://osgi.org/specification/osgi.cmpn/7.0.0/service.http.whiteboard.html}{HTTP
Whiteboard} to respond to requests at URLs that match the pattern
\texttt{http://localhost:8080/o/blade/servlet/*}.

\begin{figure}
\centering
\includegraphics{./images/servlet-sample.png}
\caption{If users visit \texttt{http://localhost:8080/o/blade/servlet},
the servlet sample shows the message \texttt{Hello\ World}.}
\end{figure}

Here's the sample servlet class:

\begin{verbatim}
package com.liferay.blade.samples.servlet;

import java.io.IOException;

import javax.servlet.Servlet;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Reference;
import org.osgi.service.log.LogService;

/**
 * @author Liferay
 */
@Component(
    immediate = true,
    property = {
        "osgi.http.whiteboard.context.path=/",
        "osgi.http.whiteboard.servlet.pattern=/blade/servlet/*"
    },
    service = Servlet.class
)
public class BladeServlet extends HttpServlet {

    @Override
    public void init() throws ServletException {
        _log.log(LogService.LOG_INFO, "BladeServlet init");

        super.init();
    }

    @Override
    protected void doGet(
            HttpServletRequest request, HttpServletResponse response)
        throws IOException, ServletException {

        _log.log(LogService.LOG_INFO, "doGet");

        _writeSampleHTML(response);
    }

    /**
     * Dummy contents
     *
     * @return dummy contents string
     */
    private String _generateSampleHTML() {
        StringBuffer sb = new StringBuffer();

        sb.append("<html>");
        sb.append("<head><title>Sample HTML</title></head>");
        sb.append("<body>");
        sb.append("<h2>Hello World</h2>");
        sb.append("</body>");
        sb.append("</html>");

        return new String(sb);
    }

    /**
     * Write sample HTML
     *
     * @param resp
     */
    private void _writeSampleHTML(HttpServletResponse resp) {
        resp.setCharacterEncoding("UTF-8");
        resp.setContentType("text/html; charset=UTF-8");
        resp.setStatus(HttpServletResponse.SC_OK);

        try {
            resp.getWriter().write(_generateSampleHTML());
        }
        catch (Exception e) {
            _log.log(LogService.LOG_WARNING, e.getMessage(), e);

            resp.setStatus(HttpServletResponse.SC_PRECONDITION_FAILED);
        }
    }

    private static final long serialVersionUID = 1L;

    @Reference
    private LogService _log;

}
\end{verbatim}

The sample servlet class uses the \texttt{@Component} annotation to
declare itself an OSGi service of type \texttt{Servlet}. It uses OSGi
HTTP Whiteboard to respond to requests at URLs matching
\texttt{http://localhost:8080/o/blade/servlet/*}. Since the component's
\texttt{osgi.http.whiteboard.context.path} and
\texttt{osgi.http.whiteboard.servlet.pattern} properties configure the
servlet mapping, there's no need to specify one in a
\texttt{WEB-INF/web.xml} descriptor.

The Portal web application's \texttt{WEB-INF/web.xml} defines Liferay's
Module Framework Servlet mapping:

\begin{verbatim}
  <servlet-mapping>
      <servlet-name>Module Framework Servlet</servlet-name>
      <url-pattern>/o/*</url-pattern>
  </servlet-mapping>
\end{verbatim}

The servlet mapping starts at URL pattern \texttt{/o/*}. Combined with
the \texttt{@Component} property
\texttt{"osgi.http.whiteboard.servlet.pattern=/blade/servlet/*"}, the
servlet sample matches URL pattern \texttt{/o/blade/servlet/*}.

To develop your own servlet, you can copy and modify all (or part) of
the
\href{/docs/7-1/reference/-/knowledge_base/r/servlet\#where-is-this-sample}{Servlet
sample module project} or create a servlet in your own module.

\subsection{Creating a Servlet}\label{creating-a-servlet}

Here's how to create your own servlet:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a
  \href{/docs/7-1/tutorials/-/knowledge_base/t/starting-module-development}{module
  project}.
\item
  Add the necessary dependencies. Here they are for Gradle:

\begin{verbatim}
compileOnly group: "javax.servlet", name: "javax.servlet-api", version: "3.0.1"
compileOnly group: "org.osgi", name: "org.osgi.service.component.annotations", version: "1.4.0"
compileOnly group: "org.osgi", name: "org.osgi.service.log", version: "1.4.0"
\end{verbatim}
\item
  Create a servlet class that extends
  \texttt{javax.servlet.http.HttpServlet}.
\item
  Add the following \texttt{@Component} annotation.

\begin{verbatim}
@Component(
    property = {
        "osgi.http.whiteboard.context.path=/",
        "osgi.http.whiteboard.servlet.pattern=/blade/servlet/*"
    },
    service = Servlet.class
) 
\end{verbatim}

  \texttt{service\ =\ Servlet.class}: Makes the component an OSGi
  service of type \texttt{Servlet}.
\item
  Set the following \texttt{@Component} \texttt{property} values to
  specify a context path and servlet URL pattern:

  \texttt{"osgi.http.whiteboard.context.path=/"}: Sets the servlet's
  context. Replace the value with your servlet's context path.

  \texttt{"osgi.http.whiteboard.servlet.pattern=/blade/servlet/*"}: Sets
  the servlet's mapping pattern. Replace the value with your servlet's
  pattern.
\item
  Override \texttt{HttpServlet} methods to implement your servlet's
  behavior.
\item
  Deploy your module.
\end{enumerate}

Your servlet is up and running. You're well on your way to delivering
custom user experiences using servlets.

\subsection{Related Topics}\label{related-topics-330}

\href{/docs/7-1/reference/-/knowledge_base/r/servlet}{Servlet Sample}

\href{/docs/7-1/tutorials/-/knowledge_base/t/servlet-filters}{Servlet
Filters}

\href{/docs/7-1/tutorials/-/knowledge_base/t/jax-rs}{JAX-RS}

\href{/docs/7-1/tutorials/-/knowledge_base/t/portlets}{Portlets}

\section{Servlet Filters}\label{servlet-filters}

Servlet filters can both pre-process requests as they arrive and
post-process responses before they go to the client browser. They let
you apply functionality to requests and responses for multiple servlets,
without the servlets knowing. Here are some common filter use cases:

\begin{itemize}
\tightlist
\item
  Logging
\item
  Auditing
\item
  Transaction management
\item
  Security
\end{itemize}

You can use patterns in descriptors to map the filters to servlet URLs.
When requests arrive at these URLs, your filters process them. Filter
chaining lets you apply filters in an order you want. Servlet Filter
Hook plugins let you deploy and undeploy filters without modifying the
Liferay web application. Here are the steps for creating and deploying a
servlet filter:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \hyperref[step-1-create-a-servlet-filter-class]{Create a Servlet
  Filter class}
\item
  \hyperref[step-2-map-urls-to-your-servlet-filter]{Map URLs to your
  Servlet Filter}
\item
  \hyperref[step-3-create-a-liferay-plugin-descriptor]{Create a Liferay
  plugin descriptor}
\item
  \hyperref[step-4-deploy-your-plugin]{Deploy your plugin}
\end{enumerate}

For reference, you can download the example
\href{https://portal.liferay.dev/documents/113763090/114000653/sample-servlet-filter-hook.zip}{servlet
filter project code}.

In a traditional web application (\texttt{.war}) project, start with
creating your servlet filter class.

\noindent\hrulefill

\textbf{Note:}
\href{https://portals.apache.org/pluto/portlet-3.0-apidocs/javax/portlet/filter/PortletFilter.html}{Portlet
filters} let you apply functionality to portlet requests and responses.
\href{/docs/7-1/tutorials/-/knowledge_base/t/jsp-overrides-using-portlet-filters}{JSP
overrides} are one way to use portlet filters.

\noindent\hrulefill

\subsection{Step 1: Create a Servlet Filter
class}\label{step-1-create-a-servlet-filter-class}

Create a class that implements
\href{https://tomcat.apache.org/tomcat-9.0-doc/servletapi/index.html}{\texttt{javax.servlet.Filter}}.
Here's an example servlet filter class:

\begin{verbatim}
package com.liferay.sampleservletfilter.hook.filter;

import com.liferay.portal.kernel.util.WebKeys;

import java.io.IOException;

import javax.servlet.Filter;
import javax.servlet.FilterChain;
import javax.servlet.FilterConfig;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;

public class SampleFilter implements Filter {

    @Override
    public void destroy() {
        System.out.println("Called SampleFilter.destroy()");
    }

    @Override
    public void doFilter(
            ServletRequest servletRequest, ServletResponse servletResponse,
            FilterChain filterChain)
        throws IOException, ServletException {

        String uri = (String)servletRequest.getAttribute(
            WebKeys.INVOKER_FILTER_URI);

        System.out.println(
            "Called SampleFilter.doFilter(" + servletRequest + ", " +
                servletResponse + ", " + filterChain + ") for URI " + uri);

        filterChain.doFilter(servletRequest, servletResponse);
    }

    @Override
    public void init(FilterConfig filterConfig) {
        System.out.println(
            "Called SampleFilter.init(" + filterConfig + ") where hello=" +
                filterConfig.getInitParameter("hello"));
    }

}
\end{verbatim}

Here are the
\href{https://tomcat.apache.org/tomcat-9.0-doc/servletapi/index.html}{\texttt{Filter}}
methods to implement:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \texttt{init(FilterConfig)}: Configure the filter and perform any
  necessary initializations.

  When \texttt{SampleFilter} is initialized, for example, its
  \texttt{init(FilterConfig)} method prints the \texttt{FilterConfig}
  object and the \texttt{hello} parameter's value:

\begin{verbatim}
Called SampleFilter.init(com.liferay.portal.kernel.servlet.filters.invoker.InvokerFilterConfig@7c953747) where hello=world
\end{verbatim}
\item
  \texttt{doFilter(ServletRequest,\ ServletResponse,\ FilterChain)}:
  Filter on requests and responses here. To apply your filter, invoke
  \texttt{filterChain.doFilter(servletRequest,\ servletResponse)}.

  When users visit URLs mapped for \texttt{SampleFilter}, for example,
  its \texttt{doFilter(...)} method prints the \texttt{ServletResponse}
  object, \texttt{FilterChain} object, and the \texttt{ServletRequest}
  URI before passing control to the next filter by invoking
  \texttt{filterChain.doFilter(servletRequest,\ servletResponse)}.

\begin{verbatim}
Called SampleFilter.doFilter(org.apache.catalina.connector.RequestFacade@68be71e0, com.liferay.portal.servlet.filters.absoluteredirects.AbsoluteRedirectsResponse@2b598f1a, com.liferay.portal.kernel.servlet.filters.invoker.InvokerFilterChain@72220503) for URI /web/guest
\end{verbatim}
\item
  \texttt{destroy()}: Clean up the filter's unneeded resources.

  When \texttt{SampleFilter} is destroyed, its \texttt{destroy()} method
  prints the message: \texttt{Called\ SampleFilter.destroy()}.
\end{enumerate}

It's time to map URLs to your servlet filter.

\subsection{Step 2: Map URLs to your Servlet
Filter}\label{step-2-map-urls-to-your-servlet-filter}

Traditionally, specifying a servlet filter and its filter mapping
requires modifying your web application's \texttt{web.xml} file. Liferay
DXP, however, lets you specify them in your plugin, so you don't need to
modify the Liferay DXP web application. Specify your servlet filter
mapping in a descriptor file \texttt{WEB-INF/liferay-hook.xml}, like
this one for Sample Filter:

\begin{verbatim}
<?xml version="1.0"?>
<!DOCTYPE hook PUBLIC "-//Liferay//DTD Hook 7.1.0//EN" "http://www.liferay.com/dtd/liferay-hook_7_1_0.dtd">

<hook>
    <servlet-filter>
        <servlet-filter-name>Sample Filter</servlet-filter-name>
        <servlet-filter-impl>com.liferay.sampleservletfilter.hook.filter.SampleFilter</servlet-filter-impl>
        <init-param>
            <param-name>hello</param-name>
            <param-value>world</param-value>
        </init-param>
    </servlet-filter>
    <servlet-filter-mapping>
        <servlet-filter-name>Sample Filter</servlet-filter-name>
        <before-filter>SSO Open SSO Filter</before-filter>
        <url-pattern>/group/*</url-pattern>
        <url-pattern>/user/*</url-pattern>
        <url-pattern>/web/*</url-pattern>
        <url-pattern>*.jsp</url-pattern>
        <dispatcher>REQUEST</dispatcher>
        <dispatcher>FORWARD</dispatcher>
    </servlet-filter-mapping>
</hook>
\end{verbatim}

Here's how to map URLs to your servlet filter:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a descriptor file \texttt{WEB-INF/liferay-hook.xml}, based on
  the
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/definitions/liferay-hook_7_1_0.dtd.html}{Liferay
  Hook DTD}.
\item
  Add a \texttt{servlet-filter} element as a sub element of
  \texttt{hook}. Specify your \texttt{servlet-filter} sub-elements.

  \texttt{servlet-filter-name}: Arbitrary name. (required)

  \texttt{servlet-filter-impl}: \texttt{Filter} implementation class.
  (required)

  \texttt{init-param} elements: Initialization parameters. (optional)
\item
  Add a \texttt{servlet-filter-mapping} element as a sub element of
  \texttt{hook}.

  \texttt{servlet-filter-name}: Match the one used in the
  \texttt{servlet-filter}. (required)

  \texttt{after-filter}: Name of a \texttt{servlet-filter} for this
  filter to go after. (optional)

  \texttt{before-filter}: Name of a \texttt{servlet-filter} for this
  filter to go before. (optional)

  \texttt{url-pattern} elements: URL patterns you want to filter
  requests and responses for. (required)

  \texttt{dispatcher} elements: Specify
  \href{https://docs.liferay.com/ce/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/servlet/filters/invoker/Dispatcher.html\#enum.constant.summary}{\texttt{Dispatcher}
  enumerated constants} to
  \href{https://docs.oracle.com/cd/E19798-01/821-1841/bnagf/index.html}{constrain
  how the filter is applied to requests}. (optional)
\end{enumerate}

\subsection{Step 3: Create a Liferay plugin
descriptor}\label{step-3-create-a-liferay-plugin-descriptor}

In a \texttt{WEB-INF/liferay-plugin-package.properties} file, specify
the versions of Liferay DXP your plugin supports:

\begin{verbatim}
liferay-versions=7.1.0+
\end{verbatim}

\subsection{Step 4: Deploy your plugin}\label{step-4-deploy-your-plugin}

Specify compile-time dependencies on these artifacts:

\begin{itemize}
\tightlist
\item
  \texttt{com.liferay.portal.kernel}
\item
  \texttt{javax.servlet-api}
\end{itemize}

Gradle:

\begin{verbatim}
compileOnly group: "com.liferay.portal", name: "com.liferay.portal.kernel", version: "3.0.0"
compileOnly group: "javax.servlet", name: "javax.servlet-api", version: "3.0.1"
\end{verbatim}

Maven:

\begin{verbatim}
<dependency>
    <groupId>com.liferay.portal</groupId>
    <artifactId>com.liferay.portal.kernel</artifactId>
    <version>3.0.0</version>
</dependency>
<dependency>
    <groupId>javax.servlet</groupId>
    <artifactId>javax.servlet-api</artifactId>
    <version>3.0.1</version>
</dependency>
\end{verbatim}

Build your plugin \texttt{.war} file and deploy it by copying it to the
\texttt{{[}LIFERAY\_HOME{]}/deploy} folder. Liferay's auto-deployer
copies the \texttt{.war} to the \texttt{{[}LIFERAY\_HOME{]}/osgi/war}
folder. The
\href{/docs/7-1/tutorials/-/knowledge_base/t/using-the-wab-generator}{WAB
Generator} converts the \texttt{.war} to an OSGi Web Application Bundle
(WAB) and installs it to Liferay DXP's runtime. The output in your
console should look like this:

\begin{verbatim}
2018-11-03 16:20:09.118 INFO  [fileinstall-C:/workspace_liferay/bundles/osgi/war][BaseAutoDeployListener:43] Copying hook plugin for C:\workspace_liferay\bundles\tomcat-9.0.6\temp\20181103162009108XCJZAKUY\sample-servlet-filter-hook.war
2018-11-03 16:20:09.390 INFO  [fileinstall-C:/workspace_liferay/bundles/osgi/war][BaseDeployer:880] Deploying sample-servlet-filter-hook.war
2018-11-03 16:20:10.019 INFO  [fileinstall-C:/workspace_liferay/bundles/osgi/war][BaseAutoDeployListener:50] Hook for C:\workspace_liferay\bundles\tomcat-9.0.6\temp\20181103162009108XCJZAKUY\sample-servlet-filter-hook.war copied successfully
2018-11-03 16:20:10.730 INFO  [Refresh Thread: Equinox Container: 4023060a-c8de-0018-1c3a-ebee784b7a28][BundleStartStopLogger:35] STARTED sample-servlet-filter-hook_7.1.10.1 [963]
2018-11-03 16:20:11.050 INFO  [Refresh Thread: Equinox Container: 4023060a-c8de-0018-1c3a-ebee784b7a28][HotDeployImpl:226] Deploying sample-servlet-filter-hook from queue
2018-11-03 16:20:11.052 INFO  [Refresh Thread: Equinox Container: 4023060a-c8de-0018-1c3a-ebee784b7a28][PluginPackageUtil:1001] Reading plugin package for sample-servlet-filter-hook
03-Nov-2018 16:20:11.066 INFO [Refresh Thread: Equinox Container: 4023060a-c8de-0018-1c3a-ebee784b7a28] org.apache.catalina.core.ApplicationContext.log Initializing Spring root WebApplicationContext
2018-11-03 16:20:11.093 INFO  [Refresh Thread: Equinox Container: 4023060a-c8de-0018-1c3a-ebee784b7a28][HookHotDeployListener:457] Registering hook for sample-servlet-filter-hook
Called SampleFilter.init(com.liferay.portal.kernel.servlet.filters.invoker.InvokerFilterConfig@7c953747) where hello=world
2018-11-03 16:20:11.134 INFO  [Refresh Thread: Equinox Container: 4023060a-c8de-0018-1c3a-ebee784b7a28][HookHotDeployListener:533] Hook for sample-servlet-filter-hook is available for use
\end{verbatim}

The servlet container calls your filter's \texttt{init} method.
Deploying \texttt{SampleFilter}, for example, invokes its \texttt{init}
method, which prints this output:

\begin{verbatim}
Called SampleFilter.init(com.liferay.portal.kernel.servlet.filters.invoker.InvokerFilterConfig@7c953747) where hello=world
\end{verbatim}

Visiting the URLs mapped to your servlet filter invokes your filter's
\texttt{doFilter} method. Since the sample's servlet filter mapping
includes the URL \texttt{/web/*}, visiting
http://localhost:8080/web/guest invokes \texttt{SampleFilter.doFilter},
which prints this:

\begin{verbatim}
Called SampleFilter.doFilter(org.apache.catalina.connector.RequestFacade@68be71e0, com.liferay.portal.servlet.filters.absoluteredirects.AbsoluteRedirectsResponse@2b598f1a, com.liferay.portal.kernel.servlet.filters.invoker.InvokerFilterChain@72220503) for URI /web/guest
\end{verbatim}

Undeploying your servlet filter \texttt{.war} invokes its
\texttt{destroy()} method.

Congratulations on filtering requests to your site's URLs.

\subsection{Related Topics}\label{related-topics-331}

\href{/docs/7-1/tutorials/-/knowledge_base/t/configuring-dependencies}{Configuring
Dependencies}

\chapter{Testing}\label{testing}

Assuring top quality is paramount in producing awesome software. Test
driven development plays a key role in this process. Liferay's tooling
and integration with standard test frameworks support test driven
development and help you reach quality milestones. Liferay lets you use
whatever testing framework you want. There's
\href{https://junit.org}{JUnit} for unit testing,
\href{http://arquillian.org/}{Arquillian} plus JUnit annotations for
integration testing, and more; consult the testing framework's
documentation for details.

Here are the ways Liferay facilitates testing:

\begin{itemize}
\tightlist
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/injecting-service-components-into-tests}{Injecting
  Service Components into Tests}: Liferay's \texttt{@Inject} annotation
  allows you to inject service instances into tests.
\end{itemize}

\section{Injecting Service Components into Integration
Tests}\label{injecting-service-components-into-integration-tests}

You can use Liferay DXP's \texttt{@Inject} annotation to inject service
components into an integration test, like you use the
\href{/docs/7-1/tutorials/-/knowledge_base/t/osgi-services-and-dependency-injection-with-declarative-services}{\texttt{@Reference}
annotation to inject service components} into an OSGi component.

\noindent\hrulefill

\textbf{Note:} \href{http://arquillian.org/}{Arquillian} plus
\href{https://junit.org}{JUnit} annotations is one way to develop
integration tests. Liferay lets you use whatever testing framework you
want.

\noindent\hrulefill

\texttt{@Inject} uses reflection to inject a field with a service
component object matching the field's interface.
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-test-integration/com/liferay/portal/test/rule/LiferayIntegrationTestRule.html}{Test
rule \texttt{LiferayIntegrationTestRule}} provides the annotation. The
annotation accepts \texttt{filter} and \texttt{type} parameters, which
you can use separately or together.

To fill a field with a particular implementation or sub-class object,
set the \texttt{type} with it.

\begin{verbatim}
@Inject(type = SubClass.class)
\end{verbatim}

Replace \texttt{SubClass} with the name of the service interface to
inject.

Here's an example test class that injects a \texttt{DDLServiceUpgrade}
object into an \texttt{UpgradeStepRegistrator} interface field:

\begin{verbatim}
public class Test {

    @ClassRule
    @Rule
    public static final AggregateTestRule aggregateTestRule = 
        new LiferayIntegrationTestRule();

    @Test
    public void testSomething() {
        // your test code here
    }

    @Inject(
        filter = "(&(objectClass=com.liferay.dynamic.data.lists.internal.upgrade.DDLServiceUpgrade))"
    )
    private static UpgradeStepRegistrator _upgradeStepRegistrator;

} 
\end{verbatim}

Here's how to inject a service component into a test class:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In your test class, add a rule field of
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-test-integration/com/liferay/portal/test/rule/LiferayIntegrationTestRule.html}{type
  \texttt{com.liferay.portal.test.rule.LiferayIntegrationTestRule}}. For
  example,

\begin{verbatim}
@ClassRule
@Rule
public static final AggregateTestRule aggregateTestRule = 
    new LiferayIntegrationTestRule();
\end{verbatim}
\item
  Add a field to hold a service component. Making the field static
  improves efficiency, because the container injects static fields once
  before test runs and nulls them after all tests run. Non-static fields
  are injected before each test run but stay in memory till all tests
  finish.
\item
  Annotate the field with an \texttt{@Inject} annotation. By default,
  the container injects the field with a service component object
  matching the field's type.
\item
  Optionally add a \texttt{filter} string or \texttt{type} parameter to
  further specify the service component object to inject.
\end{enumerate}

At runtime, the \texttt{@Inject} annotation blocks the test until a
matching service component is available. The block has a timeout and
messages are logged regarding the test's unavailable dependencies.

\noindent\hrulefill

\textbf{Important}: If you're publishing the service component you are
injecting, the test might never run. If you must publish the service
component from the test class, use
\href{/docs/7-1/tutorials/-/knowledge_base/t/service-trackers}{Service
Trackers} to access service components.

\noindent\hrulefill

Great! Now you can inject service components into your tests.

\subsection{Related Articles}\label{related-articles-3}

\href{/docs/7-1/tutorials/-/knowledge_base/t/service-trackers}{Service
Trackers}

\chapter{Modularity and OSGi}\label{modularity-and-osgi}

Things we use every day are made of carefully designed, created, and
tested subsystems. For example, a car has an engine, suspension, and air
conditioner. Teams of engineers, machinists, and technicians make these
subsystems the best they can be separately before combining them to
create a high quality car. This is modularity in action: creating things
from smaller well-designed, well-tested parts.

Liferay DXP is modular too. It comprises code modules created and tested
independently and in parallel. It's a platform on which modules and
modular applications are installed, started, used, stopped, and
uninstalled. Liferay's components use the OSGi modularity standard.

These tutorials demonstrate developing OSGi services and components to
customize Liferay DXP and create applications on it. As Liferay's
developers used modules to create applications, you and your team can
enjoy developing your own modules, applications, and customizations in
parallel.

\section{The Benefits of Modularity}\label{the-benefits-of-modularity}

Dictionary.com defines
\href{http://www.dictionary.com/browse/modularity}{modularity} as
\emph{the use of individually distinct functional units, as in
assembling an electronic or mechanical system.} The distinct functional
units are called \emph{modules}.

NASA's Apollo spacecraft, for example, comprised three modules, each
with a distinct function:

\begin{itemize}
\tightlist
\item
  \emph{Lunar Module}: Carried astronauts from the Apollo spacecraft to
  the moon's surface and back.
\item
  \emph{Service Module}: Provided fuel for propulsion, air conditioning,
  and water.
\item
  \emph{Command Module}: Housed the astronauts and communication and
  navigation controls.
\end{itemize}

\begin{figure}
\centering
\includegraphics{./images/modularity_apollo_spacecraft_diagram.png}
\caption{The Apollo spacecraft's modules collectively took astronauts to
the moon's surface and back to Earth.}
\end{figure}

The spacecraft and its modules exemplified these modularity
characteristics:

\begin{itemize}
\item
  \textbf{Distinct functionality}: Each module provides a distinct
  function (purpose); modules can be combined to provide an entirely new
  collective function.

  The Apollo spacecraft's modules were grouped together for a distinct
  collective function: take astronauts from the Earth's atmospheric rim,
  to the moon's surface, and back to Earth. The previous list identifies
  each module's distinct function.
\item
  \textbf{Dependencies}: Modules can require capabilities other modules
  satisfy.

  The Apollo modules had these dependencies:

  \begin{itemize}
  \item
    Lunar Module depended on the Service Module to get near the moon.
  \item
    Command Module depended on the Service Module for power and oxygen.
  \item
    Service Module depended on the Command Module for instruction.
  \end{itemize}
\item
  \textbf{Encapsulation}: Modules hide their implementation details but
  publicly define their capabilities and interfaces.

  Each Apollo module was commissioned with a contract defining its
  capabilities and interface, while each module's details were
  encapsulated (hidden) from other modules. NASA integrated the modules
  based on their interfaces.
\item
  \textbf{Reusability}: A module can be applied to different scenarios.

  The Command Module's structure and design were reusable. NASA used
  different versions of the Command Module, for example, throughout the
  Apollo program, and in the Gemini Program, which focused on Earth
  orbit.
\end{itemize}

NASA used modularity to successfully complete over a dozen missions to
the moon. Can modularity benefit software too? Yes! The following
sections show you how:

\begin{itemize}
\tightlist
\item
  \hyperref[modularity-benefits-for-software]{Modularity benefits for
  software}
\item
  \hyperref[example-designing-a-modular-application]{Example: How to
  design a modular application}
\end{itemize}

\subsection{Modularity Benefits for
Software}\label{modularity-benefits-for-software}

Java applications have predominantly been monolithic: they're developed
in large code bases. In a monolith, it's difficult to avoid tight
coupling of classes. Modular application design, conversely, facilitates
loose coupling, making the code easier to maintain. It's much easier and
more fun to develop small amounts of cohesive code in modules. Here are
some key benefits of developing modular software.

\subsubsection{Distinct Functionality}\label{distinct-functionality}

It's natural to focus on developing one piece of software at a time. In
a module, you work on a small set of classes to define and implement the
module's function. Keeping scope small facilitates writing high quality,
elegant code. The more cohesive the code, the easier it is to test,
debug, and maintain. Modules can be combined to provide a new function,
distinguishable from each module's function.

\subsubsection{Encapsulation}\label{encapsulation}

A module encapsulates a function (capability). Module implementations
are hidden from consumers, so you can create and modify them as you
like. Throughout a module's lifetime, you can fix and improve the
implementation or swap in an entirely new one. You make the changes
behind the scenes, transparent to consumers. A module's contract defines
its capability and interface, making the module easy to understand and
use.

\subsubsection{Dependencies}\label{dependencies}

Modules have requirements and capabilities. The interaction between
modules is a function of the capability of one satisfying the
requirement of another and so on. Modules are published to artifact
repositories, such as Maven Central. Module versioning schemes let you
specify dependencies on particular module versions or version ranges.

\subsubsection{Reusability}\label{reusability}

Modules that do their job well are hot commodities. They're reusable
across projects, for different purposes. As you discover helpful
reliable modules, you'll use them again and again.

It's time to design a modular application.

\subsection{Example: Designing a Modular
Application}\label{example-designing-a-modular-application}

Application design often starts out simple but gets more complex as you
determine capabilities the application requires. If a third party
library already provides the capability, you can
\href{/docs/7-1/tutorials/-/knowledge_base/t/adding-third-party-libraries-to-a-module}{deploy
it with your app}. You can otherwise implement the capability yourself.

As you design various aspects of your app to support its function, you
must decide how those aspects fit into the code base. Putting them in a
single monolithic code base often leads to tight coupling, while
designating separate modules for each aspect fosters loose coupling.
Adopting a modular approach to application design lets you reap the
modularity benefits.

For example, you can apply modular design to a speech recognition app.
Here are the app's function and required capabilities:

\emph{Function}: interface with users to translate their speech into
text for the computer to understand.

\emph{Required capabilities}:

\begin{itemize}
\tightlist
\item
  Translates user words to text
\item
  Uses a selected computer voice to speak to users.
\item
  Interacts with users based on a script of instructions that include
  questions, commands, requests, and confirmations.
\end{itemize}

You could create modules to provide the required capabilities:

\begin{itemize}
\tightlist
\item
  \emph{Speech to text}: Translates spoken words to text the computer
  understands.
\item
  \emph{Voice UI}: Interacts with users based on stored questions,
  commands, and confirmations.
\item
  \emph{Instruction manager}: Stores and provides the application's
  questions, commands, and confirmations.
\item
  \emph{Computer voice}: Stores and provides computer voices for users
  to choose from.
\end{itemize}

The following diagram contrasts a monolithic design for the speech
recognition application with a modular design.

\begin{figure}
\centering
\includegraphics{./images/modularity-benefits-application-design-example.png}
\caption{The speech recognition application can be implemented in a
single monolithic code base or in modules, each focused on a particular
function.}
\end{figure}

Designing the app as a monolith lumps everything together. There are no
initial boundaries between the application aspects, whereas the modular
design distinguishes the aspects.

Developers can create the modules in parallel, each one with its own
particular capability. Designing applications that comprise modules
fosters writing cohesive pieces of code that represent capabilities.
Each module's capability can potentially be \emph{reused} in other
scenarios too.

For example, the \emph{Instruction manager} and \emph{Computer voice}
modules can be \emph{reused} by a navigation app.

\begin{figure}
\centering
\includegraphics{./images/modularity-benefits-module-reuse.png}
\caption{The \emph{Instruction manager} and \emph{Computer voice}
modules designed for the speech recognition app can be used (or
\emph{reused}) by a navigation app.}
\end{figure}

Here are the benefits of designing the speech recognition app as
modules:

\begin{itemize}
\tightlist
\item
  Each module represents a capability that contributes to the app's
  overall function.
\item
  The app depends on modules, that are easy to develop, test, and
  maintain.
\item
  The modules can be reused in different applications.
\end{itemize}

In conclusion, modularity has literally taken us to the moon and back.
It benefits software development too. The example speech recognition
application demonstrated how to design an app that comprises modules.

Next you'll learn how OSGi facilitates creating modules that provide and
consume services.

\section{OSGi and Modularity}\label{osgi-and-modularity}

Modularity makes writing software, especially as a team, fun! Here are
some benefits to modular development on DXP:

\begin{itemize}
\tightlist
\item
  Liferay DXP's runtime framework is lightweight, fast, and secure.
\item
  The framework uses the OSGi standard. If you have experience using
  OSGi with other projects, you can apply your existing knowledge to
  developing on DXP.
\item
  Modules publish services to and consume services from a service
  registry. Service contracts are loosely coupled from service providers
  and consumers, and the registry manages the contracts automatically.
\item
  Modules' dependencies are managed automatically by the container,
  dynamically (no restart required).
\item
  The container manages module life cycles dynamically. Modules can be
  installed, started, updated, stopped, and uninstalled while Liferay is
  running, making deployment a snap.
\item
  Only a module's classes whose packages are explicitly exported are
  publicly visible; OSGi hides all other classes by default.
\item
  Modules and packages are semantically versioned and declare
  dependencies on specific versions of other packages. This allows two
  applications that depend on different versions of the same packages to
  each depend on their own versions of the packages.
\item
  Team members can develop, test, and improve modules in parallel.
\item
  You can use your existing developer tools and environment to develop
  modules.
\end{itemize}

There are many benefits to modular software development with OSGi, and
we can only scratch the surface here. Once you start developing modules,
you might find it hard to go back to developing any other way.

\subsection{Modules}\label{modules-1}

It's time to see what module projects look like and see Liferay DXP's
modular development features in action. To keep things simple, only
project code and structure are shown: you can
\href{/docs/7-1/tutorials/-/knowledge_base/t/starting-module-development}{create
modules} like these anytime.

These modules collectively provide a command that takes a String and
uses it in a greeting. Consider it ``Hello World'' for modules.

\subsubsection{API}\label{api}

The API module is first. It defines the contract that a provider
implements and a consumer uses. Here is its structure:

\begin{itemize}
\tightlist
\item
  \texttt{greeting-api}

  \begin{itemize}
  \tightlist
  \item
    \texttt{src}

    \begin{itemize}
    \tightlist
    \item
      \texttt{main}

      \begin{itemize}
      \tightlist
      \item
        \texttt{java}

        \begin{itemize}
        \tightlist
        \item
          \texttt{com/liferay/docs/greeting/api}

          \begin{itemize}
          \tightlist
          \item
            \texttt{Greeting.java}
          \end{itemize}
        \end{itemize}
      \end{itemize}
    \end{itemize}
  \item
    \texttt{bnd.bnd}
  \item
    \texttt{build.gradle}
  \end{itemize}
\end{itemize}

Very simple, right? Beyond the Java source file, there are only two
other files: a Gradle build script (though you can use any build system
you want), and a configuration file called \texttt{bnd.bnd}. The
\texttt{bnd.bnd} file describes and configures the module:

\begin{verbatim}
Bundle-Name: Greeting API
Bundle-SymbolicName: com.liferay.docs.greeting.api
Bundle-Version: 1.0.0
Export-Package: com.liferay.docs.greeting.api
\end{verbatim}

The module's name is \emph{Greeting API}. Its symbolic name--a name that
ensures uniqueness--is \texttt{com.liferay.docs.greeting.api}. Its
semantic version is declared next, and its package is \emph{exported},
which means it's made available to other modules. This module's package
is just an API other modules can implement.

Finally, there's the Java class, which in this case is an interface:

\begin{verbatim}
package com.liferay.docs.greeting.api;

import aQute.bnd.annotation.ProviderType;

@ProviderType
public interface Greeting {

        public void greet(String name);

}
\end{verbatim}

The interface's \texttt{@ProviderType} annotation tells the service
registry that anything implementing the interface is a provider. The
interface's one method asks for a \texttt{String} and doesn't return
anything.

That's it! As you can see, creating modules is not very different from
creating other Java projects.

\subsubsection{Provider}\label{provider}

An interface only defines an API; to do something, it must be
implemented. This is what the provider module is for. Here's what a
provider module for the Greeting API looks like:

\begin{itemize}
\tightlist
\item
  \texttt{greeting-impl}

  \begin{itemize}
  \tightlist
  \item
    \texttt{src}

    \begin{itemize}
    \tightlist
    \item
      \texttt{main}

      \begin{itemize}
      \tightlist
      \item
        \texttt{java}

        \begin{itemize}
        \tightlist
        \item
          \texttt{com/liferay/docs/greeting/impl}

          \begin{itemize}
          \tightlist
          \item
            \texttt{GreetingImpl.java}
          \end{itemize}
        \end{itemize}
      \end{itemize}
    \end{itemize}
  \item
    \texttt{bnd.bnd}
  \item
    \texttt{build.gradle}
  \end{itemize}
\end{itemize}

It has the same structure as the API module: a build script, a
\texttt{bnd.bnd} configuration file, and an implementation class. The
only differences are the file contents. The \texttt{bnd.bnd} file is a
little different:

\begin{verbatim}
Bundle-Name: Greeting Impl
Bundle-SymbolicName: com.liferay.docs.greeting.impl
Bundle-Version: 1.0.0
\end{verbatim}

The bundle name, symbolic name, and version are all set similarly to the
API.

Finally, there's no \texttt{Export-Package} declaration. A client (which
is the third module you'll create) just wants to use the API: it doesn't
care how its implementation works as long as the API returns what it's
supposed to return. The client, then, only needs to declare a dependency
on the API; the service registry injects the appropriate implementation
at runtime.

Pretty cool, eh?

All that's left, then, is the class that provides the implementation:

\begin{verbatim}
package com.liferay.docs.greeting.impl;

import com.liferay.docs.greeting.api.Greeting;

import org.osgi.service.component.annotations.Component;

@Component(
    immediate = true,
    property = {
    },
    service = Greeting.class
)
public class GreetingImpl implements Greeting {

    @Override
    public void greet(String name) {
        System.out.println("Hello " + name + "!");
    }

}
\end{verbatim}

The implementation is simple. It uses the \texttt{String} as a name and
prints a hello message. A better implementation might be to use
Liferay's API to collect all the names of all the users in the system
and send each user a greeting notification, but the point here is to
keep things simple. You should understand, though, that there's nothing
stopping you from replacing this implementation by deploying another
module whose Greeting implementation's \texttt{@Component} annotation
specifies a higher service ranking property (e.g.,
\texttt{"service.ranking:Integer=100"}).

This \texttt{@Component} annotation defines three options:
\texttt{immediate\ =\ true}, an empty property list, and the service
class that it implements. The \texttt{immediate\ =\ true} setting means
that this module should not be lazy-loaded; the service registry loads
it as soon as it's deployed, instead of when it's first used. Using the
\texttt{@Component} annotation declares the class as a Declarative
Services component, which is the most straightforward way to create
components for OSGi modules. A component is a POJO that the runtime
creates automatically when the module starts.

To compile this module, the API it's implementing must be on the
classpath. If you're using Gradle, you'd add the \texttt{greetings-api}
project to your \texttt{dependencies\ \{\ ...\ \}} block. In a
\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-workspace}{Liferay
Workspace} module, the dependency looks like this:

\begin{verbatim}
compileOnly project (':modules:greeting-api')
\end{verbatim}

That's all there is to a provider module.

\subsubsection{Consumer}\label{consumer}

The consumer or client uses the API that the API module defines and the
provider module implements. DXP has many different kinds of consumer
modules.
\href{/docs/7-1/tutorials/-/knowledge_base/t/portlets}{Portlets} are the
most common consumer module type, but since they are a topic all by
themselves, this example stays simple by creating an command for the
Apache Felix Gogo shell. Note that consumers can, of course, consume
many different APIs to provide functionality.

A consumer module has the same structure as the other module types:

\begin{itemize}
\tightlist
\item
  \texttt{greeting-command}

  \begin{itemize}
  \tightlist
  \item
    \texttt{src}

    \begin{itemize}
    \tightlist
    \item
      \texttt{main}

      \begin{itemize}
      \tightlist
      \item
        \texttt{java}

        \begin{itemize}
        \tightlist
        \item
          \texttt{com/liferay/docs/greeting/command}

          \begin{itemize}
          \tightlist
          \item
            \texttt{GreetingCommand.java}
          \end{itemize}
        \end{itemize}
      \end{itemize}
    \end{itemize}
  \item
    \texttt{bnd.bnd}
  \item
    \texttt{build.gradle}
  \end{itemize}
\end{itemize}

Again, you have a build script, a \texttt{bnd.bnd} file, and a Java
class. This module's \texttt{bnd.bnd} file is almost the same as the
provider's:

\begin{verbatim}
Bundle-Name: Greeting Command
Bundle-SymbolicName: com.liferay.docs.greeting.command
Bundle-Version: 1.0.0
\end{verbatim}

There's nothing new here: you declare the same things you declared for
the provider.

Your Java class has a little bit more going on:

\begin{verbatim}
package com.liferay.docs.greeting.command;

import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Reference;

import com.liferay.docs.greeting.api.Greeting;

@Component(
    immediate = true,
    property = {
        "osgi.command.scope=greet",
        "osgi.command.function=greet"
    },
    service = Object.class
)
public class GreetingCommand {

    public void greet(String name) {
        Greeting greeting = _greeting;

        greeting.greet(name);
    }

    @Reference
    private Greeting _greeting;

}
\end{verbatim}

The \texttt{@Component} annotation declares the same attributes, but
specifies different properties and a different service. As in Java,
where every class is a subclass of \texttt{java.lang.Object} (even
though you don't need to specify it by default), in Declarative
Services, the runtime needs to know the type of class to register.
Because you're not implementing any particular type, your parent class
is \texttt{java.lang.Object}, so you must specify that class as the
service. While Java doesn't require you to specify \texttt{Object} as
the parent when you're creating a class that doesn't inherit anything,
Declarative Services does.

The two properties define a command scope and a command function. All
commands have a scope to define their context, as it's common for
multiple APIs to have similar functions, such as \texttt{copy} or
\texttt{delete}. These properties specify you're creating a command
called \texttt{greet} in a scope called \texttt{greet}. While you get no
points for imagination, this sufficiently defines the command.

Since you specified \texttt{osgi.command.function=greet} in the
\texttt{@Component} annotation, your class must have a method named
\texttt{greet}, and you do. But how does this \texttt{greet} method
work? It obtains an instance of the \texttt{Greeting} OSGi service and
invokes its \texttt{greet} method, passing in the \texttt{name}
parameter. How is an instance of the \texttt{Greeting} OSGi service
obtained? The \texttt{GreetingCommand} class declares a private service
bean, \texttt{\_greeting} of type \texttt{Greeting}. This is the OSGi
service type that the provider module registers. The \texttt{@Reference}
annotation tells the OSGi runtime to instantiate the service bean with a
service from the service registry. The runtime binds the
\texttt{Greeting} object of type \texttt{GreetingImpl} to the private
field \texttt{\_greeting}. The \texttt{greet} method uses the
\texttt{\_greeting} field value.

Just like the provider, the consumer needs to have the API on its
classpath in order to compile, but at runtime, since you've declared all
the dependencies appropriately, the container knows about these
dependencies, and provides them automatically.

If you were to
\href{/docs/7-1/tutorials/-/knowledge_base/t/starting-module-development\#building-and-deploying-a-module}{deploy
these modules to a DXP instance}, you'd be able to attach to the
\href{develop/reference/-/knowledge_base/7-1/using-the-felix-gogo-shell}{Gogo
Shell} and execute a command like this:

\begin{verbatim}
greet:greet "Captain\ Kirk"
\end{verbatim}

The shell would then return your greeting:

\begin{verbatim}
Hello Captain Kirk!
\end{verbatim}

This most basic of examples should make it clear that module-based
development is easy and straightforward. The API-Provider-Consumer
contract fosters loose coupling, making your software easy to manage,
enhance, and support.

\subsection{A Typical Liferay
Application}\label{a-typical-liferay-application}

If you look at a typical application from Liferay's source, you'll
generally find at least four modules:

\begin{itemize}
\tightlist
\item
  An API module
\item
  A Service (provider) module
\item
  A Test module
\item
  A Web (consumer) module
\end{itemize}

This is exactly what you'll find for some smaller applications, like the
Mentions application that lets users mention other users with the
\texttt{@username} nomenclature in comments, blogs, or other
applications. Larger applications like the Documents and Media library
have more modules. In the case of the Documents and Media library, there
are separate modules for different document storage back-ends. In the
case of the Wiki, there are separate modules for different Wiki engines.

Encapsulating capability variations as modules facilitates
extensibility. If you have a document storage back-end that Liferay
doesn't yet support, you can implement Liferay's document storage API
for your solution by developing a module for it and thus extend
Liferay's Documents and Media library. If there's a Wiki dialect that
you like better than what Liferay's wiki provides, you can write a
module for it and extend Liferay's wiki.

Are you excited yet? Are you ready to start developing? Here are some
resources for you to learn more.

\subsection{Related Topics}\label{related-topics-332}

\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-ide}{Liferay IDE}

\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-workspace}{Liferay
Workspace}

\href{/docs/7-1/tutorials/-/knowledge_base/t/blade-cli}{Blade CLI}

\href{/docs/7-1/tutorials/-/knowledge_base/t/maven}{Maven}

\href{/docs/7-1/tutorials/-/knowledge_base/t/migrating-existing-code-to-liferay-7}{Planning
a Plugin Upgrade to Liferay 7}

\section{Leveraging Dependencies}\label{leveraging-dependencies}

Using an OSGi manifest, a module declares the Java packages it consumes
and shares. The manifest's \texttt{Import-Package} and
\texttt{Export-Package} settings expose this information. As you
determine whether to use a particular module, you know up-front what it
offers and what it depends on. As an improvement over Java EE, OSGi
takes away dependency guesswork.

This part of the tutorial explains:

\begin{itemize}
\item
  \hyperref[how-dependencies-work]{How dependencies work}
\item
  \hyperref[dependencies-facilitate-modular-development]{How
  dependencies facilitate modular development}
\end{itemize}

Let's start by learning how dependencies operate in 7.0.

\subsection{How Dependencies Work}\label{how-dependencies-work}

Each module's manifest lists the packages the module depends on. Using a
build environment such as Gradle, Maven, or Ant/Ivy, you can set
dependencies on each package's module. At build time, the dependency
framework verifies the entire dependency chain, downloading all newly
specified modules. The same thing happens at runtime: the OSGi runtime
knows exactly which modules depend on which other modules (failing fast
if any dependency is unmet). Dependency management is explicit and
enforced automatically upfront.

\noindent\hrulefill

\textbf{Note}: Since Liferay 7.0, all of what was in Liferay Portal 6
and its apps has been refactored into OSGi modules. The
\texttt{portal-service} API (the main API in Liferay Portal 6) has been
replaced by the \texttt{portal-kernel} module (7.0's kernel API) and
many small, highly-cohesive modules that provide frameworks, utilities,
apps, and more. Not only do Liferay DXP modules depend on third-party
modules but they also depend on each other. You can likewise leverage
dependencies in your projects. Whether you're developing new OSGi
modules or continuing to develop traditional apps, you need only set
dependencies on modules whose packages you need.

\noindent\hrulefill

Versioning is independent for each module and its exported packages. You
can use a specific package version by depending on the version of the
module that exports it. And you're free to use a mix of modules in the
versions you want (but remember, ``With great power comes great
responsibility,'' so unless you really know what you're doing, use the
same version of each module you depend on).

For all its modules, Liferay DXP uses \href{http://semver.org}{Semantic
Versioning}. It's a standard that enables API authors to communicate
programmatic compatibility of a package or module automatically as it
relates to dependent consumers and API implementations. If a package is
programmatically (i.e., semantically) incompatible with a project, bnd
(used in Liferay Workspace and projects created from
\href{/docs/7-1/reference/-/knowledge_base/r/project-templates}{Liferay
project templates}) fails that project's build immediately. Developers
not using bnd can check package versions manually in each dependency
module's manifest.

Semantic Versioning also gives you flexibility to specify a version
range of packages and modules to depend on. In other words, if several
versions of a package work for an app, you can configure the app to use
any of them. What's more, bnd automatically determines the semantically
compatible range of each package a module depends on and records the
range to the module's manifest.

On testing your project, you might find a new version of a dependency
package has bugs or behaves differently than you'd like. No problem. You
can adjust the package version range to include versions up to, but not
including, the one you don't want.

Next you want to consider when to modularize existing apps and when to
combine modules to create apps.

\subsection{Dependencies Facilitate Modular
Development}\label{dependencies-facilitate-modular-development}

Liferay DXP's support of dependencies and semantic versioning
facilitates modular development. The dependency frameworks enable you to
use modules and link them together. You can use these modules throughout
your organization and distribute them to others. Liferay's integration
with dependency management frees you to modularize existing apps and
develop apps that combine modules. It's a powerful and fun way to
develop apps on Liferay.

Here are some general steps to consider when modularizing an existing
app:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{Start by putting the entire app in a single module}: This is a
  minimal first step that acquaints you with Liferay's module framework.
  You'll gain confidence as you build, deploy, and test your app in an
  environment of your choice, such as a
  \href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-workspace}{Liferay
  Workspace}, Gradle, or Maven
  \href{/docs/7-1/reference/-/knowledge_base/r/project-templates}{project}.
\item
  \textbf{Split the front-end from the back-end}: Modularizing front-end
  portlets and servlets and back-end implementations (e.g.,
  \href{/docs/7-1/tutorials/-/knowledge_base/t/service-builder}{Service
  Builder} or OSGi component) is a logical next step. This enables each
  code area to evolve separately and allows for varying implementations.
\item
  \textbf{Extract non-essential features to modules}: You may have
  functionality or API extensions that need not be tied to an app's core
  codebase. They can be refactored as independent modules that implement
  APIs you provide. Examples might be connectors to third-party systems
  or support for various data export/import formats.
\end{enumerate}

The principles listed above also apply to developing new modular-based
apps. As you design an app, consider possible implementation variations
with respect to its features, front-end, and back-end. Encapsulate the
variations using APIs. Then develop the APIs and implementations as
separate modules. You can wire them together using dependencies.

\textbf{Liferay's Blogs application} exemplifies modularization in the
manner we've described:

\textbf{API}:

\begin{itemize}
\tightlist
\item
  \texttt{blogs-api} - Encapsulates the core implementation
\end{itemize}

\textbf{Back-end}:

\begin{itemize}
\tightlist
\item
  \texttt{blogs-service} - Implements \texttt{blogs-api}
\end{itemize}

\textbf{Front-end}:

\begin{itemize}
\tightlist
\item
  \texttt{blogs-web} - Provides the app's UI
\end{itemize}

\textbf{Non-essential features and extensions}:

\begin{itemize}
\item
  \texttt{blogs-editor-configuration} - Extends the
  \texttt{portal-kernel} module for extending editors
\item
  \texttt{blogs-recent-bloggers-web} - Provides the Recent Bloggers app
\item
  \texttt{blogs-item-selector-api} - Encapsulates the item-selector
  implementation
\item
  \texttt{blogs-item-selector-web} - Renders the Blogs app's
  item-selector
\item
  \texttt{blogs-layout-prototype} - Creates a Page Template showcasing
  blog entries
\end{itemize}

The Blogs app, like many modular apps, separates concerns into modules.
In this way, front-end developers concentrate on front-end code,
back-end developers concentrate on that code, and so on. These logical
boundaries free developers to design, implement, and test the modules
independently.

As you develop app-centered modules, you can consider bundling them with
your app (e.g., as part of a Liferay Marketplace app). Including them as
part of the app is convenient for the consumer. By bundling a module
with an app, however, you're committing to the app's release schedule.
In other words, you can't directly deploy a new version of a module for
the app--you must release it as part of the app's next release.

So far, you've learned how dependencies and Semantic Versioning work.
You've considered guidelines for modularizing existing apps and creating
new modular apps. Now, to add to the momentum around OSGi and
modularity, explore
\href{osgi-services-and-dependency-injection-with-declarative-services}{OSGi
Services and dependency injection using OSGi Declarative Services}.

\noindent\hrulefill

If you visited this tutorial as a part of the Learning Path
\href{/docs/7-1/tutorials/-/knowledge_base/t/from-liferay-6-to-liferay-7}{From
Liferay Portal 6 to 7.1}, you can continue with the next topic:
\href{/docs/7-1/tutorials/-/knowledge_base/t/osgi-services-and-dependency-injection-with-declarative-services}{OSGi
Services and dependency injection using OSGi Declarative Services}.

\noindent\hrulefill

\subsection{Related Topics}\label{related-topics-333}

\href{/docs/7-1/tutorials/-/knowledge_base/t/configuring-dependencies}{Configuring
Dependencies}

\href{/docs/7-1/tutorials/-/knowledge_base/t/importing-packages}{Importing
Packages}

\href{/docs/7-1/tutorials/-/knowledge_base/t/exporting-packages}{Exporting
Packages}

\section{OSGi Services and Dependency Injection with Declarative
Services}\label{osgi-services-and-dependency-injection-with-declarative-services}

In Liferay DXP, the OSGi framework registers objects as \emph{services}.
Each service offers functionality and can leverage functionality other
services provide. The OSGi Services model supports a collaborative
environment for objects.

Declarative Services (DS) provides a service component model on top of
OSGi Services. DS service components are marked with the
\texttt{@Component} annotation and implement or extend a service class.
Service components can refer to and use each other's services. The
Service Component Runtime (SCR) registers component services and handles
binding them to other components that reference them.

Here's how the ``magic'' happens:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{Service registration:} On installing a module that contains a
  service component, the SCR creates a component configuration that
  associates the component with its specified service type and stores it
  in a service registry.
\item
  \textbf{Service reference handling:} On installing a module whose
  service component references another service type, the SCR searches
  the registry for a component configuration that matches the service
  type and on finding a match binds an instance of that service to the
  referring component.
\end{enumerate}

It's publish, find, and bind at its best!

How do you use DS to register and bind services? Does it involve
creating XML files? No, it's much easier than that. You use two
annotations: \texttt{@Component} and \texttt{@Reference}.

\begin{itemize}
\item
  \href{https://osgi.org/javadoc/r6/residential/org/osgi/service/component/annotations/Component.html}{\texttt{@Component}}:
  Add this annotation to a class definition to make the class a
  component--a service provider.
\item
  \href{ttps://osgi.org/javadoc/r6/residential/org/osgi/service/component/annotations/Reference.html}{\texttt{@Reference}}:
  Add this annotation to a field to inject it with a service that
  matches the field's type.
\end{itemize}

The \texttt{@Component} annotation makes the class an OSGi component.
Setting a \texttt{service} property to a particular service type in the
annotation, allows other components to reference the service component
by the specified service type.

For example, the following class is a service component of type
\texttt{SomeApi.class}.

\begin{verbatim}
@Component(
    service = SomeApi.class
)
public class Service1 implements SomeApi {

   ...
}
\end{verbatim}

On deploying this class's module, the SCR creates a component
configuration that associates the class with the service type
\texttt{SomeApi}.

Specifying a service reference is easy too. Applying the
\texttt{@Reference} annotation to a field marks it to be injected with a
service matching the field's type.

\begin{verbatim}
@Reference
SomeApi _someApi;
\end{verbatim}

On deploying this class's module, the SCR finds a component
configuration of the class type \texttt{SomeApi} and binds the service
to this referencing component class.

\noindent\hrulefill

\textbf{Note:} The \texttt{@Reference} annotation can only be used in a
class that is annotated with \texttt{@Component}. That is, only a
Declarative Services component can use \texttt{@Reference} to bind to an
OSGi service.

\noindent\hrulefill

At build time in modules created from
\href{/docs/7-1/reference/-/knowledge_base/r/project-templates}{Liferay
project templates}, bnd creates a \emph{component description} file for
each module's components automatically. The file specifies the
component's services, dependencies, and activation characteristics. On
module deployment, the OSGi framework reads the component description to
create the component and manage its dependency on other components.

The SCR stands ready to pair service components with each other. For
each referencing component, the SCR binds an instance of the targeted
service to it.

As an improvement over dependency injection with Spring, OSGi
Declarative Services supports dynamic dependency injection. You can
create and publish service components for other classes to use. You can
update the components and even publish alternative component
implementations for a service. This kind of dynamism is a powerful part
of Liferay DXP.

\noindent\hrulefill

If you visited this tutorial as a part of the Learning Path
\href{/docs/7-1/tutorials/-/knowledge_base/t/from-liferay-6-to-liferay-7}{From
Liferay Portal 6 to 7.1}, you can with the next topic:
\href{/docs/7-1/tutorials/-/knowledge_base/t/dynamic-deployment}{dynamic
deployment in OSGi}.

\section{Dynamic Deployment}\label{dynamic-deployment}

In OSGi, all components, Java classes, resources, and descriptors are
deployed via modules. The \texttt{MANIFEST.MF} file describes the
module's physical characteristics, such as the packages it exports and
imports. The module's component description files specify its functional
characteristics (i.e., the services its components offer and consume).
Also modules and their components have their own lifecycles and
administrative APIs. Declarative Services and shell tools give you
fine-grained control over module and component deployment.

Since a module's contents depend on its activation, consider the
activation steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \emph{Installation}: Copying the module JAR into Liferay DXP's
  \texttt{{[}Liferay\ Home{]}/deploy} folder installs the module to the
  OSGi framework, marking the module \texttt{INSTALLED}.
\item
  \emph{Resolution}: Once all the module's requirements are met (e.g.,
  all packages it imports are available), the framework publishes the
  module's exported packages and marks the module \texttt{RESOLVED}.
\item
  \emph{Activation}: Modules are activated \emph{eagerly} by default.
  That is, they're started in the framework and marked \texttt{ACTIVE}
  on resolution. An active module's components are enabled. If a module
  specifies a \texttt{lazy} activation policy, as shown in the manifest
  header below, it's activated only after another module requests one of
  its classes.

\begin{verbatim}
Bundle-ActivationPolicy: lazy
\end{verbatim}
\end{enumerate}

The figure below illustrates the module lifecycle.

\begin{figure}
\centering
\includegraphics{./images/module-state-diagram.png}
\caption{This state diagram illustrates the module lifecycle.}
\end{figure}

The
\href{/docs/7-1/reference/-/knowledge_base/r/using-the-felix-gogo-shell}{Apache
Felix Gogo Shell} lets you manage the module lifecycle. You can
install/uninstall modules and start/stop them. You can update a module
and notify dependent modules to use the update. Liferay's tools,
including
\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-ide}{Liferay Dev
Studio DXP},
\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-workspace}{Liferay
Workspace}, and
\href{/docs/7-1/tutorials/-/knowledge_base/t/blade-cli}{Blade CLI} offer
similar shell commands that use the OSGi Admin API.

On activating a module, its components are enabled. But only
\emph{activated} components can be used. Component activation requires
all its referenced services be satisfied. That is, all services it
references must be registered. The highest ranked service that matches a
reference is bound to the component. When the container finds and binds
all the services the component references, it registers the component.
It's now ready for activation.

Components can use \emph{delayed} (default) or \emph{immediate}
activation policies. To specify immediate activation, the developer adds
the attribute \texttt{immediate=true} to the \texttt{@Component}
annotation.

\begin{verbatim}
@Component(
    immediate = true,
    ...
)
\end{verbatim}

Unless immediate activation is specified, the component's activation is
delayed. That is, the component's object is created and its classes are
loaded once the component is requested. In this way, delayed activation
can improve startup times and conserve resources.

Gogo Shell's
\href{http://felix.apache.org/documentation/subprojects/apache-felix-service-component-runtime.html\#shell-command}{Service
Component Runtime commands} let you manage components:

\begin{itemize}
\item
  \texttt{scr:list\ {[}bundleID{]}}: Lists the module's (bundle's)
  components.
\item
  \texttt{scr:info\ {[}componentID\textbar{}fullClassName{]}}: Describes
  the component, including its status and the services it provides.
\item
  \texttt{scr:enable\ {[}componentID\textbar{}fullClassName{]}}: Enables
  the component.
\item
  \texttt{scr:disable\ {[}componentID\textbar{}fullClassName{]}}:
  Disables the component. It's disabled on the server (or current server
  node in a cluster) until the server is restarted.
\end{itemize}

Service references are static and reluctant by default. That is, an
injected service remains bound to the referencing component until the
service is disabled. Alternatively, you can specify \emph{greedy}
service policies for references. Every time a higher ranked matching
service is registered, the framework unbinds the lower ranked service
from the component (whose service policy is greedy) and binds the new
service in its place automatically. Here's a \texttt{@Reference}
annotation that uses a greedy policy:

\begin{verbatim}
@Reference(policyOption = ReferencePolicyOption.GREEDY)
\end{verbatim}

Declarative Services annotations let you specify component activation
and service policies. Gogo Shell commands let you control modules and
components.

\noindent\hrulefill

If you visited this tutorial as a part of the Learning Path
\href{/docs/7-1/tutorials/-/knowledge_base/t/from-liferay-6-to-liferay-7}{From
Liferay Portal 6 to 7.1}, you can go
\href{/docs/7-1/tutorials/-/knowledge_base/t/more-ways-osgi-improves-development-on-liferay}{here}
to continue it.

\noindent\hrulefill

\subsection{Related Topics}\label{related-topics-334}

\href{/docs/7-1/tutorials/-/knowledge_base/t/starting-module-development}{Starting
Module Development}

\href{migrating-existing-code-to-liferay-7/migrating-existing-code-to-liferay-7}{Planning
Plugin Upgrades}

\section{Learning More about OSGi}\label{learning-more-about-osgi}

There is much more to learn about developing apps using OSGi. Several
resources are listed below and many more abound. To make the best of
your time, however, avoid OSGi service articles that explain techniques
that are older and more complicated than Declarative Services.

Developers new to OSGi should check out these resources:

\begin{itemize}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/introduction-to-liferay-development}{Introduction
  to Liferay Development}: For using OSGi to develop on Liferay DXP.
\item
  \href{http://enroute.osgi.org/}{OSGi enRoute} is a site the OSGi
  Alliance provides to the OSGi community. Its
  \href{https://enroute.osgi.org/Tutorial/}{Tutorials} provide hands-on
  experience with OSGi modules and Declarative Services.
\item
  \href{https://www.osgi.org/developer}{OSGi Alliance's Developer}
  section explains OSGi's architecture and modularity.
\end{itemize}

If you're ready to dive deep into OSGi, read the OSGi specifications.
They're well-written and provide comprehensive details on all that OSGi
offers.
\href{https://osgi.org/download/r6/osgi.cmpn-6.0.0.pdf}{\emph{The OSGi
Alliance OSGi Compendium: Release 6}} specifies the following services
that 7.0 leverages extensively.

\begin{itemize}
\item
  \emph{Declarative Services Specification}
\item
  \emph{Configuration Admin Service Specification}: For modifying
  deployed bundles. Since Configuration Admin services are already
  integrated with Declarative Services, however, Liferay developers need
  not use the low-level API.
\item
  \emph{Metatype Service Specification}: For describing attribute types
  as metadata.
\end{itemize}

\chapter{OSGi Basics for Liferay
Development}\label{osgi-basics-for-liferay-development}

Liferay leverages the OSGi framework to provide a development
environment for modular applications. There are many OSGi best practices
that Liferay DXP follows to provide an easy-to-develop-for platform.
Here, you're introduced to some OSGi basics and common Liferay best
practices for developing OSGi bundles (modules).

\section{Liferay Portal Classloader
Hierarchy}\label{liferay-portal-classloader-hierarchy}

All Liferay DXP applications live in its OSGi container. Portal is a web
application deployed on your application server. Portal's Module
Framework bundles (modules) live in the OSGi container and have
classloaders. All the classloaders from Java's Bootstrap classloader to
classloaders for bundle classes and JSPs are part of a hierarchy.

This tutorial explains Liferay's classloader hierarchy and describes how
it works in the following contexts:

\begin{itemize}
\tightlist
\item
  Web application, such as Liferay Portal, deployed on the app server
\item
  OSGi bundle deployed in the Module Framework
\end{itemize}

The following diagram shows Liferay's classloader hierarchy.

\begin{figure}
\centering
\includegraphics{./images/portal-classloader-hierarchy.png}
\caption{0: Here is Liferay's classloader hierarchy.}
\end{figure}

Here are the classloader descriptions:

\begin{itemize}
\item
  \textbf{Bootstrap}: The JRE's classes (from packages \texttt{java.*})
  and Java extension classes (from \texttt{\$JAVA\_HOME/lib/ext}). No
  matter the context, loading all \texttt{java.*} classes is delegated
  to the Bootstrap classloader.
\item
  \textbf{System}: Classes configured on the \texttt{CLASSPATH} and or
  passed in via the application server's Java classpath (\texttt{-cp} or
  \texttt{-classpath}) parameter.
\item
  \textbf{Common}: Classes accessible globally to web applications on
  the application server.
\item
  \textbf{Web Application}: Classes in the application's
  \texttt{WEB-INF/classes} folder and \texttt{WEB-INF/lib/*.jar}.
\item
  \textbf{Module Framework}: Liferay's OSGi module framework classloader
  which is used to provide controlled isolation for the module framework
  bundles.
\item
  \textbf{bundle}: Classes from a bundle's packages or from packages
  other bundles export.
\item
  \textbf{JSP}: A classloader that aggregates the following bundle and
  classloaders:

  \begin{itemize}
  \tightlist
  \item
    Bundle that contains the JSPs' classloader
  \item
    JSP servlet bundle's classloader
  \item
    Javax Expression Language (EL) implementation bundle's classloader
  \item
    Javax JSTL implementation bundle's classloader
  \end{itemize}
\item
  \textbf{Service Builder}: Service Builder classes
\end{itemize}

The classloader used depends on context. Classloading rules vary between
application servers. Classloading in web applications and OSGi bundles
differs too. In all contexts, however, the Bootstrap classloader loads
classes from \texttt{java.*} packages.

Classloading from a web application perspective is up next.

\subsection{Web Application Classloading
Perspective}\label{web-application-classloading-perspective}

Application servers dictate where and in what order web applications,
such as Liferay DXP, search for classes and resources. Application
servers such as
\href{https://tomcat.apache.org/tomcat-7.0-doc/class-loader-howto.html}{Apache
Tomcat} enforce the following default search order:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Bootstrap classes
\item
  Web app's \texttt{WEB-INF/classes}
\item
  web app's \texttt{WEB-INF/lib/*.jar}
\item
  System classloader
\item
  Common classloader
\end{enumerate}

First, the web application searches Bootstrap. If the class/resource
isn't there, the web application searches its own classes and JARs. If
the class/resource still isn't found, it checks the System classloader
and then Common classloader. Except for the web application checking its
own classes and JARs, it searches the hierarchy in parent-first order.

Application servers such as
\href{https://docs.oracle.com/cd/E19501-01/819-3659/beadf/index.html}{Oracle
WebLogic} and IBM WebSphere have additional classloaders. They may also
have a different classloader hierarchy and search order. Consult your
application server's documentation for classloading details.

\subsection{Other Classloading
Perspectives}\label{other-classloading-perspectives}

The
\href{/docs/7-1/tutorials/-/knowledge_base/t/bundle-classloading-flow}{Bundle
Classloading Flow} tutorial explains classloading from an OSGi bundle
perspective.

Classloading for JSPs and Service Builder classes is similar to that of
web applications and OSGi bundle classes.

You now know Liferay DXP's classloading hierarchy, understand it in
context of web applications, and have references to information on other
classloading perspectives.

\subsection{Related Topics}\label{related-topics-335}

\href{/docs/7-1/tutorials/-/knowledge_base/t/bundle-classloading-flow}{Bundle
Classloading Flow}

\section{Bundle Classloading Flow}\label{bundle-classloading-flow}

The OSGi container searches several places for imported classes. It's
important to know where it looks and in what order. Liferay DXP's
classloading flow for OSGi bundles follows the OSGi Core specification.
It's straightforward, but complex. The figure below illustrates the flow
and this tutorial walks you through it.

\begin{figure}
\centering
\includegraphics{./images/bundle-classloading-flow-chart.png}
\caption{0: This flow chart illustrates classloading in a bundle.}
\end{figure}

Here is the algorithm for classloading in a bundle:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  If the class is in a \texttt{java.*} package, delegate loading to the
  parent classloader. Otherwise, continue.
\item
  If the class is in the OSGi Framework's boot delegation list, delegate
  loading to the parent classloader. Otherwise, continue.
\item
  If the class is in one of the packages the bundle imports from a wired
  exporter, the exporting bundle's classloader loads it. A \emph{wired
  exporter} is another bundle's classloader that previously loaded the
  package. If the class isn't found, continue.
\item
  If the class is imported by one of the bundle's required bundles, the
  required bundle's classloader loads it.
\item
  If the class is in the bundle's classpath (manifest header
  \texttt{Bundle-ClassPath}), the bundle's classloader loads it.
  Otherwise, continue.
\item
  If the class is in the bundle's fragments classpath, the bundle's
  classloader loads it.
\item
  If the class is in a package that's dynamically imported using
  \texttt{DynamicImport-Package} and a wire is established with the
  exporting bundle, the exporting bundle's classloader loads it.
  Otherwise, the class isn't found.
\end{enumerate}

Congratulations! Now you know how Liferay DXP finds and loads classes
for OSGi bundles.

\section{Importing Packages}\label{importing-packages}

Your modules often must use Java classes from packages
\href{/docs/7-1/tutorials/-/knowledge_base/t/exporting-packages}{exported}
by other modules. When a module is set up to import, the OSGi framework
finds other registered modules that export the needed packages and wires
them to the importing module. At run time, the importing module gets the
class from the wired module that exports the class's package.

For this to happen, a module must specify the
\href{https://bnd.bndtools.org/heads/import_package.html}{\texttt{Import-Package}}
OSGi manifest header with a comma-separated list of the Java packages it
needs. For example, if a module needs classes from the
\texttt{javax.portlet} and \texttt{com.liferay.portal.kernel.util}
packages, it must specify them like so:

\begin{verbatim}
Import-Package: javax.portlet,com.liferay.portal.kernel.util,*
\end{verbatim}

The \texttt{*} character represents all packages that the module refers
to explicitly. Bnd detects the referenced packages.

Import packages must sometimes be specified manually, but not always.
Conveniently, Liferay DXP project templates and tools automatically
detect the packages a module uses and add them to the package imports in
the module JAR's manifest. Here are the different package import
scenarios:

\begin{itemize}
\item
  \hyperref[automatic-package-import-generation]{Automatic Package
  Import Generation}
\item
  \hyperref[manually-adding-package-imports]{Manually Adding Package
  Imports}
\end{itemize}

Let's explore how package imports are specified in these scenarios.

\subsection{Automatic Package Import
Generation}\label{automatic-package-import-generation}

\href{/docs/7-1/reference/-/knowledge_base/r/project-templates}{Gradle
and Maven module projects} created using
\href{/docs/7-1/tutorials/-/knowledge_base/t/blade-cli}{Blade CLI},
\href{/docs/7-1/tutorials/-/knowledge_base/t/maven}{Liferay's Maven
archetypes}, or
\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-ide}{Liferay Dev
Studio DXP} use \href{http://bnd.bndtools.org/}{bnd}. On building such a
project's module JAR, bnd detects the packages the module uses and
generates a \texttt{META-INF/MANIFEST.MF} file whose
\texttt{Import-Package} header specifies the packages.

\noindent\hrulefill

\textbf{Note}: Liferay's Maven module archetypes use the
\texttt{bnd-maven-plugin}. Liferay's Gradle module project templates use
\href{https://github.com/TomDmitriev/gradle-bundle-plugin}{a third-party
Gradle plugin} to invoke bnd.

\noindent\hrulefill

For example, suppose you're developing a Liferay module using Maven or
Gradle. In most cases, you specify your module's dependencies in your
\texttt{pom.xml} or \texttt{build.gradle} file. At build time, the Maven
or Gradle bundle plugin reads your \texttt{pom.xml} or
\texttt{build.gradle} file and bnd adds the required
\texttt{Import-Package} headers to your module JAR's
\texttt{META-INF/MANIFEST.MF}.

Here's an example dependencies section from a module's
\texttt{build.gradle} file:

\begin{verbatim}
dependencies {
    compileOnly group: "com.liferay.portal", name: "com.liferay.portal.kernel", version: "2.0.0"
    compileOnly group: "javax.portlet", name: "portlet-api", version: "2.0"
    compileOnly group: "org.osgi", name: "org.osgi.service.component.annotations", version: "1.3.0"
}
\end{verbatim}

And here's the \texttt{Import-Package} header that's generated in the
module JAR's \texttt{META-INF/MANIFEST.MF} file:

\begin{verbatim}
Import-Package: com.liferay.portal.kernel.portlet.bridges.mvc;version=
"[1.0,2)",com.liferay.portal.kernel.util;version="[7.0,8)",javax.nami
ng,javax.portlet;version="[2.0,3)",javax.servlet,javax.servlet.http,j
avax.sql
\end{verbatim}

Note that your build file need only specify JAR file dependencies. bnd
examines your module's class path to determine which packages from those
JAR files contain classes your application uses and imports the
packages. The examination includes all classes found in the class
path--even those from embedded
\href{/docs/7-1/tutorials/-/knowledge_base/t/adding-third-party-libraries-to-a-module}{third
party library JARs}.

Regarding classes used by a traditional Liferay plugin WAR,
\href{/docs/7-1/tutorials/-/knowledge_base/t/using-the-wab-generator}{Liferay's
WAB Generator} detects their use in the WAR's JSPs, descriptor files,
and classes (in \texttt{WEB-INF/classes} and embedded JARs). The WAB
Generator searches the \texttt{web.xml}, \texttt{liferay-web.xml},
\texttt{portlet.xml}, \texttt{liferay-portlet.xml}, and
\texttt{liferay-hook.xml} descriptor files. It adds package imports for
classes that are neither found in the plugin's \texttt{WEB-INF/classes}
folder nor in embedded JARs.

\noindent\hrulefill

\textbf{Note:} Packages for Java APIs, such as Java Portlet, aren't
semantically versioned but have Portable Java Contracts. Each API's
contract specifies the JSR it satisfies. Modules that use these APIs
must specify requirements on the API contracts. The contract requirement
specifies your module's relationship with the imported API packages. If
the system you're running does \emph{not} provide the exact contract,
your module does not resolve. Resolving the missing package is better
than handling an incompatibility failure during execution.

\begin{itemize}
\item
  \textbf{Blade CLI and Liferay Dev Studio DXP module projects} specify
  Portable Java Contracts automatically! For example, if your Blade CLI
  or Liferay Dev Studio DXP module uses the Java Portlet API and you
  compile against the Java Portlet 2.0 artifact, a contract requirement
  for the package is added to your module's manifest.
\item
  \textbf{Module projects that use bnd but are not created using Blade
  CLI or Liferay Dev Studio DXP} must specify contracts in their
  \texttt{bnd.bnd} file. For example, here are contract instructions for
  Java Portlet and Java Servlet APIs:

\begin{verbatim}
-contract: JavaPortlet,JavaServlet
\end{verbatim}

  At build time, bnd adds the contract instructions to your module's
  manifest. It adds a requirement for the first version of the API found
  in your classpath and \emph{removes} version range information from
  \texttt{Import-Package} entries for corresponding API packages---the
  package version information isn't needed.
\item
  \textbf{Projects that don't use bnd} must specify contracts in their
  module manifest. For example, here's the specified contract for
  \texttt{JavaPortlet} 2.0, which goes in your
  \texttt{META-INF/MANIFEST.MF} file:

\begin{verbatim}
Import-Package: javax.portlet
Require-Capability: osgi.contract;filter:=(&(osgi.contract=JavaPortlet)(version=2.0))
\end{verbatim}
\end{itemize}

For Portable Java Contract details, see
\href{https://www.osgi.org/portable-java-contract-definitions/}{Portable
Java Contract Definitions}.

\noindent\hrulefill

\noindent\hrulefill

\textbf{Note:} Liferay DXP 7.1 GA1 exports the Java Portlet 2.0 API.
Until Java Portlet 3.0 API is supported, make sure to use the 2.0
version.

\noindent\hrulefill

\subsection{Manually Adding Package
Imports}\label{manually-adding-package-imports}

The WAB Generator and bnd don't add package imports for classes
referenced in these places:

\begin{itemize}
\tightlist
\item
  Unrecognized descriptor file
\item
  Custom or unrecognized descriptor element or attribute
\item
  Reflection code
\item
  Class loader code
\end{itemize}

In such cases, you must manually determine these packages and specify an
\texttt{Import-Package} OSGi header that includes these packages and the
packages that Bnd detects automatically. The \texttt{Import-Package}
header belongs in the location appropriate to your project type:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.2727}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.7273}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Project type
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\texttt{Import-Package} header location
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Module (uses bnd) & \texttt{{[}project{]}/bnd.bnd} \\
Module (doesn't use bnd) &
\texttt{{[}module\ JAR{]}/META-INF/MANIFEST.MF} \\
Traditional Liferay plugin WAR &
\texttt{WEB-INF/liferay-plugin-package.properties} \\
\end{longtable}

Here's an example of adding a package called
\texttt{com.liferay.docs.foo} to the list of referenced packages that
Bnd detects automatically:

\begin{verbatim}
Import-Package:\
 com.liferay.docs.foo,\
 *
\end{verbatim}

\noindent\hrulefill

\textbf{Note:} The
\href{/docs/7-1/tutorials/-/knowledge_base/t/using-the-wab-generator}{WAB
Generator} refrains from adding WAR project embedded third-party JARs to
a WAB if
\href{/docs/7-1/tutorials/-/knowledge_base/t/resolving-a-plugins-dependencies\#understanding-excluded-jars}{Liferay
DXP already exports the JAR's packages}.

If your WAR requires a different version of a third-party package that
Liferay DXP exports, specify that package in your
\texttt{Import-Package:} list. Then if the package provider is an OSGi
module, publish its exported packages by deploying the module. If the
package provider is not an OSGi module, follow\\
the instructions for
\href{/docs/7-1/tutorials/-/knowledge_base/t/adding-third-party-libraries-to-a-module}{adding
third-party libraries}.

\noindent\hrulefill

Please see the
\href{https://bnd.bndtools.org/heads/import_package.html}{\texttt{Import-Package}}
header documentation for more information.

Congratulations! Now you can import all kinds of packages for your
modules and plugins to use.

\subsection{Related Topics}\label{related-topics-336}

\href{/docs/7-1/tutorials/-/knowledge_base/t/configuring-dependencies}{Configuring
Dependencies}

\href{/docs/7-1/tutorials/-/knowledge_base/t/resolving-a-plugins-dependencies}{Resolving
a Plugin's Dependencies}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-the-wab-generator}{Using
the WAB Generator}

\href{/docs/7-1/tutorials/-/knowledge_base/t/tooling}{Tooling}

\section{Exporting Packages}\label{exporting-packages}

An OSGi module's Java packages are private by default. To expose a
package, you must explicitly export it. This way you share only the
classes you want to share. Exporting a package in your OSGi module JAR's
manifest makes all the package's classes available for other modules to
\href{/docs/7-1/tutorials/-/knowledge_base/t/importing-packages}{import}.

To export a package, add it to your module's or plugin's
\texttt{Export-Package} OSGi header. A header exporting
\texttt{com.liferay.petra.io} and \texttt{com.liferay.petra.io.unsync}
would look like this:

\begin{verbatim}
Export-Package:\
com.liferay.petra.io,\
com.liferay.petra.io.unsync
\end{verbatim}

The correct location for the header depends on your project's type:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.2727}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.7273}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Project Type
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\texttt{Export-Package} header location
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Module (uses bnd) & \texttt{{[}project{]}/bnd.bnd} \\
Module (doesn't use bnd) &
\texttt{{[}module\ JAR{]}/META-INF/MANIFEST.MF} \\
Traditional Liferay plugin WAR &
\texttt{WEB-INF/liferay-plugin-package.properties} \\
\end{longtable}

Module projects created using
\href{/docs/7-1/tutorials/-/knowledge_base/t/blade-cli}{Blade CLI},
\href{/docs/7-1/tutorials/-/knowledge_base/t/maven}{Liferay's Maven
archetypes}, or
\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-ide}{Liferay Dev
Studio DXP} use \href{http://bnd.bndtools.org/}{bnd}. On building such a
project's module JAR, bnd propagates the OSGi headers from the project's
\texttt{bnd.bnd} file to the JAR's \texttt{META-INF/MANIFEST.MF}.

In module projects that don't use bnd, you must manually add package
exports to an \texttt{Export-Package} header in the module JAR's
\texttt{META-INF/MANIFEST.MF}.

In traditional Liferay plugin WAR projects, you must add package exports
to an \texttt{Export-Package} header in the project's
\texttt{liferay-plugin-package.properties}. On copying the WAR into the
\texttt{{[}Liferay\ Home{]}/deploy} folder, the
\href{/docs/7-1/tutorials/-/knowledge_base/t/using-the-wab-generator}{WAB
Generator} propagates the OSGi headers from the WAR's
\texttt{liferay-plugin-package.properties} file to the
\texttt{META-INF/MANIFEST.MF} file in the generated Web Application
Bundle (WAB).

\noindent\hrulefill

\textbf{Note}: bnd makes a module's exported packages
\emph{substitutable}. That is, the OSGi framework can substitute your
module's exported package with a compatible package of the same name,
but potentially different version, that's exported from a different
module. bnd enables this for your module by automatically making your
module import every package it exports. In this way, your module can
work on its own, but can also work in conjunction with modules that
provide a different (compatible) version, or even the same version, of
the package. A package from another module might provide better
``wiring'' opportunities with other modules.
\href{http://blog.osgi.org/2007/04/importance-of-exporting-nd-importing.html}{Peter
Kriens' blog post} provides more details on how substitutable exports
works.

\noindent\hrulefill

\noindent\hrulefill

\textbf{Important:} Don't export the same package from different JARs.
Multiple exports of the same package leads to ``split package'' issues,
whose side affects differ from case to case.

\noindent\hrulefill

Now you can share your module's or plugin's terrific {[}EDITOR: or
terrible!{]} packages with other modules!

\subsection{Related Topics}\label{related-topics-337}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-the-wab-generator}{Using
the WAB Generator}

\href{/docs/7-1/tutorials/-/knowledge_base/t/tooling}{Tooling}

\section{Resolving Third Party Library Package
Dependencies}\label{resolving-third-party-library-package-dependencies}

The OSGi framework lets you build applications composed of multiple OSGi
bundles (modules). For the framework to assemble the modules into a
working system, the modules must resolve their Java package
dependencies. In a perfect world, every Java library would be an OSGi
module, but many libraries aren't. So how do you resolve the packages
your module needs from non-OSGi third party libraries?

Here is the main workflow for resolving third party Java library
packages:

\textbf{Step 1 - Find an OSGi module of the library}: Projects, such as
\href{https://www.eclipse.org/orbit/}{Eclipse Orbit} and
\href{https://servicemix.apache.org/developers/source/bundles-source.html}{ServiceMix
Bundles}, convert hundreds of traditional Java libraries to OSGi
modules. Their artifacts are available at these locations:

\begin{itemize}
\tightlist
\item
  \href{https://download.eclipse.org/tools/orbit/downloads/drops/R20170919201930/}{Eclipse
  Orbit}
\item
  \href{https://mvnrepository.com/artifact/org.apache.servicemix.bundles}{ServiceMix
  Bundles}
\end{itemize}

Deploying the module to Liferay's OSGi framework lets you share it on
the system. If you find a module for the library you need,
\href{/docs/7-1/tutorials/-/knowledge_base/t/starting-module-development\#building-and-deploying-a-module}{deploy}
it. Then add a \texttt{compileOnly} dependency for it in your module.
When you deploy your module, the OSGi framework wires the dependency
module to your module. If you don't find an OSGi module based on the
Java library, go to Step 2.

\noindent\hrulefill

\textbf{Tip:} Refrain from embedding library JARs that provide the same
\href{/docs/7-1/reference/-/knowledge_base/r/third-party-packages-portal-exports}{packages
that Liferay DXP or existing modules provide already}.

\noindent\hrulefill

\noindent\hrulefill

\textbf{Note:} If you're developing a WAR that requires a different
version of a third-party package that
\href{/docs/7-1/reference/-/knowledge_base/r/third-party-packages-portal-exports}{Liferay
DXP or another module exports}, specify that package in your
\href{/docs/7-1/tutorials/-/knowledge_base/t/importing-packages}{\texttt{Import-Package:}
list}. If the package provider is an OSGi module, publish its exported
packages by deploying that module. Otherwise, rename the third-party
library (not an OSGi module) differently from the
\href{/docs/7-1/tutorials/-/knowledge_base/t/resolving-a-plugins-dependencies\#understanding-excluded-jars}{JAR
that the WAB generator excludes} and embed the JAR in your project.

\noindent\hrulefill

\textbf{Step 2 - Resolve the Java packages privately in your module}:
You can copy required library packages into your module or embed them
wholesale, if you must. The rest of the tutorial shows you how to do
these things.

\noindent\hrulefill

\textbf{Note}: Liferay's Gradle plugin \texttt{com.liferay.plugin}
automates several third party library configuration steps. The plugin is
automatically applied to
\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-workspace}{Liferay
Workspace} Gradle module projects created using
\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-ide}{Liferay Dev
Studio DXP} or
\href{/docs/7-1/tutorials/-/knowledge_base/t/blade-cli}{Liferay Blade
CLI}.

To leverage the \texttt{com.liferay.plugin} plugin outside of Liferay
Workspace, add code like the listing below to your Gradle project:

\begin{verbatim}
 buildscript {
     dependencies {
         classpath group: "com.liferay", name: "com.liferay.gradle.plugins", version: "3.2.29"
     }

     repositories {
         maven {
             url "https://repository-cdn.liferay.com/nexus/content/groups/public"
         }
     }
 }

 apply plugin: "com.liferay.plugin"
\end{verbatim}

If you use Gradle without the \texttt{com.liferay.plugin} plugin, you
must \hyperref[embedding-a-library-using-gradle]{embed the third party
libraries wholesale}.

\noindent\hrulefill

The recommended package resolution workflow is next.

\subsection{Library Package Resolution
Workflow}\label{library-package-resolution-workflow}

When you depend on a library JAR, much of the time you only need parts
of it. Explicitly specifying only the Java packages you need makes your
module more modular. This also keeps other modules that depend on your
module from incorporating unneeded packages.

Here's a configuration workflow that minimizes dependencies and Java
package imports:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add the library as a compile-only dependency (e.g.,
  \texttt{compileOnly} in Gradle).
\item
  Copy only the library packages you need by specifying them in a
  conditional package instruction (\texttt{Conditional-Package}) in your
  \texttt{bnd.bnd} file. Here are some examples:

  \texttt{Conditional-Package:\ foo.common*} adds packages your module
  uses such as \texttt{foo.common}, \texttt{foo.common-messages},
  \texttt{foo.common-web} to your module's class path.

  \texttt{Conditional-Package:\ foo.bar.*} adds packages your module
  uses such as \texttt{foo.bar} and all its sub-packages (e.g.,
  \texttt{foo.bar.baz}, \texttt{foo.bar.biz}, etc.) to your module's
  class path.

  Deploy your module. If a class your module needs or class its
  dependencies need isn't found, go back to main workflow \textbf{Step 1
  - Find an OSGi module version of the library} to resolve it.

  \textbf{Important}: Resolving packages by using compile-only
  dependencies and conditional package instructions assures you use only
  the packages you need and avoids unnecessary transitive dependencies.
  It's recommended to use the steps up to this point, as much as
  possible, to resolve required packages.
\item
  If a library package you depend on requires non-class files (e.g.,
  DLLs, descriptors) from the library, then you might need to
  \hyperref[embedding-libraries-in-a-module]{embed the library wholesale
  in your module}. This adds the entire library to your module's
  classpath.
\end{enumerate}

Next you'll learn how to embed libraries in your module.

\subsection{Embedding Libraries in a
Module}\label{embedding-libraries-in-a-module}

You can use Gradle, Maven, or Ivy to embed libraries in your module.
Below are examples for adding \href{https://shiro.apache.org}{Apache
Shiro} using all three build utilities.

\subsubsection{Embedding a Library Using
Gradle}\label{embedding-a-library-using-gradle}

Open your module's \texttt{build.gradle} file and add the library as a
dependency in the \texttt{compileInclude} configuration:

\begin{verbatim}
dependencies {
    compileInclude group: 'org.apache.shiro', name: 'shiro-core', version: '1.1.0'
}
\end{verbatim}

The \texttt{com.liferay.plugin} plugin's \texttt{compileInclude}
configuration is transitive. The \texttt{compileInclude} configuration
embeds the artifact and all its dependencies in a \texttt{lib} folder in
the module's JAR. Also, it adds the artifact JARs to the module's
\texttt{Bundle-ClassPath} manifest header.

\textbf{Note}: The \texttt{compileInclude} configuration does not
download transitive
\href{https://maven.apache.org/guides/introduction/introduction-to-optional-and-excludes-dependencies.html}{optional
dependencies}. If your module requires such artifacts, add them as you
would another third party library.

\textbf{Note:} If the library you've added as a dependency in your
\texttt{build.gradle} file has transitive dependencies, you can
reference them by name in an \texttt{-includeresource:} instruction
without having to add them explicitly to the dependency list. See how
it's used in the Maven section next.

\subsubsection{Embedding a Library Using Maven or
Ivy}\label{embedding-a-library-using-maven-or-ivy}

Follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open your module's build file and add the library as a dependency in
  the \texttt{provided} scope:

  \textbf{Maven:}

\begin{verbatim}
<dependency>
  <groupId>org.apache.shiro</groupId>
  <artifactId>shiro-core</artifactId>
  <version>1.1.0</version>
  <scope>provided</scope>
</dependency>
\end{verbatim}

  \textbf{Ant/Ivy:}

\begin{verbatim}
<dependency conf="provided" name="shiro-core" org="org.apache.shiro" rev="1.1.0" />
\end{verbatim}
\item
  Open your module's \texttt{bnd.bnd} file and add the library to an
  \texttt{-includeresource} instruction:

\begin{verbatim}
-includeresource: META-INF/lib/shiro-core.jar=shiro-core-[0-9]*.jar;lib:=true
\end{verbatim}

  This instruction adds the \texttt{shiro-core-{[}version{]}.jar} file
  as an included resource in the module's \texttt{META-INF/lib} folder.
  The \texttt{META-INF/lib/shiro-core.jar} is your module's embedded
  library. The expression \texttt{{[}0-9{]}*} helps the build tool match
  the library version to make available on the module's classpath. The
  \texttt{lib:=true} directive adds the embedded JAR to the module's
  classpath via the \texttt{Bundle-Classpath} manifest header.
\end{enumerate}

Lastly, if after embedding a library you get unresolved imports when
trying to deploy to Liferay, you might need to blacklist some imports:

\begin{verbatim}
Import-Package:\
    !foo.bar.baz,\
    *
\end{verbatim}

The \texttt{*} character represents all packages that the module refers
to explicitly. Bnd detects the referenced packages.

Congratulations! Resolving all of your module's package dependencies,
especially those from traditional Java libraries, is a quite an
accomplishment.

\subsection{Related Topics}\label{related-topics-338}

\href{/docs/7-1/tutorials/-/knowledge_base/t/importing-packages}{Importing
Packages}

\href{/docs/7-1/tutorials/-/knowledge_base/t/exporting-packages}{Exporting
Packages}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-projects-with-blade-cli}{Creating
Projects with Blade CLI}

\section{Waiting on Lifecycle Events}\label{waiting-on-lifecycle-events}

Liferay registers lifecycle events like portal and database
initialization into the OSGi service registry. Your OSGi Component or
non-component class can listen for these events by way of their service
registrations. The
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/module/framework/ModuleServiceLifecycle.html}{\texttt{ModuleServiceLifecycle}
interface} defines these names for the lifecycle event services:

\begin{itemize}
\tightlist
\item
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/constant-values.html\#com.liferay.portal.kernel.module.framework.ModuleServiceLifecycle.DATABASE_INITIALIZED}{DATABASE\_INITIALIZED}
\item
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/constant-values.html\#com.liferay.portal.kernel.module.framework.ModuleServiceLifecycle.PORTAL_INITIALIZED}{PORTAL\_INITIALIZED}
\item
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/constant-values.html\#com.liferay.portal.kernel.module.framework.ModuleServiceLifecycle.SPRING_INITIALIZED}{SPRING\_INITIALIZED}
\end{itemize}

Here you'll learn how to wait on lifecycle event services to act on them
from within a component or non-component class.

\subsection{Taking action from a
component}\label{taking-action-from-a-component}

\href{https://osgi.org/specification/osgi.cmpn/7.0.0/service.component.html}{Declarative
Services (DS)} facilitates waiting for OSGi services and acting on them
once they're available.

Here's a component whose \texttt{doSomething} method is invoked once the
\texttt{ModuleServiceLifecycle.PORTAL\_INITIALIZED} lifecycle event
service and other services are available.

\begin{verbatim}
@Component
public class MyXyz implements XyzApi {

    // Plain old OSGi service
    @Reference
    private SomeOsgiService _someOsgiService;

    // Service Builder generated service
    @Reference
    private DDMStructureLocalService _ddmStructureLocalService;

    // Liferay lifecycle service
    @Reference(target = ModuleServiceLifecycle.PORTAL_INITIALIZED)
    private ModuleServiceLifecycle _portalInitialized;

    @Activate
    public void doSomething() {
        // `@Activate` method is only executed once all of
        // `_someOsgiService`,
        // `_ddmStructureLocalService` and
        // `_portalInitialized`
        // are set.
    }
}
\end{verbatim}

Here's how to act on services in your component:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  For each lifecycle event service and OSGi service your component uses,
  add a field of that service type and add an \texttt{@Reference}
  annotation to that field. The OSGi framework binds the services to
  your fields. This field, for example, binds to a standard OSGi
  service.

\begin{verbatim}
@Reference
SomeOsgiService _someOsgiService;
\end{verbatim}
\item
  To bind to a particular lifecycle event service, target its name as
  the
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/module/framework/ModuleServiceLifecycle.html}{\texttt{ModuleServiceLifecycle}
  interface} defines. This field, for example, targets database
  initialization.

\begin{verbatim}
@Reference(target = ModuleServiceLifecycle.DATABASE_INITIALIZED)
ModuleServiceLifecycle _dataInitialized;
\end{verbatim}
\item
  Create a method that's triggered on the event(s) and add the
  \texttt{@Activate} annotation to that method. It's invoked when all
  the service objects are bound to the component's fields.
\end{enumerate}

Your component fires (via its \texttt{@Activate} method) after all its
service dependencies resolve. DS components are the easiest way to act
on lifecycle event services.

\subsection{Taking action from a non-component
class}\label{taking-action-from-a-non-component-class}

Classes that aren't DS components can use a
\texttt{org.osgi.util.tracker.ServiceTracker} or
\texttt{org.osgi.util.tracker.ServiceTrackerCustomizer} as a
\href{/docs/7-1/tutorials/-/knowledge_base/t/service-trackers\#implementing-a-callback-handler-for-services}{service
callback handler} for the lifecycle event. If you depend on multiple
services, add logic to your \texttt{ServiceTracker} or
\texttt{ServiceTrackerCustomizer} to coordinate taking action when all
the services are available.

To target a lifecycle event service, create a service tracker that
filters on that service. Use \texttt{org.osgi.framework.FrameworkUtil}
to create an \texttt{org.osgi.framework.Filter} that specifies the
service. Then pass that filter as a parameter to the service tracker
constructor. For example, this service tracker filters on the lifecycle
service \texttt{ModuleServiceLifecycle.PORTAL\_INITIALIZED}.

\begin{verbatim}
import org.osgi.framework.Filter;
import org.osgi.framework.FrameworkUtil;

Filter filter = FrameworkUtil.createFilter(
    String.format(
        "(&(objectClass=%s)%s)",
        ModuleServiceLifecycle.class.getName(),
        ModuleServiceLifecycle.PORTAL_INITIALIZED));

new ServiceTracker<>(bundleContext, filter, null);
\end{verbatim}

Acting on lifecycle event services in this way requires service callback
handling and some boilerplate code. Using DS components is easier and
more elegant, but at least service trackers provide a way to work with
lifecycle events outside of DS components.

\subsection{Related Topics}\label{related-topics-339}

\href{/docs/7-1/tutorials/-/knowledge_base/t/service-trackers}{Service
Trackers}

\href{/docs/7-1/reference/-/knowledge_base/r/liferay-startup-phases}{Liferay
DXP Startup Phases}

\section{Using the WAB Generator}\label{using-the-wab-generator}

You can create applications for Liferay DXP as Java EE-style Web
Application ARchive (WAR) artifacts or as Java ARchive (JAR) OSGi bundle
artifacts. Some portlet types, however, limit your flexibility. Portlets
like Spring MVC and JSF must be packaged as WAR artifacts because their
frameworks are designed for Java EE. Therefore, they expect a WAR layout
and require Java EE resources such as the \texttt{WEB-INF/web.xml}
descriptor.

Liferay provides a way for these WAR-styled plugins to be deployed and
treated like OSGi modules by Liferay's OSGi runtime. They can be
converted to \emph{WABs}.

Liferay DXP supports the OSGi Web Application Bundle (WAB) standard for
deployment of Java EE style WARs. Simply put, a WAB is an archive that
has a WAR layout and contains a \texttt{META-INF/MANIFEST.MF} file with
the \texttt{Bundle-SymbolicName} OSGi directive. A WAB is an OSGi
bundle. Although the project source has a WAR layout, the artifact
filename may end with either the \texttt{.jar} or \texttt{.war}
extension.

Liferay only supports the use of WABs that have been auto-generated by
the WAB Generator. The WAB Generator transforms a traditional WAR-style
plugin into a WAB during deployment. So what exactly does the WAB
Generator do to a WAR file to transform it into a WAB?

The WAB Generator detects packages referenced in the plugin WAR's JSPs,
descriptor files, and classes (in \texttt{WEB-INF/classes} and embedded
JARs). The descriptor files include \texttt{web.xml},
\texttt{liferay-web.xml}, \texttt{portlet.xml},
\texttt{liferay-portlet.xml}, and \texttt{liferay-hook.xml}. The WAB
Generator verifies whether the detected packages are in the plugin's
\texttt{WEB-INF/classes} folder or in an embedded JAR in the
\texttt{WEB-INF/lib} folder. Packages that aren't found in either
location are added to an \texttt{Import-Package} header in the WAB's
\texttt{META-INF/MANIFEST.MF} file.

To import a package that is only referenced in the following types of
locations, you must add an \texttt{Import-Package} OSGi header to the
plugin's \texttt{WEB-INF/liferay-plugin-package.properties} file and add
the package to that header's list of values.

\begin{itemize}
\tightlist
\item
  Unrecognized descriptor file
\item
  Custom or unrecognized descriptor element or attribute
\item
  Reflection code
\item
  Classloader code
\end{itemize}

The WAB folder structure and WAR folder structure differ. Consider the
following folder structure of a WAR-style portlet:

\begin{itemize}
\tightlist
\item
  my-war-portlet

  \begin{itemize}
  \tightlist
  \item
    src

    \begin{itemize}
    \tightlist
    \item
      main

      \begin{itemize}
      \tightlist
      \item
        java
      \item
        webapp

        \begin{itemize}
        \tightlist
        \item
          WEB-INF

          \begin{itemize}
          \tightlist
          \item
            classes
          \item
            lib
          \item
            resources
          \item
            views
          \item
            faces-config.xml
          \item
            liferay-display.xml
          \item
            liferay-plugin-package.properties
          \item
            liferay-portlet.xml
          \item
            portlet.xml
          \item
            web.xml
          \end{itemize}
        \end{itemize}
      \end{itemize}
    \end{itemize}
  \end{itemize}
\end{itemize}

When a WAR-style portlet is deployed to Liferay and processed by the WAB
Generator, the portlet's folder structure is transformed to something
like this

\begin{itemize}
\tightlist
\item
  my-war-portlet-that-is-now-a-wab

  \begin{itemize}
  \tightlist
  \item
    META-INF

    \begin{itemize}
    \tightlist
    \item
      MANIFEST.MF
    \end{itemize}
  \item
    WEB-INF

    \begin{itemize}
    \tightlist
    \item
      classes
    \item
      lib
    \item
      resources
    \item
      views
    \item
      faces-config.xml
    \item
      liferay-display.xml
    \item
      liferay-plugin-package.properties
    \item
      liferay-portlet.xml
    \item
      portlet.xml
    \item
      web.xml
    \end{itemize}
  \end{itemize}
\end{itemize}

The major difference is the addition of the
\texttt{META-INF/MANIFEST.MF} file. The WAB Generator automatically
generates an OSGi-ready \texttt{MANIFEST.MF} file. If you want to affect
the content of the manifest file, you can place bnd directives and OSGi
headers directly into your plugin's
\texttt{liferay-plugin-package.properties} file. It's pointless to add a
\texttt{bnd.bnd} file or a build-time plugin (e.g.,
\texttt{bnd-maven-plugin}) to your WAR plugin, because the generated WAB
cannot use of them.

Do you want to try generating a WAB? Follow the steps below to see the
WAB Generator in action.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a WAR-style plugin that follows a similar structure to the one
  outlined above. You can download an example WAR-style portlet
  \href{https://portal.liferay.dev/documents/113763090/114000186/com.liferay.hello.user.jsf.portlet-1.0-SNAPSHOT.war}{here},
  for demonstration.
\item
  Open your Liferay DXP instance in a file explorer and add a
  \texttt{portal-ext.properties} file with the following properties:

\begin{verbatim}
module.framework.web.generator.generated.wabs.store=true
module.framework.web.generator.generated.wabs.store.dir=${module.framework.base.dir}/wabs
\end{verbatim}

  These properties store your generated WAB into your Liferay instance's
  \texttt{osgi/wabs} folder. You can learn more about these properties
  in the
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/propertiesdoc/portal.properties.html\#Module\%20Framework\%20Web\%20Application\%20Bundles}{Module
  Framework Web Application Bundles} properties section. Restart Liferay
  to use these properties.
\item
  Copy your WAR plugin in your Liferay instance's \texttt{deploy}
  folder.
\item
  Navigate to your Liferay instance's \texttt{osgi/wabs} folder and
  inspect the generated WAB.
\end{enumerate}

Awesome! You've seen the WAB Generator in action!

\subsection{Related Topics}\label{related-topics-340}

\href{/docs/7-1/tutorials/-/knowledge_base/t/configurable-applications}{Configurable
Applications}

\section{Service Trackers}\label{service-trackers}

In an OSGi runtime ecosystem, you must consider how your modules can
rely on services in other modules for functionality. It's possible for
service implementations to be swapped out or removed entirely, and your
module must not just survive but thrive in this environment.

If you
\href{/docs/7-1/tutorials/-/knowledge_base/t/invoking-local-services}{call
services} from \texttt{@Component} classes, it's easy: you just use
another
\href{https://osgi.org/specification/osgi.cmpn/7.0.0/service.component.html}{Declarative
Services (DS)} annotation, \texttt{@Reference}, to get a service
reference. The component activates when the referenced service is
available.

\noindent\hrulefill

\textbf{Note:} The \texttt{@Reference} annotation can only be used in a
class that is annotated with \texttt{@Component}. That is, only a
Declarative Services component can use \texttt{@Reference} to bind to an
OSGi service.

\noindent\hrulefill

If you can use DS and leverage the \texttt{@Component} and
\texttt{@Reference} annotations, you should. DS handles much of the
complexity of handling service dynamism for you transparently.

If you can't use DS to create a Component, keep reading to learn how to
implement a Service Tracker to look up services in the service registry.

\begin{figure}
\centering
\includegraphics{./images/service-registry.png}
\caption{Service implementations that are registered in the OSGi service
registry can be accessed using Service Trackers.}
\end{figure}

\noindent\hrulefill

\textbf{Note:} When using Service Trackers in your WAR-style project,
you must configure the required \texttt{org.osgi.core} dependency
carefully in your build file (e.g., \texttt{build.gradle},
\texttt{pom.xml}, etc.) to avoid errors. Since it's included in Liferay
DXP by default, it must be configured as \texttt{provided}. See the
\href{/docs/7-1/reference/-/knowledge_base/r/third-party-packages-portal-exports}{Third
Party Packages Portal Exports} tutorial for more information.

\noindent\hrulefill

What scenarios might require using a service tracker? Keep in mind we're
focusing on scenarios where DS \emph{can't} be used. This typically
involves a non-native (to OSGi) Dependency Injection framework.

\begin{itemize}
\tightlist
\item
  Calling OSGi services from a
  \href{/docs/7-1/tutorials/-/knowledge_base/t/spring-mvc}{Spring MVC
  portlet}
\item
  Calling OSGi services from a
  \href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-plugins-to-liferay-7}{WAR-packaged
  portlet} that's been upgraded to run on 7.0, but not
  \href{/docs/7-1/tutorials/-/knowledge_base/t/modularizing-an-existing-portlet}{fully
  modularized} and made into an OSGi module
\end{itemize}

\noindent\hrulefill

\textbf{Note:} The static utility classes (e.g.,
\texttt{UserLocalServiceUtil}) that were useful in Liferay Portal 6.2
(and earlier) exist for compatibility but should not be called, if
possible. Static utility classes cannot account for the OSGi runtime's
dynamic environment. If you use a static class, you might attempt
calling a stopped service or one that hasn't been deployed or started.
This could cause unrecoverable runtime errors. Service Trackers,
however, help you make OSGi-friendly service calls.

\noindent\hrulefill

Your non-OSGi application can access any service registered in the OSGi
runtime using a Service Tracker, including your own
\href{/docs/7-1/tutorials/-/knowledge_base/t/what-is-service-builder}{Service
Builder services} and the services published by Liferay's modules (like
the popular \texttt{UserLocalService}).

\subsection{Implementing a Service
Tracker}\label{implementing-a-service-tracker}

Service Trackers don't give you the luxury of managing your service
dependencies with DS, but you can call services from the service
registry.

You can implement a service tracker in two ways: 1) In the code where
you need it, or 2) In a class that extends
\texttt{org.osgi.util.tracker.ServiceTracker}.

To create it directly, do this:

\begin{verbatim}
import org.osgi.framework.Bundle;
import org.osgi.framework.FrameworkUtil;
import org.osgi.util.tracker.ServiceTracker;

Bundle bundle = FrameworkUtil.getBundle(this.getClass());
BundleContext bundleContext = bundle.getBundleContext();
ServiceTracker<SomeService, SomeService> serviceTracker =
    new ServiceTracker(bundleContext, SomeService.class, null);
serviceTracker.open();
SomeService someService = serviceTracker.waitForService(500);
\end{verbatim}

A better way is to create a class that extends
\texttt{org.osgi.util.tracker.ServiceTracker}, because this simplifies
your code.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a class like this one that extends \texttt{ServiceTracker}:

\begin{verbatim}
public class SomeServiceTracker
    extends ServiceTracker<SomeService, SomeService> {

    public SomeServiceTracker(Object host) {
        super(
            FrameworkUtil.getBundle(host.getClass()).getBundleContext(),
            SomeService.class, null);
    }
}
\end{verbatim}
\item
  From the initialization part of your logic that uses the service, call
  your service tracker constructor. The \texttt{Object\ host} parameter
  obtains your own bundle context and must be an object from your own
  bundle in order to give accurate results.

\begin{verbatim}
ServiceTracker<SomeService, SomeService> someServiceTracker =
    new SomeServiceTracker(this);
\end{verbatim}
\item
  When you want to use the service tracker, open it, typically as early
  as you can.

\begin{verbatim}
someServiceTracker.open();
\end{verbatim}
\item
  Before attempting to use a service, use the Service Tracker to
  interrogate the service's state. In your program logic, for example,
  check whether the service is \texttt{null} before using it:

\begin{verbatim}
SomeService someService = someServiceTracker.getService();

if (someService == null) {
    _log.warn("The required service 'SomeService' is not available.");
}
else {
    someService.doSomethingCool();
}
\end{verbatim}

  Service Trackers have several other utility functions for
  introspecting tracked services.
\item
  Later when your application is being destroyed or undeployed, close
  the service tracker.

\begin{verbatim}
someServiceTracker.close();
\end{verbatim}
\end{enumerate}

Service Trackers make it possible to call OSGi services from outside the
OSGi runtime.

\subsection{Implementing a Callback Handler for
Services}\label{implementing-a-callback-handler-for-services}

If there's a strong possibility the service might not be available or if
you need to track multiple services, the Service Tracker API provides a
callback mechanism that operates on service \emph{events}. To use this,
override \texttt{ServiceTracker}'s \texttt{addingService} and
\texttt{removedService} methods. Their \texttt{ServiceReference}
parameter references an active service object.

Here's an example \texttt{ServiceTracker} implementation from the
\href{https://osgi.org/specification/osgi.core/7.0.0/util.tracker.html\#d0e51991}{OSGi
Alliance's OSGi Core Release 7 specification}:

\begin{verbatim}
new ServiceTracker<HttpService, MyServlet>(context, HttpService.class, null) {

    public MyServlet addingService(ServiceReference<HttpService> reference) {
        HttpService httpService = context.getService(reference);
        MyServlet myServlet = new MyServlet(httpService);
        return myServlet;
    }

    public void removedService(
        ServiceReference<HttpService> reference, MyServlet myServlet) {
        myServlet.close();
        context.ungetService(reference);
    }
}
\end{verbatim}

When the \texttt{HttpService} is added to the OSGi registry, this
\texttt{ServiceTracker} creates a new wrapper class, \texttt{MyServlet},
which uses the newly added service. When the service is removed from the
registry, the \texttt{removedService} method cleans up related
resources.

As an alternative to directly overloading \texttt{ServiceTracker}
methods, create a
\texttt{org.osgi.util.tracker.ServiceTrackerCustomizer}:

\begin{verbatim}
class MyServiceTrackerCustomizer 
    implements ServiceTrackerCustomizer<SomeService, MyWrapper> {
    
    private final BundleContext bundleContext;
    
    MyServiceTrackerCustomizer(BundleContext bundleContext) {
        this.bundleContext = bundleContext;
    }
    
    @Override
    public MyWrapper addedService(
        ServiceReference<SomeService> serviceReference) {
        
        // Determine if the service is one that's interesting to you.
        // The return type of this method is the `tracked` type. Its type 
        // is what is returned from `getService*` methods; useful for wrapping 
        // the service with your own type (e.g., MyWrapper).
        if (isInteresting(serviceReference)) {
            MyWrapper myWrapper = new MyWrapper(
                serviceReference, bundleContext.getService());
            
            // trigger the logic that requires the available service(s)
            triggerServiceAddedLogic(myWrapper);
            
            return myWrapper;
        }
        
        // If the return is null, the tracker is effectively ignoring any further
        // events for the service reference
        return null;
    }

    @Override
    public void modifiedService(
        ServiceReference<SomeService> serviceReference, MyWrapper myWrapper) {
        // handle the modified service
    }

    @Override
    public void removedService(
        ServiceReference<SomeService> serviceReference, MyWrapper myWrapper) {

        // finally, trigger logic when the service is going away
        triggerServiceRemovedLogic(myWrapper);
    }

}
\end{verbatim}

Register the \texttt{ServiceTrackerCustomizer} by passing it as the
\texttt{ServiceTracker} constructor's third parameter.

\begin{verbatim}
ServiceTrackerCustomizer<SomeService, MyWrapper> serviceTrackerCustomizer =
    new MyServiceTrackerCustomizer();

ServiceTracker<SomeService, MyWrapper> serviceTracker = 
    new ServiceTracker<>(
        bundleContext, SomeService.class, serviceTrackerCustomizer);
\end{verbatim}

There's a little boilerplate code you need to produce, but now you can
look up services in the service registry, even if your plugins can't
take advantage of the Declarative Services component model.

\section{Semantic Versioning}\label{semantic-versioning}

\href{https://semver.org}{Semantic Versioning} is a three tiered
versioning system that increments version numbers based on the type of
API change introduced to a releasable software component. It's a
standard way of communicating programmatic compatibility of a package or
module for dependent consumers and API implementations. If a package is
programmatically (i.e., semantically) incompatible with a project,
\href{http://bnd.bndtools.org}{Bnd} (used when building modules) fails
that project's build immediately.

The semantic version format looks like this:

\begin{verbatim}
MAJOR.MINOR.MICRO
\end{verbatim}

Certain events force each tier to be incremented:

\begin{itemize}
\tightlist
\item
  \emph{MAJOR:} an incompatible, API-breaking change is made
\item
  \emph{MINOR:} a change that affects only providers of the API, or new
  backwards- compatible functionality is added
\item
  \emph{MICRO:} a backwards-compatible bug fix is made
\end{itemize}

For more details on semantic versioning, see the official
\href{https://semver.org/}{Semantic Versioning} site and
\href{http://www.osgi.org/wp-content/uploads/SemanticVersioning1.pdf}{OSGi
Alliance's Semantic Versioning} technical whitepaper.

All of Liferay DXP's modules use Semantic Versioning.

Following Semantic Versioning is especially important because Liferay
DXP is a modular platform containing hundreds of independent OSGi
modules. With many independent modules containing a slew of
dependencies, releasing new package versions can quickly become
terrifying. With this complex intertwined system of dependencies, you
must meticulously manage your own project's API versions to ensure
compatibility for those who leverage it. With Semantic Versioning's
straightforward system and the help of Liferay tooling, managing your
project's versions is easy.

\subsection{Baselining Your Project}\label{baselining-your-project}

Following Semantic Versioning manually seems deceptively easy. There's a
sad history of good-intentioned developers updating their projects'
semantic versions manually, only to find out later they made a mistake.
The truth is, it's hard to anticipate the ramifications of a simple
update. To avoid this, you can \emph{baseline} your project after it has
been updated. Baselining verifies that the Semantic Versioning rules are
obeyed by your project. This can catch many obvious API changes that are
not so obvious to humans. Care must always be taken, however, when
making any kind of code change because this tool is not smart enough to
identify compatibility changes not represented in the signatures of Java
classes or interfaces, or in API \emph{use} changes (e.g., assumptions
about method call order, or changes to input and/or output encoding).
Baseline, as the name implies, does give you a certain measure of
\emph{baseline} comfort that a large class of compatibility issues won't
sneak past you.

You can use Liferay's Baseline Gradle plugin to provide baselining
capabilities. Add it to your Gradle build configuration and execute the
following command:

\begin{verbatim}
./gradlew baseline
\end{verbatim}

See the
\href{/docs/7-1/reference/-/knowledge_base/r/baseline-gradle-plugin}{Baseline
Gradle Plugin} article for configuration details. This plugin is not
provided in
\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-workspace}{Liferay
Workspace} by default.

When you run the \texttt{baseline} command, the plugin baselines your
new module against the latest released non-snapshot module (i.e., the
baseline). That is, it compares the public exported API of your new
module with the baseline. If there are any changes, it uses the OSGi
Semantic Versioning rules to calculate the minimum new version. If your
new module has a lower version, errors are thrown.

With baselining, your project's Semantic Versioning is as accurate as
its API expresses.

\subsection{Managing Artifact and Dependency
Versions}\label{managing-artifact-and-dependency-versions}

There are two ways to track your project's artifact and dependency
versions with Semantic Versioning:

\begin{itemize}
\tightlist
\item
  Range of versions
\item
  Exact version (one-to-one)
\end{itemize}

You should track a range of versions if you intend to build your project
for multiple versions of Liferay DXP and maintain maximum compatibility.
In other words, if several versions of a package work for an app, you
can configure the app to use any of them. What's more, Bnd automatically
determines the semantically compatible range of each package a module
depends on and records the range to the module's manifest.

For help with version range syntax, see the
\href{https://osgi.org/specification/osgi.core/7.0.0/framework.module.html\#i3189032}{OSGi
Specifications}.

A version range for imported packages in an OSGi bundle's
\texttt{bnd.bnd} looks like this:

\begin{verbatim}
Import-Package: com.liferay.docs.test; version="[1.0.0,2.0.0)"
\end{verbatim}

Popular build tools also follow this syntax. In Gradle, a version range
for a dependency looks like this:

\begin{verbatim}
compile group: "com.liferay.portal", name: "com.liferay.portal.test", version: "[1.0.0,2.0.0)"
\end{verbatim}

In Maven, it looks like this:

\begin{verbatim}
<groupId>com.liferay.portal</groupId>
<artifactId>com.liferay.portal.test</artifactId>
<version>[1.0.0,2.0.0)</version>
\end{verbatim}

Specifying the latest release version can also be considered a range of
versions with no upper limit. For example, in Gradle, it's specified as
\texttt{version:\ "latest.release"}. This can be done in Maven 2.x with
the usage of the version marker \texttt{RELEASE}. This is not possible
if you're using Maven 3.x. See \href{https://gradle.org/docs}{Gradle}
and \href{http://maven.apache.org/guides/}{Maven}'s respective docs for
more information.

Tracking a range of versions comes with a price. It's hard to reproduce
old builds when you're debugging an issue. It also comes with the risk
of differing behaviors depending on the version used. Also, relying on
the latest release could break compatibility with your project if a
major change is introduced. You should proceed with caution when
specifying a range of versions and ensure your project is tested on all
included versions.

Tracking a dependency's exact version is much safer, but is less
flexible. This might limit you to a specific version of Liferay DXP. You
would also be locked in to APIs that only exist for that specific
version. This means your module is much easier to test and has less
chance for unexpected failures.

\noindent\hrulefill

\textbf{Note:} When specifying package versions in your \texttt{bnd.bnd}
file, exact versions are typically specified like this:
\texttt{version="1.1.2"}. However, this syntax is technically a range;
it is interpreted as {[}1.1.2, ∞). Therefore, if a higher version of the
package is available, it's used instead of the version you specified.
For these cases, it may be better to specify a version range for
compatible versions that have been tested. If you want to specify a true
exact match, the syntax is like this: \texttt{{[}1.1.2{]}}. See the
\href{https://osgi.org/specification/osgi.core/7.0.0/framework.module.html\#i3189032}{Version
Range} section in the OSGi specifications for more info.

Gradle and Maven use exact versions when only one version is specified.

\noindent\hrulefill

You now know the pros and cons for tracking dependencies as a range and
as an exact match.

\chapter{Troubleshooting FAQ}\label{troubleshooting-faq}

When coding on any platform, you can sometimes run into issues that have
no clear resolution. This can be particularly frustrating. If you have
issues building, deploying, or running apps and modules, you want to
resolve them fast. These frequently asked questions and answers help you
troubleshoot and correct problems.

Here are the troubleshooting sections:

\begin{itemize}
\tightlist
\item
  \hyperref[modules]{Modules}
\item
  \hyperref[services-and-components]{Services and Components}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/troubleshooting-front-end-development-issues}{Front-end}
\end{itemize}

Click a question to view the answer.

\section{Modules}\label{modules-2}

{How can I configure dependencies on Liferay artifacts?~{}}

\begin{verbatim}
<p>See <a href="/docs/7-1/tutorials/-/knowledge_base/t/configuring-dependencies">Configuring Dependencies</a>. </p>
\end{verbatim}

{What are optional package imports and how can I specify them?~{}}

\begin{verbatim}
<p>When developing modules, you can declare <em>optional</em> package imports. An optional package import is one your module can use if it's available, but can still function without it. <a href="/docs/7-1/tutorials/-/knowledge_base/t/declaring-optional-import-package-requirements">Specifying optional package imports</a> is straightforward. </p>
\end{verbatim}

{How can I connect to a JNDI data source from my module?~{}}

\begin{verbatim}
<p>Connecting to an application server's JNDI data sources from Liferay's OSGi environment is almost the same as connecting to them from the Java EE environment. In an OSGi environment, the only difference is that you must <a href="/docs/7-1/tutorials/-/knowledge_base/t/connecting-to-data-sources-using-jndi">use Liferay DXP's class loader to load the application server's JNDI classes</a>. </p>
\end{verbatim}

{My module has an unresolved requirement. What can I do?~{}}

\begin{verbatim}
<p>If one of your bundles imports a package that no other bundle in the Liferay OSGi runtime exports, Liferay DXP reports an unresolved requirement:</p>
<pre><code>! could not resolve the bundles: ...
Unresolved requirement: Import-Package: ...
...
Unresolved requirement: Require-Capability ...
</code></pre>
<p>To satisfy the requirement, <a href="/docs/7-1/tutorials/-/knowledge_base/t/resolving-bundle-requirements">find a module that provides the capability, add it to your build file's dependencies, and deploy it</a>. </p>
\end{verbatim}

{An IllegalContextNameException reports that my bundle's context name
does not follow Bundle-SymbolicName syntax. How can I fix the context
name?~{}}

\begin{verbatim}
<p><a href="/docs/7-1/tutorials/-/knowledge_base/t/resolving-bundle-symbolicname-syntax-issues">Adjust the <code>Bundle-SymbolicName</code> to adhere to the syntax</a>. </p>
\end{verbatim}

{Why aren't my module's JavaScript and CSS changes showing?~{}}

\begin{verbatim}
<p><a href="/docs/7-1/tutorials/-/knowledge_base/t/why-arent-my-modules-javascript-and-css-changes-showing">Incorrect component properties or stale browser cache can prevent JavaScript and CSS changes from showing</a>. </p>
\end{verbatim}

{Why aren't my fragment's JSP overrides showing?~{}}

\begin{verbatim}
<p><a href="/docs/7-1/tutorials/-/knowledge_base/t/why-arent-jsp-overrides-i-made-using-fragments-showing">Make sure your <code>Fragment-Host</code>'s bundle version is compatible with the host's bundle version</a>. </p>
\end{verbatim}

{Why doesn't the package I use from the fragment host resolve?~{}}

\begin{verbatim}
<p><a href="/docs/7-1/tutorials/-/knowledge_base/t/why-is-a-package-i-use-from-the-fragment-host-unresolved">Refrain from importing (<code>Import-Package: ...</code>) host packages that the host doesn't export</a>. </p>
\end{verbatim}

{The application server and database started, but Liferay DXP failed to
connect to the database. What happened and how can I fix this?~{}}

\begin{verbatim}
<p>Liferay DXP initialization can fail while attempting to connect to a database server that isn't ready. <a href="/docs/7-1/tutorials/-/knowledge_base/t/portal-failed-to-initialize-because-the-database-wasnt-ready">Configuring startup to retry JDBC connections</a> facilitates connecting Liferay DXP to databases. </p>
\end{verbatim}

{How can I adjust my module's logging?~{}}

\begin{verbatim}
<p>See <a href="/docs/7-1/tutorials/-/knowledge_base/t/adjusting-module-logging">Adjusting Module Logging</a>. </p>
\end{verbatim}

{How can I implement logging in my module or plugin?~{}}

\begin{verbatim}
<p><a href="/docs/7-1/tutorials/-/knowledge_base/t/implementing-logging">Use Simple Logging Facade for Java (SLF4J) to log messages</a>.</p>
\end{verbatim}

{Why did the entity sort order change when I migrated to a new database
type?~{}}

\begin{verbatim}
<p><a href="/docs/7-1/tutorials/-/knowledge_base/t/sort-order-changed-with-a-different-database">Your new database uses a different default query result order--you should be able to configure a different order</a>.</p>
\end{verbatim}

{After creating a relational mapping between Service Builder entities,
my portlet is using too much memory. What can I do?~{}}

\begin{verbatim}
<p><a href="/docs/7-1/tutorials/-/knowledge_base/t/disabling-cache-for-table-mapper-tables">Disabling the cache related to the entity mapping lowers memory usage.</a>.</p>
\end{verbatim}

\section{Services and Components}\label{services-and-components}

{How can I see what's happening in the OSGi container?~{}}

\begin{verbatim}
<p><a href="/docs/7-1/tutorials/-/knowledge_base/t/system-check">Run a System Check.</a>. </p>
\end{verbatim}

{How can I detect unresolved OSGi components?~{}}

\begin{verbatim}
<p>module components that use Service Builder use Dependency Manager (DM) and most other module components use Declarative Services (DS). <a href="/docs/7-1/tutorials/-/knowledge_base/t/detecting-unresolved-osgi-components">Gogo shell commands and tools help you find and inspect unsatisfied component references for DM and DS components</a>. </p>
\end{verbatim}

{What is the safest way to call OSGi services from non-OSGi code?~{}}

\begin{verbatim}
<p>See <a href="/docs/7-1/tutorials/-/knowledge_base/t/service-trackers">Calling Non-OSGi Code that Uses OSGi Services</a>. </p>
\end{verbatim}

{How can I use files to configure components?~{}}

\begin{verbatim}
<p>See <a href="/docs/7-1/tutorials/-/knowledge_base/t/using-files-to-configure-product-modules">Using Files to Configure Module Components</a>. </p>
\end{verbatim}

{How can I access OSGi Services from my Ext plugin?~{}}

\begin{verbatim}
<p><a href="/docs/7-1/tutorials/-/knowledge_base/t/using-osgi-services-from-ext-plugins">Use `ServiceTrackers`</a>. </p>
\end{verbatim}

\section{Resolving Bundle
Requirements}\label{resolving-bundle-requirements}

If one of your bundles needs a package that is not exported by any other
bundle in the Liferay OSGi runtime, you get a bundle exception. Here's
an example exception:

\begin{verbatim}
! could not resolve the bundles: [com.liferay.messaging.client.command-1.0.0.201707261701 org.osgi.framework.BundleException: Could not resolve module: com.liferay.messaging.client.command [1]
Unresolved requirement: Import-Package: com.liferay.messaging.client.api; version="[1.0.0,2.0.0)"
-> Export-Package: com.liferay.messaging.client.api; bundle-symbolic-name="com.liferay.messaging.client.provider"; bundle-version="1.0.0.201707261701"; version="1.0.0"; uses:="org.osgi.framework"
com.liferay.messaging.client.provider [2]
Unresolved requirement: Import-Package: com.liferay.messaging; version="[1.0.0,2.0.0)"
-> Export-Package: com.liferay.messaging; bundle-symbolic-name="com.liferay.messaging.api"; bundle-version="1.0.0"; version="1.0.0"; uses:="com.liferay.petra.concurrent"
com.liferay.messaging.api [12]
Unresolved requirement: Import-Package: com.liferay.petra.io; version="[1.0.0,2.0.0)"
-> Export-Package: com.liferay.petra.io; bundle-symbolic-name="com.liferay.petra.io"; bundle-version="1.0.0"; version="1.0.0"
com.liferay.petra.io [16]
Unresolved requirement: Require-Capability osgi.extender; filter:="(osgi.extender=osgi.serviceloader.processor)"
\end{verbatim}

The first line states \emph{could not resolve the bundles}. What follows
is a string of requirements that Lferay's OSGi Runtime could not
resolve.

The bundle exception message follows this general pattern:

\begin{itemize}
\tightlist
\item
  Module A has an unresolved requirement (package or capability)
  \texttt{aaa.bbb}.
\item
  Module B provides \texttt{aaa.bbb} but has an unresolved requirement
  \texttt{ccc.ddd}.
\item
  Module C provides \texttt{ccc.ddd} but has an unresolved requirement
  \texttt{eee.fff}.
\item
  etc.
\item
  Module Z provides \texttt{www.xxx} but has an unresolved requirement
  \texttt{yyy.zzz}.
\end{itemize}

The pattern stops at the final unsatisfied requirement. The last
module's dependencies are key to resolving the bundle exception. There
are two possible causes:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  A dependency that satisfies the final requirement might be missing
  from the build file.
\item
  A dependency that satisfies the final requirement might not be
  deployed.
\end{enumerate}

Both cases require deploying a bundle that provides the missing
requirement.

The example bundle exception concludes that module
\texttt{com.liferay.petra.io} requires capability
\texttt{osgi.extender;\ filter:="(osgi.extender=osgi.serviceloader.processor)"}.
To resolve the requirement, make sure all of
\texttt{com.liferay.petra.io}'s dependencies are deployed.

The \texttt{com.liferay.petra.io} module's \texttt{build.gradle} file
lists its dependencies:

\begin{verbatim}
dependencies {
    provided group: "com.liferay", name: "com.liferay.petra.concurrent", version: "1.0.0"
    provided group: "com.liferay", name: "com.liferay.petra.memory", version: "1.0.0"
    provided group: "org.apache.aries.spifly", name: "org.apache.aries.spifly.dynamic.bundle", version: "1.0.8"
    provided group: "org.slf4j", name: "slf4j-api", version: "1.7.2"
    testCompile group: "com.liferay.portal", name: "com.liferay.portal.kernel", version: "default"
}
\end{verbatim}

Then use
\href{/docs/7-1/reference/-/knowledge_base/r/using-the-felix-gogo-shell}{Felix
Gogo Shell's \texttt{lb\ command}} to verify the dependencies are in
Liferay's OSGi Runtime:

\begin{verbatim}
lb
START LEVEL 1
   ID|State      |Level|Name
    0|Active     |    0|OSGi System Bundle (3.10.100.v20150529-1857)|3.10.100.v20150529-1857
    1|Active     |    1|com.liferay.messaging.client.command (1.0.0.201707261923)|1.0.0.201707261923
    2|Active     |    1|com.liferay.messaging.client.provider (1.0.0.201707261927)|1.0.0.201707261927
    3|Active     |    1|Apache Felix Configuration Admin Service (1.8.8)|1.8.8
    4|Active     |    1|Apache Felix Log Service (1.0.1)|1.0.1
    5|Active     |    1|Apache Felix Declarative Services (2.0.2)|2.0.2
    6|Active     |    1|Meta Type (1.4.100.v20150408-1437)|1.4.100.v20150408-1437
    7|Active     |    1|org.osgi:org.osgi.service.metatype (1.3.0.201505202024)|1.3.0.201505202024
    8|Active     |    1|Apache Felix Gogo Command (0.16.0)|0.16.0
    9|Active     |    1|Apache Felix Gogo Runtime (0.16.2)|0.16.2
   10|Active     |    1|Apache Felix Gogo Runtime (1.0.0)|1.0.0
...
\end{verbatim}

The dependency module \texttt{org.apache.aries.spifly.dynamic.bundle} is
missing from the runtime bundle list. The
\texttt{org.apache.aries.spifly.dynamic.bundle} module's
\texttt{MANIFEST.MF} file shows it provides the requirement capability
\texttt{osgi.extender;\ filter:="(osgi.extender=osgi.serviceloader.processor)"}:

\begin{verbatim}
Provide-Capability: osgi.extender;osgi.extender="osgi.serviceloader.regi
 strar";version:Version="1.0",osgi.extender;osgi.extender="osgi.servicel
 oader.processor";version:Version="1.0"
\end{verbatim}

This capability
\texttt{osgi.extender;\ filter:="(osgi.extender=osgi.serviceloader.processor)"}
is the unresolved requirement we identified earlier. Deploying this
missing bundle \texttt{org.apache.aries.spifly.dynamic.bundle} satisfies
the example module's requirement and allows the module to resolve and
install.

You can resolve your bundle exceptions by following steps similar to
these.

\noindent\hrulefill

Note: Bndtools's \emph{Resolve} button can resolve bundle dependencies
automatically. You specify the bundles your application requires and
Bndtools adds transitive dependencies from your configured artifact
repository.

\noindent\hrulefill

\subsection{Related Topics}\label{related-topics-341}

\href{/docs/7-1/tutorials/-/knowledge_base/t/configuring-dependencies}{Configuring
Dependencies}

\href{/docs/7-1/tutorials/-/knowledge_base/t/adding-third-party-libraries-to-a-module}{Adding
Third Party Libraries to a Module}

\href{/docs/7-1/reference/-/knowledge_base/r/using-the-felix-gogo-shell}{Felix
Gogo Shell}

\href{/docs/7-1/tutorials/-/knowledge_base/t/resolving-a-plugins-dependencies}{Resolving
a Plugins's Dependencies}

\section{Resolving Bundle-SymbolicName Syntax
Issues}\label{resolving-bundle-symbolicname-syntax-issues}

Liferay's OSGi Runtime framework sometimes throws an
\texttt{IllegalContextNameException}. Often, this is because an OSGi
bundle's \texttt{Bundle-SymbolicName} manifest header has a space in it.

The \texttt{Bundle-SymbolicName} uniquely identifies the bundle---along
with the \texttt{Bundle-Version} manifest header---and cannot contain
spaces. To follow naming best practices, use a reverse-domain name in
your \texttt{Bundle-SymbolicName}. For example, a module with the domain
\texttt{troubleshooting.liferay.com} would be reversed to
\texttt{com.liferay.troubleshooting.}.

There are three ways to specify a bundle's \texttt{Bundle-SymbolicName}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \texttt{Bundle-SymbolicName} header in a bundle's \texttt{bnd.bnd}
  file.
\item
  \texttt{Bundle-SymbolicName} header in a plugin WAR's
  \texttt{liferay-plugin-package.properties} file.
\item
  Plugin WAR file name, if the WAR's
  \texttt{liferay-plugin-package.properties} has no
  \texttt{Bundle-SymbolicName} header.
\end{enumerate}

For plugin WARs, specifying the \texttt{Bundle-SymbolicName} in the
\texttt{liferay-plugin-package.properties} file is preferred.

For example, if you deploy a plugin WAR that has no
\texttt{Bundle-SymbolicName} header in its
\texttt{liferay-plugin-package.properties}, the
\href{/docs/7-1/tutorials/-/knowledge_base/t/using-the-wab-generator}{WAB
Generator} uses the WAR's name as the WAB's
\texttt{Bundle-SymbolicName}. If the WAR's name has a space in it (e.g.,
\texttt{space-program-theme\ v1.war}) an
\texttt{IllegalContextNameException} occurs on deployment.

\begin{verbatim}
org.apache.catalina.core.ApplicationContext.log The context name 'space-program-theme v1' does not follow Bundle-SymbolicName syntax.
org.eclipse.equinox.http.servlet.internal.error.IllegalContextNameException: The context name 'space-program-theme v1' does not follow Bundle-SymbolicName syntax.
\end{verbatim}

However you set your a \texttt{Bundle-SymbolicName}, refrain from using
spaces.

\subsection{Related Topics}\label{related-topics-342}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-the-wab-generator}{Using
the WAB Generator}

\section{Resolving ClassNotFoundException and NoClassDefFoundError in
OSGi
Bundles}\label{resolving-classnotfoundexception-and-noclassdeffounderror-in-osgi-bundles}

\texttt{ClassNotFoundException} and \texttt{NoClassDefFoundError} are
common, well known exceptions:

\begin{itemize}
\tightlist
\item
  \texttt{ClassNotFoundException} is thrown when looking up a class that
  isn't on the classpath or using an invalid name to look up a class
  that isn't on the runtime classpath.
\item
  \texttt{NoClassDefFoundError} occurs when a compiled class references
  another class that isn't on the runtime classpath.
\end{itemize}

In OSGi environments, however, there are additional cases where a
\texttt{ClassNotFoundException} or \texttt{NoClassDefFoundError} can
occur:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  The missing class belongs to a module dependency that's an OSGi
  module.
\item
  The missing class belongs to a module dependency that's \emph{not} an
  OSGi module.
\item
  The missing class belongs to a global library, either at the Liferay
  DXP webapp scope or the application server scope.
\item
  The missing class belongs to a Java runtime package.
\end{enumerate}

This tutorial explains how to handle each case.

\subsection{Case 1: The Missing Class Belongs to an OSGi
Module}\label{case-1-the-missing-class-belongs-to-an-osgi-module}

In this case, there are two possible causes:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{The module doesn't import the class's package:} For a module
  (or WAB) to consume another module's exported class, the consuming
  module must import the exported package that contains the class. To do
  this, you add an \texttt{Import-Package} header in the consuming
  module's \texttt{bnd.bnd} file. If the consuming module tries to
  access the class without importing the package, a
  \texttt{ClassNotFoundException} or \texttt{NoClassDefFoundError}
  occurs.

  Check the package name and make sure the consuming module imports the
  right package. If the import is correct but you still get the
  exception or error, the class might no longer exist in the package.
\item
  \textbf{The class no longer exists in the imported package:} Modules
  are changed frequently in OSGi runtime environments. If you reference
  another module's class that its developer removed, a
  \texttt{NoClassDefFoundError} or \texttt{ClassNotFoundException}
  occurs. \href{http://semver.org}{Semantic Versioning} guards against
  this scenario: removing a class from an exported package constitutes a
  new major version for that package. Neglecting to increment the
  package's major version breaks dependent modules.

  For example, say a module that consumes the class \texttt{com.foo.Bar}
  specifies the package import
  \texttt{com.foo;version={[}1.0.0,\ 2.0.0)}. The module uses
  \texttt{com.foo} versions from \texttt{1.0.0} up to (but not
  including) \texttt{2.0.0}. The first part of the version number (the
  \texttt{1} in \texttt{1.0.0}) represents the \emph{major} version. The
  consuming module doesn't expect any \emph{major} breaking changes,
  like a class removal. Removing \texttt{com.foo.Bar} from
  \texttt{com.foo} without incrementing the package to a new major
  version (e.g., \texttt{2.0.0}) causes a
  \texttt{ClassNotFoundException} or \texttt{NoClassDefFoundError} when
  other modules look up or reference that class.

  You have limited options when the class no longer exists in the
  package:

  \begin{itemize}
  \item
    Adapt to the new API. To learn how to do this, read the
    package's/module's Javadoc, release notes, and/or formal
    documentation. You can also ask the author or search forums.
  \item
    Revert to the module version you used previously. Deployed module
    versions reside in \texttt{{[}Liferay\_Home{]}/osgi/}. For details,
    see
    \href{/docs/7-1/deploy/-/knowledge_base/d/backing-up-a-liferay-installation\#backing-up-liferays-file-system}{Backing
    up Liferay Installations}.
  \end{itemize}

  Do what you think is best to get your module working properly.
\end{enumerate}

Now you know how to resolve common situations involving
\texttt{ClassNotFoundException} or \texttt{NoClassDefFoundError}. For
additional information on \texttt{NoClassDefFoundError}, see OSGi
Enroute's article
\href{http://enroute.osgi.org/faq/class-not-found-exception.html}{What
is NoClassDefFoundError?}.

\subsection{Case 2: The Missing Class Doesn't Belong to an OSGi
Module}\label{case-2-the-missing-class-doesnt-belong-to-an-osgi-module}

In this case, you have two options:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Convert the dependency into an OSGi module so it can export the
  missing class. Converting a non-OSGi \texttt{JAR} file dependency into
  an OSGi module that you can deploy alongside your application is the
  ideal solution, so it should be your first choice.
\item
  Embed the dependency in your module by embedding the dependency
  \texttt{JAR} file's packages as private packages in your module. If
  you want to embed a non-OSGi \texttt{JAR} file in your application,
  see the tutorial
  \href{/docs/7-1/tutorials/-/knowledge_base/t/adding-third-party-libraries-to-a-module}{Adding
  Third Party Libraries to a Module}.
\end{enumerate}

\subsection{Case 3: The Missing Class Belongs to a Global
Library}\label{case-3-the-missing-class-belongs-to-a-global-library}

In this case, you can configure Liferay DXP so the OSGi system module
exports the missing class's package. Then your module can import it. You
should \textbf{NOT}, however, undertake this lightly. If Liferay
intended to make a global library available for use by developers, the
system module would already export this library! Proceed only if you
have no other solution, and watch out for unintended consequences. There
are two ways to export the package:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In your \texttt{portal-ext.properties} file, use the property
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/propertiesdoc/portal.properties.html\#Module\%20Framework}{\texttt{module.framework.system.packages.extra}}
  to specify the packages to export. Preserve the property's current
  list.
\item
  If the package you need is from a Liferay DXP JAR, you might be able
  to add the module to the list of exported packages in
  \texttt{{[}LIFERAY\_HOME{]}/osgi/core/com.liferay.portal.bootstrap.jar}'s
  \texttt{META-INF/system.packages.extra.bnd} file. Try this option only
  if the first option doesn't work.
\end{enumerate}

If the package you need is from a Liferay DXP module, (i.e., it's
\textbf{NOT} from a global library), you can add the package to that
module's \texttt{bnd.bnd} exports. You should \textbf{NOT}, however,
undertake this lightly. The package would already be exported if Liferay
intended for it to be available.

\subsection{Case 4: The Missing Class Belongs to a Java Runtime
Package}\label{case-4-the-missing-class-belongs-to-a-java-runtime-package}

\texttt{rt.jar} (the JRE library) has non-public packages. If your
module imports one of them, configure Liferay DXP's system bundle to
export the package to the module framework.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add the current
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/propertiesdoc/portal.properties.html\#Module\%20Framework}{\texttt{module.framework.system.packages.extra}
  property setting} to a
  \texttt{{[}LIFERAY\_HOME{]}/portal-ext.properties} file. Your server's
  current setting is in the Liferay DXP web application's
  \texttt{/WEB-INF/lib/portal-impl.jar/portal.properties} file.
\item
  In your \texttt{portal-ext.properties} file, append the required Java
  runtime package to the end of the
  \texttt{module.framework.system.packages.extra} property's package
  list.
\item
  Restart your server.
\end{enumerate}

The package requirement resolves.

\subsection{Related Topics}\label{related-topics-343}

\href{/docs/7-1/deploy/-/knowledge_base/d/backing-up-a-liferay-installation}{Backing
up Liferay Installations}

\href{/docs/7-1/tutorials/-/knowledge_base/t/adding-third-party-libraries-to-a-module}{Adding
Third Party Libraries to a Module}

\href{/docs/7-1/tutorials/-/knowledge_base/t/bundle-classloading-flow}{Bundle
Classloading Flow}

\section{Identifying Liferay Artifact Versions for
Dependencies}\label{identifying-liferay-artifact-versions-for-dependencies}

When you're developing an application using Liferay APIs or tools---for
example, you might create a Service Builder application or use Message
Bus or Asset Framework---you must determine which versions of Liferay
artifacts (modules, apps, etc.) you application's modules must specify
as dependencies. To learn how to find Liferay artifacts and configure
dependencies on them, see
\href{/docs/7-1/tutorials/-/knowledge_base/t/configuring-dependencies}{Configuring
Dependencies}.

\subsection{Related Topics}\label{related-topics-344}

\href{/docs/7-1/tutorials/-/knowledge_base/t/configuring-dependencies}{Configuring
Dependencies}

\href{/docs/7-1/tutorials/-/knowledge_base/t/finding-extension-points}{Finding
Extension Points}

\section{Connecting to JNDI Data
Sources}\label{connecting-to-jndi-data-sources}

Connecting to an application server's JNDI data sources from Liferay
DXP's OSGi environment is almost the same as connecting to them from the
Java EE environment. In an OSGi environment, the only difference is that
you must use Liferay DXP's class loader to load the application server's
JNDI classes. The following code demonstrates this.

\begin{verbatim}
Thread thread = Thread.currentThread();

// Get the thread's class loader. You'll reinstate it after using
// the data source you look up using JNDI

ClassLoader origLoader = thread.getContextClassLoader();

// Set Liferay's class loader on the thread

thread.setContextClassLoader(PortalClassLoaderUtil.getClassLoader());

try {

        // Look up the data source and connect to it

        InitialContext ctx = new InitialContext();
        DataSource datasource = (DataSource)
            ctx.lookup("java:comp/env/jdbc/TestDB");

        Connection connection = datasource.getConnection();
        Statement statement = connection.createStatement();

        // Execute SQL statements here ...

        connection.close();
}
catch (NamingException ne) {

    ne.printStackTrace();
}
catch (SQLException sqle) {

    sqle.printStackTrace();
}
finally {
       // Switch back to the original context class loader

       thread.setContextClassLoader(origLoader);
}
\end{verbatim}

The example code sets Liferay DXP's classloader on the thread to access
the JNDI API.

\begin{verbatim}
thread.setContextClassLoader(PortalClassLoaderUtil.getClassLoader());
\end{verbatim}

It uses JNDI to look up the data source.

\begin{verbatim}
InitialContext ctx = new InitialContext();
DataSource datasource = (DataSource)
    ctx.lookup("java:comp/env/jdbc/TestDB"); 
\end{verbatim}

After working with the data source, the code reinstates the thread's
original classloader.

\begin{verbatim}
 thread.setContextClassLoader(origLoader);
\end{verbatim}

Here are the class imports for the example code:

\begin{verbatim}
import java.sql.Connection;
import java.sql.SQLException;
import java.sql.Statement;
import javax.naming.InitialContext;
import javax.naming.NamingException;
import javax.sql.DataSource;
import com.liferay.portal.kernel.util.PortalClassLoaderUtil;
\end{verbatim}

Your applications can use similar code to access a data source. Make
sure to substitute \texttt{jdbc/TestDB} with your data source name.

\noindent\hrulefill

\textbf{Note}: An OSGi bundle's attempt to connect to a JNDI data source
without using Liferay DXP's classloader results in a
\texttt{java.lang.ClassNotFoundException}. For example, here's an
exception from attempting to use Apache Tomcat's JNDI API without using
Liferay DXP's classloader:

\begin{verbatim}
 javax.naming.NoInitialContextException: Cannot instantiate class:
 org.apache.naming.java.javaURLContextFactory [Root exception is
 java.lang.ClassNotFoundException:
 org.apache.naming.java.javaURLContextFactory]
\end{verbatim}

\noindent\hrulefill

An easier way to work with databases is to
\href{/docs/7-1/tutorials/-/knowledge_base/t/connecting-service-builder-to-external-databases}{connect
to them using Service Builder}.

\subsection{Related Topics}\label{related-topics-345}

\href{/docs/7-1/tutorials/-/knowledge_base/t/connecting-service-builder-to-external-databases}{Connecting
Service Builder to External Databases}

\section{Adjusting Module Logging}\label{adjusting-module-logging}

Liferay DXP uses \href{http://logging.apache.org/log4j/1.2/}{Log4j}
logging services. Here are the ways to configure logging for module
classes and class hierarchies.

\begin{itemize}
\tightlist
\item
  \emph{Log Levels} in
  \href{/docs/7-1/user/-/knowledge_base/u/server-administration}{Liferay
  DXP's UI}
\item
  Configure Log4j for multiple modules in a
  \texttt{{[}anyModule{]}/src/main/resources/META-INF/module-log4j.xml}
  file.
\item
  Configure Log4j for a specific module in a
  \texttt{{[}Liferay\ Home{]}/osgi/log4j/{[}symbolicNameOfBundle{]}-log4j-ext.xml}
  file.
\item
  Configure Log4j for an OSGi fragment host module in a
  \texttt{/META-INF/module-log4j-ext.xml} file
\end{itemize}

Here's an example Log4j XML configuration:

\begin{verbatim}
<?xml version="1.0"?>
<!DOCTYPE log4j:configuration SYSTEM "log4j.dtd">
<log4j:configuration xmlns:log4j="http://jakarta.apache.org/log4j/">
    <category name="org.foo">
        <priority value="DEBUG" />
    </category>
</log4j:configuration>
\end{verbatim}

Use \texttt{category} elements to specify each class or class hierarchy
to log messages for. Set the \texttt{name} attribute to that class name
or root package. The example category sets logging for the class
hierarchy starting at package \texttt{org.foo}. Log messages at or above
the \texttt{DEBUG} log level are printed for classes in \texttt{org.foo}
and classes in packages starting with \texttt{org.foo}.

Set each category's \texttt{priority} element to the log
\href{http://logging.apache.org/log4j/1.2/apidocs/org/apache/log4j/Level.html}{level}
(priority) you want.

\begin{itemize}
\tightlist
\item
  ALL
\item
  DEBUG
\item
  INFO
\item
  WARN
\item
  ERROR
\item
  FATAL
\item
  OFF
\end{itemize}

The log messages are printed to Liferay log files in
\texttt{{[}Liferay\_Home{]}/logs}.

You can see examples of module logging in several Liferay sample
projects. For example, the
\href{https://github.com/liferay/liferay-blade-samples/tree/7.1/gradle/apps/action-command-portlet}{action-command-portlet},
\href{https://github.com/liferay/liferay-blade-samples/tree/7.1/gradle/extensions/document-action}{document-action},
and
\href{https://github.com/liferay/liferay-blade-samples/tree/7.1/gradle/apps/service-builder/jdbc}{service-builder/jdbc}
samples (among others) leverage module logging.

\noindent\hrulefill

Note: If the log level configuration isn't appearing (e.g., you set the
log level to \texttt{ERROR} but you're still getting \texttt{WARN}
messages), make sure the log configuration file name prefix matches the
module's symbolic name. If you have bnd installed, output from command
\texttt{bnd\ print\ {[}path-to-bundle{]}} includes the module's symbolic
name
(\href{https://github.com/bndtools/bnd/wiki/Install-bnd-on-the-command-line}{Here}
are instructions for installing bnd for the command line).

\noindent\hrulefill

That's it for module log configuration. You're all set to print the
information you want.

\subsection{Related Topics}\label{related-topics-346}

\href{/docs/7-1/tutorials/-/knowledge_base/t/implementing-logging}{Implementing
Logging}

\section{Implementing Logging}\label{implementing-logging}

7.0 uses the Log4j logging framework, but it may be replaced in the
future. It's a best practice to use \href{https://www.slf4j.org/}{Simple
Logging Facade for Java (SLF4J)} to log messages in your modules and
traditional plugins. SLF4J is already integrated into Liferay DXP, so
you can focus on logging messages.

Here's how to use SLF4J to log messages in a class:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add a private static SLF4J
  \href{https://www.slf4j.org/apidocs/org/slf4j/Logger.html}{\texttt{Logger}
  field}.

\begin{verbatim}
private static Logger _logger;
\end{verbatim}
\item
  Instantiate the logger.

\begin{verbatim}
_logger = LoggerFactory.getLogger(this.getClass().getName());
\end{verbatim}
\item
  Throughout your class, log messages where noteworthy things happen.

  For example,

\begin{verbatim}
_logger.debug("...");
_logger.warn("...");
_logger.error("...");
...
\end{verbatim}

  Use \texttt{Logger} methods appropriate for each message:

  \begin{itemize}
  \tightlist
  \item
    \texttt{debug}: Event and application information helpful for
    debugging.
  \item
    \texttt{error}: Normal errors. This is the least verbose message
    level.
  \item
    \texttt{info}: High level events.
  \item
    \texttt{trace}: Provides more information than debug. This is the
    most verbose message level.
  \item
    \texttt{warn}: Information that might, but does not necessarily,
    indicate a problem.
  \end{itemize}
\end{enumerate}

Log verbosity should correlate with the log level set for the class or
package. Make sure you provide additional information at log levels
expected to be more verbose, such as \texttt{info} and \texttt{debug}.

You're all set to add logging to your modules and traditional plugins.

\subsection{Related Topics}\label{related-topics-347}

\href{/docs/7-1/tutorials/-/knowledge_base/t/adjusting-module-logging}{Adjusting
Module Logging}

\section{Declaring Optional Import Package
Requirements}\label{declaring-optional-import-package-requirements}

When developing modules, you can declare \emph{optional} dependencies.
An optional dependency is one your module can use if available, but can
still function without it.

\noindent\hrulefill

\textbf{Important:} Try to avoid optional dependencies. The best module
designs rely on normal dependencies. If an optional dependency seems
desirable, your module may be trying to provide more than one distinct
type of functionality. In such a situation, it's best to split it into
multiple modules that provide smaller, more focused functionality.

\noindent\hrulefill

If you decide that your module requires an optional dependency, follow
these steps to add it:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In your module's \texttt{bnd.bnd} file, declare the package your
  module optionally depends on:

\begin{verbatim}
Import-Package: com.liferay.demo.foo;resolution:="optional"
\end{verbatim}

  Note that you can use either an optional or dynamic import. The
  differences are explained
  \href{https://osgi.org/specification/osgi.core/7.0.0/framework.module.html\#i2548181}{here}.
\item
  Create a component to use the optional package:

\begin{verbatim}
import com.liferay.demo.foo.Foo; // A class from the optional package

@Component(
    enabled = false // instruct declarative services to ignore this component by default
)
public class OptionalPackageConsumer implements Foo {...}
\end{verbatim}
\item
  Create a second component to be a controller for the first. The second
  component checks the classloader for the optional class on the
  classpath. If it's not there, this means you must catch any
  \texttt{ClassNotFoundException}. For example:

\begin{verbatim}
@Component
public class OptionalPackageConsumerStarter {
    @Activate
    void activate(ComponentContext componentContext) {
        try {
            Class.forName(com.liferay.demo.foo.Foo.class.getName());

            componentContext.enableComponent(OptionalPackageConsumer.class.getName());
        }
        catch (Throwable t) {
            _log.warn("Could not find {}", t.getMessage()); // Could use _log.info instead
        }
    }
}
\end{verbatim}
\end{enumerate}

If the classloader check in the controller component is successful, the
client component is enabled. This check is automatically performed
whenever there are any wiring changes to the module containing these
components (Declarative Services components are always restarted when
there are wiring changes).

If you install the module when the optional dependency is missing from
Liferay DXP's OSGi runtime, your controller component catches a
\texttt{ClassNotFoundException} and logs a warning or info message (or
takes whatever other action you implement to handle this case). If you
install the optional dependency, refreshing your module triggers the
OSGi bundle lifecycle events that trigger your controller's
\texttt{activate} method and the check for the optional dependency.
Since the dependency exists, your client component uses it.

Note that you can refresh a bundle from
\href{/docs/7-1/reference/-/knowledge_base/r/using-the-felix-gogo-shell}{Gogo
shell} with this command:

\begin{verbatim}
equinox:refresh [bundle ID] 
\end{verbatim}

\subsection{Related Topics}\label{related-topics-348}

\href{/docs/7-1/tutorials/-/knowledge_base/t/configuring-dependencies}{Configuring
Dependencies}

\section{Why Aren't my Module's JavaScript and CSS Changes
Showing?}\label{why-arent-my-modules-javascript-and-css-changes-showing}

To determine why JavaScript and CSS updates to your module aren't having
an effect in your browser, perform these checks:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  If you're developing a portlet module, check that your portlet class
  has the correct properties specified in its \texttt{@Component}
  annotation:

  \begin{itemize}
  \tightlist
  \item
    Make sure the resources referred to by the properties of your
    portlet class's \texttt{@Component} annotation exist in the correct
    location in your module project.
  \item
    Make sure that you're using a portlet CSS wrapper class to prevent
    potential CSS ID and class name conflicts with other applications on
    the page.
  \end{itemize}

  For example, consider this sample portlet class:

\begin{verbatim}
@Component(
    immediate = true,
    property = {
        "com.liferay.portlet.css-class-wrapper=example-portlet",
        "com.liferay.portlet.display-category=category.sample",
        "com.liferay.portlet.instanceable=true",
        "com.liferay.portlet.header-portlet-css=/css/main.css",
        "com.liferay.portlet.header-portlet-javascript=/css/main.js",
        "javax.portlet.display-name=Example Portlet",
        "javax.portlet.init-param.template-path=/",
        "javax.portlet.init-param.view-template=/view.jsp",
        "javax.portlet.name=" + ExamplePortletKeys.TicTacToe,
        "javax.portlet.resource-bundle=content.Language",
        "javax.portlet.security-role-ref=power-user,user"
    },
    service = Portlet.class
)
public class ExamplePortlet extends MVCPortlet {

}
\end{verbatim}

  As described in the first item above, the portlet's CSS file is
  specified by the property
  \texttt{com.liferay.portlet.header-portlet-css}. Paths specified as
  values of this property are relative to the module's
  \texttt{src/main/resources/META-INF/resources} folder. So if you
  specify a value of \texttt{css/main.css}, the actual path to the CSS
  file in the module is
  \texttt{src/main/resources/META-INF/resources/css/main.css}. The path
  to your portlet's JavaScript file is specified by the property
  \texttt{com.liferay.portlet.header-portlet-javascript}. Values for
  this property work the same as the values for the CSS property.

  Also note that the property
  \texttt{com.liferay.portlet.css-class-wrapper} specifies the CSS class
  wrapper \texttt{example-portlet}. Thus, you should use subclasses of
  \texttt{example-portlet} in your portlet's actual CSS file. For
  example, in \texttt{main.css} you'd do this to change the background
  to green:

\begin{verbatim}
.example-portlet {
    .greenBackground {
        background-color: green;
    }

    ... (further properties)

}
\end{verbatim}

  In other words, to avoid CSS class and ID name conflicts, all the CSS
  properties you specify must be subclasses of the class specified via
  the \texttt{com.liferay.portlet.css-class-wrapper} property. Liferay
  DXP wraps your portlet's HTML content with a
  \texttt{\textless{}div\textgreater{}}. The class specified by
  \texttt{com.liferay.portlet.css-class-wrapper}
  (\texttt{example-portlet}, in this example) has been applied to this
  \texttt{\textless{}div\textgreater{}}.
\item
  Check that caching isn't preventing JS and CSS updates to your module
  from appearing in your browser:

  \begin{itemize}
  \tightlist
  \item
    Clear your browser's cache.
  \item
    During development, enable developer mode to turn off Liferay DXP's
    resource caching.
    \href{/docs/7-1/tutorials/-/knowledge_base/t/using-developer-mode-with-themes}{Click
    here} to learn how to enable Liferay DXP's developer mode.
  \end{itemize}
\end{enumerate}

\subsection{Related Topics}\label{related-topics-349}

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-developer-mode-with-themes}{Using
Developer Mode with Themes}

\section{Why Aren't JSP overrides I Made Using Fragments
Showing?}\label{why-arent-jsp-overrides-i-made-using-fragments-showing}

\noindent\hrulefill

\textbf{Important:} It's strongly recommended to
\href{/docs/7-1/tutorials/-/knowledge_base/t/customizing-jsps}{customize
JSPs using Liferay DXP's API}. Since overriding a JSP using an OSGi
fragment is not based on APIs there's no way to guarantee that it will
fail gracefully. Instead, if your customization is buggy (because of
your code or because of a change in Liferay), you are most likely to
find out at runtime, where functionality breaks and nasty log errors
greet you. Overriding a JSP using a fragment should only be used as a
last resort.

\noindent\hrulefill

The fragment module must specify the exact version of the host module. A
Liferay DXP upgrade might have changed some JSPs in the host module,
prompting a version update. If this occurs, check that your JSP
customizations are compatible with the updated host JSPs and then update
your fragment module's targeted version to match the host module.

For example, this \texttt{bnd.bnd} file from a fragment module uses
\texttt{Fragment-Host} to specify the host module and host module
version:

\begin{verbatim}
Bundle-Name: custom-login-jsp
Bundle-SymbolicName: custom.login.jsp
Bundle-Version: 1.0.0
Fragment-Host: com.liferay.login.web;bundle-version="1.1.18"
\end{verbatim}

\href{/docs/7-1/tutorials/-/knowledge_base/t/configuring-dependencies\#finding-liferay-app-and-independent-artifacts}{Finding
versions of deployed modules} is straightforward.

\subsection{Related Topics}\label{related-topics-350}

\href{/docs/7-1/tutorials/-/knowledge_base/t/jsp-overrides-using-portlet-filters}{JSP
Overrides using Portlet Filters}

\href{/docs/7-1/tutorials/-/knowledge_base/t/customizing-jsps}{Customizing
JSPs}

\href{/docs/7-1/tutorials/-/knowledge_base/t/configuring-dependencies}{Configuring
Dependencies}

\section{Why doesn't the package I use from the fragment host
resolve?}\label{why-doesnt-the-package-i-use-from-the-fragment-host-resolve}

An OSGi fragment can access all of the fragment host's packages---it
doesn't need to import them from another bundle. bnd adds external
packages the fragment uses (even ones in the fragment host) to the
fragment's \texttt{Import-Package:\ {[}package{]},...} OSGi manifest
header. That's fine for packages exported to the OSGi runtime. The
problem is, however, when bnd tries to import a host's internal package
(a package the host doesn't export). The OSGi runtime can't activate the
fragment because the internal package remains an
\texttt{Unresolved\ requirement}---a fragment shouldn't import a
fragment host's packages.

Resolve the issue by explicitly excluding host packages that the host
doesn't export.

For example, this fragment bundle's JSP uses classes from the fragment
host bundle's internal package
\texttt{com.liferay.portal.search.web.internal.custom.facet.display.context}:

\begin{verbatim}
<%@
page import="com.liferay.portal.search.web.internal.custom.facet.display.context.CustomFacetDisplayContext" %><%@
page import="com.liferay.portal.search.web.internal.custom.facet.display.context.CustomFacetTermDisplayContext" %>
\end{verbatim}

Since the example host bundle doesn't export the package, the fragment
bundle can avoid importing the package by using an OSGi manifest header,
like the one below, to explicitly exclude the package from package
imports:

\begin{verbatim}
Import-Package: !com.liferay.portal.search.web.internal.*,*
\end{verbatim}

\section{Sort Order Changed with a Different
Database}\label{sort-order-changed-with-a-different-database}

If you've been using Liferay DXP, but are switching it to use a
different database type, consult your database vendor documentation to
understand your old and new database's default query result order. The
default order is either case-sensitive or case-insensitive. This affects
entity sort order in Liferay DXP.

Here are some examples of ascending alphabetical sort order.

Case-sensitive:

\begin{verbatim}
111
222
AAA
BBB
aaa
bbb
\end{verbatim}

Case-insensitive:

\begin{verbatim}
111
222
AAA
aaa
BBB
bbb
\end{verbatim}

Your new database's default query result order might differ from your
current database's order.

Consult your vendor's documentation to configure the order the way you
want.

\section{Disabling Cache for Table Mapper
Tables}\label{disabling-cache-for-table-mapper-tables}

Service Builder creates
\href{/docs/7-1/tutorials/-/knowledge_base/t/defining-relationships-between-service-entities}{relational
mappings between entities}. It uses mapping tables to associate the
entities. In your \texttt{service.xml} file, both entities have a
\texttt{mapping-table} column attribute of the format
\texttt{mapping-table="table1\_table2"}. For example, a
\texttt{service.xml} that maps \texttt{AssetEntry}s to
\texttt{AssetCategory}s has an \texttt{AssetCategory} entity with this
column:

\begin{verbatim}
<column entity="AssetEntry" 
mapping-table="AssetEntries_AssetCategories" 
name="entries" type="Collection" />
\end{verbatim}

and an \texttt{AssetEntry} entity element with this column:

\begin{verbatim}
<column entity="AssetCategory" 
mapping-table="AssetEntries_AssetCategories" 
name="categories" type="Collection" />
\end{verbatim}

By default, a table mapper cache is associated with each mapping table.
The cache optimizes object retrieval. In some cases, however, it's best
to disable a table mapper cache.

\subsection{Why would I want to disable cache on a table
mapper?}\label{why-would-i-want-to-disable-cache-on-a-table-mapper}

Super-large entity tables can result in a memory-hogging table mapper
cache. For this reason, consider disabling cache on a table mapper.

The
\href{https://docs.liferay.com/dxp/portal/7.1-latest/propertiesdoc/portal.properties.html\#Table\%20Mapper}{\texttt{table.mapper.cacheless.mapping.table.names}
Portal property} disables cache for table mappers associated with the
specified mapping tables. Here's the default property setting:

\begin{verbatim}
##
## Table Mapper
##

  #
  # Set a list of comma delimited mapping table names that will not be using
  # cache in their table mappers.
  #
  table.mapper.cacheless.mapping.table.names=\
    Users_Groups,\
    Users_Orgs,\
    Users_Roles,\
    Users_Teams,\
    Users_UserGroups
\end{verbatim}

All of the disabled caches above pertain to the \texttt{User} object
because the table mappers tend to be much too large to have a useful
cache---each \texttt{User} can have several entries in each related
table.

Potential race conditions retrieving objects from the cache is another
reason to disable a table mapper.

For example,
\href{https://issues.liferay.com/browse/LPS-84374}{LPS-84374} describes
a race condition in which a custom entity's table mapper cache can be
cleared while in use, causing transactional rollbacks. Publishing
\texttt{AssetEntry}s clears all associated table mapper caches. If
they're published at the same time getter methods are retrieving objects
from the \texttt{AssetEntries\_AssetCategories} mapping table,
transaction rollbacks occur.

\subsection{Disabling a Table Mapper
Cache}\label{disabling-a-table-mapper-cache}

Adding a mapping table name to the
\texttt{table.mapper.cacheless.mapping.table.names} Portal property
disables the associated table mapper cache.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In your
  \href{/docs/7-1/deploy/-/knowledge_base/d/installing-liferay\#liferay-home}{\texttt{{[}Liferay\_Home{]}/portal-ext.properties}
  file}, add the current
  \texttt{table.mapper.cacheless.mapping.table.names} property setting.
  The setting is in your Liferay DXP installation's
  \texttt{portal-impl.jar/portal.properties} file.
\item
  Append your mapping table name to the list. For example, to disable
  the cache associated with a mapping table named
  \texttt{AssetEntries\_AssetCategories}, add that name to the list.

\begin{verbatim}
table.mapper.cacheless.mapping.table.names=\
    Users_Groups,\
    Users_Orgs,\
    Users_Roles,\
    Users_Teams,\
    Users_UserGroups,\
    AssetEntries_AssetCategories
\end{verbatim}
\item
  Restart the Liferay DXP instance to delete the table mapper cache.
\end{enumerate}

You've disabled an unwanted table mapper cache.

\section{Patching DXP Source Code}\label{patching-dxp-source-code}

Auto mechanics, enthusiasts, and prospective owners ask about cars,
``What's under the hood?'' Here are common reasons for asking that
question:

\begin{itemize}
\tightlist
\item
  Concern about an issue
\item
  Curiosity about the car's capability and inner-workings
\item
  Desire to improve or customize the car
\end{itemize}

You might have similar reasons for asking ``What's under \emph{DXP's}
hood?'' And since you get access to DXP Digital Enterprise (DXP)'s
source code, you can attach a debugger and see it in action! Setting up
the code locally is your ticket to exploring DXP, investigating issues,
and making improvements and customizations.

Here's how:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Download DXP, the DXP source code, and patches
\item
  Prepare DXP
\item
  Patch the DXP source code
\end{enumerate}

\subsection{Step 1: Download DXP, the DXP source code, and
patches}\label{step-1-download-dxp-the-dxp-source-code-and-patches}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Download a DXP bundle (or DXP JARs) and the DXP source code for the
  version you're using from the
  \href{https://web.liferay.com/group/customer/dxp/downloads/7-1}{customer
  portal}.
\item
  Download fix packs and their source code from
  \href{https://web.liferay.com/group/customer/dxp/downloads/7-1}{here}.
  Fix pack ZIP files that end in \texttt{-src.zip} contain a fix pack
  and source code.
\end{enumerate}

Next install and configure DXP. DXP's patching tool lets you install fix
packs and fix pack source code. If you have a patched DXP installation
already and want to use it, skip to the section below on patching the
DXP source code.

\subsection{Step 2: Prepare DXP}\label{step-2-prepare-dxp}

Preparing DXP locally involves installing, configuring, and patching
DXP.

\subsubsection{Install and Configure
DXP}\label{install-and-configure-dxp}

Here's how to install and configure DXP:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \href{/docs/7-1/deploy/-/knowledge_base/d/deploying-product}{Install
  and Deploy DXP} locally.
\item
  Start DXP.
\item
  Configure DXP to use your database.
\item
  Stop DXP.
\end{enumerate}

It's time apply the DXP patches you want.

\subsubsection{Patch DXP}\label{patch-dxp}

Here's how to patch DXP:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Copy all the patch ZIP files you want to
  \texttt{{[}LIFERAY\_HOME{]}/patching-tool/patches}. The
  \texttt{-src.zip} fix pack files are best to use because they contain
  both the fix pack binaries and source code.
\item
  Open a command line to \texttt{{[}LIFERAY\_HOME{]}/patching-tool}.
\item
  Run the command \texttt{patching-tool.sh\ auto-discovery} to generate
  the default patching profile called \texttt{default.properties}. Make
  sure the profile's properties refer to your DXP installation. See the
  \href{/docs/7-1/deploy/-/knowledge_base/d/patching-tool}{patching tool
  documentation} for more details.

  Here's an example profile:

\begin{verbatim}
patching.mode=binary
war.path=../tomcat-9.0.6/webapps/ROOT/
global.lib.path=../tomcat-9.0.6/lib/ext/
liferay.home=../
\end{verbatim}
\item
  To list all the patch files available in
  \texttt{{[}LIFERAY\_HOME{]}/patching-tool/patches}, execute the
  following command:

\begin{verbatim}
patching-tool.sh info
\end{verbatim}
\item
  Execute this command to install the patches:

\begin{verbatim}
patching-tool.sh install
\end{verbatim}

  The \href{/docs/7-1/deploy/-/knowledge_base/d/patching-tool}{patching
  tool documentation} describes additional steps that might apply to
  your situation, such as creating database indexes.
\end{enumerate}

It's time to prepare the DXP source code and patch source code.

\subsection{Step 3: Patch the DXP Source
Code}\label{step-3-patch-the-dxp-source-code}

Unzip the DXP source code to where you want to work with it.

Next you'll create a patching tool profile for your DXP source code.

\subsubsection{Create a Patching Tool Profile for the Source
Code}\label{create-a-patching-tool-profile-for-the-source-code}

Here's how to create a profile that refers to your source code.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Execute the following command to create a profile. Replace
  \texttt{{[}profile{]}} with a name for your profile.

\begin{verbatim}
patching-tool.sh auto-discovery [profile]
\end{verbatim}
\item
  In the profile properties file generated in the previous step, set the
  \texttt{patching.mode} property to \texttt{source} and set the
  \texttt{source.path} property to your source code path:

\begin{verbatim}
patching.mode=source
source.path=[DXP source code path]
\end{verbatim}
\end{enumerate}

It's time to apply the DXP patches you downloaded earlier.

\subsection{Patch the Source Code}\label{patch-the-source-code}

DXP's patching tool is safe and easy to use. Beyond installing patches,
it has these functions:

\begin{itemize}
\tightlist
\item
  List a patch's code changes
\item
  List the issues (\href{https://issues.liferay.com}{LPS/LPE tickets}) a
  patch fixes
\item
  Revert a patch
\end{itemize}

See the following patching tool documentation for more details:

\begin{itemize}
\tightlist
\item
  \href{/docs/7-1/deploy/-/knowledge_base/d/working-with-patches\#comparing-patch-levels}{Comparing
  Patch Levels}
\item
  \href{/docs/7-1/deploy/-/knowledge_base/d/working-with-patches\#uninstalling-patches}{Removing
  or Reverting Patches}
\end{itemize}

\noindent\hrulefill

In addition to using the patching tool to manage DXP source code, you
can optionally manage it in a version control system such as
\href{https://git-scm.com/}{Git}.

Here are commands for setting up the DXP source code in Git:

\begin{verbatim}
 cd [path to source code root folder]
 git init
 git add .
 git commit -a
\end{verbatim}

Here are the command descriptions:

\begin{itemize}
\tightlist
\item
  \texttt{init} creates a Git repository for the current folder (i.e.,
  the root folder) and all its contents.
\item
  \texttt{add} stages the root folder and its contents.
\item
  \texttt{commit} checks in the staged files.
\end{itemize}

You can commit any code changes (e.g., DXP patches) to your Git
repository.

\noindent\hrulefill

The patching tool installs all patches and patch source code from the
ZIP files it finds in
\texttt{{[}LIFERAY\_HOME{]}/patching-tool/patches}. All your patches
must be in the \texttt{patches} folder for the patching tool to apply
them.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Copy all the patch source ZIP files to
  \texttt{{[}LIFERAY\_HOME{]}/patching-tool/patches} if you haven't
  already copied them there.
\item
  Execute the \texttt{info} command to make sure it lists your patches.
  If a patch isn't listed, copy its ZIP file into the \texttt{patches}
  folder. Replace \texttt{{[}profile{]}} with your DXP source code
  profile name:

\begin{verbatim}
patching-tool.sh [profile] info
\end{verbatim}
\item
  Apply the patches by executing the \texttt{install} command on your
  profile:

\begin{verbatim}
patching-tool.sh [profile] install
\end{verbatim}
\end{enumerate}

Your DXP installation and source code is patched and ready to debug!

Attach your favorite debugger to your DXP instance and start the server.
See your debugger's documentation for configuration details.

Congratulations! You're free to explore DXP inside and out!

\subsection{Related Topics}\label{related-topics-351}

\href{/docs/7-1/tutorials/-/knowledge_base/t/troubleshooting-faq}{Troubleshooting
FAQ}

\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-ide}{Liferay Dev
Studio DXP}

\section{Troubleshooting Front-End Development
Issues}\label{troubleshooting-front-end-development-issues}

Front-end development involves many moving parts. Sometimes it's hard to
tell what may be causing the issues you run into along the way. This can
be particularly frustrating. These frequently asked questions and
answers help you troubleshoot and correct problems arising during
front-end development.

Here are the troubleshooting sections:

\begin{itemize}
\tightlist
\item
  \hyperref[css]{CSS}
\item
  \hyperref[modules]{Modules}
\item
  \hyperref[portlets]{Portlets}
\item
  \hyperref[templates]{Templates}
\item
  \hyperref[themes]{Themes}
\end{itemize}

Click a question to view the answer.

\subsection{CSS}\label{css-1}

\begin{itemize}
\tightlist
\item
  \hyperref[broken-css-angular-app]{Why are my CSS templates not applied
  in my Angular app?}
\item
  \hyperref[portal-css-broken-ie]{Why is Liferay Portal's CSS broken in
  Internet Explorer?}
\end{itemize}

\phantomsection\label{broken-css-angular-app}
{Why are my CSS templates not applied in my Angular app?~{}}

\begin{verbatim}
<p>A known <a href="https://github.com/angular/angular/issues/4974">bug</a> with Angular causes absolute URLs for CSS files not to be recognized.</p>
<p>Due to the nature of portals, a relative URL is not an option either because the app can be placed on any page.</p>
<p>To fix this, you can either provide the CSS with a theme or themelet, or you can specify the path to the CSS file with the <code>com.liferay.portlet.header-portlet-css</code> property in the portlet containing your Angular code.</p>
\end{verbatim}

\phantomsection\label{portal-css-broken-ie}
{Why is Liferay Portal's CSS broken in Internet Explorer?~{}}

\begin{verbatim}
<p>By default CSS files are minified in the browser. This can cause issues in Internet Explorer. You can disable this behavior by including <code>theme.css.fast.load=false</code> and <code>minifier.enabled=false</code> in your <code>portal-ext.properties</code> file. </p>
\end{verbatim}

\subsection{Modules}\label{modules-3}

\begin{itemize}
\tightlist
\item
  \hyperref[jquery-anonymous-module-error]{Why does my JQuery module
  throw an anonymous module error when I try to load it?}
\item
  \hyperref[source-maps-not-showing]{Why are my source maps not showing
  for my Angular or Typescript module?}
\item
  \hyperref[disable-bundler-analytics]{I'm using the liferay-npm-bundler
  for multiple projects. How can I disable analytics tracking for the
  entire tool across all my projects?}
\end{itemize}

\phantomsection\label{jquery-anonymous-module-error}
{Why does my JQuery module throw an anonymous module error when I try to
load it?~{}}

\begin{verbatim}
<p>If you're using an external library that you host, you must disable the <i>Expose Global</i> option as described in the <a href="https://portal.liferay.dev/docs/7-1/tutorials/-/knowledge_base/t/using-external-javascript-libraries#using-libraries-that-you-host">Using External JavaScript Libraries</a> tutorial.</p>
\end{verbatim}

\phantomsection\label{source-maps-not-showing}
{Why are my source maps not showing for my Angular or Typescript
module?~{}}

\begin{verbatim}
<p>This is due to <a href="https://issues.liferay.com/browse/LPS-83052">LPS-83052</a>.</p>
<p>To solve this, activate the <a href="https://www.typescriptlang.org/docs/handbook/compiler-options.html"><code>inlineSources</code> compiler option</a> via argument or your <code>tsconfig.json</code> file.</p>
\end{verbatim}

\phantomsection\label{disable-bundler-analytics}
{I'm using the liferay-npm-bundler for multiple projects. How can I
disable analytics tracking for the liferay-npm-bundler in my
projects?~{}}

\begin{verbatim}
<p>There are a couple options you can use to disable reporting:</p>
<ul>
  <li><p>Use the <code>--no-tracking</code> flag in your <code>package.json</code>'s build script to disable reporting:</p>
  <p><pre><code>liferay-npm-bundler --no-tracking</code></pre></p>
  </li>
  <li>
  <p>Create a <code>.liferay-npm-bundler-no-tracking</code> file in your project's root folder, or any of its ancestors, to disable reporting.</p>
  <p>This equates to answering <code>No</code> to the <code>May liferay-npm-bundler anonymously report usage statistics to improve the tool over time?</code> question.</p>
  </li>
</ul>
\end{verbatim}

\subsection{Portlets}\label{portlets-1}

\begin{itemize}
\tightlist
\item
  \hyperref[angular-react-vue-portlet-disable-spa]{I want to use a
  custom router in my Angular/React/Vue portlet. How can I disable the
  default Senna JS SPA engine in my portlet?}
\end{itemize}

\phantomsection\label{angular-react-vue-portlet-disable-spa}
{I want to use a custom router in my Angular/React/Vue portlet. How can
I disable the default Senna JS SPA engine in my portlet?~{}}

\begin{verbatim}
<p>By default, the <a href="https://portal.liferay.dev/docs/7-1/tutorials/-/knowledge_base/t/automatic-single-page-applications#what-is-sennajs">Senna JS SPA engine</a> is enabled in your portlets and sites. This disables full page reloads during portlet navigation.</p>
<p>If you want to use a custom router in your portlet instead, follow the <a href="https://portal.liferay.dev/docs/7-1/tutorials/-/knowledge_base/t/automatic-single-page-applications#disabling-spa">instructions in the SPA documentation</a> to blacklist your portlet from SPA.</p>
\end{verbatim}

\subsection{Templates}\label{templates-1}

\begin{itemize}
\tightlist
\item
  \hyperref[cacheable-web-content-taglibs]{Why does my web content break
  when I refresh the page?}
\end{itemize}

\phantomsection\label{cacheable-web-content-taglibs}
{Why does my web content break when I refresh the page?~{}}

\begin{verbatim}
<p>Some taglibs, such as the <code>liferay-map</code> taglib, have limitations when used in a cacheable template (e.g., FreeMarker and Velocity). For instance, when the <code>liferay-map</code> taglib is used in a cacheable template and the user refreshes the page, the map does not show. </p>
<p>One possible workaround is to disable cache for the template by editing it and unchecking the cacheable option. Alternatively, you can disable cache for all templates by navigating to <code>System Settings</code>&rarr;<code>Template Engines</code> and setting <code>Resource Modification Check</code> to <code>0</code>. </p>
<p>As best practice, however, we recommend that you don't use taglibs in cacheable web content. </p>
\end{verbatim}

\subsection{Themes}\label{themes-3}

\begin{itemize}
\tightlist
\item
  \hyperref[classic-base-theme]{How can I use the Classic theme as my
  base theme?}
\item
  \hyperref[osgi-headers-in-themes]{How can I include OSGi headers in my
  theme?}
\item
  \hyperref[developer-mode]{Why aren't my changes showing up after I
  redeploy my theme?}
\item
  \hyperref[default-theme-returned]{Why is my theme not loading? It
  returns the default theme instead.}
\item
  \hyperref[rtl-no-flip]{How can I prevent specific CSS rules from
  transforming for RTL Languages?}
\end{itemize}

\phantomsection\label{classic-base-theme}
{How can I use the Classic theme as my base theme?~{}}

\begin{verbatim}
<p>The Classic theme is already an implementation of an existing base theme and should not be extended. You can use the <a href="/docs/7-1/tutorials/-/knowledge_base/t/copying-an-existing-themes-files">Gulp kickstart</a> task to copy files from the Classic theme into your theme if you wish. If you want to start off with some base styling, start with the Styled theme instead.</p>
\end{verbatim}

\phantomsection\label{osgi-headers-in-themes}
{How can I include OSGi headers in my theme?~{}}

\begin{verbatim}
<p>Specify the headers you want to use in your theme's <code>liferay-plugin-package.properties</code> file. Any headers placed in this file are included automatically in your MANIFEST and the OSGi bundle.</p>
<p>For example, you can add OSGi dependencies in your theme by importing the exported package with the <code>Import-Package</code> header:</p>
<pre><code>Import-Package:com.liferay.docs.portlet</code></pre>
\end{verbatim}

\phantomsection\label{developer-mode}
{Why aren't my changes showing up after I redeploy my theme?~{}}

\begin{verbatim}
<p>By default CSS, JS, and theme template files are cached in the browser. During development, you can enable <a href="/docs/7-1/tutorials/-/knowledge_base/t/using-developer-mode-with-themes">Devloper Mode</a> to prevent your theme's files from caching. </p>
\end{verbatim}

\phantomsection\label{default-theme-returned}
{Why is my theme not loading? It returns the default theme instead.~{}}

\begin{verbatim}
<p>If you receive the warning "No theme found for specified theme id...", you may be referencing an outdated theme ID in your Site. Verify that the theme ID in your theme's <code>liferay-look-and-feel.xml</code> matches the theme ID in the warning message: "mytheme_WAR_mytheme". If the theme IDs match, there may be pages using the outdated theme instead of the Site theme. You can verify this by checking the pages manually or searching the database for layouts with values for <code>themeId -</code>. </p>
\end{verbatim}

\phantomsection\label{rtl-no-flip}
{How can I prevent specific CSS rules from transforming for RTL
Languages?~{}}

\begin{verbatim}
<p>You can prevent specific CSS rules from transforming (flipping) with the <code>/* @noflip */</code> decoration. Place the decoration to the left of the CSS rule to apply it. For example, this rule gives a left margin of <code>20em</code> to the <code>body</code> no matter if the selected language is LTR or RTL:</p>
  <pre><code>
  /* @noflip */ body {
   margin-left: 20em;
  }
  </pre></code>
<p>You can also use the <code>.rtl</code> CSS selector for rules that exclusively apply to RTL languages.</p>
\end{verbatim}

\section{System Check}\label{system-check}

During development, all kinds of strange things can happen in the OSGi
container. Liferay's \texttt{system:check}
\href{/docs/7-1/reference/-/knowledge_base/r/using-the-felix-gogo-shell}{Gogo
shell} command can help you see what's happening. You can enable it to
run as the last Portal startup step and you can execute it any time in
Gogo shell.

\texttt{system:check} aggregates these commands:

\begin{itemize}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/detecting-unresolved-osgi-components\#dsunsatisfied-command}{\texttt{ds:unsatisfied}}:
  Reports unsatisfied Declarative Service components.
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/detecting-unresolved-osgi-components\#dm-na-command}{\texttt{dm\ na}}:
  Reports unsatisfied Dependency Manager service components, including
  Service Builder services.
\end{itemize}

System checking functionality from future Liferay tools will be added to
\texttt{system:check}.

\href{/docs/7-1/tutorials/-/knowledge_base/t/using-developer-mode-with-themes}{Developer
mode} runs \texttt{system:check} automatically on every startup.

You can enable \texttt{system:check} to run on startup outside of
developer mode by setting this property in your
\texttt{portal-ext.properties} file:

\begin{verbatim}
module.framework.properties.initial.system.check.enabled=true
\end{verbatim}

As stated previously, you can run the \texttt{system:check} command any
time in
\href{/docs/7-1/reference/-/knowledge_base/r/using-the-felix-gogo-shell}{Gogo
shell}. Enjoy detecting unresolved components and other issues fast
using \texttt{system:check}.

\subsection{Related Topics}\label{related-topics-352}

\href{/docs/7-1/tutorials/-/knowledge_base/t/detecting-unresolved-osgi-components}{Detecting
Unresolved OSGi Components}

\href{/docs/7-1/reference/-/knowledge_base/r/using-the-felix-gogo-shell}{Gogo
shell}

\section{Detecting Unresolved OSGi
Components}\label{detecting-unresolved-osgi-components}

Liferay DXP includes
\href{/docs/7-1/reference/-/knowledge_base/r/using-the-felix-gogo-shell}{Gogo
shell} commands that come in handy when trying to diagnose a problem due
to an unresolved OSGi component. The specific tools to use depend on the
component framework of the unresolved component. Most Liferay DXP
components are developed using Declarative Services (DS), also known as
SCR (Service Component Runtime). An exception to this is Liferay DXP's
Service Builder services, which are Dependency Manager (DM) components.
Both
\href{http://felix.apache.org/documentation/subprojects/apache-felix-service-component-runtime.html}{Declarative
Services} and
\href{http://felix.apache.org/documentation/subprojects/apache-felix-dependency-manager.html}{Dependency
Manager} are Apache Felix projects.

The unresolved component troubleshooting instructions are divided into
these sections:

\begin{itemize}
\tightlist
\item
  \hyperref[declarative-services-components]{Declarative Services
  Components}

  \begin{itemize}
  \tightlist
  \item
    \hyperref[declarative-services-unsatisfied-component-scanner]{Declarative
    Services Unsatisfied Component Scanner}
  \item
    \hyperref[dsunsatisfied-command]{ds:unsatisfied Command}
  \end{itemize}
\item
  \hyperref[service-builder-components]{Service Builder Components}

  \begin{itemize}
  \tightlist
  \item
    \hyperref[unavailable-component-scanner]{Unavailable Component
    Scanner}
  \item
    \hyperref[dm-na-command]{dm na Command}
  \item
    \hyperref[serviceproxyfactory]{\texttt{ServiceProxyFactory}}
  \end{itemize}
\end{itemize}

\subsection{Declarative Services
Components}\label{declarative-services-components}

Start with DS, since most Liferay DXP components, apart from Service
Builder components, are DS components. Suppose one of your bundle's
components has an unsatisfied service reference. How can you detect
this? Two ways:

\begin{itemize}
\item
  Enable a
  \hyperref[declarative-services-unsatisfied-component-scanner]{Declarative
  Services Unsatisfied Component Scanner} to report unsatisfied
  references automatically or
\item
  Use the \hyperref[dsunsatisfied-command]{Gogo shell command
  \texttt{ds:unsatisfied}} to check for them manually.
\end{itemize}

\subsubsection{Declarative Services Unsatisfied Component
Scanner}\label{declarative-services-unsatisfied-component-scanner}

Here's how to enable the unsatisfied component scanner:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a file
  \texttt{com.liferay.portal.osgi.debug.declarative.service.internal.configuration.UnsatisfiedComponentScannerConfiguration.cfg}.
\item
  Add the following content:

  \texttt{unsatisfiedComponentScanningInterval=5}
\item
  Copy the file into \texttt{{[}LIFERAY\_HOME{]}/osgi/configs}.
\end{enumerate}

The scanner detects and logs unsatisfied service component references.
The log message describes the bundle, the referencing DS component
class, and the referenced component.

Here's an example scanner message:

\begin{verbatim}
11:18:28,881 WARN  [Declarative Service Unsatisfied Component Scanner][UnsatisfiedComponentScanner:91]
Bundle {id: 631, name: com.liferay.blogs.web, version: 2.0.0}
    Declarative Service {id: 3333, name: com.liferay.blogs.web.internal.portlet.action.EditEntryMVCRenderCommand, unsatisfied references:
        {name: ItemSelectorHelper, target: null}
    }
\end{verbatim}

The message above warns that the \texttt{com.liferay.blogs.web} bundle's
DS component
\texttt{com.liferay.blogs.web.internal.portlet.action.EditEntryMVCRenderCommand}
has an unsatisfied reference to a component of type
\texttt{ItemSelectorHelper}. The referencing component's ID (SCR ID) is
\texttt{3333} and its bundle ID is \texttt{631}.

\subsubsection{ds:unsatisfied Command}\label{dsunsatisfied-command}

Another way to detect unsatisfied component references is to invoke the
Gogo shell command \texttt{ds:unsatisfied}.

\begin{itemize}
\tightlist
\item
  \texttt{ds:unsatisfied} shows all unsatisfied DS components
\item
  \texttt{ds:unsatisfied\ {[}BUNDLE\_ID{]}} shows the bundle's
  unsatisfied DS components
\end{itemize}

To view more detailed information about the unsatisfied DS component,
pass the component's ID to the command
\texttt{scr:info\ {[}component\ ID{]}}. For example, the following
command does this for a component with ID \texttt{1701}:

\begin{verbatim}
g! scr:info 1701
*** Bundle: org.foo.bar.command (507)
Component Description:
    Name: org.foo.bar.command
    Implementation Class: org.foo.bar.command.FooBarCommand
    Default State: enabled
    Activation: delayed
    Configuration Policy: optional
    Activate Method: activate
    Deactivate Method: deactivate
    Modified Method: -
    Configuration Pid: [org.foo.bar.command]
    Services:
        org.foo.bar.command.DuckQuackCommand
    Service Scope: singleton
    Reference: Duck
        Interface Name: org.foo.bar.api.Foo
        Cardinality: 1..1
        Policy: static
        Policy option: reluctant
        Reference Scope: bundle
    Component Description Properties:
        osgi.command.function = foo
        osgi.command.scope = bar
    Component Configuration:
        ComponentId: 1701
        State: unsatisfied reference
        UnsatisfiedReference: Foo
        Target: null
        (no target services)
        Component Configuration Properties:
        component.id = 1701
        component.name = org.foo.bar.command
        osgi.command.function = foo
        osgi.command.scope = bar
\end{verbatim}

In the \texttt{Component\ Configuration} section,
\texttt{UnsatisfiedReference} lists the unsatisfied reference's type.
This bundle's component isn't working because it's missing a
\texttt{Foo} service. Now you can focus on why \texttt{Foo} is
unavailable. The solution may be as simple as starting or deploying a
bundle that provides the \texttt{Foo} service.

\subsection{Service Builder
Components}\label{service-builder-components}

Service Builder modules are implemented using Spring. Liferay DXP uses
\href{http://felix.apache.org/documentation/subprojects/apache-felix-dependency-manager.html}{the
Apache Felix Dependency Manager} to manage Service Builder module OSGi
components via the
\href{https://repository.liferay.com/nexus/content/repositories/liferay-public-releases/com/liferay/com.liferay.portal.spring.extender/}{Portal
Spring Extender} module.

When developing a Liferay Service Builder application, you might
sometimes have an unresolved Spring-related OSGi component. This can
occur if you update your application's database schema but forget to
trigger an upgrade (for information on creating database upgrade
processes for your Liferay DXP applications, see the tutorial
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-an-upgrade-process-for-your-app}{Creating
an Upgrade Process for Your App}).

These features detect unresolved Service Builder related components.

\begin{itemize}
\tightlist
\item
  \hyperref[unavailable-component-scanner]{Unavailable Component
  Scanner}
\item
  \hyperref[dm-na-command]{dm na Command}
\item
  \hyperref[serviceproxyfactory]{ServiceProxyFactory}
\end{itemize}

\subsubsection{Unavailable Component
Scanner}\label{unavailable-component-scanner}

The
\href{https://repository.liferay.com/nexus/content/repositories/liferay-public-releases/com/liferay/com.liferay.portal.osgi.debug.spring.extender/}{OSGi
Debug Spring Extender} module's Unavailable Component Scanner reports
missing components in modules that use Service Builder. Here's how to
enable the scanner:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create the configuration file
  \texttt{com.liferay.portal.osgi.debug.spring.extender.internal.configuration.UnavailableComponentScannerConfiguration.cfg}.
\item
  In the configuration file, set the time interval (in seconds) between
  scans:

  \texttt{unavailableComponentScanningInterval=5}
\item
  Copy the file into \texttt{{[}LIFERAY\_HOME{]}/osgi/configs}.
\end{enumerate}

The scanner reports Spring extender dependency manager component status
on the set interval. If all components are registered, the scanner sends
a confirmation message.

\begin{verbatim}
11:10:53,817 INFO  [Spring Extender Unavailable Component Scanner][UnavailableComponentScanner:166] All Spring extender dependency manager components are registered
\end{verbatim}

If a component is unavailable, it warns you:

\begin{verbatim}
11:13:08,851 WARN  [Spring Extender Unavailable Component Scanner][UnavailableComponentScanner:173] Found unavailable component in bundle com.liferay.screens.service_1.0.28 [516].
Component ComponentImpl[null com.liferay.portal.spring.extender.internal.context.ModuleApplicationContextRegistrator@1541eee] is unavailable due to missing required dependencies: ServiceDependency[interface com.liferay.blogs.service.BlogsEntryService null].
\end{verbatim}

Component unavailability, such as what's reported above, can occur when
DS components and Service Builder components are published and used in
the same module. Use separate modules to publish DS components and
Service Builder components.

\subsubsection{dm na Command}\label{dm-na-command}

Dependency Manager's
\href{http://felix.apache.org/documentation/subprojects/apache-felix-dependency-manager/tutorials/leveraging-the-shell.html}{Gogo
shell command \texttt{dm}} lists all Service Builder components, their
required services, and whether each required service is available.

To list unresolved components only execute this Gogo shell command:

\texttt{dm\ na}

The \texttt{na} option stands for ``not available.''

\subsubsection{ServiceProxyFactory}\label{serviceproxyfactory}

Liferay DXP's logs report unresolved Service Builder components too. For
example, Liferay DXP logs an error when a Service Proxy Factory can't
create a new instance of a Service Builder based entity because a
service component is unresolved.

The following code demonstrates using a
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/util/ServiceProxyFactory.html}{\texttt{ServiceProxyFactory}
class} to create a new entity instance:

\begin{verbatim}
private static volatile MessageBus _messageBus =
    ServiceProxyFactory.newServiceTrackedInstance(
        MessageBus.class, MessageBusUtil.class, "_messageBus", true);
\end{verbatim}

This message alerts you to the unavailable service:

\begin{verbatim}
11:07:35,139 ERROR [localhost-startStop-1][ServiceProxyFactory:265] Service "com.liferay.portal.kernel.messaging.sender.SingleDestinationMessageSenderFactory" is unavailable in 60000 milliseconds while setting field "_singleDestinationMessageSenderFactory" for class "com.liferay.portal.kernel.messaging.sender.SingleDestinationMessageSenderFactoryUtil", will retry...
\end{verbatim}

Based on the message above, there's no bundle providing the service
\texttt{com.liferay.portal.kernel.messaging.sender.SingleDestinationMessageSenderFactory}.

Now you can detect unresolved components, DS and DM components,
automatically using scanners, manually using Gogo shell commands, and
programmatically using a \texttt{ServiceProxyFactory}.

\subsection{Related Topics}\label{related-topics-353}

\href{/docs/7-1/tutorials/-/knowledge_base/t/system-check}{System Check}

\section{Using Files to Configure Module
Components}\label{using-files-to-configure-module-components}

Liferay DXP uses
\href{http://felix.apache.org/documentation/subprojects/apache-felix-file-install.html}{Felix
File Install} to monitor file system folders for new/updated
configuration files, and the \href{http://felix.apache.org/}{Felix OSGi
implementation} of
\href{http://felix.apache.org/documentation/subprojects/apache-felix-config-admin.html}{Configuration
Admin} to let you use files to configure module service components.

To learn how to work with configuration files, first review
\href{/docs/7-1/user/-/knowledge_base/u/understanding-system-configuration-files}{Understanding
System Configuration Files}.

\subsection{Configuration File
Formats}\label{configuration-file-formats}

There are two different configuration file formats:

\begin{itemize}
\tightlist
\item
  \texttt{.cfg}: An older, simple format that only supports
  \texttt{String} values as properties.
\item
  \texttt{.config}: A format that supports strings, type information,
  and other non-string values in its properties.
\end{itemize}

Although Liferay DXP supports both formats, use \texttt{.config} files
for their flexibility and ability to use type information. Since
\texttt{.cfg} files lack type information, if you want to store anything
but a \texttt{String}, you must use properties utility classes to cast
\texttt{String}s to intended types (and you must carefully document
properties that aren't \texttt{String}s). \texttt{.config} files
eliminate this need by allowing type information. The articles below
explain the file formats:

\begin{itemize}
\tightlist
\item
  \href{/docs/7-1/user/-/knowledge_base/u/understanding-system-configuration-files}{Understanding
  System Configuration Files}
\item
  \href{https://sling.apache.org/documentation/bundles/configuration-installer-factory.html\#configuration-files-config}{Configuration
  file (\texttt{.config}) syntax}
\item
  \href{https://sling.apache.org/documentation/bundles/configuration-installer-factory.html\#property-files-cfg}{Properties
  file(\texttt{.cfg}) syntax}
\end{itemize}

\subsection{Naming Configuration
Files}\label{naming-configuration-files}

Before you
\href{/docs/7-1/user/-/knowledge_base/u/creating-configuration-files}{create
a configuration file}, follow these steps to determine whether multiple
instances of the component can be created or if the component is
intended to be a singleton:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Deploy the component's module if you haven't done so already.
\item
  In Liferay DXP's UI, go to \emph{Control Panel} → \emph{Configuration}
  → \emph{System Settings}.
\item
  Find the component's settings by searching or browsing for the
  component.
\item
  If the component's settings page has a section called
  \emph{Configuration Entries}, you can create multiple instances of the
  component configured however you like. Otherwise, you should treat the
  component as a singleton.
\end{enumerate}

\begin{figure}
\centering
\includegraphics{./images/system-settings-page-lists-configuration-entries.png}
\caption{You can create multiple instances of components whose System
Settings page has a \emph{Configuration Entries} section.}
\end{figure}

\emph{All} configuration file names must start with the component's PID
(PID stands for \emph{persistent identity}) and end with
\texttt{.config} or \texttt{.cfg}.

For example, this class uses
\href{/docs/7-1/tutorials/-/knowledge_base/t/osgi-services-and-dependency-injection-with-declarative-services}{Declarative
Services} to define a component:

\begin{verbatim}
package com;
@Component
class Foo {}
\end{verbatim}

The component's PID is \texttt{com.Foo}. All the component's
configuration files must start with the PID \texttt{com.Foo}.

For each non-singleton component instance you want to create or update
with a configuration, you must use a uniquely named configuration file
that starts with the component's PID and ends with \texttt{.config} or
\texttt{.cfg}. Creating configurations for multiple component instances
requires that the configuration files use different \emph{subnames}. A
subname is the part of a configuration file name after the PID and
before the suffix \texttt{.config} or \texttt{.cfg}. Here's the
configuration file name pattern for non-singleton components:

\begin{itemize}
\tightlist
\item
  \texttt{{[}PID{]}-{[}subname1{]}.config}
\item
  \texttt{{[}PID{]}-{[}subname2{]}.config}
\item
  etc.
\end{itemize}

For example, you could configure two different instances of the
component \texttt{com.Foo} by using configuration files with these
names:

\begin{itemize}
\tightlist
\item
  \texttt{com.Foo-one.config}
\item
  \texttt{com.Foo-two.config}
\end{itemize}

Each configuration file creates and/or updates an instance of the
component that matches the PID. The subname is arbitrary---it doesn't
have to match a specific component instance. This means you can use
whatever subname you like. For example, these configuration files are
just as valid as the two above:

\begin{itemize}
\tightlist
\item
  \texttt{com.Foo-puppies.config}
\item
  \texttt{com.Foo-kitties.config}
\end{itemize}

Using the subname \texttt{default}, however, is Liferay DXP's convention
for configuring a component's first instance. The file name pattern is
therefore

\begin{verbatim}
[PID]-default.config
\end{verbatim}

A singleton component's configuration file must also start with
\texttt{{[}PID{]}} and end with \texttt{.config} or \texttt{.cfg}.
Here's the common pattern used for singleton component configuration
file names:

\begin{verbatim}
[PID].config
\end{verbatim}

When you're done creating a configuration file, you can
\href{/docs/7-1/user/-/knowledge_base/u/creating-configuration-files\#deploying-a-configuration-file}{deploy
it}.

\subsection{Resolving Configuration File Deployment
Failures}\label{resolving-configuration-file-deployment-failures}

The following \texttt{IOException} hints that the configuration file has
a syntax issue:

\begin{verbatim}
Failed to install artifact: [path to .config or .cfg file]
java.io.IOException: Unexpected token 78; expected: 61 (line=0, pos=107)
\end{verbatim}

To resolve this, fix the
\hyperref[configuration-file-formats]{configuration file's syntax}.

Great! Now you know how to configure module components using
configuration files.

\subsection{Related Articles}\label{related-articles-4}

\href{/docs/7-1/user/-/knowledge_base/u/understanding-system-configuration-files}{Understanding
System Configuration Files}

\section{Calling Non-OSGi Code that Uses OSGi
Services}\label{calling-non-osgi-code-that-uses-osgi-services}

Liferay DXP's static service utilities (e.g., \texttt{UserServiceUtil},
\texttt{CompanyServiceUtil}, \texttt{GroupServiceUtil}, etc.) are
examples of non-OSGi code that use OSGi services. Service Builder
generates them for backwards compatibility purposes only. If you're
tempted to call a \texttt{*ServiceUtil} class or your existing code
calls one, access the \texttt{*Service} directly instead using one these
alternatives:

\begin{itemize}
\item
  If your class is a Declarative Services component, use an
  \href{/docs/7-1/tutorials/-/knowledge_base/t/osgi-services-and-dependency-injection-with-declarative-services}{\texttt{@Reference}
  annotation} to access the \texttt{*Service} class.
\item
  If your class isn't a Declarative Services component, use a
  \href{/docs/7-1/tutorials/-/knowledge_base/t/service-trackers}{\texttt{ServiceTracker}}
  to access the \texttt{*Service} class.
\end{itemize}

You can check the state of Liferay DXP's services in
\href{/docs/7-1/reference/-/knowledge_base/r/using-the-felix-gogo-shell}{the
Gogo shell}. The \texttt{scr:list} Gogo shell command shows all
Declarative Services components, including inactive ones from
unsatisfied dependencies. To find unsatisfied dependencies for Service
Builder services, use the Dependency Manager's
\texttt{dependencymanager:dm\ wtf} command. Note that these commands
only show components that haven't been activated because of unsatisfied
dependencies. They don't show pure service trackers that are waiting for
a service because of unsatisfied dependencies.

\subsection{Related Topics}\label{related-topics-354}

\href{/docs/7-1/tutorials/-/knowledge_base/t/detecting-unresolved-osgi-components}{Detecting
Unresolved OSGi Components}

\href{/docs/7-1/reference/-/knowledge_base/r/using-the-felix-gogo-shell}{Felix
Gogo Shell}

\href{/docs/7-1/tutorials/-/knowledge_base/t/osgi-basics-for-liferay-development}{OSGi
Basics For Liferay Development}

\section{Liferay DXP Failed to Initialize Because the Database Wasn't
Ready}\label{liferay-dxp-failed-to-initialize-because-the-database-wasnt-ready}

If you start your database server and application server at the same
time, Liferay DXP might try connecting to the data source before the
database is ready. By default, Liferay DXP doesn't retry connecting to
the database; it just fails. But there is a way to avoid this situation:
database connection retries.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a \texttt{portal-ext.properties} file in your
  \href{/docs/7-1/deploy/-/knowledge_base/d/installing-liferay\#liferay-home}{Liferay
  Home} folder.
\item
  Set the property \texttt{retry.jdbc.on.startup.max.retries} equal to
  the number of times to retry connecting to the data source.
\item
  Set property \texttt{retry.jdbc.on.startup.delay} equal to the number
  of seconds to wait before retrying connection.
\end{enumerate}

If at first the connection doesn't succeed, Liferay DXP uses the retry
settings to try again.

\subsection{Related Topics}\label{related-topics-355}

\href{/docs/7-1/tutorials/-/knowledge_base/t/connecting-to-data-sources-using-jndi}{Connecting
to JNDI Data Sources}

\section{Using OSGi Services from EXT
Plugins}\label{using-osgi-services-from-ext-plugins}

\href{/docs/7-1/tutorials/-/knowledge_base/t/service-trackers}{\texttt{ServiceTrackers}}
are the best way for Ext plugins to access OSGi services. They account
for the possibility of OSGi services coming and going.

\subsection{Related Topics}\label{related-topics-356}

\href{/docs/7-1/tutorials/-/knowledge_base/t/detecting-unresolved-osgi-components}{Detecting
Unresolved OSGi Components}

\href{/docs/7-1/reference/-/knowledge_base/r/using-the-felix-gogo-shell}{Felix
Gogo Shell}

\href{/docs/7-1/tutorials/-/knowledge_base/t/osgi-basics-for-liferay-development}{OSGi
Basics For Liferay Development}

\chapter{Data Upgrades}\label{data-upgrades}

The development process doesn't end when you first release your
application. Through your own planning, feature requests, and bug
reports, developers improve their applications on a regular basis.

Sometimes, those changes result in changes to the data structure and
underlying database. When users upgrade, they need a process that
transitions them to improved versions of your application. For this, you
must create an upgrade process.

This section shows how to do that.

\section{Creating Data Upgrade Processes for
Modules}\label{creating-data-upgrade-processes-for-modules}

Some changes you make to a module involve modifying the database. These
changes bring with them the need for an upgrade process to move your
module's database from one version to the next. Liferay has an upgrade
framework you can use to make this easier to do. It's a feature-rich
framework that makes upgrades safe: the system records the current state
of the schema so that if the upgrade fails, the process can revert the
module back to its previous version.

\noindent\hrulefill

\textbf{Note}: Upgrade processes for traditional Liferay plugins (WAR
files) work
\href{/docs/7-1/tutorials/-/knowledge_base/t/optimizing-app-upgrade-processes\#understanding-liferay-portal-6-upgrade-processes}{the
same way they did for Liferay Portal 6.x}.

\noindent\hrulefill

Liferay DXP's upgrade framework executes your module's upgrades
automatically when the new version starts for the first time. You
implement concrete data schema changes in upgrade step classes and then
register them with the upgrade framework using an upgrade step
registrator. In this tutorial, you'll learn how to do all these things
to create an upgrade process for your module.

Here's what's involved:

\begin{itemize}
\item
  \textbf{\hyperref[specifying-the-schema-version]{Specifying the schema
  version}}
\item
  \textbf{\hyperref[declaring-dependencies]{Declaring dependencies}}
\item
  \textbf{\hyperref[writing-upgrade-steps]{Writing upgrade steps}}
\item
  \textbf{\hyperref[writing-the-upgrade-step-registrator]{Writing the
  registrator}}
\item
  \textbf{\hyperref[waiting-for-upgrade-completion]{Waiting for upgrade
  completion}}
\end{itemize}

It's time to get started.

\subsection{Specifying the Schema
Version}\label{specifying-the-schema-version}

In your module's \texttt{bnd.bnd} file, specify a
\texttt{Liferay-Require-SchemaVersion} header with the new schema
version value. Here's an example schema version header for a module
whose new schema is version \texttt{1.1}:

\begin{verbatim}
Liferay-Require-SchemaVersion: 1.1
\end{verbatim}

Specifying the major and minor schema version only (format
\texttt{major.minor}) gives your module flexibility to use any micro
schema version. This lets you disregard new micro schema versions or
upgrade to them when you want. You can also revert micro schema
versions.

\noindent\hrulefill

\textbf{Important}: If no \texttt{Liferay-Require-SchemaVersion} header
is specified, Liferay DXP considers the \texttt{Bundle-Version} header
value to be the database schema version.

\noindent\hrulefill

Next, you'll specify your upgrade's dependencies.

\subsection{Declaring Dependencies}\label{declaring-dependencies}

In your module's dependency management file (e.g., Maven POM, Gradle
build file, or Ivy \texttt{ivy.xml} file),
\href{/docs/7-1/tutorials/-/knowledge_base/t/configuring-dependencies}{add
a dependency} on the
\href{https://repository.liferay.com/nexus/content/repositories/liferay-public-releases/com/liferay/com.liferay.portal.upgrade/}{\texttt{com.liferay.portal.upgrade}
module}.

In a \texttt{build.gradle} file, the dependency would look like this:

\begin{verbatim}
compile group: "com.liferay", name: "com.liferay.portal.upgrade.api", version: "2.0.3"
\end{verbatim}

If there are other modules your upgrade process requires, specify them
as dependencies.

You've configured your module project for the upgrade. It's time to
create upgrade steps to update the database from the current schema
version to the new one.

\subsection{Writing Upgrade Steps}\label{writing-upgrade-steps}

An upgrade step is a class that adapts module data to the module's
target database schema. It can execute SQL commands and DDL files to
upgrade the data. The upgrade framework lets you encapsulate upgrade
logic in multiple upgrade step classes per schema version.

The upgrade class extends the
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/upgrade/UpgradeProcess.html}{\texttt{UpgradeProcess}
base class}, which implements the
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/upgrade/UpgradeStep.html}{\texttt{UpgradeStep}
interface}. Each upgrade step must override the \texttt{UpgradeProcess}
class's method \texttt{doUpgrade} with instructions for modifying the
database.

Since \texttt{UpgradeProcess} extends the
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/dao/db/BaseDBProcess.html}{\texttt{BaseDBProcess}
class}, you can use its \texttt{runSQL} and \texttt{runSQLTemplate*}
methods to execute your SQL commands and SQL DDL, respectively.

If you want to create, modify, or drop tables or indexes by executing
DDL sentences from an SQL file, make sure to use ANSI SQL only. Doing
this assures the commands work on different databases.

If you need to use non-ANSI SQL, it's best to write it in the
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/upgrade/UpgradeProcess.html}{\texttt{UpgradeProcess}
class's} \texttt{runSQL} or \texttt{alter} methods, along with tokens
that allow porting the sentences to different databases.

For example, consider the journal-service module's
\href{https://github.com/liferay/liferay-portal/blob/master/modules/apps/journal/journal-service/src/main/java/com/liferay/journal/internal/upgrade/v0_0_4/UpgradeSchema.java}{\texttt{UpgradeSchema}
upgrade step class}:

\begin{verbatim}
package com.liferay.journal.internal.upgrade.v0_0_4;

import com.liferay.journal.internal.upgrade.v0_0_4.util.JournalArticleTable;
import com.liferay.journal.internal.upgrade.v0_0_4.util.JournalFeedTable;
import com.liferay.portal.kernel.upgrade.UpgradeMVCCVersion;
import com.liferay.portal.kernel.upgrade.UpgradeProcess;
import com.liferay.portal.kernel.util.StringUtil;

/**
 * @author Eduardo Garcia
 */
public class UpgradeSchema extends UpgradeProcess {

    @Override
    protected void doUpgrade() throws Exception {
        String template = StringUtil.read(
            UpgradeSchema.class.getResourceAsStream("dependencies/update.sql"));

        runSQLTemplateString(template, false, false);

        upgrade(UpgradeMVCCVersion.class);

        alter(
            JournalArticleTable.class,
            new AlterColumnName(
                "structureId", "DDMStructureKey VARCHAR(75) null"),
            new AlterColumnName(
                "templateId", "DDMTemplateKey VARCHAR(75) null"),
            new AlterColumnType("description", "TEXT null"));

        alter(
            JournalFeedTable.class,
            new AlterColumnName("structureId", "DDMStructureKey TEXT null"),
            new AlterColumnName("templateId", "DDMTemplateKey TEXT null"),
            new AlterColumnName(
                "rendererTemplateId", "DDMRendererTemplateKey TEXT null"),
            new AlterColumnType("targetPortletId", "VARCHAR(200) null"));
    }

}
\end{verbatim}

The above example class \texttt{UpgradeSchema} uses the
\texttt{runSQLTemplateString} method to execute ANSI SQL DDL from an SQL
file. To modify column names and column types, it uses the
\texttt{alter} method and
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/upgrade/UpgradeProcess.html}{\texttt{UpgradeProcess}'s}
\texttt{UpgradeProcess.AlterColumnName} and
\texttt{UpgradeProcess.AlterColumnType} inner classes as token classes.

Here's a simpler example upgrade step from the
\texttt{com.liferay.calendar.service} module. It uses the \texttt{alter}
method to modify a column type in the calendar booking table:

\begin{verbatim}
public class UpgradeCalendarBooking extends UpgradeProcess {

        @Override
        protected void doUpgrade() throws Exception {
                alter(
                        CalendarBookingTable.class,
                        new AlterColumnType("description", "TEXT null"));
        }

}
\end{verbatim}

You can implement upgrade steps just like these for your module schemas.

How you name and organize upgrade steps is up to you. Liferay's upgrade
classes are organized using a package structure similar to this one:

\begin{itemize}
\tightlist
\item
  \emph{some.package.structure}

  \begin{itemize}
  \tightlist
  \item
    \texttt{upgrade}

    \begin{itemize}
    \tightlist
    \item
      \texttt{v1\_1\_0}

      \begin{itemize}
      \tightlist
      \item
        \texttt{UpgradeFoo.java} ← Upgrade Step
      \end{itemize}
    \item
      \texttt{v2\_0\_0}

      \begin{itemize}
      \tightlist
      \item
        \texttt{UpgradeFoo.java} ← Upgrade Step
      \item
        \texttt{UpgradeBar.java} ← Upgrade Step
      \end{itemize}
    \item
      \texttt{MyCustomModuleUpgrade.java} ← Registrator
    \end{itemize}
  \end{itemize}
\end{itemize}

The example upgrade structure shown above is for a module that has two
database schema versions: \texttt{1.1.0} and \texttt{2.0.0}. They're
represented by packages \texttt{v1\_1\_0} and \texttt{v2\_0\_0}. Each
version package contains upgrade step classes that update the database.
The example upgrade steps focus on fictitious data elements \texttt{Foo}
and \texttt{Bar}. The registrator class (\texttt{MyCustomModuleUpgrade},
in this example) is responsible for registering the applicable upgrade
steps for each schema version.

Here are some organizational tips:

\begin{itemize}
\item
  Put all upgrade classes in a sub-package called \texttt{upgrade}.
\item
  Group together similar database updates (ones that operate on a data
  element or related data elements) in the same upgrade step class.
\item
  Create upgrade steps in sub-packages named after each data schema
  version.
\end{itemize}

Before continuing with upgrade step registrators, if your application
was modularized from a former traditional Liferay plugin application
(application WAR) and it uses Service Builder, it requires a Bundle
Activator to register itself in Liferay DXP's \texttt{Release\_} table.
If this is the case for your application,
\href{/docs/7-1/tutorials/-/knowledge_base/t/upgrade-processes-for-former-service-builder-plugins}{create
and register a Bundle Activator} and then return here to write your
upgrade step registrator.

\subsection{Writing the Upgrade Step
Registrator}\label{writing-the-upgrade-step-registrator}

A module's upgrade step registrator notifies Liferay's upgrade framework
of all the upgrade steps to update the module data for each schema
version. It specifies the module's entire upgrade process. The upgrade
framework executes the upgrade steps to update the current module data
to the latest schema.

For example, the upgrade step registrator class
\texttt{MyCustomModuleUpgrade} (below) registers upgrade steps
incrementally for each schema version (past and present):

\begin{verbatim}
package com.liferay.mycustommodule.upgrade;

import com.liferay.portal.upgrade.registry.UpgradeStepRegistrator;

import org.osgi.service.component.annotations.Component;

@Component(immediate = true, service = UpgradeStepRegistrator.class)
public class MyCustomModuleUpgrade implements UpgradeStepRegistrator {

    @Override
    public void register(Registry registry) {
        registry.register(
            "com.liferay.mycustommodule", "0.0.0", "2.0.0",
            new DummyUpgradeStep());

        registry.register(
            "com.liferay.mycustommodule", "1.0.0", "1.1.0",
            new com.liferay.mycustommodule.upgrade.v1_1_0.UpgradeFoo());

        registry.register(
            "com.liferay.mycustommodule", "1.1.0", "2.0.0",
            new com.liferay.mycustommodule.upgrade.v2_0_0.UpgradeFoo(),
            new com.liferay.mycustommodule.upgrade.v2_0_0.UpgradeBar());
    }

}
\end{verbatim}

The registrator's \texttt{register} method informs the upgrade framework
about each new schema and associated upgrade steps to adapt data to it.
Each schema upgrade is represented by a registration. A registration is
an abstraction for all the changes you need to apply to the database
from one schema version to the next one.

The following diagram illustrates the relationship between the
registrator and the upgrade steps.

\begin{figure}
\centering
\includegraphics{./images/data-upgrade-module-upgrade-architecture.png}
\caption{In a registrator class, the developer specifies a registration
for each schema version upgrade. The upgrade steps handle the database
updates.}
\end{figure}

The previous example \texttt{MyCustomModuleUpgrade} registrator class
listing shows how this works.

The registrator class declares itself to be an OSGi Component of service
type \texttt{UpgradeStepRegistrator.class}. The \texttt{@Component}
annotation registers the class to the OSGi framework as the module's
upgrade step registrator. The attribute \texttt{immediate\ =\ true}
tells the OSGi framework to activate this module immediately after it's
installed.

The registrator implements the
\href{https://docs.liferay.com/dxp/apps/foundation/latest/javadocs/com/liferay/portal/upgrade/registry/UpgradeStepRegistrator.html}{\texttt{UpgradeStepRegistrator}
interface}, which is in the \texttt{com.liferay.portal.upgrade} module.
The interface declares a
\href{https://docs.liferay.com/dxp/apps/foundation/latest/javadocs/com/liferay/portal/upgrade/registry/UpgradeStepRegistrator.html\#register-com.liferay.portal.upgrade.registry.UpgradeStepRegistrator.Registry-}{\texttt{register}
method} that the registrator must override. In that method, the
registrator implements all the module's upgrade registrations.

Upgrade registrations are defined by the following values:

\begin{itemize}
\tightlist
\item
  \textbf{Module's bundle symbolic name}
\item
  \textbf{Schema version to upgrade from} (as a \texttt{String})
\item
  \textbf{Schema version to upgrade to} (as a \texttt{String})
\item
  \textbf{List of upgrade steps}
\end{itemize}

The example registrator \texttt{MyCustomModuleUpgrade} registers three
upgrades:

\begin{itemize}
\tightlist
\item
  \texttt{0.0.0} to \texttt{2.0.0}
\item
  \texttt{1.0.0} to \texttt{1.1.0}
\item
  \texttt{1.1.0} to \texttt{2.0.0}
\end{itemize}

The \texttt{MyCustomModuleUpgrade} registrator's first registration is
applied by the upgrade framework if the module has not been installed
previously. Its list of upgrade steps contains only one:
\texttt{new\ DummyUpgradeStep()}.

\begin{verbatim}
registry.register(
    "com.liferay.document.library.web", "0.0.0", "2.0.0",
    new DummyUpgradeStep());
\end{verbatim}

The
\href{https://github.com/liferay/liferay-portal/blob/7.1.0-ga1/portal-kernel/src/com/liferay/portal/kernel/upgrade/DummyUpgradeStep.java}{\texttt{DummyUpgradeStep}
class} provides an empty upgrade step. The
\texttt{MyCustomModuleUpgrade} registrator defines this registration so
that the upgrade framework records the module's latest schema version
(i.e., \texttt{2.0.0}) in Liferay DXP's \texttt{Release\_} table.

\textbf{Important}: Modules that use Service Builder \emph{should not}
define a registration for their initial database schema version, as
Service Builder already records their schema versions to Liferay DXP's
\texttt{Release\_} table. Modules that don't use Service Builder,
however, \emph{should} define a registration for their initial schema.

The \texttt{MyCustomUpgrade} registrator's next registration (from
schema version \texttt{1.0.0} to \texttt{1.1.0}) includes one upgrade
step.

\begin{verbatim}
registry.register(
    "com.liferay.mycustommodule", "1.0.0", "1.1.0",
          new com.liferay.mycustommodule.upgrade.v1_1_0.UpgradeFoo());
\end{verbatim}

The upgrade step's fully qualified class name is required because
classes named \texttt{UpgradeFoo} are in package
\texttt{com.liferay.mycustommodule.upgrade.v1\_1\_0}and
\texttt{com.liferay.mycustommodule.upgrade.v2\_0\_0}.

The registrator's final registration (from schema version \texttt{1.1.0}
to \texttt{2.0.0}) contains two upgrade steps.

\begin{verbatim}
registry.register(
    "com.liferay.mycustommodule", "1.1.0", "2.0.0",
    new com.liferay.mycustommodule.upgrade.v2_0_0.UpgradeFoo(),
    new UpgradeBar());
\end{verbatim}

Both upgrade steps, \texttt{UpgradeFoo} and \texttt{UpgradeBar}, reside
in the module's \texttt{com.liferay.mycustommodule.upgrade.v2\_0\_0}
package. The fully qualified class name
\texttt{com.liferay.mycustommodule.upgrade.v2\_0\_0.UpgradeFoo} is used
for the \texttt{UpgradeFoo} class, while the simple class name
\texttt{UpgradeBar} is fine for the second upgrade step.

A registration's upgrade step list can consist of as many upgrade steps
as needed.

\textbf{Important}: If your upgrade step uses an OSGi service, your
upgrade must wait for that service's availability. To specify that your
upgrade is to be executed only after that service is available, add an
OSGi reference to that service.

For example, the
\href{https://github.com/liferay/liferay-portal/blob/7.1.0-ga1/modules/apps/wiki/wiki-service/src/main/java/com/liferay/wiki/upgrade/WikiServiceUpgrade.java}{\texttt{WikiServiceUpgrade}
registrator class} references the \texttt{SettingsFactory} class. The
upgrade step class
\href{https://github.com/liferay/liferay-portal/blob/7.1.0-ga1/modules/apps/wiki/wiki-service/src/main/java/com/liferay/wiki/upgrade/v1_0_0/UpgradePortletSettings.java}{\texttt{UpgradePortletSettings}
upgrade step} uses it. Here's the \texttt{WikiServiceUpgrade} class:

\begin{verbatim}
@Component(immediate = true, service = UpgradeStepRegistrator.class)
public class WikiServiceUpgrade implements UpgradeStepRegistrator {

    @Override
    public void register(Registry registry) {
        registry.register(
            "com.liferay.wiki.service", "0.0.1", "0.0.2", new UpgradeSchema());

        registry.register(
            "com.liferay.wiki.service", "0.0.2", "0.0.3",
            new UpgradeKernelPackage(), new UpgradePortletId());

        registry.register(
            "com.liferay.wiki.service", "0.0.3", "1.0.0",
            new UpgradeCompanyId(), new UpgradeLastPublishDate(),
            new UpgradePortletPreferences(),
            new UpgradePortletSettings(_settingsFactory),
            new UpgradeWikiPageResource());
    }

    @Reference(unbind = "-")
    protected void setSettingsFactory(SettingsFactory settingsFactory) {
        _settingsFactory = settingsFactory;
    }

    private SettingsFactory _settingsFactory;

}
\end{verbatim}

In the third registration in the listing above, the
\texttt{UpgradePortletSettings} upgrade step uses the
\texttt{SettingsFactory} service. The \texttt{setSettingsFactory}
method's \texttt{@Reference} annotation declares that the registrator
class depends on and must wait for the \texttt{SettingsFactory} service
to be available in the run time environment. The annotation's attribute
setting \texttt{unbind\ =\ "-"} indicates that the registrator class has
no method for unbinding the service.

Next, you must make sure the module's upgrade is executed before making
its services available.

\subsection{Waiting for Upgrade
Completion}\label{waiting-for-upgrade-completion}

Before module services that access the database are used, the database
should be upgraded to the latest database schema.

As a convenience, configuring the Bnd header
\texttt{Liferay-Require-SchemaVersion} to the latest schema version is
all that's required to assure the database is upgraded for
\href{/docs/7-1/tutorials/-/knowledge_base/t/what-is-service-builder}{Service
Builder} services.

For all other services, the developer can assure database upgrade by
specifying an \texttt{@Reference} annotation that targets the containing
module and its latest schema version.

Here are the target's required attributes:

\begin{itemize}
\tightlist
\item
  \texttt{release.bundle.symbolic.name}: module's bundle symbolic name
\item
  \texttt{release.schema.version}: module's current schema version
\end{itemize}

For example, the \texttt{com.liferay.comment.page.comments.web} module's
\href{https://github.com/liferay/liferay-portal/blob/7.1.0-ga1/modules/apps/comment/comment-page-comments-web/src/main/java/com/liferay/comment/page/comments/web/internal/portlet/PageCommentsPortlet.java}{\texttt{PageCommentsPortlet}
class} assures upgrading to schema version \texttt{1.0.0} by defining
the following reference:

\begin{verbatim}
@Reference(
    target = "(&(release.bundle.symbolic.name=com.liferay.comment.page.comments.web)(release.schema.version=1.0.0))",
    unbind = "-"
)
protected void setRelease(Release release) {
}
\end{verbatim}

Dependencies between OSGi services can reduce the number of service
classes in which upgrade reference annotations are needed. For example,
there's no need to add an upgrade reference in a dependent service, if
the dependency already refers to the upgrade.

\noindent\hrulefill

\textbf{Note}: Data verifications using the class \texttt{VerifyProcess}
are deprecated. Verifications should be tied schema versions. Upgrade
processes are associated with schema versions but \texttt{VerifyProcess}
instances are not.

\noindent\hrulefill

Now you know how to create data upgrades for all your modules. You
specify the new data schema version in the \texttt{bnd.bnd} file, add a
reference to your module and to the schema version to assure upgrade
execution if the module doesn't use Service Builder, and add a
dependency on the \texttt{com.liferay.portal.upgrade} module. For the
second part of the process, you create upgrade step classes to update
the database schema and register the upgrade steps in a registrator
class. That's all there is to it!

\subsection{Related Topics}\label{related-topics-357}

\href{/docs/7-1/tutorials/-/knowledge_base/t/upgrade-processes-for-former-service-builder-plugins}{Upgrade
Processes for Former Service Builder Plugins}

\href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-plugins-to-liferay-7}{Upgrading
Plugins to Liferay 7}

\href{/docs/7-1/tutorials/-/knowledge_base/t/configurable-applications}{Configurable
Applications}

\href{/docs/7-1/tutorials/-/knowledge_base/t/optimizing-app-upgrade-processes}{Migrating
Data Upgrade Processes to the New Framework for Modules}

\section{Upgrade Processes for Former Service Builder
Plugins}\label{upgrade-processes-for-former-service-builder-plugins}

If you modularized a traditional Liferay plugin application that
implements Service Builder services, your new modular application must
register itself in the Liferay DXP's \texttt{Release\_} table. This is
required regardless of whether release records already exist for
previous versions of the app. A Bundle Activator is the recommended way
to add a release record for the first modular version of your converted
application. Here you'll see an example Bundle Activator and learn how
to create and activate a Bundle Activator for your application.

\textbf{Important}: This tutorial only applies to modular applications
that use Service Builder and were modularized from traditional Liferay
plugin applications. It does not apply to you if your application does
not use Service Builder or has never been a traditional Liferay plugin
application (a WAR application).

Bundle Activator class code is dense but straightforward. Referring to
an example Bundle Activator can be helpful. Here's the Liferay Knowledge
Base application's Bundle Activator:

\begin{verbatim}
public class KnowledgeBaseServiceBundleActivator implements BundleActivator {

    @Override
    public void start(BundleContext bundleContext) throws Exception {
        Filter filter = bundleContext.createFilter(
            StringBundler.concat(
                "(&(objectClass=", ModuleServiceLifecycle.class.getName(), ")",
                ModuleServiceLifecycle.DATABASE_INITIALIZED, ")"));

        _serviceTracker = new ServiceTracker<Object, Object>(
            bundleContext, filter, null) {

            @Override
            public Object addingService(
                ServiceReference<Object> serviceReference) {

                try {
                    BaseUpgradeServiceModuleRelease
                        upgradeServiceModuleRelease =
                            new BaseUpgradeServiceModuleRelease() {

                                @Override
                                protected String getNamespace() {
                                    return "KB";
                                }

                                @Override
                                protected String getNewBundleSymbolicName() {
                                    return "com.liferay.knowledge.base.service";
                                }

                                @Override
                                protected String getOldBundleSymbolicName() {
                                    return "knowledge-base-portlet";
                                }

                            };

                    upgradeServiceModuleRelease.upgrade();

                    return null;
                }
                catch (UpgradeException ue) {
                    throw new RuntimeException(ue);
                }
            }

        };

        _serviceTracker.open();
    }

    @Override
    public void stop(BundleContext bundleContext) throws Exception {
        _serviceTracker.close();
    }

    private ServiceTracker<Object, Object> _serviceTracker;

}
\end{verbatim}

The following steps explain how to create a Bundle Activator, like the
example above.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a class that implements the interface
  \texttt{org.osgi.framework.BundleActivator}.
\item
  Add a service tracker field:

  \texttt{private\ ServiceTracker\textless{}Object,\ Object\textgreater{}\ \_serviceTracker;}
\item
  Override BundleActivator's \texttt{stop} method to close the service
  tracker:

\begin{verbatim}
@Override
public void stop(BundleContext bundleContext) throws Exception {
    _serviceTracker.close();
}
\end{verbatim}
\item
  Override BundleActivator's \texttt{start} method to instantiate a
  service tracker that creates a filter to listens for the app's
  database initialization event and initializes the service tracker to
  use that filter. You'll add the service tracker initialization code in
  the next steps. At the end of the \texttt{start} method, open the
  service tracker.

\begin{verbatim}
@Override
public void start(BundleContext bundleContext) throws Exception {
    Filter filter = bundleContext.createFilter(
        StringBundler.concat(
            "(&(objectClass=", ModuleServiceLifecycle.class.getName(), ")",
            ModuleServiceLifecycle.DATABASE_INITIALIZED, ")"));

    _serviceTracker = new ServiceTracker<Object, Object>(
        bundleContext, filter, null) {
        // See the next step for this code ...
    };

    _serviceTracker.open();
}
\end{verbatim}
\item
  In the service tracker initialization block
  \texttt{\{\ //\ See\ the\ next\ step\ for\ this\ \ \ \ \ code\ ...\ \}}
  from the previous step, add an \texttt{addingService} method that
  instantiates a \texttt{BaseUpgradeServiceModuleRelease} for describing
  your app. The example \texttt{BaseUpgradeServiceModuleRelease}
  instance below describes Liferay's Knowledge Base app:

\begin{verbatim}
@Override
public Object addingService(
    ServiceReference<Object> serviceReference) {

    try {
        BaseUpgradeServiceModuleRelease
                upgradeServiceModuleRelease =
            new BaseUpgradeServiceModuleRelease() {

                @Override
                protected String getNamespace() {
                    return "KB";
                }

                @Override
                protected String getNewBundleSymbolicName() {
                    return "com.liferay.knowledge.base.service";
                }

                @Override
                protected String getOldBundleSymbolicName() {
                    return "knowledge-base-portlet";
                }

            };

        upgradeServiceModuleRelease.upgrade();

        return null;
    }
    catch (UpgradeException ue) {
        throw new RuntimeException(ue);
    }
}
\end{verbatim}

  The \texttt{BaseUpgradeServiceModuleRelease} implements the following
  methods:

  \begin{itemize}
  \tightlist
  \item
    \texttt{getNamespace}: Returns the namespace value as specified in
    the former plugin's \texttt{service.xml} file. This value is also in
    the \texttt{buildNamespace} field in the plugin's
    \texttt{ServiceComponent} table record.
  \item
    \texttt{getOldBundleSymbolicName}: Returns the former plugin's name.
  \item
    \texttt{getNewBundleSymbolicName}: Returns the module's symbolic
    name. In the module's \texttt{bnd.bnd} file, it's the
    \texttt{Bundle-SymbolicName} value.
  \item
    \texttt{upgrade}: Invokes the app's upgrade processes.
  \end{itemize}
\item
  In the module's \texttt{bnd.bnd} file, reference the Bundle Activator
  class you created. Here's the example's Bundle Activator reference:

  \texttt{Bundle-Activator:\ com.liferay.knowledge.base.internal.activator.KnowledgeBaseServiceBundleActivator}
\end{enumerate}

The Bundle Activator uses one of the following values to initialize the
\texttt{schemaVersion} field in the application's \texttt{Release\_}
table record:

\begin{itemize}
\tightlist
\item
  Current \texttt{buildNumber}: if there is an existing
  \texttt{Release\_} table record for the previous plugin.
\item
  \texttt{0.0.1}: if there is no existing \texttt{Release\_} table
  record.
\end{itemize}

You've set your service module's data upgrade process.

\subsection{Related Topics}\label{related-topics-358}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-an-upgrade-process-for-your-app}{Creating
Data Upgrade Processes for Modules}

\href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-plugins-to-liferay-7}{Upgrading
Plugins to Liferay 7}

\section{Meaningful Schema
Versioning}\label{meaningful-schema-versioning}

Data schema versions can be as arbitrary as you like; but they are most
helpful when they provide meaning. Liferay's data schema version
convention communicates a schema's compatibility with older versions of
the software. It tells you whether a schema's changes maintain or break
compatibility with existing software. For example, if a new data schema
removes a field your software expects, the schema breaks compatibility.
But if a new schema's changes are non-breaking (e.g., adds a new field),
the schema is compatible and can be used with existing software. Since
Liferay DXP 7.1, Liferay uses a meaningful schema version convention
(similar to \href{http://semver.org}{Semantic Versioning}) to define new
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-an-upgrade-process-for-your-app}{upgrade
steps} and support rollback of schema micro versions. The convention is
optional but tracks data schema backwards compatibility.

Here's Liferay's schema version convention:

\textbf{MAJOR.MINOR.MICRO}

Each part means something:

\textbf{MAJOR:} Contains breaking schema/data changes that are
incompatible with the latest version of existing code.

\textbf{MINOR:} Contains schema/data changes compatible with the latest
version of existing code. The changes typically involve supporting new
functionality.

\textbf{MICRO:} Contains schema/data changes that are compatible with
the latest version of existing code.

Next are some concrete examples of micro, minor, and major changes.

\subsection{Micro change examples}\label{micro-change-examples}

Here are common micro changes:

\begin{itemize}
\tightlist
\item
  Increasing \texttt{VARCHAR} field sizes.
\item
  Modifying DB indexes.
\item
  Modifying data values to adapt to current logic. These include
  backwards compatible data changes only. These changes commonly occur
  when data updates are missed for new functionalities.
\item
  Converting a field from a String to a CLOB, as long as the field has
  few records and isn't used in \texttt{DISTINCT} or \texttt{GROUP\ BY}
  SQL clauses.
\end{itemize}

\subsection{Minor change examples}\label{minor-change-examples}

Here are common minor changes:

\begin{itemize}
\tightlist
\item
  Adding a new DB field.
\item
  Creating a new DB table.
\end{itemize}

\subsection{Major change examples}\label{major-change-examples}

Here are common major changes:

\begin{itemize}
\tightlist
\item
  Removing a DB field
\item
  Removing a DB table.
\item
  Altering a column name.
\item
  Decreasing the size of a \texttt{VARCHAR} field.
\item
  Converting a field from a String to a CLOB, where the field is has
  many records or is used in \texttt{DISTINCT} or \texttt{GROUP\ BY} SQL
  clauses.
\end{itemize}

Now you can ascribe meaningful versions to your module's data schemas.

\section{Upgrading Data Schemas in
Development}\label{upgrading-data-schemas-in-development}

As you develop modules, you might need to iterate through several
database schema changes. Before you release new module versions with
your finalized schema changes, you must create a formal
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-an-upgrade-process-for-your-app}{data
upgrade process}. Until then, you can use the Build Auto Upgrade feature
to test schema changes on the fly.

\noindent\hrulefill

\textbf{Note}: In Liferay Portal 6.x Service Builder portlets, the
\texttt{build.auto.upgrade} property in \texttt{service.properties}
applies Liferay Service schema changes upon rebuilding services and
redeploying the portlets. As of 7.0, this property is deprecated.

The Build Auto Upgrade feature is now in a global property
\texttt{schema.module.build.auto.upgrade} in the file
\texttt{{[}Liferay\_Home{]}/portal-developer.properties}.

\noindent\hrulefill

Setting the global property \texttt{schema.module.build.auto.upgrade} to
\texttt{true} applies module schema changes for redeployed modules whose
service build numbers have incremented. The \texttt{build.number}
property in the module's \texttt{service.properties} file indicates the
service build number. Build Auto Upgrade executes schema changes without
massaging existing data. It leaves data empty for created columns, drops
data from deleted and renamed columns, and orphans data from deleted and
renamed tables.

Although Build Auto Upgrade updates databases quickly and automatically,
it doesn't guarantee a proper data upgrade--you implement that via
\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-an-upgrade-process-for-your-app}{data
upgrade processes}. Build Auto Upgrade is for development purposes only.

\noindent\hrulefill

\textbf{WARNING}: DO NOT USE the Build Auto Upgrade feature in
production. Liferay DXP DOES NOT support Build Auto Upgrade in
production. Build Auto Upgrade is for development purposes only.
Enabling it in production can result in data loss and improper data
upgrade. In production environments, leave the property
\texttt{schema.module.build.auto.upgrade} in
\texttt{portal-developer.properties} set to \texttt{false}.

\noindent\hrulefill

By default, \texttt{schema.module.build.auto.upgrade} is set to
\texttt{false}. On any module's first deployment, the module's tables
are generated regardless of the
\texttt{schema.module.build.auto.upgrade} value.

The following table summarizes Build Auto Upgrade's handling of schema
changes:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.5200}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.4800}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Schema Change
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Result
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Add column & Create a new empty column. \\
Rename column & Drop the existing column and delete all its data. Create
a new empty column. \\
Delete column & Drop the existing column and delete all its data. \\
Create or rename a table in Liferay DXP's built-in data source. & Orphan
the existing table and all its data. Create the new table. \\
\end{longtable}

Great! Now you know how to use the Build Auto Upgrade developer feature.

\subsection{Related Topics}\label{related-topics-359}

\href{/docs/7-1/tutorials/-/knowledge_base/t/creating-an-upgrade-process-for-your-app}{Creating
Data Upgrade Process for Modules}

\chapter{Back-end Frameworks}\label{back-end-frameworks}

Back-end frameworks are analogous to supporting actors and actresses in
show business. They fill out the stories in films we know and love. As
actors bring richness and life to their films, Liferay's powerful
back-end frameworks bring essential services and deliver terrific
performances of their own. Here are some of the frameworks:

\begin{itemize}
\tightlist
\item
  Device Recognition
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/portlet-providers}{Portlet
  Providers}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/data-scopes}{Data Scopes}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/message-bus}{Message Bus}
\end{itemize}

These frameworks and more deliver smashing performances and are stars in
their own right.

\chapter{Portlet Providers}\label{portlet-providers}

Some apps perform the same operations on different entity types. For
example, the Asset Publisher lets users browse, add, preview, and view
various entities as assets including documents, web content, blogs, and
more. The entities vary, while the operations and surrounding business
logic stay the same. Apps such as the Asset Publisher rely on the
Portlet Providers framework to fetch portlets to operate on the
entities. In this way, the framework lets you focus on entity operations
and frees you from concern about portlets that carry out those
operations. This tutorial shows you how to

\begin{itemize}
\item
  \hyperref[creating-portletproviders]{Create and register Portlet
  Providers}
\item
  \hyperref[retrieving-portlets-for-desired-behaviors]{Retrieve portlets
  from the Portlet Providers}
\end{itemize}

\section{Creating PortletProviders}\label{creating-portletproviders}

\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/PortletProvider.html}{\texttt{PortletProvider}s}
are Component classes associated with an entity type. They have methods
that return portlet IDs and portlet URLs. Once you've registered a
\texttt{PortletProvider}, you can invoke the
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/PortletProviderUtil.html}{\texttt{PortletProviderUtil}}
class to retrieve the portlet ID or portlet URL from the corresponding
\texttt{PortletProvider}.

Examine the
\href{https://docs.liferay.com/dxp/portal/7.1.0-ga1/modules/apps/wiki/wiki-web/src/main/java/com/liferay/wiki/web/internal/portlet/WikiPortletProvider.java\#L27-L44}{\texttt{WikiPortletProvider}}
class:

\begin{verbatim}
@Component(
    immediate = true,
    property = {
        "model.class.name=com.liferay.wiki.model.WikiPage",
        "service.ranking:Integer=100"
    },
    service = {EditPortletProvider.class, ViewPortletProvider.class}
)
public class WikiPortletProvider
    extends BasePortletProvider
    implements EditPortletProvider, ViewPortletProvider {

    @Override
    public String getPortletName() {
        return WikiPortletKeys.WIKI;
    }

}
\end{verbatim}

\texttt{WikiPortletProvider} extends \texttt{BasePortletProvider},
inheriting its \texttt{getPortletURL} methods. It must, however,
implement \texttt{PortletProvider}'s \texttt{getPortletName} method,
which returns the portlet's name \texttt{WikiPortletKeys.WIKI}.

\noindent\hrulefill

\textbf{Note:} If you're creating a \texttt{PortletProvider} for one of
Liferay's portlets, make your \texttt{getPortletName} method returns the
portlet name from that portlet's \texttt{*PortletKeys} class if it has
such a class.

\noindent\hrulefill

\texttt{WikiPortletProvider}'s \texttt{@Component} annotation specifies
these elements and properties:

\begin{itemize}
\tightlist
\item
  \texttt{immediate\ =\ true} activates the component immediately upon
  installation.
\item
  \texttt{"model.class.name=com.liferay.wiki.model.WikiPage"} specifies
  the entity type the portlet operates on.
\item
  \texttt{"service.ranking:Integer=100"} sets the component's rank to
  \texttt{100}, prioritizing it above all \texttt{PortletProvider}s that
  specify the same \texttt{model.class.name} value but have a lower
  rank.
\item
  \texttt{service\ =\ \{EditPortletProvider.class,\ ViewPortletProvider.class\}}
  reflects the subinterface \texttt{PortletProvider} classes this class
  implements.
\end{itemize}

Here's how to create your own \texttt{PortletProvider}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/starting-module-development\#creating-a-module}{Create
  an OSGi module}.
\item
  Create a \texttt{PortletProvider} class in your module. Use the
  recommended class naming convention:

  \texttt{{[}Entity{]}\ +\ {[}Action{]}\ +\ PortletProvider}

  Example:

  \texttt{LanguageEntryViewPortletProvider}
\item
  Extend
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/BasePortletProvider.html}{\texttt{BasePortletProvider}}
  if you want to use its \texttt{getPortletURL} method implementations.
\item
  Implement one or more
  \href{https://docs.liferay.com/ce/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/PortletProvider.html}{\texttt{PortletProvider}}
  subinterfaces that match your action(s):

  \begin{itemize}
  \tightlist
  \item
    \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/BrowsePortletProvider.html}{\texttt{BrowsePortletProvider}}
  \item
    \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/EditPortletProvider.html}{\texttt{EditPortletProvider}}
  \item
    \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/ManagePortletProvider.html}{\texttt{ManagePortletProvider}}
  \item
    \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/PreviewPortletProvider.html}{\texttt{PreviewPortletProvider}}
  \item
    \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/ViewPortletProvider.html}{\texttt{ViewPortletProvider}}
  \end{itemize}
\item
  Make the class an OSGi Component by adding an annotation like this
  one:

\begin{verbatim}
@Component(
    immediate = true,
    property = {"model.class.name=CLASS_NAME"},
    service = {INTERFACE_1.class, ...}
)
\end{verbatim}

  The \texttt{immediate\ =\ true} element specifies that the component
  should be activated immediately upon installation.

  Assign the property \texttt{model.class.name} class name of the entity
  the portlet operates on by replacing \texttt{CLASS\_NAME} with your
  entity's fully qualified class name. Here's an example
  \texttt{model.class.name} property:

\begin{verbatim}
"model.class.name=com.liferay.wiki.model.WikiPage"
\end{verbatim}

  Assign the \texttt{service} element to the \texttt{PortletProvider}
  subinterface(s) you're implementing (e.g.,
  \texttt{ViewPortletProvider.class}, \texttt{BrowsePortletProvider}).
  Replace \texttt{INTERFACE\_1.class,\ ...} with a list of the
  subinterface(s) you're implementing.
\item
  If you're overriding an existing \texttt{PortletProvider}, outrank it
  with your own custom \texttt{PortletProvider} by specifying a
  \texttt{service.ranking:Integer} property with a higher integer
  ranking.

\begin{verbatim}
property= {"service.ranking:Integer=10"}
\end{verbatim}
\item
  Implement the provider methods you want. Make sure you implement
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/PortletProvider.html}{\texttt{PortletProvider}}'s
  \texttt{getPortletName} method. If you didn't extend
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/BasePortletProvider.html}{\texttt{BasePortletProvider}},
  implement \texttt{PortletProvider}'s \texttt{getPortletURL} methods
  too.
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/starting-module-development\#building-and-deploying-a-module}{Deploy
  your module}.
\end{enumerate}

Now your \texttt{PortletProvider} is available to return the ID and URL
of the portlet that provides the desired behaviors. Using
\texttt{PortletProviderUtil} to fetch the portlet IDs and URLs is next.

\section{Retrieving Portlets for Desired
Behaviors}\label{retrieving-portlets-for-desired-behaviors}

The
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/PortletProviderUtil.html}{\texttt{PortletProviderUtil}}
class facilitates fetching portlets to execute actions on entities. You
can request the ID or URL of a portlet that performs the entity action
you want.

The Portlet Provider framework's
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/PortletProvider.Action.html}{\texttt{PortletProvider.Action}}
Enums define these action types:

\begin{itemize}
\tightlist
\item
  \texttt{ADD}
\item
  \texttt{BROWSE}
\item
  \texttt{EDIT}
\item
  \texttt{MANAGE}
\item
  \texttt{PREVIEW}
\item
  \texttt{VIEW}
\end{itemize}

The action type and entity type are key parameters in fetching a
portlet's ID or URL.

\subsection{Fetching a Portlet ID}\label{fetching-a-portlet-id}

The Portlet Provider framework's
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/PortletProviderUtil.html}{\texttt{PortletProviderUtil}}
class facilitates fetching an ID of a portlet for handling an entity
operation. For example, this call gets the ID of a portlet for viewing
Recycle Bin entries:

\begin{verbatim}
String portletId = PortletProviderUtil.getPortletId(
    "com.liferay.portlet.trash.model.TrashEntry", 
    PortletProvider.Action.VIEW);
\end{verbatim}

\texttt{PortletProvider.Action.VIEW} is the operation and
\texttt{com.liferay.portlet.trash.model.TrashEntry} is the entity type.

Another example is how the Asset Publisher uses the Portlet Provider
framework to add a previewed asset to a page---it adds the asset to a
portlet and adds that portlet to the page. The Asset Publisher uses the
\texttt{liferay-asset:asset\_display} tag library tag whose
\texttt{asset\_display/preview.jsp} shows an \emph{Add} button for
adding the portlet. If the previewed asset is a Blogs entry, for
example, the framework returns a blogs portlet ID or URL for adding the
portlet to the current page. Here's the relevant code from the
\href{https://github.com/liferay/liferay-portal/blob/7.1.0-ga1/modules/apps/asset/asset-taglib/src/main/resources/META-INF/resources/asset_display/preview.jsp\#L75-L91}{\texttt{asset\_display/preview.jsp}}:

\begin{verbatim}
Map<String, Object> data = new HashMap<String, Object>();

<!-- populate the data map -->

String portletId = PortletProviderUtil.getPortletId(assetEntry.getClassName(), PortletProvider.Action.ADD);

data.put("portlet-id", portletId);

<!-- add more to the data map -->
%>

<c:if test="<%= PortletPermissionUtil.contains(permissionChecker, layout, portletId, ActionKeys.ADD_TO_PAGE) %>">
    <aui:button cssClass="add-button-preview" data="<%= data %>" value="add" />
</c:if>
\end{verbatim}

The code above invokes
\texttt{PortletProviderUtil.getPortletId(assetEntry.getClassName(),\ PortletProvider.Action.ADD)}
to get the ID of a portlet that adds and displays the asset of the
underlying entity class.

The JSP puts the portlet ID into the \texttt{data} map.

\begin{verbatim}
data.put("portlet-id", portletId);
\end{verbatim}

Then it passes the \texttt{data} map to a new \emph{Add} button that
adds the portlet to the page.

\begin{verbatim}
<aui:button cssClass="add-button-preview" data="<%= data %>" value="add" />
\end{verbatim}

Fetching a portlet URL is just as easy.

\subsection{Fetching a Portlet URL}\label{fetching-a-portlet-url}

\texttt{PortletProviderUtil}'s
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/PortletProviderUtil.html}{\texttt{getPortletURL}
methods} return a \texttt{javax.portlet.PortletURL} based on an
\texttt{HttpServletRequest} or \texttt{PortletRequest}. They also let
you specify a \texttt{Group}.

For example, when the Asset Publisher is configured in Manual mode, the
user can use an Asset Browser to select asset entries. The
\texttt{asset-publisher-web} module's
\href{https://github.com/liferay/liferay-portal/blob/7.1.0-ga1/modules/apps/asset/asset-publisher-web/src/main/resources/META-INF/resources/configuration/asset_entries.jsp\#L125}{\texttt{configuration/asset\_entries.jsp}}
file uses \texttt{PortletProviderUtil}'s \texttt{getPortletURL} method
(at the end of the code below) to generate a corresponding Asset Browser
URL.

\begin{verbatim}
List<AssetRendererFactory<?>> assetRendererFactories = 
    ListUtil.sort(
        AssetRendererFactoryRegistryUtil.getAssetRendererFactories(
            company.getCompanyId()),
            new AssetRendererFactoryTypeNameComparator(locale));

for (AssetRendererFactory<?> curRendererFactory : assetRendererFactories) {
    long curGroupId = groupId;

    if (!curRendererFactory.isSelectable()) {
        continue;
    }

    PortletURL assetBrowserURL = PortletProviderUtil.getPortletURL(
        request, curRendererFactory.getClassName(),
        PortletProvider.Action.BROWSE);
\end{verbatim}

Now you can unleash an arsenal of \texttt{PortletProvider}s to use in
your apps!

\section{Related Topics}\label{related-topics-360}

\href{/docs/7-1/tutorials/-/knowledge_base/t/portlets}{Portlets}

\href{/docs/7-1/tutorials/-/knowledge_base/t/embedding-portlets-in-themes}{Embedding
Portlets in Themes}

\href{/docs/7-1/tutorials/-/knowledge_base/t/customizing-liferay-services-service-wrappers}{Customizing
Liferay Services}

\chapter{Data Scopes}\label{data-scopes}

Apps can restrict their data to specific scopes. Scopes provide a
context for the application's data.

\emph{Global:} One data set throughout a portal instance.

\emph{Site:} Separate data sets for each Site it's added to.

\emph{Page:} Separate data sets for each page it's added to.

For example, a Site-scoped app can display its data across a single
Site. For a detailed explanation of scopes, see the user guide article
\href{/docs/7-1/user/-/knowledge_base/u/widget-scope}{Widget Scope}. To
give your applications scope, you must manually add support for it. This
tutorial shows you how.

\section{Scoping Your Entities}\label{scoping-your-entities}

In your service layer, your entities must have a \texttt{companyId}
attribute of type \texttt{long} to enable scoping by portal instance and
a \texttt{groupId} attribute of type \texttt{long} to enable scoping by
Site. Using
\href{/docs/7-1/tutorials/-/knowledge_base/t/service-builder}{Service
Builder} is the simplest way to do this. The
\href{/docs/7-1/tutorials/-/knowledge_base/t/service-builder-persistence}{Service
Builder Persistence} and
\href{/docs/7-1/tutorials/-/knowledge_base/t/business-logic-with-service-builder}{Business
Logic with Service Builder} tutorials show you how.

\section{Enabling Scoping}\label{enabling-scoping}

To enable scoping in your app, set the property
\texttt{"com.liferay.portlet.scopeable=true"} in your portlet class's
\texttt{@Component} annotation. For example, the
\href{https://github.com/liferay/liferay-portal/blob/7.1.0-ga1/modules/apps/journal/journal-content-web/src/main/java/com/liferay/journal/content/web/internal/portlet/JournalContentPortlet.java}{Web
Content Display Portlet's portlet class} sets this component property:

\begin{verbatim}
@Component(
    immediate = true,
    property = {
        ...
        "com.liferay.portlet.scopeable=true",
        ...,
    },
    service = Portlet.class
)
public class JournalContentPortlet extends MVCPortlet {...
\end{verbatim}

That's it! Next, you'll access your app's scope in your code.

\section{Accessing Your App's Scope}\label{accessing-your-apps-scope}

Users can typically set an app's scope to a page, a Site, or the entire
portal. To handle your app's data, you must access it in its current
scope. Your app's scope is available in these ways:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Via the \texttt{scopeGroupId} variable that is injected in your JSPs
  that use the
  \texttt{\textless{}liferay-theme:defineObjects\ /\textgreater{}} tag.
  This variable contains your app's current scope. For example, the
  Liferay Bookmarks app's
  \href{https://github.com/liferay/liferay-portal/blob/7.1.0-ga1/modules/apps/bookmarks/bookmarks-web/src/main/resources/META-INF/resources/bookmarks/view.jsp\#L122-L125}{\texttt{view.jsp}}
  uses its \texttt{scopeGroupId} to retrieve the bookmarks and total
  number of bookmarks in the current scope:

\begin{verbatim}
...
total = BookmarksEntryServiceUtil.getGroupEntriesCount(scopeGroupId, groupEntriesUserId);

bookmarksSearchContainer.setTotal(total);
bookmarksSearchContainer.setResults(BookmarksEntryServiceUtil.getGroupEntries(scopeGroupId, groupEntriesUserId, bookmarksSearchContainer.getStart(), bookmarksSearchContainer.getEnd()));
...
\end{verbatim}
\item
  By calling the \texttt{getScopeGroupId()} method on the request's
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/theme/ThemeDisplay.html}{\texttt{ThemeDisplay}
  instance}. This method returns your app's current scope. For example,
  the Liferay Blogs app's
  \href{https://github.com/liferay/liferay-portal/blob/7.1.0-ga1/modules/apps/blogs/blogs-web/src/main/java/com/liferay/blogs/web/internal/portlet/action/EditEntryMVCActionCommand.java\#L371-L383}{\texttt{EditEntryMVCActionCommand}
  class} does this in its \texttt{subscribe} and \texttt{unsubscribe}
  methods:

\begin{verbatim}
protected void subscribe(ActionRequest actionRequest) throws Exception {
    ThemeDisplay themeDisplay = (ThemeDisplay)actionRequest.getAttribute(
        WebKeys.THEME_DISPLAY);

    _blogsEntryService.subscribe(themeDisplay.getScopeGroupId());
}

protected void unsubscribe(ActionRequest actionRequest) throws Exception {
    ThemeDisplay themeDisplay = (ThemeDisplay)actionRequest.getAttribute(
        WebKeys.THEME_DISPLAY);

    _blogsEntryService.unsubscribe(themeDisplay.getScopeGroupId());
}
\end{verbatim}

  If you know your app always needs the portal instance ID, use
  \texttt{themeDisplay.getCompanyId()}.
\item
  By calling the \texttt{getScopeGroupId()} method on a
  \texttt{ServiceContext} object. The tutorial
  \href{/docs/7-1/tutorials/-/knowledge_base/t/understanding-servicecontext}{Understanding
  \texttt{ServiceContext}} provides an example and details. If you know
  your app always needs the portal instance ID, use the
  \texttt{ServiceContext} object's \texttt{getCompanyId()} method.
\end{enumerate}

Awesome! Now you know how to get your app's scope. Next, you'll learn
about a special use case: getting the Site scope for entities that
belong to a different app.

\section{Accessing the Site Scope Across
Apps}\label{accessing-the-site-scope-across-apps}

There may be times when you must access a different app's Site-scoped
data from your app that is scoped to a page or the portal. For example,
web content articles can be created in the page, Site, or portal scope.
\href{/docs/7-1/user/-/knowledge_base/u/designing-uniform-content}{Structures
and Templates} for such articles, however, exist only in the Site scope.
The above techniques return the app's scope, which might not be the Site
scope. What a pickle! Never fear, the \texttt{ThemeDisplay} method
\texttt{getSiteGroupId()} is here! This method always gets the Site
scope, no matter your app's current scope. For example,
\href{https://github.com/liferay/liferay-portal/blob/7.1.0-ga1/modules/apps/journal/journal-web/src/main/resources/META-INF/resources/edit_feed.jsp\#L40}{the
Web Content app's \texttt{edit\_feed.jsp}} uses this method to get the
Site ID needed to retrieve Structures:

\begin{verbatim}
...

ddmStructure = DDMStructureLocalServiceUtil.fetchStructure(themeDisplay.getSiteGroupId(), 
    PortalUtil.getClassNameId(JournalArticle.class), ddmStructureKey, true);

...
\end{verbatim}

Great! Now you know how to scope your apps, access their scope, and even
get the Site scope of entities that belong to other apps.

\section{Related Topics}\label{related-topics-361}

\href{/docs/7-1/user/-/knowledge_base/u/widget-scope}{Widget Scope}

\href{/docs/7-1/tutorials/-/knowledge_base/t/service-builder}{Service
Builder}

\href{/docs/7-1/tutorials/-/knowledge_base/t/service-builder-persistence}{Service
Builder Persistence}

\href{/docs/7-1/tutorials/-/knowledge_base/t/business-logic-with-service-builder}{Business
Logic with Service Builder}

\chapter{Message Bus}\label{message-bus}

If you ever need to do some data processing outside the scope of the
web's request/response, look no further than the Message Bus. It's
conceptually similar to Java Messaging Service (JMS) Topics, but
sacrifices transactional, reliable delivery capabilities, making it much
lighter-weight. Liferay DXP uses Message Bus all over the place:

\begin{itemize}
\tightlist
\item
  Auditing
\item
  Search engine integration
\item
  Email subscriptions
\item
  Monitoring
\item
  Document Library processing
\item
  Background tasks
\item
  Cluster-wide request execution
\item
  Clustered cache replication
\end{itemize}

You can use it too! Here are some of Message Bus's most important
features:

\begin{itemize}
\tightlist
\item
  publish/subscribe messaging
\item
  request queuing and throttling
\item
  flow control
\item
  multi-thread message processing
\end{itemize}

There are also tools, such as the Java SE's JConsole, that can monitor
Message Bus activities.

\begin{figure}
\centering
\includegraphics{./images/message-bus-jconsole.png}
\caption{JConsole shows statistics on Message Bus messages sent,
messages pending, and more.}
\end{figure}

The Message Bus topics are covered in these tutorials:

\begin{itemize}
\tightlist
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/messaging-destinations}{Messaging
  Destinations}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/message-listeners}{Message
  Listeners}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/sending-messages}{Sending
  Messages}
\end{itemize}

Since all messages are sent to and received at destinations, messaging
destinations is worth exploring first.

\section{Messaging Destinations}\label{messaging-destinations}

In Message Bus, you send messages to \emph{destinations}. A destination
is a named logical (not physical) location. Sender classes send messages
to destinations, while listener classes wait to receive messages at the
destinations. In this way, the sender and recipient don't need to know
each other---they're loosely coupled. Here are the messaging destination
topics this tutorial covers:

\begin{itemize}
\tightlist
\item
  \hyperref[destination-configuration]{Destination configuration}
\item
  \hyperref[creating-a-destination]{Creating a destination}
\item
  \hyperref[messaging-event-listeners]{Messaging event listeners}
\end{itemize}

It's time to configure a destination.

\subsection{Destination Configuration}\label{destination-configuration}

Each destination has a name and type and can have several other
attributes. The destination type determines whether there's a message
queue, the kinds of threads involved with a destination, and the message
delivery behavior to expect at the destination.

Here are the primary destination types:

\begin{itemize}
\item
  \textbf{Parallel Destination}

  \begin{itemize}
  \item
    Messages sent here are queued.
  \item
    Multiple worker threads from a thread pool deliver each message to a
    registered message listener. There's one worker thread per message
    per message listener.
  \end{itemize}
\item
  \textbf{Serial Destination}

  \begin{itemize}
  \item
    Messages sent here are queued.
  \item
    Worker threads from a thread pool deliver the messages to each
    registered message listener, one worker thread per message.
  \end{itemize}
\item
  \textbf{Synchronous Destination}

  \begin{itemize}
  \item
    Messages sent here are directly delivered to message listeners.
  \item
    The thread sending the message here delivers the message to all
    message listeners also.
  \end{itemize}
\end{itemize}

Liferay has preconfigured destinations for various purposes. The
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/messaging/DestinationNames.html}{\texttt{DestinationNames}
class} defines \texttt{String} constants for each of them. For example,
\texttt{DestinationNames.HOT\_DEPLOY} (value is
\texttt{"liferay/hot\_deploy"}) is for deployment event messages. Since
destinations are tuned for specific purposes, don't modify them.

Destinations are based on
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/messaging/DestinationConfiguration.html}{\texttt{DestinationConfiguration}
instances}. The configuration specifies the destination type, name, and
these destination- related attributes:

\textbf{Maximum Queue Size}: limits the number of queued messages for
the destination.

\textbf{Rejected Execution Handler}: A
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/concurrent/RejectedExecutionHandler.html}{\texttt{com.liferay.portal.kernel.concurrent.RejectedExecutionHandler}
instance} can take action (e.g., log warnings) regarding rejected
messages when the destination queue is full.

\textbf{Workers Core Size}: initial number of worker threads for
processing messages.

\textbf{Workers Max Size}: limits the number of worker threads for
processing messages.

The \texttt{DestinationConfiguration} class provides these static
methods for creating the various types of configurations.

\begin{itemize}
\item
  \texttt{createParallelDestinationConfiguration(String\ destinationName)}
\item
  \texttt{createSerialDestinationConfiguration(String\ destinationName)}
\item
  \texttt{createSynchronousDestinationConfiguration(String\ destinationName)}
\end{itemize}

You can also use the
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/messaging/DestinationConfiguration.html\#DestinationConfiguration-java.lang.String-java.lang.String-}{\texttt{DestinationConfiguration}
constructor} to create a configuration for any destination type, even
your own.

\subsection{Creating a Destination}\label{creating-a-destination}

Message Bus destinations are based on destination configurations and
registered as OSGi services. Message Bus detects the destination
services and manages their associated destinations.

Here are the general steps for creating a destination. The example
configurator class that follows demonstrates these steps.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a destination configuration using one of
  \texttt{DestinationConfiguration}'s static \texttt{create*} methods or
  its constructor. Set any attributes that apply to the destinations
  you'll create with it.
\item
  Create a destination by invoking the
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/messaging/DestinationFactory.html}{\texttt{DestinationFactory}}
  method \texttt{createDestination(DestinationConfiguration)}, passing
  in the destination configuration you created in the previous step.
\item
  Register the destination as an OSGi service by invoking the
  \href{https://osgi.org/javadoc/r4v43/core/org/osgi/framework/BundleContext.html}{\texttt{BundleContext}
  method \texttt{registerService}}, passing in the following parameters.

  \begin{itemize}
  \tightlist
  \item
    Destination class \texttt{Destination.class}
  \item
    Your \texttt{Destination} object
  \item
    A \texttt{Dictionary} of properties defining the destination,
    including the \texttt{destination.name}
  \end{itemize}
\item
  Manage the destination object and service registration resources using
  a collection, such as a
  \texttt{Map\textless{}String,\ ServiceRegistration\textless{}Destination\textgreater{}\textgreater{}}.
  Keeping references to these resources is helpful for when you're ready
  to unregister and destroy them. The \texttt{deactivate} method in the
  example below demonstrates this.
\end{enumerate}

Here's an example messaging configurator component that creates and
registers a parallel destination and manages its resources:

\begin{verbatim}
@Component (
    immediate = true,
    service = MyMessagingConfigurator .class
)
public class MyMessagingConfigurator {

    @Activate
    protected void activate(BundleContext bundleContext) {

        _bundleContext = bundleContext;

        // Create a DestinationConfiguration for parallel destinations.

        DestinationConfiguration destinationConfiguration =
            new DestinationConfiguration(
                DestinationConfiguration.DESTINATION_TYPE_PARALLEL,
                    "myDestinationName");

        // Set the DestinationConfiguration's max queue size and
        // rejected execution handler.

        destinationConfiguration.setMaximumQueueSize(_MAXIMUM_QUEUE_SIZE);

        RejectedExecutionHandler rejectedExecutionHandler =
            new CallerRunsPolicy() {

                @Override
                public void rejectedExecution(
                    Runnable runnable, ThreadPoolExecutor threadPoolExecutor) {

                    if (_log.isWarnEnabled()) {
                        _log.warn(
                            "The current thread will handle the request " +
                                "because the graph walker's task queue is at " +
                                    "its maximum capacity");
                    }

                    super.rejectedExecution(runnable, threadPoolExecutor);
                }

            };

       destinationConfiguration.setRejectedExecutionHandler(
            rejectedExecutionHandler);

       // Create the destination

       Destination destination = _destinationFactory.createDestination(
            destinationConfiguration);

        // Add the destination to the OSGi service registry

        Dictionary<String, Object> properties = new HashMapDictionary<>();

        properties.put("destination.name", destination.getName());

        ServiceRegistration<Destination> serviceRegistration =
            _bundleContext.registerService(
                Destination.class, destination, properties);

        // Track references to the destination service registrations 

        _serviceRegistrations.put(destination.getName(),    
            serviceRegistration);
    }

    @Deactivate
    protected void deactivate() {

        // Unregister and destroy destinations this component unregistered

        for (ServiceRegistration<Destination> serviceRegistration : 
        _serviceRegistrations.values()) {

            Destination destination = _bundleContext.getService(
                serviceRegistration.getReference());

            serviceRegistration.unregister();

            destination.destroy();

        }

        _serviceRegistrations.clear();

     }

    @Reference
    private DestinationFactory _destinationFactory;

    private final Map<String, ServiceRegistration<Destination>>
        _serviceRegistrations = new HashMap<>();
}
\end{verbatim}

On activation, the example configurator above does these things:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Creates a \texttt{DestinationConfiguration} for parallel destinations.
\item
  Sets the \texttt{DestinationConfiguration}'s max queue size and a
  rejected execution handler.
\item
  Uses the \texttt{DestinationFactory} (the one bound to the
  \texttt{\_destinationFactory} field) to create the destination.
\item
  Adds the destination to the OSGi service registry
\item
  Adds the destination service registration to a map for managing them.
\end{enumerate}

Once the destination is registered, Message Bus detects its service and
manages the destination. On deactivating the example configurator, its
\texttt{deactivate} method unregisters the destination services and
destroys the destinations.

As an added bonus to creating destinations, you can create classes that
listen for new destinations and new message listeners. You might want to
create such listeners to log the deployment of new message bus
endpoints.

\subsection{Messaging Event Listeners}\label{messaging-event-listeners}

There are Message Bus framework interfaces that let you listen for new
destinations and message listeners.

\subsubsection{Listening for new
Destinations}\label{listening-for-new-destinations}

The Message Bus notifies Message Bus Event Listeners when destinations
are added and removed. To register these listeners, publish a
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/messaging/MessageBusEventListener.html}{\texttt{MessageBusEventListener}
instance} to the OSGi service registry (e.g., via an \texttt{@Component}
annotation).

\begin{verbatim}
@Component(
    immediate = true,
    service = MessageBusEventListener.class
)
public class MyMessageBusEventListener implements MessageBusEventListener {

    void destinationAdded(Destination destination) {
        ...
    }

    void destinationDestroyed(Destination destination) {
        ...
    }
}
\end{verbatim}

Listening for new message listeners is easy too.

\subsubsection{Listening for new Message
Listeners}\label{listening-for-new-message-listeners}

The Message Bus notifies
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/messaging/DestinationEventListener.html}{\texttt{DestinationEventListener}
instances} when message listeners are either registered or unregistered
to destinations. To register a listener to a destination, publish a
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/messaging/DestinationEventListener.html}{\texttt{DestinationEventListener}
service} to the OSGi service registry, making sure to specify the
destination's \texttt{destination.name} property.

\begin{verbatim}
@Component(
    immediate = true,
    property = {"destination.name=myCustom/Destination"},
    service = DestinationEventListener.class
)
public class MyDestinationEventListener implements DestinationEventListener {

    void messageListenerRegistered(String destinationName,
                                   MessageListener messageListener) {
        ...
    }

    void messageListenerUnregistered(String destinationName,
                                   MessageListener messageListener) {
        ...
    }
}
\end{verbatim}

And that's how you listen for new destinations and message listeners.

Now you understand the different destination types, how to create and
register destinations, and how to manage destination resources. Once you
deploy your destination, registered message listeners receive messages
sent to it.

\subsection{Related Topics}\label{related-topics-362}

\href{/docs/7-1/tutorials/-/knowledge_base/t/message-listeners}{Message
Listeners}

\href{/docs/7-1/tutorials/-/knowledge_base/t/sending-messages}{Sending
Messages}

\section{Message Listeners}\label{message-listeners}

If you're interested in messages sent to a destination, you need to
``listen'' for them. That is, you must create and register a message
listener for the destination.

To create a message listener, implement the
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/messaging/MessageListener.html}{\texttt{MessageListener}
interface} and override its \texttt{receive(Message)} method to process
messages your way.

\begin{verbatim}
public void receive(Message message) {
    // Process messages your way
}
\end{verbatim}

Here are the ways to register your listener with Message Bus:

\begin{itemize}
\item
  \textbf{Automatic Registration as a Component}: Publish the listener
  to the OSGi registry as a
  \href{/docs/7-1/tutorials/-/knowledge_base/t/osgi-services-and-dependency-injection-with-declarative-services}{Declarative
  Services Component} that specifies a destination. Message Bus
  automatically wires the listener to the destination.
\item
  \textbf{Registering via MessageBus}: Obtain a reference to the Message
  Bus and use it directly to register the listener to a destination.
\item
  \textbf{Registering directly to a Destination}: Obtain a reference to
  a specific destination and use it directly to register the listener
  with that destination.
\end{itemize}

\noindent\hrulefill

\textbf{Note}: The
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/messaging/DestinationNames.html}{\texttt{DestinationNames}
class} defines \texttt{String} constants for Liferay DXP's preconfigured
destinations.

\noindent\hrulefill

The Declarative Services component module provides the easiest way to
register a message listener.

\subsection{Automatic Registration as a
Component}\label{automatic-registration-as-a-component}

You can specify a message listener in the Declarative Services (DS)
\texttt{@Component} annotation:

\begin{verbatim}
@Component (
    immediate = true,
    property = {"destination.name=myCustom/Destination"},
    service = MessageListener.class
)
public class MyMessageListener implements MessageListener {
   ...

   public void receive(Message message) {
       // Handle the message
   }
}
\end{verbatim}

The Message Bus listens for \texttt{MessageListener} service components
like this one to publish themselves to the OSGi service registry. The
attribute \texttt{immediate\ =\ true} tells the OSGi framework to
activate the component as soon as its dependencies resolve. Message Bus
wires each registered listener to the destination its
\texttt{destination.name} property specifies. If the destination is not
yet registered, Message Bus queues the listener until the destination
registers.

Registration as a component is the preferred way to register message
listeners to destinations.

\subsection{Registering via
MessageBus}\label{registering-via-messagebus}

You can use the
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/messaging/MessageBus.html}{\texttt{MessageBus}
instance} directly to register message listeners to destinations. You
might want to do this if, for example, you want to create some special
proxy wrappers. Here's a registrator that demonstrates registering a
listener this way:

\begin{verbatim}
@Component (
    immediate = true,
    service = MyMessageListenerRegistrator.class
)
public class MyMessageListenerRegistrator {
    ...

    @Activate
    protected void activate() {

        _messageListener = new MessageListener() {

            public void receive(Message message) {
                // Handle the message
            }
        };

        _messageBus.registerMessageListener("myDestinationName",  
            _messageListener);
    }

    @Deactivate
    protected void deactivate() {
        _messageBus.unregisterMessageListener("myDestinationName",  
            _messageListener);
    }

    @Reference
    private MessageBus _messageBus;

    private MessageListener _messageListener;
}
\end{verbatim}

The \texttt{\_messageBus} field's \texttt{@Reference} annotation binds
it to the \texttt{MessageBus} instance. The \texttt{activate} method
creates the listener and uses the Message Bus to register the listener
to a destination named \texttt{"myDestination"}. When this registrator
component is destroyed, the \texttt{deactivate} method unregisters the
listener.

\subsection{Registering directly to the
Destination}\label{registering-directly-to-the-destination}

You can use a \texttt{Destination} instance to register a listener to
that destination. You might want to do this if, for example, you want to
create some special proxy wrappers. Here's a registrator that
demonstrates registering a listener this way:

\begin{verbatim}
@Component (
    immediate = true,
    service = MyMessageListenerRegistrator.class
)
public class MyMessageListenerRegistrator {
   ...

    @Activate
    protected void activate() {

        _messageListener = new MessageListener() {

            public void receive(Message message) {
                // Handle the message
            }
        };

        _destination.register(_messageListener);
    }

    @Deactivate
    protected void deactivate() {

        _destination.unregister(_messageListener);
    }

    @Reference(target = "(destination.name=someDestination)")
    private Destination _destination;

    private MessageListener _messageListener;
}
\end{verbatim}

The \texttt{\_destination} field's \texttt{@Reference} annotation binds
it to a destination named \texttt{"someDestination"}. The
\texttt{activate} method creates the listener and registers it to the
destination. When this registrator component is destroyed, the
\texttt{deactivate} method unregisters the listener.

Now you know how to create and register message listeners for receiving
messages sent to the destinations.

\subsection{Related Topics}\label{related-topics-363}

\href{/docs/7-1/tutorials/-/knowledge_base/t/messaging-destinations}{Messaging
Destinations}

\href{/docs/7-1/tutorials/-/knowledge_base/t/sending-messages}{Sending
Messages}

\section{Sending Messages}\label{sending-messages}

Message Bus lets you send messages to destinations that have any number
of listening classes. As a message sender you don't need to know the
message recipients. Instead, you focus on creating message content
(payload) and sending messages to destinations.

You can also send messages in a synchronous or asynchronous manner. The
synchronous option waits for a response that the message was received or
that it timed out. The asynchronous option gives you the ``fire and
forget'' behavior; send the message and continue processing without
waiting for a response.

Here are the message sending topics:

\begin{itemize}
\tightlist
\item
  \hyperref[creating-a-message]{Creating a message}
\item
  \hyperref[sending-a-message]{Sending a message} (the way you want)
\item
  \hyperref[sending-messages-across-the-cluster]{Sending messages across
  a cluster}
\end{itemize}

Start by creating a message.

\subsection{Creating a Message}\label{creating-a-message}

Here's how to create a message:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Call the
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/messaging/Message.html}{\texttt{Message}
  constructor}.

  \texttt{Message\ message\ =\ new\ Message();}
\item
  Populate the message with a \texttt{String} or \texttt{Object} payload

  \begin{itemize}
  \item
    String payload:
    \texttt{message.setPayload("Message\ Bus\ is\ great!")}
  \item
    Object payload: \texttt{message.put("firstName",\ "Joe")}
  \end{itemize}
\item
  To receive responses at a particular location, set both of these
  attributes

  \begin{itemize}
  \item
    Response destination name:
    \texttt{setResponseDestinationName(String)}
  \item
    Response ID: \texttt{setResponseId(String)}
  \end{itemize}
\end{enumerate}

Your new message is ready to send.

\subsection{Sending a Message}\label{sending-a-message}

Here are the ways to send a message:

\begin{itemize}
\tightlist
\item
  \hyperref[directly-using-the-message-bus]{Directly using the
  \texttt{MessageBus}}
\item
  \hyperref[using-singledestinationmessagesender]{Asynchronously using a
  \texttt{SingleDestinationMessageSender}}
\item
  \hyperref[using-a-synchronousmessagesender]{Using a
  \texttt{SynchronousMessageSender}}
\end{itemize}

First, let's consider using Message Bus directly.

\subsubsection{Directly Using the Message
Bus}\label{directly-using-the-message-bus}

This method involves obtaining a
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/messaging/MessageBus.html}{\texttt{MessageBus}
instance} and invoking it to send messages. Here's an example of
directly using Message Bus to send a message.

\begin{verbatim}
@Component(
    immediate = true,
    service = SomeServiceImpl.class
)
public class SomeServiceImpl {
    ...

    public void sendSomeMessage() {

        Message message = new Message();
        message.put("myId", 12345);
        message.put("someAttribute", "abcdef");
        _messageBus.sendMessage("myDestinationName", message);
    }

    @Reference
    private MessageBus _messageBus;
}
\end{verbatim}

To send messages asynchronously, consider using
\texttt{SingleDestinationMessageSender}.

\subsubsection{Using
SingleDestinationMessageSender}\label{using-singledestinationmessagesender}

The
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/messaging/sender/SingleDestinationMessageSender.html}{\texttt{SingleDestinationMessageSender}
class} wraps the Message Bus to send messages asynchronously. This class
demonstrates using a \texttt{SingleDestinationMessageSender}:

\begin{verbatim}
@Component(
    immediate = true,
    service = SomeServiceImpl.class
)
public class SomeServiceImpl {
    ...

    public void sendSomeMessage() {

        Message message = new Message();
        message.put("myId", 12345);
        message.put("someValue", "abcdef");

        SingleDestinationMessageSender messageSender = 
           _messageSenderFactory.createSingleDestinationMessageSender("myDestinationName");

        messageSender.send(message);
    }

    @Reference
    private SingleDestinationMessageSenderFactory _messageSenderFactory;
}
\end{verbatim}

The \texttt{\_messageSenderFactory} field's \texttt{@Reference} wires it
to a \texttt{SingleDestinationMessageSenderFactory} instance. The method
\texttt{sendSomeMessage} creates a message, uses the
\texttt{\_messageSenderFactory} to create a
\texttt{SingleDestinationMessageSender} for the specified destination,
and sends the message through the sender.

\subsubsection{Using a
SynchronousMessageSender}\label{using-a-synchronousmessagesender}

A
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/messaging/sender/SynchronousMessageSender.html}{\texttt{SynchronousMessageSender}
instance} sends a message to the Message Bus and blocks until receiving
a response or the response times out. A
\texttt{SynchronousMessageSender} has these
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/messaging/sender/SynchronousMessageSender.Mode.html}{operating
modes}:

\begin{itemize}
\item
  \texttt{DEFAULT}: Delivers the message in a separate thread and also
  provides timeouts, in case the message is not delivered properly.
\item
  \texttt{DIRECT}: Delivers the message in the same thread of execution
  and blocks until it receives a response.
\end{itemize}

Here's an example of using \texttt{SynchronousMessageSender} in
\texttt{DEFAULT} mode.

\begin{verbatim}
@Component(
    immediate = true,
    service = SomeServiceImpl.class
)
public class SomeServiceImpl {
    ...

    public void sendSomeMessage() {

        Message message = new Message();
        message.put("myId", 12345);
        message.put("someAttribute", "abcdef");

        SingleDestinationSynchronousMessageSender messageSender = 
            _messageSenderFactory.createSingleDestinationSynchronousMessageSender(
                "myDestinationName", SynchronousMessageSender.Mode.DEFAULT);

        messageSender.send(message);

    }

    @Reference
    private SingleDestinationMessageSenderFactory _messageSenderFactory;
}
\end{verbatim}

And those are the ways to send messages. Next, if you're in a cluster
and want messages sent to a destination across all nodes, you must
register a bridge message listener to that destination.

\subsection{Sending Messages Across the
Cluster}\label{sending-messages-across-the-cluster}

To ensure a message sent to a destination is received by all cluster
nodes, you must register a
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/cluster/messaging/ClusterBridgeMessageListener.html}{\texttt{ClusterBridgeMessageListener}}
at that destination. This bridges the local destination to the cluster.

Here's a message listener registrator that bridges a destination for
distributing messages to all the cluster nodes.

\begin{verbatim}
@Component(
    immediate = true,
    service = MyMessageListenerRegistrator.class
)
public class MyMessageListenerRegistrator {
    ...

    @Activate
    protected void activate() {

        _clusterBridgeMessageListener = new ClusterBridgeMessageListener();
        _clusterBridgeMessageListener.setPriority(Priority.LEVEL_5)
        _destination.register(_clusterBridgeMessageListener);
    }

    @Deactivate
    protected void deactivate() {

        _destination.unregister(_clusterBridgeMessageListener );
    }

    @Reference(target = "(destination.name=liferay/live_users)")
    private Destination _destination;

    private MessageListener _clusterBridgeMessageListener;
}
\end{verbatim}

The destination named \texttt{"liferay/live\_users"} is bound to the
\texttt{\_destination} field. The \texttt{activate} method creates a
\texttt{ClusterBridgeMessageListener}, sets its priority queue, and
registers it to the destination. Messages sent to the destination are
distributed across the cluster's JVMs.

The
\href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/portal/kernel/cluster/Priority.html}{\texttt{com.liferay.portal.kernel.cluster.Priority}
class} has ten levels (\texttt{Level\_1} through \texttt{Level\_10},
with \texttt{Level\ 10} being the most important). Each level is a
priority queue for sending messages through the cluster. This is similar
in concept to thread priorities: \texttt{Thread.MIN\_PRIORITY},
\texttt{Thread.MAX\_PRIORITY}, and \texttt{Thread.NORM\_PRIORITY}.

That concludes the tour on sending messages. You've learned how to
create messages, send messages synchronously and asynchronously, and
send messages to a destination in a clustered environment.

\subsection{Related Topics}\label{related-topics-364}

\href{/docs/7-1/tutorials/-/knowledge_base/t/messaging-destinations}{Messaging
Destinations}

\href{/docs/7-1/tutorials/-/knowledge_base/t/message-listeners}{Message
Listeners}
