# Creating Remote Services with Service Builder

In an earlier section of the learning path, you used Service Builder to generate 
the model, persistence, and service layers of your app. The services generated 
by Service Builder come in two flavors: local and remote. Local services, as 
their name implies, can only be invoked locally. This means that they're invoked 
from the JVM in which Liferay is running. Remote services can be invoked 
remotely. They're designed for use by any web client that has permission to 
access them. The remote services generated by Service Builder are published as 
JSON web services when your application is deployed. You can also use Service 
Builder to generate a WSDL (Web Services Description Language) document for your 
remote services to make them available via SOAP (Simple Object Access Protocol). 
For more information, 
[click here](/develop/tutorials/-/knowledge_base/7-0/service-builder-web-services) 
to see the Service Builder Web Services section of tutorials. 

To examine the Liferay web services that are currently available on your portal, 
navigate to `http://[host name]:[port number]/api/jsonws` 
([http://localhost:8080/api/jsonws](http://localhost:8080/api/jsonws) 
if you're running @product@ locally on port 8080). By default, this page lists 
the web service methods in the `portal` context. To view an app's web services, 
select the app's context path in the *Context Path* menu. For example, to view 
the Calendar app's web services, select `calendar` in the *Context Path* menu. 
Once you add remote services to the Guestbook app, you'll be able to access them 
from the app's context path. 

To specify whether Service Builder should generate local services, remote 
services, or both, you must add the appropriate entries to your app's 
`service.xml` file. Open your `guestbook-service` module's `service.xml` file 
and examine the tags for the `Guestbook` and `Entry` entities: 

    <entity name="Guestbook" local-service="true" uuid="true">

    <entity name="Entry" local-service="true" uuid="true">

As described in the `service.xml` 
[DTD](https://docs.liferay.com/ce/portal/7.0-ga3/definitions/), 
`local-service` defaults to `false` and `remote-service` defaults to `true`. 
However, it's best to specify explicitly whether Service Builder should generate 
local and remote services. Other developers who read your `service.xml` file 
might not know or remember the defaults. Therefore, add `remote-service="true"` 
to the entity tags of the `Guestbook` and `Entry` entities: 

    <entity name="Guestbook" local-service="true" remote-service="true" uuid="true">

    <entity name="Entry" local-service="true" remote-service="true" uuid="true">

In the *Gradle Tasks* window on the right-hand side of Liferay IDE, expand your 
service module's build folder. Run Service Builder by double-clicking 
*buildService*. When Service Builder finishes, refresh the `guestbook-api` and 
`guestbook-service` modules in the Project Explorer. 

You're probably wondering what, exactly, Service Builder just did. Recall that 
in an earlier section of Learning Path, you exposed access to the app's 
persistence layer by adding methods to the `*LocalServiceImpl` classes generated 
by Service Builder. In the `guestbook-service` module, these classes are 
`GuestbookLocalServiceImpl` and `EntryLocalServiceImpl`. Service Builder 
generated them initially, but after that didn't touch them. You implemented your 
local service layer in them. Similarly, running Service Builder with 
`remote-service="true"` set on your entities generates `*ServiceImpl` classes in 
which you must implement your remote service layer. In the `guestbook-service` 
module, these classes are `GuestbookServiceImpl` and `EntryServiceImpl`. To get 
remote services working for the Guestbook app, use the following steps: 

1. Create a new class in the `com.liferay.docs.guestbook.util` package called
   `ActionKeys`. Add the following code to this class:

        package com.liferay.docs.guestbook.util;

        public class ActionKeys extends
                        com.liferay.portal.kernel.security.permission.ActionKeys {

                public static final String ADD_ENTRY = "ADD_ENTRY";
                public static final String ADD_GUESTBOOK = "ADD_GUESTBOOK";
        }

    The `ADD_ENTRY` and `ADD_GUESTBOOK` strings are used to reference the 
    permissions that you defined in the `guestbook-service` module's 
    `docroot/WEB-INF/src/resource-actions/default.xml` file in an earlier 
    section of this learning path. It's a best practice to create strings to 
    refer to your permissions in a class called `ActionKeys` that extends 
    `com.liferay.portal.kernel.security.permission.ActionKeys`. The latter 
    `ActionKeys` contains strings that are used to refer to portal permissions. 
    These include strings for common permissions such as `VIEW`, `UPDATE`, 
    `DELETE`, and so on. 

2. Open the `GuestbookServiceImpl` class and add the following methods: 

        public Guestbook addGuestbook(long userId, String name,
            ServiceContext serviceContext) throws SystemException,
            PortalException {

            return guestbookLocalService.addGuestbook(userId, name, serviceContext);
        }

        public Guestbook deleteGuestbook(long guestbookId,
            ServiceContext serviceContext) throws PortalException,
            SystemException {

            return guestbookLocalService.deleteGuestbook(guestbookId, serviceContext);
        }

        public List<Guestbook> getGuestbooks(long groupId) throws SystemException {
                return guestbookLocalService.getGuestbooks(groupId);
        }

        public List<Guestbook> getGuestbooks(long groupId, int start, int end)
                        throws SystemException {
                return guestbookLocalService.getGuestbooks(groupId, start, end);
        }

        public int getGuestbooksCount(long groupId) throws SystemException {
                return guestbookLocalService.getGuestbooksCount();
        }

        public Guestbook updateGuestbook(long userId, long guestbookId,
            String name, ServiceContext serviceContext) throws PortalException,
            SystemException {

            return guestbookLocalService.updateGuestbook(userId, guestbookId,
                name, serviceContext);
        }

    Here, you add a remote service method for each existing guestbook local 
    service method. For now, the remote service method implementations simply 
    call the local service implementations. By @product@ convention, however, 
    permission checking is added in remote service implementations, because 
    users calling those services aren't calling them from the app's UI (which 
    already has permission checks). Since they're bypassing the UI and going 
    directly to the services, you have to check to see if they have permission 
    to access the data they're trying to access before you give it to them. 
    You'll implement permission checking in the next section. For now, you just 
    want to create remote services, confirm that they're accessible, and confirm 
    that they work. 

3. Open the `EntryServiceImpl` class and add the following methods: 

        public Entry addEntry(long userId, long guestbookId, String name,
                String email, String message, ServiceContext serviceContext)
                throws PortalException, SystemException {

            return entryLocalService.addEntry(userId, guestbookId, name, email,
                         message, serviceContext);
        }

        public Entry deleteEntry(long entryId, ServiceContext serviceContext)
                        throws PortalException, SystemException {

            return entryLocalService.deleteEntry(entryId, serviceContext);
        }

        public List<Entry> getEntries(long groupId, long guestbookId)
                        throws SystemException {

            return entryLocalService.getEntries(groupId, guestbookId);
        }

        public List<Entry> getEntries(long groupId, long guestbookId, int start,
                        int end) throws SystemException {

            return entryLocalService.getEntries(groupId, guestbookId, start, end);
        }

        public int getEntriesCount(long groupId, long guestbookId)
                        throws SystemException {

            return entryLocalService.getEntriesCount(groupId, guestbookId);
        }

        public Entry updateEntry(long userId, long guestbookId, long entryId,
                        String name, String email, String message,
                        ServiceContext serviceContext) throws PortalException,
                        SystemException {

            return entryLocalService.updateEntry(userId, guestbookId, entryId,
                                name, email, message, serviceContext);
        }

    Here, you're doing the same thing for guestbook entries that you did for
    guestbooks in step 2. You're creating skeleton remote service methods that 
    correspond to existing local service methods. The remote service methods 
    call the local service methods. You'll add permission checks in the next
    section. 

4. Run Service Builder and redeploy the `guestbook-*` modules. 

Now navigate to @product@'s JSONWS page 
(`http://[host name]:[port number]/api/jsonws`) and click the *Context Path* 
selector. The Guestbook app's context, `gb`, now appears as an option. Select it 
and confirm that your remote service methods appear in the list. 

![Figure 1: After you've added remote service methods to your project's `*ServiceImpl` classes, run Service Builder and redeploy your modules. Then check that your remote services are accessible.](../../../images/jsonws-guestbook.png)

To test that your remote services are working, choose a method to invoke. Pick a 
simple method that does not require a Service Context parameter, like 
`getGuestbooksCount(long groupId)`. To find the appropriate `groupId` (the ID of 
the site containing the Guestbook app), navigate to that site in your browser 
and select *Configuration* &rarr; *Site Settings* from the Site Menu on the 
left. The site ID is listed at the top of the Site Settings page. Now return to 
the JSONWS page and enter the site ID into the group ID field and click 
*Invoke*. Confirm that the correct number of guestbooks is returned. Great! Your
remote web services are working. 

Next, you'll build a WSDD (Web Service Deployment Descriptor) document for your
remote services to make them available via SOAP (Simple Object Access Protocol). 
Follow these steps to do so:

1. In your Liferay workspace's `settings.gradle` file, add imports for 
   `ServiceBuilderPlugin` and `WSDDBuilderPlugin`. Then add the 
   `gradle.beforeProject` closure at the bottom of the file: 

        import com.liferay.gradle.plugins.service.builder.ServiceBuilderPlugin
        import com.liferay.gradle.plugins.wsdd.builder.WSDDBuilderPlugin

        ...

        gradle.beforeProject {
            project ->

            project.plugins.withType(ServiceBuilderPlugin) {
                project.apply plugin: WSDDBuilderPlugin
            }
        }

    Refresh your workspace's Gradle files by right clicking `settings.gradle` in 
    the Project Explorer and then selecting *Gradle* &rarr; *Refresh Gradle 
    Project*. 

2. In the `guestbook-service` module's `build.gradle` file, add the following 
   inside `dependencies{...}`: 

        compileOnly group: "com.liferay", name: "com.liferay.registry.api", version: "1.0.0"
        compileOnly group: "javax.portlet", name: "portlet-api", version: "2.0"
        compileOnly group: "javax.servlet", name: "javax.servlet-api", version: "3.0.1"

3. In the *Gradle Tasks* window on the right-hand side of Liferay IDE, expand 
   your service module's build folder. Build the WSDD by double-clicking 
   *buildWSDD*. 

In the `guestbook-service` module's `build/libs` folder, the WSDD build 
generates `guestbook.service-wsdd-1.0.0.jar`. This JAR file contains the WSDD 
and WSDL files. To access your app's SOAP web services, you must deploy this JAR 
file to your @product@ instance. Do so now by copying and pasting the file into 
your @product@ instance's `deploy` folder. When the deploy completes, navigate 
to `http://[host name]:[port number]/o/guestbook.service/api/axis` in your 
browser to view the Guestbook app's SOAP web services. If you're running 
@product@ locally on port 8080, this is 
[http://localhost:8080/o/guestbook.service/api/axis](http://localhost:8080/o/guestbook.service/api/axis). 

This page contains links to the WSDL (Web Services Description Language) 
documents for the Guestbook and Entry remote service methods. WSDL files 
describe details about the remote service methods, including the type of data 
that these methods handle. 

If you'd like to make your app's services available for remote invocation via 
SOAP, generating WSDD and WSDL files is required. For example, 
[the Liferay Mobile SDK](https://web.liferay.com/community/liferay-projects/liferay-mobile-sdk/overview) 
relies on the WSDD and WSDL to discover your @product@ app's remote services. 
For the Liferay Mobile SDK to create a mobile client that can access your 
@product@ app's web services, you must therefore generate a WSDD and WSDL for 
your app. 

Next, you'll learn how to secure your web services. Unless you secure your web
services by implementing permission checks, any user can add, update, or delete
guestbooks or guestbook entries, and you certainly don't want that. 
